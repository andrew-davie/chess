------- FILE ./chess.asm LEVEL 1 PASS 4
      1  7c00 ????						; Chess
      2  7c00 ????						; Atari 2600 Chess display system
      3  7c00 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  7c00 ????						; andrew@taswegian.com
      5  7c00 ????
      6  7c00 ????
      7  7c00 ????	       00 40	   TIA_BASE_ADDRESS =	$40
      8  7c00 ????
      9  7c00 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 4
      0  7c00 ????				      include	"vcs.h"
      1  7c00 ????						; VCS.H
      2  7c00 ????						; Version 1.05, 13/November/2003
      3  7c00 ????
      4  7c00 ????	       00 69	   VERSION_VCS =	105
      5  7c00 ????
      6  7c00 ????						; This file defines hardware registers and memory mapping for the
      7  7c00 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  7c00 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  7c00 ????						; available at at http://www.atari2600.org/dasm
     10  7c00 ????						;
     11  7c00 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  7c00 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  7c00 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  7c00 ????						; with your views.  Please contribute, if you think you can improve this
     15  7c00 ????						; file!
     16  7c00 ????						;
     17  7c00 ????						; Latest Revisions...
     18  7c00 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  7c00 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  7c00 ????						;			    This will allow conditional code to verify VCS.H being
     21  7c00 ????						;			    used for code assembly.
     22  7c00 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  7c00 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  7c00 ????						;			 mirrored reading/writing differences.	This is more a
     25  7c00 ????						;			 readability issue, and binary compatibility with disassembled
     26  7c00 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  7c00 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  7c00 ????						;			 which was broken by the use of segments in this file, as
     29  7c00 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  7c00 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  7c00 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  7c00 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  7c00 ????						;						   it is safe to leave it undefined, and the base address will
     34  7c00 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  7c00 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  7c00 ????						;			  - register definitions are now generated through assignment
     37  7c00 ????						;			    in uninitialised segments.	This allows a changeable base
     38  7c00 ????						;			    address architecture.
     39  7c00 ????						; 1.0	22/MAR/2003		Initial release
     40  7c00 ????
     41  7c00 ????
     42  7c00 ????						;-------------------------------------------------------------------------------
     43  7c00 ????
     44  7c00 ????						; TIA_BASE_ADDRESS
     45  7c00 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  7c00 ????						; Normally 0, the base address should (externally, before including this file)
     47  7c00 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  7c00 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  7c00 ????						; < $40 as a bankswitch.
     50  7c00 ????
     51  7c00 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  7c00 ????			  -TIA_BASE_ADDRESS =	0
     53  7c00 ????				      ENDIF
     54  7c00 ????
     55  7c00 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  7c00 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  7c00 ????						; *OR* by declaring the label before including this file, eg:
     58  7c00 ????						; TIA_BASE_ADDRESS = $40
     59  7c00 ????						;   include "vcs.h"
     60  7c00 ????
     61  7c00 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  7c00 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  7c00 ????						; for the mirrored ROM hardware registers.
     64  7c00 ????
     65  7c00 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  7c00 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  7c00 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  7c00 ????
     69  7c00 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  7c00 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  7c00 ????				      ENDIF
     72  7c00 ????
     73  7c00 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  7c00 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  7c00 ????				      ENDIF
     76  7c00 ????
     77  7c00 ????						;-------------------------------------------------------------------------------
     78  7c00 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE macro.h LEVEL 2 PASS 4
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE piece_defines.h LEVEL 2 PASS 4
      0  0000 ????				      include	"piece_defines.h"
      1  0000 ????						; Copyright (C)2020 Andrew Davie
      2  0000 ????
      3  0000 ????	       00 80	   BLACK      =	128
      4  0000 ????	       00 00	   WHITE      =	0
      5  0000 ????
      6  0000 ????	       00 80	   FLAG_COLOUR =	128	; mask
      7  0000 ????	       00 40	   FLAG_MOVED =	64	; mark ALL pieces when moved. Used for castling
      8  0000 ????						; but maybe useful for evaluation of development
      9  0000 ????	       00 20	   FLAG_ENPASSANT =	32
     10  0000 ????	       00 10	   FLAG_CASTLE =	16
     11  0000 ????
     12  0000 ????						;---------------------------------------------------------------------------------------------------
     13  0000 ????						; DEFINE THE PIECES
     14  0000 ????						; ID lives in bits 0-2
     15  0000 ????
     16  0000 ????	       00 00	   BLANK      =	0
     17  0000 ????	       00 00	   ███  =	BLANK
     18  0000 ????
     19  0000 ????	       00 01	   WPAWN      =	1
     20  0000 ????	       00 01	   WP	      =	WPAWN
     21  0000 ????	       00 02	   BPAWN      =	2
     22  0000 ????	       00 02	   BP	      =	BPAWN
     23  0000 ????	       00 03	   KNIGHT     =	3
     24  0000 ????	       00 03	   N	      =	KNIGHT
     25  0000 ????	       00 04	   BISHOP     =	4
     26  0000 ????	       00 04	   B	      =	BISHOP
     27  0000 ????	       00 05	   ROOK       =	5
     28  0000 ????	       00 05	   R	      =	ROOK
     29  0000 ????	       00 06	   QUEEN      =	6
     30  0000 ????	       00 06	   Q	      =	QUEEN
     31  0000 ????	       00 07	   KING       =	7
     32  0000 ????	       00 07	   K	      =	KING
     33  0000 ????
     34  0000 ????	       00 0f	   PIECE_MASK =	15	; trim off the flags leaving just piece ID
     35  0000 ????
     36  0000 ????						;---------------------------------------------------------------------------------------------------
     37  0000 ????
     38  0000 ????						; Movements
     39  0000 ????
     40  0000 ????	       00 0a	   _UP	      =	10	; up
     41  0000 ????	       ff ff ff ff _LEFT      =	-1	; left
     42  0000 ????	       ff ff ff f6 _DOWN      =	-10	; down
     43  0000 ????	       00 01	   _RIGHT     =	1	; right
     44  0000 ????
     45  0000 ????						; EOF
------- FILE ./chess.asm
     13  0000 ????
     14  0000 ????	       00 00	   VERBOSE    =	0	; set to 1 for compile messages
     15  0000 ????
     16  0000 ????			   ORIGIN     SET	0
     17  0000 ????			   ORIGIN_RAM SET	0
     18  0000 ????
     19  0000 ????						;include "segtime.asm"
     20  0000 ????
     21  0000 ????
     22  0000 ????	       00 00	   _FIRST_BANK =	0	; 3E+ 1st bank holds reset vectors
     23  0000 ????
     24  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     25  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     26  0000 ????						;FIXED_BANK		 = 15 * 2048	       ; ->> 32K
     27  0000 ????						;FIXED_BANK		 = 31 * 2048	       ; ->> 64K
     28  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     29  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     30  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     31  0000 ????
     32  0000 ????	       00 01	   YES	      =	1
     33  0000 ????	       00 00	   NO	      =	0
     34  0000 ????	       00 40	   HUMAN      =	64
     35  0000 ????
     36  0000 ????	       70 00	   INFINITY   =	$7000	;32767
     37  0000 ????
     38  0000 ????
     39  0000 ????						; assemble diagnostics. Remove for release.
     40  0000 ????
     41  0000 ????	       00 00	   TEST_POSITION =	0	; 0=normal, 1 = setup test position
     42  0000 ????	       00 01	   DIAGNOSTICS =	1
     43  0000 ????	       00 01	   QUIESCENCE =	1
     44  0000 ????	       00 00	   ASSERTS    =	0
     45  0000 ????	       00 00	   PVSP       =	0	; player versus player =1
     46  0000 ????	       00 01	   ENPASSANT_ENABLED =	1
     47  0000 ????	       00 01	   CASTLING_ENABLED =	1
     48  0000 ????
     49  0000 ????
     50  0000 ????	       00 02	   SELECT_SWITCH =	2	; (SWCHB & SELECT_SWITCH)  0 == PRESSED
     51  0000 ????
     52  0000 ????
     53  0000 ????						; NOTE: SEARCH_DEPTH cannot be < 3, because the player's moves are generated from PLY+1, and use
     54  0000 ????						; PLY+2 for computer response (thus, 3). The bank allocation gets stomped!
     55  0000 ????
     56  0000 ????
     57  0000 ????	       00 03	   SEARCH_DEPTH =	3
     58  0000 ????	       00 06	   QUIESCE_EXTRA_DEPTH =	6
     59  0000 ????
     60  0000 ????
     61  0000 ????			  -	      IF	SEARCH_DEPTH < 3
     62  0000 ????			  -	      ECHO	"ERROR: Search depth must be >= 3"
     63  0000 ????			  -	      ERR
     64  0000 ????				      ENDIF
     65  0000 ????
     66  0000 ????
     67  0000 ????
     68  0000 ????	       00 09	   PLY_BANKS  =	SEARCH_DEPTH + QUIESCE_EXTRA_DEPTH
     69  0000 ????	       00 09	   MAX_PLY_DEPTH_BANK =	PLY_BANKS	;TODO -- RAMBANK_PLY + PLY_BANKS
     70  0000 ????
     71  0000 ????						;IF RAMBANK_PLY + MAX_PLY_DEPTH_BANK > 31
     72  0000 ????						;    ERR "Not enough RAM for PLY banks"
     73  0000 ????						;ENDIF
     74  0000 ????
     75  0000 ????
     76  0000 ????
     77  0000 ????
     78  0000 ????	       00 80	   SWAP_SIDE  =	128	;TODO + (RAMBANK_PLY ^ (RAMBANK_PLY+1))
     79  0000 ????
     80  0000 ????
     81  0000 ????
     82  0000 ????						; DELAYS
     83  0000 ????
     84  0000 ????	       00 0a	   READY_TO_MOVE_FLASH =	10
     85  0000 ????
     86  0000 ????						;===================================
     87  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     88  0000 ????						;===================================
     89  0000 ????
     90  0000 ????						;-------------------------------------------------------------------------------
     91  0000 ????						; The following are optional YES/NO depending on phase of the moon
     92  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     93  0000 ????						;-------------------------------------------------------------------------------
     94  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     95  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     96  0000 ????			  -	      IF	FINAL_VERSION = YES
     97  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     98  0000 ????				      ENDIF
     99  0000 ????
    100  0000 ????						;-------------------------------------------------------------------------------
    101  0000 ????
    102  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
    103  0000 ????
    104  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
    105  0000 ????
    106  0000 ????						;------------------------------------------------------------------------------
    107  0000 ????
    108  0000 ????	       00 01	   PLUSCART   =	YES
    109  0000 ????
    110  0000 ????						;------------------------------------------------------------------------------
    111  0000 ????
    112  0000 ????
    113  0000 ????	       00 08	   CHESSBOARD_ROWS =	8	; number of ROWS of chessboard
    114  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    115  0000 ????	       00 48	   PIECE_SHAPE_SIZE =	72	; 3 PF bytes x 24 scanlines
    116  0000 ????
    117  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    118  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    119  0000 ????
    120  0000 ????
    121  0000 ????	       04 00	   RAM_SIZE   =	$400	; address space for write AND read
    122  0000 ????	       02 00	   RAM_WRITE  =	$200	; add this to RAM address when doing writes
    123  0000 ????	       02 00	   RAM	      =	RAM_WRITE
    124  0000 ????
    125  0000 ????	       04 00	   _ROM_BANK_SIZE =	$400
    126  0000 ????	       02 00	   _RAM_BANK_SIZE =	$200
    127  0000 ????
    128  0000 ????
    129  0000 ????						; Platform constants:
    130  0000 ????	       00 02	   PAL	      =	%10
    131  0000 ????	       00 02	   PAL_50     =	PAL|0
    132  0000 ????	       00 03	   PAL_60     =	PAL|1
    133  0000 ????
    134  0000 ????
    135  0000 ????				      IF	L276
    136  0000 ????	       00 30	   VBLANK_TIM_NTSC =	48	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    137  0000 ????			  -	      ELSE
    138  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    139  0000 ????				      ENDIF
    140  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    141  0000 ????
    142  0000 ????				      IF	L276
    143  0000 ????	       00 23	   OVERSCAN_TIM_NTSC =	35	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    144  0000 ????			  -	      ELSE
    145  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    146  0000 ????				      ENDIF
    147  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    148  0000 ????
    149  0000 ????				      IF	L276
    150  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    151  0000 ????			  -	      ELSE
    152  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    153  0000 ????				      ENDIF
    154  0000 ????	       01 38	   SCANLINES_PAL =	312
    155  0000 ????
    156  0000 ????
    157  0000 ????	       00 2e	   TIME_PART_2 =	46
    158  0000 ????	       00 2e	   TIME_PART_1 =	46
    159  0000 ????
    160  0000 ????
    161  0000 ????	       00 00	   SLOT0      =	0
    162  0000 ????	       00 40	   SLOT1      =	64
    163  0000 ????	       00 80	   SLOT2      =	128
    164  0000 ????	       00 c0	   SLOT3      =	192
    165  0000 ????
    166  0000 ????						;------------------------------------------------------------------------------
    167  0000 ????						; MACRO definitions
    168  0000 ????
    169  0000 ????
    170  0000 ????
    171  0000 ????				      MAC	rombank
    172  0000 ????				      SEG	{1}
    173  0000 ????				      ORG	_ORIGIN
    174  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    175  0000 ????			   _BANK_START SET	*
    176  0000 ????			   {1}_START  SET	*
    177  0000 ????			   _CURRENT_BANK SET	_ORIGIN/1024
    178  0000 ????			   {1}	      SET	_BANK_SLOT + _CURRENT_BANK
    179  0000 ????			   _ORIGIN    SET	_ORIGIN + 1024
    180  0000 ????				      ENDM		; bank name
    181  0000 ????
    182  0000 ????						;	      MAC DEFINE_1K_SEGMENT ; {seg name}
    183  0000 ????						;		  ALIGN $400
    184  0000 ????						;SEGMENT_{1}	  SET *
    185  0000 ????						;BANK_{1}	  SET _CURRENT_BANK
    186  0000 ????						;	      ENDM
    187  0000 ????
    188  0000 ????				      MAC	check_bank_size
    189  0000 ????			   .TEMP      =	* - _BANK_START
    190  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
    191  0000 ????				      IF	( .TEMP ) > _ROM_BANK_SIZE
    192  0000 ????				      ECHO	"BANK OVERFLOW @ ", {1}, " size=", * - ORIGIN
    193  0000 ????				      ERR
    194  0000 ????				      ENDIF
    195  0000 ????				      ENDM		; name
    196  0000 ????
    197  0000 ????				      MAC	check_ram_bank_size
    198  0000 ????			   .TEMP      =	* - _BANK_START
    199  0000 ????				      ECHO	{1}, "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
    200  0000 ????				      IF	( .TEMP ) > _RAM_BANK_SIZE
    201  0000 ????				      ECHO	"BANK OVERFLOW @ ", {1}, " size=", * - ORIGIN
    202  0000 ????				      ERR
    203  0000 ????				      ENDIF
    204  0000 ????				      ENDM		; name
    205  0000 ????
    206  0000 ????						;---------------------------------------------------------------------------------------------------
    207  0000 ????
    208  0000 ????						; Macro inserts a page break if the object would overlap a page
    209  0000 ????
    210  0000 ????				      MAC	optional_pagebreak
    211  0000 ????				      LIST	OFF
    212  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    213  0000 ????			   EARLY_LOCATION SET	*
    214  0000 ????				      ALIGN	256
    215  0000 ????				      IF	VERBOSE=1
    216  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR", {1}
    217  0000 ????				      ECHO	"REQUESTED SIZE =", {2}
    218  0000 ????				      ECHO	"WASTED SPACE =", *-EARLY_LOCATION
    219  0000 ????				      ECHO	"PAGEBREAK LOCATION =", *
    220  0000 ????				      ENDIF
    221  0000 ????				      ENDIF
    222  0000 ????				      LIST	ON
    223  0000 ????				      ENDM		; { string, size }
    224  0000 ????
    225  0000 ????
    226  0000 ????				      MAC	check_page_crossing
    227  0000 ????				      LIST	OFF
    228  0000 ????				      IF	( >BLOCK_END != >BLOCK_START )
    229  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    230  0000 ????				      ENDIF
    231  0000 ????				      LIST	ON
    232  0000 ????				      ENDM
    233  0000 ????
    234  0000 ????				      MAC	checkpage
    235  0000 ????				      LIST	OFF
    236  0000 ????				      IF	>. != >{1}
    237  0000 ????				      ECHO	""
    238  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    239  0000 ????				      ECHO	""
    240  0000 ????				      ERR
    241  0000 ????				      ENDIF
    242  0000 ????				      LIST	ON
    243  0000 ????				      ENDM
    244  0000 ????
    245  0000 ????				      MAC	checkpagex
    246  0000 ????				      LIST	OFF
    247  0000 ????				      IF	>. != >{1}
    248  0000 ????				      ECHO	""
    249  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    250  0000 ????				      ECHO	{2}
    251  0000 ????				      ECHO	""
    252  0000 ????				      ERR
    253  0000 ????				      ENDIF
    254  0000 ????				      LIST	ON
    255  0000 ????				      ENDM
    256  0000 ????
    257  0000 ????						;---------------------------------------------------------------------------------------------------
    258  0000 ????
    259  0000 ????						; Defines a variable of the given size, making sure it doesn't cross a page
    260  0000 ????				      MAC	variable
    261  0000 ????				      OPTIONAL_PAGEBREAK	"Variable", {2}
    262  0000 ????			   {1}	      ds	{2}
    263  0000 ????				      ENDM		; {name, size}
    264  0000 ????
    265  0000 ????
    266  0000 ????						;---------------------------------------------------------------------------------------------------
    267  0000 ????
    268  0000 ????				      MAC	def
    269  0000 ????			   SLOT_{1}   SET	_BANK_SLOT
    270  0000 ????			   BANK_{1}   SET	SLOT_{1} + _CURRENT_BANK	; bank in which this subroutine resides
    271  0000 ????			   {1}			; entry point
    272  0000 ????			   TEMPORARY_VAR SET	Overlay
    273  0000 ????			   TEMPORARY_OFFSET SET	0
    274  0000 ????			   VAR_BOUNDARY_{1} SET	TEMPORARY_OFFSET
    275  0000 ????			   FUNCTION_NAME SET	{1}
    276  0000 ????				      ENDM		; name of subroutine
    277  0000 ????
    278  0000 ????
    279  0000 ????						;---------------------------------------------------------------------------------------------------
    280  0000 ????
    281  0000 ????				      MAC	allocate
    282  0000 ????				      OPTIONAL_PAGEBREAK	"Table", {2}
    283  0000 ????				      DEF	{1}
    284  0000 ????				      ENDM
    285  0000 ????
    286  0000 ????						;---------------------------------------------------------------------------------------------------
    287  0000 ????
    288  0000 ????				      MAC	slot
    289  0000 ????				      IF	({1} < 0) || ({1} > 3)
    290  0000 ????				      ECHO	"Illegal bank address/segment location", {1}
    291  0000 ????				      ERR
    292  0000 ????				      ENDIF
    293  0000 ????			   _BANK_ADDRESS_ORIGIN SET	$F000 + ({1} * _ROM_BANK_SIZE)
    294  0000 ????			   _BANK_SLOT SET	{1} * 64	; D7/D6 selector
    295  0000 ????				      ENDM		; {1}
    296  0000 ????
    297  0000 ????
    298  0000 ????						;---------------------------------------------------------------------------------------------------
    299  0000 ????
    300  0000 ????				      MAC	negeval
    301  0000 ????
    302  0000 ????				      sec
    303  0000 ????				      lda	#0
    304  0000 ????				      sbc	Evaluation
    305  0000 ????				      sta	Evaluation
    306  0000 ????				      lda	#0
    307  0000 ????				      sbc	Evaluation+1
    308  0000 ????				      sta	Evaluation+1
    309  0000 ????				      ENDM
    310  0000 ????
    311  0000 ????
    312  0000 ????				      MAC	swap
    313  0000 ????				      lda	sideToMove
    314  0000 ????				      eor	#SWAP_SIDE|HUMAN
    315  0000 ????				      sta	sideToMove
    316  0000 ????
    317  0000 ????						;NEGEVAL
    318  0000 ????				      ENDM
    319  0000 ????
    320  0000 ????
    321  0000 ????						;---------------------------------------------------------------------------------------------------
    322  0000 ????
    323  0000 ????			   TEMPORARY_OFFSET SET	0
    324  0000 ????
    325  0000 ????
    326  0000 ????				      MAC	vend
    327  0000 ????				      IFNCONST	{1}
    328  0000 ????				      ECHO	"Incorrect VEND label", {1}
    329  0000 ????				      ERR
    330  0000 ????				      ENDIF
    331  0000 ????			   VAREND_{1} =	TEMPORARY_VAR
    332  0000 ????				      ENDM		; {1}
    333  0000 ????
    334  0000 ????
    335  0000 ????				      MAC	refer
    336  0000 ????				      IF	VAREND_{1} > TEMPORARY_VAR
    337  0000 ????			   TEMPORARY_VAR SET	VAREND_{1}
    338  0000 ????				      ENDIF
    339  0000 ????				      ENDM		; {1}
    340  0000 ????
    341  0000 ????
    342  0000 ????
    343  0000 ????						; Define a temporary variable for use in a subroutine
    344  0000 ????						; Will allocate appropriate bytes, and also check for overflow of the available overlay buffer
    345  0000 ????
    346  0000 ????				      MAC	var
    347  0000 ????			   {1}	      =	TEMPORARY_VAR
    348  0000 ????			   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + {2}
    349  0000 ????
    350  0000 ????			   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
    351  0000 ????				      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
    352  0000 ????			   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
    353  0000 ????				      ENDIF
    354  0000 ????				      IF	OVERLAY_DELTA > OVERLAY_SIZE
    355  0000 ????				      ECHO	"Temporary Variable", {1}, "overflow!"
    356  0000 ????				      ERR
    357  0000 ????				      ENDIF
    358  0000 ????				      LIST	ON
    359  0000 ????				      ENDM		; { name, size }
    360  0000 ????
    361  0000 ????
    362  0000 ????						;---------------------------------------------------------------------------------------------------
    363  0000 ????
    364  0000 ????				      MAC	tag
    365  0000 ????						; {0}
    366  0000 ????				      ENDM		; {ident/tag}
    367  0000 ????
    368  0000 ????						;---------------------------------------------------------------------------------------------------
    369  0000 ????
    370  0000 ????				      MAC	sta@ram
    371  0000 ????				      sta	[RAM]+{0}
    372  0000 ????				      ENDM		;{}
    373  0000 ????
    374  0000 ????				      MAC	stx@ram
    375  0000 ????				      stx	[RAM]+{0}
    376  0000 ????				      ENDM
    377  0000 ????
    378  0000 ????				      MAC	sty@ram
    379  0000 ????				      sty	[RAM]+{0}
    380  0000 ????				      ENDM
    381  0000 ????
    382  0000 ????				      MAC	sta@ply
    383  0000 ????				      sta	[RAM]+{0}
    384  0000 ????				      ENDM		;{}
    385  0000 ????
    386  0000 ????				      MAC	stx@ply
    387  0000 ????				      stx	[RAM]+{0}
    388  0000 ????				      ENDM
    389  0000 ????
    390  0000 ????				      MAC	sty@ply
    391  0000 ????				      sty	[RAM]+{0}
    392  0000 ????				      ENDM
    393  0000 ????
    394  0000 ????
    395  0000 ????				      MAC	lda@ram
    396  0000 ????				      lda	{0}
    397  0000 ????				      ENDM		;{}
    398  0000 ????
    399  0000 ????				      MAC	ldx@ram
    400  0000 ????				      ldx	{0}
    401  0000 ????				      ENDM		;{}
    402  0000 ????
    403  0000 ????				      MAC	ldy@ram
    404  0000 ????				      ldy	{0}
    405  0000 ????				      ENDM		;{}
    406  0000 ????
    407  0000 ????
    408  0000 ????				      MAC	lda@ply
    409  0000 ????				      lda	{0}
    410  0000 ????				      ENDM		;{}
    411  0000 ????
    412  0000 ????				      MAC	ldx@ply
    413  0000 ????				      ldx	{0}
    414  0000 ????				      ENDM		;{}
    415  0000 ????
    416  0000 ????				      MAC	ldy@ply
    417  0000 ????				      ldy	{0}
    418  0000 ????				      ENDM		;{}
    419  0000 ????
    420  0000 ????
    421  0000 ????				      MAC	adc@ply
    422  0000 ????				      adc	{0}
    423  0000 ????				      ENDM		;{}
    424  0000 ????
    425  0000 ????				      MAC	sbc@ply
    426  0000 ????				      sbc	{0}
    427  0000 ????				      ENDM		;{}
    428  0000 ????
    429  0000 ????				      MAC	cmp@ply
    430  0000 ????				      cmp	{0}
    431  0000 ????				      ENDM		;{}
    432  0000 ????
    433  0000 ????						;---------------------------------------------------------------------------------------------------
    434  0000 ????
    435  0000 ????				      MAC	newrambank
    436  0000 ????						; {1}	     bank name
    437  0000 ????						; {2}	     RAM bank number
    438  0000 ????
    439  0000 ????				      SEG.U	{1}
    440  0000 ????				      ORG	ORIGIN_RAM
    441  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    442  0000 ????			   _BANK_START SET	*
    443  0000 ????			   RAMBANK_{1} SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
    444  0000 ????			   _CURRENT_RAMBANK SET	RAMBANK_{1}
    445  0000 ????			   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    446  0000 ????				      ENDM		; bank name
    447  0000 ????
    448  0000 ????
    449  0000 ????
    450  0000 ????				      MAC	set_platform
    451  0000 ????						; 00 = NTSC
    452  0000 ????						; 01 = NTSC
    453  0000 ????						; 10 = PAL-50
    454  0000 ????						; 11 = PAL-60
    455  0000 ????				      lda	SWCHB
    456  0000 ????				      rol
    457  0000 ????				      rol
    458  0000 ????				      rol
    459  0000 ????				      and	#%11
    460  0000 ????				      eor	#PAL
    461  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    462  0000 ????				      ENDM
    463  0000 ????
    464  0000 ????
    465  0000 ????						;---------------------------------------------------------------------------------------------------
    466  0000 ????
    467  0000 ????						;    MAC JSROM_SAFE ; {routine}
    468  0000 ????						;    ; Saves bank of routine to variable for later restore.
    469  0000 ????						;    ; Switches to the bank and does a JSR to the routine.
    470  0000 ????
    471  0000 ????						;		  lda #BANK_{1}
    472  0000 ????						;		  sta savedBank
    473  0000 ????						;		  sta SET_BANK
    474  0000 ????						;		  jsr {1}
    475  0000 ????						;    ENDM
    476  0000 ????
    477  0000 ????
    478  0000 ????						;    MAC JSROM ; {routine}
    479  0000 ????
    480  0000 ????						;		  lda #BANK_{1}
    481  0000 ????						;		  sta SET_BANK
    482  0000 ????						;		  jsr {1}
    483  0000 ????						;    ENDM
    484  0000 ????
    485  0000 ????
    486  0000 ????						;    MAC JSRAM
    487  0000 ????						;		  lda #BANK_{1}
    488  0000 ????						;		  sta SET_BANK_RAM
    489  0000 ????						;		  jsr {1}
    490  0000 ????						;    ENDM
    491  0000 ????
    492  0000 ????
    493  0000 ????
    494  0000 ????				      MAC	timecheck
    495  0000 ????				      lda	INTIM
    496  0000 ????				      cmp	#SPEEDOF_{1}
    497  0000 ????				      bcc	{2}
    498  0000 ????				      ENDM		; {ident}, {branch if out of time}
    499  0000 ????
    500  0000 ????
    501  0000 ????				      MAC	timing
    502  0000 ????			   SPEEDOF_{1} =	({2}/64) + 1
    503  0000 ????				      ENDM		; {label}, {cycles}
    504  0000 ????
    505  0000 ????
    506  0000 ????						;---------------------------------------------------------------------------------------------------
    507  0000 ????
    508  0000 ????						; Failsafe call of function in another bank
    509  0000 ????						; This will check the slot #s for current, call to make sure they're not the same!
    510  0000 ????
    511  0000 ????				      MAC	call
    512  0000 ????				      IF	SLOT_{1} == _BANK_SLOT
    513  0000 ????				      ECHO	"ERROR: Incompatible call to function requiring same slot..."
    514  0000 ????				      ECHO	"Cannot switch bank in use for", {0}
    515  0000 ????				      ERR
    516  0000 ????				      ENDIF
    517  0000 ????				      lda	#BANK_{1}
    518  0000 ????				      sta	SET_BANK
    519  0000 ????				      jsr	{1}
    520  0000 ????				      ENDM		; function name
    521  0000 ????
    522  0000 ????
    523  0000 ????
    524  0000 ????						;---------------------------------------------------------------------------------------------------
    525  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						; Chess
      2  0000 ????						; Atari 2600 Chess display system
      3  0000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  0000 ????						; andrew@taswegian.com
      5  0000 ????
      6 U00ff ????				      SEG.U	variables
      7 U0080					      ORG	$80
      8 U0080
      9 U0080		       00	   squareToDraw ds	1
     10 U0081		       00	   rnd	      ds	1	; random
     11 U0082		       00	   drawDelay  ds	1
     12 U0083		       00	   lastSquareX12 ds	1
     13 U0084
     14 U0084		       00	   drawCount  ds	1
     15 U0085		       00	   fromX12    ds	1
     16 U0086		       00	   toX12      ds	1
     17 U0087		       00	   originX12  ds	1
     18 U0088
     19 U0088		       00	   cursorX12  ds	1
     20 U0089
     21 U0089		       00	   mdelay     ds	1
     22 U008a		       00	   ccur       ds	1
     23 U008b		       00	   aiState    ds	1	; state
     24 U008c		       00	   aiFlashDelay ds	1
     25 U008d
     26 U008d		       00	   aiMoveIndex ds	1
     27 U008e
     28 U008e		       00	   aiFlashPhase ds	1
     29 U008f
     30 U008f		       00 00	   Evaluation ds	2	; tracks value of the board position
     31 U0091
     32 U0091		       00	   currentPiece ds	1
     33 U0092		       00	   currentSquare ds	1
     34 U0093		       00	   enPassantPawn ds	1	; TODO - this belongs in PLY bank
     35 U0094		       00	   currentPly ds	1
     36 U0095
     37 U0095		       00	   sideToMove ds	1	; d7 == side, 0=white, 128 = black
     38 U0096		       00	   fromPiece  ds	1
     39 U0097		       00	   lastPiece  ds	1
     40 U0098		       00	   previousPiece ds	1
     41 U0099
     42 U0099							;Platform			  ds 1		      ; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     43 U0099		       00 00	   speech_addr ds	2
     44 U009b							;bg				  ds 1
     45 U009b
     46 U009b		       00	   capture    ds	1
     47 U009c
     48 U009c					      IF	DIAGNOSTICS
     49 U009c		       00 00 00    positionCount ds	3
     50 U009f					      ENDIF
     51 U009f
     52 U009f							;maxPly			  ds 1
     53 U009f		       00	   flagCheck  ds	1	; -1 = no, #KING = yes
     54 U00a0		       00	   protecting ds	1
     55 U00a1		       00	   randomness ds	1
     56 U00a2		       00 00	   __psb      ds	2
     57 U00a4
     58 U00a4		       00 00	   vkSquare   ds	2	; current move's king traversal squares during castling
     59 U00a6		       00	   human      ds	1	; colour of human
------- FILE ./chess.asm
------- FILE overlays.asm LEVEL 2 PASS 4
      0 U00a7					      include	"overlays.asm"
      1 U00a7							; Chess
      2 U00a7							; Atari 2600 Chess display system
      3 U00a7							; Copyright (c) 2019-2020 Andrew Davie
      4 U00a7							; andrew@taswegian.com
      5 U00a7
      6 U00a7							;---------------------------------------------------------------------------------------------------
      7 U00a7							; OVERLAYS!
      8 U00a7							; These variables are overlays, and should be managed with care
      9 U00a7							; They co-exist (each "OVERLAY" starts at the zero-page variable "Overlay"
     10 U00a7							; and thus, overlays cannot be used at the same time (that is, you cannot
     11 U00a7							; use a variable in overlay #1 while at the same time using a variable in
     12 U00a7							; overlay #2
     13 U00a7
     14 U00a7							; for clarity, prefix ALL overlay variables with double-underscore (__)
     15 U00a7
     16 U00a7							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
     17 U00a7							; ensure this by using the VALIDATE_OVERLAY macro
     18 U00a7							;---------------------------------------------------------------------------------------------------
     19 U00a7
     20 U00a7					      MAC	overlay
     21 U00a7				   OVERLAY_NAME SET	{1}
     22 U00a7					      SEG.U	OVERLAY_{1}
     23 U00a7					      org	Overlay
     24 U00a7					      ENDM		; {name}
     25 U00a7
     26 U00a7							;---------------------------------------------------------------------------------------------------
     27 U00a7
     28 U00a7					      MAC	validate_overlay
     29 U00a7					      LIST	OFF
     30 U00a7				   OVERLAY_DELTA SET	* - Overlay
     31 U00a7					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
     32 U00a7				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
     33 U00a7					      ENDIF
     34 U00a7					      IF	OVERLAY_DELTA > OVERLAY_SIZE
     35 U00a7					      ECHO	"Overlay", OVERLAY_NAME, "is too big!"
     36 U00a7					      ECHO	"REQUIRED SIZE =", OVERLAY_DELTA
     37 U00a7					      ERR
     38 U00a7					      ENDIF
     39 U00a7					      LIST	ON
     40 U00a7					      ECHO	OVERLAY_NAME, "-", OVERLAY_SIZE - ( * - Overlay ), "bytes available"
     41 U00a7					      ENDM
     42 U00a7
     43 U00a7							;---------------------------------------------------------------------------------------------------
     44 U00a7
     45 U00a7				   OVERLAY_SIZE SET	$4C	; maximum size
     46 U00a7				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	0
     47 U00a7
     48 U00a7
     49 U00a7							; This overlay variable is used for the overlay variables.  That's OK.
     50 U00a7							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
     51 U00a7							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
     52 U00a7							; (especially the latter ones) are only used in rare occasions.
     53 U00a7
     54 U00a7							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
     55 U00a7							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
     56 U00a7
      0 U00a7					      DEF	Overlay
      1 U00a7				   SLOT_Overlay SET	_BANK_SLOT
      2 U00a7				   BANK_Overlay SET	SLOT_Overlay + _CURRENT_BANK
      3 U00a7				   Overlay
      4 U00a7				   TEMPORARY_VAR SET	Overlay
      5 U00a7				   TEMPORARY_OFFSET SET	0
      6 U00a7				   VAR_BOUNDARY_Overlay SET	TEMPORARY_OFFSET
      7 U00a7				   FUNCTION_NAME SET	Overlay
     58 U00a7		       00 00 00 00*	      ds	OVERLAY_SIZE	;--> overlay (share) variables
     59 U00f3				   END_OF_OVERLAY
     60 U00f3
     61 U00f3							;---------------------------------------------------------------------------------------------------
     62 U00f3							; And now... the overlays....
     63 U00f3
 ---- OVERLAYS ( $4c bytes ) ----
     64 U00f3					      ECHO	"---- OVERLAYS (", OVERLAY_SIZE, "bytes ) ----"
     65 U00f3
     66 U00f3							;---------------------------------------------------------------------------------------------------
     67 U00f3
     68 U00f3		       00 a7	   __pieceShapeBuffer =	Overlay	; size = PIECE_SHAPE_SIZE
     69 U00f3
     70 U00f3							;---------------------------------------------------------------------------------------------------
     71 U00f3
     72 U00f3
     73 U00f3					      ORG	END_OF_OVERLAY
 ---- END OF OVERLAYS ----
     74 U00f3					      ECHO	"---- END OF OVERLAYS ----"
 MAXIMUM OVERLAY SIZE NEEDED =  $0
     75 U00f3					      ECHO	"MAXIMUM OVERLAY SIZE NEEDED = ", MAXIMUM_REQUIRED_OVERLAY_SIZE
     76 U00f3
     77 U00f3							;EOF
------- FILE ./chess.asm
------- FILE stack.asm LEVEL 2 PASS 4
      0 U00f3					      include	"stack.asm"
      1 U00f3							; Chess
      2 U00f3							; Atari 2600 Chess display system
      3 U00f3							; Copyright (c) 2019-2020 Andrew Davie
      4 U00f3							; andrew@taswegian.com
      5 U00f3
      6 U00f3
      7 U00f3		       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
      8 U00f3
      9 U00f3		       00 00 00 00*	      ds	RESERVED_FOR_STACK
     10 U00ff
     11 U00ff							; WARNING/NOTE - the alphabeta search violates the above size constraints
     12 U00ff							; HOWEVER, the "OVERLAY" segment is beneath this, and will be stomped, depending on # plys
     13 U00ff							;  but since overlay is not generally stressed during alphabeta, we're good.
     14 U00ff
     15 U00ff							; Ensure there isn't any stomping of stack/overlay excess usage
     16 U00ff
 Overlay boundary:  $a7
     17 U00ff					      ECHO	"Overlay boundary: ", Overlay + MAXIMUM_REQUIRED_OVERLAY_SIZE
 Stack boundary:  $ed
     18 U00ff					      ECHO	"Stack boundary: ", $FF- PLY_BANKS*2
     19 U00ff
     20 U00ff				  -	      IF	($FF - PLY_BANKS*2) < (Overlay + MAXIMUM_REQUIRED_OVERLAY_SIZE)
     21 U00ff				  -	      ECHO	"ERROR: Not enough reserved space for stack with given #PLY"
     22 U00ff				  -	      ERR
     23 U00ff					      ENDIF
     24 U00ff
     25 U00ff
------- FILE ./chess.asm
    529 U00ff
 FREE BYTES IN ZERO PAGE =  $0
    530 U00ff					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    531 U00ff				  -	      IF	* > $FF
    532 U00ff				  -	      ERR	"Zero Page overflow!"
    533 U00ff					      ENDIF
    534 U00ff
    535 U00ff							;------------------------------------------------------------------------------
    536 U00ff							;##############################################################################
    537 U00ff							;------------------------------------------------------------------------------
    538 U00ff
    539 U00ff							; NOW THE VERY INTERESTING '3E' RAM BANKS
    540 U00ff							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 512 bytes TOTAL ACCESSIBLE
    541 U00ff							; IN A 1K MEMORY SPACE
    542 U00ff
      0 U00ff					      SLOT	0
      1 U00ff				  -	      IF	(0 < 0) || (0 > 3)
      2 U00ff				  -	      ECHO	"Illegal bank address/segment location", 0
      3 U00ff				  -	      ERR
      4 U00ff					      ENDIF
      5 U00ff				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      6 U00ff				   _BANK_SLOT SET	0 * 64
      0 U00ff					      NEWRAMBANK	CHESS_BOARD_ROW
      1 U00ff
      2 U00ff
      3 U00ff
      4 U0000 ????				      SEG.U	CHESS_BOARD_ROW
      5 U0000					      ORG	ORIGIN_RAM
      6 U0000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0000				   _BANK_START SET	*
      8 U0000				   RAMBANK_CHESS_BOARD_ROW SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0000				   _CURRENT_RAMBANK SET	RAMBANK_CHESS_BOARD_ROW
     10 U0000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    545 U0000					      REPEAT	(CHESSBOARD_ROWS) - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U0000
      2 U0000
      3 U0000
      4 U1c00 ????				      SEG.U	.DUMMY
      5 U0400					      ORG	ORIGIN_RAM
      6 U0400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0400				   _BANK_START SET	*
      8 U0400				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    545 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400
      2 U0400
      3 U0400
      4 U0400					      SEG.U	.DUMMY
      5 U0800					      ORG	ORIGIN_RAM
      6 U0800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0800				   _BANK_START SET	*
      8 U0800				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    545 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800
      2 U0800
      3 U0800
      4 U0800					      SEG.U	.DUMMY
      5 U0c00					      ORG	ORIGIN_RAM
      6 U0c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0c00				   _BANK_START SET	*
      8 U0c00				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    545 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00
      2 U0c00
      3 U0c00
      4 U0c00					      SEG.U	.DUMMY
      5 U1000					      ORG	ORIGIN_RAM
      6 U1000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1000				   _BANK_START SET	*
      8 U1000				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    545 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000
      2 U1000
      3 U1000
      4 U1000					      SEG.U	.DUMMY
      5 U1400					      ORG	ORIGIN_RAM
      6 U1400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1400				   _BANK_START SET	*
      8 U1400				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    545 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400
      2 U1400
      3 U1400
      4 U1400					      SEG.U	.DUMMY
      5 U1800					      ORG	ORIGIN_RAM
      6 U1800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1800				   _BANK_START SET	*
      8 U1800				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    545 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800
      2 U1800
      3 U1800
      4 U1800					      SEG.U	.DUMMY
      5 U1c00					      ORG	ORIGIN_RAM
      6 U1c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1c00				   _BANK_START SET	*
      8 U1c00				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    547 U1c00					      REPEND
    548 U1c00
    549 U1c00							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    550 U1c00							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    551 U1c00							; The variable definitions are also in that ROM bank (even though they're RAM :)
    552 U1c00
    553 U1c00							; Now we have the actual graphics data for each of the rows.  This consists of an
    554 U1c00							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    555 U1c00							; character shapes are masked/copied. The depth of the character shapes may be
    556 U1c00							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    557 U1c00							; a multiple of 3, so that the RGB scanlines match at character joins.
    558 U1c00
    559 U1c00							; We have one bank for each chessboard row.  These banks are duplicates of the above,
    560 U1c00							; accessed via the above labels but with the appropriate bank switched in.
    561 U1c00
    562 U1c00							;---------------------------------------------------------------------------------------------------
    563 U1c00
    564 U1c00
    565 U1c00					      MAC	phase
    566 U1c00					      lda	#{1}
    567 U1c00					      sta	aiState
    568 U1c00					      ENDM		;#
    569 U1c00
    570 U1c00
    571 U1c00							;--------------------------------------------------------------------------------
    572 U1c00
    573 U1c00					      MAC	common_vars
    574 U1c00
    575 U1c00					      VAR	__thinkbar, 1
    576 U1c00					      VAR	__toggle, 1
    577 U1c00
    578 U1c00					      VAR	__bestMove, 1
    579 U1c00					      VAR	__alpha, 2
    580 U1c00					      VAR	__beta, 2
    581 U1c00					      VAR	__negaMax, 2
    582 U1c00					      VAR	__value, 2
    583 U1c00
    584 U1c00					      VAR	__quiesceCapOnly, 1
    585 U1c00
    586 U1c00					      VAR	__originalPiece, 1
    587 U1c00					      VAR	__capturedPiece, 1
    588 U1c00
    589 U1c00					      ENDM
    590 U1c00							;---------------------------------------------------------------------------------------------------
    591 U1c00
------- FILE MACROS.asm LEVEL 2 PASS 4
      0 U1c00					      include	"MACROS.asm"
      1 U1c00							; MACROS.asm
      2 U1c00
      3 U1c00
      4 U1c00							;---------------------------------------------------------------------------------------------------
      5 U1c00
      6 U1c00					      MAC	def
      7 U1c00
      8 U1c00							; Declare a subroutine
      9 U1c00							; Sets up a whole lot of helper stuff
     10 U1c00							;   slot and bank equates
     11 U1c00							;   local variable setup
     12 U1c00
     13 U1c00				   SLOT_{1}   SET	_BANK_SLOT
     14 U1c00				   BANK_{1}   SET	SLOT_{1} + _CURRENT_BANK	; bank in which this subroutine resides
     15 U1c00				   {1}			; entry point
     16 U1c00				   TEMPORARY_VAR SET	Overlay
     17 U1c00				   TEMPORARY_OFFSET SET	0
     18 U1c00				   VAR_BOUNDARY_{1} SET	TEMPORARY_OFFSET
     19 U1c00				   _FUNCTION_NAME SETSTR	{1}
     20 U1c00					      ENDM		; {name of subroutine}
     21 U1c00
     22 U1c00
     23 U1c00							;---------------------------------------------------------------------------------------------------
     24 U1c00
     25 U1c00					      MAC	ramdef
     26 U1c00
     27 U1c00							; Just an alternate name for "DEF" that makes it clear the subroutine is in RAM
     28 U1c00
     29 U1c00					      DEF	{1}
     30 U1c00					      ENDM		; {name of subroutine}
     31 U1c00
     32 U1c00							;---------------------------------------------------------------------------------------------------
     33 U1c00
     34 U1c00					      MAC	slot
     35 U1c00
     36 U1c00					      IF	({1} < 0) || ({1} > 3)
     37 U1c00					      ECHO	"Illegal bank address/segment location", {1}
     38 U1c00					      ERR
     39 U1c00					      ENDIF
     40 U1c00
     41 U1c00				   _BANK_ADDRESS_ORIGIN SET	$F000 + ({1} * _ROM_BANK_SIZE)
     42 U1c00				   _BANK_SLOT SET	{1} * 64	; D7/D6 selector
     43 U1c00
     44 U1c00					      ENDM		; {1}
     45 U1c00
     46 U1c00							;---------------------------------------------------------------------------------------------------
     47 U1c00							; Temporary local variables
     48 U1c00							; usage:
     49 U1c00							;
     50 U1c00							;   DEF fna
     51 U1c00							;	 REFER fnc
     52 U1c00							;	 REFER fnd
     53 U1c00							;	 VAR localVar1,1
     54 U1c00							;	 VAR ptr,2
     55 U1c00							;	 VEND fna
     56 U1c00							;
     57 U1c00							; The above declares a functino named 'fna'
     58 U1c00							; The function declares two local variables, 'localVar1' (1 byte) and 'ptr' (2 bytes)
     59 U1c00							; These variables are given an address in the overlay area which does NOT overlap any of
     60 U1c00							; the local variables which are declared in the referring functions 'fnc' and 'fnd'
     61 U1c00							; Although the local variables are available to other functions (i.e., global in scope), care
     62 U1c00							; should be taken NOT to use them in other functions unless absolutely necessary and required.
     63 U1c00							; To share local variables between functions, they should be (re)declared in both so that they
     64 U1c00							; have exactly the same addresses.
     65 U1c00
     66 U1c00
     67 U1c00
     68 U1c00							; The relative offset into the overlay area for the next variable declaration...
     69 U1c00				   TEMPORARY_OFFSET SET	0
     70 U1c00
     71 U1c00
     72 U1c00
     73 U1c00							; Finalise the declaration block for local variables
     74 U1c00							; {1} = name of the function for which this block is defined
     75 U1c00					      MAC	vend
     76 U1c00							; register the end of variables for this function
     77 U1c00
     78 U1c00				   VAREND_{1} =	TEMPORARY_VAR
     79 U1c00							;V2_._FUNCTION_NAME = TEMPORARY_VAR
     80 U1c00					      ENDM
     81 U1c00
     82 U1c00
     83 U1c00							; Note a reference to this function by an external function
     84 U1c00							; The external function's VEND block is used to guarantee that variables for
     85 U1c00							; the function we are declaring will start AFTER all other variables in all referencing blocks
     86 U1c00
     87 U1c00					      MAC	ref
     88 U1c00					      IF	VAREND_{1} > TEMPORARY_VAR
     89 U1c00				   TEMPORARY_VAR SET	VAREND_{1}
     90 U1c00					      ENDIF
     91 U1c00					      ENDM		; {1}
     92 U1c00
     93 U1c00
     94 U1c00
     95 U1c00							; Define a temporary variable for use in a subroutine
     96 U1c00							; Will allocate appropriate bytes, and also check for overflow of the available overlay buffer
     97 U1c00
     98 U1c00					      MAC	var
     99 U1c00							;	  ;LIST OFF
    100 U1c00				   {1}	      =	TEMPORARY_VAR
    101 U1c00				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + {2}
    102 U1c00
    103 U1c00				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
    104 U1c00					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
    105 U1c00				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
    106 U1c00					      ENDIF
    107 U1c00					      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
    108 U1c00					      LIST	ON
    109 U1c00					      VNAME	SETSTR {1}
    110 U1c00					      ECHO	"Temporary Variable", VNAME, "overflow!"
    111 U1c00					      ERR
    112 U1c00					      ECHO	"Temporary Variable overlow!"
    113 U1c00					      ENDIF
    114 U1c00					      LIST	ON
    115 U1c00					      ENDM		; { name, size }
    116 U1c00
    117 U1c00
    118 U1c00					      MAC	rombank
    119 U1c00					      SEG	ROM_{1}
    120 U1c00					      ORG	_ORIGIN
    121 U1c00					      RORG	_BANK_ADDRESS_ORIGIN
    122 U1c00				   _BANK_START SET	*
    123 U1c00				   {1}_START  SET	*
    124 U1c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
    125 U1c00				   ROMBANK_{1} SET	_BANK_SLOT + _CURRENT_BANK
    126 U1c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
    127 U1c00				   _LAST_BANK SETSTR	{1}
    128 U1c00					      ENDM		; bank name
    129 U1c00
    130 U1c00
    131 U1c00							;---------------------------------------------------------------------------------------------------
    132 U1c00
    133 U1c00					      MAC	check_bank_size
    134 U1c00				   .TEMP      =	* - _BANK_START
    135 U1c00					      ECHO	_LAST_BANK, "SIZE =", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
    136 U1c00					      IF	( .TEMP ) > _ROM_BANK_SIZE
    137 U1c00					      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN
    138 U1c00					      ERR
    139 U1c00					      ENDIF
    140 U1c00					      ENDM
    141 U1c00
    142 U1c00
    143 U1c00							;---------------------------------------------------------------------------------------------------
    144 U1c00
    145 U1c00					      MAC	check_ram_bank_size
    146 U1c00				   .TEMP      =	* - _BANK_START
    147 U1c00					      ECHO	_LAST_BANK, "SIZE =", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
    148 U1c00					      IF	( .TEMP ) > _RAM_BANK_SIZE
    149 U1c00					      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN
    150 U1c00					      ERR
    151 U1c00					      ENDIF
    152 U1c00					      ENDM
    153 U1c00
    154 U1c00
    155 U1c00							;---------------------------------------------------------------------------------------------------
    156 U1c00
    157 U1c00					      MAC	rambank
    158 U1c00
    159 U1c00					      SEG.U	RAM_{1}
    160 U1c00					      ORG	ORIGIN_RAM
    161 U1c00					      RORG	_BANK_ADDRESS_ORIGIN
    162 U1c00				   _BANK_START SET	*
    163 U1c00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
    164 U1c00				   RAMBANK_{1} SET	_BANK_SLOT + _CURRENT_RAMBANK
    165 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
    166 U1c00				   _LAST_BANK SETSTR	{1}
    167 U1c00
    168 U1c00					      ENDM		; {bank name}
    169 U1c00
    170 U1c00
    171 U1c00							;---------------------------------------------------------------------------------------------------
    172 U1c00
    173 U1c00							; Failsafe call of function in another bank
    174 U1c00							; This will check the slot #s for current, call to make sure they're not the same!
    175 U1c00
    176 U1c00					      MAC	call
    177 U1c00					      IF	SLOT_{1} == _BANK_SLOT
    178 U1c00				   FNAME      SETSTR	{1}
    179 U1c00					      ECHO	""
    180 U1c00					      ECHO	"ERROR: Incompatible slot for call to function", FNAME
    181 U1c00					      ECHO	"Cannot switch bank in use for ", FNAME
    182 U1c00					      ERR
    183 U1c00					      ENDIF
    184 U1c00					      lda	#BANK_{1}
    185 U1c00					      sta	SET_BANK
    186 U1c00					      jsr	{1}
    187 U1c00					      ENDM		; function name
    188 U1c00
    189 U1c00
    190 U1c00							;---------------------------------------------------------------------------------------------------
    191 U1c00							; RAM accessor macros
    192 U1c00							; ALL RAM usage (reads and writes) should use these
    193 U1c00							; They automate the write offset address addition, and make it clear what memory is being accessed
    194 U1c00
    195 U1c00
    196 U1c00					      MAC	sta@ram
    197 U1c00					      sta	[RAM]+{0}
    198 U1c00					      ENDM		;{}
    199 U1c00
    200 U1c00					      MAC	stx@ram
    201 U1c00					      stx	[RAM]+{0}
    202 U1c00					      ENDM		;{}
    203 U1c00
    204 U1c00					      MAC	sty@ram
    205 U1c00					      sty	[RAM]+{0}
    206 U1c00					      ENDM		;{}
    207 U1c00
    208 U1c00
    209 U1c00					      MAC	lda@ram
    210 U1c00					      lda	{0}
    211 U1c00					      ENDM		;{}
    212 U1c00
    213 U1c00					      MAC	ldx@ram
    214 U1c00					      ldx	{0}
    215 U1c00					      ENDM		;{}
    216 U1c00
    217 U1c00					      MAC	ldy@ram
    218 U1c00					      ldy	{0}
    219 U1c00					      ENDM		;{}
    220 U1c00
    221 U1c00
    222 U1c00					      MAC	adc@ram
    223 U1c00					      lda	{0}
    224 U1c00					      ENDM		;{}
    225 U1c00
    226 U1c00					      MAC	sbc@ram
    227 U1c00					      lda	{0}
    228 U1c00					      ENDM		;{}
    229 U1c00
    230 U1c00					      MAC	cmp@ram
    231 U1c00					      cmp	{0}
    232 U1c00					      ENDM		;{}
    233 U1c00
    234 U1c00
    235 U1c00							;---------------------------------------------------------------------------------------------------
    236 U1c00
    237 U1c00					      MAC	overlay
    238 U1c00					      SEG.U	OVERLAY_{1}
    239 U1c00					      org	Overlay
    240 U1c00					      ENDM		; {name}
    241 U1c00
    242 U1c00
    243 U1c00							;---------------------------------------------------------------------------------------------------
    244 U1c00
    245 U1c00					      MAC	validate_overlay
    246 U1c00							;	  ;LIST OFF
    247 U1c00					      if	* - Overlay > OVERLAY_SIZE
    248 U1c00					      ERR
    249 U1c00					      endif
    250 U1c00					      LIST	ON
    251 U1c00					      ENDM
    252 U1c00
    253 U1c00
    254 U1c00							;---------------------------------------------------------------------------------------------------
    255 U1c00							; Macro inserts a page break if the object would overlap a page
    256 U1c00
    257 U1c00					      MAC	optional_pagebreak
    258 U1c00							;	  ;LIST OFF
    259 U1c00					      IF	(>( * + {2} -1 )) > ( >* )
    260 U1c00				   EARLY_LOCATION SET	*
    261 U1c00					      ALIGN	256
    262 U1c00					      ECHO	"PAGE BREAK INSERTED FOR ", {1}
    263 U1c00					      ECHO	"REQUESTED SIZE = ", {2}
    264 U1c00					      ECHO	"WASTED SPACE = ", *-EARLY_LOCATION
    265 U1c00					      ECHO	"PAGEBREAK LOCATION = ", *
    266 U1c00					      ENDIF
    267 U1c00					      LIST	ON
    268 U1c00					      ENDM		; { string, size }
    269 U1c00
    270 U1c00
    271 U1c00							;---------------------------------------------------------------------------------------------------
    272 U1c00
    273 U1c00		       00 fe	   RND_EOR_VAL =	$FE	;B4
    274 U1c00
    275 U1c00					      MAC	next_random
    276 U1c00					      lda	rnd
    277 U1c00					      lsr
    278 U1c00					      bcc	.skipEOR
    279 U1c00					      eor	#RND_EOR_VAL
    280 U1c00				   .skipEOR   sta	rnd
    281 U1c00					      ENDM
    282 U1c00
    283 U1c00
    284 U1c00							;---------------------------------------------------------------------------------------------------
    285 U1c00
    286 U1c00
    287 U1c00					      MAC	set_platform
    288 U1c00							; 00 = NTSC
    289 U1c00							; 01 = NTSC
    290 U1c00							; 10 = PAL-50
    291 U1c00							; 11 = PAL-60
    292 U1c00					      lda	SWCHB	; 4
    293 U1c00					      and	#%11000000	; 2	 make sure carry is clear afterwards
    294 U1c00					      asl		; 2
    295 U1c00					      rol		; 2
    296 U1c00					      rol		; 2
    297 U1c00					      if	NTSC_MODE = NO
    298 U1c00					      eor	#PAL
    299 U1c00					      endif
    300 U1c00					      sta	Platform	; 3 = 15 P1 difficulty ──▷ TV system (0=NTSC, 1=PAL)
    301 U1c00					      ENDM
    302 U1c00
    303 U1c00
    304 U1c00							;---------------------------------------------------------------------------------------------------
    305 U1c00
    306 U1c00					      MAC	nop_b
    307 U1c00					      .byte	$82
    308 U1c00					      ENDM		; unused
    309 U1c00
    310 U1c00
    311 U1c00							;---------------------------------------------------------------------------------------------------
    312 U1c00
    313 U1c00					      MAC	nop_w
    314 U1c00					      .byte	$0c
    315 U1c00					      ENDM
    316 U1c00
    317 U1c00
    318 U1c00							;---------------------------------------------------------------------------------------------------
    319 U1c00							;EOF
------- FILE ./chess.asm
    593 U1c00
------- FILE STARTBANK@3.asm LEVEL 2 PASS 4
      0 U1c00					      include	"STARTBANK@3.asm"	; MUST be first ROM bank
      1 U1c00				   _ORIGIN    SET	_FIRST_BANK
      2 U1c00
      3 U1c00							;---------------------------------------------------------------------------------------------------
      4 U1c00
      0 U1c00					      SLOT	3
      1 U1c00				  -	      IF	(3 < 0) || (3 > 3)
      2 U1c00				  -	      ECHO	"Illegal bank address/segment location", 3
      3 U1c00				  -	      ERR
      4 U1c00					      ENDIF
      5 U1c00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6 U1c00				   _BANK_SLOT SET	3 * 64
      0 U1c00					      ROMBANK	STARTBANK
      1  0012 ????				      SEG	STARTBANK
      2  0000					      ORG	_ORIGIN
      3  0000					      RORG	_BANK_ADDRESS_ORIGIN
      4  0000				   _BANK_START SET	*
      5  0000				   STARTBANK_START SET	*
      6  0000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0000				   STARTBANK  SET	_BANK_SLOT + _CURRENT_BANK
      8  0000				   _ORIGIN    SET	_ORIGIN + 1024
      7  0000
      8  0000
      9  0000							;---------------------------------------------------------------------------------------------------
     10  0000
      0  0000					      DEF	StartCartridge
      1  0000				   SLOT_StartCartridge SET	_BANK_SLOT
      2  0000				   BANK_StartCartridge SET	SLOT_StartCartridge + _CURRENT_BANK
      3  0000				   StartCartridge
      4  0000				   TEMPORARY_VAR SET	Overlay
      5  0000				   TEMPORARY_OFFSET SET	0
      6  0000				   VAR_BOUNDARY_StartCartridge SET	TEMPORARY_OFFSET
      7  0000				   FUNCTION_NAME SET	StartCartridge
     12  0000
      0  0000					      CLEAN_START
      1  0000		       78		      sei
      2  0001		       d8		      cld
      3  0002
      4  0002		       a2 00		      ldx	#0
      5  0004		       8a		      txa
      6  0005		       a8		      tay
      7  0006		       ca	   .CLEAR_STACK dex
      8  0007		       9a		      txs
      9  0008		       48		      pha
     10  0009		       d0 fb		      bne	.CLEAR_STACK
     11  000b
     14  000b
     15  000b		       a9 01		      lda	#BANK_StartupBankReset
     16  000d		       85 3f		      sta	SET_BANK
     17  000f		       4c 00 f0 	      jmp	StartupBankReset
     18  0012
     19  0012
     20  0012							;---------------------------------------------------------------------------------------------------
     21  0012
 FREE BYTES IN STARTBANK =  $fffffffffffff7e9
     22  0012					      ECHO	"FREE BYTES IN STARTBANK = ", $F3FB - *
     23  0012
     24  0012
     25  0012							;---------------------------------------------------------------------------------------------------
     26  0012
     27  0012							; The reset vectors
     28  0012							; these must live in the fixed bank (bank 0 in 3E+ format)
     29  0012
     30  0012
     31  0400 ????				      SEG	InterruptVectors
     32  03fc					      ORG	_FIRST_BANK + $3FC
     33  03fc
     34  03fc		       00 fc		      .word.w	StartCartridge	; RESET
     35  03fe		       00 fc		      .word.w	StartCartridge	; IRQ	      (not used)
     36  0400
     37  0400							;---------------------------------------------------------------------------------------------------
     38  0400							;EOF
------- FILE ./chess.asm
    595  0400
------- FILE BANK_FIRST@0.asm LEVEL 2 PASS 4
      0  0400					      include	"BANK_FIRST@0.asm"
      1  0400							; Chess
      2  0400							; Copyright (c) 2019-2020 Andrew Davie
      3  0400							; andrew@taswegian.com
      4  0400
      5  0400
      6  0400							; SLOT0 - screen draw, state machine dispatcher
      7  0400							; SLOT1 - anything
      8  0400							; SLOT2 - moves/ply
      9  0400							; SLOT3 - board
     10  0400
     11  0400
     12  0400
     13  0400
     14  0400
     15  0400
      0  0400					      SLOT	0
      1  0400				  -	      IF	(0 < 0) || (0 > 3)
      2  0400				  -	      ECHO	"Illegal bank address/segment location", 0
      3  0400				  -	      ERR
      4  0400					      ENDIF
      5  0400				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      6  0400				   _BANK_SLOT SET	0 * 64
     17  0400
     18  0400							;---------------------------------------------------------------------------------------------------
     19  0400							;#########################################  FIXED BANK  ############################################
     20  0400							;---------------------------------------------------------------------------------------------------
     21  0400
     22  0400							;_ORIGIN	      SET _FIRST_BANK
     23  0400
      0  0400					      ROMBANK	THE_FIRST_BANK
      1  07d8 ????				      SEG	THE_FIRST_BANK
      2  0400					      ORG	_ORIGIN
      3  0400					      RORG	_BANK_ADDRESS_ORIGIN
      4  0400				   _BANK_START SET	*
      5  0400				   THE_FIRST_BANK_START SET	*
      6  0400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0400				   THE_FIRST_BANK SET	_BANK_SLOT + _CURRENT_BANK
      8  0400				   _ORIGIN    SET	_ORIGIN + 1024
     25  0400					      RORG	$f000
     26  0400
     27  0400							;---------------------------------------------------------------------------------------------------
     28  0400
      0  0400					      DEF	StartupBankReset
      1  0400				   SLOT_StartupBankReset SET	_BANK_SLOT
      2  0400				   BANK_StartupBankReset SET	SLOT_StartupBankReset + _CURRENT_BANK
      3  0400				   StartupBankReset
      4  0400				   TEMPORARY_VAR SET	Overlay
      5  0400				   TEMPORARY_OFFSET SET	0
      6  0400				   VAR_BOUNDARY_StartupBankReset SET	TEMPORARY_OFFSET
      7  0400				   FUNCTION_NAME SET	StartupBankReset
     30  0400					      SUBROUTINE
     31  0400
      0  0400					      VEND	StartupBankReset
      1  0400				  -	      IFNCONST	StartupBankReset
      2  0400				  -	      ECHO	"Incorrect VEND label", StartupBankReset
      3  0400				  -	      ERR
      4  0400					      ENDIF
      5  0400		       00 a7	   VAREND_StartupBankReset =	TEMPORARY_VAR
     33  0400
     34  0400							; On startup, 3E+ switches banks 0 and 3 to the 1st ROM bank (1K), from which the reset
     35  0400							; vector is obtained from bank 0 (+$FFC). Chess3E+ (maybe) will leave this bank (3) alone
     36  0400							; so that a system reset will always have the reset vectors available at FFFC, where expected
     37  0400
     38  0400		       a2 ff		      ldx	#$FF
     39  0402		       9a		      txs
     40  0403
      0  0403					      CALL	TitleScreen
      1  0403				  -	      IF	SLOT_TitleScreen == _BANK_SLOT
      2  0403				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0403				  -	      ECHO	"Cannot switch bank in use for", TitleScreen
      4  0403				  -	      ERR
      5  0403					      ENDIF
      6  0403		       a9 5c		      lda	#BANK_TitleScreen
      7  0405		       85 3f		      sta	SET_BANK
      8  0407		       20 06 f4 	      jsr	TitleScreen
     42  040a
      0  040a					      CALL	CartInit
      1  040a				  -	      IF	SLOT_CartInit == _BANK_SLOT
      2  040a				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  040a				  -	      ECHO	"Cannot switch bank in use for", CartInit
      4  040a				  -	      ERR
      5  040a					      ENDIF
      6  040a		       a9 42		      lda	#BANK_CartInit
      7  040c		       85 3f		      sta	SET_BANK
      8  040e		       20 00 f4 	      jsr	CartInit
      0  0411					      CALL	SetupBanks
      1  0411				  -	      IF	SLOT_SetupBanks == _BANK_SLOT
      2  0411				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0411				  -	      ECHO	"Cannot switch bank in use for", SetupBanks
      4  0411				  -	      ERR
      5  0411					      ENDIF
      6  0411		       a9 42		      lda	#BANK_SetupBanks
      7  0413		       85 3f		      sta	SET_BANK
      8  0415		       20 32 f4 	      jsr	SetupBanks
      0  0418					      CALL	InitialisePieceSquares
      1  0418				  -	      IF	SLOT_InitialisePieceSquares == _BANK_SLOT
      2  0418				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0418				  -	      ECHO	"Cannot switch bank in use for", InitialisePieceSquares
      4  0418				  -	      ERR
      5  0418					      ENDIF
      6  0418		       a9 42		      lda	#BANK_InitialisePieceSquares
      7  041a		       85 3f		      sta	SET_BANK
      8  041c		       20 92 f4 	      jsr	InitialisePieceSquares
     46  041f		       20 48 f2 	      jsr	ListPlayerMoves	;@0
     47  0422
     48  0422
     49  0422				   .StartFrame
     50  0422
     51  0422
     52  0422							; START OF FRAME
     53  0422
     54  0422		       a9 0e		      lda	#%1110	; VSYNC ON
     55  0424		       85 42	   .loopVSync3 sta	WSYNC
     56  0426		       85 40		      sta	VSYNC
     57  0428		       4a		      lsr
     58  0429		       d0 f9		      bne	.loopVSync3	; branch until VYSNC has been reset
     59  042b
     60  042b		       85 41		      sta	VBLANK
     61  042d
     62  042d		       a0 2e		      ldy	#TIME_PART_1
     63  042f		       8c 96 02 	      sty	TIM64T
     64  0432
     65  0432							; LOTS OF PROCESSING TIME - USE IT
     66  0432
     67  0432
     68  0432
     69  0432		       20 8a f1 	      jsr	AiStateMachine
     70  0435
     71  0435				  -	      IF	ASSERTS
     72  0435				  -			; Catch timer expired already
     73  0435				  -			;		      bit TIMINT
     74  0435				  -			;.whoops	      bmi .whoops
     75  0435					      ENDIF
     76  0435
     77  0435
     78  0435		       2c 85 02    .wait      bit	TIMINT
     79  0438		       10 fb		      bpl	.wait
     80  043a
     81  043a
     82  043a							; START OF VISIBLE SCANLINES
     83  043a
     84  043a
      0  043a					      CALL	longD
      1  043a				  -	      IF	SLOT_longD == _BANK_SLOT
      2  043a				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  043a				  -	      ECHO	"Cannot switch bank in use for", longD
      4  043a				  -	      ERR
      5  043a					      ENDIF
      6  043a		       a9 92		      lda	#BANK_longD
      7  043c		       85 3f		      sta	SET_BANK
      8  043e		       20 16 f8 	      jsr	longD
     86  0441
     87  0441
     88  0441		       a2 80		      ldx	#SLOT_DrawRow	; + BANK_DrawRow
     89  0443		       86 3e		      stx	SET_BANK_RAM
     90  0445		       20 03 f9 	      jsr	DrawRow	; draw the ENTIRE visible screen!
     91  0448
      0  0448					      CALL	tidySc
      1  0448				  -	      IF	SLOT_tidySc == _BANK_SLOT
      2  0448				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0448				  -	      ECHO	"Cannot switch bank in use for", tidySc
      4  0448				  -	      ERR
      5  0448					      ENDIF
      6  0448		       a9 92		      lda	#BANK_tidySc
      7  044a		       85 3f		      sta	SET_BANK
      8  044c		       20 04 f8 	      jsr	tidySc
     93  044f
     94  044f		       20 8a f1 	      jsr	AiStateMachine
     95  0452
     96  0452		       ad 84 02 	      lda	INTIM
     97  0455		       c9 14		      cmp	#20
     98  0457		       90 20		      bcc	.notnow
     99  0459
    100  0459							;CALL GameSpeak
      0  0459					      CALL	PositionSprites
      1  0459				  -	      IF	SLOT_PositionSprites == _BANK_SLOT
      2  0459				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0459				  -	      ECHO	"Cannot switch bank in use for", PositionSprites
      4  0459				  -	      ERR
      5  0459					      ENDIF
      6  0459		       a9 48		      lda	#BANK_PositionSprites
      7  045b		       85 3f		      sta	SET_BANK
      8  045d		       20 00 f5 	      jsr	PositionSprites
    102  0460
    103  0460
    104  0460					      IF	1
    105  0460							; "draw" sprite shapes into row banks
    106  0460
    107  0460		       a2 07		      ldx	#7
    108  0462		       8a	   zapem      txa
    109  0463		       18		      clc
    110  0464		       69 80		      adc	#SLOT_DrawRow
    111  0466		       85 3e		      sta	SET_BANK_RAM
      0  0468					      CALL	WriteBlank	;@3
      1  0468				  -	      IF	SLOT_WriteBlank == _BANK_SLOT
      2  0468				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0468				  -	      ECHO	"Cannot switch bank in use for", WriteBlank
      4  0468				  -	      ERR
      5  0468					      ENDIF
      6  0468		       a9 c4		      lda	#BANK_WriteBlank
      7  046a		       85 3f		      sta	SET_BANK
      8  046c		       20 0b fc 	      jsr	WriteBlank
    113  046f		       ca		      dex
    114  0470		       10 f0		      bpl	zapem
    115  0472
      0  0472					      CALL	WriteCursor	;@3
      1  0472				  -	      IF	SLOT_WriteCursor == _BANK_SLOT
      2  0472				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0472				  -	      ECHO	"Cannot switch bank in use for", WriteCursor
      4  0472				  -	      ERR
      5  0472					      ENDIF
      6  0472		       a9 c4		      lda	#BANK_WriteCursor
      7  0474		       85 3f		      sta	SET_BANK
      8  0476		       20 34 fc 	      jsr	WriteCursor
    117  0479					      ENDIF
    118  0479
    119  0479				   .notnow
    120  0479
    121  0479		       2c 85 02    .waitTime  bit	TIMINT
    122  047c		       10 fb		      bpl	.waitTime
    123  047e
    124  047e		       4c 22 f0 	      jmp	.StartFrame
    125  0481
    126  0481
    127  0481							;---------------------------------------------------------------------------------------------------
    128  0481
      0  0481					      DEF	ThinkBar
      1  0481				   SLOT_ThinkBar SET	_BANK_SLOT
      2  0481				   BANK_ThinkBar SET	SLOT_ThinkBar + _CURRENT_BANK
      3  0481				   ThinkBar
      4  0481				   TEMPORARY_VAR SET	Overlay
      5  0481				   TEMPORARY_OFFSET SET	0
      6  0481				   VAR_BOUNDARY_ThinkBar SET	TEMPORARY_OFFSET
      7  0481				   FUNCTION_NAME SET	ThinkBar
    130  0481					      SUBROUTINE
    131  0481
      0  0481					      COMMON_VARS
      1  0481
      0  0481					      VAR	__thinkbar, 1
      1  0481		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0481				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  0481				  -	      ERR
     11  0481					      ENDIF
     12  0481					      LIST	ON
      0  0481					      VAR	__toggle, 1
      1  0481		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0481				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  0481				  -	      ERR
     11  0481					      ENDIF
     12  0481					      LIST	ON
      4  0481
      0  0481					      VAR	__bestMove, 1
      1  0481		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0481				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  0481				  -	      ERR
     11  0481					      ENDIF
     12  0481					      LIST	ON
      0  0481					      VAR	__alpha, 2
      1  0481		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0481				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  0481				  -	      ERR
     11  0481					      ENDIF
     12  0481					      LIST	ON
      0  0481					      VAR	__beta, 2
      1  0481		       00 ac	   __beta     =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0481				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  0481				  -	      ERR
     11  0481					      ENDIF
     12  0481					      LIST	ON
      0  0481					      VAR	__negaMax, 2
      1  0481		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0481				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  0481				  -	      ERR
     11  0481					      ENDIF
     12  0481					      LIST	ON
      0  0481					      VAR	__value, 2
      1  0481		       00 b0	   __value    =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0481				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  0481				  -	      ERR
     11  0481					      ENDIF
     12  0481					      LIST	ON
     10  0481
      0  0481					      VAR	__quiesceCapOnly, 1
      1  0481		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0481				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  0481				  -	      ERR
     11  0481					      ENDIF
     12  0481					      LIST	ON
     12  0481
      0  0481					      VAR	__originalPiece, 1
      1  0481		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0481				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  0481				  -	      ERR
     11  0481					      ENDIF
     12  0481					      LIST	ON
      0  0481					      VAR	__capturedPiece, 1
      1  0481		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0481				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  0481				  -	      ERR
     11  0481					      ENDIF
     12  0481					      LIST	ON
     15  0481
      0  0481					      REFER	negaMax	;✅
      1  0481				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0481				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  0481					      ENDIF
      0  0481					      REFER	quiesce	;✅
      1  0481				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  0481				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  0481					      ENDIF
      0  0481					      VEND	ThinkBar
      1  0481				  -	      IFNCONST	ThinkBar
      2  0481				  -	      ECHO	"Incorrect VEND label", ThinkBar
      3  0481				  -	      ERR
      4  0481					      ENDIF
      5  0481		       00 b5	   VAREND_ThinkBar =	TEMPORARY_VAR
    136  0481
    137  0481					      IF	DIAGNOSTICS
    138  0481
    139  0481		       e6 9c		      inc	positionCount
    140  0483		       d0 06		      bne	.p1
    141  0485		       e6 9d		      inc	positionCount+1
    142  0487		       d0 02		      bne	.p1
    143  0489		       e6 9e		      inc	positionCount+2
    144  048b				   .p1
    145  048b					      ENDIF
    146  048b
    147  048b							; The 'thinkbar' pattern...
    148  048b
    149  048b		       a9 00		      lda	#0
    150  048d		       a4 4c		      ldy	INPT4
    151  048f		       30 13		      bmi	.doThink
    152  0491
    153  0491		       e6 a7		      inc	__thinkbar
    154  0493		       a5 a7		      lda	__thinkbar
    155  0495		       29 0f		      and	#15
    156  0497		       a8		      tay
    157  0498		       a5 81		      lda	rnd
    158  049a		       29 04		      and	#4
    159  049c		       19 ab f0 	      ora	TBcol,y
    160  049f		       85 48		      sta	COLUPF
    161  04a1
    162  04a1		       b9 bb f0 	      lda	SynapsePattern,y
    163  04a4		       85 4f	   .doThink   sta	PF2
    164  04a6		       85 4e		      sta	PF1
    165  04a8		       85 4d		      sta	PF0
    166  04aa		       60		      rts
    167  04ab
    168  04ab
    169  04ab				   TBcol
    170  04ab				   .TBC       SET	2
    171  04ab					      REPEAT	16
    172  04ab		       02		      .byte.b	.TBC
    173  04ab				   .TBC       SET	.TBC + 16
    171  04ab					      REPEND
    172  04ac		       12		      .byte.b	.TBC
    173  04ac				   .TBC       SET	.TBC + 16
    171  04ac					      REPEND
    172  04ad		       22		      .byte.b	.TBC
    173  04ad				   .TBC       SET	.TBC + 16
    171  04ad					      REPEND
    172  04ae		       32		      .byte.b	.TBC
    173  04ae				   .TBC       SET	.TBC + 16
    171  04ae					      REPEND
    172  04af		       42		      .byte.b	.TBC
    173  04af				   .TBC       SET	.TBC + 16
    171  04af					      REPEND
    172  04b0		       52		      .byte.b	.TBC
    173  04b0				   .TBC       SET	.TBC + 16
    171  04b0					      REPEND
    172  04b1		       62		      .byte.b	.TBC
    173  04b1				   .TBC       SET	.TBC + 16
    171  04b1					      REPEND
    172  04b2		       72		      .byte.b	.TBC
    173  04b2				   .TBC       SET	.TBC + 16
    171  04b2					      REPEND
    172  04b3		       82		      .byte.b	.TBC
    173  04b3				   .TBC       SET	.TBC + 16
    171  04b3					      REPEND
    172  04b4		       92		      .byte.b	.TBC
    173  04b4				   .TBC       SET	.TBC + 16
    171  04b4					      REPEND
    172  04b5		       a2		      .byte.b	.TBC
    173  04b5				   .TBC       SET	.TBC + 16
    171  04b5					      REPEND
    172  04b6		       b2		      .byte.b	.TBC
    173  04b6				   .TBC       SET	.TBC + 16
    171  04b6					      REPEND
    172  04b7		       c2		      .byte.b	.TBC
    173  04b7				   .TBC       SET	.TBC + 16
    171  04b7					      REPEND
    172  04b8		       d2		      .byte.b	.TBC
    173  04b8				   .TBC       SET	.TBC + 16
    171  04b8					      REPEND
    172  04b9		       e2		      .byte.b	.TBC
    173  04b9				   .TBC       SET	.TBC + 16
    171  04b9					      REPEND
    172  04ba		       f2		      .byte.b	.TBC
    173  04ba				   .TBC       SET	.TBC + 16
    174  04bb					      REPEND
    175  04bb
    176  04bb				   SynapsePattern
    177  04bb
    178  04bb		       c1		      .byte.b	%11000001
    179  04bc		       60		      .byte.b	%01100000
    180  04bd		       30		      .byte.b	%00110000
    181  04be		       18		      .byte.b	%00011000
    182  04bf		       0c		      .byte.b	%00001100
    183  04c0		       06		      .byte.b	%00000110
    184  04c1		       83		      .byte.b	%10000011
    185  04c2		       c1		      .byte.b	%11000001
    186  04c3
    187  04c3		       83		      .byte.b	%10000011
    188  04c4		       06		      .byte.b	%00000110
    189  04c5		       0c		      .byte.b	%00001100
    190  04c6		       18		      .byte.b	%00011000
    191  04c7		       30		      .byte.b	%00110000
    192  04c8		       60		      .byte.b	%01100000
    193  04c9		       c1		      .byte.b	%11000001
    194  04ca		       83		      .byte.b	%10000011
    195  04cb
    196  04cb
    197  04cb							;---------------------------------------------------------------------------------------------------
    198  04cb
      0  04cb					      DEF	CopySinglePiece
      1  04cb				   SLOT_CopySinglePiece SET	_BANK_SLOT
      2  04cb				   BANK_CopySinglePiece SET	SLOT_CopySinglePiece + _CURRENT_BANK
      3  04cb				   CopySinglePiece
      4  04cb				   TEMPORARY_VAR SET	Overlay
      5  04cb				   TEMPORARY_OFFSET SET	0
      6  04cb				   VAR_BOUNDARY_CopySinglePiece SET	TEMPORARY_OFFSET
      7  04cb				   FUNCTION_NAME SET	CopySinglePiece
    200  04cb					      SUBROUTINE
    201  04cb
      0  04cb					      TIMING	COPYSINGLEPIECE, (2600)
      1  04cb		       00 29	   SPEEDOF_COPYSINGLEPIECE =	((2600)/64) + 1
    203  04cb
      0  04cb					      REFER	showMoveCaptures	;✅
      1  04cb					      IF	VAREND_showMoveCaptures > TEMPORARY_VAR
      2  04cb				   TEMPORARY_VAR SET	VAREND_showMoveCaptures
      3  04cb					      ENDIF
      0  04cb					      REFER	aiDrawEntireBoard	;✅
      1  04cb				  -	      IF	VAREND_aiDrawEntireBoard > TEMPORARY_VAR
      2  04cb				  -TEMPORARY_VAR SET	VAREND_aiDrawEntireBoard
      3  04cb					      ENDIF
      0  04cb					      REFER	aiDrawPart2	;✅
      1  04cb				  -	      IF	VAREND_aiDrawPart2 > TEMPORARY_VAR
      2  04cb				  -TEMPORARY_VAR SET	VAREND_aiDrawPart2
      3  04cb					      ENDIF
      0  04cb					      REFER	aiMarchB	;✅
      1  04cb				  -	      IF	VAREND_aiMarchB > TEMPORARY_VAR
      2  04cb				  -TEMPORARY_VAR SET	VAREND_aiMarchB
      3  04cb					      ENDIF
      0  04cb					      REFER	aiFlashComputerMove	;✅
      1  04cb				  -	      IF	VAREND_aiFlashComputerMove > TEMPORARY_VAR
      2  04cb				  -TEMPORARY_VAR SET	VAREND_aiFlashComputerMove
      3  04cb					      ENDIF
      0  04cb					      REFER	aiSelectDestinationSquare	;✅
      1  04cb				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  04cb				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  04cb					      ENDIF
      0  04cb					      REFER	aiMarchA2	;✅
      1  04cb				  -	      IF	VAREND_aiMarchA2 > TEMPORARY_VAR
      2  04cb				  -TEMPORARY_VAR SET	VAREND_aiMarchA2
      3  04cb					      ENDIF
      0  04cb					      REFER	aiMarchB2	;✅
      1  04cb				  -	      IF	VAREND_aiMarchB2 > TEMPORARY_VAR
      2  04cb				  -TEMPORARY_VAR SET	VAREND_aiMarchB2
      3  04cb					      ENDIF
      0  04cb					      REFER	aiWriteStartPieceBlank	;✅
      1  04cb				  -	      IF	VAREND_aiWriteStartPieceBlank > TEMPORARY_VAR
      2  04cb				  -TEMPORARY_VAR SET	VAREND_aiWriteStartPieceBlank
      3  04cb					      ENDIF
      0  04cb					      REFER	aiChoosePromotePiece	;✅
      1  04cb				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  04cb				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  04cb					      ENDIF
      0  04cb					      REFER	aiMarchToTargetB	;✅
      1  04cb				  -	      IF	VAREND_aiMarchToTargetB > TEMPORARY_VAR
      2  04cb				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetB
      3  04cb					      ENDIF
      0  04cb					      REFER	aiPromotePawnStart	;✅
      1  04cb				  -	      IF	VAREND_aiPromotePawnStart > TEMPORARY_VAR
      2  04cb				  -TEMPORARY_VAR SET	VAREND_aiPromotePawnStart
      3  04cb					      ENDIF
      0  04cb					      REFER	aiFinalFlash	;✅
      1  04cb				  -	      IF	VAREND_aiFinalFlash > TEMPORARY_VAR
      2  04cb				  -TEMPORARY_VAR SET	VAREND_aiFinalFlash
      3  04cb					      ENDIF
    217  04cb
    218  04cb
      0  04cb					      VEND	CopySinglePiece
      1  04cb				  -	      IFNCONST	CopySinglePiece
      2  04cb				  -	      ECHO	"Incorrect VEND label", CopySinglePiece
      3  04cb				  -	      ERR
      4  04cb					      ENDIF
      5  04cb		       00 ac	   VAREND_CopySinglePiece =	TEMPORARY_VAR
    220  04cb
    221  04cb							; WARNING: CANNOT USE VAR/OVERLAY IN ANY ROUTINE CALLING THIS!!
    222  04cb							; ALSO CAN'T USE IN THIS ROUTINE
    223  04cb							; This routine will STOMP on those vars due to __pieceShapeBuffer occupying whole overlay
    224  04cb							; @2150 max
    225  04cb							; = 33 TIM64T
    226  04cb
      0  04cb					      CALL	CopySetup	;@2
      1  04cb				  -	      IF	SLOT_CopySetup == _BANK_SLOT
      2  04cb				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  04cb				  -	      ECHO	"Cannot switch bank in use for", CopySetup
      4  04cb				  -	      ERR
      5  04cb					      ENDIF
      6  04cb		       a9 92		      lda	#BANK_CopySetup
      7  04cd		       85 3f		      sta	SET_BANK
      8  04cf		       20 8a f8 	      jsr	CopySetup
    228  04d2
    229  04d2
      0  04d2					      DEF	InterceptMarkerCopy
      1  04d2				   SLOT_InterceptMarkerCopy SET	_BANK_SLOT
      2  04d2				   BANK_InterceptMarkerCopy SET	SLOT_InterceptMarkerCopy + _CURRENT_BANK
      3  04d2				   InterceptMarkerCopy
      4  04d2				   TEMPORARY_VAR SET	Overlay
      5  04d2				   TEMPORARY_OFFSET SET	0
      6  04d2				   VAR_BOUNDARY_InterceptMarkerCopy SET	TEMPORARY_OFFSET
      7  04d2				   FUNCTION_NAME SET	InterceptMarkerCopy
    231  04d2					      SUBROUTINE
    232  04d2
      0  04d2					      REFER	CopySinglePiece	;✅
      1  04d2					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  04d2				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  04d2					      ENDIF
      0  04d2					      REFER	showPromoteOptions	;✅
      1  04d2				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  04d2				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  04d2					      ENDIF
      0  04d2					      REFER	showMoveOptions	;✅
      1  04d2				  -	      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  04d2				  -TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  04d2					      ENDIF
      0  04d2					      VEND	InterceptMarkerCopy
      1  04d2				  -	      IFNCONST	InterceptMarkerCopy
      2  04d2				  -	      ECHO	"Incorrect VEND label", InterceptMarkerCopy
      3  04d2				  -	      ERR
      4  04d2					      ENDIF
      5  04d2		       00 ac	   VAREND_InterceptMarkerCopy =	TEMPORARY_VAR
    237  04d2
    238  04d2							; Copy a piece shape (3 PF bytes wide x 24 lines) to the RAM buffer
    239  04d2							; y = piece index
    240  04d2
    241  04d2		       a9 92		      lda	#BANK_PIECE_VECTOR_BANK
    242  04d4		       85 3f		      sta	SET_BANK	;@2
    243  04d6
    244  04d6		       b9 e5 f9 	      lda	PIECE_VECTOR_LO,y
    245  04d9		       85 a2		      sta	__psb
    246  04db		       b9 75 fa 	      lda	PIECE_VECTOR_HI,y
    247  04de		       85 a3		      sta	__psb+1
    248  04e0		       b9 05 fb 	      lda	PIECE_VECTOR_BANK,y
    249  04e3		       85 3f		      sta	SET_BANK	;@2
    250  04e5
    251  04e5		       a0 47		      ldy	#PIECE_SHAPE_SIZE-1
    252  04e7		       b1 a2	   .copy      lda	(__psb),y
    253  04e9		       99 a7 00 	      sta	__pieceShapeBuffer,y
    254  04ec		       88		      dey
    255  04ed		       10 f8		      bpl	.copy
    256  04ef
    257  04ef		       a5 80		      lda	squareToDraw
    258  04f1		       38		      sec
    259  04f2		       a2 0a		      ldx	#10
    260  04f4		       e9 0a	   .sub10     sbc	#10
    261  04f6		       ca		      dex
    262  04f7		       b0 fb		      bcs	.sub10
    263  04f9
    264  04f9		       69 08		      adc	#8
    265  04fb		       c9 04		      cmp	#4	; CS = right side of screen
    266  04fd
    267  04fd		       8a		      txa
    268  04fe		       09 80		      ora	#[SLOT2]
    269  0500		       85 3e		      sta	SET_BANK_RAM	;@2		 ; bank row
    270  0502
    271  0502		       20 48 f3 	      jsr	CopyPieceToRowBitmap	;@3
    272  0505		       60		      rts
    273  0506
    274  0506
    275  0506							;---------------------------------------------------------------------------------------------------
    276  0506
    277  0506				   P	      SET	0
    278  0506					      MAC	ain
    279  0506				   AI_{1}     SET	P
    280  0506				   P	      SET	P+1
    281  0506					      ENDM
    282  0506
    283  0506					      MAC	lo
    284  0506					      .byte	<ai{1}
    285  0506					      ENDM
    286  0506
    287  0506					      MAC	hi
    288  0506					      .byte	>ai{1}
    289  0506					      ENDM
    290  0506
    291  0506					      MAC	bk
    292  0506					      .byte	BANK_ai{1}
    293  0506					      ENDM
    294  0506
    295  0506
    296  0506		       00 28	   ONCEPERFRAME =	40
    297  0506
    298  0506					      MAC	tabdef
    299  0506
    300  0506					      {1}	FlashComputerMove	; 0
    301  0506					      {1}	BeginSelectMovePhase	; 1
    302  0506					      {1}	SelectStartSquare	; 2
    303  0506					      {1}	StartSquareSelected	; 3
    304  0506					      {1}	DrawMoves	; 4
    305  0506					      {1}	ShowMoveCaptures	; 5
    306  0506					      {1}	SlowFlash	; 6
    307  0506					      {1}	UnDrawTargetSquares	; 7
    308  0506					      {1}	SelectDestinationSquare	; 8
    309  0506					      {1}	Quiescent	; 9
    310  0506					      {1}	ReselectDebounce	; 10
    311  0506					      {1}	StartMoveGen	; 11
    312  0506					      {1}	StepMoveGen	; 12
    313  0506					      {1}	StartClearBoard	; 13
    314  0506					      {1}	ClearEachRow	; 14
    315  0506					      {1}	DrawEntireBoard	; 15
    316  0506					      {1}	DrawPart2	; 16
    317  0506					      {1}	DrawPart3	; 17
    318  0506					      {1}	GenerateMoves	; 18
    319  0506					      {1}	ComputerMove	; 19
    320  0506					      {1}	MoveIsSelected	; 20
    321  0506					      {1}	WriteStartPieceBlank	; 21
    322  0506					      {1}	MarchToTargetA	; 22
    323  0506					      {1}	MarchA2	; 23
    324  0506					      {1}	MarchB	; 24
    325  0506					      {1}	MarchToTargetB	; 25
    326  0506					      {1}	MarchB2	; 26
    327  0506					      {1}	FinalFlash	; 27
    328  0506					      {1}	SpecialMoveFixup	; 28
    329  0506					      {1}	InCheckBackup	; 29
    330  0506					      {1}	InCheckDelay	; 30
    331  0506					      {1}	PromotePawnStart	; 31
    332  0506					      {1}	RollPromotionPiece	; 32
    333  0506					      {1}	ChoosePromotePiece	; 33
    334  0506					      {1}	ChooseDebounce	; 34
    335  0506					      {1}	CheckMate	; 35
    336  0506					      {1}	Draw	; 36
    337  0506					      {1}	DelayAfterMove	; 37
    338  0506					      {1}	DelayAfterMove2	; 38
    339  0506					      {1}	DelayAfterPlaced	; 39
    340  0506					      {1}	DelayAfterPlaced2	; 40
    341  0506					      {1}	EPHandler	; 41
    342  0506					      {1}	EPFlash	; 42
    343  0506					      {1}	DebounceSelect	; 43
    344  0506
    345  0506					      ENDM		; {1} = macro to use
    346  0506
      0  0506					      TABDEF	AIN
      1  0506
      0  0506					      AIN	FlashComputerMove
      1  0506				   AI_FlashComputerMove SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	BeginSelectMovePhase
      1  0506				   AI_BeginSelectMovePhase SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	SelectStartSquare
      1  0506				   AI_SelectStartSquare SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	StartSquareSelected
      1  0506				   AI_StartSquareSelected SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	DrawMoves
      1  0506				   AI_DrawMoves SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	ShowMoveCaptures
      1  0506				   AI_ShowMoveCaptures SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	SlowFlash
      1  0506				   AI_SlowFlash SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	UnDrawTargetSquares
      1  0506				   AI_UnDrawTargetSquares SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	SelectDestinationSquare
      1  0506				   AI_SelectDestinationSquare SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	Quiescent
      1  0506				   AI_Quiescent SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	ReselectDebounce
      1  0506				   AI_ReselectDebounce SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	StartMoveGen
      1  0506				   AI_StartMoveGen SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	StepMoveGen
      1  0506				   AI_StepMoveGen SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	StartClearBoard
      1  0506				   AI_StartClearBoard SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	ClearEachRow
      1  0506				   AI_ClearEachRow SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	DrawEntireBoard
      1  0506				   AI_DrawEntireBoard SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	DrawPart2
      1  0506				   AI_DrawPart2 SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	DrawPart3
      1  0506				   AI_DrawPart3 SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	GenerateMoves
      1  0506				   AI_GenerateMoves SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	ComputerMove
      1  0506				   AI_ComputerMove SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	MoveIsSelected
      1  0506				   AI_MoveIsSelected SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	WriteStartPieceBlank
      1  0506				   AI_WriteStartPieceBlank SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	MarchToTargetA
      1  0506				   AI_MarchToTargetA SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	MarchA2
      1  0506				   AI_MarchA2 SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	MarchB
      1  0506				   AI_MarchB  SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	MarchToTargetB
      1  0506				   AI_MarchToTargetB SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	MarchB2
      1  0506				   AI_MarchB2 SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	FinalFlash
      1  0506				   AI_FinalFlash SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	SpecialMoveFixup
      1  0506				   AI_SpecialMoveFixup SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	InCheckBackup
      1  0506				   AI_InCheckBackup SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	InCheckDelay
      1  0506				   AI_InCheckDelay SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	PromotePawnStart
      1  0506				   AI_PromotePawnStart SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	RollPromotionPiece
      1  0506				   AI_RollPromotionPiece SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	ChoosePromotePiece
      1  0506				   AI_ChoosePromotePiece SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	ChooseDebounce
      1  0506				   AI_ChooseDebounce SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	CheckMate
      1  0506				   AI_CheckMate SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	Draw
      1  0506				   AI_Draw    SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	DelayAfterMove
      1  0506				   AI_DelayAfterMove SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	DelayAfterMove2
      1  0506				   AI_DelayAfterMove2 SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	DelayAfterPlaced
      1  0506				   AI_DelayAfterPlaced SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	DelayAfterPlaced2
      1  0506				   AI_DelayAfterPlaced2 SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	EPHandler
      1  0506				   AI_EPHandler SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	EPFlash
      1  0506				   AI_EPFlash SET	P
      2  0506				   P	      SET	P+1
      0  0506					      AIN	DebounceSelect
      1  0506				   AI_DebounceSelect SET	P
      2  0506				   P	      SET	P+1
     46  0506
    348  0506
      0  0506					      DEF	AiVectorLO
      1  0506				   SLOT_AiVectorLO SET	_BANK_SLOT
      2  0506				   BANK_AiVectorLO SET	SLOT_AiVectorLO + _CURRENT_BANK
      3  0506				   AiVectorLO
      4  0506				   TEMPORARY_VAR SET	Overlay
      5  0506				   TEMPORARY_OFFSET SET	0
      6  0506				   VAR_BOUNDARY_AiVectorLO SET	TEMPORARY_OFFSET
      7  0506				   FUNCTION_NAME SET	AiVectorLO
      0  0506					      TABDEF	LO
      1  0506
      0  0506					      LO	FlashComputerMove
      1  0506		       3c		      .byte.b	<aiFlashComputerMove
      0  0507					      LO	BeginSelectMovePhase
      1  0507		       1d		      .byte.b	<aiBeginSelectMovePhase
      0  0508					      LO	SelectStartSquare
      1  0508		       75		      .byte.b	<aiSelectStartSquare
      0  0509					      LO	StartSquareSelected
      1  0509		       b4		      .byte.b	<aiStartSquareSelected
      0  050a					      LO	DrawMoves
      1  050a		       dd		      .byte.b	<aiDrawMoves
      0  050b					      LO	ShowMoveCaptures
      1  050b		       d1		      .byte.b	<aiShowMoveCaptures
      0  050c					      LO	SlowFlash
      1  050c		       f7		      .byte.b	<aiSlowFlash
      0  050d					      LO	UnDrawTargetSquares
      1  050d		       a7		      .byte.b	<aiUnDrawTargetSquares
      0  050e					      LO	SelectDestinationSquare
      1  050e		       20		      .byte.b	<aiSelectDestinationSquare
      0  050f					      LO	Quiescent
      1  050f		       26		      .byte.b	<aiQuiescent
      0  0510					      LO	ReselectDebounce
      1  0510		       14		      .byte.b	<aiReselectDebounce
      0  0511					      LO	StartMoveGen
      1  0511		       00		      .byte.b	<aiStartMoveGen
      0  0512					      LO	StepMoveGen
      1  0512		       ad		      .byte.b	<aiStepMoveGen
      0  0513					      LO	StartClearBoard
      1  0513		       2a		      .byte.b	<aiStartClearBoard
      0  0514					      LO	ClearEachRow
      1  0514		       37		      .byte.b	<aiClearEachRow
      0  0515					      LO	DrawEntireBoard
      1  0515		       bb		      .byte.b	<aiDrawEntireBoard
      0  0516					      LO	DrawPart2
      1  0516		       ef		      .byte.b	<aiDrawPart2
      0  0517					      LO	DrawPart3
      1  0517		       f2		      .byte.b	<aiDrawPart3
      0  0518					      LO	GenerateMoves
      1  0518		       9a		      .byte.b	<aiGenerateMoves
      0  0519					      LO	ComputerMove
      1  0519		       00		      .byte.b	<aiComputerMove
      0  051a					      LO	MoveIsSelected
      1  051a		       44		      .byte.b	<aiMoveIsSelected
      0  051b					      LO	WriteStartPieceBlank
      1  051b		       cf		      .byte.b	<aiWriteStartPieceBlank
      0  051c					      LO	MarchToTargetA
      1  051c		       38		      .byte.b	<aiMarchToTargetA
      0  051d					      LO	MarchA2
      1  051d		       51		      .byte.b	<aiMarchA2
      0  051e					      LO	MarchB
      1  051e		       0c		      .byte.b	<aiMarchB
      0  051f					      LO	MarchToTargetB
      1  051f		       54		      .byte.b	<aiMarchToTargetB
      0  0520					      LO	MarchB2
      1  0520		       7e		      .byte.b	<aiMarchB2
      0  0521					      LO	FinalFlash
      1  0521		       92		      .byte.b	<aiFinalFlash
      0  0522					      LO	SpecialMoveFixup
      1  0522		       56		      .byte.b	<aiSpecialMoveFixup
      0  0523					      LO	InCheckBackup
      1  0523		       05		      .byte.b	<aiInCheckBackup
      0  0524					      LO	InCheckDelay
      1  0524		       10		      .byte.b	<aiInCheckDelay
      0  0525					      LO	PromotePawnStart
      1  0525		       76		      .byte.b	<aiPromotePawnStart
      0  0526					      LO	RollPromotionPiece
      1  0526		       81		      .byte.b	<aiRollPromotionPiece
      0  0527					      LO	ChoosePromotePiece
      1  0527		       d4		      .byte.b	<aiChoosePromotePiece
      0  0528					      LO	ChooseDebounce
      1  0528		       00		      .byte.b	<aiChooseDebounce
      0  0529					      LO	CheckMate
      1  0529		       21		      .byte.b	<aiCheckMate
      0  052a					      LO	Draw
      1  052a		       1c		      .byte.b	<aiDraw
      0  052b					      LO	DelayAfterMove
      1  052b		       1d		      .byte.b	<aiDelayAfterMove
      0  052c					      LO	DelayAfterMove2
      1  052c		       26		      .byte.b	<aiDelayAfterMove2
      0  052d					      LO	DelayAfterPlaced
      1  052d		       2f		      .byte.b	<aiDelayAfterPlaced
      0  052e					      LO	DelayAfterPlaced2
      1  052e		       3f		      .byte.b	<aiDelayAfterPlaced2
      0  052f					      LO	EPHandler
      1  052f		       a2		      .byte.b	<aiEPHandler
      0  0530					      LO	EPFlash
      1  0530		       6e		      .byte.b	<aiEPFlash
      0  0531					      LO	DebounceSelect
      1  0531		       be		      .byte.b	<aiDebounceSelect
     46  0532
    351  0532
      0  0532					      DEF	AiVectorHI
      1  0532				   SLOT_AiVectorHI SET	_BANK_SLOT
      2  0532				   BANK_AiVectorHI SET	SLOT_AiVectorHI + _CURRENT_BANK
      3  0532				   AiVectorHI
      4  0532				   TEMPORARY_VAR SET	Overlay
      5  0532				   TEMPORARY_OFFSET SET	0
      6  0532				   VAR_BOUNDARY_AiVectorHI SET	TEMPORARY_OFFSET
      7  0532				   FUNCTION_NAME SET	AiVectorHI
      0  0532					      TABDEF	HI
      1  0532
      0  0532					      HI	FlashComputerMove
      1  0532		       f4		      .byte.b	>aiFlashComputerMove
      0  0533					      HI	BeginSelectMovePhase
      1  0533		       f4		      .byte.b	>aiBeginSelectMovePhase
      0  0534					      HI	SelectStartSquare
      1  0534		       f4		      .byte.b	>aiSelectStartSquare
      0  0535					      HI	StartSquareSelected
      1  0535		       f5		      .byte.b	>aiStartSquareSelected
      0  0536					      HI	DrawMoves
      1  0536		       f4		      .byte.b	>aiDrawMoves
      0  0537					      HI	ShowMoveCaptures
      1  0537		       f5		      .byte.b	>aiShowMoveCaptures
      0  0538					      HI	SlowFlash
      1  0538		       f5		      .byte.b	>aiSlowFlash
      0  0539					      HI	UnDrawTargetSquares
      1  0539		       f5		      .byte.b	>aiUnDrawTargetSquares
      0  053a					      HI	SelectDestinationSquare
      1  053a		       f6		      .byte.b	>aiSelectDestinationSquare
      0  053b					      HI	Quiescent
      1  053b		       f6		      .byte.b	>aiQuiescent
      0  053c					      HI	ReselectDebounce
      1  053c		       f4		      .byte.b	>aiReselectDebounce
      0  053d					      HI	StartMoveGen
      1  053d		       f4		      .byte.b	>aiStartMoveGen
      0  053e					      HI	StepMoveGen
      1  053e		       f4		      .byte.b	>aiStepMoveGen
      0  053f					      HI	StartClearBoard
      1  053f		       f8		      .byte.b	>aiStartClearBoard
      0  0540					      HI	ClearEachRow
      1  0540		       f8		      .byte.b	>aiClearEachRow
      0  0541					      HI	DrawEntireBoard
      1  0541		       f5		      .byte.b	>aiDrawEntireBoard
      0  0542					      HI	DrawPart2
      1  0542		       f5		      .byte.b	>aiDrawPart2
      0  0543					      HI	DrawPart3
      1  0543		       f5		      .byte.b	>aiDrawPart3
      0  0544					      HI	GenerateMoves
      1  0544		       f4		      .byte.b	>aiGenerateMoves
      0  0545					      HI	ComputerMove
      1  0545		       f4		      .byte.b	>aiComputerMove
      0  0546					      HI	MoveIsSelected
      1  0546		       f8		      .byte.b	>aiMoveIsSelected
      0  0547					      HI	WriteStartPieceBlank
      1  0547		       f5		      .byte.b	>aiWriteStartPieceBlank
      0  0548					      HI	MarchToTargetA
      1  0548		       f5		      .byte.b	>aiMarchToTargetA
      0  0549					      HI	MarchA2
      1  0549		       f7		      .byte.b	>aiMarchA2
      0  054a					      HI	MarchB
      1  054a		       f6		      .byte.b	>aiMarchB
      0  054b					      HI	MarchToTargetB
      1  054b		       f4		      .byte.b	>aiMarchToTargetB
      0  054c					      HI	MarchB2
      1  054c		       f7		      .byte.b	>aiMarchB2
      0  054d					      HI	FinalFlash
      1  054d		       f5		      .byte.b	>aiFinalFlash
      0  054e					      HI	SpecialMoveFixup
      1  054e		       f5		      .byte.b	>aiSpecialMoveFixup
      0  054f					      HI	InCheckBackup
      1  054f		       f4		      .byte.b	>aiInCheckBackup
      0  0550					      HI	InCheckDelay
      1  0550		       f4		      .byte.b	>aiInCheckDelay
      0  0551					      HI	PromotePawnStart
      1  0551		       f4		      .byte.b	>aiPromotePawnStart
      0  0552					      HI	RollPromotionPiece
      1  0552		       f6		      .byte.b	>aiRollPromotionPiece
      0  0553					      HI	ChoosePromotePiece
      1  0553		       f6		      .byte.b	>aiChoosePromotePiece
      0  0554					      HI	ChooseDebounce
      1  0554		       f4		      .byte.b	>aiChooseDebounce
      0  0555					      HI	CheckMate
      1  0555		       f6		      .byte.b	>aiCheckMate
      0  0556					      HI	Draw
      1  0556		       f6		      .byte.b	>aiDraw
      0  0557					      HI	DelayAfterMove
      1  0557		       f4		      .byte.b	>aiDelayAfterMove
      0  0558					      HI	DelayAfterMove2
      1  0558		       f4		      .byte.b	>aiDelayAfterMove2
      0  0559					      HI	DelayAfterPlaced
      1  0559		       f4		      .byte.b	>aiDelayAfterPlaced
      0  055a					      HI	DelayAfterPlaced2
      1  055a		       f4		      .byte.b	>aiDelayAfterPlaced2
      0  055b					      HI	EPHandler
      1  055b		       f7		      .byte.b	>aiEPHandler
      0  055c					      HI	EPFlash
      1  055c		       f5		      .byte.b	>aiEPFlash
      0  055d					      HI	DebounceSelect
      1  055d		       f4		      .byte.b	>aiDebounceSelect
     46  055e
    354  055e
      0  055e					      DEF	AiVectorBANK
      1  055e				   SLOT_AiVectorBANK SET	_BANK_SLOT
      2  055e				   BANK_AiVectorBANK SET	SLOT_AiVectorBANK + _CURRENT_BANK
      3  055e				   AiVectorBANK
      4  055e				   TEMPORARY_VAR SET	Overlay
      5  055e				   TEMPORARY_OFFSET SET	0
      6  055e				   VAR_BOUNDARY_AiVectorBANK SET	TEMPORARY_OFFSET
      7  055e				   FUNCTION_NAME SET	AiVectorBANK
      0  055e					      TABDEF	BK
      1  055e
      0  055e					      BK	FlashComputerMove
      1  055e		       47		      .byte.b	BANK_aiFlashComputerMove
      0  055f					      BK	BeginSelectMovePhase
      1  055f		       47		      .byte.b	BANK_aiBeginSelectMovePhase
      0  0560					      BK	SelectStartSquare
      1  0560		       47		      .byte.b	BANK_aiSelectStartSquare
      0  0561					      BK	StartSquareSelected
      1  0561		       48		      .byte.b	BANK_aiStartSquareSelected
      0  0562					      BK	DrawMoves
      1  0562		       47		      .byte.b	BANK_aiDrawMoves
      0  0563					      BK	ShowMoveCaptures
      1  0563		       47		      .byte.b	BANK_aiShowMoveCaptures
      0  0564					      BK	SlowFlash
      1  0564		       47		      .byte.b	BANK_aiSlowFlash
      0  0565					      BK	UnDrawTargetSquares
      1  0565		       47		      .byte.b	BANK_aiUnDrawTargetSquares
      0  0566					      BK	SelectDestinationSquare
      1  0566		       47		      .byte.b	BANK_aiSelectDestinationSquare
      0  0567					      BK	Quiescent
      1  0567		       42		      .byte.b	BANK_aiQuiescent
      0  0568					      BK	ReselectDebounce
      1  0568		       48		      .byte.b	BANK_aiReselectDebounce
      0  0569					      BK	StartMoveGen
      1  0569		       47		      .byte.b	BANK_aiStartMoveGen
      0  056a					      BK	StepMoveGen
      1  056a		       48		      .byte.b	BANK_aiStepMoveGen
      0  056b					      BK	StartClearBoard
      1  056b		       92		      .byte.b	BANK_aiStartClearBoard
      0  056c					      BK	ClearEachRow
      1  056c		       92		      .byte.b	BANK_aiClearEachRow
      0  056d					      BK	DrawEntireBoard
      1  056d		       42		      .byte.b	BANK_aiDrawEntireBoard
      0  056e					      BK	DrawPart2
      1  056e		       42		      .byte.b	BANK_aiDrawPart2
      0  056f					      BK	DrawPart3
      1  056f		       42		      .byte.b	BANK_aiDrawPart3
      0  0570					      BK	GenerateMoves
      1  0570		       48		      .byte.b	BANK_aiGenerateMoves
      0  0571					      BK	ComputerMove
      1  0571		       58		      .byte.b	BANK_aiComputerMove
      0  0572					      BK	MoveIsSelected
      1  0572		       92		      .byte.b	BANK_aiMoveIsSelected
      0  0573					      BK	WriteStartPieceBlank
      1  0573		       48		      .byte.b	BANK_aiWriteStartPieceBlank
      0  0574					      BK	MarchToTargetA
      1  0574		       48		      .byte.b	BANK_aiMarchToTargetA
      0  0575					      BK	MarchA2
      1  0575		       47		      .byte.b	BANK_aiMarchA2
      0  0576					      BK	MarchB
      1  0576		       42		      .byte.b	BANK_aiMarchB
      0  0577					      BK	MarchToTargetB
      1  0577		       48		      .byte.b	BANK_aiMarchToTargetB
      0  0578					      BK	MarchB2
      1  0578		       47		      .byte.b	BANK_aiMarchB2
      0  0579					      BK	FinalFlash
      1  0579		       48		      .byte.b	BANK_aiFinalFlash
      0  057a					      BK	SpecialMoveFixup
      1  057a		       42		      .byte.b	BANK_aiSpecialMoveFixup
      0  057b					      BK	InCheckBackup
      1  057b		       47		      .byte.b	BANK_aiInCheckBackup
      0  057c					      BK	InCheckDelay
      1  057c		       47		      .byte.b	BANK_aiInCheckDelay
      0  057d					      BK	PromotePawnStart
      1  057d		       48		      .byte.b	BANK_aiPromotePawnStart
      0  057e					      BK	RollPromotionPiece
      1  057e		       47		      .byte.b	BANK_aiRollPromotionPiece
      0  057f					      BK	ChoosePromotePiece
      1  057f		       47		      .byte.b	BANK_aiChoosePromotePiece
      0  0580					      BK	ChooseDebounce
      1  0580		       48		      .byte.b	BANK_aiChooseDebounce
      0  0581					      BK	CheckMate
      1  0581		       42		      .byte.b	BANK_aiCheckMate
      0  0582					      BK	Draw
      1  0582		       42		      .byte.b	BANK_aiDraw
      0  0583					      BK	DelayAfterMove
      1  0583		       48		      .byte.b	BANK_aiDelayAfterMove
      0  0584					      BK	DelayAfterMove2
      1  0584		       48		      .byte.b	BANK_aiDelayAfterMove2
      0  0585					      BK	DelayAfterPlaced
      1  0585		       48		      .byte.b	BANK_aiDelayAfterPlaced
      0  0586					      BK	DelayAfterPlaced2
      1  0586		       48		      .byte.b	BANK_aiDelayAfterPlaced2
      0  0587					      BK	EPHandler
      1  0587		       47		      .byte.b	BANK_aiEPHandler
      0  0588					      BK	EPFlash
      1  0588		       42		      .byte.b	BANK_aiEPFlash
      0  0589					      BK	DebounceSelect
      1  0589		       47		      .byte.b	BANK_aiDebounceSelect
     46  058a
    357  058a
    358  058a
    359  058a							;---------------------------------------------------------------------------------------------------
    360  058a
      0  058a					      DEF	AiStateMachine
      1  058a				   SLOT_AiStateMachine SET	_BANK_SLOT
      2  058a				   BANK_AiStateMachine SET	SLOT_AiStateMachine + _CURRENT_BANK
      3  058a				   AiStateMachine
      4  058a				   TEMPORARY_VAR SET	Overlay
      5  058a				   TEMPORARY_OFFSET SET	0
      6  058a				   VAR_BOUNDARY_AiStateMachine SET	TEMPORARY_OFFSET
      7  058a				   FUNCTION_NAME SET	AiStateMachine
    362  058a					      SUBROUTINE
    363  058a
      0  058a					      REFER	StartupBankReset	;✅
      1  058a				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  058a				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  058a					      ENDIF
      0  058a					      VAR	__aiVec, 2
      1  058a		       00 a7	   __aiVec    =	TEMPORARY_VAR
      2  058a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  058a
      4  058a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  058a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  058a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  058a					      ENDIF
      8  058a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  058a				  -	      ECHO	"Temporary Variable", __aiVec, "overflow!"
     10  058a				  -	      ERR
     11  058a					      ENDIF
     12  058a					      LIST	ON
      0  058a					      VEND	AiStateMachine
      1  058a				  -	      IFNCONST	AiStateMachine
      2  058a				  -	      ECHO	"Incorrect VEND label", AiStateMachine
      3  058a				  -	      ERR
      4  058a					      ENDIF
      5  058a		       00 a9	   VAREND_AiStateMachine =	TEMPORARY_VAR
    367  058a
    368  058a
    369  058a							; State machine vector setup - points to current routine to execute
    370  058a
    371  058a		       a6 8b		      ldx	aiState
    372  058c		       bd 06 f1 	      lda	AiVectorLO,x
    373  058f		       85 a7		      sta	__aiVec
    374  0591		       bd 32 f1 	      lda	AiVectorHI,x
    375  0594		       85 a8		      sta	__aiVec+1
    376  0596
    377  0596		       bd 5e f1 	      lda	AiVectorBANK,x
    378  0599		       85 3f		      sta	SET_BANK
    379  059b		       6c a7 00 	      jmp	(__aiVec)	; NOTE: could branch back to squeeze cycles
    380  059e
    381  059e
    382  059e							;---------------------------------------------------------------------------------------------------
    383  059e
      0  059e					      DEF	GenerateAllMoves
      1  059e				   SLOT_GenerateAllMoves SET	_BANK_SLOT
      2  059e				   BANK_GenerateAllMoves SET	SLOT_GenerateAllMoves + _CURRENT_BANK
      3  059e				   GenerateAllMoves
      4  059e				   TEMPORARY_VAR SET	Overlay
      5  059e				   TEMPORARY_OFFSET SET	0
      6  059e				   VAR_BOUNDARY_GenerateAllMoves SET	TEMPORARY_OFFSET
      7  059e				   FUNCTION_NAME SET	GenerateAllMoves
    385  059e					      SUBROUTINE
    386  059e
      0  059e					      REFER	ListPlayerMoves	;✅
      1  059e					      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  059e				   TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  059e					      ENDIF
      0  059e					      REFER	aiComputerMove	;✅
      1  059e				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  059e				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  059e					      ENDIF
      0  059e					      REFER	quiesce	;✅
      1  059e				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  059e				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  059e					      ENDIF
      0  059e					      REFER	negaMax	;✅
      1  059e				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  059e				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  059e					      ENDIF
    391  059e
      0  059e					      VAR	__vector, 2
      1  059e		       00 b5	   __vector   =	TEMPORARY_VAR
      2  059e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  059e
      4  059e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  059e					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  059e				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  059e					      ENDIF
      8  059e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  059e				  -	      ECHO	"Temporary Variable", __vector, "overflow!"
     10  059e				  -	      ERR
     11  059e					      ENDIF
     12  059e					      LIST	ON
      0  059e					      VAR	__pieceFilter, 1
      1  059e		       00 b7	   __pieceFilter =	TEMPORARY_VAR
      2  059e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  059e
      4  059e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  059e					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  059e				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  059e					      ENDIF
      8  059e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  059e				  -	      ECHO	"Temporary Variable", __pieceFilter, "overflow!"
     10  059e				  -	      ERR
     11  059e					      ENDIF
     12  059e					      LIST	ON
    394  059e
      0  059e					      VEND	GenerateAllMoves
      1  059e				  -	      IFNCONST	GenerateAllMoves
      2  059e				  -	      ECHO	"Incorrect VEND label", GenerateAllMoves
      3  059e				  -	      ERR
      4  059e					      ENDIF
      5  059e		       00 b8	   VAREND_GenerateAllMoves =	TEMPORARY_VAR
    396  059e
    397  059e							; Do the move generation in two passes - pawns then pieces
    398  059e							; This is an effort to get the alphabeta pruning happening with major pieces handled first in list
    399  059e
    400  059e							;{
    401  059e
    402  059e							; This MUST be called at the start of a new ply
    403  059e							; It initialises the movelist to empty
    404  059e							; x must be preserved
    405  059e
    406  059e		       a5 94		      lda	currentPly
    407  05a0		       85 3e		      sta	SET_BANK_RAM	;@2
    408  05a2
    409  05a2							; note that 'alpha' and 'beta' are set externally!!
    410  05a2
    411  05a2		       a9 ff		      lda	#-1
      0  05a4					      sta@PLY	moveIndex	; no valid moves
      1  05a4		       8d cf fb 	      sta	[RAM]+moveIndex
      0  05a7					      sta@PLY	bestMove
      1  05a7		       8d d1 fb 	      sta	[RAM]+bestMove
    414  05aa
    415  05aa		       a5 93		      lda	enPassantPawn	; flag/square from last actual move made
      0  05ac					      sta@PLY	enPassantSquare	; used for backtracking, to reset the flag
      1  05ac		       8d ca fb 	      sta	[RAM]+enPassantSquare
    417  05af
    418  05af		       a5 a4		      lda	vkSquare
      0  05b1					      sta@PLY	virtualKingSquare
      1  05b1		       8d da fb 	      sta	[RAM]+virtualKingSquare
    420  05b4		       a5 a5		      lda	vkSquare+1
      0  05b6					      sta@PLY	virtualKingSquare+1	; traversal squares of king for castling
      1  05b6		       8d db fb 	      sta	[RAM]+virtualKingSquare+1
    422  05b9
    423  05b9							; The value of the material (signed, 16-bit) is restored to the saved value at the reversion
    424  05b9							; of a move. It's quicker to restore than to re-sum. So we save the current evaluation at the
    425  05b9							; start of each new ply.
    426  05b9
    427  05b9		       a5 8f		      lda	Evaluation
      0  05bb					      sta@PLY	savedEvaluation
      1  05bb		       8d c8 fb 	      sta	[RAM]+savedEvaluation
    429  05be		       a5 90		      lda	Evaluation+1
      0  05c0					      sta@PLY	savedEvaluation+1
      1  05c0		       8d c9 fb 	      sta	[RAM]+savedEvaluation+1
    431  05c3							;}
    432  05c3
    433  05c3
    434  05c3
    435  05c3		       a9 08		      lda	#8	; pawns
    436  05c5		       85 b7		      sta	__pieceFilter
    437  05c7		       20 d8 f1 	      jsr	MoveGenX
    438  05ca							;lda #99
    439  05ca							;sta currentSquare
    440  05ca		       a9 00		      lda	#0
    441  05cc		       85 b7		      sta	__pieceFilter
    442  05ce		       20 d8 f1 	      jsr	MoveGenX
    443  05d1
    444  05d1		       a9 58		      lda	#BANK_Sort
    445  05d3		       85 3f		      sta	SET_BANK
    446  05d5		       4c 32 f6 	      jmp	Sort	;@1
    447  05d8
    448  05d8
    449  05d8
      0  05d8					      DEF	MoveGenX
      1  05d8				   SLOT_MoveGenX SET	_BANK_SLOT
      2  05d8				   BANK_MoveGenX SET	SLOT_MoveGenX + _CURRENT_BANK
      3  05d8				   MoveGenX
      4  05d8				   TEMPORARY_VAR SET	Overlay
      5  05d8				   TEMPORARY_OFFSET SET	0
      6  05d8				   VAR_BOUNDARY_MoveGenX SET	TEMPORARY_OFFSET
      7  05d8				   FUNCTION_NAME SET	MoveGenX
    451  05d8					      SUBROUTINE
    452  05d8
    453  05d8		       a9 d1		      lda	#RAMBANK_BOARD
    454  05da		       85 3e		      sta	SET_BANK_RAM	;@3		 ; should be hardwired forever, right?
    455  05dc
    456  05dc		       a2 64		      ldx	#100
    457  05de		       d0 02		      bne	.next
    458  05e0
      0  05e0					      DEF	MoveReturn
      1  05e0				   SLOT_MoveReturn SET	_BANK_SLOT
      2  05e0				   BANK_MoveReturn SET	SLOT_MoveReturn + _CURRENT_BANK
      3  05e0				   MoveReturn
      4  05e0				   TEMPORARY_VAR SET	Overlay
      5  05e0				   TEMPORARY_OFFSET SET	0
      6  05e0				   VAR_BOUNDARY_MoveReturn SET	TEMPORARY_OFFSET
      7  05e0				   FUNCTION_NAME SET	MoveReturn
    460  05e0
    461  05e0		       a6 92		      ldx	currentSquare
    462  05e2		       ca	   .next      dex
    463  05e3		       e0 16		      cpx	#22
    464  05e5		       90 2c		      bcc	.exit
    465  05e7
    466  05e7		       bd 79 fc 	      lda	Board,x
    467  05ea		       f0 f6		      beq	.next
    468  05ec		       c9 ff		      cmp	#-1
    469  05ee		       f0 f2		      beq	.next
    470  05f0		       45 95		      eor	sideToMove
    471  05f2		       30 ee		      bmi	.next
    472  05f4
    473  05f4		       86 92		      stx	currentSquare
    474  05f6
    475  05f6		       45 95		      eor	sideToMove
    476  05f8		       29 ef		      and	#~FLAG_CASTLE	; todo: better part of the move, mmh?
    477  05fa		       85 91		      sta	currentPiece
    478  05fc		       29 0f		      and	#PIECE_MASK
    479  05fe		       05 b7		      ora	__pieceFilter
    480  0600		       a8		      tay
    481  0601
    482  0601		       b9 28 f2 	      lda	HandlerVectorHI,y
    483  0604		       85 b6		      sta	__vector+1
    484  0606		       b9 18 f2 	      lda	HandlerVectorLO,y
    485  0609		       85 b5		      sta	__vector
    486  060b
    487  060b		       b9 38 f2 	      lda	HandlerVectorBANK,y
    488  060e		       85 3f		      sta	SET_BANK	;@1
    489  0610
    490  0610		       6c b5 00 	      jmp	(__vector)
    491  0613
    492  0613
    493  0613		       a9 58	   .exit      lda	#BANK_negaMax
    494  0615		       85 3f		      sta	SET_BANK
    495  0617		       60		      rts
    496  0618
    497  0618					      MAC	handlevec
    498  0618
    499  0618					      .byte	{1}MoveReturn
    500  0618					      .byte	{1}MoveReturn	;byte {1}Handle_WHITE_PAWN	   ; 1
    501  0618					      .byte	{1}MoveReturn	;.byte {1}Handle_BLACK_PAWN	    ; 2
    502  0618					      .byte	{1}Handle_KNIGHT	; 3
    503  0618					      .byte	{1}Handle_BISHOP	; 4
    504  0618					      .byte	{1}Handle_ROOK	; 5
    505  0618					      .byte	{1}Handle_QUEEN	; 6
    506  0618					      .byte	{1}Handle_KING	; 7
    507  0618
    508  0618					      .byte	{1}MoveReturn
    509  0618					      .byte	{1}Handle_WHITE_PAWN	; 1
    510  0618					      .byte	{1}Handle_BLACK_PAWN	; 2
    511  0618					      .byte	{1}MoveReturn	;.byte {1}Handle_KNIGHT	    ; 3
    512  0618					      .byte	{1}MoveReturn	;.byte {1}Handle_BISHOP	    ; 4
    513  0618					      .byte	{1}MoveReturn	;.byte {1}Handle_ROOK		    ; 5
    514  0618					      .byte	{1}MoveReturn	;.byte {1}Handle_QUEEN 	    ; 6
    515  0618					      .byte	{1}MoveReturn	;.byte {1}Handle_KING		    ; 7
    516  0618					      ENDM
    517  0618
    518  0618
    519  0618							;    .byte 0	  ; dummy to prevent page cross access on index 0
    520  0618
      0  0618					      DEF	HandlerVectorLO
      1  0618				   SLOT_HandlerVectorLO SET	_BANK_SLOT
      2  0618				   BANK_HandlerVectorLO SET	SLOT_HandlerVectorLO + _CURRENT_BANK
      3  0618				   HandlerVectorLO
      4  0618				   TEMPORARY_VAR SET	Overlay
      5  0618				   TEMPORARY_OFFSET SET	0
      6  0618				   VAR_BOUNDARY_HandlerVectorLO SET	TEMPORARY_OFFSET
      7  0618				   FUNCTION_NAME SET	HandlerVectorLO
      0  0618					      HANDLEVEC	<
      1  0618
      2  0618		       e0		      .byte.b	<MoveReturn
      3  0619		       e0		      .byte.b	<MoveReturn
      4  061a		       e0		      .byte.b	<MoveReturn
      5  061b		       a8		      .byte.b	<Handle_KNIGHT
      6  061c		       51		      .byte.b	<Handle_BISHOP
      7  061d		       00		      .byte.b	<Handle_ROOK
      8  061e		       7b		      .byte.b	<Handle_QUEEN
      9  061f		       6e		      .byte.b	<Handle_KING
     10  0620
     11  0620		       e0		      .byte.b	<MoveReturn
     12  0621		       29		      .byte.b	<Handle_WHITE_PAWN
     13  0622		       fd		      .byte.b	<Handle_BLACK_PAWN
     14  0623		       e0		      .byte.b	<MoveReturn
     15  0624		       e0		      .byte.b	<MoveReturn
     16  0625		       e0		      .byte.b	<MoveReturn
     17  0626		       e0		      .byte.b	<MoveReturn
     18  0627		       e0		      .byte.b	<MoveReturn
      0  0628					      DEF	HandlerVectorHI
      1  0628				   SLOT_HandlerVectorHI SET	_BANK_SLOT
      2  0628				   BANK_HandlerVectorHI SET	SLOT_HandlerVectorHI + _CURRENT_BANK
      3  0628				   HandlerVectorHI
      4  0628				   TEMPORARY_VAR SET	Overlay
      5  0628				   TEMPORARY_OFFSET SET	0
      6  0628				   VAR_BOUNDARY_HandlerVectorHI SET	TEMPORARY_OFFSET
      7  0628				   FUNCTION_NAME SET	HandlerVectorHI
      0  0628					      HANDLEVEC	>
      1  0628
      2  0628		       f1		      .byte.b	>MoveReturn
      3  0629		       f1		      .byte.b	>MoveReturn
      4  062a		       f1		      .byte.b	>MoveReturn
      5  062b		       f5		      .byte.b	>Handle_KNIGHT
      6  062c		       f6		      .byte.b	>Handle_BISHOP
      7  062d		       f4		      .byte.b	>Handle_ROOK
      8  062e		       f4		      .byte.b	>Handle_QUEEN
      9  062f		       f5		      .byte.b	>Handle_KING
     10  0630
     11  0630		       f1		      .byte.b	>MoveReturn
     12  0631		       f4		      .byte.b	>Handle_WHITE_PAWN
     13  0632		       f4		      .byte.b	>Handle_BLACK_PAWN
     14  0633		       f1		      .byte.b	>MoveReturn
     15  0634		       f1		      .byte.b	>MoveReturn
     16  0635		       f1		      .byte.b	>MoveReturn
     17  0636		       f1		      .byte.b	>MoveReturn
     18  0637		       f1		      .byte.b	>MoveReturn
      0  0638					      DEF	HandlerVectorBANK
      1  0638				   SLOT_HandlerVectorBANK SET	_BANK_SLOT
      2  0638				   BANK_HandlerVectorBANK SET	SLOT_HandlerVectorBANK + _CURRENT_BANK
      3  0638				   HandlerVectorBANK
      4  0638				   TEMPORARY_VAR SET	Overlay
      5  0638				   TEMPORARY_OFFSET SET	0
      6  0638				   VAR_BOUNDARY_HandlerVectorBANK SET	TEMPORARY_OFFSET
      7  0638				   FUNCTION_NAME SET	HandlerVectorBANK
      0  0638					      HANDLEVEC	BANK_
      1  0638
      2  0638		       01		      .byte.b	BANK_MoveReturn
      3  0639		       01		      .byte.b	BANK_MoveReturn
      4  063a		       01		      .byte.b	BANK_MoveReturn
      5  063b		       59		      .byte.b	BANK_Handle_KNIGHT
      6  063c		       59		      .byte.b	BANK_Handle_BISHOP
      7  063d		       5a		      .byte.b	BANK_Handle_ROOK
      8  063e		       5a		      .byte.b	BANK_Handle_QUEEN
      9  063f		       5a		      .byte.b	BANK_Handle_KING
     10  0640
     11  0640		       01		      .byte.b	BANK_MoveReturn
     12  0641		       59		      .byte.b	BANK_Handle_WHITE_PAWN
     13  0642		       59		      .byte.b	BANK_Handle_BLACK_PAWN
     14  0643		       01		      .byte.b	BANK_MoveReturn
     15  0644		       01		      .byte.b	BANK_MoveReturn
     16  0645		       01		      .byte.b	BANK_MoveReturn
     17  0646		       01		      .byte.b	BANK_MoveReturn
     18  0647		       01		      .byte.b	BANK_MoveReturn
    527  0648
    528  0648
    529  0648							;---------------------------------------------------------------------------------------------------
    530  0648
      0  0648					      DEF	ListPlayerMoves
      1  0648				   SLOT_ListPlayerMoves SET	_BANK_SLOT
      2  0648				   BANK_ListPlayerMoves SET	SLOT_ListPlayerMoves + _CURRENT_BANK
      3  0648				   ListPlayerMoves
      4  0648				   TEMPORARY_VAR SET	Overlay
      5  0648				   TEMPORARY_OFFSET SET	0
      6  0648				   VAR_BOUNDARY_ListPlayerMoves SET	TEMPORARY_OFFSET
      7  0648				   FUNCTION_NAME SET	ListPlayerMoves
    532  0648					      SUBROUTINE
    533  0648
    534  0648							; Build a list of (mostly) valid player moves. The list of all moves is generated, and then
    535  0648							; these are each verified by making the move and listing all opponent moves. If the opponent
    536  0648							; can capture the king, the move is invalidated by setting its "from" square to zero.
    537  0648
    538  0648							; The movelist is built in the second ply so as not to stomp on the movelist from the computer
    539  0648							; on the previous response. This allows the player movelist to be generated BEFORE the
    540  0648							; computer's move has been visually shown on the screen.
    541  0648
    542  0648							; This in turn requires the minimum memory for PLY banks to be 3 (computer, player, response)
    543  0648
      0  0648					      COMMON_VARS
      1  0648
      0  0648					      VAR	__thinkbar, 1
      1  0648		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  0648				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0648
      4  0648				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0648				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0648				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0648					      ENDIF
      8  0648				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0648				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  0648				  -	      ERR
     11  0648					      ENDIF
     12  0648					      LIST	ON
      0  0648					      VAR	__toggle, 1
      1  0648		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  0648				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0648
      4  0648				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0648				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0648				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0648					      ENDIF
      8  0648				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0648				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  0648				  -	      ERR
     11  0648					      ENDIF
     12  0648					      LIST	ON
      4  0648
      0  0648					      VAR	__bestMove, 1
      1  0648		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  0648				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0648
      4  0648				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0648				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0648				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0648					      ENDIF
      8  0648				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0648				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  0648				  -	      ERR
     11  0648					      ENDIF
     12  0648					      LIST	ON
      0  0648					      VAR	__alpha, 2
      1  0648		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  0648				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0648
      4  0648				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0648				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0648				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0648					      ENDIF
      8  0648				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0648				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  0648				  -	      ERR
     11  0648					      ENDIF
     12  0648					      LIST	ON
      0  0648					      VAR	__beta, 2
      1  0648		       00 ac	   __beta     =	TEMPORARY_VAR
      2  0648				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0648
      4  0648				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0648				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0648				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0648					      ENDIF
      8  0648				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0648				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  0648				  -	      ERR
     11  0648					      ENDIF
     12  0648					      LIST	ON
      0  0648					      VAR	__negaMax, 2
      1  0648		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  0648				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0648
      4  0648				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0648				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0648				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0648					      ENDIF
      8  0648				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0648				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  0648				  -	      ERR
     11  0648					      ENDIF
     12  0648					      LIST	ON
      0  0648					      VAR	__value, 2
      1  0648		       00 b0	   __value    =	TEMPORARY_VAR
      2  0648				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0648
      4  0648				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0648				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0648				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0648					      ENDIF
      8  0648				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0648				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  0648				  -	      ERR
     11  0648					      ENDIF
     12  0648					      LIST	ON
     10  0648
      0  0648					      VAR	__quiesceCapOnly, 1
      1  0648		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  0648				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0648
      4  0648				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0648				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0648				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0648					      ENDIF
      8  0648				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0648				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  0648				  -	      ERR
     11  0648					      ENDIF
     12  0648					      LIST	ON
     12  0648
      0  0648					      VAR	__originalPiece, 1
      1  0648		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  0648				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0648
      4  0648				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0648				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0648				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0648					      ENDIF
      8  0648				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0648				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  0648				  -	      ERR
     11  0648					      ENDIF
     12  0648					      LIST	ON
      0  0648					      VAR	__capturedPiece, 1
      1  0648		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  0648				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0648
      4  0648				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0648				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0648				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0648					      ENDIF
      8  0648				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0648				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  0648				  -	      ERR
     11  0648					      ENDIF
     12  0648					      LIST	ON
     15  0648
      0  0648					      REFER	selectmove	;✅
      1  0648				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  0648				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  0648					      ENDIF
      0  0648					      REFER	StartupBankReset	;✅
      1  0648				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0648				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0648					      ENDIF
    547  0648
      0  0648					      VEND	ListPlayerMoves
      1  0648				  -	      IFNCONST	ListPlayerMoves
      2  0648				  -	      ECHO	"Incorrect VEND label", ListPlayerMoves
      3  0648				  -	      ERR
      4  0648					      ENDIF
      5  0648		       00 b5	   VAREND_ListPlayerMoves =	TEMPORARY_VAR
    549  0648
    550  0648
    551  0648		       a9 00		      lda	#0
    552  064a		       85 b2		      sta	__quiesceCapOnly	; gen ALL moves
    553  064c
    554  064c		       a9 89		      lda	#RAMBANK_PLY+1
    555  064e		       85 94		      sta	currentPly
    556  0650
    557  0650		       20 9e f1 	      jsr	GenerateAllMoves	;@this
    558  0653
      0  0653					      ldx@PLY	moveIndex
      1  0653		       ae cf f9 	      ldx	moveIndex
      0  0656				   .scan      stx@PLY	movePtr
      1  0656		       8e d0 fb 	      stx	[RAM]+movePtr
    561  0659
      0  0659					      CALL	MakeMove	;@1
      1  0659				  -	      IF	SLOT_MakeMove == _BANK_SLOT
      2  0659				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0659				  -	      ECHO	"Cannot switch bank in use for", MakeMove
      4  0659				  -	      ERR
      5  0659					      ENDIF
      6  0659		       a9 58		      lda	#BANK_MakeMove
      7  065b		       85 3f		      sta	SET_BANK
      8  065d		       20 8b f4 	      jsr	MakeMove
    563  0660
    564  0660		       e6 94		      inc	currentPly
    565  0662		       20 9e f1 	      jsr	GenerateAllMoves	;@this
    566  0665
    567  0665		       c6 94		      dec	currentPly
    568  0667
    569  0667		       20 a5 f2 	      jsr	unmakeMove	;@this
    570  066a
    571  066a		       a5 9f		      lda	flagCheck
    572  066c		       f0 08		      beq	.next
    573  066e
      0  066e					      ldx@PLY	movePtr
      1  066e		       ae d0 f9 	      ldx	movePtr
    575  0671		       a9 00		      lda	#0
      0  0673					      sta@PLY	MoveFrom,x	; invalidate move (still in check!)
      1  0673		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
    577  0676
      0  0676				   .next      ldx@PLY	movePtr
      1  0676		       ae d0 f9 	      ldx	movePtr
    579  0679		       ca		      dex
    580  067a		       10 da		      bpl	.scan
    581  067c
    582  067c		       60		      rts
    583  067d
    584  067d
    585  067d							;---------------------------------------------------------------------------------------------------
    586  067d
      0  067d					      DEF	AddMove
      1  067d				   SLOT_AddMove SET	_BANK_SLOT
      2  067d				   BANK_AddMove SET	SLOT_AddMove + _CURRENT_BANK
      3  067d				   AddMove
      4  067d				   TEMPORARY_VAR SET	Overlay
      5  067d				   TEMPORARY_OFFSET SET	0
      6  067d				   VAR_BOUNDARY_AddMove SET	TEMPORARY_OFFSET
      7  067d				   FUNCTION_NAME SET	AddMove
    588  067d					      SUBROUTINE
    589  067d
      0  067d					      REFER	Handle_KING	;✅
      1  067d					      IF	VAREND_Handle_KING > TEMPORARY_VAR
      2  067d				   TEMPORARY_VAR SET	VAREND_Handle_KING
      3  067d					      ENDIF
      0  067d					      REFER	Handle_QUEEN	;✅
      1  067d				  -	      IF	VAREND_Handle_QUEEN > TEMPORARY_VAR
      2  067d				  -TEMPORARY_VAR SET	VAREND_Handle_QUEEN
      3  067d					      ENDIF
      0  067d					      REFER	Handle_ROOK	;✅
      1  067d				  -	      IF	VAREND_Handle_ROOK > TEMPORARY_VAR
      2  067d				  -TEMPORARY_VAR SET	VAREND_Handle_ROOK
      3  067d					      ENDIF
      0  067d					      REFER	Handle_BISHOP	;✅
      1  067d				  -	      IF	VAREND_Handle_BISHOP > TEMPORARY_VAR
      2  067d				  -TEMPORARY_VAR SET	VAREND_Handle_BISHOP
      3  067d					      ENDIF
      0  067d					      REFER	Handle_KNIGHT	;✅
      1  067d				  -	      IF	VAREND_Handle_KNIGHT > TEMPORARY_VAR
      2  067d				  -TEMPORARY_VAR SET	VAREND_Handle_KNIGHT
      3  067d					      ENDIF
      0  067d					      REFER	Handle_WHITE_PAWN	;✅
      1  067d				  -	      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  067d				  -TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  067d					      ENDIF
      0  067d					      REFER	Handle_BLACK_PAWN	;✅
      1  067d				  -	      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  067d				  -TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  067d					      ENDIF
    597  067d
      0  067d					      VEND	AddMove
      1  067d				  -	      IFNCONST	AddMove
      2  067d				  -	      ECHO	"Incorrect VEND label", AddMove
      3  067d				  -	      ERR
      4  067d					      ENDIF
      5  067d		       00 b8	   VAREND_AddMove =	TEMPORARY_VAR
    599  067d
    600  067d							; add square in y register to movelist as destination (X12 format)
    601  067d							; [y]		     to square (X12)
    602  067d							; currentSquare     from square (X12)
    603  067d							; currentPiece      piece.
    604  067d							;   ENPASSANT flag set if pawn double-moving off opening rank
    605  067d							; capture	     captured piece
    606  067d
    607  067d
    608  067d		       a5 9b		      lda	capture
    609  067f		       d0 04		      bne	.always
    610  0681		       a5 b2		      lda	__quiesceCapOnly
    611  0683		       d0 1c		      bne	.abort
    612  0685
    613  0685		       98	   .always    tya
    614  0686		       aa		      tax
    615  0687
      0  0687					      ldy@PLY	moveIndex
      1  0687		       ac cf f9 	      ldy	moveIndex
    617  068a		       c8		      iny
      0  068b					      sty@PLY	moveIndex
      1  068b		       8c cf fb 	      sty	[RAM]+moveIndex
    619  068e
      0  068e					      sta@PLY	MoveTo,y
      1  068e		       99 64 fa 	      sta	[RAM]+MoveTo,y
    621  0691		       a5 92		      lda	currentSquare
      0  0693					      sta@PLY	MoveFrom,y
      1  0693		       99 00 fa 	      sta	[RAM]+MoveFrom,y
    623  0696		       a5 91		      lda	currentPiece
      0  0698					      sta@PLY	MovePiece,y
      1  0698		       99 00 fb 	      sta	[RAM]+MovePiece,y
    625  069b		       a5 9b		      lda	capture
      0  069d					      sta@PLY	MoveCapture,y
      1  069d		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    627  06a0		       60		      rts
    628  06a1
    629  06a1		       98	   .abort     tya
    630  06a2		       aa		      tax
    631  06a3		       60		      rts
    632  06a4
    633  06a4
    634  06a4
    635  06a4							;---------------------------------------------------------------------------------------------------
    636  06a4
      0  06a4					      DEF	debug
      1  06a4				   SLOT_debug SET	_BANK_SLOT
      2  06a4				   BANK_debug SET	SLOT_debug + _CURRENT_BANK
      3  06a4				   debug
      4  06a4				   TEMPORARY_VAR SET	Overlay
      5  06a4				   TEMPORARY_OFFSET SET	0
      6  06a4				   VAR_BOUNDARY_debug SET	TEMPORARY_OFFSET
      7  06a4				   FUNCTION_NAME SET	debug
    638  06a4					      SUBROUTINE
    639  06a4		       60		      rts
    640  06a5
    641  06a5
    642  06a5							;---------------------------------------------------------------------------------------------------
    643  06a5
      0  06a5					      DEF	unmakeMove
      1  06a5				   SLOT_unmakeMove SET	_BANK_SLOT
      2  06a5				   BANK_unmakeMove SET	SLOT_unmakeMove + _CURRENT_BANK
      3  06a5				   unmakeMove
      4  06a5				   TEMPORARY_VAR SET	Overlay
      5  06a5				   TEMPORARY_OFFSET SET	0
      6  06a5				   VAR_BOUNDARY_unmakeMove SET	TEMPORARY_OFFSET
      7  06a5				   FUNCTION_NAME SET	unmakeMove
    645  06a5					      SUBROUTINE
    646  06a5
      0  06a5					      REFER	selectmove	;✅
      1  06a5					      IF	VAREND_selectmove > TEMPORARY_VAR
      2  06a5				   TEMPORARY_VAR SET	VAREND_selectmove
      3  06a5					      ENDIF
      0  06a5					      REFER	ListPlayerMoves	;✅
      1  06a5				  -	      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  06a5				  -TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  06a5					      ENDIF
      0  06a5					      REFER	quiesce	;✅
      1  06a5				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  06a5				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  06a5					      ENDIF
      0  06a5					      REFER	negaMax	;✅
      1  06a5				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  06a5				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  06a5					      ENDIF
      0  06a5					      VEND	unmakeMove
      1  06a5				  -	      IFNCONST	unmakeMove
      2  06a5				  -	      ECHO	"Incorrect VEND label", unmakeMove
      3  06a5				  -	      ERR
      4  06a5					      ENDIF
      5  06a5		       00 b5	   VAREND_unmakeMove =	TEMPORARY_VAR
    652  06a5
    653  06a5							; restore the board evaluation to what it was at the start of this ply
    654  06a5							; TODO: note: moved flag seems wrong on restoration??
    655  06a5
    656  06a5		       a5 94		      lda	currentPly
    657  06a7		       85 3e		      sta	SET_BANK_RAM	;@2
    658  06a9		       a2 d1		      ldx	#RAMBANK_BOARD
    659  06ab		       86 3e		      stx	SET_BANK_RAM	;@3
    660  06ad
      0  06ad					      lda@PLY	savedEvaluation
      1  06ad		       ad c8 f9 	      lda	savedEvaluation
    662  06b0		       85 8f		      sta	Evaluation
      0  06b2					      lda@PLY	savedEvaluation+1
      1  06b2		       ad c9 f9 	      lda	savedEvaluation+1
    664  06b5		       85 90		      sta	Evaluation+1
    665  06b7
      0  06b7					      lda@PLY	virtualKingSquare
      1  06b7		       ad da f9 	      lda	virtualKingSquare
    667  06ba		       85 a4		      sta	vkSquare
      0  06bc					      lda@PLY	virtualKingSquare+1
      1  06bc		       ad db f9 	      lda	virtualKingSquare+1
    669  06bf		       85 a5		      sta	vkSquare+1
    670  06c1
      0  06c1					      lda@PLY	enPassantSquare
      1  06c1		       ad ca f9 	      lda	enPassantSquare
    672  06c4		       85 93		      sta	enPassantPawn
    673  06c6
      0  06c6					      ldx@PLY	movePtr
      1  06c6		       ae d0 f9 	      ldx	movePtr
      0  06c9					      ldy@PLY	MoveFrom,x
      1  06c9		       bc 00 f8 	      ldy	MoveFrom,x
      0  06cc					      lda@PLY	restorePiece
      1  06cc		       ad d9 f9 	      lda	restorePiece
      0  06cf					      sta@RAM	Board,y
      1  06cf		       99 79 fe 	      sta	[RAM]+Board,y
    678  06d2
      0  06d2					      ldy@PLY	MoveTo,x
      1  06d2		       bc 64 f8 	      ldy	MoveTo,x
      0  06d5					      lda@PLY	capturedPiece
      1  06d5		       ad cb f9 	      lda	capturedPiece
      0  06d8					      sta@RAM	Board,y
      1  06d8		       99 79 fe 	      sta	[RAM]+Board,y
    682  06db
    683  06db
    684  06db							; See if there are any 'secondary' pieces that moved
    685  06db							; here we're dealing with reverting a castling or enPassant move
    686  06db
      0  06db					      lda@PLY	secondaryPiece
      1  06db		       ad cc f9 	      lda	secondaryPiece
    688  06de		       f0 10		      beq	.noSecondary
      0  06e0					      ldx@PLY	secondarySquare
      1  06e0		       ae cd f9 	      ldx	secondarySquare
      0  06e3					      sta@RAM	Board,x	; put piece back
      1  06e3		       9d 79 fe 	      sta	[RAM]+Board,x
      0  06e6					      ldy@PLY	secondaryBlank
      1  06e6		       ac ce f9 	      ldy	secondaryBlank
    692  06e9		       f0 05		      beq	.noSecondary	; enpassant - no blanker square
    693  06eb		       a9 00		      lda	#0
      0  06ed					      sta@RAM	Board,y	; blank piece origin
      1  06ed		       99 79 fe 	      sta	[RAM]+Board,y
    695  06f0
      0  06f0				   .noSecondary SWAP
      1  06f0		       a5 95		      lda	sideToMove
      2  06f2		       49 c0		      eor	#SWAP_SIDE|HUMAN
      3  06f4		       85 95		      sta	sideToMove
      4  06f6
      5  06f6
    697  06f6		       60		      rts
    698  06f7
    699  06f7
    700  06f7							;---------------------------------------------------------------------------------------------------
    701  06f7
      0  06f7					      DEF	showMoveCaptures
      1  06f7				   SLOT_showMoveCaptures SET	_BANK_SLOT
      2  06f7				   BANK_showMoveCaptures SET	SLOT_showMoveCaptures + _CURRENT_BANK
      3  06f7				   showMoveCaptures
      4  06f7				   TEMPORARY_VAR SET	Overlay
      5  06f7				   TEMPORARY_OFFSET SET	0
      6  06f7				   VAR_BOUNDARY_showMoveCaptures SET	TEMPORARY_OFFSET
      7  06f7				   FUNCTION_NAME SET	showMoveCaptures
    703  06f7					      SUBROUTINE
    704  06f7
      0  06f7					      REFER	aiShowMoveCaptures	;✅
      1  06f7					      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  06f7				   TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  06f7					      ENDIF
    706  06f7
      0  06f7					      VAR	__toSquareX12, 1
      1  06f7		       00 a9	   __toSquareX12 =	TEMPORARY_VAR
      2  06f7				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  06f7
      4  06f7				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  06f7				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  06f7				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  06f7					      ENDIF
      8  06f7				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  06f7				  -	      ECHO	"Temporary Variable", __toSquareX12, "overflow!"
     10  06f7				  -	      ERR
     11  06f7					      ENDIF
     12  06f7					      LIST	ON
      0  06f7					      VAR	__fromPiece, 1
      1  06f7		       00 aa	   __fromPiece =	TEMPORARY_VAR
      2  06f7				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  06f7
      4  06f7				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  06f7				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  06f7				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  06f7					      ENDIF
      8  06f7				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  06f7				  -	      ECHO	"Temporary Variable", __fromPiece, "overflow!"
     10  06f7				  -	      ERR
     11  06f7					      ENDIF
     12  06f7					      LIST	ON
      0  06f7					      VAR	__aiMoveIndex, 1
      1  06f7		       00 ab	   __aiMoveIndex =	TEMPORARY_VAR
      2  06f7				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  06f7
      4  06f7				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  06f7				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  06f7				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  06f7					      ENDIF
      8  06f7				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  06f7				  -	      ECHO	"Temporary Variable", __aiMoveIndex, "overflow!"
     10  06f7				  -	      ERR
     11  06f7					      ENDIF
     12  06f7					      LIST	ON
    710  06f7
      0  06f7					      VEND	showMoveCaptures
      1  06f7				  -	      IFNCONST	showMoveCaptures
      2  06f7				  -	      ECHO	"Incorrect VEND label", showMoveCaptures
      3  06f7				  -	      ERR
      4  06f7					      ENDIF
      5  06f7		       00 ac	   VAREND_showMoveCaptures =	TEMPORARY_VAR
    712  06f7
    713  06f7							; place a marker on the board for any square matching the piece
    714  06f7							; EXCEPT for squares which are occupied (we'll flash those later)
    715  06f7							; x = movelist item # being checked
    716  06f7
    717  06f7
    718  06f7		       a6 8d	   .next      ldx	aiMoveIndex
    719  06f9		       86 ab		      stx	__aiMoveIndex
    720  06fb		       30 4a		      bmi	.skip	; no moves in list
    721  06fd
    722  06fd		       ad 84 02 	      lda	INTIM
    723  0700		       c9 14		      cmp	#20
    724  0702		       90 43		      bcc	.skip
    725  0704
    726  0704		       c6 8d		      dec	aiMoveIndex
    727  0706
    728  0706		       a9 89		      lda	#RAMBANK_PLY+1
    729  0708		       85 3e		      sta	SET_BANK_RAM
      0  070a					      lda@PLY	MoveFrom,x
      1  070a		       bd 00 f8 	      lda	MoveFrom,x
    731  070d		       c5 85		      cmp	fromX12
    732  070f		       d0 e6		      bne	.next
    733  0711
      0  0711					      lda@PLY	MoveTo,x
      1  0711		       bd 64 f8 	      lda	MoveTo,x
    735  0714		       85 a9		      sta	__toSquareX12
    736  0716		       a8		      tay
    737  0717
    738  0717		       a9 d1		      lda	#RAMBANK_BOARD
    739  0719		       85 3e		      sta	SET_BANK_RAM	;@3
    740  071b		       b9 79 fc 	      lda	Board,y
    741  071e		       29 0f		      and	#PIECE_MASK
    742  0720		       f0 d5		      beq	.next
    743  0722
    744  0722							; There's something on the board at destination, so it's a capture
    745  0722							; Let's see if we are doing a pawn promote...
    746  0722
    747  0722		       a4 85		      ldy	fromX12
    748  0724
    749  0724		       a9 d1		      lda	#RAMBANK_BOARD
    750  0726		       85 3e		      sta	SET_BANK_RAM	;@3
    751  0728		       b9 79 fc 	      lda	Board,y
    752  072b		       85 aa		      sta	__fromPiece
    753  072d
    754  072d		       a9 89		      lda	#RAMBANK_PLY+1
    755  072f		       85 3e		      sta	SET_BANK_RAM
      0  0731					      lda@PLY	MovePiece,x
      1  0731		       bd 00 f9 	      lda	MovePiece,x
    757  0734		       45 aa		      eor	__fromPiece
    758  0736		       29 0f		      and	#PIECE_MASK
    759  0738		       f0 06		      beq	.legit	; from == to, so not a promote
    760  073a
    761  073a							; Have detected a promotion duplicate - skip all 3 of them
    762  073a							; TODO: this will need reworking once moves are sorted
    763  073a
    764  073a		       c6 8d		      dec	aiMoveIndex	; skip "KBRQ" promotes
    765  073c		       c6 8d		      dec	aiMoveIndex
    766  073e		       c6 8d		      dec	aiMoveIndex
    767  0740
    768  0740				   .legit
    769  0740
    770  0740							;TIMECHECK COPYSINGLEPIECE, restoreIndex     ; not enough time to draw
    771  0740
    772  0740		       a5 a9		      lda	__toSquareX12
    773  0742		       85 80		      sta	squareToDraw
    774  0744
    775  0744							; WARNING - local variables will not survive the following call...!
    776  0744		       20 cb f0 	      jsr	CopySinglePiece	;@0
    777  0747
    778  0747		       60	   .skip      rts
    779  0748
    780  0748
    781  0748							;---------------------------------------------------------------------------------------------------
    782  0748
      0  0748					      DEF	CopyPieceToRowBitmap
      1  0748				   SLOT_CopyPieceToRowBitmap SET	_BANK_SLOT
      2  0748				   BANK_CopyPieceToRowBitmap SET	SLOT_CopyPieceToRowBitmap + _CURRENT_BANK
      3  0748				   CopyPieceToRowBitmap
      4  0748				   TEMPORARY_VAR SET	Overlay
      5  0748				   TEMPORARY_OFFSET SET	0
      6  0748				   VAR_BOUNDARY_CopyPieceToRowBitmap SET	TEMPORARY_OFFSET
      7  0748				   FUNCTION_NAME SET	CopyPieceToRowBitmap
    784  0748					      SUBROUTINE
    785  0748
      0  0748					      REFER	InterceptMarkerCopy	;✅
      1  0748					      IF	VAREND_InterceptMarkerCopy > TEMPORARY_VAR
      2  0748				   TEMPORARY_VAR SET	VAREND_InterceptMarkerCopy
      3  0748					      ENDIF
    787  0748
      0  0748					      VEND	CopyPieceToRowBitmap
      1  0748				  -	      IFNCONST	CopyPieceToRowBitmap
      2  0748				  -	      ECHO	"Incorrect VEND label", CopyPieceToRowBitmap
      3  0748				  -	      ERR
      4  0748					      ENDIF
      5  0748		       00 ac	   VAREND_CopyPieceToRowBitmap =	TEMPORARY_VAR
    789  0748
    790  0748		       a0 11		      ldy	#17
    791  074a		       b0 30		      bcs	.rightSide
    792  074c
    793  074c		       b9 a7 00    .copyPiece lda	__pieceShapeBuffer,y
    794  074f		       f0 06		      beq	.blank1
    795  0751		       59 00 f8 	      eor	ChessBitmap,y
      0  0754					      sta@RAM	ChessBitmap,y
      1  0754		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
    797  0757
    798  0757		       b9 b9 00    .blank1    lda	__pieceShapeBuffer+18,y
    799  075a		       f0 06		      beq	.blank2
    800  075c		       59 12 f8 	      eor	ChessBitmap+18,y
      0  075f					      sta@RAM	ChessBitmap+18,y
      1  075f		       99 12 fa 	      sta	[RAM]+ChessBitmap+18,y
    802  0762
    803  0762		       b9 cb 00    .blank2    lda	__pieceShapeBuffer+36,y
    804  0765		       f0 06		      beq	.blank3
    805  0767		       59 24 f8 	      eor	ChessBitmap+36,y
      0  076a					      sta@RAM	ChessBitmap+36,y
      1  076a		       99 24 fa 	      sta	[RAM]+ChessBitmap+36,y
    807  076d
    808  076d		       b9 dd 00    .blank3    lda	__pieceShapeBuffer+54,y
    809  0770		       f0 06		      beq	.blank4
    810  0772		       59 36 f8 	      eor	ChessBitmap+54,y
      0  0775					      sta@RAM	ChessBitmap+54,y
      1  0775		       99 36 fa 	      sta	[RAM]+ChessBitmap+54,y
    812  0778
    813  0778		       88	   .blank4    dey
    814  0779		       10 d1		      bpl	.copyPiece
    815  077b		       60		      rts
    816  077c
    817  077c				   .rightSide
    818  077c
    819  077c					      SUBROUTINE
    820  077c
    821  077c		       b9 a7 00    .copyPieceR lda	__pieceShapeBuffer,y
    822  077f		       f0 06		      beq	.blank1
    823  0781		       59 48 f8 	      eor	ChessBitmap+72,y
      0  0784					      sta@RAM	ChessBitmap+72,y
      1  0784		       99 48 fa 	      sta	[RAM]+ChessBitmap+72,y
    825  0787
    826  0787		       b9 b9 00    .blank1    lda	__pieceShapeBuffer+18,y
    827  078a		       f0 06		      beq	.blank2
    828  078c		       59 5a f8 	      eor	ChessBitmap+72+18,y
      0  078f					      sta@RAM	ChessBitmap+72+18,y
      1  078f		       99 5a fa 	      sta	[RAM]+ChessBitmap+72+18,y
    830  0792
    831  0792		       b9 cb 00    .blank2    lda	__pieceShapeBuffer+36,y
    832  0795		       f0 06		      beq	.blank3
    833  0797		       59 6c f8 	      eor	ChessBitmap+72+36,y
      0  079a					      sta@RAM	ChessBitmap+72+36,y
      1  079a		       99 6c fa 	      sta	[RAM]+ChessBitmap+72+36,y
    835  079d
    836  079d		       b9 dd 00    .blank3    lda	__pieceShapeBuffer+54,y
    837  07a0		       f0 06		      beq	.blank4
    838  07a2		       59 7e f8 	      eor	ChessBitmap+72+54,y
      0  07a5					      sta@RAM	ChessBitmap+72+54,y
      1  07a5		       99 7e fa 	      sta	[RAM]+ChessBitmap+72+54,y
    840  07a8
    841  07a8		       88	   .blank4    dey
    842  07a9		       10 d1		      bpl	.copyPieceR
    843  07ab		       60		      rts
    844  07ac
    845  07ac
    846  07ac							;---------------------------------------------------------------------------------------------------
    847  07ac
      0  07ac					      DEF	EnPassantRemoveCapturedPawn
      1  07ac				   SLOT_EnPassantRemoveCapturedPawn SET	_BANK_SLOT
      2  07ac				   BANK_EnPassantRemoveCapturedPawn SET	SLOT_EnPassantRemoveCapturedPawn + _CURRENT_BANK
      3  07ac				   EnPassantRemoveCapturedPawn
      4  07ac				   TEMPORARY_VAR SET	Overlay
      5  07ac				   TEMPORARY_OFFSET SET	0
      6  07ac				   VAR_BOUNDARY_EnPassantRemoveCapturedPawn SET	TEMPORARY_OFFSET
      7  07ac				   FUNCTION_NAME SET	EnPassantRemoveCapturedPawn
    849  07ac					      SUBROUTINE
    850  07ac
      0  07ac					      REFER	aiSpecialMoveFixup
      1  07ac					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  07ac				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  07ac					      ENDIF
      0  07ac					      VEND	EnPassantRemoveCapturedPawn
      1  07ac				  -	      IFNCONST	EnPassantRemoveCapturedPawn
      2  07ac				  -	      ECHO	"Incorrect VEND label", EnPassantRemoveCapturedPawn
      3  07ac				  -	      ERR
      4  07ac					      ENDIF
      5  07ac		       00 b5	   VAREND_EnPassantRemoveCapturedPawn =	TEMPORARY_VAR
    853  07ac
    854  07ac		       a4 93		      ldy	enPassantPawn
    855  07ae		       f0 27		      beq	.exit
    856  07b0
    857  07b0
    858  07b0		       a9 d1		      lda	#RAMBANK_BOARD
    859  07b2		       85 3e		      sta	SET_BANK_RAM	;@3
    860  07b4
    861  07b4							; Account for the opponent pawn being removed
    862  07b4							; Effectively ADD the values to our current score
    863  07b4
    864  07b4		       a5 95		      lda	sideToMove
    865  07b6		       49 80		      eor	#128
    866  07b8		       29 80		      and	#128
    867  07ba		       09 01		      ora	#WP	; == BP in this usage
    868  07bc
    869  07bc		       a2 92		      ldx	#BANK_AddPiecePositionValue
    870  07be		       86 3f		      stx	SET_BANK	;@2
    871  07c0		       20 54 f9 	      jsr	AddPiecePositionValue	; remove pos value for original position
    872  07c3
    873  07c3		       a9 01		      lda	#WP	; == BP
    874  07c5		       a2 92		      ldx	#BANK_AddPieceMaterialValue
    875  07c7		       86 3f		      stx	SET_BANK	;@2
    876  07c9		       20 31 f9 	      jsr	AddPieceMaterialValue	; remove material for original type
    877  07cc
    878  07cc		       a9 d1		      lda	#RAMBANK_BOARD
    879  07ce		       85 3e		      sta	SET_BANK_RAM	;@3
    880  07d0
    881  07d0		       a6 93		      ldx	enPassantPawn
    882  07d2		       a9 00		      lda	#0
      0  07d4					      sta@RAM	Board,x
      1  07d4		       9d 79 fe 	      sta	[RAM]+Board,x
    884  07d7
    885  07d7
    886  07d7		       60	   .exit      rts
    887  07d8
    888  07d8
    889  07d8							;---------------------------------------------------------------------------------------------------
    890  07d8
 FREE BYTES IN BANK_FIRST@0 BANK =  $24
    891  07d8					      ECHO	"FREE BYTES IN BANK_FIRST@0 BANK = ", $F3FC - *
    892  07d8
    893  07d8
    894  07d8							; EOF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@1#1.asm LEVEL 2 PASS 4
      0  07d8					      include	"BANK_GENERIC@1#1.asm"
      1  07d8							; Chess
      2  07d8							; Copyright (c) 2019-2020 Andrew Davie
      3  07d8							; andrew@taswegian.com
      4  07d8
      0  07d8					      SLOT	1	; which bank this code switches to
      1  07d8				  -	      IF	(1 < 0) || (1 > 3)
      2  07d8				  -	      ECHO	"Illegal bank address/segment location", 1
      3  07d8				  -	      ERR
      4  07d8					      ENDIF
      5  07d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  07d8				   _BANK_SLOT SET	1 * 64
      0  07d8					      ROMBANK	ONE
      1  0a4e ????				      SEG	ONE
      2  0800					      ORG	_ORIGIN
      3  0800					      RORG	_BANK_ADDRESS_ORIGIN
      4  0800				   _BANK_START SET	*
      5  0800				   ONE_START  SET	*
      6  0800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0800				   ONE	      SET	_BANK_SLOT + _CURRENT_BANK
      8  0800				   _ORIGIN    SET	_ORIGIN + 1024
      7  0800
      8  0800
      9  0800							;---------------------------------------------------------------------------------------------------
     10  0800							; ... the above is a (potentially) RAM-copied section -- the following is ROM-only.  Note that
     11  0800							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     12  0800							; bank finishes.  Just continue on from where it left off...
     13  0800							;---------------------------------------------------------------------------------------------------
     14  0800
      0  0800					      DEF	CartInit
      1  0800				   SLOT_CartInit SET	_BANK_SLOT
      2  0800				   BANK_CartInit SET	SLOT_CartInit + _CURRENT_BANK
      3  0800				   CartInit
      4  0800				   TEMPORARY_VAR SET	Overlay
      5  0800				   TEMPORARY_OFFSET SET	0
      6  0800				   VAR_BOUNDARY_CartInit SET	TEMPORARY_OFFSET
      7  0800				   FUNCTION_NAME SET	CartInit
     16  0800					      SUBROUTINE
     17  0800
      0  0800					      REFER	StartupBankReset	;✅
      1  0800				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0800				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0800					      ENDIF
     19  0800
      0  0800					      VEND	CartInit
      1  0800				  -	      IFNCONST	CartInit
      2  0800				  -	      ECHO	"Incorrect VEND label", CartInit
      3  0800				  -	      ERR
      4  0800					      ENDIF
      5  0800		       00 a7	   VAREND_CartInit =	TEMPORARY_VAR
     21  0800
     22  0800		       78		      sei
     23  0801		       d8		      cld
     24  0802							; See if we can come up with something 'random' for startup
     25  0802
     26  0802		       ac 84 02 	      ldy	INTIM
     27  0805		       d0 02		      bne	.toR
     28  0807		       a0 9a		      ldy	#$9A
     29  0809		       84 81	   .toR       sty	rnd
     30  080b
     31  080b		       a9 1f		      lda	#31
     32  080d		       85 a1		      sta	randomness
     33  080f
     34  080f		       a9 00		      lda	#0
     35  0811		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     36  0814		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     37  0817		       85 6b		      sta	HMCLR
     38  0819
     39  0819		       85 5b		      sta	GRP0
     40  081b		       85 5c		      sta	GRP1
     41  081d		       85 5d		      sta	ENAM0
     42  081f		       85 5e		      sta	ENAM1
     43  0821		       85 5f		      sta	ENABL
     44  0823
     45  0823							; cleanup remains of title screen
     46  0823							;sta GRP0
     47  0823							;sta GRP1
     48  0823
     49  0823		       a9 07		      lda	#%111
     50  0825		       85 44		      sta	NUSIZ0
     51  0827		       85 45		      sta	NUSIZ1	; quad-width
     52  0829
     53  0829							;lda #%00000100
     54  0829							;sta CTRLPF
     55  0829		       a9 00		      lda	#BACKGCOL
     56  082b		       85 49		      sta	COLUBK
     57  082d
     58  082d
     59  082d		       a9 40		      lda	#WHITE|HUMAN
     60  082f		       85 95		      sta	sideToMove
     61  0831
     62  0831		       60		      rts
     63  0832
     64  0832
     65  0832							;---------------------------------------------------------------------------------------------------
     66  0832
      0  0832					      DEF	SetupBanks
      1  0832				   SLOT_SetupBanks SET	_BANK_SLOT
      2  0832				   BANK_SetupBanks SET	SLOT_SetupBanks + _CURRENT_BANK
      3  0832				   SetupBanks
      4  0832				   TEMPORARY_VAR SET	Overlay
      5  0832				   TEMPORARY_OFFSET SET	0
      6  0832				   VAR_BOUNDARY_SetupBanks SET	TEMPORARY_OFFSET
      7  0832				   FUNCTION_NAME SET	SetupBanks
     68  0832					      SUBROUTINE
     69  0832
     70  0832							; Move a copy of the row bank template to the first 8 banks of RAM
     71  0832							; and then terminate the draw subroutine by substituting in a RTS on the last one
     72  0832
      0  0832					      REFER	StartupBankReset	;✅
      1  0832				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0832				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0832					      ENDIF
      0  0832					      VEND	SetupBanks
      1  0832				  -	      IFNCONST	SetupBanks
      2  0832				  -	      ECHO	"Incorrect VEND label", SetupBanks
      3  0832				  -	      ERR
      4  0832					      ENDIF
      5  0832		       00 a7	   VAREND_SetupBanks =	TEMPORARY_VAR
     75  0832
     76  0832							; Copy the bitmap shadow into the first 8 RAM banks via x(SLOT3)-->y(SLOT2)
     77  0832
     78  0832				   .ROWBANK   SET	0
     79  0832					      REPEAT	8
     80  0832		       a2 83		      ldx	#BANK_SHADOW_ChessBitmap
     81  0834		       a0 c0		      ldy	#[SLOT3] + .ROWBANK
     82  0836		       20 7b f4 	      jsr	CopyShadowROMtoRAM
     83  0836				   .ROWBANK   SET	.ROWBANK+1
     79  0836					      REPEND
     80  0839		       a2 83		      ldx	#BANK_SHADOW_ChessBitmap
     81  083b		       a0 c1		      ldy	#[SLOT3] + .ROWBANK
     82  083d		       20 7b f4 	      jsr	CopyShadowROMtoRAM
     83  083d				   .ROWBANK   SET	.ROWBANK+1
     79  083d					      REPEND
     80  0840		       a2 83		      ldx	#BANK_SHADOW_ChessBitmap
     81  0842		       a0 c2		      ldy	#[SLOT3] + .ROWBANK
     82  0844		       20 7b f4 	      jsr	CopyShadowROMtoRAM
     83  0844				   .ROWBANK   SET	.ROWBANK+1
     79  0844					      REPEND
     80  0847		       a2 83		      ldx	#BANK_SHADOW_ChessBitmap
     81  0849		       a0 c3		      ldy	#[SLOT3] + .ROWBANK
     82  084b		       20 7b f4 	      jsr	CopyShadowROMtoRAM
     83  084b				   .ROWBANK   SET	.ROWBANK+1
     79  084b					      REPEND
     80  084e		       a2 83		      ldx	#BANK_SHADOW_ChessBitmap
     81  0850		       a0 c4		      ldy	#[SLOT3] + .ROWBANK
     82  0852		       20 7b f4 	      jsr	CopyShadowROMtoRAM
     83  0852				   .ROWBANK   SET	.ROWBANK+1
     79  0852					      REPEND
     80  0855		       a2 83		      ldx	#BANK_SHADOW_ChessBitmap
     81  0857		       a0 c5		      ldy	#[SLOT3] + .ROWBANK
     82  0859		       20 7b f4 	      jsr	CopyShadowROMtoRAM
     83  0859				   .ROWBANK   SET	.ROWBANK+1
     79  0859					      REPEND
     80  085c		       a2 83		      ldx	#BANK_SHADOW_ChessBitmap
     81  085e		       a0 c6		      ldy	#[SLOT3] + .ROWBANK
     82  0860		       20 7b f4 	      jsr	CopyShadowROMtoRAM
     83  0860				   .ROWBANK   SET	.ROWBANK+1
     79  0860					      REPEND
     80  0863		       a2 83		      ldx	#BANK_SHADOW_ChessBitmap
     81  0865		       a0 c7		      ldy	#[SLOT3] + .ROWBANK
     82  0867		       20 7b f4 	      jsr	CopyShadowROMtoRAM
     83  0867				   .ROWBANK   SET	.ROWBANK+1
     84  086a					      REPEND
     85  086a
     86  086a
     87  086a							; Patch the final row's "loop" to a RTS
     88  086a
     89  086a		       a2 87		      ldx	#[SLOT2] + 7	; last ROW BITMAP bank
     90  086c		       86 3e		      stx	SET_BANK_RAM
     91  086e		       a9 60		      lda	#$60	; "rts"
      0  0870					      sta@RAM	SELFMOD_RTS_ON_LAST_ROW
      1  0870		       8d 00 fb 	      sta	[RAM]+SELFMOD_RTS_ON_LAST_ROW
     93  0873
     94  0873
     95  0873
     96  0873							; copy the BOARD/MOVES bank
     97  0873
     98  0873		       a2 85		      ldx	#SHADOW_BOARD
     99  0875		       a0 d1		      ldy	#RAMBANK_BOARD
    100  0877		       20 7b f4 	      jsr	CopyShadowROMtoRAM	; this auto-initialises Board too
    101  087a
    102  087a
    103  087a							; copy the PLY banks
    104  087a							; If there's no content (only variable decs) then we don't really need to do this.
    105  087a
    106  087a							;.PLY SET 0
    107  087a							;    REPEAT PLY_BANKS
    108  087a
    109  087a							;		      ldx #SHADOW_PLY
    110  087a							;		      ldy #RAMBANK_PLY + .PLY
    111  087a							;jsr CopyShadowROMtoRAM
    112  087a							;.PLY SET .PLY + 1
    113  087a							;    REPEND
    114  087a
    115  087a							; copy the evaluation code/tables
    116  087a							; 3E+ moved from RAM to ROM
    117  087a
    118  087a							;		      ldx #[SLOT2] + SHADOW_EVAL
    119  087a							;		      ldy #[SLOT3] + EVAL
    120  087a							;		      jsr CopyShadowROMtoRAM
    121  087a
    122  087a
    123  087a							;		      ldy #RAMBANK_RAM_PIECELIST
    124  087a							;		      ldx #ROM_PIECELIST
    125  087a							;		      jsr CopyShadowROMtoRAM
    126  087a
    127  087a		       60		      rts
    128  087b
    129  087b
    130  087b							;---------------------------------------------------------------------------------------------------
    131  087b
      0  087b					      DEF	CopyShadowROMtoRAM
      1  087b				   SLOT_CopyShadowROMtoRAM SET	_BANK_SLOT
      2  087b				   BANK_CopyShadowROMtoRAM SET	SLOT_CopyShadowROMtoRAM + _CURRENT_BANK
      3  087b				   CopyShadowROMtoRAM
      4  087b				   TEMPORARY_VAR SET	Overlay
      5  087b				   TEMPORARY_OFFSET SET	0
      6  087b				   VAR_BOUNDARY_CopyShadowROMtoRAM SET	TEMPORARY_OFFSET
      7  087b				   FUNCTION_NAME SET	CopyShadowROMtoRAM
    133  087b					      SUBROUTINE
    134  087b
      0  087b					      REFER	SetupBanks	;✅
      1  087b				  -	      IF	VAREND_SetupBanks > TEMPORARY_VAR
      2  087b				  -TEMPORARY_VAR SET	VAREND_SetupBanks
      3  087b					      ENDIF
    136  087b
      0  087b					      VEND	CopyShadowROMtoRAM
      1  087b				  -	      IFNCONST	CopyShadowROMtoRAM
      2  087b				  -	      ECHO	"Incorrect VEND label", CopyShadowROMtoRAM
      3  087b				  -	      ERR
      4  087b					      ENDIF
      5  087b		       00 a7	   VAREND_CopyShadowROMtoRAM =	TEMPORARY_VAR
    138  087b
    139  087b							; Copy a whole ROM SHADOW into a destination RAM 512 byte bank
    140  087b							; used to setup callable RAM code from ROM templates
    141  087b
    142  087b							; x = source ROM bank
    143  087b							; y = destination RAM bank (preserved)
    144  087b
    145  087b		       86 3f		      stx	SET_BANK
    146  087d		       84 3e		      sty	SET_BANK_RAM
    147  087f
    148  087f		       a2 00		      ldx	#0
    149  0881		       bd 00 f8    .copyPage  lda	$F800,x
      0  0884					      sta@RAM	$FC00,x
      1  0884		       9d 00 fe 	      sta	[RAM]+$FC00,x
    151  0887		       bd 00 f9 	      lda	$F900,x
      0  088a					      sta@RAM	$FD00,x
      1  088a		       9d 00 ff 	      sta	[RAM]+$FD00,x
    153  088d		       ca		      dex
    154  088e		       d0 f1		      bne	.copyPage
    155  0890		       60		      rts
    156  0891
    157  0891
    158  0891							;---------------------------------------------------------------------------------------------------
    159  0891
      0  0891					      DEF	CallClear
      1  0891				   SLOT_CallClear SET	_BANK_SLOT
      2  0891				   BANK_CallClear SET	SLOT_CallClear + _CURRENT_BANK
      3  0891				   CallClear
      4  0891				   TEMPORARY_VAR SET	Overlay
      5  0891				   TEMPORARY_OFFSET SET	0
      6  0891				   VAR_BOUNDARY_CallClear SET	TEMPORARY_OFFSET
      7  0891				   FUNCTION_NAME SET	CallClear
    161  0891					      SUBROUTINE
    162  0891
    163  0891				  -	      IF	0
    164  0891				  -	      REFER	aiClearEachRow	;TODO
    165  0891					      ENDIF
    166  0891
      0  0891					      VEND	CallClear
      1  0891				  -	      IFNCONST	CallClear
      2  0891				  -	      ECHO	"Incorrect VEND label", CallClear
      3  0891				  -	      ERR
      4  0891					      ENDIF
      5  0891		       00 a7	   VAREND_CallClear =	TEMPORARY_VAR
    168  0891
    169  0891				  -	      IF	0
    170  0891				  -			; No transient variable dependencies/calls
    171  0891				  -
    172  0891				  -	      sty	SET_BANK_RAM
    173  0891				  -	      jsr	ClearRowBitmap
    174  0891					      ENDIF
    175  0891		       60		      rts
    176  0892
    177  0892
    178  0892							;---------------------------------------------------------------------------------------------------
    179  0892
      0  0892					      DEF	InitialisePieceSquares
      1  0892				   SLOT_InitialisePieceSquares SET	_BANK_SLOT
      2  0892				   BANK_InitialisePieceSquares SET	SLOT_InitialisePieceSquares + _CURRENT_BANK
      3  0892				   InitialisePieceSquares
      4  0892				   TEMPORARY_VAR SET	Overlay
      5  0892				   TEMPORARY_OFFSET SET	0
      6  0892				   VAR_BOUNDARY_InitialisePieceSquares SET	TEMPORARY_OFFSET
      7  0892				   FUNCTION_NAME SET	InitialisePieceSquares
    181  0892					      SUBROUTINE
    182  0892
      0  0892					      COMMON_VARS
      1  0892
      0  0892					      VAR	__thinkbar, 1
      1  0892		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  0892				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0892
      4  0892				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0892				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0892				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0892					      ENDIF
      8  0892				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0892				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  0892				  -	      ERR
     11  0892					      ENDIF
     12  0892					      LIST	ON
      0  0892					      VAR	__toggle, 1
      1  0892		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  0892				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0892
      4  0892				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0892				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0892				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0892					      ENDIF
      8  0892				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0892				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  0892				  -	      ERR
     11  0892					      ENDIF
     12  0892					      LIST	ON
      4  0892
      0  0892					      VAR	__bestMove, 1
      1  0892		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  0892				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0892
      4  0892				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0892				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0892				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0892					      ENDIF
      8  0892				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0892				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  0892				  -	      ERR
     11  0892					      ENDIF
     12  0892					      LIST	ON
      0  0892					      VAR	__alpha, 2
      1  0892		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  0892				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0892
      4  0892				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0892				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0892				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0892					      ENDIF
      8  0892				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0892				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  0892				  -	      ERR
     11  0892					      ENDIF
     12  0892					      LIST	ON
      0  0892					      VAR	__beta, 2
      1  0892		       00 ac	   __beta     =	TEMPORARY_VAR
      2  0892				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0892
      4  0892				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0892				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0892				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0892					      ENDIF
      8  0892				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0892				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  0892				  -	      ERR
     11  0892					      ENDIF
     12  0892					      LIST	ON
      0  0892					      VAR	__negaMax, 2
      1  0892		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  0892				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0892
      4  0892				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0892				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0892				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0892					      ENDIF
      8  0892				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0892				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  0892				  -	      ERR
     11  0892					      ENDIF
     12  0892					      LIST	ON
      0  0892					      VAR	__value, 2
      1  0892		       00 b0	   __value    =	TEMPORARY_VAR
      2  0892				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0892
      4  0892				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0892				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0892				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0892					      ENDIF
      8  0892				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0892				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  0892				  -	      ERR
     11  0892					      ENDIF
     12  0892					      LIST	ON
     10  0892
      0  0892					      VAR	__quiesceCapOnly, 1
      1  0892		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  0892				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0892
      4  0892				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0892				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0892				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0892					      ENDIF
      8  0892				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0892				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  0892				  -	      ERR
     11  0892					      ENDIF
     12  0892					      LIST	ON
     12  0892
      0  0892					      VAR	__originalPiece, 1
      1  0892		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  0892				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0892
      4  0892				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0892				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0892				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0892					      ENDIF
      8  0892				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0892				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  0892				  -	      ERR
     11  0892					      ENDIF
     12  0892					      LIST	ON
      0  0892					      VAR	__capturedPiece, 1
      1  0892		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  0892				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0892
      4  0892				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0892				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0892				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0892					      ENDIF
      8  0892				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0892				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  0892				  -	      ERR
     11  0892					      ENDIF
     12  0892					      LIST	ON
     15  0892
      0  0892					      REFER	StartupBankReset	;✅
      1  0892				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0892				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0892					      ENDIF
    185  0892
      0  0892					      VAR	__initPiece, 1
      1  0892		       00 b5	   __initPiece =	TEMPORARY_VAR
      2  0892				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0892
      4  0892				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0892				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0892				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0892					      ENDIF
      8  0892				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0892				  -	      ECHO	"Temporary Variable", __initPiece, "overflow!"
     10  0892				  -	      ERR
     11  0892					      ENDIF
     12  0892					      LIST	ON
      0  0892					      VAR	__initSquare, 1
      1  0892		       00 b6	   __initSquare =	TEMPORARY_VAR
      2  0892				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0892
      4  0892				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0892				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0892				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0892					      ENDIF
      8  0892				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0892				  -	      ECHO	"Temporary Variable", __initSquare, "overflow!"
     10  0892				  -	      ERR
     11  0892					      ENDIF
     12  0892					      LIST	ON
      0  0892					      VAR	__initListPtr, 1
      1  0892		       00 b7	   __initListPtr =	TEMPORARY_VAR
      2  0892				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0892
      4  0892				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0892				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0892				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0892					      ENDIF
      8  0892				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0892				  -	      ECHO	"Temporary Variable", __initListPtr, "overflow!"
     10  0892				  -	      ERR
     11  0892					      ENDIF
     12  0892					      LIST	ON
      0  0892					      VAR	__op, 1
      1  0892		       00 b8	   __op       =	TEMPORARY_VAR
      2  0892				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0892
      4  0892				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0892					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0892				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0892					      ENDIF
      8  0892				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0892				  -	      ECHO	"Temporary Variable", __op, "overflow!"
     10  0892				  -	      ERR
     11  0892					      ENDIF
     12  0892					      LIST	ON
    190  0892
      0  0892					      VEND	InitialisePieceSquares
      1  0892				  -	      IFNCONST	InitialisePieceSquares
      2  0892				  -	      ECHO	"Incorrect VEND label", InitialisePieceSquares
      3  0892				  -	      ERR
      4  0892					      ENDIF
      5  0892		       00 b9	   VAREND_InitialisePieceSquares =	TEMPORARY_VAR
    192  0892
    193  0892		       a9 00		      lda	#0
    194  0894		       85 8f		      sta	Evaluation
    195  0896		       85 90		      sta	Evaluation+1	; tracks CURRENT value of everything (signed 16-bit)
    196  0898		       85 93		      sta	enPassantPawn	; no en-passant
    197  089a
    198  089a
      0  089a					      PHASE	AI_StartClearBoard
      1  089a		       a9 0d		      lda	#AI_StartClearBoard
      2  089c		       85 8b		      sta	aiState
    200  089e
    201  089e		       a2 00		      ldx	#0
    202  08a0				   .fillPieceLists
    203  08a0
    204  08a0
    205  08a0		       bd f2 f4 	      lda	InitPieceList,x	; colour/-1
    206  08a3		       f0 4c		      beq	.exit
    207  08a5		       85 b8		      sta	__op	; type
    208  08a7		       bc f3 f4 	      ldy	InitPieceList+1,x	; square
    209  08aa		       84 b6		      sty	__initSquare
    210  08ac
    211  08ac		       a9 d1		      lda	#RAMBANK_BOARD
    212  08ae		       85 3e		      sta	SET_BANK_RAM
    213  08b0		       a5 b8		      lda	__op
      0  08b2					      sta@RAM	Board,y
      1  08b2		       99 79 fe 	      sta	[RAM]+Board,y
    215  08b5		       10 0d		      bpl	.white
    216  08b7
      0  08b7					      NEGEVAL
      1  08b7
      2  08b7		       38		      sec
      3  08b8		       a9 00		      lda	#0
      4  08ba		       e5 8f		      sbc	Evaluation
      5  08bc		       85 8f		      sta	Evaluation
      6  08be		       a9 00		      lda	#0
      7  08c0		       e5 90		      sbc	Evaluation+1
      8  08c2		       85 90		      sta	Evaluation+1
    218  08c4				   .white
    219  08c4
    220  08c4		       86 b7		      stx	__initListPtr
    221  08c6
    222  08c6							; Add the material value of the piece to the evaluation
    223  08c6
    224  08c6		       a5 b8		      lda	__op
    225  08c8		       a2 92		      ldx	#BANK_AddPieceMaterialValue
    226  08ca		       86 3f		      stx	SET_BANK	;@2
    227  08cc		       20 31 f9 	      jsr	AddPieceMaterialValue
    228  08cf
    229  08cf
    230  08cf							; add the positional value of the piece to the evaluation
    231  08cf
    232  08cf		       a4 b6		      ldy	__initSquare
    233  08d1		       a5 b8		      lda	__op
    234  08d3		       a2 92		      ldx	#BANK_AddPiecePositionValue
    235  08d5		       86 3f		      stx	SET_BANK
    236  08d7		       20 54 f9 	      jsr	AddPiecePositionValue
    237  08da
    238  08da		       a5 b8		      lda	__op	; type/colour
    239  08dc		       10 0d		      bpl	.white2
      0  08de					      NEGEVAL
      1  08de
      2  08de		       38		      sec
      3  08df		       a9 00		      lda	#0
      4  08e1		       e5 8f		      sbc	Evaluation
      5  08e3		       85 8f		      sta	Evaluation
      6  08e5		       a9 00		      lda	#0
      7  08e7		       e5 90		      sbc	Evaluation+1
      8  08e9		       85 90		      sta	Evaluation+1
    241  08eb				   .white2
    242  08eb
    243  08eb		       a6 b7		      ldx	__initListPtr
    244  08ed		       e8		      inx
    245  08ee		       e8		      inx
    246  08ef		       10 af		      bpl	.fillPieceLists
    247  08f1
    248  08f1				   .exit
    249  08f1		       60		      rts
    250  08f2
    251  08f2
    252  08f2				   InitPieceList
    253  08f2
    254  08f2
    255  08f2					      IF	!TEST_POSITION
    256  08f2
    257  08f2		       06 19		      .byte.b	WHITE|Q, 25
    258  08f4		       04 18		      .byte.b	WHITE|B, 24
    259  08f6		       04 1b		      .byte.b	WHITE|B, 27
    260  08f8		       05 16		      .byte.b	WHITE|R, 22
    261  08fa		       05 1d		      .byte.b	WHITE|R, 29
    262  08fc		       03 17		      .byte.b	WHITE|N, 23
    263  08fe		       03 1c		      .byte.b	WHITE|N, 28
    264  0900
    265  0900		       01 23		      .byte.b	WHITE|WP, 35
    266  0902		       01 24		      .byte.b	WHITE|WP, 36
    267  0904		       01 22		      .byte.b	WHITE|WP, 34
    268  0906		       01 25		      .byte.b	WHITE|WP, 37
    269  0908		       01 21		      .byte.b	WHITE|WP, 33
    270  090a		       01 26		      .byte.b	WHITE|WP, 38
    271  090c		       01 20		      .byte.b	WHITE|WP, 32
    272  090e		       01 27		      .byte.b	WHITE|WP, 39
    273  0910
    274  0910		       07 1a		      .byte.b	WHITE|K, 26
    275  0912
    276  0912		       86 5f		      .byte.b	BLACK|Q, 95
    277  0914		       84 5e		      .byte.b	BLACK|B, 94
    278  0916		       84 61		      .byte.b	BLACK|B, 97
    279  0918		       85 5c		      .byte.b	BLACK|R, 92
    280  091a		       85 63		      .byte.b	BLACK|R, 99
    281  091c		       83 5d		      .byte.b	BLACK|N, 93
    282  091e		       83 62		      .byte.b	BLACK|N, 98
    283  0920
    284  0920		       82 55		      .byte.b	BLACK|BP, 85
    285  0922		       82 56		      .byte.b	BLACK|BP, 86
    286  0924		       82 54		      .byte.b	BLACK|BP, 84
    287  0926		       82 57		      .byte.b	BLACK|BP, 87
    288  0928		       82 53		      .byte.b	BLACK|BP, 83
    289  092a		       82 58		      .byte.b	BLACK|BP, 88
    290  092c		       82 52		      .byte.b	BLACK|BP, 82
    291  092e		       82 59		      .byte.b	BLACK|BP, 89
    292  0930
    293  0930		       87 60		      .byte.b	BLACK|K, 96
    294  0932
    295  0932		       00		      .byte.b	0	;end
    296  0933
    297  0933				  -	      ELSE		; test position...
    298  0933				  -
    299  0933				  -	      IF	0
    300  0933				  -			; make sure illegal moves leaving K in check are removed
    301  0933				  -
    302  0933				  -	      .byte	WHITE|N, 28
    303  0933				  -	      .byte	WHITE|K, 26
    304  0933				  -
    305  0933				  -	      .byte	BLACK|Q, 29
    306  0933				  -
    307  0933				  -	      .byte	0	;end
    308  0933				  -
    309  0933				  -	      ENDIF
    310  0933				  -
    311  0933				  -	      IF	0
    312  0933				  -
    313  0933				  -	      .byte	WHITE|K, 28
    314  0933				  -	      .byte	WHITE|WP, 37
    315  0933				  -	      .byte	WHITE|WP, 38
    316  0933				  -	      .byte	WHITE|WP, 53
    317  0933				  -	      .byte	WHITE|WP, 49
    318  0933				  -	      .byte	WHITE|WP, 32
    319  0933				  -	      .byte	WHITE|R, 27
    320  0933				  -	      .byte	WHITE|B, 46
    321  0933				  -	      .byte	WHITE|R, 54
    322  0933				  -
    323  0933				  -	      .byte	BLACK|BP, 56
    324  0933				  -	      .byte	BLACK|BP, 87
    325  0933				  -	      .byte	BLACK|BP, 88
    326  0933				  -	      .byte	BLACK|BP, 89
    327  0933				  -	      .byte	BLACK|BP, 84
    328  0933				  -	      .byte	BLACK|B, 66
    329  0933				  -	      .byte	BLACK|R, 69
    330  0933				  -	      .byte	BLACK|K, 98
    331  0933				  -
    332  0933				  -	      .byte	BLACK|R, 92
    333  0933				  -
    334  0933				  -
    335  0933				  -
    336  0933				  -	      ENDIF
    337  0933				  -
    338  0933				  -	      IF	TEST_POSITION & 0
    339  0933				  -			; Castling across/into check
    340  0933				  -			; pawn promotion
    341  0933				  -
    342  0933				  -	      .byte	WHITE|K, 26
    343  0933				  -	      .byte	WHITE|R, 29
    344  0933				  -	      .byte	BLACK|B, 45
    345  0933				  -	      .byte	WHITE|Q, 72
    346  0933				  -	      .byte	BLACK|N, 84
    347  0933				  -	      .byte	WHITE|WP,89
    348  0933				  -
    349  0933				  -	      ENDIF
    350  0933				  -
    351  0933				  -
    352  0933				  -
    353  0933				  -	      IF	TEST_POSITION & 0
    354  0933				  -			; En passant test
    355  0933				  -
    356  0933				  -	      .byte	BLACK|BP, 88
    357  0933				  -	      .byte	BLACK|BP, 86
    358  0933				  -
    359  0933				  -	      .byte	WHITE|WP|FLAG_MOVED, 67
    360  0933				  -	      .byte	WHITE|K, 52
    361  0933				  -
    362  0933				  -
    363  0933				  -	      ENDIF
    364  0933				  -
    365  0933				  -	      IF	TEST_POSITION & 0
    366  0933				  -			; En passant test (white)
    367  0933				  -
    368  0933				  -	      .byte	BLACK|BP|FLAG_MOVED, 53
    369  0933				  -
    370  0933				  -	      .byte	WHITE|WP, 34
    371  0933				  -	      .byte	WHITE|K, 52
    372  0933				  -
    373  0933				  -
    374  0933				  -	      .byte	BLACK|BP, 88
    375  0933				  -	      .byte	WHITE|WP|FLAG_MOVED, 67
    376  0933				  -
    377  0933				  -
    378  0933				  -	      ENDIF
    379  0933				  -
    380  0933				  -
    381  0933				  -	      IF	TEST_POSITION & 1
    382  0933				  -			; castle
    383  0933				  -
    384  0933				  -	      .byte	BLACK|R, 99
    385  0933				  -	      .byte	BLACK|K, 96
    386  0933				  -	      .byte	BLACK|BP, 89
    387  0933				  -
    388  0933				  -	      .byte	WHITE|WP, 37
    389  0933				  -	      .byte	WHITE|WP, 38
    390  0933				  -	      .byte	WHITE|WP, 39
    391  0933				  -	      .byte	WHITE|R,29
    392  0933				  -	      .byte	WHITE|K, 26
    393  0933				  -
    394  0933				  -	      ENDIF
    395  0933				  -
    396  0933				  -
    397  0933				  -
    398  0933				  -
    399  0933				  -	      IF	TEST_POSITION & 0
    400  0933				  -			; promote test
    401  0933				  -
    402  0933				  -	      .byte	BLACK|K, 22
    403  0933				  -	      .byte	BLACK|N, 96
    404  0933				  -
    405  0933				  -	      .byte	WHITE|WP, 87
    406  0933				  -	      .byte	WHITE|R,95
    407  0933				  -	      .byte	WHITE|R,94
    408  0933				  -	      .byte	WHITE|K, 52
    409  0933				  -
    410  0933				  -
    411  0933				  -	      ENDIF
    412  0933				  -
    413  0933				  -
    414  0933				  -
    415  0933				  -	      IF	0
    416  0933				  -
    417  0933				  -
    418  0933				  -			;.byte BLACK|R, 97
    419  0933				  -	      .byte	BLACK|K, 98
    420  0933				  -	      .byte	BLACK|BP, 87
    421  0933				  -	      .byte	BLACK|BP, 88
    422  0933				  -	      .byte	BLACK|BP, 89
    423  0933				  -			;    .byte BLACK|B, 76
    424  0933				  -
    425  0933				  -
    426  0933				  -	      .byte	WHITE|R,28
    427  0933				  -	      .byte	WHITE|Q,58
    428  0933				  -			;   .byte WHITE|N,65
    429  0933				  -	      ENDIF
    430  0933				  -
    431  0933				  -	      IF	0
    432  0933				  -			;.byte WHITE|WP, 56
    433  0933				  -
    434  0933				  -
    435  0933				  -	      .byte	BLACK|K, 98
    436  0933				  -
    437  0933				  -
    438  0933				  -	      .byte	WHITE|R,29
    439  0933				  -	      .byte	WHITE|Q,49
    440  0933				  -	      .byte	WHITE|N,65
    441  0933				  -	      ENDIF
    442  0933				  -	      .byte	0	;end
    443  0933				  -
    444  0933					      ENDIF
    445  0933
    446  0933
    447  0933							;---------------------------------------------------------------------------------------------------
    448  0933
    449  0933				  -	      IF	0
    450  0933				  -	      DEF	SAFE_BackupBitmaps
    451  0933				  -	      SUBROUTINE
    452  0933				  -
    453  0933				  -	      REFER	aiInCheckBackup
    454  0933				  -	      VEND	SAFE_BackupBitmaps
    455  0933				  -
    456  0933				  -	      sty	SET_BANK_RAM
    457  0933				  -	      jsr	SaveBitmap
    458  0933				  -	      rts
    459  0933					      ENDIF
    460  0933
    461  0933
    462  0933							;---------------------------------------------------------------------------------------------------
    463  0933
      0  0933					      DEF	AddMoveSimple
      1  0933				   SLOT_AddMoveSimple SET	_BANK_SLOT
      2  0933				   BANK_AddMoveSimple SET	SLOT_AddMoveSimple + _CURRENT_BANK
      3  0933				   AddMoveSimple
      4  0933				   TEMPORARY_VAR SET	Overlay
      5  0933				   TEMPORARY_OFFSET SET	0
      6  0933				   VAR_BOUNDARY_AddMoveSimple SET	TEMPORARY_OFFSET
      7  0933				   FUNCTION_NAME SET	AddMoveSimple
    465  0933					      SUBROUTINE
    466  0933
      0  0933					      VEND	AddMoveSimple
      1  0933				  -	      IFNCONST	AddMoveSimple
      2  0933				  -	      ECHO	"Incorrect VEND label", AddMoveSimple
      3  0933				  -	      ERR
      4  0933					      ENDIF
      5  0933		       00 a7	   VAREND_AddMoveSimple =	TEMPORARY_VAR
    468  0933
    469  0933							; add square in y register to movelist as destination (X12 format)
    470  0933							; [y]		     to square (X12)
    471  0933							; currentSquare     from square (X12)
    472  0933							; currentPiece      piece.
    473  0933							;   ENPASSANT flag set if pawn double-moving off opening rank
    474  0933							; capture	     captured piece
    475  0933
    476  0933		       a5 9b		      lda	capture
    477  0935		       d0 04		      bne	.always
    478  0937		       a5 b2		      lda	__quiesceCapOnly
    479  0939		       d0 1a		      bne	.abort
    480  093b
    481  093b		       98	   .always    tya
    482  093c
      0  093c					      ldy@PLY	moveIndex
      1  093c		       ac cf f9 	      ldy	moveIndex
    484  093f		       c8		      iny
      0  0940					      sty@PLY	moveIndex
      1  0940		       8c cf fb 	      sty	[RAM]+moveIndex
    486  0943
      0  0943					      sta@PLY	MoveTo,y
      1  0943		       99 64 fa 	      sta	[RAM]+MoveTo,y
    488  0946		       a5 92		      lda	currentSquare
      0  0948					      sta@PLY	MoveFrom,y
      1  0948		       99 00 fa 	      sta	[RAM]+MoveFrom,y
    490  094b		       a5 91		      lda	currentPiece
      0  094d					      sta@PLY	MovePiece,y
      1  094d		       99 00 fb 	      sta	[RAM]+MovePiece,y
    492  0950		       a5 9b		      lda	capture
      0  0952					      sta@PLY	MoveCapture,y
      1  0952		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    494  0955
    495  0955		       60	   .abort     rts
    496  0956
    497  0956
    498  0956							;---------------------------------------------------------------------------------------------------
    499  0956
      0  0956					      DEF	aiSpecialMoveFixup
      1  0956				   SLOT_aiSpecialMoveFixup SET	_BANK_SLOT
      2  0956				   BANK_aiSpecialMoveFixup SET	SLOT_aiSpecialMoveFixup + _CURRENT_BANK
      3  0956				   aiSpecialMoveFixup
      4  0956				   TEMPORARY_VAR SET	Overlay
      5  0956				   TEMPORARY_OFFSET SET	0
      6  0956				   VAR_BOUNDARY_aiSpecialMoveFixup SET	TEMPORARY_OFFSET
      7  0956				   FUNCTION_NAME SET	aiSpecialMoveFixup
    501  0956					      SUBROUTINE
    502  0956
      0  0956					      COMMON_VARS
      1  0956
      0  0956					      VAR	__thinkbar, 1
      1  0956		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  0956				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0956
      4  0956				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0956				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0956				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0956					      ENDIF
      8  0956				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0956				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  0956				  -	      ERR
     11  0956					      ENDIF
     12  0956					      LIST	ON
      0  0956					      VAR	__toggle, 1
      1  0956		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  0956				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0956
      4  0956				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0956				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0956				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0956					      ENDIF
      8  0956				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0956				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  0956				  -	      ERR
     11  0956					      ENDIF
     12  0956					      LIST	ON
      4  0956
      0  0956					      VAR	__bestMove, 1
      1  0956		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  0956				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0956
      4  0956				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0956				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0956				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0956					      ENDIF
      8  0956				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0956				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  0956				  -	      ERR
     11  0956					      ENDIF
     12  0956					      LIST	ON
      0  0956					      VAR	__alpha, 2
      1  0956		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  0956				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0956
      4  0956				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0956				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0956				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0956					      ENDIF
      8  0956				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0956				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  0956				  -	      ERR
     11  0956					      ENDIF
     12  0956					      LIST	ON
      0  0956					      VAR	__beta, 2
      1  0956		       00 ac	   __beta     =	TEMPORARY_VAR
      2  0956				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0956
      4  0956				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0956				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0956				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0956					      ENDIF
      8  0956				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0956				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  0956				  -	      ERR
     11  0956					      ENDIF
     12  0956					      LIST	ON
      0  0956					      VAR	__negaMax, 2
      1  0956		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  0956				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0956
      4  0956				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0956				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0956				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0956					      ENDIF
      8  0956				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0956				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  0956				  -	      ERR
     11  0956					      ENDIF
     12  0956					      LIST	ON
      0  0956					      VAR	__value, 2
      1  0956		       00 b0	   __value    =	TEMPORARY_VAR
      2  0956				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0956
      4  0956				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0956				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0956				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0956					      ENDIF
      8  0956				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0956				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  0956				  -	      ERR
     11  0956					      ENDIF
     12  0956					      LIST	ON
     10  0956
      0  0956					      VAR	__quiesceCapOnly, 1
      1  0956		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  0956				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0956
      4  0956				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0956				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0956				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0956					      ENDIF
      8  0956				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0956				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  0956				  -	      ERR
     11  0956					      ENDIF
     12  0956					      LIST	ON
     12  0956
      0  0956					      VAR	__originalPiece, 1
      1  0956		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  0956				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0956
      4  0956				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0956				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0956				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0956					      ENDIF
      8  0956				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0956				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  0956				  -	      ERR
     11  0956					      ENDIF
     12  0956					      LIST	ON
      0  0956					      VAR	__capturedPiece, 1
      1  0956		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  0956				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0956
      4  0956				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0956				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0956				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0956					      ENDIF
      8  0956				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0956				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  0956				  -	      ERR
     11  0956					      ENDIF
     12  0956					      LIST	ON
     15  0956
      0  0956					      REFER	AiStateMachine	;✅
      1  0956				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0956				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0956					      ENDIF
      0  0956					      VEND	aiSpecialMoveFixup
      1  0956				  -	      IFNCONST	aiSpecialMoveFixup
      2  0956				  -	      ECHO	"Incorrect VEND label", aiSpecialMoveFixup
      3  0956				  -	      ERR
      4  0956					      ENDIF
      5  0956		       00 b5	   VAREND_aiSpecialMoveFixup =	TEMPORARY_VAR
    506  0956
    507  0956		       ad 84 02 	      lda	INTIM
    508  0959		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    509  095b		       b0 01		      bcs	.cont
    510  095d		       60		      rts
    511  095e
    512  095e
    513  095e				   .cont
    514  095e
      0  095e					      PHASE	AI_DelayAfterPlaced
      1  095e		       a9 27		      lda	#AI_DelayAfterPlaced
      2  0960		       85 8b		      sta	aiState
    516  0962
    517  0962
    518  0962							; Special move fixup
    519  0962
    520  0962		       a5 94		      lda	currentPly
    521  0964		       85 3e		      sta	SET_BANK_RAM
    522  0966
    523  0966		       20 97 f5 	      jsr	CastleFixupDraw
    524  0969
    525  0969		       a5 85		      lda	fromX12
    526  096b		       85 80		      sta	squareToDraw
    527  096d
    528  096d		       60		      rts
    529  096e
    530  096e
    531  096e							;---------------------------------------------------------------------------------------------------
    532  096e
    533  096e
    534  096e
      0  096e					      DEF	aiEPFlash
      1  096e				   SLOT_aiEPFlash SET	_BANK_SLOT
      2  096e				   BANK_aiEPFlash SET	SLOT_aiEPFlash + _CURRENT_BANK
      3  096e				   aiEPFlash
      4  096e				   TEMPORARY_VAR SET	Overlay
      5  096e				   TEMPORARY_OFFSET SET	0
      6  096e				   VAR_BOUNDARY_aiEPFlash SET	TEMPORARY_OFFSET
      7  096e				   FUNCTION_NAME SET	aiEPFlash
    536  096e					      SUBROUTINE
    537  096e
      0  096e					      REFER	AiStateMachine
      1  096e					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  096e				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  096e					      ENDIF
      0  096e					      VEND	aiEPFlash
      1  096e				  -	      IFNCONST	aiEPFlash
      2  096e				  -	      ECHO	"Incorrect VEND label", aiEPFlash
      3  096e				  -	      ERR
      4  096e					      ENDIF
      5  096e		       00 a9	   VAREND_aiEPFlash =	TEMPORARY_VAR
    540  096e
    541  096e		       a5 82		      lda	drawDelay
    542  0970		       f0 03		      beq	.deCount
    543  0972		       c6 82		      dec	drawDelay
    544  0974		       60		      rts
    545  0975
    546  0975		       a5 84	   .deCount   lda	drawCount
    547  0977		       f0 0e		      beq	.flashDone2
    548  0979		       c6 84		      dec	drawCount
    549  097b
    550  097b		       a9 0a		      lda	#10
    551  097d		       85 82		      sta	drawDelay	; "getting ready to move" flash
    552  097f
    553  097f		       a5 93		      lda	enPassantPawn
    554  0981		       85 80		      sta	squareToDraw
    555  0983
    556  0983							; WARNING - local variables will not survive the following call...!
    557  0983		       20 cb f0 	      jsr	CopySinglePiece	;@0
    558  0986		       60		      rts
    559  0987
    560  0987				   .flashDone2
    561  0987
    562  0987
    563  0987		       a9 00		      lda	#0	; on/off count
    564  0989		       85 84		      sta	drawCount	; flashing for piece about to move
    565  098b		       a9 00		      lda	#0
    566  098d		       85 82		      sta	drawDelay
    567  098f
    568  098f		       20 ac f3 	      jsr	EnPassantRemoveCapturedPawn
    569  0992
    570  0992							;lda #100
    571  0992							;sta aiFlashDelay ;???
    572  0992
      0  0992					      PHASE	AI_FinalFlash
      1  0992		       a9 1b		      lda	#AI_FinalFlash
      2  0994		       85 8b		      sta	aiState
    574  0996		       60		      rts
    575  0997
    576  0997
    577  0997							;---------------------------------------------------------------------------------------------------
    578  0997
      0  0997					      DEF	CastleFixupDraw
      1  0997				   SLOT_CastleFixupDraw SET	_BANK_SLOT
      2  0997				   BANK_CastleFixupDraw SET	SLOT_CastleFixupDraw + _CURRENT_BANK
      3  0997				   CastleFixupDraw
      4  0997				   TEMPORARY_VAR SET	Overlay
      5  0997				   TEMPORARY_OFFSET SET	0
      6  0997				   VAR_BOUNDARY_CastleFixupDraw SET	TEMPORARY_OFFSET
      7  0997				   FUNCTION_NAME SET	CastleFixupDraw
    580  0997					      SUBROUTINE
    581  0997
      0  0997					      REFER	aiSpecialMoveFixup	;✅
      1  0997					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  0997				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  0997					      ENDIF
      0  0997					      VEND	CastleFixupDraw
      1  0997				  -	      IFNCONST	CastleFixupDraw
      2  0997				  -	      ECHO	"Incorrect VEND label", CastleFixupDraw
      3  0997				  -	      ERR
      4  0997					      ENDIF
      5  0997		       00 b5	   VAREND_CastleFixupDraw =	TEMPORARY_VAR
    584  0997
    585  0997							; guarantee flags for piece, post-move, are correct
    586  0997
    587  0997
    588  0997		       a9 d1		      lda	#RAMBANK_BOARD
    589  0999		       85 3e		      sta	SET_BANK_RAM	;@2
    590  099b
    591  099b		       a5 96		      lda	fromPiece
    592  099d		       29 df		      and	#~FLAG_ENPASSANT
    593  099f		       09 40		      ora	#FLAG_MOVED
    594  09a1
    595  09a1		       a4 85		      ldy	fromX12	; destinatino
      0  09a3					      sta@RAM	Board,y
      1  09a3		       99 79 fe 	      sta	[RAM]+Board,y
    597  09a6
    598  09a6
    599  09a6							; fixup any castling issues
    600  09a6							; at this point the king has finished his two-square march
    601  09a6							; based on the finish square, we determine which rook we're interacting with
    602  09a6							; and generate a 'move' for the rook to position on the other side of the king
    603  09a6
    604  09a6
    605  09a6					      IF	CASTLING_ENABLED
      0  09a6					      CALL	GenCastleMoveForRook	;@3
      1  09a6				  -	      IF	SLOT_GenCastleMoveForRook == _BANK_SLOT
      2  09a6				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  09a6				  -	      ECHO	"Cannot switch bank in use for", GenCastleMoveForRook
      4  09a6				  -	      ERR
      5  09a6					      ENDIF
      6  09a6		       a9 db		      lda	#BANK_GenCastleMoveForRook
      7  09a8		       85 3f		      sta	SET_BANK
      8  09aa		       20 21 fc 	      jsr	GenCastleMoveForRook
    607  09ad		       b0 07		      bcs	.phase
    608  09af					      ENDIF
    609  09af
      0  09af					      SWAP
      1  09af		       a5 95		      lda	sideToMove
      2  09b1		       49 c0		      eor	#SWAP_SIDE|HUMAN
      3  09b3		       85 95		      sta	sideToMove
      4  09b5
      5  09b5
    611  09b5		       60		      rts
    612  09b6
    613  09b6				   .phase
    614  09b6
    615  09b6							; in this siutation (castle, rook moving) we do not change sides yet!
    616  09b6
      0  09b6					      PHASE	AI_MoveIsSelected
      1  09b6		       a9 14		      lda	#AI_MoveIsSelected
      2  09b8		       85 8b		      sta	aiState
    618  09ba		       60		      rts
    619  09bb
    620  09bb
    621  09bb
    622  09bb							;---------------------------------------------------------------------------------------------------
    623  09bb
      0  09bb					      DEF	aiDrawEntireBoard
      1  09bb				   SLOT_aiDrawEntireBoard SET	_BANK_SLOT
      2  09bb				   BANK_aiDrawEntireBoard SET	SLOT_aiDrawEntireBoard + _CURRENT_BANK
      3  09bb				   aiDrawEntireBoard
      4  09bb				   TEMPORARY_VAR SET	Overlay
      5  09bb				   TEMPORARY_OFFSET SET	0
      6  09bb				   VAR_BOUNDARY_aiDrawEntireBoard SET	TEMPORARY_OFFSET
      7  09bb				   FUNCTION_NAME SET	aiDrawEntireBoard
    625  09bb					      SUBROUTINE
    626  09bb
      0  09bb					      REFER	AiStateMachine	;✅
      1  09bb					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  09bb				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  09bb					      ENDIF
    628  09bb
      0  09bb					      VEND	aiDrawEntireBoard
      1  09bb				  -	      IFNCONST	aiDrawEntireBoard
      2  09bb				  -	      ECHO	"Incorrect VEND label", aiDrawEntireBoard
      3  09bb				  -	      ERR
      4  09bb					      ENDIF
      5  09bb		       00 a9	   VAREND_aiDrawEntireBoard =	TEMPORARY_VAR
    630  09bb
    631  09bb
    632  09bb		       ad 84 02 	      lda	INTIM
    633  09be		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    634  09c0		       90 2c		      bcc	.exit
    635  09c2
    636  09c2							; We use [SLOT3] for accessing board
    637  09c2
    638  09c2		       a9 d1		      lda	#RAMBANK_BOARD
    639  09c4		       85 3e		      sta	SET_BANK_RAM
    640  09c6		       a4 80		      ldy	squareToDraw
    641  09c8		       b9 15 fc 	      lda	ValidSquare,y
    642  09cb		       30 1d		      bmi	.isablank2
    643  09cd
    644  09cd		       b9 79 fc 	      lda	Board,y
    645  09d0		       f0 13		      beq	.isablank
    646  09d2		       48		      pha
    647  09d3		       a9 00		      lda	#BLANK
      0  09d5					      sta@RAM	Board,y
      1  09d5		       99 79 fe 	      sta	[RAM]+Board,y
    649  09d8
    650  09d8							; WARNING - local variables will not survive the following call...!
    651  09d8		       20 cb f0 	      jsr	CopySinglePiece	;@0
    652  09db
    653  09db		       a9 d1		      lda	#RAMBANK_BOARD
    654  09dd		       85 3e		      sta	SET_BANK_RAM
    655  09df
    656  09df		       a4 80		      ldy	squareToDraw
    657  09e1		       68		      pla
      0  09e2					      sta@RAM	Board,y
      1  09e2		       99 79 fe 	      sta	[RAM]+Board,y
    659  09e5
      0  09e5				   .isablank  PHASE	AI_DrawPart2
      1  09e5		       a9 10		      lda	#AI_DrawPart2
      2  09e7		       85 8b		      sta	aiState
    661  09e9		       60		      rts
    662  09ea
      0  09ea				   .isablank2 PHASE	AI_DrawPart3
      1  09ea		       a9 11		      lda	#AI_DrawPart3
      2  09ec		       85 8b		      sta	aiState
    664  09ee		       60	   .exit      rts
    665  09ef
    666  09ef
    667  09ef							;---------------------------------------------------------------------------------------------------
    668  09ef
      0  09ef					      DEF	aiDrawPart2
      1  09ef				   SLOT_aiDrawPart2 SET	_BANK_SLOT
      2  09ef				   BANK_aiDrawPart2 SET	SLOT_aiDrawPart2 + _CURRENT_BANK
      3  09ef				   aiDrawPart2
      4  09ef				   TEMPORARY_VAR SET	Overlay
      5  09ef				   TEMPORARY_OFFSET SET	0
      6  09ef				   VAR_BOUNDARY_aiDrawPart2 SET	TEMPORARY_OFFSET
      7  09ef				   FUNCTION_NAME SET	aiDrawPart2
    670  09ef					      SUBROUTINE
    671  09ef
      0  09ef					      REFER	AiStateMachine
      1  09ef					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  09ef				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  09ef					      ENDIF
      0  09ef					      VEND	aiDrawPart2
      1  09ef				  -	      IFNCONST	aiDrawPart2
      2  09ef				  -	      ECHO	"Incorrect VEND label", aiDrawPart2
      3  09ef				  -	      ERR
      4  09ef					      ENDIF
      5  09ef		       00 a9	   VAREND_aiDrawPart2 =	TEMPORARY_VAR
    674  09ef
    675  09ef							; WARNING - local variables will not survive the following call...!
    676  09ef		       20 cb f0 	      jsr	CopySinglePiece	;@0
    677  09f2
      0  09f2					      DEF	aiDrawPart3
      1  09f2				   SLOT_aiDrawPart3 SET	_BANK_SLOT
      2  09f2				   BANK_aiDrawPart3 SET	SLOT_aiDrawPart3 + _CURRENT_BANK
      3  09f2				   aiDrawPart3
      4  09f2				   TEMPORARY_VAR SET	Overlay
      5  09f2				   TEMPORARY_OFFSET SET	0
      6  09f2				   VAR_BOUNDARY_aiDrawPart3 SET	TEMPORARY_OFFSET
      7  09f2				   FUNCTION_NAME SET	aiDrawPart3
    679  09f2					      SUBROUTINE
    680  09f2
    681  09f2		       c6 80		      dec	squareToDraw
    682  09f4		       a5 80		      lda	squareToDraw
    683  09f6		       c9 16		      cmp	#22
    684  09f8		       90 05		      bcc	.comp
    685  09fa
      0  09fa					      PHASE	AI_DrawEntireBoard
      1  09fa		       a9 0f		      lda	#AI_DrawEntireBoard
      2  09fc		       85 8b		      sta	aiState
    687  09fe		       60		      rts
    688  09ff
    689  09ff				   .comp
    690  09ff
    691  09ff		       a9 ff		      lda	#-1
    692  0a01		       85 86		      sta	toX12	; becomes startup flash square
    693  0a03		       a9 24		      lda	#36	; becomes cursor position
    694  0a05		       85 87		      sta	originX12
    695  0a07
    696  0a07
      0  0a07					      PHASE	AI_GenerateMoves
      1  0a07		       a9 12		      lda	#AI_GenerateMoves
      2  0a09		       85 8b		      sta	aiState
    698  0a0b		       60		      rts
    699  0a0c
    700  0a0c
    701  0a0c							;---------------------------------------------------------------------------------------------------
    702  0a0c
      0  0a0c					      DEF	aiMarchB
      1  0a0c				   SLOT_aiMarchB SET	_BANK_SLOT
      2  0a0c				   BANK_aiMarchB SET	SLOT_aiMarchB + _CURRENT_BANK
      3  0a0c				   aiMarchB
      4  0a0c				   TEMPORARY_VAR SET	Overlay
      5  0a0c				   TEMPORARY_OFFSET SET	0
      6  0a0c				   VAR_BOUNDARY_aiMarchB SET	TEMPORARY_OFFSET
      7  0a0c				   FUNCTION_NAME SET	aiMarchB
    704  0a0c					      SUBROUTINE
    705  0a0c
      0  0a0c					      REFER	AiStateMachine
      1  0a0c					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0a0c				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0a0c					      ENDIF
      0  0a0c					      VEND	aiMarchB
      1  0a0c				  -	      IFNCONST	aiMarchB
      2  0a0c				  -	      ECHO	"Incorrect VEND label", aiMarchB
      3  0a0c				  -	      ERR
      4  0a0c					      ENDIF
      5  0a0c		       00 a9	   VAREND_aiMarchB =	TEMPORARY_VAR
    708  0a0c
    709  0a0c							; Draw the piece in the new square
    710  0a0c
    711  0a0c		       a5 85		      lda	fromX12
    712  0a0e		       85 80		      sta	squareToDraw
    713  0a10
    714  0a10							; WARNING - local variables will not survive the following call...!
    715  0a10		       20 cb f0 	      jsr	CopySinglePiece	;@0	      ; draw the moving piece into the new square
    716  0a13
    717  0a13		       a9 02		      lda	#2	; snail trail delay
    718  0a15		       85 82		      sta	drawDelay
    719  0a17
      0  0a17					      PHASE	AI_MarchToTargetB
      1  0a17		       a9 19		      lda	#AI_MarchToTargetB
      2  0a19		       85 8b		      sta	aiState
    721  0a1b		       60		      rts
    722  0a1c
    723  0a1c
    724  0a1c							;---------------------------------------------------------------------------------------------------
    725  0a1c
      0  0a1c					      DEF	aiDraw
      1  0a1c				   SLOT_aiDraw SET	_BANK_SLOT
      2  0a1c				   BANK_aiDraw SET	SLOT_aiDraw + _CURRENT_BANK
      3  0a1c				   aiDraw
      4  0a1c				   TEMPORARY_VAR SET	Overlay
      5  0a1c				   TEMPORARY_OFFSET SET	0
      6  0a1c				   VAR_BOUNDARY_aiDraw SET	TEMPORARY_OFFSET
      7  0a1c				   FUNCTION_NAME SET	aiDraw
    727  0a1c					      SUBROUTINE
    728  0a1c		       a9 c0		      lda	#$C0
    729  0a1e		       85 49		      sta	COLUBK
    730  0a20		       60		      rts
    731  0a21
    732  0a21
    733  0a21							;---------------------------------------------------------------------------------------------------
    734  0a21
      0  0a21					      DEF	aiCheckMate
      1  0a21				   SLOT_aiCheckMate SET	_BANK_SLOT
      2  0a21				   BANK_aiCheckMate SET	SLOT_aiCheckMate + _CURRENT_BANK
      3  0a21				   aiCheckMate
      4  0a21				   TEMPORARY_VAR SET	Overlay
      5  0a21				   TEMPORARY_OFFSET SET	0
      6  0a21				   VAR_BOUNDARY_aiCheckMate SET	TEMPORARY_OFFSET
      7  0a21				   FUNCTION_NAME SET	aiCheckMate
    736  0a21					      SUBROUTINE
    737  0a21		       a9 44		      lda	#$44
    738  0a23		       85 49		      sta	COLUBK
    739  0a25		       60		      rts
    740  0a26
    741  0a26
    742  0a26							;---------------------------------------------------------------------------------------------------
    743  0a26
      0  0a26					      DEF	aiQuiescent
      1  0a26				   SLOT_aiQuiescent SET	_BANK_SLOT
      2  0a26				   BANK_aiQuiescent SET	SLOT_aiQuiescent + _CURRENT_BANK
      3  0a26				   aiQuiescent
      4  0a26				   TEMPORARY_VAR SET	Overlay
      5  0a26				   TEMPORARY_OFFSET SET	0
      6  0a26				   VAR_BOUNDARY_aiQuiescent SET	TEMPORARY_OFFSET
      7  0a26				   FUNCTION_NAME SET	aiQuiescent
    745  0a26					      SUBROUTINE
    746  0a26
      0  0a26					      REFER	AiStateMachine
      1  0a26					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0a26				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0a26					      ENDIF
      0  0a26					      VEND	aiQuiescent
      1  0a26				  -	      IFNCONST	aiQuiescent
      2  0a26				  -	      ECHO	"Incorrect VEND label", aiQuiescent
      3  0a26				  -	      ERR
      4  0a26					      ENDIF
      5  0a26		       00 a9	   VAREND_aiQuiescent =	TEMPORARY_VAR
    749  0a26
    750  0a26							; Move has been selected
    751  0a26
    752  0a26		       a9 ff		      lda	#-1
    753  0a28		       85 88		      sta	cursorX12
    754  0a2a
    755  0a2a		       a5 85		      lda	fromX12
    756  0a2c		       85 87		      sta	originX12
      0  0a2e					      CALL	GetPiece	;@3		    ; from the movelist
      1  0a2e				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  0a2e				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0a2e				  -	      ECHO	"Cannot switch bank in use for", GetPiece
      4  0a2e				  -	      ERR
      5  0a2e					      ENDIF
      6  0a2e		       a9 db		      lda	#BANK_GetPiece
      7  0a30		       85 3f		      sta	SET_BANK
      8  0a32		       20 00 fc 	      jsr	GetPiece
    758  0a35
    759  0a35		       a4 85		      ldy	fromX12
    760  0a37		       a9 d1		      lda	#RAMBANK_BOARD
    761  0a39		       85 3e		      sta	SET_BANK_RAM	;@3
    762  0a3b		       b9 79 fc 	      lda	Board,y
    763  0a3e		       45 96		      eor	fromPiece
    764  0a40		       29 0f		      and	#PIECE_MASK	; if not the same piece board/movelist...
    765  0a42		       d0 05		      bne	.promote	; promote a pawn
    766  0a44
      0  0a44					      PHASE	AI_MoveIsSelected
      1  0a44		       a9 14		      lda	#AI_MoveIsSelected
      2  0a46		       85 8b		      sta	aiState
    768  0a48		       60		      rts
    769  0a49
      0  0a49				   .promote   PHASE	AI_PromotePawnStart
      1  0a49		       a9 1f		      lda	#AI_PromotePawnStart
      2  0a4b		       85 8b		      sta	aiState
    771  0a4d		       60		      rts
    772  0a4e
    773  0a4e
    774  0a4e							;---------------------------------------------------------------------------------------------------
    775  0a4e
      0  0a4e					      CHECK_BANK_SIZE	"BANK_GENERIC@1#1"
      1  0a4e		       02 4e	   .TEMP      =	* - _BANK_START
 BANK_GENERIC@1#1 (1K) SIZE =  $24e , FREE= $1b2
      2  0a4e					      ECHO	"BANK_GENERIC@1#1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  0a4e				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  0a4e				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC@1#1", " size=", * - ORIGIN
      5  0a4e				  -	      ERR
      6  0a4e					      ENDIF
    777  0a4e
    778  0a4e							;---------------------------------------------------------------------------------------------------
    779  0a4e							; EOF
------- FILE ./chess.asm
------- FILE BANK_ROM_SHADOW_SCREEN.asm LEVEL 2 PASS 4
      0  0a4e					      include	"BANK_ROM_SHADOW_SCREEN.asm"
      1  0a4e
      0  0a4e					      SLOT	2
      1  0a4e				  -	      IF	(2 < 0) || (2 > 3)
      2  0a4e				  -	      ECHO	"Illegal bank address/segment location", 2
      3  0a4e				  -	      ERR
      4  0a4e					      ENDIF
      5  0a4e				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  0a4e				   _BANK_SLOT SET	2 * 64
      0  0a4e					      ROMBANK	BITMAP
      1  0da6 ????				      SEG	BITMAP
      2  0c00					      ORG	_ORIGIN
      3  0c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  0c00				   _BANK_START SET	*
      5  0c00				   BITMAP_START SET	*
      6  0c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0c00				   BITMAP     SET	_BANK_SLOT + _CURRENT_BANK
      8  0c00				   _ORIGIN    SET	_ORIGIN + 1024
      4  0c00
      5  0c00							; These equates allow revectoring (address offset) if the RAM slot is not the same as the SHADOW slot
      6  0c00
      7  0c00		       f8 00	   ChessBitmap =	SHADOW_ChessBitmap
      8  0c00
      9  0c00		       f8 00	   ChessBitmap0 =	SHADOW_ChessBitmap0
     10  0c00		       f8 18	   ChessBitmap1 =	SHADOW_ChessBitmap1
     11  0c00		       f8 30	   ChessBitmap2 =	SHADOW_ChessBitmap2
     12  0c00		       f8 48	   ChessBitmap3 =	SHADOW_ChessBitmap3
     13  0c00		       f8 60	   ChessBitmap4 =	SHADOW_ChessBitmap4
     14  0c00		       f8 78	   ChessBitmap5 =	SHADOW_ChessBitmap5
     15  0c00
     16  0c00							; Template bank for a SINGLE ROW of the chessboard display.
     17  0c00							; There are 8x of these.
     18  0c00							; The bank contains the definition of the bitmap, and also the code to draw the bitmap
     19  0c00							; The bank is copied from ROM into RAM at startup.
     20  0c00							; The draw switches between consecutive row banks, with the last returning
     21  0c00							; we effectively have 1K
     22  0c00							;---------------------------------------------------------------------------------------------------
     23  0c00
     24  0c00		       00 84	   COLOUR_LINE_1 =	$84
     25  0c00		       00 48	   COLOUR_LINE_2 =	$48
     26  0c00		       00 2e	   COLOUR_LINE_3 =	$2e
     27  0c00		       00 00	   BACKGCOL   =	$00
     28  0c00
     29  0c00
     30  0c00		       00 90	   ROW_BITMAP_SIZE =	6 * 24	; PF0/PF1/PF2/(PF0)/(PF1)/(PF2) x 8 ICC pixels
     31  0c00
     32  0c00
      0  0c00					      ALLOCATE	SHADOW_ChessBitmap, ROW_BITMAP_SIZE
      0  0c00					      OPTIONAL_PAGEBREAK	"Table", ROW_BITMAP_SIZE
     12  0c00					      LIST	ON
      0  0c00					      DEF	SHADOW_ChessBitmap
      1  0c00				   SLOT_SHADOW_ChessBitmap SET	_BANK_SLOT
      2  0c00				   BANK_SHADOW_ChessBitmap SET	SLOT_SHADOW_ChessBitmap + _CURRENT_BANK
      3  0c00				   SHADOW_ChessBitmap
      4  0c00				   TEMPORARY_VAR SET	Overlay
      5  0c00				   TEMPORARY_OFFSET SET	0
      6  0c00				   VAR_BOUNDARY_SHADOW_ChessBitmap SET	TEMPORARY_OFFSET
      7  0c00				   FUNCTION_NAME SET	SHADOW_ChessBitmap
     34  0c00		       00 00 00 00*SHADOW_ChessBitmap0 ds	24
     35  0c18		       00 00 00 00*SHADOW_ChessBitmap1 ds	24
     36  0c30		       00 00 00 00*SHADOW_ChessBitmap2 ds	24
     37  0c48		       00 00 00 00*SHADOW_ChessBitmap3 ds	24
     38  0c60		       00 00 00 00*SHADOW_ChessBitmap4 ds	24
     39  0c78		       00 00 00 00*SHADOW_ChessBitmap5 ds	24
     40  0c90
      0  0c90					      ALLOCATE	BlankSprite, 8
      0  0c90					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0c90					      LIST	ON
      0  0c90					      DEF	BlankSprite
      1  0c90				   SLOT_BlankSprite SET	_BANK_SLOT
      2  0c90				   BANK_BlankSprite SET	SLOT_BlankSprite + _CURRENT_BANK
      3  0c90				   BlankSprite
      4  0c90				   TEMPORARY_VAR SET	Overlay
      5  0c90				   TEMPORARY_OFFSET SET	0
      6  0c90				   VAR_BOUNDARY_BlankSprite SET	TEMPORARY_OFFSET
      7  0c90				   FUNCTION_NAME SET	BlankSprite
     42  0c90		       00 00 00 00*	      ds	8, 0
     43  0c98
      0  0c98					      ALLOCATE	SpriteBuffer, 8
      0  0c98					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0c98					      LIST	ON
      0  0c98					      DEF	SpriteBuffer
      1  0c98				   SLOT_SpriteBuffer SET	_BANK_SLOT
      2  0c98				   BANK_SpriteBuffer SET	SLOT_SpriteBuffer + _CURRENT_BANK
      3  0c98				   SpriteBuffer
      4  0c98				   TEMPORARY_VAR SET	Overlay
      5  0c98				   TEMPORARY_OFFSET SET	0
      6  0c98				   VAR_BOUNDARY_SpriteBuffer SET	TEMPORARY_OFFSET
      7  0c98				   FUNCTION_NAME SET	SpriteBuffer
     45  0c98				   SpriteBuffer2
     46  0c98		       f8		      .byte.b	%11111000
     47  0c99		       f8		      .byte.b	%11111000
     48  0c9a		       f8		      .byte.b	%11111000
     49  0c9b		       f8		      .byte.b	%11111000
     50  0c9c		       f8		      .byte.b	%11111000
     51  0c9d		       f8		      .byte.b	%11111000
     52  0c9e		       f8		      .byte.b	%11111000
     53  0c9f		       f8		      .byte.b	%11111000
     54  0ca0
     55  0ca0				  -	      IF	0
     56  0ca0				  -	      ALLOCATE	BackupBitmap, ROW_BITMAP_SIZE
     57  0ca0				  -	      ds	ROW_BITMAP_SIZE, 0
     58  0ca0					      ENDIF
     59  0ca0
     60  0ca0							;---------------------------------------------------------------------------------------------------
     61  0ca0
     62  0d00		       00 00 00 00*	      ALIGN	256
     63  0d00					      SUBROUTINE
     64  0d00
      0  0d00					      REFER	StartupBankReset
      1  0d00				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0d00				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0d00					      ENDIF
     66  0d00				   __dummy
      0  0d00					      VEND	__dummy
      1  0d00				  -	      IFNCONST	__dummy
      2  0d00				  -	      ECHO	"Incorrect VEND label", __dummy
      3  0d00				  -	      ERR
      4  0d00					      ENDIF
      5  0d00		       00 a7	   VAREND___dummy =	TEMPORARY_VAR
     68  0d00
     69  0d00							; x = row # (and bank#)
     70  0d00
     71  0d00				   .endline
     72  0d00
     73  0d00							;@59
     74  0d00
     75  0d00							; The following 'inx' is replaced in the LAST row bank with a 'RTS', thus ending the draw loop
     76  0d00							; Note that the other 7 row banks are unmodified (keeping the 'inx')
     77  0d00				   SELFMOD_RTS_ON_LAST_ROW
     78  0d00
     79  0d00		       e8		      inx		; 2
     80  0d01		       86 3e		      stx	SET_BANK_RAM	; 3 @64     BANK switch to next row
     81  0d03
      0  0d03					      DEF	DrawRow
      1  0d03				   SLOT_DrawRow SET	_BANK_SLOT
      2  0d03				   BANK_DrawRow SET	SLOT_DrawRow + _CURRENT_BANK
      3  0d03				   DrawRow
      4  0d03				   TEMPORARY_VAR SET	Overlay
      5  0d03				   TEMPORARY_OFFSET SET	0
      6  0d03				   VAR_BOUNDARY_DrawRow SET	TEMPORARY_OFFSET
      7  0d03				   FUNCTION_NAME SET	DrawRow
     83  0d03
     84  0d03							;@64
     85  0d03		       a0 07		      ldy	#7	; 2
     86  0d05		       10 3b		      bpl	.dl2	; 3   (must be 69 here)
     87  0d07
     88  0d07							;@58...
     89  0d07
     90  0d07				   .l3
     91  0d07
     92  0d07		       b9 a8 f8    SMSPRITE16_0 lda	SpriteBuffer+16,y	; 4
     93  0d0a		       85 5b		      sta	GRP0	; 3
     94  0d0c		       b9 a8 f8    SMSPRITE16_1 lda	SpriteBuffer2+16,y	; 4
     95  0d0f		       85 5c		      sta	GRP1	; 3
     96  0d11
     97  0d11							;@-4
     98  0d11
     99  0d11		       a9 84		      lda	#COLOUR_LINE_1	;#$94			  ; 2
    100  0d13		       85 48		      sta	COLUPF	; 3 @1
    101  0d15
    102  0d15		       b9 10 f8 	      lda	ChessBitmap0+16,y	; 4
    103  0d18		       85 4d		      sta	PF0	; 3
    104  0d1a		       b9 28 f8 	      lda	ChessBitmap1+16,y	; 4
    105  0d1d		       85 4e		      sta	PF1	; 3
    106  0d1f		       b9 40 f8 	      lda	ChessBitmap2+16,y	; 4
    107  0d22		       85 4f		      sta	PF2	; 3 @22
    108  0d24
      0  0d24					      SLEEP	6	; 6 @28
      1  0d24				   .CYCLES    SET	6
      2  0d24
      3  0d24				  -	      IF	.CYCLES < 2
      4  0d24				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0d24				  -	      ERR
      6  0d24					      ENDIF
      7  0d24
      8  0d24				  -	      IF	.CYCLES & 1
      9  0d24				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0d24				  -	      nop	0
     11  0d24				  -	      ELSE
     12  0d24				  -	      bit	VSYNC
     13  0d24				  -	      ENDIF
     14  0d24				  -.CYCLES    SET	.CYCLES - 3
     15  0d24					      ENDIF
     16  0d24
     17  0d24					      REPEAT	.CYCLES / 2
     18  0d24		       ea		      nop
     17  0d24					      REPEND
     18  0d25		       ea		      nop
     17  0d25					      REPEND
     18  0d26		       ea		      nop
     19  0d27					      REPEND
    110  0d27
    111  0d27		       b9 58 f8 	      lda	ChessBitmap3+16,y	; 4
    112  0d2a		       85 4d		      sta	PF0	; 3
    113  0d2c		       b9 70 f8 	      lda	ChessBitmap4+16,y	; 4
    114  0d2f		       85 4e		      sta	PF1	; 3
    115  0d31		       b9 88 f8 	      lda	ChessBitmap5+16,y	; 4
    116  0d34		       8d 4f 00 	      sta.w	PF2	; 4 @50
    117  0d37
      0  0d37					      SLEEP	4	; 4
      1  0d37				   .CYCLES    SET	4
      2  0d37
      3  0d37				  -	      IF	.CYCLES < 2
      4  0d37				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0d37				  -	      ERR
      6  0d37					      ENDIF
      7  0d37
      8  0d37				  -	      IF	.CYCLES & 1
      9  0d37				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0d37				  -	      nop	0
     11  0d37				  -	      ELSE
     12  0d37				  -	      bit	VSYNC
     13  0d37				  -	      ENDIF
     14  0d37				  -.CYCLES    SET	.CYCLES - 3
     15  0d37					      ENDIF
     16  0d37
     17  0d37					      REPEAT	.CYCLES / 2
     18  0d37		       ea		      nop
     17  0d37					      REPEND
     18  0d38		       ea		      nop
     19  0d39					      REPEND
    119  0d39
    120  0d39		       88		      dey		; 2
    121  0d3a		       30 c4		      bmi	.endline	; 2 (3)
    122  0d3c
    123  0d3c							;@57
    124  0d3c				   .drawLine
    125  0d3c
      0  0d3c					      SLEEP	11
      1  0d3c				   .CYCLES    SET	11
      2  0d3c
      3  0d3c				  -	      IF	.CYCLES < 2
      4  0d3c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0d3c				  -	      ERR
      6  0d3c					      ENDIF
      7  0d3c
      8  0d3c					      IF	.CYCLES & 1
      9  0d3c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0d3c		       04 00		      nop	0
     11  0d3e				  -	      ELSE
     12  0d3e				  -	      bit	VSYNC
     13  0d3e					      ENDIF
     14  0d3e				   .CYCLES    SET	.CYCLES - 3
     15  0d3e					      ENDIF
     16  0d3e
     17  0d3e					      REPEAT	.CYCLES / 2
     18  0d3e		       ea		      nop
     17  0d3e					      REPEND
     18  0d3f		       ea		      nop
     17  0d3f					      REPEND
     18  0d40		       ea		      nop
     17  0d40					      REPEND
     18  0d41		       ea		      nop
     19  0d42					      REPEND
    127  0d42
    128  0d42				   .dl2
    129  0d42		       b9 98 f8    SMSPRITE0_0 lda	SpriteBuffer,y	; 4
    130  0d45		       85 5b		      sta	GRP0	; 3
    131  0d47		       b9 98 f8    SMSPRITE0_1 lda	SpriteBuffer2,y	; 4
    132  0d4a		       85 5c		      sta	GRP1	; 3
    133  0d4c
    134  0d4c							;@7
    135  0d4c
    136  0d4c		       a9 48		      lda	#COLOUR_LINE_2	;#$4A			  ; 2
    137  0d4e		       85 48		      sta	COLUPF	; 3 @12
    138  0d50
    139  0d50		       b9 00 f8 	      lda	ChessBitmap0,y	; 4
    140  0d53		       85 4d		      sta	PF0	; 3
    141  0d55		       b9 18 f8 	      lda	ChessBitmap1,y	; 4
    142  0d58		       85 4e		      sta	PF1	; 3
    143  0d5a		       b9 30 f8 	      lda	ChessBitmap2,y	; 4
    144  0d5d		       85 4f		      sta	PF2	; 3 @33
    145  0d5f
      0  0d5f					      SLEEP	3	; 3 @36
      1  0d5f				   .CYCLES    SET	3
      2  0d5f
      3  0d5f				  -	      IF	.CYCLES < 2
      4  0d5f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0d5f				  -	      ERR
      6  0d5f					      ENDIF
      7  0d5f
      8  0d5f					      IF	.CYCLES & 1
      9  0d5f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0d5f		       04 00		      nop	0
     11  0d61				  -	      ELSE
     12  0d61				  -	      bit	VSYNC
     13  0d61					      ENDIF
     14  0d61				   .CYCLES    SET	.CYCLES - 3
     15  0d61					      ENDIF
     16  0d61
     17  0d61				  -	      REPEAT	.CYCLES / 2
     18  0d61				  -	      nop
     19  0d61					      REPEND
    147  0d61
    148  0d61		       b9 48 f8 	      lda	ChessBitmap3,y	; 4
    149  0d64		       85 4d		      sta	PF0	; 3
    150  0d66		       b9 60 f8 	      lda	ChessBitmap4,y	; 4
    151  0d69		       85 4e		      sta	PF1	; 3
    152  0d6b		       b9 78 f8 	      lda	ChessBitmap5,y	; 4
    153  0d6e		       85 4f		      sta	PF2	; 3 @57
    154  0d70
      0  0d70					      SLEEP	5
      1  0d70				   .CYCLES    SET	5
      2  0d70
      3  0d70				  -	      IF	.CYCLES < 2
      4  0d70				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0d70				  -	      ERR
      6  0d70					      ENDIF
      7  0d70
      8  0d70					      IF	.CYCLES & 1
      9  0d70					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0d70		       04 00		      nop	0
     11  0d72				  -	      ELSE
     12  0d72				  -	      bit	VSYNC
     13  0d72					      ENDIF
     14  0d72				   .CYCLES    SET	.CYCLES - 3
     15  0d72					      ENDIF
     16  0d72
     17  0d72					      REPEAT	.CYCLES / 2
     18  0d72		       ea		      nop
     19  0d73					      REPEND
    156  0d73
    157  0d73		       b9 a0 f8    SMSPRITE8_0 lda	SpriteBuffer+8,y	; 4
    158  0d76		       85 5b		      sta	GRP0	; 3
    159  0d78		       b9 a0 f8    SMSPRITE8_1 lda	SpriteBuffer2+8,y	; 4
    160  0d7b		       85 5c		      sta	GRP1	; 3
    161  0d7d
    162  0d7d							;@0
    163  0d7d		       a9 2e		      lda	#COLOUR_LINE_3	;#$28			  ; 2
    164  0d7f		       85 48		      sta	COLUPF	; 3 @5
    165  0d81
    166  0d81		       b9 08 f8 	      lda	ChessBitmap0+8,y	; 4
    167  0d84		       85 4d		      sta	PF0	; 3
    168  0d86		       b9 20 f8 	      lda	ChessBitmap1+8,y	; 4
    169  0d89		       85 4e		      sta	PF1	; 3
    170  0d8b		       b9 38 f8 	      lda	ChessBitmap2+8,y	; 4
    171  0d8e		       85 4f		      sta	PF2	; 3 @26
    172  0d90
      0  0d90					      SLEEP	8	; 6 @34
      1  0d90				   .CYCLES    SET	8
      2  0d90
      3  0d90				  -	      IF	.CYCLES < 2
      4  0d90				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0d90				  -	      ERR
      6  0d90					      ENDIF
      7  0d90
      8  0d90				  -	      IF	.CYCLES & 1
      9  0d90				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0d90				  -	      nop	0
     11  0d90				  -	      ELSE
     12  0d90				  -	      bit	VSYNC
     13  0d90				  -	      ENDIF
     14  0d90				  -.CYCLES    SET	.CYCLES - 3
     15  0d90					      ENDIF
     16  0d90
     17  0d90					      REPEAT	.CYCLES / 2
     18  0d90		       ea		      nop
     17  0d90					      REPEND
     18  0d91		       ea		      nop
     17  0d91					      REPEND
     18  0d92		       ea		      nop
     17  0d92					      REPEND
     18  0d93		       ea		      nop
     19  0d94					      REPEND
    174  0d94
    175  0d94		       b9 50 f8 	      lda	ChessBitmap3+8,y	; 4
    176  0d97		       85 4d		      sta	PF0	; 3
    177  0d99		       b9 68 f8 	      lda	ChessBitmap4+8,y	; 4
    178  0d9c		       85 4e		      sta	PF1	; 3
    179  0d9e		       b9 80 f8 	      lda	ChessBitmap5+8,y	; 4
    180  0da1		       85 4f		      sta	PF2	; 3 @55
    181  0da3
    182  0da3		       4c 07 f9 	      jmp	.l3	; 3 @58
    183  0da6
    184  0da6
    185  0da6
    186  0da6							;---------------------------------------------------------------------------------------------------
    187  0da6
      0  0da6					      CHECK_RAM_BANK_SIZE	"ROM_SHADOW_SCREEN"
      1  0da6		       01 a6	   .TEMP      =	* - _BANK_START
 ROM_SHADOW_SCREEN (512 byte) SIZE =  $1a6 , FREE= $5a
      2  0da6					      ECHO	"ROM_SHADOW_SCREEN", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3  0da6				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  0da6				  -	      ECHO	"BANK OVERFLOW @ ", "ROM_SHADOW_SCREEN", " size=", * - ORIGIN
      5  0da6				  -	      ERR
      6  0da6					      ENDIF
    189  0da6
    190  0da6							;---------------------------------------------------------------------------------------------------
    191  0da6							;EOF
------- FILE ./chess.asm
------- FILE ROM_SCREEN@3.asm LEVEL 2 PASS 4
      0  0da6					      include	"ROM_SCREEN@3.asm"
      1  0da6
      0  0da6					      SLOT	3
      1  0da6				  -	      IF	(3 < 0) || (3 > 3)
      2  0da6				  -	      ECHO	"Illegal bank address/segment location", 3
      3  0da6				  -	      ERR
      4  0da6					      ENDIF
      5  0da6				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  0da6				   _BANK_SLOT SET	3 * 64
      0  0da6					      ROMBANK	ROM_SCREEN
      1  105c ????				      SEG	ROM_SCREEN
      2  1000					      ORG	_ORIGIN
      3  1000					      RORG	_BANK_ADDRESS_ORIGIN
      4  1000				   _BANK_START SET	*
      5  1000				   ROM_SCREEN_START SET	*
      6  1000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1000				   ROM_SCREEN SET	_BANK_SLOT + _CURRENT_BANK
      8  1000				   _ORIGIN    SET	_ORIGIN + 1024
      4  1000
      5  1000							;---------------------------------------------------------------------------------------------------
      6  1000
      0  1000					      DEF	ClearRowBitmap
      1  1000				   SLOT_ClearRowBitmap SET	_BANK_SLOT
      2  1000				   BANK_ClearRowBitmap SET	SLOT_ClearRowBitmap + _CURRENT_BANK
      3  1000				   ClearRowBitmap
      4  1000				   TEMPORARY_VAR SET	Overlay
      5  1000				   TEMPORARY_OFFSET SET	0
      6  1000				   VAR_BOUNDARY_ClearRowBitmap SET	TEMPORARY_OFFSET
      7  1000				   FUNCTION_NAME SET	ClearRowBitmap
      8  1000					      SUBROUTINE
      9  1000
      0  1000					      REFER	CallClear	;✅
      1  1000				  -	      IF	VAREND_CallClear > TEMPORARY_VAR
      2  1000				  -TEMPORARY_VAR SET	VAREND_CallClear
      3  1000					      ENDIF
      0  1000					      VEND	ClearRowBitmap
      1  1000				  -	      IFNCONST	ClearRowBitmap
      2  1000				  -	      ECHO	"Incorrect VEND label", ClearRowBitmap
      3  1000				  -	      ERR
      4  1000					      ENDIF
      5  1000		       00 a7	   VAREND_ClearRowBitmap =	TEMPORARY_VAR
     12  1000
     13  1000							; No transient variable dependencies/calls
     14  1000
     15  1000		       a9 00		      lda	#0
     16  1002		       a0 90		      ldy	#ROW_BITMAP_SIZE
      0  1004				   .clearRow  sta@RAM	ChessBitmap-1,y
      1  1004		       99 ff f9 	      sta	[RAM]+ChessBitmap-1,y
     18  1007		       88		      dey
     19  1008		       d0 fa		      bne	.clearRow
     20  100a		       60		      rts
     21  100b
     22  100b
     23  100b							;---------------------------------------------------------------------------------------------------
     24  100b
     25  100b					      IF	1
      0  100b					      DEF	WriteBlank
      1  100b				   SLOT_WriteBlank SET	_BANK_SLOT
      2  100b				   BANK_WriteBlank SET	SLOT_WriteBlank + _CURRENT_BANK
      3  100b				   WriteBlank
      4  100b				   TEMPORARY_VAR SET	Overlay
      5  100b				   TEMPORARY_OFFSET SET	0
      6  100b				   VAR_BOUNDARY_WriteBlank SET	TEMPORARY_OFFSET
      7  100b				   FUNCTION_NAME SET	WriteBlank
     27  100b					      SUBROUTINE
     28  100b
      0  100b					      REFER	StartupBankReset	;✅
      1  100b				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  100b				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  100b					      ENDIF
      0  100b					      VEND	WriteBlank
      1  100b				  -	      IFNCONST	WriteBlank
      2  100b				  -	      ECHO	"Incorrect VEND label", WriteBlank
      3  100b				  -	      ERR
      4  100b					      ENDIF
      5  100b		       00 a7	   VAREND_WriteBlank =	TEMPORARY_VAR
     31  100b
     32  100b		       a9 90		      lda	#<BlankSprite
      0  100d					      sta@RAM	SMSPRITE0_0+1
      1  100d		       8d 43 fb 	      sta	[RAM]+SMSPRITE0_0+1
      0  1010					      sta@RAM	SMSPRITE8_0+1
      1  1010		       8d 74 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  1013					      sta@RAM	SMSPRITE16_0+1
      1  1013		       8d 08 fb 	      sta	[RAM]+SMSPRITE16_0+1
      0  1016					      sta@RAM	SMSPRITE0_1+1
      1  1016		       8d 48 fb 	      sta	[RAM]+SMSPRITE0_1+1
      0  1019					      sta@RAM	SMSPRITE8_1+1
      1  1019		       8d 79 fb 	      sta	[RAM]+SMSPRITE8_1+1
      0  101c					      sta@RAM	SMSPRITE16_1+1
      1  101c		       8d 0d fb 	      sta	[RAM]+SMSPRITE16_1+1
     39  101f
     40  101f		       a9 f8		      lda	#>BlankSprite
      0  1021					      sta@RAM	SMSPRITE0_0+2
      1  1021		       8d 44 fb 	      sta	[RAM]+SMSPRITE0_0+2
      0  1024					      sta@RAM	SMSPRITE8_0+2
      1  1024		       8d 75 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  1027					      sta@RAM	SMSPRITE16_0+2
      1  1027		       8d 09 fb 	      sta	[RAM]+SMSPRITE16_0+2
      0  102a					      sta@RAM	SMSPRITE0_1+2
      1  102a		       8d 49 fb 	      sta	[RAM]+SMSPRITE0_1+2
      0  102d					      sta@RAM	SMSPRITE8_1+2
      1  102d		       8d 7a fb 	      sta	[RAM]+SMSPRITE8_1+2
      0  1030					      sta@RAM	SMSPRITE16_1+2
      1  1030		       8d 0e fb 	      sta	[RAM]+SMSPRITE16_1+2
     47  1033
     48  1033		       60		      rts
     49  1034					      ENDIF
     50  1034
     51  1034							;---------------------------------------------------------------------------------------------------
     52  1034
     53  1034					      IF	1
      0  1034					      DEF	WriteCursor
      1  1034				   SLOT_WriteCursor SET	_BANK_SLOT
      2  1034				   BANK_WriteCursor SET	SLOT_WriteCursor + _CURRENT_BANK
      3  1034				   WriteCursor
      4  1034				   TEMPORARY_VAR SET	Overlay
      5  1034				   TEMPORARY_OFFSET SET	0
      6  1034				   VAR_BOUNDARY_WriteCursor SET	TEMPORARY_OFFSET
      7  1034				   FUNCTION_NAME SET	WriteCursor
     55  1034					      SUBROUTINE
     56  1034
      0  1034					      REFER	StartupBankReset	;✅
      1  1034				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  1034				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  1034					      ENDIF
      0  1034					      VEND	WriteCursor
      1  1034				  -	      IFNCONST	WriteCursor
      2  1034				  -	      ECHO	"Incorrect VEND label", WriteCursor
      3  1034				  -	      ERR
      4  1034					      ENDIF
      5  1034		       00 a7	   VAREND_WriteCursor =	TEMPORARY_VAR
     59  1034
     60  1034		       38		      sec
     61  1035		       a5 88		      lda	cursorX12
     62  1037		       30 22		      bmi	.exit
     63  1039		       a2 0a		      ldx	#10
     64  103b		       e9 0a	   .sub10     sbc	#10
     65  103d		       ca		      dex
     66  103e		       b0 fb		      bcs	.sub10
     67  1040
     68  1040		       8a		      txa
     69  1041		       69 80		      adc	#SLOT_DrawRow	;cc implied
     70  1043		       85 3e		      sta	SET_BANK_RAM
     71  1045
     72  1045		       a9 98		      lda	#<SpriteBuffer
      0  1047					      sta@RAM	SMSPRITE0_0+1
      1  1047		       8d 43 fb 	      sta	[RAM]+SMSPRITE0_0+1
      0  104a					      sta@RAM	SMSPRITE8_0+1
      1  104a		       8d 74 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  104d					      sta@RAM	SMSPRITE16_0+1
      1  104d		       8d 08 fb 	      sta	[RAM]+SMSPRITE16_0+1
     76  1050		       a9 f8		      lda	#>SpriteBuffer
      0  1052					      sta@RAM	SMSPRITE0_0+2
      1  1052		       8d 44 fb 	      sta	[RAM]+SMSPRITE0_0+2
      0  1055					      sta@RAM	SMSPRITE8_0+2
      1  1055		       8d 75 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  1058					      sta@RAM	SMSPRITE16_0+2
      1  1058		       8d 09 fb 	      sta	[RAM]+SMSPRITE16_0+2
     80  105b
     81  105b		       60	   .exit      rts
     82  105c					      ENDIF
     83  105c
     84  105c
     85  105c							;---------------------------------------------------------------------------------------------------
     86  105c
     87  105c				  -	      IF	0
     88  105c				  -	      DEF	SaveBitmap
     89  105c				  -	      SUBROUTINE
     90  105c				  -
     91  105c				  -	      REFER	SAFE_BackupBitmaps	;✅
     92  105c				  -	      VEND	SaveBitmap
     93  105c				  -
     94  105c				  -	      ldy	#71
     95  105c				  -.fromTo    lda	ChessBitmap,y
     96  105c				  -	      sta@RAM	BackupBitmap,y
     97  105c				  -	      lda	ChessBitmap+72,y
     98  105c				  -	      sta@RAM	BackupBitmap+72,y
     99  105c				  -	      dey
    100  105c				  -	      bpl	.fromTo
    101  105c				  -	      rts
    102  105c					      ENDIF
    103  105c
    104  105c							;---------------------------------------------------------------------------------------------------
    105  105c
    106  105c				  -	      IF	0
    107  105c				  -
    108  105c				  -	      DEF	RestoreBitmap
    109  105c				  -	      SUBROUTINE
    110  105c				  -
    111  105c				  -	      VEND	RestoreBitmap
    112  105c				  -
    113  105c				  -	      ldy	#71
    114  105c				  -.fromTo    lda	BackupBitmap,y
    115  105c				  -	      sta@RAM	ChessBitmap,y
    116  105c				  -	      lda	BackupBitmap+72,y
    117  105c				  -	      sta@RAM	ChessBitmap+72,y
    118  105c				  -	      dey
    119  105c				  -	      bpl	.fromTo
    120  105c				  -	      rts
    121  105c					      ENDIF
    122  105c
    123  105c							;---------------------------------------------------------------------------------------------------
    124  105c
    125  105c				  -	      IF	0
    126  105c				  -
    127  105c				  -	      DEF	CopyTextToRowBitmap
    128  105c				  -	      SUBROUTINE
    129  105c				  -
    130  105c				  -	      VEND	CopyTextToRowBitmap
    131  105c				  -
    132  105c				  -			; An OR-draw, used for placing matricies/text onscreen
    133  105c				  -			; Similar to the EOR - first copy data into __pieceShapeBuffer, then call this function
    134  105c				  -			; The draw can be bracketed by "SaveBitmap" and "RestoreBitmap" to leave screen
    135  105c				  -			; in original state once text disappears
    136  105c				  -
    137  105c				  -	      ldy	#71
    138  105c				  -	      bcs	.rightSide
    139  105c				  -
    140  105c				  -.copy      lda	__pieceShapeBuffer,y
    141  105c				  -	      ora	ChessBitmap,y
    142  105c				  -	      sta@RAM	ChessBitmap,y
    143  105c				  -	      dey
    144  105c				  -	      bpl	.copy
    145  105c				  -
    146  105c				  -	      rts
    147  105c				  -
    148  105c				  -.rightSide
    149  105c				  -
    150  105c				  -	      SUBROUTINE
    151  105c				  -
    152  105c				  -.copy      lda	__pieceShapeBuffer,y
    153  105c				  -	      ora	ChessBitmap+72,y
    154  105c				  -	      sta@RAM	ChessBitmap+72,y
    155  105c				  -	      dey
    156  105c				  -	      bpl	.copy
    157  105c				  -
    158  105c				  -	      rts
    159  105c				  -
    160  105c					      ENDIF
    161  105c
    162  105c							;---------------------------------------------------------------------------------------------------
    163  105c
      0  105c					      CHECK_RAM_BANK_SIZE	"ROM_SCREEN@3"
      1  105c		       00 5c	   .TEMP      =	* - _BANK_START
 ROM_SCREEN@3 (512 byte) SIZE =  $5c , FREE= $1a4
      2  105c					      ECHO	"ROM_SCREEN@3", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3  105c				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  105c				  -	      ECHO	"BANK OVERFLOW @ ", "ROM_SCREEN@3", " size=", * - ORIGIN
      5  105c				  -	      ERR
      6  105c					      ENDIF
    165  105c
    166  105c							;---------------------------------------------------------------------------------------------------
    167  105c							;EOF
------- FILE ./chess.asm
------- FILE SHADOW_PLY.asm LEVEL 2 PASS 4
      0  105c					      include	"SHADOW_PLY.asm"
      1  105c							; Chess
      2  105c							; Copyright (c) 2019-2020 Andrew Davie
      3  105c							; andrew@taswegian.com
      4  105c
      5  105c
      6  105c							;---------------------------------------------------------------------------------------------------
      7  105c							; Define the RAM banks
      8  105c							; A "PLY" bank represents all the data required on any single ply of the search tree.
      9  105c							; The banks are organised sequentially, PLY_BANKS of them starting at RAMBANK_PLY
     10  105c							; The startup code copies the ROM shadow into each of these PLY banks, and from then on
     11  105c							; they act as independant switchable banks usable for data on each ply during the search.
     12  105c							; A ply will hold the move list for that position
     13  105c
     14  105c
      0  105c					      SLOT	2
      1  105c				  -	      IF	(2 < 0) || (2 > 3)
      2  105c				  -	      ECHO	"Illegal bank address/segment location", 2
      3  105c				  -	      ERR
      4  105c					      ENDIF
      5  105c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  105c				   _BANK_SLOT SET	2 * 64
      0  105c					      NEWRAMBANK	PLY	; RAM bank for holding the following ROM shadow
      1  105c
      2  105c
      3  105c
      4 U21dc ????				      SEG.U	PLY
      5 U2000					      ORG	ORIGIN_RAM
      6 U2000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2000				   _BANK_START SET	*
      8 U2000				   RAMBANK_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2000				   _CURRENT_RAMBANK SET	RAMBANK_PLY
     10 U2000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U2000
     18 U2000							;---------------------------------------------------------------------------------------------------
     19 U2000
     20 U2000		       00 64	   MAX_MOVES  =	100	; big is good
     21 U2000
      0 U2000					      VARIABLE	MoveFrom, MAX_MOVES
      0 U2000					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2000					      LIST	ON
      2 U2000		       00 00 00 00*MoveFrom   ds	MAX_MOVES
      0 U2064					      VARIABLE	MoveTo, MAX_MOVES
      0 U2064					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2064					      LIST	ON
      2 U2064		       00 00 00 00*MoveTo     ds	MAX_MOVES
      0 U20c8					      VARIABLE	MovePiece, MAX_MOVES
      0 U20c8					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2100					      LIST	ON
      2 U2100		       00 00 00 00*MovePiece  ds	MAX_MOVES
      0 U2164					      VARIABLE	MoveCapture, MAX_MOVES
      0 U2164					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2164					      LIST	ON
      2 U2164		       00 00 00 00*MoveCapture ds	MAX_MOVES
     26 U21c8
     27 U21c8
     28 U21c8							;---------------------------------------------------------------------------------------------------
     29 U21c8
     30 U21c8							; The X12 square at which a pawn CAN be taken en-passant. Normally 0.
     31 U21c8							; This is set/cleared whenever a move is made. The flag is indicated in the move description.
     32 U21c8
      0 U21c8					      VARIABLE	savedEvaluation, 2	; THIS node's evaluation - used for reverting moves!
      0 U21c8					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21c8					      LIST	ON
      2 U21c8		       00 00	   savedEvaluation ds	2
      0 U21ca					      VARIABLE	enPassantSquare, 1
      0 U21ca					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21ca					      LIST	ON
      2 U21ca		       00	   enPassantSquare ds	1
      0 U21cb					      VARIABLE	capturedPiece, 1
      0 U21cb					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cb					      LIST	ON
      2 U21cb		       00	   capturedPiece ds	1
     36 U21cc							;VARIABLE originalPiece, 1
      0 U21cc					      VARIABLE	secondaryPiece, 1	; original piece on secondary (castle, enpassant)
      0 U21cc					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cc					      LIST	ON
      2 U21cc		       00	   secondaryPiece ds	1
      0 U21cd					      VARIABLE	secondarySquare, 1	; original square of secondary piece
      0 U21cd					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cd					      LIST	ON
      2 U21cd		       00	   secondarySquare ds	1
      0 U21ce					      VARIABLE	secondaryBlank, 1	; square to blank on secondary
      0 U21ce					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21ce					      LIST	ON
      2 U21ce		       00	   secondaryBlank ds	1
      0 U21cf					      VARIABLE	moveIndex, 1	; points to first available 'slot' for move storage
      0 U21cf					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cf					      LIST	ON
      2 U21cf		       00	   moveIndex  ds	1
      0 U21d0					      VARIABLE	movePtr, 1
      0 U21d0					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d0					      LIST	ON
      2 U21d0		       00	   movePtr    ds	1
      0 U21d1					      VARIABLE	bestMove, 1
      0 U21d1					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d1					      LIST	ON
      2 U21d1		       00	   bestMove   ds	1
      0 U21d2					      VARIABLE	alpha, 2
      0 U21d2					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21d2					      LIST	ON
      2 U21d2		       00 00	   alpha      ds	2
      0 U21d4					      VARIABLE	beta, 2
      0 U21d4					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21d4					      LIST	ON
      2 U21d4		       00 00	   beta       ds	2
      0 U21d6					      VARIABLE	value, 2
      0 U21d6					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21d6					      LIST	ON
      2 U21d6		       00 00	   value      ds	2
      0 U21d8					      VARIABLE	depthLeft, 1
      0 U21d8					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d8					      LIST	ON
      2 U21d8		       00	   depthLeft  ds	1
      0 U21d9					      VARIABLE	restorePiece, 1
      0 U21d9					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d9					      LIST	ON
      2 U21d9		       00	   restorePiece ds	1
      0 U21da					      VARIABLE	virtualKingSquare, 2	; traversing squares for castle/check
      0 U21da					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21da					      LIST	ON
      2 U21da		       00 00	   virtualKingSquare ds	2
     49 U21dc
     50 U21dc
      0 U21dc					      CHECK_RAM_BANK_SIZE	"SHADOW_PLY"
      1 U21dc		       01 dc	   .TEMP      =	* - _BANK_START
 SHADOW_PLY (512 byte) SIZE =  $1dc , FREE= $24
      2 U21dc					      ECHO	"SHADOW_PLY", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3 U21dc				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U21dc				  -	      ECHO	"BANK OVERFLOW @ ", "SHADOW_PLY", " size=", * - ORIGIN
      5 U21dc				  -	      ERR
      6 U21dc					      ENDIF
     52 U21dc
     53 U21dc					      REPEAT	PLY_BANKS-1
      0 U21dc					      NEWRAMBANK	.DUMMY_PLY
      1 U21dc
      2 U21dc
      3 U21dc
      4 U4000 ????				      SEG.U	.DUMMY_PLY
      5 U2400					      ORG	ORIGIN_RAM
      6 U2400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2400				   _BANK_START SET	*
      8 U2400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U2400					      REPEND
      0 U2400					      NEWRAMBANK	.DUMMY_PLY
      1 U2400
      2 U2400
      3 U2400
      4 U2400					      SEG.U	.DUMMY_PLY
      5 U2800					      ORG	ORIGIN_RAM
      6 U2800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2800				   _BANK_START SET	*
      8 U2800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U2800					      REPEND
      0 U2800					      NEWRAMBANK	.DUMMY_PLY
      1 U2800
      2 U2800
      3 U2800
      4 U2800					      SEG.U	.DUMMY_PLY
      5 U2c00					      ORG	ORIGIN_RAM
      6 U2c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2c00				   _BANK_START SET	*
      8 U2c00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U2c00					      REPEND
      0 U2c00					      NEWRAMBANK	.DUMMY_PLY
      1 U2c00
      2 U2c00
      3 U2c00
      4 U2c00					      SEG.U	.DUMMY_PLY
      5 U3000					      ORG	ORIGIN_RAM
      6 U3000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3000				   _BANK_START SET	*
      8 U3000				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U3000					      REPEND
      0 U3000					      NEWRAMBANK	.DUMMY_PLY
      1 U3000
      2 U3000
      3 U3000
      4 U3000					      SEG.U	.DUMMY_PLY
      5 U3400					      ORG	ORIGIN_RAM
      6 U3400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3400				   _BANK_START SET	*
      8 U3400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U3400					      REPEND
      0 U3400					      NEWRAMBANK	.DUMMY_PLY
      1 U3400
      2 U3400
      3 U3400
      4 U3400					      SEG.U	.DUMMY_PLY
      5 U3800					      ORG	ORIGIN_RAM
      6 U3800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3800				   _BANK_START SET	*
      8 U3800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U3800					      REPEND
      0 U3800					      NEWRAMBANK	.DUMMY_PLY
      1 U3800
      2 U3800
      3 U3800
      4 U3800					      SEG.U	.DUMMY_PLY
      5 U3c00					      ORG	ORIGIN_RAM
      6 U3c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3c00				   _BANK_START SET	*
      8 U3c00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U3c00					      REPEND
      0 U3c00					      NEWRAMBANK	.DUMMY_PLY
      1 U3c00
      2 U3c00
      3 U3c00
      4 U3c00					      SEG.U	.DUMMY_PLY
      5 U4000					      ORG	ORIGIN_RAM
      6 U4000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U4000				   _BANK_START SET	*
      8 U4000				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U4000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U4000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     55 U4000					      REPEND
     56 U4000
     57 U4000
     58 U4000							;---------------------------------------------------------------------------------------------------
     59 U4000							; EOF
------- FILE ./chess.asm
------- FILE SHADOW_BOARD.asm LEVEL 2 PASS 4
      0 U4000					      include	"SHADOW_BOARD.asm"
      1 U4000							; Copyright (C)2020 Andrew Davie
      2 U4000
      3 U4000
      4 U4000							;---------------------------------------------------------------------------------------------------
      0 U4000					      SLOT	3
      1 U4000				  -	      IF	(3 < 0) || (3 > 3)
      2 U4000				  -	      ECHO	"Illegal bank address/segment location", 3
      3 U4000				  -	      ERR
      4 U4000					      ENDIF
      5 U4000				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6 U4000				   _BANK_SLOT SET	3 * 64
      0 U4000					      NEWRAMBANK	BOARD	; RAM bank for holding the following ROM shadow
      1 U4000
      2 U4000
      3 U4000
      4 U4400 ????				      SEG.U	BOARD
      5 U4400					      ORG	ORIGIN_RAM
      6 U4400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U4400				   _BANK_START SET	*
      8 U4400				   RAMBANK_BOARD SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U4400				   _CURRENT_RAMBANK SET	RAMBANK_BOARD
     10 U4400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      7 U4400
      8 U4400		       fc 15	   ValidSquare =	ShadowValidSquare + $400
      9 U4400		       fc 79	   Board      =	ShadowBoard + $400
     10 U4400
      0 U4400					      SLOT	2
      1 U4400				  -	      IF	(2 < 0) || (2 > 3)
      2 U4400				  -	      ECHO	"Illegal bank address/segment location", 2
      3 U4400				  -	      ERR
      4 U4400					      ENDIF
      5 U4400				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6 U4400				   _BANK_SLOT SET	2 * 64
      0 U4400					      ROMBANK	SHADOW_BOARD	; copy the following bank to RAMBANK_BOARD
      1  14dd ????				      SEG	SHADOW_BOARD
      2  1400					      ORG	_ORIGIN
      3  1400					      RORG	_BANK_ADDRESS_ORIGIN
      4  1400				   _BANK_START SET	*
      5  1400				   SHADOW_BOARD_START SET	*
      6  1400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1400				   SHADOW_BOARD SET	_BANK_SLOT + _CURRENT_BANK
      8  1400				   _ORIGIN    SET	_ORIGIN + 1024
     13  1400
     14  1400							; Board is a 10 x 12 object which simplifies the generation of moves
     15  1400							; The squares marked '░░░' are illegal. The ("X12") index of each square is the left
     16  1400							; number + the bottom number. Bottom left legal square (AS VISIBLE ON SCREEN) is #22
     17  1400
     18  1400							;     X12 numbering
     19  1400							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     20  1400							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     21  1400							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     22  1400							; 90 ┃░░░┊░░░┊ 92┊ 93┊ 94┊ 95┊ 96┊ 97┊ 98┊ 99┃ 8 BLACK
     23  1400							; 80 ┃░░░┊░░░┊ 82┊ 83┊ 84┊ 85┊ 86┊ 87┊ 88┊ 89┃ 7 BLACK
     24  1400							; 70 ┃░░░┊░░░┊ 72┊ 73┊ 74┊ 75┊ 76┊ 77┊ 78┊ 79┃ 6
     25  1400							; 60 ┃░░░┊░░░┊ 62┊ 63┊ 64┊ 65┊ 66┊ 67┊ 68┊ 69┃ 5
     26  1400							; 50 ┃░░░┊░░░┊ 52┊ 53┊ 54┊ 55┊ 56┊ 57┊ 58┊ 59┃ 4
     27  1400							; 40 ┃░░░┊░░░┊ 42┊ 43┊ 44┊ 45┊ 46┊ 47┊ 48┊ 49┃ 3
     28  1400							; 30 ┃░░░┊░░░┊ 32┊ 33┊ 34┊ 35┊ 36┊ 37┊ 38┊ 39┃ 2 WHITE
     29  1400							; 20 ┃░░░┊░░░┊ 22┊ 23┊ 24┊ 25┊ 26┊ 27┊ 28┊ 29┃ 1 WHITE
     30  1400							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     31  1400							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     32  1400							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     33  1400							;	0   1	2   3	4   5	6   7	8   9
     34  1400							;		A   B	C   D	E   F	G   H
     35  1400
     36  1400							;     HEX X12
     37  1400							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     38  1400							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     39  1400							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     40  1400							; 90 ┃░░░┊░░░┊$5C┊$5D┊$5E┊$5F┊$60┊$61┊$62┊$63┃ 8
     41  1400							; 80 ┃░░░┊░░░┊$52┊$53┊$54┊$55┊$56┊$57┊$58┊$59┃ 7
     42  1400							; 70 ┃░░░┊░░░┊$48┊$49┊$4A┊$4B┊$4C┊$4D┊$4E┊$4F┃ 6
     43  1400							; 60 ┃░░░┊░░░┊$3E┊$3F┊$40┊$41┊$42┊$43┊$44┊$45┃ 5
     44  1400							; 50 ┃░░░┊░░░┊$34┊$35┊$36┊$37┊$38┊$39┊$3A┊$3B┃ 4
     45  1400							; 40 ┃░░░┊░░░┊$2A┊$2B┊$2C┊$2D┊$2E┊$2F┊$30┊$31┃ 3
     46  1400							; 30 ┃░░░┊░░░┊$20┊$21┊$22┊$23┊$24┊$25┊$26|$27┃ 2
     47  1400							; 20 ┃░░░┊░░░┊$16┊$17┊$18┊$19┊$1A┊$1B┊$1C┊$1D┃ 1
     48  1400							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     49  1400							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     50  1400							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     51  1400							;	0   1	2   3	4   5	6   7	8   9
     52  1400							;		A   B	C   D	E   F	G   H
     53  1400
     54  1400
     55  1400							; We put a short buffer before 'ValidSquare' when it is at the start of the bank, so that
     56  1400							; the move indexing (ie., "ValidSquare+{1},x" won't drop off the beginning of the bank
     57  1400							; and sause "segfaults". 21 is the max offset (a knight move). These spare bytes can
     58  1400							; be re-used for something else - we just need to guarantee there are 21 of them there
     59  1400
      0  1400					      ALLOCATE	Valid, 120 + 80 + 21
      0  1400					      OPTIONAL_PAGEBREAK	"Table", 120 + 80 + 21
     12  1400					      LIST	ON
      0  1400					      DEF	Valid
      1  1400				   SLOT_Valid SET	_BANK_SLOT
      2  1400				   BANK_Valid SET	SLOT_Valid + _CURRENT_BANK
      3  1400				   Valid
      4  1400				   TEMPORARY_VAR SET	Overlay
      5  1400				   TEMPORARY_OFFSET SET	0
      6  1400				   VAR_BOUNDARY_Valid SET	TEMPORARY_OFFSET
      7  1400				   FUNCTION_NAME SET	Valid
     61  1400		       00 00 00 00*	      ds	21	; so indexing of "ValidSquare-21,x" won't fail
     62  1415							; Note, we will never index INTO the above bytes - x will always be >= 21
     63  1415							; We just need to make sure that the actual indexing will not have an address before
     64  1415							; the index of outside the page.
     65  1415
      0  1415					      DEF	ShadowValidSquare
      1  1415				   SLOT_ShadowValidSquare SET	_BANK_SLOT
      2  1415				   BANK_ShadowValidSquare SET	SLOT_ShadowValidSquare + _CURRENT_BANK
      3  1415				   ShadowValidSquare
      4  1415				   TEMPORARY_VAR SET	Overlay
      5  1415				   TEMPORARY_OFFSET SET	0
      6  1415				   VAR_BOUNDARY_ShadowValidSquare SET	TEMPORARY_OFFSET
      7  1415				   FUNCTION_NAME SET	ShadowValidSquare
     67  1415
     68  1415
     69  1415							; Use this table to
     70  1415							;   a) Determine if a square is valid (-1 = NO)
     71  1415							;   b) Move pieces without addition.  e.g., "lda ValidSquareTable+10,x" will let you know
     72  1415							;	if a white pawn on square "x" can move "up" the board.
     73  1415
     74  1415		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     75  141f		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     76  1429		       ff ff 16 17*	      .byte.b	-1, -1, 22, 23, 24, 25, 26, 27, 28, 29
     77  1433		       ff ff 20 21*	      .byte.b	-1, -1, 32, 33, 34, 35, 36, 37, 38, 39
     78  143d		       ff ff 2a 2b*	      .byte.b	-1, -1, 42, 43, 44, 45, 46, 47, 48, 49
     79  1447		       ff ff 34 35*	      .byte.b	-1, -1, 52, 53, 54, 55, 56, 57, 58, 59
     80  1451		       ff ff 3e 3f*	      .byte.b	-1, -1, 62, 63, 64, 65, 66, 67, 68, 69
     81  145b		       ff ff 48 49*	      .byte.b	-1, -1, 72, 73, 74, 75, 76, 77, 78, 79
     82  1465		       ff ff 52 53*	      .byte.b	-1, -1, 82, 83, 84, 85, 86, 87, 88, 89
     83  146f		       ff ff 5c 5d*	      .byte.b	-1, -1, 92, 93, 94, 95, 96, 97, 98, 99	; CONTINUES...
     84  1479
      0  1479					      DEF	ShadowBoard
      1  1479				   SLOT_ShadowBoard SET	_BANK_SLOT
      2  1479				   BANK_ShadowBoard SET	SLOT_ShadowBoard + _CURRENT_BANK
      3  1479				   ShadowBoard
      4  1479				   TEMPORARY_VAR SET	Overlay
      5  1479				   TEMPORARY_OFFSET SET	0
      6  1479				   VAR_BOUNDARY_ShadowBoard SET	TEMPORARY_OFFSET
      7  1479				   FUNCTION_NAME SET	ShadowBoard
     86  1479
     87  1479							; A 10X10... we should never write using invalid square
     88  1479							; ON COPY TO RAM BANK, 'BOARD' SELF-INITIALISES TO THE FOLLOWING VALUES
     89  1479							; FROM THEN ON IT'S WRITEABLE (REMEMBER TO +RAM_WRITE) FOR MODIFICATIONS
     90  1479
     91  1479		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     92  1483		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     93  148d
     94  148d					      REPEAT	8
     95  148d		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  148d					      REPEND
     95  1497		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  1497					      REPEND
     95  14a1		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  14a1					      REPEND
     95  14ab		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  14ab					      REPEND
     95  14b5		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  14b5					      REPEND
     95  14bf		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  14bf					      REPEND
     95  14c9		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  14c9					      REPEND
     95  14d3		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     96  14dd					      REPEND
     97  14dd
     98  14dd							; DON'T OVERSTEP BOUNDS WHEN WRITING BOARD - MAXIMUM INDEX = 99
     99  14dd
    100  14dd
    101  14dd							;---------------------------------------------------------------------------------------------------
    102  14dd							; EOF
------- FILE ./chess.asm
------- FILE BANK_EVAL.asm LEVEL 2 PASS 4
      0  14dd					      include	"BANK_EVAL.asm"
      1  14dd
      0  14dd					      SLOT	3
      1  14dd				  -	      IF	(3 < 0) || (3 > 3)
      2  14dd				  -	      ECHO	"Illegal bank address/segment location", 3
      3  14dd				  -	      ERR
      4  14dd					      ENDIF
      5  14dd				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  14dd				   _BANK_SLOT SET	3 * 64
      3  14dd
      4  14dd
      0  14dd					      NEWRAMBANK	BANK_EVAL
      1  14dd
      2  14dd
      3  14dd
      4 U4800 ????				      SEG.U	BANK_EVAL
      5 U4800					      ORG	ORIGIN_RAM
      6 U4800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U4800				   _BANK_START SET	*
      8 U4800				   RAMBANK_BANK_EVAL SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U4800				   _CURRENT_RAMBANK SET	RAMBANK_BANK_EVAL
     10 U4800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U4800					      ROMBANK	EVAL
      1  1a40 ????				      SEG	EVAL
      2  1800					      ORG	_ORIGIN
      3  1800					      RORG	_BANK_ADDRESS_ORIGIN
      4  1800				   _BANK_START SET	*
      5  1800				   EVAL_START SET	*
      6  1800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1800				   EVAL       SET	_BANK_SLOT + _CURRENT_BANK
      8  1800				   _ORIGIN    SET	_ORIGIN + 1024
      7  1800
      8  1800
      9  1800							; see https://www.chessprogramming.org/Simplified_Evaluation_Function
     10  1800
     11  1800
     12  1800
     13  1800							;---------------------------------------------------------------------------------------------------
     14  1800							; Vectors to the position value tables for each piece
     15  1800
     16  1800							;---------------------------------------------------------------------------------------------------
     17  1800							; Vectors to the position value tables for each piece
     18  1800
     19  1800					      MAC	posval
     20  1800					      .byte	0
     21  1800					      .byte	{1}(PositionalValue_PAWN - 22)
     22  1800					      .byte	{1}(PositionalValue_PAWN - 22)
     23  1800					      .byte	{1}(PositionalValue_KNIGHT - 22)
     24  1800					      .byte	{1}(PositionalValue_BISHOP - 22)
     25  1800					      .byte	{1}(PositionalValue_ROOK - 22)
     26  1800					      .byte	{1}(PositionalValue_QUEEN - 22)
     27  1800					      .byte	{1}(PositionalValue_KING_ENDGAME - 22)
     28  1800					      ENDM
     29  1800
      0  1800					      ALLOCATE	PosValVecLO, 8
      0  1800					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1800					      LIST	ON
      0  1800					      DEF	PosValVecLO
      1  1800				   SLOT_PosValVecLO SET	_BANK_SLOT
      2  1800				   BANK_PosValVecLO SET	SLOT_PosValVecLO + _CURRENT_BANK
      3  1800				   PosValVecLO
      4  1800				   TEMPORARY_VAR SET	Overlay
      5  1800				   TEMPORARY_OFFSET SET	0
      6  1800				   VAR_BOUNDARY_PosValVecLO SET	TEMPORARY_OFFSET
      7  1800				   FUNCTION_NAME SET	PosValVecLO
      0  1800					      POSVAL	<
      1  1800		       00		      .byte.b	0
      2  1801		       fa		      .byte.b	<(PositionalValue_PAWN - 22)
      3  1802		       fa		      .byte.b	<(PositionalValue_PAWN - 22)
      4  1803		       4a		      .byte.b	<(PositionalValue_KNIGHT - 22)
      5  1804		       9a		      .byte.b	<(PositionalValue_BISHOP - 22)
      6  1805		       ea		      .byte.b	<(PositionalValue_ROOK - 22)
      7  1806		       3a		      .byte.b	<(PositionalValue_QUEEN - 22)
      8  1807		       da		      .byte.b	<(PositionalValue_KING_ENDGAME - 22)
      0  1808					      ALLOCATE	PosValVecHI, 8
      0  1808					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1808					      LIST	ON
      0  1808					      DEF	PosValVecHI
      1  1808				   SLOT_PosValVecHI SET	_BANK_SLOT
      2  1808				   BANK_PosValVecHI SET	SLOT_PosValVecHI + _CURRENT_BANK
      3  1808				   PosValVecHI
      4  1808				   TEMPORARY_VAR SET	Overlay
      5  1808				   TEMPORARY_OFFSET SET	0
      6  1808				   VAR_BOUNDARY_PosValVecHI SET	TEMPORARY_OFFSET
      7  1808				   FUNCTION_NAME SET	PosValVecHI
      0  1808					      POSVAL	>
      1  1808		       00		      .byte.b	0
      2  1809		       fb		      .byte.b	>(PositionalValue_PAWN - 22)
      3  180a		       fb		      .byte.b	>(PositionalValue_PAWN - 22)
      4  180b		       fc		      .byte.b	>(PositionalValue_KNIGHT - 22)
      5  180c		       fc		      .byte.b	>(PositionalValue_BISHOP - 22)
      6  180d		       fc		      .byte.b	>(PositionalValue_ROOK - 22)
      7  180e		       fd		      .byte.b	>(PositionalValue_QUEEN - 22)
      8  180f		       fd		      .byte.b	>(PositionalValue_KING_ENDGAME - 22)
     34  1810
     35  1810
     36  1810					      MAC	eval8
     37  1810					      IF	({1} > 127) || ({1} < -128)
     38  1810					      ECHO	"Erroneous position value", {1}
     39  1810					      ERR
     40  1810					      ENDIF
     41  1810					      .byte	{1}
     42  1810					      ENDM
     43  1810
     44  1810
     45  1810					      MAC	pval
     46  1810					      EVAL8	{1}
     47  1810					      EVAL8	{2}
     48  1810					      EVAL8	{3}
     49  1810					      EVAL8	{4}
     50  1810					      EVAL8	{5}
     51  1810					      EVAL8	{6}
     52  1810					      EVAL8	{7}
     53  1810					      EVAL8	{8}
     54  1810					      EVAL8	0
     55  1810					      EVAL8	0
     56  1810					      ENDM		;{ 10 entries }
     57  1810
     58  1810
     59  1810				  -	      IF	0
     69  1810				  -	      ENDM
     70  1810				  -
     71  1810				  -	      ALLOCATE	PosValVecLO, 8
     72  1810				  -	      POSVAL	<
     73  1810				  -	      ALLOCATE	PosValVecHI, 8
     74  1810				  -	      POSVAL	>
     75  1810				  -
     76  1810				  -BZ	      =	0
     77  1810				  -
     89  1810				  -	      ENDM		;{ 10 entries }
     90  1810					      ENDIF
     91  1810
     92  1810							;---------------------------------------------------------------------------------------------------
     93  1810
     94  1810				   PositionalValue_PAWN
     95  1810
      0  1810					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  1810					      EVAL8	0
      1  1810				  -	      IF	(0 > 127) || (0 < -128)
      2  1810				  -	      ECHO	"Erroneous position value", 0
      3  1810				  -	      ERR
      4  1810					      ENDIF
      5  1810		       00		      .byte.b	0
      0  1811					      EVAL8	0
      1  1811				  -	      IF	(0 > 127) || (0 < -128)
      2  1811				  -	      ECHO	"Erroneous position value", 0
      3  1811				  -	      ERR
      4  1811					      ENDIF
      5  1811		       00		      .byte.b	0
      0  1812					      EVAL8	0
      1  1812				  -	      IF	(0 > 127) || (0 < -128)
      2  1812				  -	      ECHO	"Erroneous position value", 0
      3  1812				  -	      ERR
      4  1812					      ENDIF
      5  1812		       00		      .byte.b	0
      0  1813					      EVAL8	0
      1  1813				  -	      IF	(0 > 127) || (0 < -128)
      2  1813				  -	      ECHO	"Erroneous position value", 0
      3  1813				  -	      ERR
      4  1813					      ENDIF
      5  1813		       00		      .byte.b	0
      0  1814					      EVAL8	0
      1  1814				  -	      IF	(0 > 127) || (0 < -128)
      2  1814				  -	      ECHO	"Erroneous position value", 0
      3  1814				  -	      ERR
      4  1814					      ENDIF
      5  1814		       00		      .byte.b	0
      0  1815					      EVAL8	0
      1  1815				  -	      IF	(0 > 127) || (0 < -128)
      2  1815				  -	      ECHO	"Erroneous position value", 0
      3  1815				  -	      ERR
      4  1815					      ENDIF
      5  1815		       00		      .byte.b	0
      0  1816					      EVAL8	0
      1  1816				  -	      IF	(0 > 127) || (0 < -128)
      2  1816				  -	      ECHO	"Erroneous position value", 0
      3  1816				  -	      ERR
      4  1816					      ENDIF
      5  1816		       00		      .byte.b	0
      0  1817					      EVAL8	0
      1  1817				  -	      IF	(0 > 127) || (0 < -128)
      2  1817				  -	      ECHO	"Erroneous position value", 0
      3  1817				  -	      ERR
      4  1817					      ENDIF
      5  1817		       00		      .byte.b	0
      0  1818					      EVAL8	0
      1  1818				  -	      IF	(0 > 127) || (0 < -128)
      2  1818				  -	      ECHO	"Erroneous position value", 0
      3  1818				  -	      ERR
      4  1818					      ENDIF
      5  1818		       00		      .byte.b	0
      0  1819					      EVAL8	0
      1  1819				  -	      IF	(0 > 127) || (0 < -128)
      2  1819				  -	      ECHO	"Erroneous position value", 0
      3  1819				  -	      ERR
      4  1819					      ENDIF
      5  1819		       00		      .byte.b	0
      0  181a					      PVAL	15, 20, 0, -10, -10, 0, 20, 15
      0  181a					      EVAL8	15
      1  181a				  -	      IF	(15 > 127) || (15 < -128)
      2  181a				  -	      ECHO	"Erroneous position value", 15
      3  181a				  -	      ERR
      4  181a					      ENDIF
      5  181a		       0f		      .byte.b	15
      0  181b					      EVAL8	20
      1  181b				  -	      IF	(20 > 127) || (20 < -128)
      2  181b				  -	      ECHO	"Erroneous position value", 20
      3  181b				  -	      ERR
      4  181b					      ENDIF
      5  181b		       14		      .byte.b	20
      0  181c					      EVAL8	0
      1  181c				  -	      IF	(0 > 127) || (0 < -128)
      2  181c				  -	      ECHO	"Erroneous position value", 0
      3  181c				  -	      ERR
      4  181c					      ENDIF
      5  181c		       00		      .byte.b	0
      0  181d					      EVAL8	-10
      1  181d				  -	      IF	(-10 > 127) || (-10 < -128)
      2  181d				  -	      ECHO	"Erroneous position value", -10
      3  181d				  -	      ERR
      4  181d					      ENDIF
      5  181d		       f6		      .byte.b	-10
      0  181e					      EVAL8	-10
      1  181e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  181e				  -	      ECHO	"Erroneous position value", -10
      3  181e				  -	      ERR
      4  181e					      ENDIF
      5  181e		       f6		      .byte.b	-10
      0  181f					      EVAL8	0
      1  181f				  -	      IF	(0 > 127) || (0 < -128)
      2  181f				  -	      ECHO	"Erroneous position value", 0
      3  181f				  -	      ERR
      4  181f					      ENDIF
      5  181f		       00		      .byte.b	0
      0  1820					      EVAL8	20
      1  1820				  -	      IF	(20 > 127) || (20 < -128)
      2  1820				  -	      ECHO	"Erroneous position value", 20
      3  1820				  -	      ERR
      4  1820					      ENDIF
      5  1820		       14		      .byte.b	20
      0  1821					      EVAL8	15
      1  1821				  -	      IF	(15 > 127) || (15 < -128)
      2  1821				  -	      ECHO	"Erroneous position value", 15
      3  1821				  -	      ERR
      4  1821					      ENDIF
      5  1821		       0f		      .byte.b	15
      0  1822					      EVAL8	0
      1  1822				  -	      IF	(0 > 127) || (0 < -128)
      2  1822				  -	      ECHO	"Erroneous position value", 0
      3  1822				  -	      ERR
      4  1822					      ENDIF
      5  1822		       00		      .byte.b	0
      0  1823					      EVAL8	0
      1  1823				  -	      IF	(0 > 127) || (0 < -128)
      2  1823				  -	      ECHO	"Erroneous position value", 0
      3  1823				  -	      ERR
      4  1823					      ENDIF
      5  1823		       00		      .byte.b	0
      0  1824					      PVAL	5, -5, 20, 0, 0, 20, -5, 5
      0  1824					      EVAL8	5
      1  1824				  -	      IF	(5 > 127) || (5 < -128)
      2  1824				  -	      ECHO	"Erroneous position value", 5
      3  1824				  -	      ERR
      4  1824					      ENDIF
      5  1824		       05		      .byte.b	5
      0  1825					      EVAL8	-5
      1  1825				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1825				  -	      ECHO	"Erroneous position value", -5
      3  1825				  -	      ERR
      4  1825					      ENDIF
      5  1825		       fb		      .byte.b	-5
      0  1826					      EVAL8	20
      1  1826				  -	      IF	(20 > 127) || (20 < -128)
      2  1826				  -	      ECHO	"Erroneous position value", 20
      3  1826				  -	      ERR
      4  1826					      ENDIF
      5  1826		       14		      .byte.b	20
      0  1827					      EVAL8	0
      1  1827				  -	      IF	(0 > 127) || (0 < -128)
      2  1827				  -	      ECHO	"Erroneous position value", 0
      3  1827				  -	      ERR
      4  1827					      ENDIF
      5  1827		       00		      .byte.b	0
      0  1828					      EVAL8	0
      1  1828				  -	      IF	(0 > 127) || (0 < -128)
      2  1828				  -	      ECHO	"Erroneous position value", 0
      3  1828				  -	      ERR
      4  1828					      ENDIF
      5  1828		       00		      .byte.b	0
      0  1829					      EVAL8	20
      1  1829				  -	      IF	(20 > 127) || (20 < -128)
      2  1829				  -	      ECHO	"Erroneous position value", 20
      3  1829				  -	      ERR
      4  1829					      ENDIF
      5  1829		       14		      .byte.b	20
      0  182a					      EVAL8	-5
      1  182a				  -	      IF	(-5 > 127) || (-5 < -128)
      2  182a				  -	      ECHO	"Erroneous position value", -5
      3  182a				  -	      ERR
      4  182a					      ENDIF
      5  182a		       fb		      .byte.b	-5
      0  182b					      EVAL8	5
      1  182b				  -	      IF	(5 > 127) || (5 < -128)
      2  182b				  -	      ECHO	"Erroneous position value", 5
      3  182b				  -	      ERR
      4  182b					      ENDIF
      5  182b		       05		      .byte.b	5
      0  182c					      EVAL8	0
      1  182c				  -	      IF	(0 > 127) || (0 < -128)
      2  182c				  -	      ECHO	"Erroneous position value", 0
      3  182c				  -	      ERR
      4  182c					      ENDIF
      5  182c		       00		      .byte.b	0
      0  182d					      EVAL8	0
      1  182d				  -	      IF	(0 > 127) || (0 < -128)
      2  182d				  -	      ECHO	"Erroneous position value", 0
      3  182d				  -	      ERR
      4  182d					      ENDIF
      5  182d		       00		      .byte.b	0
      0  182e					      PVAL	5, 5, 10, 20, 40, 20, 5, 5
      0  182e					      EVAL8	5
      1  182e				  -	      IF	(5 > 127) || (5 < -128)
      2  182e				  -	      ECHO	"Erroneous position value", 5
      3  182e				  -	      ERR
      4  182e					      ENDIF
      5  182e		       05		      .byte.b	5
      0  182f					      EVAL8	5
      1  182f				  -	      IF	(5 > 127) || (5 < -128)
      2  182f				  -	      ECHO	"Erroneous position value", 5
      3  182f				  -	      ERR
      4  182f					      ENDIF
      5  182f		       05		      .byte.b	5
      0  1830					      EVAL8	10
      1  1830				  -	      IF	(10 > 127) || (10 < -128)
      2  1830				  -	      ECHO	"Erroneous position value", 10
      3  1830				  -	      ERR
      4  1830					      ENDIF
      5  1830		       0a		      .byte.b	10
      0  1831					      EVAL8	20
      1  1831				  -	      IF	(20 > 127) || (20 < -128)
      2  1831				  -	      ECHO	"Erroneous position value", 20
      3  1831				  -	      ERR
      4  1831					      ENDIF
      5  1831		       14		      .byte.b	20
      0  1832					      EVAL8	40
      1  1832				  -	      IF	(40 > 127) || (40 < -128)
      2  1832				  -	      ECHO	"Erroneous position value", 40
      3  1832				  -	      ERR
      4  1832					      ENDIF
      5  1832		       28		      .byte.b	40
      0  1833					      EVAL8	20
      1  1833				  -	      IF	(20 > 127) || (20 < -128)
      2  1833				  -	      ECHO	"Erroneous position value", 20
      3  1833				  -	      ERR
      4  1833					      ENDIF
      5  1833		       14		      .byte.b	20
      0  1834					      EVAL8	5
      1  1834				  -	      IF	(5 > 127) || (5 < -128)
      2  1834				  -	      ECHO	"Erroneous position value", 5
      3  1834				  -	      ERR
      4  1834					      ENDIF
      5  1834		       05		      .byte.b	5
      0  1835					      EVAL8	5
      1  1835				  -	      IF	(5 > 127) || (5 < -128)
      2  1835				  -	      ECHO	"Erroneous position value", 5
      3  1835				  -	      ERR
      4  1835					      ENDIF
      5  1835		       05		      .byte.b	5
      0  1836					      EVAL8	0
      1  1836				  -	      IF	(0 > 127) || (0 < -128)
      2  1836				  -	      ECHO	"Erroneous position value", 0
      3  1836				  -	      ERR
      4  1836					      ENDIF
      5  1836		       00		      .byte.b	0
      0  1837					      EVAL8	0
      1  1837				  -	      IF	(0 > 127) || (0 < -128)
      2  1837				  -	      ECHO	"Erroneous position value", 0
      3  1837				  -	      ERR
      4  1837					      ENDIF
      5  1837		       00		      .byte.b	0
      0  1838					      PVAL	15, 15, 20, 40, 50, 20, 15, 15
      0  1838					      EVAL8	15
      1  1838				  -	      IF	(15 > 127) || (15 < -128)
      2  1838				  -	      ECHO	"Erroneous position value", 15
      3  1838				  -	      ERR
      4  1838					      ENDIF
      5  1838		       0f		      .byte.b	15
      0  1839					      EVAL8	15
      1  1839				  -	      IF	(15 > 127) || (15 < -128)
      2  1839				  -	      ECHO	"Erroneous position value", 15
      3  1839				  -	      ERR
      4  1839					      ENDIF
      5  1839		       0f		      .byte.b	15
      0  183a					      EVAL8	20
      1  183a				  -	      IF	(20 > 127) || (20 < -128)
      2  183a				  -	      ECHO	"Erroneous position value", 20
      3  183a				  -	      ERR
      4  183a					      ENDIF
      5  183a		       14		      .byte.b	20
      0  183b					      EVAL8	40
      1  183b				  -	      IF	(40 > 127) || (40 < -128)
      2  183b				  -	      ECHO	"Erroneous position value", 40
      3  183b				  -	      ERR
      4  183b					      ENDIF
      5  183b		       28		      .byte.b	40
      0  183c					      EVAL8	50
      1  183c				  -	      IF	(50 > 127) || (50 < -128)
      2  183c				  -	      ECHO	"Erroneous position value", 50
      3  183c				  -	      ERR
      4  183c					      ENDIF
      5  183c		       32		      .byte.b	50
      0  183d					      EVAL8	20
      1  183d				  -	      IF	(20 > 127) || (20 < -128)
      2  183d				  -	      ECHO	"Erroneous position value", 20
      3  183d				  -	      ERR
      4  183d					      ENDIF
      5  183d		       14		      .byte.b	20
      0  183e					      EVAL8	15
      1  183e				  -	      IF	(15 > 127) || (15 < -128)
      2  183e				  -	      ECHO	"Erroneous position value", 15
      3  183e				  -	      ERR
      4  183e					      ENDIF
      5  183e		       0f		      .byte.b	15
      0  183f					      EVAL8	15
      1  183f				  -	      IF	(15 > 127) || (15 < -128)
      2  183f				  -	      ECHO	"Erroneous position value", 15
      3  183f				  -	      ERR
      4  183f					      ENDIF
      5  183f		       0f		      .byte.b	15
      0  1840					      EVAL8	0
      1  1840				  -	      IF	(0 > 127) || (0 < -128)
      2  1840				  -	      ECHO	"Erroneous position value", 0
      3  1840				  -	      ERR
      4  1840					      ENDIF
      5  1840		       00		      .byte.b	0
      0  1841					      EVAL8	0
      1  1841				  -	      IF	(0 > 127) || (0 < -128)
      2  1841				  -	      ECHO	"Erroneous position value", 0
      3  1841				  -	      ERR
      4  1841					      ENDIF
      5  1841		       00		      .byte.b	0
      0  1842					      PVAL	60, 60, 80, 80, 80, 80, 60, 60
      0  1842					      EVAL8	60
      1  1842				  -	      IF	(60 > 127) || (60 < -128)
      2  1842				  -	      ECHO	"Erroneous position value", 60
      3  1842				  -	      ERR
      4  1842					      ENDIF
      5  1842		       3c		      .byte.b	60
      0  1843					      EVAL8	60
      1  1843				  -	      IF	(60 > 127) || (60 < -128)
      2  1843				  -	      ECHO	"Erroneous position value", 60
      3  1843				  -	      ERR
      4  1843					      ENDIF
      5  1843		       3c		      .byte.b	60
      0  1844					      EVAL8	80
      1  1844				  -	      IF	(80 > 127) || (80 < -128)
      2  1844				  -	      ECHO	"Erroneous position value", 80
      3  1844				  -	      ERR
      4  1844					      ENDIF
      5  1844		       50		      .byte.b	80
      0  1845					      EVAL8	80
      1  1845				  -	      IF	(80 > 127) || (80 < -128)
      2  1845				  -	      ECHO	"Erroneous position value", 80
      3  1845				  -	      ERR
      4  1845					      ENDIF
      5  1845		       50		      .byte.b	80
      0  1846					      EVAL8	80
      1  1846				  -	      IF	(80 > 127) || (80 < -128)
      2  1846				  -	      ECHO	"Erroneous position value", 80
      3  1846				  -	      ERR
      4  1846					      ENDIF
      5  1846		       50		      .byte.b	80
      0  1847					      EVAL8	80
      1  1847				  -	      IF	(80 > 127) || (80 < -128)
      2  1847				  -	      ECHO	"Erroneous position value", 80
      3  1847				  -	      ERR
      4  1847					      ENDIF
      5  1847		       50		      .byte.b	80
      0  1848					      EVAL8	60
      1  1848				  -	      IF	(60 > 127) || (60 < -128)
      2  1848				  -	      ECHO	"Erroneous position value", 60
      3  1848				  -	      ERR
      4  1848					      ENDIF
      5  1848		       3c		      .byte.b	60
      0  1849					      EVAL8	60
      1  1849				  -	      IF	(60 > 127) || (60 < -128)
      2  1849				  -	      ECHO	"Erroneous position value", 60
      3  1849				  -	      ERR
      4  1849					      ENDIF
      5  1849		       3c		      .byte.b	60
      0  184a					      EVAL8	0
      1  184a				  -	      IF	(0 > 127) || (0 < -128)
      2  184a				  -	      ECHO	"Erroneous position value", 0
      3  184a				  -	      ERR
      4  184a					      ENDIF
      5  184a		       00		      .byte.b	0
      0  184b					      EVAL8	0
      1  184b				  -	      IF	(0 > 127) || (0 < -128)
      2  184b				  -	      ECHO	"Erroneous position value", 0
      3  184b				  -	      ERR
      4  184b					      ENDIF
      5  184b		       00		      .byte.b	0
      0  184c					      PVAL	100, 100, 120, 120, 120, 120, 100, 100
      0  184c					      EVAL8	100
      1  184c				  -	      IF	(100 > 127) || (100 < -128)
      2  184c				  -	      ECHO	"Erroneous position value", 100
      3  184c				  -	      ERR
      4  184c					      ENDIF
      5  184c		       64		      .byte.b	100
      0  184d					      EVAL8	100
      1  184d				  -	      IF	(100 > 127) || (100 < -128)
      2  184d				  -	      ECHO	"Erroneous position value", 100
      3  184d				  -	      ERR
      4  184d					      ENDIF
      5  184d		       64		      .byte.b	100
      0  184e					      EVAL8	120
      1  184e				  -	      IF	(120 > 127) || (120 < -128)
      2  184e				  -	      ECHO	"Erroneous position value", 120
      3  184e				  -	      ERR
      4  184e					      ENDIF
      5  184e		       78		      .byte.b	120
      0  184f					      EVAL8	120
      1  184f				  -	      IF	(120 > 127) || (120 < -128)
      2  184f				  -	      ECHO	"Erroneous position value", 120
      3  184f				  -	      ERR
      4  184f					      ENDIF
      5  184f		       78		      .byte.b	120
      0  1850					      EVAL8	120
      1  1850				  -	      IF	(120 > 127) || (120 < -128)
      2  1850				  -	      ECHO	"Erroneous position value", 120
      3  1850				  -	      ERR
      4  1850					      ENDIF
      5  1850		       78		      .byte.b	120
      0  1851					      EVAL8	120
      1  1851				  -	      IF	(120 > 127) || (120 < -128)
      2  1851				  -	      ECHO	"Erroneous position value", 120
      3  1851				  -	      ERR
      4  1851					      ENDIF
      5  1851		       78		      .byte.b	120
      0  1852					      EVAL8	100
      1  1852				  -	      IF	(100 > 127) || (100 < -128)
      2  1852				  -	      ECHO	"Erroneous position value", 100
      3  1852				  -	      ERR
      4  1852					      ENDIF
      5  1852		       64		      .byte.b	100
      0  1853					      EVAL8	100
      1  1853				  -	      IF	(100 > 127) || (100 < -128)
      2  1853				  -	      ECHO	"Erroneous position value", 100
      3  1853				  -	      ERR
      4  1853					      ENDIF
      5  1853		       64		      .byte.b	100
      0  1854					      EVAL8	0
      1  1854				  -	      IF	(0 > 127) || (0 < -128)
      2  1854				  -	      ECHO	"Erroneous position value", 0
      3  1854				  -	      ERR
      4  1854					      ENDIF
      5  1854		       00		      .byte.b	0
      0  1855					      EVAL8	0
      1  1855				  -	      IF	(0 > 127) || (0 < -128)
      2  1855				  -	      ECHO	"Erroneous position value", 0
      3  1855				  -	      ERR
      4  1855					      ENDIF
      5  1855		       00		      .byte.b	0
      0  1856					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  1856					      EVAL8	0
      1  1856				  -	      IF	(0 > 127) || (0 < -128)
      2  1856				  -	      ECHO	"Erroneous position value", 0
      3  1856				  -	      ERR
      4  1856					      ENDIF
      5  1856		       00		      .byte.b	0
      0  1857					      EVAL8	0
      1  1857				  -	      IF	(0 > 127) || (0 < -128)
      2  1857				  -	      ECHO	"Erroneous position value", 0
      3  1857				  -	      ERR
      4  1857					      ENDIF
      5  1857		       00		      .byte.b	0
      0  1858					      EVAL8	0
      1  1858				  -	      IF	(0 > 127) || (0 < -128)
      2  1858				  -	      ECHO	"Erroneous position value", 0
      3  1858				  -	      ERR
      4  1858					      ENDIF
      5  1858		       00		      .byte.b	0
      0  1859					      EVAL8	0
      1  1859				  -	      IF	(0 > 127) || (0 < -128)
      2  1859				  -	      ECHO	"Erroneous position value", 0
      3  1859				  -	      ERR
      4  1859					      ENDIF
      5  1859		       00		      .byte.b	0
      0  185a					      EVAL8	0
      1  185a				  -	      IF	(0 > 127) || (0 < -128)
      2  185a				  -	      ECHO	"Erroneous position value", 0
      3  185a				  -	      ERR
      4  185a					      ENDIF
      5  185a		       00		      .byte.b	0
      0  185b					      EVAL8	0
      1  185b				  -	      IF	(0 > 127) || (0 < -128)
      2  185b				  -	      ECHO	"Erroneous position value", 0
      3  185b				  -	      ERR
      4  185b					      ENDIF
      5  185b		       00		      .byte.b	0
      0  185c					      EVAL8	0
      1  185c				  -	      IF	(0 > 127) || (0 < -128)
      2  185c				  -	      ECHO	"Erroneous position value", 0
      3  185c				  -	      ERR
      4  185c					      ENDIF
      5  185c		       00		      .byte.b	0
      0  185d					      EVAL8	0
      1  185d				  -	      IF	(0 > 127) || (0 < -128)
      2  185d				  -	      ECHO	"Erroneous position value", 0
      3  185d				  -	      ERR
      4  185d					      ENDIF
      5  185d		       00		      .byte.b	0
      0  185e					      EVAL8	0
      1  185e				  -	      IF	(0 > 127) || (0 < -128)
      2  185e				  -	      ECHO	"Erroneous position value", 0
      3  185e				  -	      ERR
      4  185e					      ENDIF
      5  185e		       00		      .byte.b	0
      0  185f					      EVAL8	0
      1  185f				  -	      IF	(0 > 127) || (0 < -128)
      2  185f				  -	      ECHO	"Erroneous position value", 0
      3  185f				  -	      ERR
      4  185f					      ENDIF
      5  185f		       00		      .byte.b	0
    104  1860
    105  1860							;---------------------------------------------------------------------------------------------------
    106  1860
    107  1860				   PositionalValue_KNIGHT
    108  1860
      0  1860					      PVAL	-50, -30, -30, -30, -30, -30, -22, -50
      0  1860					      EVAL8	-50
      1  1860				  -	      IF	(-50 > 127) || (-50 < -128)
      2  1860				  -	      ECHO	"Erroneous position value", -50
      3  1860				  -	      ERR
      4  1860					      ENDIF
      5  1860		       ce		      .byte.b	-50
      0  1861					      EVAL8	-30
      1  1861				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1861				  -	      ECHO	"Erroneous position value", -30
      3  1861				  -	      ERR
      4  1861					      ENDIF
      5  1861		       e2		      .byte.b	-30
      0  1862					      EVAL8	-30
      1  1862				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1862				  -	      ECHO	"Erroneous position value", -30
      3  1862				  -	      ERR
      4  1862					      ENDIF
      5  1862		       e2		      .byte.b	-30
      0  1863					      EVAL8	-30
      1  1863				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1863				  -	      ECHO	"Erroneous position value", -30
      3  1863				  -	      ERR
      4  1863					      ENDIF
      5  1863		       e2		      .byte.b	-30
      0  1864					      EVAL8	-30
      1  1864				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1864				  -	      ECHO	"Erroneous position value", -30
      3  1864				  -	      ERR
      4  1864					      ENDIF
      5  1864		       e2		      .byte.b	-30
      0  1865					      EVAL8	-30
      1  1865				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1865				  -	      ECHO	"Erroneous position value", -30
      3  1865				  -	      ERR
      4  1865					      ENDIF
      5  1865		       e2		      .byte.b	-30
      0  1866					      EVAL8	-22
      1  1866				  -	      IF	(-22 > 127) || (-22 < -128)
      2  1866				  -	      ECHO	"Erroneous position value", -22
      3  1866				  -	      ERR
      4  1866					      ENDIF
      5  1866		       ea		      .byte.b	-22
      0  1867					      EVAL8	-50
      1  1867				  -	      IF	(-50 > 127) || (-50 < -128)
      2  1867				  -	      ECHO	"Erroneous position value", -50
      3  1867				  -	      ERR
      4  1867					      ENDIF
      5  1867		       ce		      .byte.b	-50
      0  1868					      EVAL8	0
      1  1868				  -	      IF	(0 > 127) || (0 < -128)
      2  1868				  -	      ECHO	"Erroneous position value", 0
      3  1868				  -	      ERR
      4  1868					      ENDIF
      5  1868		       00		      .byte.b	0
      0  1869					      EVAL8	0
      1  1869				  -	      IF	(0 > 127) || (0 < -128)
      2  1869				  -	      ECHO	"Erroneous position value", 0
      3  1869				  -	      ERR
      4  1869					      ENDIF
      5  1869		       00		      .byte.b	0
      0  186a					      PVAL	-40, -20, 0, -5, -25, 0, -20, -40
      0  186a					      EVAL8	-40
      1  186a				  -	      IF	(-40 > 127) || (-40 < -128)
      2  186a				  -	      ECHO	"Erroneous position value", -40
      3  186a				  -	      ERR
      4  186a					      ENDIF
      5  186a		       d8		      .byte.b	-40
      0  186b					      EVAL8	-20
      1  186b				  -	      IF	(-20 > 127) || (-20 < -128)
      2  186b				  -	      ECHO	"Erroneous position value", -20
      3  186b				  -	      ERR
      4  186b					      ENDIF
      5  186b		       ec		      .byte.b	-20
      0  186c					      EVAL8	0
      1  186c				  -	      IF	(0 > 127) || (0 < -128)
      2  186c				  -	      ECHO	"Erroneous position value", 0
      3  186c				  -	      ERR
      4  186c					      ENDIF
      5  186c		       00		      .byte.b	0
      0  186d					      EVAL8	-5
      1  186d				  -	      IF	(-5 > 127) || (-5 < -128)
      2  186d				  -	      ECHO	"Erroneous position value", -5
      3  186d				  -	      ERR
      4  186d					      ENDIF
      5  186d		       fb		      .byte.b	-5
      0  186e					      EVAL8	-25
      1  186e				  -	      IF	(-25 > 127) || (-25 < -128)
      2  186e				  -	      ECHO	"Erroneous position value", -25
      3  186e				  -	      ERR
      4  186e					      ENDIF
      5  186e		       e7		      .byte.b	-25
      0  186f					      EVAL8	0
      1  186f				  -	      IF	(0 > 127) || (0 < -128)
      2  186f				  -	      ECHO	"Erroneous position value", 0
      3  186f				  -	      ERR
      4  186f					      ENDIF
      5  186f		       00		      .byte.b	0
      0  1870					      EVAL8	-20
      1  1870				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1870				  -	      ECHO	"Erroneous position value", -20
      3  1870				  -	      ERR
      4  1870					      ENDIF
      5  1870		       ec		      .byte.b	-20
      0  1871					      EVAL8	-40
      1  1871				  -	      IF	(-40 > 127) || (-40 < -128)
      2  1871				  -	      ECHO	"Erroneous position value", -40
      3  1871				  -	      ERR
      4  1871					      ENDIF
      5  1871		       d8		      .byte.b	-40
      0  1872					      EVAL8	0
      1  1872				  -	      IF	(0 > 127) || (0 < -128)
      2  1872				  -	      ECHO	"Erroneous position value", 0
      3  1872				  -	      ERR
      4  1872					      ENDIF
      5  1872		       00		      .byte.b	0
      0  1873					      EVAL8	0
      1  1873				  -	      IF	(0 > 127) || (0 < -128)
      2  1873				  -	      ECHO	"Erroneous position value", 0
      3  1873				  -	      ERR
      4  1873					      ENDIF
      5  1873		       00		      .byte.b	0
      0  1874					      PVAL	-30, 0, 18, 15, 15, 18, 0, -30
      0  1874					      EVAL8	-30
      1  1874				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1874				  -	      ECHO	"Erroneous position value", -30
      3  1874				  -	      ERR
      4  1874					      ENDIF
      5  1874		       e2		      .byte.b	-30
      0  1875					      EVAL8	0
      1  1875				  -	      IF	(0 > 127) || (0 < -128)
      2  1875				  -	      ECHO	"Erroneous position value", 0
      3  1875				  -	      ERR
      4  1875					      ENDIF
      5  1875		       00		      .byte.b	0
      0  1876					      EVAL8	18
      1  1876				  -	      IF	(18 > 127) || (18 < -128)
      2  1876				  -	      ECHO	"Erroneous position value", 18
      3  1876				  -	      ERR
      4  1876					      ENDIF
      5  1876		       12		      .byte.b	18
      0  1877					      EVAL8	15
      1  1877				  -	      IF	(15 > 127) || (15 < -128)
      2  1877				  -	      ECHO	"Erroneous position value", 15
      3  1877				  -	      ERR
      4  1877					      ENDIF
      5  1877		       0f		      .byte.b	15
      0  1878					      EVAL8	15
      1  1878				  -	      IF	(15 > 127) || (15 < -128)
      2  1878				  -	      ECHO	"Erroneous position value", 15
      3  1878				  -	      ERR
      4  1878					      ENDIF
      5  1878		       0f		      .byte.b	15
      0  1879					      EVAL8	18
      1  1879				  -	      IF	(18 > 127) || (18 < -128)
      2  1879				  -	      ECHO	"Erroneous position value", 18
      3  1879				  -	      ERR
      4  1879					      ENDIF
      5  1879		       12		      .byte.b	18
      0  187a					      EVAL8	0
      1  187a				  -	      IF	(0 > 127) || (0 < -128)
      2  187a				  -	      ECHO	"Erroneous position value", 0
      3  187a				  -	      ERR
      4  187a					      ENDIF
      5  187a		       00		      .byte.b	0
      0  187b					      EVAL8	-30
      1  187b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  187b				  -	      ECHO	"Erroneous position value", -30
      3  187b				  -	      ERR
      4  187b					      ENDIF
      5  187b		       e2		      .byte.b	-30
      0  187c					      EVAL8	0
      1  187c				  -	      IF	(0 > 127) || (0 < -128)
      2  187c				  -	      ECHO	"Erroneous position value", 0
      3  187c				  -	      ERR
      4  187c					      ENDIF
      5  187c		       00		      .byte.b	0
      0  187d					      EVAL8	0
      1  187d				  -	      IF	(0 > 127) || (0 < -128)
      2  187d				  -	      ECHO	"Erroneous position value", 0
      3  187d				  -	      ERR
      4  187d					      ENDIF
      5  187d		       00		      .byte.b	0
      0  187e					      PVAL	-40, 0, 15, 30, 30, 15, 0, -40
      0  187e					      EVAL8	-40
      1  187e				  -	      IF	(-40 > 127) || (-40 < -128)
      2  187e				  -	      ECHO	"Erroneous position value", -40
      3  187e				  -	      ERR
      4  187e					      ENDIF
      5  187e		       d8		      .byte.b	-40
      0  187f					      EVAL8	0
      1  187f				  -	      IF	(0 > 127) || (0 < -128)
      2  187f				  -	      ECHO	"Erroneous position value", 0
      3  187f				  -	      ERR
      4  187f					      ENDIF
      5  187f		       00		      .byte.b	0
      0  1880					      EVAL8	15
      1  1880				  -	      IF	(15 > 127) || (15 < -128)
      2  1880				  -	      ECHO	"Erroneous position value", 15
      3  1880				  -	      ERR
      4  1880					      ENDIF
      5  1880		       0f		      .byte.b	15
      0  1881					      EVAL8	30
      1  1881				  -	      IF	(30 > 127) || (30 < -128)
      2  1881				  -	      ECHO	"Erroneous position value", 30
      3  1881				  -	      ERR
      4  1881					      ENDIF
      5  1881		       1e		      .byte.b	30
      0  1882					      EVAL8	30
      1  1882				  -	      IF	(30 > 127) || (30 < -128)
      2  1882				  -	      ECHO	"Erroneous position value", 30
      3  1882				  -	      ERR
      4  1882					      ENDIF
      5  1882		       1e		      .byte.b	30
      0  1883					      EVAL8	15
      1  1883				  -	      IF	(15 > 127) || (15 < -128)
      2  1883				  -	      ECHO	"Erroneous position value", 15
      3  1883				  -	      ERR
      4  1883					      ENDIF
      5  1883		       0f		      .byte.b	15
      0  1884					      EVAL8	0
      1  1884				  -	      IF	(0 > 127) || (0 < -128)
      2  1884				  -	      ECHO	"Erroneous position value", 0
      3  1884				  -	      ERR
      4  1884					      ENDIF
      5  1884		       00		      .byte.b	0
      0  1885					      EVAL8	-40
      1  1885				  -	      IF	(-40 > 127) || (-40 < -128)
      2  1885				  -	      ECHO	"Erroneous position value", -40
      3  1885				  -	      ERR
      4  1885					      ENDIF
      5  1885		       d8		      .byte.b	-40
      0  1886					      EVAL8	0
      1  1886				  -	      IF	(0 > 127) || (0 < -128)
      2  1886				  -	      ECHO	"Erroneous position value", 0
      3  1886				  -	      ERR
      4  1886					      ENDIF
      5  1886		       00		      .byte.b	0
      0  1887					      EVAL8	0
      1  1887				  -	      IF	(0 > 127) || (0 < -128)
      2  1887				  -	      ECHO	"Erroneous position value", 0
      3  1887				  -	      ERR
      4  1887					      ENDIF
      5  1887		       00		      .byte.b	0
      0  1888					      PVAL	-40, 5, 15, 30, 30, 15, 5, -40
      0  1888					      EVAL8	-40
      1  1888				  -	      IF	(-40 > 127) || (-40 < -128)
      2  1888				  -	      ECHO	"Erroneous position value", -40
      3  1888				  -	      ERR
      4  1888					      ENDIF
      5  1888		       d8		      .byte.b	-40
      0  1889					      EVAL8	5
      1  1889				  -	      IF	(5 > 127) || (5 < -128)
      2  1889				  -	      ECHO	"Erroneous position value", 5
      3  1889				  -	      ERR
      4  1889					      ENDIF
      5  1889		       05		      .byte.b	5
      0  188a					      EVAL8	15
      1  188a				  -	      IF	(15 > 127) || (15 < -128)
      2  188a				  -	      ECHO	"Erroneous position value", 15
      3  188a				  -	      ERR
      4  188a					      ENDIF
      5  188a		       0f		      .byte.b	15
      0  188b					      EVAL8	30
      1  188b				  -	      IF	(30 > 127) || (30 < -128)
      2  188b				  -	      ECHO	"Erroneous position value", 30
      3  188b				  -	      ERR
      4  188b					      ENDIF
      5  188b		       1e		      .byte.b	30
      0  188c					      EVAL8	30
      1  188c				  -	      IF	(30 > 127) || (30 < -128)
      2  188c				  -	      ECHO	"Erroneous position value", 30
      3  188c				  -	      ERR
      4  188c					      ENDIF
      5  188c		       1e		      .byte.b	30
      0  188d					      EVAL8	15
      1  188d				  -	      IF	(15 > 127) || (15 < -128)
      2  188d				  -	      ECHO	"Erroneous position value", 15
      3  188d				  -	      ERR
      4  188d					      ENDIF
      5  188d		       0f		      .byte.b	15
      0  188e					      EVAL8	5
      1  188e				  -	      IF	(5 > 127) || (5 < -128)
      2  188e				  -	      ECHO	"Erroneous position value", 5
      3  188e				  -	      ERR
      4  188e					      ENDIF
      5  188e		       05		      .byte.b	5
      0  188f					      EVAL8	-40
      1  188f				  -	      IF	(-40 > 127) || (-40 < -128)
      2  188f				  -	      ECHO	"Erroneous position value", -40
      3  188f				  -	      ERR
      4  188f					      ENDIF
      5  188f		       d8		      .byte.b	-40
      0  1890					      EVAL8	0
      1  1890				  -	      IF	(0 > 127) || (0 < -128)
      2  1890				  -	      ECHO	"Erroneous position value", 0
      3  1890				  -	      ERR
      4  1890					      ENDIF
      5  1890		       00		      .byte.b	0
      0  1891					      EVAL8	0
      1  1891				  -	      IF	(0 > 127) || (0 < -128)
      2  1891				  -	      ECHO	"Erroneous position value", 0
      3  1891				  -	      ERR
      4  1891					      ENDIF
      5  1891		       00		      .byte.b	0
      0  1892					      PVAL	-30, 0, 10, 15, 15, 10, 0, -30
      0  1892					      EVAL8	-30
      1  1892				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1892				  -	      ECHO	"Erroneous position value", -30
      3  1892				  -	      ERR
      4  1892					      ENDIF
      5  1892		       e2		      .byte.b	-30
      0  1893					      EVAL8	0
      1  1893				  -	      IF	(0 > 127) || (0 < -128)
      2  1893				  -	      ECHO	"Erroneous position value", 0
      3  1893				  -	      ERR
      4  1893					      ENDIF
      5  1893		       00		      .byte.b	0
      0  1894					      EVAL8	10
      1  1894				  -	      IF	(10 > 127) || (10 < -128)
      2  1894				  -	      ECHO	"Erroneous position value", 10
      3  1894				  -	      ERR
      4  1894					      ENDIF
      5  1894		       0a		      .byte.b	10
      0  1895					      EVAL8	15
      1  1895				  -	      IF	(15 > 127) || (15 < -128)
      2  1895				  -	      ECHO	"Erroneous position value", 15
      3  1895				  -	      ERR
      4  1895					      ENDIF
      5  1895		       0f		      .byte.b	15
      0  1896					      EVAL8	15
      1  1896				  -	      IF	(15 > 127) || (15 < -128)
      2  1896				  -	      ECHO	"Erroneous position value", 15
      3  1896				  -	      ERR
      4  1896					      ENDIF
      5  1896		       0f		      .byte.b	15
      0  1897					      EVAL8	10
      1  1897				  -	      IF	(10 > 127) || (10 < -128)
      2  1897				  -	      ECHO	"Erroneous position value", 10
      3  1897				  -	      ERR
      4  1897					      ENDIF
      5  1897		       0a		      .byte.b	10
      0  1898					      EVAL8	0
      1  1898				  -	      IF	(0 > 127) || (0 < -128)
      2  1898				  -	      ECHO	"Erroneous position value", 0
      3  1898				  -	      ERR
      4  1898					      ENDIF
      5  1898		       00		      .byte.b	0
      0  1899					      EVAL8	-30
      1  1899				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1899				  -	      ECHO	"Erroneous position value", -30
      3  1899				  -	      ERR
      4  1899					      ENDIF
      5  1899		       e2		      .byte.b	-30
      0  189a					      EVAL8	0
      1  189a				  -	      IF	(0 > 127) || (0 < -128)
      2  189a				  -	      ECHO	"Erroneous position value", 0
      3  189a				  -	      ERR
      4  189a					      ENDIF
      5  189a		       00		      .byte.b	0
      0  189b					      EVAL8	0
      1  189b				  -	      IF	(0 > 127) || (0 < -128)
      2  189b				  -	      ECHO	"Erroneous position value", 0
      3  189b				  -	      ERR
      4  189b					      ENDIF
      5  189b		       00		      .byte.b	0
      0  189c					      PVAL	-40, -20, 30, 0, 0, 30, -20, -40
      0  189c					      EVAL8	-40
      1  189c				  -	      IF	(-40 > 127) || (-40 < -128)
      2  189c				  -	      ECHO	"Erroneous position value", -40
      3  189c				  -	      ERR
      4  189c					      ENDIF
      5  189c		       d8		      .byte.b	-40
      0  189d					      EVAL8	-20
      1  189d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  189d				  -	      ECHO	"Erroneous position value", -20
      3  189d				  -	      ERR
      4  189d					      ENDIF
      5  189d		       ec		      .byte.b	-20
      0  189e					      EVAL8	30
      1  189e				  -	      IF	(30 > 127) || (30 < -128)
      2  189e				  -	      ECHO	"Erroneous position value", 30
      3  189e				  -	      ERR
      4  189e					      ENDIF
      5  189e		       1e		      .byte.b	30
      0  189f					      EVAL8	0
      1  189f				  -	      IF	(0 > 127) || (0 < -128)
      2  189f				  -	      ECHO	"Erroneous position value", 0
      3  189f				  -	      ERR
      4  189f					      ENDIF
      5  189f		       00		      .byte.b	0
      0  18a0					      EVAL8	0
      1  18a0				  -	      IF	(0 > 127) || (0 < -128)
      2  18a0				  -	      ECHO	"Erroneous position value", 0
      3  18a0				  -	      ERR
      4  18a0					      ENDIF
      5  18a0		       00		      .byte.b	0
      0  18a1					      EVAL8	30
      1  18a1				  -	      IF	(30 > 127) || (30 < -128)
      2  18a1				  -	      ECHO	"Erroneous position value", 30
      3  18a1				  -	      ERR
      4  18a1					      ENDIF
      5  18a1		       1e		      .byte.b	30
      0  18a2					      EVAL8	-20
      1  18a2				  -	      IF	(-20 > 127) || (-20 < -128)
      2  18a2				  -	      ECHO	"Erroneous position value", -20
      3  18a2				  -	      ERR
      4  18a2					      ENDIF
      5  18a2		       ec		      .byte.b	-20
      0  18a3					      EVAL8	-40
      1  18a3				  -	      IF	(-40 > 127) || (-40 < -128)
      2  18a3				  -	      ECHO	"Erroneous position value", -40
      3  18a3				  -	      ERR
      4  18a3					      ENDIF
      5  18a3		       d8		      .byte.b	-40
      0  18a4					      EVAL8	0
      1  18a4				  -	      IF	(0 > 127) || (0 < -128)
      2  18a4				  -	      ECHO	"Erroneous position value", 0
      3  18a4				  -	      ERR
      4  18a4					      ENDIF
      5  18a4		       00		      .byte.b	0
      0  18a5					      EVAL8	0
      1  18a5				  -	      IF	(0 > 127) || (0 < -128)
      2  18a5				  -	      ECHO	"Erroneous position value", 0
      3  18a5				  -	      ERR
      4  18a5					      ENDIF
      5  18a5		       00		      .byte.b	0
      0  18a6					      PVAL	-50, -20, -30, -30, -30, -30, -20, -50
      0  18a6					      EVAL8	-50
      1  18a6				  -	      IF	(-50 > 127) || (-50 < -128)
      2  18a6				  -	      ECHO	"Erroneous position value", -50
      3  18a6				  -	      ERR
      4  18a6					      ENDIF
      5  18a6		       ce		      .byte.b	-50
      0  18a7					      EVAL8	-20
      1  18a7				  -	      IF	(-20 > 127) || (-20 < -128)
      2  18a7				  -	      ECHO	"Erroneous position value", -20
      3  18a7				  -	      ERR
      4  18a7					      ENDIF
      5  18a7		       ec		      .byte.b	-20
      0  18a8					      EVAL8	-30
      1  18a8				  -	      IF	(-30 > 127) || (-30 < -128)
      2  18a8				  -	      ECHO	"Erroneous position value", -30
      3  18a8				  -	      ERR
      4  18a8					      ENDIF
      5  18a8		       e2		      .byte.b	-30
      0  18a9					      EVAL8	-30
      1  18a9				  -	      IF	(-30 > 127) || (-30 < -128)
      2  18a9				  -	      ECHO	"Erroneous position value", -30
      3  18a9				  -	      ERR
      4  18a9					      ENDIF
      5  18a9		       e2		      .byte.b	-30
      0  18aa					      EVAL8	-30
      1  18aa				  -	      IF	(-30 > 127) || (-30 < -128)
      2  18aa				  -	      ECHO	"Erroneous position value", -30
      3  18aa				  -	      ERR
      4  18aa					      ENDIF
      5  18aa		       e2		      .byte.b	-30
      0  18ab					      EVAL8	-30
      1  18ab				  -	      IF	(-30 > 127) || (-30 < -128)
      2  18ab				  -	      ECHO	"Erroneous position value", -30
      3  18ab				  -	      ERR
      4  18ab					      ENDIF
      5  18ab		       e2		      .byte.b	-30
      0  18ac					      EVAL8	-20
      1  18ac				  -	      IF	(-20 > 127) || (-20 < -128)
      2  18ac				  -	      ECHO	"Erroneous position value", -20
      3  18ac				  -	      ERR
      4  18ac					      ENDIF
      5  18ac		       ec		      .byte.b	-20
      0  18ad					      EVAL8	-50
      1  18ad				  -	      IF	(-50 > 127) || (-50 < -128)
      2  18ad				  -	      ECHO	"Erroneous position value", -50
      3  18ad				  -	      ERR
      4  18ad					      ENDIF
      5  18ad		       ce		      .byte.b	-50
      0  18ae					      EVAL8	0
      1  18ae				  -	      IF	(0 > 127) || (0 < -128)
      2  18ae				  -	      ECHO	"Erroneous position value", 0
      3  18ae				  -	      ERR
      4  18ae					      ENDIF
      5  18ae		       00		      .byte.b	0
      0  18af					      EVAL8	0
      1  18af				  -	      IF	(0 > 127) || (0 < -128)
      2  18af				  -	      ECHO	"Erroneous position value", 0
      3  18af				  -	      ERR
      4  18af					      ENDIF
      5  18af		       00		      .byte.b	0
    117  18b0
    118  18b0
    119  18b0							;---------------------------------------------------------------------------------------------------
    120  18b0
    121  18b0				   PositionalValue_BISHOP
    122  18b0
      0  18b0					      PVAL	-20, -10, -50, -10, -10, -50, -10, -20
      0  18b0					      EVAL8	-20
      1  18b0				  -	      IF	(-20 > 127) || (-20 < -128)
      2  18b0				  -	      ECHO	"Erroneous position value", -20
      3  18b0				  -	      ERR
      4  18b0					      ENDIF
      5  18b0		       ec		      .byte.b	-20
      0  18b1					      EVAL8	-10
      1  18b1				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18b1				  -	      ECHO	"Erroneous position value", -10
      3  18b1				  -	      ERR
      4  18b1					      ENDIF
      5  18b1		       f6		      .byte.b	-10
      0  18b2					      EVAL8	-50
      1  18b2				  -	      IF	(-50 > 127) || (-50 < -128)
      2  18b2				  -	      ECHO	"Erroneous position value", -50
      3  18b2				  -	      ERR
      4  18b2					      ENDIF
      5  18b2		       ce		      .byte.b	-50
      0  18b3					      EVAL8	-10
      1  18b3				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18b3				  -	      ECHO	"Erroneous position value", -10
      3  18b3				  -	      ERR
      4  18b3					      ENDIF
      5  18b3		       f6		      .byte.b	-10
      0  18b4					      EVAL8	-10
      1  18b4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18b4				  -	      ECHO	"Erroneous position value", -10
      3  18b4				  -	      ERR
      4  18b4					      ENDIF
      5  18b4		       f6		      .byte.b	-10
      0  18b5					      EVAL8	-50
      1  18b5				  -	      IF	(-50 > 127) || (-50 < -128)
      2  18b5				  -	      ECHO	"Erroneous position value", -50
      3  18b5				  -	      ERR
      4  18b5					      ENDIF
      5  18b5		       ce		      .byte.b	-50
      0  18b6					      EVAL8	-10
      1  18b6				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18b6				  -	      ECHO	"Erroneous position value", -10
      3  18b6				  -	      ERR
      4  18b6					      ENDIF
      5  18b6		       f6		      .byte.b	-10
      0  18b7					      EVAL8	-20
      1  18b7				  -	      IF	(-20 > 127) || (-20 < -128)
      2  18b7				  -	      ECHO	"Erroneous position value", -20
      3  18b7				  -	      ERR
      4  18b7					      ENDIF
      5  18b7		       ec		      .byte.b	-20
      0  18b8					      EVAL8	0
      1  18b8				  -	      IF	(0 > 127) || (0 < -128)
      2  18b8				  -	      ECHO	"Erroneous position value", 0
      3  18b8				  -	      ERR
      4  18b8					      ENDIF
      5  18b8		       00		      .byte.b	0
      0  18b9					      EVAL8	0
      1  18b9				  -	      IF	(0 > 127) || (0 < -128)
      2  18b9				  -	      ECHO	"Erroneous position value", 0
      3  18b9				  -	      ERR
      4  18b9					      ENDIF
      5  18b9		       00		      .byte.b	0
      0  18ba					      PVAL	-10, 5, 0, 0, 0, 0, 5, -10
      0  18ba					      EVAL8	-10
      1  18ba				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18ba				  -	      ECHO	"Erroneous position value", -10
      3  18ba				  -	      ERR
      4  18ba					      ENDIF
      5  18ba		       f6		      .byte.b	-10
      0  18bb					      EVAL8	5
      1  18bb				  -	      IF	(5 > 127) || (5 < -128)
      2  18bb				  -	      ECHO	"Erroneous position value", 5
      3  18bb				  -	      ERR
      4  18bb					      ENDIF
      5  18bb		       05		      .byte.b	5
      0  18bc					      EVAL8	0
      1  18bc				  -	      IF	(0 > 127) || (0 < -128)
      2  18bc				  -	      ECHO	"Erroneous position value", 0
      3  18bc				  -	      ERR
      4  18bc					      ENDIF
      5  18bc		       00		      .byte.b	0
      0  18bd					      EVAL8	0
      1  18bd				  -	      IF	(0 > 127) || (0 < -128)
      2  18bd				  -	      ECHO	"Erroneous position value", 0
      3  18bd				  -	      ERR
      4  18bd					      ENDIF
      5  18bd		       00		      .byte.b	0
      0  18be					      EVAL8	0
      1  18be				  -	      IF	(0 > 127) || (0 < -128)
      2  18be				  -	      ECHO	"Erroneous position value", 0
      3  18be				  -	      ERR
      4  18be					      ENDIF
      5  18be		       00		      .byte.b	0
      0  18bf					      EVAL8	0
      1  18bf				  -	      IF	(0 > 127) || (0 < -128)
      2  18bf				  -	      ECHO	"Erroneous position value", 0
      3  18bf				  -	      ERR
      4  18bf					      ENDIF
      5  18bf		       00		      .byte.b	0
      0  18c0					      EVAL8	5
      1  18c0				  -	      IF	(5 > 127) || (5 < -128)
      2  18c0				  -	      ECHO	"Erroneous position value", 5
      3  18c0				  -	      ERR
      4  18c0					      ENDIF
      5  18c0		       05		      .byte.b	5
      0  18c1					      EVAL8	-10
      1  18c1				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18c1				  -	      ECHO	"Erroneous position value", -10
      3  18c1				  -	      ERR
      4  18c1					      ENDIF
      5  18c1		       f6		      .byte.b	-10
      0  18c2					      EVAL8	0
      1  18c2				  -	      IF	(0 > 127) || (0 < -128)
      2  18c2				  -	      ECHO	"Erroneous position value", 0
      3  18c2				  -	      ERR
      4  18c2					      ENDIF
      5  18c2		       00		      .byte.b	0
      0  18c3					      EVAL8	0
      1  18c3				  -	      IF	(0 > 127) || (0 < -128)
      2  18c3				  -	      ECHO	"Erroneous position value", 0
      3  18c3				  -	      ERR
      4  18c3					      ENDIF
      5  18c3		       00		      .byte.b	0
      0  18c4					      PVAL	-10, 10, 10, 10, 10, 10, 10, -10
      0  18c4					      EVAL8	-10
      1  18c4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18c4				  -	      ECHO	"Erroneous position value", -10
      3  18c4				  -	      ERR
      4  18c4					      ENDIF
      5  18c4		       f6		      .byte.b	-10
      0  18c5					      EVAL8	10
      1  18c5				  -	      IF	(10 > 127) || (10 < -128)
      2  18c5				  -	      ECHO	"Erroneous position value", 10
      3  18c5				  -	      ERR
      4  18c5					      ENDIF
      5  18c5		       0a		      .byte.b	10
      0  18c6					      EVAL8	10
      1  18c6				  -	      IF	(10 > 127) || (10 < -128)
      2  18c6				  -	      ECHO	"Erroneous position value", 10
      3  18c6				  -	      ERR
      4  18c6					      ENDIF
      5  18c6		       0a		      .byte.b	10
      0  18c7					      EVAL8	10
      1  18c7				  -	      IF	(10 > 127) || (10 < -128)
      2  18c7				  -	      ECHO	"Erroneous position value", 10
      3  18c7				  -	      ERR
      4  18c7					      ENDIF
      5  18c7		       0a		      .byte.b	10
      0  18c8					      EVAL8	10
      1  18c8				  -	      IF	(10 > 127) || (10 < -128)
      2  18c8				  -	      ECHO	"Erroneous position value", 10
      3  18c8				  -	      ERR
      4  18c8					      ENDIF
      5  18c8		       0a		      .byte.b	10
      0  18c9					      EVAL8	10
      1  18c9				  -	      IF	(10 > 127) || (10 < -128)
      2  18c9				  -	      ECHO	"Erroneous position value", 10
      3  18c9				  -	      ERR
      4  18c9					      ENDIF
      5  18c9		       0a		      .byte.b	10
      0  18ca					      EVAL8	10
      1  18ca				  -	      IF	(10 > 127) || (10 < -128)
      2  18ca				  -	      ECHO	"Erroneous position value", 10
      3  18ca				  -	      ERR
      4  18ca					      ENDIF
      5  18ca		       0a		      .byte.b	10
      0  18cb					      EVAL8	-10
      1  18cb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18cb				  -	      ECHO	"Erroneous position value", -10
      3  18cb				  -	      ERR
      4  18cb					      ENDIF
      5  18cb		       f6		      .byte.b	-10
      0  18cc					      EVAL8	0
      1  18cc				  -	      IF	(0 > 127) || (0 < -128)
      2  18cc				  -	      ECHO	"Erroneous position value", 0
      3  18cc				  -	      ERR
      4  18cc					      ENDIF
      5  18cc		       00		      .byte.b	0
      0  18cd					      EVAL8	0
      1  18cd				  -	      IF	(0 > 127) || (0 < -128)
      2  18cd				  -	      ECHO	"Erroneous position value", 0
      3  18cd				  -	      ERR
      4  18cd					      ENDIF
      5  18cd		       00		      .byte.b	0
      0  18ce					      PVAL	-10, 0, 10, 20, 20, 10, 0, -10
      0  18ce					      EVAL8	-10
      1  18ce				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18ce				  -	      ECHO	"Erroneous position value", -10
      3  18ce				  -	      ERR
      4  18ce					      ENDIF
      5  18ce		       f6		      .byte.b	-10
      0  18cf					      EVAL8	0
      1  18cf				  -	      IF	(0 > 127) || (0 < -128)
      2  18cf				  -	      ECHO	"Erroneous position value", 0
      3  18cf				  -	      ERR
      4  18cf					      ENDIF
      5  18cf		       00		      .byte.b	0
      0  18d0					      EVAL8	10
      1  18d0				  -	      IF	(10 > 127) || (10 < -128)
      2  18d0				  -	      ECHO	"Erroneous position value", 10
      3  18d0				  -	      ERR
      4  18d0					      ENDIF
      5  18d0		       0a		      .byte.b	10
      0  18d1					      EVAL8	20
      1  18d1				  -	      IF	(20 > 127) || (20 < -128)
      2  18d1				  -	      ECHO	"Erroneous position value", 20
      3  18d1				  -	      ERR
      4  18d1					      ENDIF
      5  18d1		       14		      .byte.b	20
      0  18d2					      EVAL8	20
      1  18d2				  -	      IF	(20 > 127) || (20 < -128)
      2  18d2				  -	      ECHO	"Erroneous position value", 20
      3  18d2				  -	      ERR
      4  18d2					      ENDIF
      5  18d2		       14		      .byte.b	20
      0  18d3					      EVAL8	10
      1  18d3				  -	      IF	(10 > 127) || (10 < -128)
      2  18d3				  -	      ECHO	"Erroneous position value", 10
      3  18d3				  -	      ERR
      4  18d3					      ENDIF
      5  18d3		       0a		      .byte.b	10
      0  18d4					      EVAL8	0
      1  18d4				  -	      IF	(0 > 127) || (0 < -128)
      2  18d4				  -	      ECHO	"Erroneous position value", 0
      3  18d4				  -	      ERR
      4  18d4					      ENDIF
      5  18d4		       00		      .byte.b	0
      0  18d5					      EVAL8	-10
      1  18d5				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18d5				  -	      ECHO	"Erroneous position value", -10
      3  18d5				  -	      ERR
      4  18d5					      ENDIF
      5  18d5		       f6		      .byte.b	-10
      0  18d6					      EVAL8	0
      1  18d6				  -	      IF	(0 > 127) || (0 < -128)
      2  18d6				  -	      ECHO	"Erroneous position value", 0
      3  18d6				  -	      ERR
      4  18d6					      ENDIF
      5  18d6		       00		      .byte.b	0
      0  18d7					      EVAL8	0
      1  18d7				  -	      IF	(0 > 127) || (0 < -128)
      2  18d7				  -	      ECHO	"Erroneous position value", 0
      3  18d7				  -	      ERR
      4  18d7					      ENDIF
      5  18d7		       00		      .byte.b	0
      0  18d8					      PVAL	-10, 5, 5, 20, 20, 5, 5, -10
      0  18d8					      EVAL8	-10
      1  18d8				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18d8				  -	      ECHO	"Erroneous position value", -10
      3  18d8				  -	      ERR
      4  18d8					      ENDIF
      5  18d8		       f6		      .byte.b	-10
      0  18d9					      EVAL8	5
      1  18d9				  -	      IF	(5 > 127) || (5 < -128)
      2  18d9				  -	      ECHO	"Erroneous position value", 5
      3  18d9				  -	      ERR
      4  18d9					      ENDIF
      5  18d9		       05		      .byte.b	5
      0  18da					      EVAL8	5
      1  18da				  -	      IF	(5 > 127) || (5 < -128)
      2  18da				  -	      ECHO	"Erroneous position value", 5
      3  18da				  -	      ERR
      4  18da					      ENDIF
      5  18da		       05		      .byte.b	5
      0  18db					      EVAL8	20
      1  18db				  -	      IF	(20 > 127) || (20 < -128)
      2  18db				  -	      ECHO	"Erroneous position value", 20
      3  18db				  -	      ERR
      4  18db					      ENDIF
      5  18db		       14		      .byte.b	20
      0  18dc					      EVAL8	20
      1  18dc				  -	      IF	(20 > 127) || (20 < -128)
      2  18dc				  -	      ECHO	"Erroneous position value", 20
      3  18dc				  -	      ERR
      4  18dc					      ENDIF
      5  18dc		       14		      .byte.b	20
      0  18dd					      EVAL8	5
      1  18dd				  -	      IF	(5 > 127) || (5 < -128)
      2  18dd				  -	      ECHO	"Erroneous position value", 5
      3  18dd				  -	      ERR
      4  18dd					      ENDIF
      5  18dd		       05		      .byte.b	5
      0  18de					      EVAL8	5
      1  18de				  -	      IF	(5 > 127) || (5 < -128)
      2  18de				  -	      ECHO	"Erroneous position value", 5
      3  18de				  -	      ERR
      4  18de					      ENDIF
      5  18de		       05		      .byte.b	5
      0  18df					      EVAL8	-10
      1  18df				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18df				  -	      ECHO	"Erroneous position value", -10
      3  18df				  -	      ERR
      4  18df					      ENDIF
      5  18df		       f6		      .byte.b	-10
      0  18e0					      EVAL8	0
      1  18e0				  -	      IF	(0 > 127) || (0 < -128)
      2  18e0				  -	      ECHO	"Erroneous position value", 0
      3  18e0				  -	      ERR
      4  18e0					      ENDIF
      5  18e0		       00		      .byte.b	0
      0  18e1					      EVAL8	0
      1  18e1				  -	      IF	(0 > 127) || (0 < -128)
      2  18e1				  -	      ECHO	"Erroneous position value", 0
      3  18e1				  -	      ERR
      4  18e1					      ENDIF
      5  18e1		       00		      .byte.b	0
      0  18e2					      PVAL	-10, 0, 5, 10, 10, 5, 0, -10
      0  18e2					      EVAL8	-10
      1  18e2				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18e2				  -	      ECHO	"Erroneous position value", -10
      3  18e2				  -	      ERR
      4  18e2					      ENDIF
      5  18e2		       f6		      .byte.b	-10
      0  18e3					      EVAL8	0
      1  18e3				  -	      IF	(0 > 127) || (0 < -128)
      2  18e3				  -	      ECHO	"Erroneous position value", 0
      3  18e3				  -	      ERR
      4  18e3					      ENDIF
      5  18e3		       00		      .byte.b	0
      0  18e4					      EVAL8	5
      1  18e4				  -	      IF	(5 > 127) || (5 < -128)
      2  18e4				  -	      ECHO	"Erroneous position value", 5
      3  18e4				  -	      ERR
      4  18e4					      ENDIF
      5  18e4		       05		      .byte.b	5
      0  18e5					      EVAL8	10
      1  18e5				  -	      IF	(10 > 127) || (10 < -128)
      2  18e5				  -	      ECHO	"Erroneous position value", 10
      3  18e5				  -	      ERR
      4  18e5					      ENDIF
      5  18e5		       0a		      .byte.b	10
      0  18e6					      EVAL8	10
      1  18e6				  -	      IF	(10 > 127) || (10 < -128)
      2  18e6				  -	      ECHO	"Erroneous position value", 10
      3  18e6				  -	      ERR
      4  18e6					      ENDIF
      5  18e6		       0a		      .byte.b	10
      0  18e7					      EVAL8	5
      1  18e7				  -	      IF	(5 > 127) || (5 < -128)
      2  18e7				  -	      ECHO	"Erroneous position value", 5
      3  18e7				  -	      ERR
      4  18e7					      ENDIF
      5  18e7		       05		      .byte.b	5
      0  18e8					      EVAL8	0
      1  18e8				  -	      IF	(0 > 127) || (0 < -128)
      2  18e8				  -	      ECHO	"Erroneous position value", 0
      3  18e8				  -	      ERR
      4  18e8					      ENDIF
      5  18e8		       00		      .byte.b	0
      0  18e9					      EVAL8	-10
      1  18e9				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18e9				  -	      ECHO	"Erroneous position value", -10
      3  18e9				  -	      ERR
      4  18e9					      ENDIF
      5  18e9		       f6		      .byte.b	-10
      0  18ea					      EVAL8	0
      1  18ea				  -	      IF	(0 > 127) || (0 < -128)
      2  18ea				  -	      ECHO	"Erroneous position value", 0
      3  18ea				  -	      ERR
      4  18ea					      ENDIF
      5  18ea		       00		      .byte.b	0
      0  18eb					      EVAL8	0
      1  18eb				  -	      IF	(0 > 127) || (0 < -128)
      2  18eb				  -	      ECHO	"Erroneous position value", 0
      3  18eb				  -	      ERR
      4  18eb					      ENDIF
      5  18eb		       00		      .byte.b	0
      0  18ec					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      0  18ec					      EVAL8	-10
      1  18ec				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18ec				  -	      ECHO	"Erroneous position value", -10
      3  18ec				  -	      ERR
      4  18ec					      ENDIF
      5  18ec		       f6		      .byte.b	-10
      0  18ed					      EVAL8	0
      1  18ed				  -	      IF	(0 > 127) || (0 < -128)
      2  18ed				  -	      ECHO	"Erroneous position value", 0
      3  18ed				  -	      ERR
      4  18ed					      ENDIF
      5  18ed		       00		      .byte.b	0
      0  18ee					      EVAL8	0
      1  18ee				  -	      IF	(0 > 127) || (0 < -128)
      2  18ee				  -	      ECHO	"Erroneous position value", 0
      3  18ee				  -	      ERR
      4  18ee					      ENDIF
      5  18ee		       00		      .byte.b	0
      0  18ef					      EVAL8	0
      1  18ef				  -	      IF	(0 > 127) || (0 < -128)
      2  18ef				  -	      ECHO	"Erroneous position value", 0
      3  18ef				  -	      ERR
      4  18ef					      ENDIF
      5  18ef		       00		      .byte.b	0
      0  18f0					      EVAL8	0
      1  18f0				  -	      IF	(0 > 127) || (0 < -128)
      2  18f0				  -	      ECHO	"Erroneous position value", 0
      3  18f0				  -	      ERR
      4  18f0					      ENDIF
      5  18f0		       00		      .byte.b	0
      0  18f1					      EVAL8	0
      1  18f1				  -	      IF	(0 > 127) || (0 < -128)
      2  18f1				  -	      ECHO	"Erroneous position value", 0
      3  18f1				  -	      ERR
      4  18f1					      ENDIF
      5  18f1		       00		      .byte.b	0
      0  18f2					      EVAL8	0
      1  18f2				  -	      IF	(0 > 127) || (0 < -128)
      2  18f2				  -	      ECHO	"Erroneous position value", 0
      3  18f2				  -	      ERR
      4  18f2					      ENDIF
      5  18f2		       00		      .byte.b	0
      0  18f3					      EVAL8	-10
      1  18f3				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18f3				  -	      ECHO	"Erroneous position value", -10
      3  18f3				  -	      ERR
      4  18f3					      ENDIF
      5  18f3		       f6		      .byte.b	-10
      0  18f4					      EVAL8	0
      1  18f4				  -	      IF	(0 > 127) || (0 < -128)
      2  18f4				  -	      ECHO	"Erroneous position value", 0
      3  18f4				  -	      ERR
      4  18f4					      ENDIF
      5  18f4		       00		      .byte.b	0
      0  18f5					      EVAL8	0
      1  18f5				  -	      IF	(0 > 127) || (0 < -128)
      2  18f5				  -	      ECHO	"Erroneous position value", 0
      3  18f5				  -	      ERR
      4  18f5					      ENDIF
      5  18f5		       00		      .byte.b	0
      0  18f6					      PVAL	-20, -10, -10, -10, -10, -10, -10, -20
      0  18f6					      EVAL8	-20
      1  18f6				  -	      IF	(-20 > 127) || (-20 < -128)
      2  18f6				  -	      ECHO	"Erroneous position value", -20
      3  18f6				  -	      ERR
      4  18f6					      ENDIF
      5  18f6		       ec		      .byte.b	-20
      0  18f7					      EVAL8	-10
      1  18f7				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18f7				  -	      ECHO	"Erroneous position value", -10
      3  18f7				  -	      ERR
      4  18f7					      ENDIF
      5  18f7		       f6		      .byte.b	-10
      0  18f8					      EVAL8	-10
      1  18f8				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18f8				  -	      ECHO	"Erroneous position value", -10
      3  18f8				  -	      ERR
      4  18f8					      ENDIF
      5  18f8		       f6		      .byte.b	-10
      0  18f9					      EVAL8	-10
      1  18f9				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18f9				  -	      ECHO	"Erroneous position value", -10
      3  18f9				  -	      ERR
      4  18f9					      ENDIF
      5  18f9		       f6		      .byte.b	-10
      0  18fa					      EVAL8	-10
      1  18fa				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18fa				  -	      ECHO	"Erroneous position value", -10
      3  18fa				  -	      ERR
      4  18fa					      ENDIF
      5  18fa		       f6		      .byte.b	-10
      0  18fb					      EVAL8	-10
      1  18fb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18fb				  -	      ECHO	"Erroneous position value", -10
      3  18fb				  -	      ERR
      4  18fb					      ENDIF
      5  18fb		       f6		      .byte.b	-10
      0  18fc					      EVAL8	-10
      1  18fc				  -	      IF	(-10 > 127) || (-10 < -128)
      2  18fc				  -	      ECHO	"Erroneous position value", -10
      3  18fc				  -	      ERR
      4  18fc					      ENDIF
      5  18fc		       f6		      .byte.b	-10
      0  18fd					      EVAL8	-20
      1  18fd				  -	      IF	(-20 > 127) || (-20 < -128)
      2  18fd				  -	      ECHO	"Erroneous position value", -20
      3  18fd				  -	      ERR
      4  18fd					      ENDIF
      5  18fd		       ec		      .byte.b	-20
      0  18fe					      EVAL8	0
      1  18fe				  -	      IF	(0 > 127) || (0 < -128)
      2  18fe				  -	      ECHO	"Erroneous position value", 0
      3  18fe				  -	      ERR
      4  18fe					      ENDIF
      5  18fe		       00		      .byte.b	0
      0  18ff					      EVAL8	0
      1  18ff				  -	      IF	(0 > 127) || (0 < -128)
      2  18ff				  -	      ECHO	"Erroneous position value", 0
      3  18ff				  -	      ERR
      4  18ff					      ENDIF
      5  18ff		       00		      .byte.b	0
    131  1900
    132  1900
    133  1900							;---------------------------------------------------------------------------------------------------
    134  1900
    135  1900				   PositionalValue_ROOK
    136  1900
      0  1900					      PVAL	-25, -20, 10, 55, 55, 50, -20, -25
      0  1900					      EVAL8	-25
      1  1900				  -	      IF	(-25 > 127) || (-25 < -128)
      2  1900				  -	      ECHO	"Erroneous position value", -25
      3  1900				  -	      ERR
      4  1900					      ENDIF
      5  1900		       e7		      .byte.b	-25
      0  1901					      EVAL8	-20
      1  1901				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1901				  -	      ECHO	"Erroneous position value", -20
      3  1901				  -	      ERR
      4  1901					      ENDIF
      5  1901		       ec		      .byte.b	-20
      0  1902					      EVAL8	10
      1  1902				  -	      IF	(10 > 127) || (10 < -128)
      2  1902				  -	      ECHO	"Erroneous position value", 10
      3  1902				  -	      ERR
      4  1902					      ENDIF
      5  1902		       0a		      .byte.b	10
      0  1903					      EVAL8	55
      1  1903				  -	      IF	(55 > 127) || (55 < -128)
      2  1903				  -	      ECHO	"Erroneous position value", 55
      3  1903				  -	      ERR
      4  1903					      ENDIF
      5  1903		       37		      .byte.b	55
      0  1904					      EVAL8	55
      1  1904				  -	      IF	(55 > 127) || (55 < -128)
      2  1904				  -	      ECHO	"Erroneous position value", 55
      3  1904				  -	      ERR
      4  1904					      ENDIF
      5  1904		       37		      .byte.b	55
      0  1905					      EVAL8	50
      1  1905				  -	      IF	(50 > 127) || (50 < -128)
      2  1905				  -	      ECHO	"Erroneous position value", 50
      3  1905				  -	      ERR
      4  1905					      ENDIF
      5  1905		       32		      .byte.b	50
      0  1906					      EVAL8	-20
      1  1906				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1906				  -	      ECHO	"Erroneous position value", -20
      3  1906				  -	      ERR
      4  1906					      ENDIF
      5  1906		       ec		      .byte.b	-20
      0  1907					      EVAL8	-25
      1  1907				  -	      IF	(-25 > 127) || (-25 < -128)
      2  1907				  -	      ECHO	"Erroneous position value", -25
      3  1907				  -	      ERR
      4  1907					      ENDIF
      5  1907		       e7		      .byte.b	-25
      0  1908					      EVAL8	0
      1  1908				  -	      IF	(0 > 127) || (0 < -128)
      2  1908				  -	      ECHO	"Erroneous position value", 0
      3  1908				  -	      ERR
      4  1908					      ENDIF
      5  1908		       00		      .byte.b	0
      0  1909					      EVAL8	0
      1  1909				  -	      IF	(0 > 127) || (0 < -128)
      2  1909				  -	      ECHO	"Erroneous position value", 0
      3  1909				  -	      ERR
      4  1909					      ENDIF
      5  1909		       00		      .byte.b	0
      0  190a					      PVAL	-120, 0, 0, 0, 0, 0, 0, -128
      0  190a					      EVAL8	-120
      1  190a				  -	      IF	(-120 > 127) || (-120 < -128)
      2  190a				  -	      ECHO	"Erroneous position value", -120
      3  190a				  -	      ERR
      4  190a					      ENDIF
      5  190a		       88		      .byte.b	-120
      0  190b					      EVAL8	0
      1  190b				  -	      IF	(0 > 127) || (0 < -128)
      2  190b				  -	      ECHO	"Erroneous position value", 0
      3  190b				  -	      ERR
      4  190b					      ENDIF
      5  190b		       00		      .byte.b	0
      0  190c					      EVAL8	0
      1  190c				  -	      IF	(0 > 127) || (0 < -128)
      2  190c				  -	      ECHO	"Erroneous position value", 0
      3  190c				  -	      ERR
      4  190c					      ENDIF
      5  190c		       00		      .byte.b	0
      0  190d					      EVAL8	0
      1  190d				  -	      IF	(0 > 127) || (0 < -128)
      2  190d				  -	      ECHO	"Erroneous position value", 0
      3  190d				  -	      ERR
      4  190d					      ENDIF
      5  190d		       00		      .byte.b	0
      0  190e					      EVAL8	0
      1  190e				  -	      IF	(0 > 127) || (0 < -128)
      2  190e				  -	      ECHO	"Erroneous position value", 0
      3  190e				  -	      ERR
      4  190e					      ENDIF
      5  190e		       00		      .byte.b	0
      0  190f					      EVAL8	0
      1  190f				  -	      IF	(0 > 127) || (0 < -128)
      2  190f				  -	      ECHO	"Erroneous position value", 0
      3  190f				  -	      ERR
      4  190f					      ENDIF
      5  190f		       00		      .byte.b	0
      0  1910					      EVAL8	0
      1  1910				  -	      IF	(0 > 127) || (0 < -128)
      2  1910				  -	      ECHO	"Erroneous position value", 0
      3  1910				  -	      ERR
      4  1910					      ENDIF
      5  1910		       00		      .byte.b	0
      0  1911					      EVAL8	-128
      1  1911				  -	      IF	(-128 > 127) || (-128 < -128)
      2  1911				  -	      ECHO	"Erroneous position value", -128
      3  1911				  -	      ERR
      4  1911					      ENDIF
      5  1911		       80		      .byte.b	-128
      0  1912					      EVAL8	0
      1  1912				  -	      IF	(0 > 127) || (0 < -128)
      2  1912				  -	      ECHO	"Erroneous position value", 0
      3  1912				  -	      ERR
      4  1912					      ENDIF
      5  1912		       00		      .byte.b	0
      0  1913					      EVAL8	0
      1  1913				  -	      IF	(0 > 127) || (0 < -128)
      2  1913				  -	      ECHO	"Erroneous position value", 0
      3  1913				  -	      ERR
      4  1913					      ENDIF
      5  1913		       00		      .byte.b	0
      0  1914					      PVAL	-128, 0, 0, 0, 0, 0, 0, -100
      0  1914					      EVAL8	-128
      1  1914				  -	      IF	(-128 > 127) || (-128 < -128)
      2  1914				  -	      ECHO	"Erroneous position value", -128
      3  1914				  -	      ERR
      4  1914					      ENDIF
      5  1914		       80		      .byte.b	-128
      0  1915					      EVAL8	0
      1  1915				  -	      IF	(0 > 127) || (0 < -128)
      2  1915				  -	      ECHO	"Erroneous position value", 0
      3  1915				  -	      ERR
      4  1915					      ENDIF
      5  1915		       00		      .byte.b	0
      0  1916					      EVAL8	0
      1  1916				  -	      IF	(0 > 127) || (0 < -128)
      2  1916				  -	      ECHO	"Erroneous position value", 0
      3  1916				  -	      ERR
      4  1916					      ENDIF
      5  1916		       00		      .byte.b	0
      0  1917					      EVAL8	0
      1  1917				  -	      IF	(0 > 127) || (0 < -128)
      2  1917				  -	      ECHO	"Erroneous position value", 0
      3  1917				  -	      ERR
      4  1917					      ENDIF
      5  1917		       00		      .byte.b	0
      0  1918					      EVAL8	0
      1  1918				  -	      IF	(0 > 127) || (0 < -128)
      2  1918				  -	      ECHO	"Erroneous position value", 0
      3  1918				  -	      ERR
      4  1918					      ENDIF
      5  1918		       00		      .byte.b	0
      0  1919					      EVAL8	0
      1  1919				  -	      IF	(0 > 127) || (0 < -128)
      2  1919				  -	      ECHO	"Erroneous position value", 0
      3  1919				  -	      ERR
      4  1919					      ENDIF
      5  1919		       00		      .byte.b	0
      0  191a					      EVAL8	0
      1  191a				  -	      IF	(0 > 127) || (0 < -128)
      2  191a				  -	      ECHO	"Erroneous position value", 0
      3  191a				  -	      ERR
      4  191a					      ENDIF
      5  191a		       00		      .byte.b	0
      0  191b					      EVAL8	-100
      1  191b				  -	      IF	(-100 > 127) || (-100 < -128)
      2  191b				  -	      ECHO	"Erroneous position value", -100
      3  191b				  -	      ERR
      4  191b					      ENDIF
      5  191b		       9c		      .byte.b	-100
      0  191c					      EVAL8	0
      1  191c				  -	      IF	(0 > 127) || (0 < -128)
      2  191c				  -	      ECHO	"Erroneous position value", 0
      3  191c				  -	      ERR
      4  191c					      ENDIF
      5  191c		       00		      .byte.b	0
      0  191d					      EVAL8	0
      1  191d				  -	      IF	(0 > 127) || (0 < -128)
      2  191d				  -	      ECHO	"Erroneous position value", 0
      3  191d				  -	      ERR
      4  191d					      ENDIF
      5  191d		       00		      .byte.b	0
      0  191e					      PVAL	-100, 0, 0, 0, 0, 0, 0, -100
      0  191e					      EVAL8	-100
      1  191e				  -	      IF	(-100 > 127) || (-100 < -128)
      2  191e				  -	      ECHO	"Erroneous position value", -100
      3  191e				  -	      ERR
      4  191e					      ENDIF
      5  191e		       9c		      .byte.b	-100
      0  191f					      EVAL8	0
      1  191f				  -	      IF	(0 > 127) || (0 < -128)
      2  191f				  -	      ECHO	"Erroneous position value", 0
      3  191f				  -	      ERR
      4  191f					      ENDIF
      5  191f		       00		      .byte.b	0
      0  1920					      EVAL8	0
      1  1920				  -	      IF	(0 > 127) || (0 < -128)
      2  1920				  -	      ECHO	"Erroneous position value", 0
      3  1920				  -	      ERR
      4  1920					      ENDIF
      5  1920		       00		      .byte.b	0
      0  1921					      EVAL8	0
      1  1921				  -	      IF	(0 > 127) || (0 < -128)
      2  1921				  -	      ECHO	"Erroneous position value", 0
      3  1921				  -	      ERR
      4  1921					      ENDIF
      5  1921		       00		      .byte.b	0
      0  1922					      EVAL8	0
      1  1922				  -	      IF	(0 > 127) || (0 < -128)
      2  1922				  -	      ECHO	"Erroneous position value", 0
      3  1922				  -	      ERR
      4  1922					      ENDIF
      5  1922		       00		      .byte.b	0
      0  1923					      EVAL8	0
      1  1923				  -	      IF	(0 > 127) || (0 < -128)
      2  1923				  -	      ECHO	"Erroneous position value", 0
      3  1923				  -	      ERR
      4  1923					      ENDIF
      5  1923		       00		      .byte.b	0
      0  1924					      EVAL8	0
      1  1924				  -	      IF	(0 > 127) || (0 < -128)
      2  1924				  -	      ECHO	"Erroneous position value", 0
      3  1924				  -	      ERR
      4  1924					      ENDIF
      5  1924		       00		      .byte.b	0
      0  1925					      EVAL8	-100
      1  1925				  -	      IF	(-100 > 127) || (-100 < -128)
      2  1925				  -	      ECHO	"Erroneous position value", -100
      3  1925				  -	      ERR
      4  1925					      ENDIF
      5  1925		       9c		      .byte.b	-100
      0  1926					      EVAL8	0
      1  1926				  -	      IF	(0 > 127) || (0 < -128)
      2  1926				  -	      ECHO	"Erroneous position value", 0
      3  1926				  -	      ERR
      4  1926					      ENDIF
      5  1926		       00		      .byte.b	0
      0  1927					      EVAL8	0
      1  1927				  -	      IF	(0 > 127) || (0 < -128)
      2  1927				  -	      ECHO	"Erroneous position value", 0
      3  1927				  -	      ERR
      4  1927					      ENDIF
      5  1927		       00		      .byte.b	0
      0  1928					      PVAL	-50, 0, 0, 0, 0, 0, 0, -50
      0  1928					      EVAL8	-50
      1  1928				  -	      IF	(-50 > 127) || (-50 < -128)
      2  1928				  -	      ECHO	"Erroneous position value", -50
      3  1928				  -	      ERR
      4  1928					      ENDIF
      5  1928		       ce		      .byte.b	-50
      0  1929					      EVAL8	0
      1  1929				  -	      IF	(0 > 127) || (0 < -128)
      2  1929				  -	      ECHO	"Erroneous position value", 0
      3  1929				  -	      ERR
      4  1929					      ENDIF
      5  1929		       00		      .byte.b	0
      0  192a					      EVAL8	0
      1  192a				  -	      IF	(0 > 127) || (0 < -128)
      2  192a				  -	      ECHO	"Erroneous position value", 0
      3  192a				  -	      ERR
      4  192a					      ENDIF
      5  192a		       00		      .byte.b	0
      0  192b					      EVAL8	0
      1  192b				  -	      IF	(0 > 127) || (0 < -128)
      2  192b				  -	      ECHO	"Erroneous position value", 0
      3  192b				  -	      ERR
      4  192b					      ENDIF
      5  192b		       00		      .byte.b	0
      0  192c					      EVAL8	0
      1  192c				  -	      IF	(0 > 127) || (0 < -128)
      2  192c				  -	      ECHO	"Erroneous position value", 0
      3  192c				  -	      ERR
      4  192c					      ENDIF
      5  192c		       00		      .byte.b	0
      0  192d					      EVAL8	0
      1  192d				  -	      IF	(0 > 127) || (0 < -128)
      2  192d				  -	      ECHO	"Erroneous position value", 0
      3  192d				  -	      ERR
      4  192d					      ENDIF
      5  192d		       00		      .byte.b	0
      0  192e					      EVAL8	0
      1  192e				  -	      IF	(0 > 127) || (0 < -128)
      2  192e				  -	      ECHO	"Erroneous position value", 0
      3  192e				  -	      ERR
      4  192e					      ENDIF
      5  192e		       00		      .byte.b	0
      0  192f					      EVAL8	-50
      1  192f				  -	      IF	(-50 > 127) || (-50 < -128)
      2  192f				  -	      ECHO	"Erroneous position value", -50
      3  192f				  -	      ERR
      4  192f					      ENDIF
      5  192f		       ce		      .byte.b	-50
      0  1930					      EVAL8	0
      1  1930				  -	      IF	(0 > 127) || (0 < -128)
      2  1930				  -	      ECHO	"Erroneous position value", 0
      3  1930				  -	      ERR
      4  1930					      ENDIF
      5  1930		       00		      .byte.b	0
      0  1931					      EVAL8	0
      1  1931				  -	      IF	(0 > 127) || (0 < -128)
      2  1931				  -	      ECHO	"Erroneous position value", 0
      3  1931				  -	      ERR
      4  1931					      ENDIF
      5  1931		       00		      .byte.b	0
      0  1932					      PVAL	-5, 0, 30, 30, 30, 30, 0, -5
      0  1932					      EVAL8	-5
      1  1932				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1932				  -	      ECHO	"Erroneous position value", -5
      3  1932				  -	      ERR
      4  1932					      ENDIF
      5  1932		       fb		      .byte.b	-5
      0  1933					      EVAL8	0
      1  1933				  -	      IF	(0 > 127) || (0 < -128)
      2  1933				  -	      ECHO	"Erroneous position value", 0
      3  1933				  -	      ERR
      4  1933					      ENDIF
      5  1933		       00		      .byte.b	0
      0  1934					      EVAL8	30
      1  1934				  -	      IF	(30 > 127) || (30 < -128)
      2  1934				  -	      ECHO	"Erroneous position value", 30
      3  1934				  -	      ERR
      4  1934					      ENDIF
      5  1934		       1e		      .byte.b	30
      0  1935					      EVAL8	30
      1  1935				  -	      IF	(30 > 127) || (30 < -128)
      2  1935				  -	      ECHO	"Erroneous position value", 30
      3  1935				  -	      ERR
      4  1935					      ENDIF
      5  1935		       1e		      .byte.b	30
      0  1936					      EVAL8	30
      1  1936				  -	      IF	(30 > 127) || (30 < -128)
      2  1936				  -	      ECHO	"Erroneous position value", 30
      3  1936				  -	      ERR
      4  1936					      ENDIF
      5  1936		       1e		      .byte.b	30
      0  1937					      EVAL8	30
      1  1937				  -	      IF	(30 > 127) || (30 < -128)
      2  1937				  -	      ECHO	"Erroneous position value", 30
      3  1937				  -	      ERR
      4  1937					      ENDIF
      5  1937		       1e		      .byte.b	30
      0  1938					      EVAL8	0
      1  1938				  -	      IF	(0 > 127) || (0 < -128)
      2  1938				  -	      ECHO	"Erroneous position value", 0
      3  1938				  -	      ERR
      4  1938					      ENDIF
      5  1938		       00		      .byte.b	0
      0  1939					      EVAL8	-5
      1  1939				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1939				  -	      ECHO	"Erroneous position value", -5
      3  1939				  -	      ERR
      4  1939					      ENDIF
      5  1939		       fb		      .byte.b	-5
      0  193a					      EVAL8	0
      1  193a				  -	      IF	(0 > 127) || (0 < -128)
      2  193a				  -	      ECHO	"Erroneous position value", 0
      3  193a				  -	      ERR
      4  193a					      ENDIF
      5  193a		       00		      .byte.b	0
      0  193b					      EVAL8	0
      1  193b				  -	      IF	(0 > 127) || (0 < -128)
      2  193b				  -	      ECHO	"Erroneous position value", 0
      3  193b				  -	      ERR
      4  193b					      ENDIF
      5  193b		       00		      .byte.b	0
      0  193c					      PVAL	55, 80, 90, 90, 90, 90, 80, 55
      0  193c					      EVAL8	55
      1  193c				  -	      IF	(55 > 127) || (55 < -128)
      2  193c				  -	      ECHO	"Erroneous position value", 55
      3  193c				  -	      ERR
      4  193c					      ENDIF
      5  193c		       37		      .byte.b	55
      0  193d					      EVAL8	80
      1  193d				  -	      IF	(80 > 127) || (80 < -128)
      2  193d				  -	      ECHO	"Erroneous position value", 80
      3  193d				  -	      ERR
      4  193d					      ENDIF
      5  193d		       50		      .byte.b	80
      0  193e					      EVAL8	90
      1  193e				  -	      IF	(90 > 127) || (90 < -128)
      2  193e				  -	      ECHO	"Erroneous position value", 90
      3  193e				  -	      ERR
      4  193e					      ENDIF
      5  193e		       5a		      .byte.b	90
      0  193f					      EVAL8	90
      1  193f				  -	      IF	(90 > 127) || (90 < -128)
      2  193f				  -	      ECHO	"Erroneous position value", 90
      3  193f				  -	      ERR
      4  193f					      ENDIF
      5  193f		       5a		      .byte.b	90
      0  1940					      EVAL8	90
      1  1940				  -	      IF	(90 > 127) || (90 < -128)
      2  1940				  -	      ECHO	"Erroneous position value", 90
      3  1940				  -	      ERR
      4  1940					      ENDIF
      5  1940		       5a		      .byte.b	90
      0  1941					      EVAL8	90
      1  1941				  -	      IF	(90 > 127) || (90 < -128)
      2  1941				  -	      ECHO	"Erroneous position value", 90
      3  1941				  -	      ERR
      4  1941					      ENDIF
      5  1941		       5a		      .byte.b	90
      0  1942					      EVAL8	80
      1  1942				  -	      IF	(80 > 127) || (80 < -128)
      2  1942				  -	      ECHO	"Erroneous position value", 80
      3  1942				  -	      ERR
      4  1942					      ENDIF
      5  1942		       50		      .byte.b	80
      0  1943					      EVAL8	55
      1  1943				  -	      IF	(55 > 127) || (55 < -128)
      2  1943				  -	      ECHO	"Erroneous position value", 55
      3  1943				  -	      ERR
      4  1943					      ENDIF
      5  1943		       37		      .byte.b	55
      0  1944					      EVAL8	0
      1  1944				  -	      IF	(0 > 127) || (0 < -128)
      2  1944				  -	      ECHO	"Erroneous position value", 0
      3  1944				  -	      ERR
      4  1944					      ENDIF
      5  1944		       00		      .byte.b	0
      0  1945					      EVAL8	0
      1  1945				  -	      IF	(0 > 127) || (0 < -128)
      2  1945				  -	      ECHO	"Erroneous position value", 0
      3  1945				  -	      ERR
      4  1945					      ENDIF
      5  1945		       00		      .byte.b	0
      0  1946					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  1946					      EVAL8	0
      1  1946				  -	      IF	(0 > 127) || (0 < -128)
      2  1946				  -	      ECHO	"Erroneous position value", 0
      3  1946				  -	      ERR
      4  1946					      ENDIF
      5  1946		       00		      .byte.b	0
      0  1947					      EVAL8	0
      1  1947				  -	      IF	(0 > 127) || (0 < -128)
      2  1947				  -	      ECHO	"Erroneous position value", 0
      3  1947				  -	      ERR
      4  1947					      ENDIF
      5  1947		       00		      .byte.b	0
      0  1948					      EVAL8	0
      1  1948				  -	      IF	(0 > 127) || (0 < -128)
      2  1948				  -	      ECHO	"Erroneous position value", 0
      3  1948				  -	      ERR
      4  1948					      ENDIF
      5  1948		       00		      .byte.b	0
      0  1949					      EVAL8	0
      1  1949				  -	      IF	(0 > 127) || (0 < -128)
      2  1949				  -	      ECHO	"Erroneous position value", 0
      3  1949				  -	      ERR
      4  1949					      ENDIF
      5  1949		       00		      .byte.b	0
      0  194a					      EVAL8	0
      1  194a				  -	      IF	(0 > 127) || (0 < -128)
      2  194a				  -	      ECHO	"Erroneous position value", 0
      3  194a				  -	      ERR
      4  194a					      ENDIF
      5  194a		       00		      .byte.b	0
      0  194b					      EVAL8	0
      1  194b				  -	      IF	(0 > 127) || (0 < -128)
      2  194b				  -	      ECHO	"Erroneous position value", 0
      3  194b				  -	      ERR
      4  194b					      ENDIF
      5  194b		       00		      .byte.b	0
      0  194c					      EVAL8	0
      1  194c				  -	      IF	(0 > 127) || (0 < -128)
      2  194c				  -	      ECHO	"Erroneous position value", 0
      3  194c				  -	      ERR
      4  194c					      ENDIF
      5  194c		       00		      .byte.b	0
      0  194d					      EVAL8	0
      1  194d				  -	      IF	(0 > 127) || (0 < -128)
      2  194d				  -	      ECHO	"Erroneous position value", 0
      3  194d				  -	      ERR
      4  194d					      ENDIF
      5  194d		       00		      .byte.b	0
      0  194e					      EVAL8	0
      1  194e				  -	      IF	(0 > 127) || (0 < -128)
      2  194e				  -	      ECHO	"Erroneous position value", 0
      3  194e				  -	      ERR
      4  194e					      ENDIF
      5  194e		       00		      .byte.b	0
      0  194f					      EVAL8	0
      1  194f				  -	      IF	(0 > 127) || (0 < -128)
      2  194f				  -	      ECHO	"Erroneous position value", 0
      3  194f				  -	      ERR
      4  194f					      ENDIF
      5  194f		       00		      .byte.b	0
    145  1950
    146  1950
    147  1950							;---------------------------------------------------------------------------------------------------
    148  1950
    149  1950				   PositionalValue_QUEEN
    150  1950
      0  1950					      PVAL	-20, -10, -5, -5, -5, -10, -10, -20
      0  1950					      EVAL8	-20
      1  1950				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1950				  -	      ECHO	"Erroneous position value", -20
      3  1950				  -	      ERR
      4  1950					      ENDIF
      5  1950		       ec		      .byte.b	-20
      0  1951					      EVAL8	-10
      1  1951				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1951				  -	      ECHO	"Erroneous position value", -10
      3  1951				  -	      ERR
      4  1951					      ENDIF
      5  1951		       f6		      .byte.b	-10
      0  1952					      EVAL8	-5
      1  1952				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1952				  -	      ECHO	"Erroneous position value", -5
      3  1952				  -	      ERR
      4  1952					      ENDIF
      5  1952		       fb		      .byte.b	-5
      0  1953					      EVAL8	-5
      1  1953				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1953				  -	      ECHO	"Erroneous position value", -5
      3  1953				  -	      ERR
      4  1953					      ENDIF
      5  1953		       fb		      .byte.b	-5
      0  1954					      EVAL8	-5
      1  1954				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1954				  -	      ECHO	"Erroneous position value", -5
      3  1954				  -	      ERR
      4  1954					      ENDIF
      5  1954		       fb		      .byte.b	-5
      0  1955					      EVAL8	-10
      1  1955				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1955				  -	      ECHO	"Erroneous position value", -10
      3  1955				  -	      ERR
      4  1955					      ENDIF
      5  1955		       f6		      .byte.b	-10
      0  1956					      EVAL8	-10
      1  1956				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1956				  -	      ECHO	"Erroneous position value", -10
      3  1956				  -	      ERR
      4  1956					      ENDIF
      5  1956		       f6		      .byte.b	-10
      0  1957					      EVAL8	-20
      1  1957				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1957				  -	      ECHO	"Erroneous position value", -20
      3  1957				  -	      ERR
      4  1957					      ENDIF
      5  1957		       ec		      .byte.b	-20
      0  1958					      EVAL8	0
      1  1958				  -	      IF	(0 > 127) || (0 < -128)
      2  1958				  -	      ECHO	"Erroneous position value", 0
      3  1958				  -	      ERR
      4  1958					      ENDIF
      5  1958		       00		      .byte.b	0
      0  1959					      EVAL8	0
      1  1959				  -	      IF	(0 > 127) || (0 < -128)
      2  1959				  -	      ECHO	"Erroneous position value", 0
      3  1959				  -	      ERR
      4  1959					      ENDIF
      5  1959		       00		      .byte.b	0
      0  195a					      PVAL	-10, 0, 5, 0, 0, 0, 0, -10
      0  195a					      EVAL8	-10
      1  195a				  -	      IF	(-10 > 127) || (-10 < -128)
      2  195a				  -	      ECHO	"Erroneous position value", -10
      3  195a				  -	      ERR
      4  195a					      ENDIF
      5  195a		       f6		      .byte.b	-10
      0  195b					      EVAL8	0
      1  195b				  -	      IF	(0 > 127) || (0 < -128)
      2  195b				  -	      ECHO	"Erroneous position value", 0
      3  195b				  -	      ERR
      4  195b					      ENDIF
      5  195b		       00		      .byte.b	0
      0  195c					      EVAL8	5
      1  195c				  -	      IF	(5 > 127) || (5 < -128)
      2  195c				  -	      ECHO	"Erroneous position value", 5
      3  195c				  -	      ERR
      4  195c					      ENDIF
      5  195c		       05		      .byte.b	5
      0  195d					      EVAL8	0
      1  195d				  -	      IF	(0 > 127) || (0 < -128)
      2  195d				  -	      ECHO	"Erroneous position value", 0
      3  195d				  -	      ERR
      4  195d					      ENDIF
      5  195d		       00		      .byte.b	0
      0  195e					      EVAL8	0
      1  195e				  -	      IF	(0 > 127) || (0 < -128)
      2  195e				  -	      ECHO	"Erroneous position value", 0
      3  195e				  -	      ERR
      4  195e					      ENDIF
      5  195e		       00		      .byte.b	0
      0  195f					      EVAL8	0
      1  195f				  -	      IF	(0 > 127) || (0 < -128)
      2  195f				  -	      ECHO	"Erroneous position value", 0
      3  195f				  -	      ERR
      4  195f					      ENDIF
      5  195f		       00		      .byte.b	0
      0  1960					      EVAL8	0
      1  1960				  -	      IF	(0 > 127) || (0 < -128)
      2  1960				  -	      ECHO	"Erroneous position value", 0
      3  1960				  -	      ERR
      4  1960					      ENDIF
      5  1960		       00		      .byte.b	0
      0  1961					      EVAL8	-10
      1  1961				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1961				  -	      ECHO	"Erroneous position value", -10
      3  1961				  -	      ERR
      4  1961					      ENDIF
      5  1961		       f6		      .byte.b	-10
      0  1962					      EVAL8	0
      1  1962				  -	      IF	(0 > 127) || (0 < -128)
      2  1962				  -	      ECHO	"Erroneous position value", 0
      3  1962				  -	      ERR
      4  1962					      ENDIF
      5  1962		       00		      .byte.b	0
      0  1963					      EVAL8	0
      1  1963				  -	      IF	(0 > 127) || (0 < -128)
      2  1963				  -	      ECHO	"Erroneous position value", 0
      3  1963				  -	      ERR
      4  1963					      ENDIF
      5  1963		       00		      .byte.b	0
      0  1964					      PVAL	-10, 5, 5, 5, 5, 25, 0, -10
      0  1964					      EVAL8	-10
      1  1964				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1964				  -	      ECHO	"Erroneous position value", -10
      3  1964				  -	      ERR
      4  1964					      ENDIF
      5  1964		       f6		      .byte.b	-10
      0  1965					      EVAL8	5
      1  1965				  -	      IF	(5 > 127) || (5 < -128)
      2  1965				  -	      ECHO	"Erroneous position value", 5
      3  1965				  -	      ERR
      4  1965					      ENDIF
      5  1965		       05		      .byte.b	5
      0  1966					      EVAL8	5
      1  1966				  -	      IF	(5 > 127) || (5 < -128)
      2  1966				  -	      ECHO	"Erroneous position value", 5
      3  1966				  -	      ERR
      4  1966					      ENDIF
      5  1966		       05		      .byte.b	5
      0  1967					      EVAL8	5
      1  1967				  -	      IF	(5 > 127) || (5 < -128)
      2  1967				  -	      ECHO	"Erroneous position value", 5
      3  1967				  -	      ERR
      4  1967					      ENDIF
      5  1967		       05		      .byte.b	5
      0  1968					      EVAL8	5
      1  1968				  -	      IF	(5 > 127) || (5 < -128)
      2  1968				  -	      ECHO	"Erroneous position value", 5
      3  1968				  -	      ERR
      4  1968					      ENDIF
      5  1968		       05		      .byte.b	5
      0  1969					      EVAL8	25
      1  1969				  -	      IF	(25 > 127) || (25 < -128)
      2  1969				  -	      ECHO	"Erroneous position value", 25
      3  1969				  -	      ERR
      4  1969					      ENDIF
      5  1969		       19		      .byte.b	25
      0  196a					      EVAL8	0
      1  196a				  -	      IF	(0 > 127) || (0 < -128)
      2  196a				  -	      ECHO	"Erroneous position value", 0
      3  196a				  -	      ERR
      4  196a					      ENDIF
      5  196a		       00		      .byte.b	0
      0  196b					      EVAL8	-10
      1  196b				  -	      IF	(-10 > 127) || (-10 < -128)
      2  196b				  -	      ECHO	"Erroneous position value", -10
      3  196b				  -	      ERR
      4  196b					      ENDIF
      5  196b		       f6		      .byte.b	-10
      0  196c					      EVAL8	0
      1  196c				  -	      IF	(0 > 127) || (0 < -128)
      2  196c				  -	      ECHO	"Erroneous position value", 0
      3  196c				  -	      ERR
      4  196c					      ENDIF
      5  196c		       00		      .byte.b	0
      0  196d					      EVAL8	0
      1  196d				  -	      IF	(0 > 127) || (0 < -128)
      2  196d				  -	      ECHO	"Erroneous position value", 0
      3  196d				  -	      ERR
      4  196d					      ENDIF
      5  196d		       00		      .byte.b	0
      0  196e					      PVAL	-10, 0, 5, 25, 25, 25, 0, -10
      0  196e					      EVAL8	-10
      1  196e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  196e				  -	      ECHO	"Erroneous position value", -10
      3  196e				  -	      ERR
      4  196e					      ENDIF
      5  196e		       f6		      .byte.b	-10
      0  196f					      EVAL8	0
      1  196f				  -	      IF	(0 > 127) || (0 < -128)
      2  196f				  -	      ECHO	"Erroneous position value", 0
      3  196f				  -	      ERR
      4  196f					      ENDIF
      5  196f		       00		      .byte.b	0
      0  1970					      EVAL8	5
      1  1970				  -	      IF	(5 > 127) || (5 < -128)
      2  1970				  -	      ECHO	"Erroneous position value", 5
      3  1970				  -	      ERR
      4  1970					      ENDIF
      5  1970		       05		      .byte.b	5
      0  1971					      EVAL8	25
      1  1971				  -	      IF	(25 > 127) || (25 < -128)
      2  1971				  -	      ECHO	"Erroneous position value", 25
      3  1971				  -	      ERR
      4  1971					      ENDIF
      5  1971		       19		      .byte.b	25
      0  1972					      EVAL8	25
      1  1972				  -	      IF	(25 > 127) || (25 < -128)
      2  1972				  -	      ECHO	"Erroneous position value", 25
      3  1972				  -	      ERR
      4  1972					      ENDIF
      5  1972		       19		      .byte.b	25
      0  1973					      EVAL8	25
      1  1973				  -	      IF	(25 > 127) || (25 < -128)
      2  1973				  -	      ECHO	"Erroneous position value", 25
      3  1973				  -	      ERR
      4  1973					      ENDIF
      5  1973		       19		      .byte.b	25
      0  1974					      EVAL8	0
      1  1974				  -	      IF	(0 > 127) || (0 < -128)
      2  1974				  -	      ECHO	"Erroneous position value", 0
      3  1974				  -	      ERR
      4  1974					      ENDIF
      5  1974		       00		      .byte.b	0
      0  1975					      EVAL8	-10
      1  1975				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1975				  -	      ECHO	"Erroneous position value", -10
      3  1975				  -	      ERR
      4  1975					      ENDIF
      5  1975		       f6		      .byte.b	-10
      0  1976					      EVAL8	0
      1  1976				  -	      IF	(0 > 127) || (0 < -128)
      2  1976				  -	      ECHO	"Erroneous position value", 0
      3  1976				  -	      ERR
      4  1976					      ENDIF
      5  1976		       00		      .byte.b	0
      0  1977					      EVAL8	0
      1  1977				  -	      IF	(0 > 127) || (0 < -128)
      2  1977				  -	      ECHO	"Erroneous position value", 0
      3  1977				  -	      ERR
      4  1977					      ENDIF
      5  1977		       00		      .byte.b	0
      0  1978					      PVAL	-5, 0, 15, 55, 55, 55, 0, -5
      0  1978					      EVAL8	-5
      1  1978				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1978				  -	      ECHO	"Erroneous position value", -5
      3  1978				  -	      ERR
      4  1978					      ENDIF
      5  1978		       fb		      .byte.b	-5
      0  1979					      EVAL8	0
      1  1979				  -	      IF	(0 > 127) || (0 < -128)
      2  1979				  -	      ECHO	"Erroneous position value", 0
      3  1979				  -	      ERR
      4  1979					      ENDIF
      5  1979		       00		      .byte.b	0
      0  197a					      EVAL8	15
      1  197a				  -	      IF	(15 > 127) || (15 < -128)
      2  197a				  -	      ECHO	"Erroneous position value", 15
      3  197a				  -	      ERR
      4  197a					      ENDIF
      5  197a		       0f		      .byte.b	15
      0  197b					      EVAL8	55
      1  197b				  -	      IF	(55 > 127) || (55 < -128)
      2  197b				  -	      ECHO	"Erroneous position value", 55
      3  197b				  -	      ERR
      4  197b					      ENDIF
      5  197b		       37		      .byte.b	55
      0  197c					      EVAL8	55
      1  197c				  -	      IF	(55 > 127) || (55 < -128)
      2  197c				  -	      ECHO	"Erroneous position value", 55
      3  197c				  -	      ERR
      4  197c					      ENDIF
      5  197c		       37		      .byte.b	55
      0  197d					      EVAL8	55
      1  197d				  -	      IF	(55 > 127) || (55 < -128)
      2  197d				  -	      ECHO	"Erroneous position value", 55
      3  197d				  -	      ERR
      4  197d					      ENDIF
      5  197d		       37		      .byte.b	55
      0  197e					      EVAL8	0
      1  197e				  -	      IF	(0 > 127) || (0 < -128)
      2  197e				  -	      ECHO	"Erroneous position value", 0
      3  197e				  -	      ERR
      4  197e					      ENDIF
      5  197e		       00		      .byte.b	0
      0  197f					      EVAL8	-5
      1  197f				  -	      IF	(-5 > 127) || (-5 < -128)
      2  197f				  -	      ECHO	"Erroneous position value", -5
      3  197f				  -	      ERR
      4  197f					      ENDIF
      5  197f		       fb		      .byte.b	-5
      0  1980					      EVAL8	0
      1  1980				  -	      IF	(0 > 127) || (0 < -128)
      2  1980				  -	      ECHO	"Erroneous position value", 0
      3  1980				  -	      ERR
      4  1980					      ENDIF
      5  1980		       00		      .byte.b	0
      0  1981					      EVAL8	0
      1  1981				  -	      IF	(0 > 127) || (0 < -128)
      2  1981				  -	      ECHO	"Erroneous position value", 0
      3  1981				  -	      ERR
      4  1981					      ENDIF
      5  1981		       00		      .byte.b	0
      0  1982					      PVAL	-10, 0, 25, 75, 75, 75, 0, -10
      0  1982					      EVAL8	-10
      1  1982				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1982				  -	      ECHO	"Erroneous position value", -10
      3  1982				  -	      ERR
      4  1982					      ENDIF
      5  1982		       f6		      .byte.b	-10
      0  1983					      EVAL8	0
      1  1983				  -	      IF	(0 > 127) || (0 < -128)
      2  1983				  -	      ECHO	"Erroneous position value", 0
      3  1983				  -	      ERR
      4  1983					      ENDIF
      5  1983		       00		      .byte.b	0
      0  1984					      EVAL8	25
      1  1984				  -	      IF	(25 > 127) || (25 < -128)
      2  1984				  -	      ECHO	"Erroneous position value", 25
      3  1984				  -	      ERR
      4  1984					      ENDIF
      5  1984		       19		      .byte.b	25
      0  1985					      EVAL8	75
      1  1985				  -	      IF	(75 > 127) || (75 < -128)
      2  1985				  -	      ECHO	"Erroneous position value", 75
      3  1985				  -	      ERR
      4  1985					      ENDIF
      5  1985		       4b		      .byte.b	75
      0  1986					      EVAL8	75
      1  1986				  -	      IF	(75 > 127) || (75 < -128)
      2  1986				  -	      ECHO	"Erroneous position value", 75
      3  1986				  -	      ERR
      4  1986					      ENDIF
      5  1986		       4b		      .byte.b	75
      0  1987					      EVAL8	75
      1  1987				  -	      IF	(75 > 127) || (75 < -128)
      2  1987				  -	      ECHO	"Erroneous position value", 75
      3  1987				  -	      ERR
      4  1987					      ENDIF
      5  1987		       4b		      .byte.b	75
      0  1988					      EVAL8	0
      1  1988				  -	      IF	(0 > 127) || (0 < -128)
      2  1988				  -	      ECHO	"Erroneous position value", 0
      3  1988				  -	      ERR
      4  1988					      ENDIF
      5  1988		       00		      .byte.b	0
      0  1989					      EVAL8	-10
      1  1989				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1989				  -	      ECHO	"Erroneous position value", -10
      3  1989				  -	      ERR
      4  1989					      ENDIF
      5  1989		       f6		      .byte.b	-10
      0  198a					      EVAL8	0
      1  198a				  -	      IF	(0 > 127) || (0 < -128)
      2  198a				  -	      ECHO	"Erroneous position value", 0
      3  198a				  -	      ERR
      4  198a					      ENDIF
      5  198a		       00		      .byte.b	0
      0  198b					      EVAL8	0
      1  198b				  -	      IF	(0 > 127) || (0 < -128)
      2  198b				  -	      ECHO	"Erroneous position value", 0
      3  198b				  -	      ERR
      4  198b					      ENDIF
      5  198b		       00		      .byte.b	0
      0  198c					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      0  198c					      EVAL8	-10
      1  198c				  -	      IF	(-10 > 127) || (-10 < -128)
      2  198c				  -	      ECHO	"Erroneous position value", -10
      3  198c				  -	      ERR
      4  198c					      ENDIF
      5  198c		       f6		      .byte.b	-10
      0  198d					      EVAL8	0
      1  198d				  -	      IF	(0 > 127) || (0 < -128)
      2  198d				  -	      ECHO	"Erroneous position value", 0
      3  198d				  -	      ERR
      4  198d					      ENDIF
      5  198d		       00		      .byte.b	0
      0  198e					      EVAL8	0
      1  198e				  -	      IF	(0 > 127) || (0 < -128)
      2  198e				  -	      ECHO	"Erroneous position value", 0
      3  198e				  -	      ERR
      4  198e					      ENDIF
      5  198e		       00		      .byte.b	0
      0  198f					      EVAL8	0
      1  198f				  -	      IF	(0 > 127) || (0 < -128)
      2  198f				  -	      ECHO	"Erroneous position value", 0
      3  198f				  -	      ERR
      4  198f					      ENDIF
      5  198f		       00		      .byte.b	0
      0  1990					      EVAL8	0
      1  1990				  -	      IF	(0 > 127) || (0 < -128)
      2  1990				  -	      ECHO	"Erroneous position value", 0
      3  1990				  -	      ERR
      4  1990					      ENDIF
      5  1990		       00		      .byte.b	0
      0  1991					      EVAL8	0
      1  1991				  -	      IF	(0 > 127) || (0 < -128)
      2  1991				  -	      ECHO	"Erroneous position value", 0
      3  1991				  -	      ERR
      4  1991					      ENDIF
      5  1991		       00		      .byte.b	0
      0  1992					      EVAL8	0
      1  1992				  -	      IF	(0 > 127) || (0 < -128)
      2  1992				  -	      ECHO	"Erroneous position value", 0
      3  1992				  -	      ERR
      4  1992					      ENDIF
      5  1992		       00		      .byte.b	0
      0  1993					      EVAL8	-10
      1  1993				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1993				  -	      ECHO	"Erroneous position value", -10
      3  1993				  -	      ERR
      4  1993					      ENDIF
      5  1993		       f6		      .byte.b	-10
      0  1994					      EVAL8	0
      1  1994				  -	      IF	(0 > 127) || (0 < -128)
      2  1994				  -	      ECHO	"Erroneous position value", 0
      3  1994				  -	      ERR
      4  1994					      ENDIF
      5  1994		       00		      .byte.b	0
      0  1995					      EVAL8	0
      1  1995				  -	      IF	(0 > 127) || (0 < -128)
      2  1995				  -	      ECHO	"Erroneous position value", 0
      3  1995				  -	      ERR
      4  1995					      ENDIF
      5  1995		       00		      .byte.b	0
      0  1996					      PVAL	-20, -10, -10, -5, -5, -10, -10, -20
      0  1996					      EVAL8	-20
      1  1996				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1996				  -	      ECHO	"Erroneous position value", -20
      3  1996				  -	      ERR
      4  1996					      ENDIF
      5  1996		       ec		      .byte.b	-20
      0  1997					      EVAL8	-10
      1  1997				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1997				  -	      ECHO	"Erroneous position value", -10
      3  1997				  -	      ERR
      4  1997					      ENDIF
      5  1997		       f6		      .byte.b	-10
      0  1998					      EVAL8	-10
      1  1998				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1998				  -	      ECHO	"Erroneous position value", -10
      3  1998				  -	      ERR
      4  1998					      ENDIF
      5  1998		       f6		      .byte.b	-10
      0  1999					      EVAL8	-5
      1  1999				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1999				  -	      ECHO	"Erroneous position value", -5
      3  1999				  -	      ERR
      4  1999					      ENDIF
      5  1999		       fb		      .byte.b	-5
      0  199a					      EVAL8	-5
      1  199a				  -	      IF	(-5 > 127) || (-5 < -128)
      2  199a				  -	      ECHO	"Erroneous position value", -5
      3  199a				  -	      ERR
      4  199a					      ENDIF
      5  199a		       fb		      .byte.b	-5
      0  199b					      EVAL8	-10
      1  199b				  -	      IF	(-10 > 127) || (-10 < -128)
      2  199b				  -	      ECHO	"Erroneous position value", -10
      3  199b				  -	      ERR
      4  199b					      ENDIF
      5  199b		       f6		      .byte.b	-10
      0  199c					      EVAL8	-10
      1  199c				  -	      IF	(-10 > 127) || (-10 < -128)
      2  199c				  -	      ECHO	"Erroneous position value", -10
      3  199c				  -	      ERR
      4  199c					      ENDIF
      5  199c		       f6		      .byte.b	-10
      0  199d					      EVAL8	-20
      1  199d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  199d				  -	      ECHO	"Erroneous position value", -20
      3  199d				  -	      ERR
      4  199d					      ENDIF
      5  199d		       ec		      .byte.b	-20
      0  199e					      EVAL8	0
      1  199e				  -	      IF	(0 > 127) || (0 < -128)
      2  199e				  -	      ECHO	"Erroneous position value", 0
      3  199e				  -	      ERR
      4  199e					      ENDIF
      5  199e		       00		      .byte.b	0
      0  199f					      EVAL8	0
      1  199f				  -	      IF	(0 > 127) || (0 < -128)
      2  199f				  -	      ECHO	"Erroneous position value", 0
      3  199f				  -	      ERR
      4  199f					      ENDIF
      5  199f		       00		      .byte.b	0
    159  19a0
    160  19a0
    161  19a0							;---------------------------------------------------------------------------------------------------
    162  19a0
    163  19a0				   PositionalValue_KING_MIDGAME
    164  19a0
      0  19a0					      PVAL	0, 0, 40, -60, -30, 0, 50, 0
      0  19a0					      EVAL8	0
      1  19a0				  -	      IF	(0 > 127) || (0 < -128)
      2  19a0				  -	      ECHO	"Erroneous position value", 0
      3  19a0				  -	      ERR
      4  19a0					      ENDIF
      5  19a0		       00		      .byte.b	0
      0  19a1					      EVAL8	0
      1  19a1				  -	      IF	(0 > 127) || (0 < -128)
      2  19a1				  -	      ECHO	"Erroneous position value", 0
      3  19a1				  -	      ERR
      4  19a1					      ENDIF
      5  19a1		       00		      .byte.b	0
      0  19a2					      EVAL8	40
      1  19a2				  -	      IF	(40 > 127) || (40 < -128)
      2  19a2				  -	      ECHO	"Erroneous position value", 40
      3  19a2				  -	      ERR
      4  19a2					      ENDIF
      5  19a2		       28		      .byte.b	40
      0  19a3					      EVAL8	-60
      1  19a3				  -	      IF	(-60 > 127) || (-60 < -128)
      2  19a3				  -	      ECHO	"Erroneous position value", -60
      3  19a3				  -	      ERR
      4  19a3					      ENDIF
      5  19a3		       c4		      .byte.b	-60
      0  19a4					      EVAL8	-30
      1  19a4				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19a4				  -	      ECHO	"Erroneous position value", -30
      3  19a4				  -	      ERR
      4  19a4					      ENDIF
      5  19a4		       e2		      .byte.b	-30
      0  19a5					      EVAL8	0
      1  19a5				  -	      IF	(0 > 127) || (0 < -128)
      2  19a5				  -	      ECHO	"Erroneous position value", 0
      3  19a5				  -	      ERR
      4  19a5					      ENDIF
      5  19a5		       00		      .byte.b	0
      0  19a6					      EVAL8	50
      1  19a6				  -	      IF	(50 > 127) || (50 < -128)
      2  19a6				  -	      ECHO	"Erroneous position value", 50
      3  19a6				  -	      ERR
      4  19a6					      ENDIF
      5  19a6		       32		      .byte.b	50
      0  19a7					      EVAL8	0
      1  19a7				  -	      IF	(0 > 127) || (0 < -128)
      2  19a7				  -	      ECHO	"Erroneous position value", 0
      3  19a7				  -	      ERR
      4  19a7					      ENDIF
      5  19a7		       00		      .byte.b	0
      0  19a8					      EVAL8	0
      1  19a8				  -	      IF	(0 > 127) || (0 < -128)
      2  19a8				  -	      ECHO	"Erroneous position value", 0
      3  19a8				  -	      ERR
      4  19a8					      ENDIF
      5  19a8		       00		      .byte.b	0
      0  19a9					      EVAL8	0
      1  19a9				  -	      IF	(0 > 127) || (0 < -128)
      2  19a9				  -	      ECHO	"Erroneous position value", 0
      3  19a9				  -	      ERR
      4  19a9					      ENDIF
      5  19a9		       00		      .byte.b	0
      0  19aa					      PVAL	0, 0, -80, -80, -70, -70, 0, 0
      0  19aa					      EVAL8	0
      1  19aa				  -	      IF	(0 > 127) || (0 < -128)
      2  19aa				  -	      ECHO	"Erroneous position value", 0
      3  19aa				  -	      ERR
      4  19aa					      ENDIF
      5  19aa		       00		      .byte.b	0
      0  19ab					      EVAL8	0
      1  19ab				  -	      IF	(0 > 127) || (0 < -128)
      2  19ab				  -	      ECHO	"Erroneous position value", 0
      3  19ab				  -	      ERR
      4  19ab					      ENDIF
      5  19ab		       00		      .byte.b	0
      0  19ac					      EVAL8	-80
      1  19ac				  -	      IF	(-80 > 127) || (-80 < -128)
      2  19ac				  -	      ECHO	"Erroneous position value", -80
      3  19ac				  -	      ERR
      4  19ac					      ENDIF
      5  19ac		       b0		      .byte.b	-80
      0  19ad					      EVAL8	-80
      1  19ad				  -	      IF	(-80 > 127) || (-80 < -128)
      2  19ad				  -	      ECHO	"Erroneous position value", -80
      3  19ad				  -	      ERR
      4  19ad					      ENDIF
      5  19ad		       b0		      .byte.b	-80
      0  19ae					      EVAL8	-70
      1  19ae				  -	      IF	(-70 > 127) || (-70 < -128)
      2  19ae				  -	      ECHO	"Erroneous position value", -70
      3  19ae				  -	      ERR
      4  19ae					      ENDIF
      5  19ae		       ba		      .byte.b	-70
      0  19af					      EVAL8	-70
      1  19af				  -	      IF	(-70 > 127) || (-70 < -128)
      2  19af				  -	      ECHO	"Erroneous position value", -70
      3  19af				  -	      ERR
      4  19af					      ENDIF
      5  19af		       ba		      .byte.b	-70
      0  19b0					      EVAL8	0
      1  19b0				  -	      IF	(0 > 127) || (0 < -128)
      2  19b0				  -	      ECHO	"Erroneous position value", 0
      3  19b0				  -	      ERR
      4  19b0					      ENDIF
      5  19b0		       00		      .byte.b	0
      0  19b1					      EVAL8	0
      1  19b1				  -	      IF	(0 > 127) || (0 < -128)
      2  19b1				  -	      ECHO	"Erroneous position value", 0
      3  19b1				  -	      ERR
      4  19b1					      ENDIF
      5  19b1		       00		      .byte.b	0
      0  19b2					      EVAL8	0
      1  19b2				  -	      IF	(0 > 127) || (0 < -128)
      2  19b2				  -	      ECHO	"Erroneous position value", 0
      3  19b2				  -	      ERR
      4  19b2					      ENDIF
      5  19b2		       00		      .byte.b	0
      0  19b3					      EVAL8	0
      1  19b3				  -	      IF	(0 > 127) || (0 < -128)
      2  19b3				  -	      ECHO	"Erroneous position value", 0
      3  19b3				  -	      ERR
      4  19b3					      ENDIF
      5  19b3		       00		      .byte.b	0
      0  19b4					      PVAL	-10, -20, -20, -50, -60, -60, -20, -10
      0  19b4					      EVAL8	-10
      1  19b4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  19b4				  -	      ECHO	"Erroneous position value", -10
      3  19b4				  -	      ERR
      4  19b4					      ENDIF
      5  19b4		       f6		      .byte.b	-10
      0  19b5					      EVAL8	-20
      1  19b5				  -	      IF	(-20 > 127) || (-20 < -128)
      2  19b5				  -	      ECHO	"Erroneous position value", -20
      3  19b5				  -	      ERR
      4  19b5					      ENDIF
      5  19b5		       ec		      .byte.b	-20
      0  19b6					      EVAL8	-20
      1  19b6				  -	      IF	(-20 > 127) || (-20 < -128)
      2  19b6				  -	      ECHO	"Erroneous position value", -20
      3  19b6				  -	      ERR
      4  19b6					      ENDIF
      5  19b6		       ec		      .byte.b	-20
      0  19b7					      EVAL8	-50
      1  19b7				  -	      IF	(-50 > 127) || (-50 < -128)
      2  19b7				  -	      ECHO	"Erroneous position value", -50
      3  19b7				  -	      ERR
      4  19b7					      ENDIF
      5  19b7		       ce		      .byte.b	-50
      0  19b8					      EVAL8	-60
      1  19b8				  -	      IF	(-60 > 127) || (-60 < -128)
      2  19b8				  -	      ECHO	"Erroneous position value", -60
      3  19b8				  -	      ERR
      4  19b8					      ENDIF
      5  19b8		       c4		      .byte.b	-60
      0  19b9					      EVAL8	-60
      1  19b9				  -	      IF	(-60 > 127) || (-60 < -128)
      2  19b9				  -	      ECHO	"Erroneous position value", -60
      3  19b9				  -	      ERR
      4  19b9					      ENDIF
      5  19b9		       c4		      .byte.b	-60
      0  19ba					      EVAL8	-20
      1  19ba				  -	      IF	(-20 > 127) || (-20 < -128)
      2  19ba				  -	      ECHO	"Erroneous position value", -20
      3  19ba				  -	      ERR
      4  19ba					      ENDIF
      5  19ba		       ec		      .byte.b	-20
      0  19bb					      EVAL8	-10
      1  19bb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  19bb				  -	      ECHO	"Erroneous position value", -10
      3  19bb				  -	      ERR
      4  19bb					      ENDIF
      5  19bb		       f6		      .byte.b	-10
      0  19bc					      EVAL8	0
      1  19bc				  -	      IF	(0 > 127) || (0 < -128)
      2  19bc				  -	      ECHO	"Erroneous position value", 0
      3  19bc				  -	      ERR
      4  19bc					      ENDIF
      5  19bc		       00		      .byte.b	0
      0  19bd					      EVAL8	0
      1  19bd				  -	      IF	(0 > 127) || (0 < -128)
      2  19bd				  -	      ECHO	"Erroneous position value", 0
      3  19bd				  -	      ERR
      4  19bd					      ENDIF
      5  19bd		       00		      .byte.b	0
      0  19be					      PVAL	-20, -30, -30, -40, -40, -30, -30, -20
      0  19be					      EVAL8	-20
      1  19be				  -	      IF	(-20 > 127) || (-20 < -128)
      2  19be				  -	      ECHO	"Erroneous position value", -20
      3  19be				  -	      ERR
      4  19be					      ENDIF
      5  19be		       ec		      .byte.b	-20
      0  19bf					      EVAL8	-30
      1  19bf				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19bf				  -	      ECHO	"Erroneous position value", -30
      3  19bf				  -	      ERR
      4  19bf					      ENDIF
      5  19bf		       e2		      .byte.b	-30
      0  19c0					      EVAL8	-30
      1  19c0				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19c0				  -	      ECHO	"Erroneous position value", -30
      3  19c0				  -	      ERR
      4  19c0					      ENDIF
      5  19c0		       e2		      .byte.b	-30
      0  19c1					      EVAL8	-40
      1  19c1				  -	      IF	(-40 > 127) || (-40 < -128)
      2  19c1				  -	      ECHO	"Erroneous position value", -40
      3  19c1				  -	      ERR
      4  19c1					      ENDIF
      5  19c1		       d8		      .byte.b	-40
      0  19c2					      EVAL8	-40
      1  19c2				  -	      IF	(-40 > 127) || (-40 < -128)
      2  19c2				  -	      ECHO	"Erroneous position value", -40
      3  19c2				  -	      ERR
      4  19c2					      ENDIF
      5  19c2		       d8		      .byte.b	-40
      0  19c3					      EVAL8	-30
      1  19c3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19c3				  -	      ECHO	"Erroneous position value", -30
      3  19c3				  -	      ERR
      4  19c3					      ENDIF
      5  19c3		       e2		      .byte.b	-30
      0  19c4					      EVAL8	-30
      1  19c4				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19c4				  -	      ECHO	"Erroneous position value", -30
      3  19c4				  -	      ERR
      4  19c4					      ENDIF
      5  19c4		       e2		      .byte.b	-30
      0  19c5					      EVAL8	-20
      1  19c5				  -	      IF	(-20 > 127) || (-20 < -128)
      2  19c5				  -	      ECHO	"Erroneous position value", -20
      3  19c5				  -	      ERR
      4  19c5					      ENDIF
      5  19c5		       ec		      .byte.b	-20
      0  19c6					      EVAL8	0
      1  19c6				  -	      IF	(0 > 127) || (0 < -128)
      2  19c6				  -	      ECHO	"Erroneous position value", 0
      3  19c6				  -	      ERR
      4  19c6					      ENDIF
      5  19c6		       00		      .byte.b	0
      0  19c7					      EVAL8	0
      1  19c7				  -	      IF	(0 > 127) || (0 < -128)
      2  19c7				  -	      ECHO	"Erroneous position value", 0
      3  19c7				  -	      ERR
      4  19c7					      ENDIF
      5  19c7		       00		      .byte.b	0
      0  19c8					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  19c8					      EVAL8	-30
      1  19c8				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19c8				  -	      ECHO	"Erroneous position value", -30
      3  19c8				  -	      ERR
      4  19c8					      ENDIF
      5  19c8		       e2		      .byte.b	-30
      0  19c9					      EVAL8	-40
      1  19c9				  -	      IF	(-40 > 127) || (-40 < -128)
      2  19c9				  -	      ECHO	"Erroneous position value", -40
      3  19c9				  -	      ERR
      4  19c9					      ENDIF
      5  19c9		       d8		      .byte.b	-40
      0  19ca					      EVAL8	-40
      1  19ca				  -	      IF	(-40 > 127) || (-40 < -128)
      2  19ca				  -	      ECHO	"Erroneous position value", -40
      3  19ca				  -	      ERR
      4  19ca					      ENDIF
      5  19ca		       d8		      .byte.b	-40
      0  19cb					      EVAL8	-50
      1  19cb				  -	      IF	(-50 > 127) || (-50 < -128)
      2  19cb				  -	      ECHO	"Erroneous position value", -50
      3  19cb				  -	      ERR
      4  19cb					      ENDIF
      5  19cb		       ce		      .byte.b	-50
      0  19cc					      EVAL8	-50
      1  19cc				  -	      IF	(-50 > 127) || (-50 < -128)
      2  19cc				  -	      ECHO	"Erroneous position value", -50
      3  19cc				  -	      ERR
      4  19cc					      ENDIF
      5  19cc		       ce		      .byte.b	-50
      0  19cd					      EVAL8	-40
      1  19cd				  -	      IF	(-40 > 127) || (-40 < -128)
      2  19cd				  -	      ECHO	"Erroneous position value", -40
      3  19cd				  -	      ERR
      4  19cd					      ENDIF
      5  19cd		       d8		      .byte.b	-40
      0  19ce					      EVAL8	-40
      1  19ce				  -	      IF	(-40 > 127) || (-40 < -128)
      2  19ce				  -	      ECHO	"Erroneous position value", -40
      3  19ce				  -	      ERR
      4  19ce					      ENDIF
      5  19ce		       d8		      .byte.b	-40
      0  19cf					      EVAL8	-30
      1  19cf				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19cf				  -	      ECHO	"Erroneous position value", -30
      3  19cf				  -	      ERR
      4  19cf					      ENDIF
      5  19cf		       e2		      .byte.b	-30
      0  19d0					      EVAL8	0
      1  19d0				  -	      IF	(0 > 127) || (0 < -128)
      2  19d0				  -	      ECHO	"Erroneous position value", 0
      3  19d0				  -	      ERR
      4  19d0					      ENDIF
      5  19d0		       00		      .byte.b	0
      0  19d1					      EVAL8	0
      1  19d1				  -	      IF	(0 > 127) || (0 < -128)
      2  19d1				  -	      ECHO	"Erroneous position value", 0
      3  19d1				  -	      ERR
      4  19d1					      ENDIF
      5  19d1		       00		      .byte.b	0
      0  19d2					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  19d2					      EVAL8	-30
      1  19d2				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19d2				  -	      ECHO	"Erroneous position value", -30
      3  19d2				  -	      ERR
      4  19d2					      ENDIF
      5  19d2		       e2		      .byte.b	-30
      0  19d3					      EVAL8	-40
      1  19d3				  -	      IF	(-40 > 127) || (-40 < -128)
      2  19d3				  -	      ECHO	"Erroneous position value", -40
      3  19d3				  -	      ERR
      4  19d3					      ENDIF
      5  19d3		       d8		      .byte.b	-40
      0  19d4					      EVAL8	-40
      1  19d4				  -	      IF	(-40 > 127) || (-40 < -128)
      2  19d4				  -	      ECHO	"Erroneous position value", -40
      3  19d4				  -	      ERR
      4  19d4					      ENDIF
      5  19d4		       d8		      .byte.b	-40
      0  19d5					      EVAL8	-50
      1  19d5				  -	      IF	(-50 > 127) || (-50 < -128)
      2  19d5				  -	      ECHO	"Erroneous position value", -50
      3  19d5				  -	      ERR
      4  19d5					      ENDIF
      5  19d5		       ce		      .byte.b	-50
      0  19d6					      EVAL8	-50
      1  19d6				  -	      IF	(-50 > 127) || (-50 < -128)
      2  19d6				  -	      ECHO	"Erroneous position value", -50
      3  19d6				  -	      ERR
      4  19d6					      ENDIF
      5  19d6		       ce		      .byte.b	-50
      0  19d7					      EVAL8	-40
      1  19d7				  -	      IF	(-40 > 127) || (-40 < -128)
      2  19d7				  -	      ECHO	"Erroneous position value", -40
      3  19d7				  -	      ERR
      4  19d7					      ENDIF
      5  19d7		       d8		      .byte.b	-40
      0  19d8					      EVAL8	-40
      1  19d8				  -	      IF	(-40 > 127) || (-40 < -128)
      2  19d8				  -	      ECHO	"Erroneous position value", -40
      3  19d8				  -	      ERR
      4  19d8					      ENDIF
      5  19d8		       d8		      .byte.b	-40
      0  19d9					      EVAL8	-30
      1  19d9				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19d9				  -	      ECHO	"Erroneous position value", -30
      3  19d9				  -	      ERR
      4  19d9					      ENDIF
      5  19d9		       e2		      .byte.b	-30
      0  19da					      EVAL8	0
      1  19da				  -	      IF	(0 > 127) || (0 < -128)
      2  19da				  -	      ECHO	"Erroneous position value", 0
      3  19da				  -	      ERR
      4  19da					      ENDIF
      5  19da		       00		      .byte.b	0
      0  19db					      EVAL8	0
      1  19db				  -	      IF	(0 > 127) || (0 < -128)
      2  19db				  -	      ECHO	"Erroneous position value", 0
      3  19db				  -	      ERR
      4  19db					      ENDIF
      5  19db		       00		      .byte.b	0
      0  19dc					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  19dc					      EVAL8	-30
      1  19dc				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19dc				  -	      ECHO	"Erroneous position value", -30
      3  19dc				  -	      ERR
      4  19dc					      ENDIF
      5  19dc		       e2		      .byte.b	-30
      0  19dd					      EVAL8	-40
      1  19dd				  -	      IF	(-40 > 127) || (-40 < -128)
      2  19dd				  -	      ECHO	"Erroneous position value", -40
      3  19dd				  -	      ERR
      4  19dd					      ENDIF
      5  19dd		       d8		      .byte.b	-40
      0  19de					      EVAL8	-40
      1  19de				  -	      IF	(-40 > 127) || (-40 < -128)
      2  19de				  -	      ECHO	"Erroneous position value", -40
      3  19de				  -	      ERR
      4  19de					      ENDIF
      5  19de		       d8		      .byte.b	-40
      0  19df					      EVAL8	-50
      1  19df				  -	      IF	(-50 > 127) || (-50 < -128)
      2  19df				  -	      ECHO	"Erroneous position value", -50
      3  19df				  -	      ERR
      4  19df					      ENDIF
      5  19df		       ce		      .byte.b	-50
      0  19e0					      EVAL8	-50
      1  19e0				  -	      IF	(-50 > 127) || (-50 < -128)
      2  19e0				  -	      ECHO	"Erroneous position value", -50
      3  19e0				  -	      ERR
      4  19e0					      ENDIF
      5  19e0		       ce		      .byte.b	-50
      0  19e1					      EVAL8	-40
      1  19e1				  -	      IF	(-40 > 127) || (-40 < -128)
      2  19e1				  -	      ECHO	"Erroneous position value", -40
      3  19e1				  -	      ERR
      4  19e1					      ENDIF
      5  19e1		       d8		      .byte.b	-40
      0  19e2					      EVAL8	-40
      1  19e2				  -	      IF	(-40 > 127) || (-40 < -128)
      2  19e2				  -	      ECHO	"Erroneous position value", -40
      3  19e2				  -	      ERR
      4  19e2					      ENDIF
      5  19e2		       d8		      .byte.b	-40
      0  19e3					      EVAL8	-30
      1  19e3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19e3				  -	      ECHO	"Erroneous position value", -30
      3  19e3				  -	      ERR
      4  19e3					      ENDIF
      5  19e3		       e2		      .byte.b	-30
      0  19e4					      EVAL8	0
      1  19e4				  -	      IF	(0 > 127) || (0 < -128)
      2  19e4				  -	      ECHO	"Erroneous position value", 0
      3  19e4				  -	      ERR
      4  19e4					      ENDIF
      5  19e4		       00		      .byte.b	0
      0  19e5					      EVAL8	0
      1  19e5				  -	      IF	(0 > 127) || (0 < -128)
      2  19e5				  -	      ECHO	"Erroneous position value", 0
      3  19e5				  -	      ERR
      4  19e5					      ENDIF
      5  19e5		       00		      .byte.b	0
      0  19e6					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  19e6					      EVAL8	-30
      1  19e6				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19e6				  -	      ECHO	"Erroneous position value", -30
      3  19e6				  -	      ERR
      4  19e6					      ENDIF
      5  19e6		       e2		      .byte.b	-30
      0  19e7					      EVAL8	-40
      1  19e7				  -	      IF	(-40 > 127) || (-40 < -128)
      2  19e7				  -	      ECHO	"Erroneous position value", -40
      3  19e7				  -	      ERR
      4  19e7					      ENDIF
      5  19e7		       d8		      .byte.b	-40
      0  19e8					      EVAL8	-40
      1  19e8				  -	      IF	(-40 > 127) || (-40 < -128)
      2  19e8				  -	      ECHO	"Erroneous position value", -40
      3  19e8				  -	      ERR
      4  19e8					      ENDIF
      5  19e8		       d8		      .byte.b	-40
      0  19e9					      EVAL8	-50
      1  19e9				  -	      IF	(-50 > 127) || (-50 < -128)
      2  19e9				  -	      ECHO	"Erroneous position value", -50
      3  19e9				  -	      ERR
      4  19e9					      ENDIF
      5  19e9		       ce		      .byte.b	-50
      0  19ea					      EVAL8	-50
      1  19ea				  -	      IF	(-50 > 127) || (-50 < -128)
      2  19ea				  -	      ECHO	"Erroneous position value", -50
      3  19ea				  -	      ERR
      4  19ea					      ENDIF
      5  19ea		       ce		      .byte.b	-50
      0  19eb					      EVAL8	-40
      1  19eb				  -	      IF	(-40 > 127) || (-40 < -128)
      2  19eb				  -	      ECHO	"Erroneous position value", -40
      3  19eb				  -	      ERR
      4  19eb					      ENDIF
      5  19eb		       d8		      .byte.b	-40
      0  19ec					      EVAL8	-40
      1  19ec				  -	      IF	(-40 > 127) || (-40 < -128)
      2  19ec				  -	      ECHO	"Erroneous position value", -40
      3  19ec				  -	      ERR
      4  19ec					      ENDIF
      5  19ec		       d8		      .byte.b	-40
      0  19ed					      EVAL8	-30
      1  19ed				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19ed				  -	      ECHO	"Erroneous position value", -30
      3  19ed				  -	      ERR
      4  19ed					      ENDIF
      5  19ed		       e2		      .byte.b	-30
      0  19ee					      EVAL8	0
      1  19ee				  -	      IF	(0 > 127) || (0 < -128)
      2  19ee				  -	      ECHO	"Erroneous position value", 0
      3  19ee				  -	      ERR
      4  19ee					      ENDIF
      5  19ee		       00		      .byte.b	0
      0  19ef					      EVAL8	0
      1  19ef				  -	      IF	(0 > 127) || (0 < -128)
      2  19ef				  -	      ECHO	"Erroneous position value", 0
      3  19ef				  -	      ERR
      4  19ef					      ENDIF
      5  19ef		       00		      .byte.b	0
    173  19f0
    174  19f0
    175  19f0							;---------------------------------------------------------------------------------------------------
    176  19f0
    177  19f0				   PositionalValue_KING_ENDGAME
    178  19f0
      0  19f0					      PVAL	-50, -30, -30, -30, -30, -30, -30, -50
      0  19f0					      EVAL8	-50
      1  19f0				  -	      IF	(-50 > 127) || (-50 < -128)
      2  19f0				  -	      ECHO	"Erroneous position value", -50
      3  19f0				  -	      ERR
      4  19f0					      ENDIF
      5  19f0		       ce		      .byte.b	-50
      0  19f1					      EVAL8	-30
      1  19f1				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19f1				  -	      ECHO	"Erroneous position value", -30
      3  19f1				  -	      ERR
      4  19f1					      ENDIF
      5  19f1		       e2		      .byte.b	-30
      0  19f2					      EVAL8	-30
      1  19f2				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19f2				  -	      ECHO	"Erroneous position value", -30
      3  19f2				  -	      ERR
      4  19f2					      ENDIF
      5  19f2		       e2		      .byte.b	-30
      0  19f3					      EVAL8	-30
      1  19f3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19f3				  -	      ECHO	"Erroneous position value", -30
      3  19f3				  -	      ERR
      4  19f3					      ENDIF
      5  19f3		       e2		      .byte.b	-30
      0  19f4					      EVAL8	-30
      1  19f4				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19f4				  -	      ECHO	"Erroneous position value", -30
      3  19f4				  -	      ERR
      4  19f4					      ENDIF
      5  19f4		       e2		      .byte.b	-30
      0  19f5					      EVAL8	-30
      1  19f5				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19f5				  -	      ECHO	"Erroneous position value", -30
      3  19f5				  -	      ERR
      4  19f5					      ENDIF
      5  19f5		       e2		      .byte.b	-30
      0  19f6					      EVAL8	-30
      1  19f6				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19f6				  -	      ECHO	"Erroneous position value", -30
      3  19f6				  -	      ERR
      4  19f6					      ENDIF
      5  19f6		       e2		      .byte.b	-30
      0  19f7					      EVAL8	-50
      1  19f7				  -	      IF	(-50 > 127) || (-50 < -128)
      2  19f7				  -	      ECHO	"Erroneous position value", -50
      3  19f7				  -	      ERR
      4  19f7					      ENDIF
      5  19f7		       ce		      .byte.b	-50
      0  19f8					      EVAL8	0
      1  19f8				  -	      IF	(0 > 127) || (0 < -128)
      2  19f8				  -	      ECHO	"Erroneous position value", 0
      3  19f8				  -	      ERR
      4  19f8					      ENDIF
      5  19f8		       00		      .byte.b	0
      0  19f9					      EVAL8	0
      1  19f9				  -	      IF	(0 > 127) || (0 < -128)
      2  19f9				  -	      ECHO	"Erroneous position value", 0
      3  19f9				  -	      ERR
      4  19f9					      ENDIF
      5  19f9		       00		      .byte.b	0
      0  19fa					      PVAL	-30, -30, 0, 0, 0, 0, -30, -30
      0  19fa					      EVAL8	-30
      1  19fa				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19fa				  -	      ECHO	"Erroneous position value", -30
      3  19fa				  -	      ERR
      4  19fa					      ENDIF
      5  19fa		       e2		      .byte.b	-30
      0  19fb					      EVAL8	-30
      1  19fb				  -	      IF	(-30 > 127) || (-30 < -128)
      2  19fb				  -	      ECHO	"Erroneous position value", -30
      3  19fb				  -	      ERR
      4  19fb					      ENDIF
      5  19fb		       e2		      .byte.b	-30
      0  19fc					      EVAL8	0
      1  19fc				  -	      IF	(0 > 127) || (0 < -128)
      2  19fc				  -	      ECHO	"Erroneous position value", 0
      3  19fc				  -	      ERR
      4  19fc					      ENDIF
      5  19fc		       00		      .byte.b	0
      0  19fd					      EVAL8	0
      1  19fd				  -	      IF	(0 > 127) || (0 < -128)
      2  19fd				  -	      ECHO	"Erroneous position value", 0
      3  19fd				  -	      ERR
      4  19fd					      ENDIF
      5  19fd		       00		      .byte.b	0
      0  19fe					      EVAL8	0
      1  19fe				  -	      IF	(0 > 127) || (0 < -128)
      2  19fe				  -	      ECHO	"Erroneous position value", 0
      3  19fe				  -	      ERR
      4  19fe					      ENDIF
      5  19fe		       00		      .byte.b	0
      0  19ff					      EVAL8	0
      1  19ff				  -	      IF	(0 > 127) || (0 < -128)
      2  19ff				  -	      ECHO	"Erroneous position value", 0
      3  19ff				  -	      ERR
      4  19ff					      ENDIF
      5  19ff		       00		      .byte.b	0
      0  1a00					      EVAL8	-30
      1  1a00				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1a00				  -	      ECHO	"Erroneous position value", -30
      3  1a00				  -	      ERR
      4  1a00					      ENDIF
      5  1a00		       e2		      .byte.b	-30
      0  1a01					      EVAL8	-30
      1  1a01				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1a01				  -	      ECHO	"Erroneous position value", -30
      3  1a01				  -	      ERR
      4  1a01					      ENDIF
      5  1a01		       e2		      .byte.b	-30
      0  1a02					      EVAL8	0
      1  1a02				  -	      IF	(0 > 127) || (0 < -128)
      2  1a02				  -	      ECHO	"Erroneous position value", 0
      3  1a02				  -	      ERR
      4  1a02					      ENDIF
      5  1a02		       00		      .byte.b	0
      0  1a03					      EVAL8	0
      1  1a03				  -	      IF	(0 > 127) || (0 < -128)
      2  1a03				  -	      ECHO	"Erroneous position value", 0
      3  1a03				  -	      ERR
      4  1a03					      ENDIF
      5  1a03		       00		      .byte.b	0
      0  1a04					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      0  1a04					      EVAL8	-30
      1  1a04				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1a04				  -	      ECHO	"Erroneous position value", -30
      3  1a04				  -	      ERR
      4  1a04					      ENDIF
      5  1a04		       e2		      .byte.b	-30
      0  1a05					      EVAL8	-10
      1  1a05				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1a05				  -	      ECHO	"Erroneous position value", -10
      3  1a05				  -	      ERR
      4  1a05					      ENDIF
      5  1a05		       f6		      .byte.b	-10
      0  1a06					      EVAL8	20
      1  1a06				  -	      IF	(20 > 127) || (20 < -128)
      2  1a06				  -	      ECHO	"Erroneous position value", 20
      3  1a06				  -	      ERR
      4  1a06					      ENDIF
      5  1a06		       14		      .byte.b	20
      0  1a07					      EVAL8	30
      1  1a07				  -	      IF	(30 > 127) || (30 < -128)
      2  1a07				  -	      ECHO	"Erroneous position value", 30
      3  1a07				  -	      ERR
      4  1a07					      ENDIF
      5  1a07		       1e		      .byte.b	30
      0  1a08					      EVAL8	30
      1  1a08				  -	      IF	(30 > 127) || (30 < -128)
      2  1a08				  -	      ECHO	"Erroneous position value", 30
      3  1a08				  -	      ERR
      4  1a08					      ENDIF
      5  1a08		       1e		      .byte.b	30
      0  1a09					      EVAL8	20
      1  1a09				  -	      IF	(20 > 127) || (20 < -128)
      2  1a09				  -	      ECHO	"Erroneous position value", 20
      3  1a09				  -	      ERR
      4  1a09					      ENDIF
      5  1a09		       14		      .byte.b	20
      0  1a0a					      EVAL8	-10
      1  1a0a				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1a0a				  -	      ECHO	"Erroneous position value", -10
      3  1a0a				  -	      ERR
      4  1a0a					      ENDIF
      5  1a0a		       f6		      .byte.b	-10
      0  1a0b					      EVAL8	-30
      1  1a0b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1a0b				  -	      ECHO	"Erroneous position value", -30
      3  1a0b				  -	      ERR
      4  1a0b					      ENDIF
      5  1a0b		       e2		      .byte.b	-30
      0  1a0c					      EVAL8	0
      1  1a0c				  -	      IF	(0 > 127) || (0 < -128)
      2  1a0c				  -	      ECHO	"Erroneous position value", 0
      3  1a0c				  -	      ERR
      4  1a0c					      ENDIF
      5  1a0c		       00		      .byte.b	0
      0  1a0d					      EVAL8	0
      1  1a0d				  -	      IF	(0 > 127) || (0 < -128)
      2  1a0d				  -	      ECHO	"Erroneous position value", 0
      3  1a0d				  -	      ERR
      4  1a0d					      ENDIF
      5  1a0d		       00		      .byte.b	0
      0  1a0e					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      0  1a0e					      EVAL8	-30
      1  1a0e				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1a0e				  -	      ECHO	"Erroneous position value", -30
      3  1a0e				  -	      ERR
      4  1a0e					      ENDIF
      5  1a0e		       e2		      .byte.b	-30
      0  1a0f					      EVAL8	-10
      1  1a0f				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1a0f				  -	      ECHO	"Erroneous position value", -10
      3  1a0f				  -	      ERR
      4  1a0f					      ENDIF
      5  1a0f		       f6		      .byte.b	-10
      0  1a10					      EVAL8	30
      1  1a10				  -	      IF	(30 > 127) || (30 < -128)
      2  1a10				  -	      ECHO	"Erroneous position value", 30
      3  1a10				  -	      ERR
      4  1a10					      ENDIF
      5  1a10		       1e		      .byte.b	30
      0  1a11					      EVAL8	40
      1  1a11				  -	      IF	(40 > 127) || (40 < -128)
      2  1a11				  -	      ECHO	"Erroneous position value", 40
      3  1a11				  -	      ERR
      4  1a11					      ENDIF
      5  1a11		       28		      .byte.b	40
      0  1a12					      EVAL8	40
      1  1a12				  -	      IF	(40 > 127) || (40 < -128)
      2  1a12				  -	      ECHO	"Erroneous position value", 40
      3  1a12				  -	      ERR
      4  1a12					      ENDIF
      5  1a12		       28		      .byte.b	40
      0  1a13					      EVAL8	30
      1  1a13				  -	      IF	(30 > 127) || (30 < -128)
      2  1a13				  -	      ECHO	"Erroneous position value", 30
      3  1a13				  -	      ERR
      4  1a13					      ENDIF
      5  1a13		       1e		      .byte.b	30
      0  1a14					      EVAL8	-10
      1  1a14				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1a14				  -	      ECHO	"Erroneous position value", -10
      3  1a14				  -	      ERR
      4  1a14					      ENDIF
      5  1a14		       f6		      .byte.b	-10
      0  1a15					      EVAL8	-30
      1  1a15				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1a15				  -	      ECHO	"Erroneous position value", -30
      3  1a15				  -	      ERR
      4  1a15					      ENDIF
      5  1a15		       e2		      .byte.b	-30
      0  1a16					      EVAL8	0
      1  1a16				  -	      IF	(0 > 127) || (0 < -128)
      2  1a16				  -	      ECHO	"Erroneous position value", 0
      3  1a16				  -	      ERR
      4  1a16					      ENDIF
      5  1a16		       00		      .byte.b	0
      0  1a17					      EVAL8	0
      1  1a17				  -	      IF	(0 > 127) || (0 < -128)
      2  1a17				  -	      ECHO	"Erroneous position value", 0
      3  1a17				  -	      ERR
      4  1a17					      ENDIF
      5  1a17		       00		      .byte.b	0
      0  1a18					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      0  1a18					      EVAL8	-30
      1  1a18				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1a18				  -	      ECHO	"Erroneous position value", -30
      3  1a18				  -	      ERR
      4  1a18					      ENDIF
      5  1a18		       e2		      .byte.b	-30
      0  1a19					      EVAL8	-10
      1  1a19				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1a19				  -	      ECHO	"Erroneous position value", -10
      3  1a19				  -	      ERR
      4  1a19					      ENDIF
      5  1a19		       f6		      .byte.b	-10
      0  1a1a					      EVAL8	30
      1  1a1a				  -	      IF	(30 > 127) || (30 < -128)
      2  1a1a				  -	      ECHO	"Erroneous position value", 30
      3  1a1a				  -	      ERR
      4  1a1a					      ENDIF
      5  1a1a		       1e		      .byte.b	30
      0  1a1b					      EVAL8	40
      1  1a1b				  -	      IF	(40 > 127) || (40 < -128)
      2  1a1b				  -	      ECHO	"Erroneous position value", 40
      3  1a1b				  -	      ERR
      4  1a1b					      ENDIF
      5  1a1b		       28		      .byte.b	40
      0  1a1c					      EVAL8	40
      1  1a1c				  -	      IF	(40 > 127) || (40 < -128)
      2  1a1c				  -	      ECHO	"Erroneous position value", 40
      3  1a1c				  -	      ERR
      4  1a1c					      ENDIF
      5  1a1c		       28		      .byte.b	40
      0  1a1d					      EVAL8	30
      1  1a1d				  -	      IF	(30 > 127) || (30 < -128)
      2  1a1d				  -	      ECHO	"Erroneous position value", 30
      3  1a1d				  -	      ERR
      4  1a1d					      ENDIF
      5  1a1d		       1e		      .byte.b	30
      0  1a1e					      EVAL8	-10
      1  1a1e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1a1e				  -	      ECHO	"Erroneous position value", -10
      3  1a1e				  -	      ERR
      4  1a1e					      ENDIF
      5  1a1e		       f6		      .byte.b	-10
      0  1a1f					      EVAL8	-30
      1  1a1f				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1a1f				  -	      ECHO	"Erroneous position value", -30
      3  1a1f				  -	      ERR
      4  1a1f					      ENDIF
      5  1a1f		       e2		      .byte.b	-30
      0  1a20					      EVAL8	0
      1  1a20				  -	      IF	(0 > 127) || (0 < -128)
      2  1a20				  -	      ECHO	"Erroneous position value", 0
      3  1a20				  -	      ERR
      4  1a20					      ENDIF
      5  1a20		       00		      .byte.b	0
      0  1a21					      EVAL8	0
      1  1a21				  -	      IF	(0 > 127) || (0 < -128)
      2  1a21				  -	      ECHO	"Erroneous position value", 0
      3  1a21				  -	      ERR
      4  1a21					      ENDIF
      5  1a21		       00		      .byte.b	0
      0  1a22					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      0  1a22					      EVAL8	-30
      1  1a22				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1a22				  -	      ECHO	"Erroneous position value", -30
      3  1a22				  -	      ERR
      4  1a22					      ENDIF
      5  1a22		       e2		      .byte.b	-30
      0  1a23					      EVAL8	-10
      1  1a23				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1a23				  -	      ECHO	"Erroneous position value", -10
      3  1a23				  -	      ERR
      4  1a23					      ENDIF
      5  1a23		       f6		      .byte.b	-10
      0  1a24					      EVAL8	20
      1  1a24				  -	      IF	(20 > 127) || (20 < -128)
      2  1a24				  -	      ECHO	"Erroneous position value", 20
      3  1a24				  -	      ERR
      4  1a24					      ENDIF
      5  1a24		       14		      .byte.b	20
      0  1a25					      EVAL8	30
      1  1a25				  -	      IF	(30 > 127) || (30 < -128)
      2  1a25				  -	      ECHO	"Erroneous position value", 30
      3  1a25				  -	      ERR
      4  1a25					      ENDIF
      5  1a25		       1e		      .byte.b	30
      0  1a26					      EVAL8	30
      1  1a26				  -	      IF	(30 > 127) || (30 < -128)
      2  1a26				  -	      ECHO	"Erroneous position value", 30
      3  1a26				  -	      ERR
      4  1a26					      ENDIF
      5  1a26		       1e		      .byte.b	30
      0  1a27					      EVAL8	20
      1  1a27				  -	      IF	(20 > 127) || (20 < -128)
      2  1a27				  -	      ECHO	"Erroneous position value", 20
      3  1a27				  -	      ERR
      4  1a27					      ENDIF
      5  1a27		       14		      .byte.b	20
      0  1a28					      EVAL8	-10
      1  1a28				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1a28				  -	      ECHO	"Erroneous position value", -10
      3  1a28				  -	      ERR
      4  1a28					      ENDIF
      5  1a28		       f6		      .byte.b	-10
      0  1a29					      EVAL8	-30
      1  1a29				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1a29				  -	      ECHO	"Erroneous position value", -30
      3  1a29				  -	      ERR
      4  1a29					      ENDIF
      5  1a29		       e2		      .byte.b	-30
      0  1a2a					      EVAL8	0
      1  1a2a				  -	      IF	(0 > 127) || (0 < -128)
      2  1a2a				  -	      ECHO	"Erroneous position value", 0
      3  1a2a				  -	      ERR
      4  1a2a					      ENDIF
      5  1a2a		       00		      .byte.b	0
      0  1a2b					      EVAL8	0
      1  1a2b				  -	      IF	(0 > 127) || (0 < -128)
      2  1a2b				  -	      ECHO	"Erroneous position value", 0
      3  1a2b				  -	      ERR
      4  1a2b					      ENDIF
      5  1a2b		       00		      .byte.b	0
      0  1a2c					      PVAL	-30, -20, -10, 0, 0, -10, -20, -30
      0  1a2c					      EVAL8	-30
      1  1a2c				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1a2c				  -	      ECHO	"Erroneous position value", -30
      3  1a2c				  -	      ERR
      4  1a2c					      ENDIF
      5  1a2c		       e2		      .byte.b	-30
      0  1a2d					      EVAL8	-20
      1  1a2d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1a2d				  -	      ECHO	"Erroneous position value", -20
      3  1a2d				  -	      ERR
      4  1a2d					      ENDIF
      5  1a2d		       ec		      .byte.b	-20
      0  1a2e					      EVAL8	-10
      1  1a2e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1a2e				  -	      ECHO	"Erroneous position value", -10
      3  1a2e				  -	      ERR
      4  1a2e					      ENDIF
      5  1a2e		       f6		      .byte.b	-10
      0  1a2f					      EVAL8	0
      1  1a2f				  -	      IF	(0 > 127) || (0 < -128)
      2  1a2f				  -	      ECHO	"Erroneous position value", 0
      3  1a2f				  -	      ERR
      4  1a2f					      ENDIF
      5  1a2f		       00		      .byte.b	0
      0  1a30					      EVAL8	0
      1  1a30				  -	      IF	(0 > 127) || (0 < -128)
      2  1a30				  -	      ECHO	"Erroneous position value", 0
      3  1a30				  -	      ERR
      4  1a30					      ENDIF
      5  1a30		       00		      .byte.b	0
      0  1a31					      EVAL8	-10
      1  1a31				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1a31				  -	      ECHO	"Erroneous position value", -10
      3  1a31				  -	      ERR
      4  1a31					      ENDIF
      5  1a31		       f6		      .byte.b	-10
      0  1a32					      EVAL8	-20
      1  1a32				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1a32				  -	      ECHO	"Erroneous position value", -20
      3  1a32				  -	      ERR
      4  1a32					      ENDIF
      5  1a32		       ec		      .byte.b	-20
      0  1a33					      EVAL8	-30
      1  1a33				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1a33				  -	      ECHO	"Erroneous position value", -30
      3  1a33				  -	      ERR
      4  1a33					      ENDIF
      5  1a33		       e2		      .byte.b	-30
      0  1a34					      EVAL8	0
      1  1a34				  -	      IF	(0 > 127) || (0 < -128)
      2  1a34				  -	      ECHO	"Erroneous position value", 0
      3  1a34				  -	      ERR
      4  1a34					      ENDIF
      5  1a34		       00		      .byte.b	0
      0  1a35					      EVAL8	0
      1  1a35				  -	      IF	(0 > 127) || (0 < -128)
      2  1a35				  -	      ECHO	"Erroneous position value", 0
      3  1a35				  -	      ERR
      4  1a35					      ENDIF
      5  1a35		       00		      .byte.b	0
      0  1a36					      PVAL	-50, -40, -30, -20,- 20, -30, -40, -50
      0  1a36					      EVAL8	-50
      1  1a36				  -	      IF	(-50 > 127) || (-50 < -128)
      2  1a36				  -	      ECHO	"Erroneous position value", -50
      3  1a36				  -	      ERR
      4  1a36					      ENDIF
      5  1a36		       ce		      .byte.b	-50
      0  1a37					      EVAL8	-40
      1  1a37				  -	      IF	(-40 > 127) || (-40 < -128)
      2  1a37				  -	      ECHO	"Erroneous position value", -40
      3  1a37				  -	      ERR
      4  1a37					      ENDIF
      5  1a37		       d8		      .byte.b	-40
      0  1a38					      EVAL8	-30
      1  1a38				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1a38				  -	      ECHO	"Erroneous position value", -30
      3  1a38				  -	      ERR
      4  1a38					      ENDIF
      5  1a38		       e2		      .byte.b	-30
      0  1a39					      EVAL8	-20
      1  1a39				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1a39				  -	      ECHO	"Erroneous position value", -20
      3  1a39				  -	      ERR
      4  1a39					      ENDIF
      5  1a39		       ec		      .byte.b	-20
      0  1a3a					      EVAL8	- 20
      1  1a3a				  -	      IF	(- 20 > 127) || (- 20 < -128)
      2  1a3a				  -	      ECHO	"Erroneous position value", - 20
      3  1a3a				  -	      ERR
      4  1a3a					      ENDIF
      5  1a3a		       ec		      .byte.b	- 20
      0  1a3b					      EVAL8	-30
      1  1a3b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1a3b				  -	      ECHO	"Erroneous position value", -30
      3  1a3b				  -	      ERR
      4  1a3b					      ENDIF
      5  1a3b		       e2		      .byte.b	-30
      0  1a3c					      EVAL8	-40
      1  1a3c				  -	      IF	(-40 > 127) || (-40 < -128)
      2  1a3c				  -	      ECHO	"Erroneous position value", -40
      3  1a3c				  -	      ERR
      4  1a3c					      ENDIF
      5  1a3c		       d8		      .byte.b	-40
      0  1a3d					      EVAL8	-50
      1  1a3d				  -	      IF	(-50 > 127) || (-50 < -128)
      2  1a3d				  -	      ECHO	"Erroneous position value", -50
      3  1a3d				  -	      ERR
      4  1a3d					      ENDIF
      5  1a3d		       ce		      .byte.b	-50
      0  1a3e					      EVAL8	0
      1  1a3e				  -	      IF	(0 > 127) || (0 < -128)
      2  1a3e				  -	      ECHO	"Erroneous position value", 0
      3  1a3e				  -	      ERR
      4  1a3e					      ENDIF
      5  1a3e		       00		      .byte.b	0
      0  1a3f					      EVAL8	0
      1  1a3f				  -	      IF	(0 > 127) || (0 < -128)
      2  1a3f				  -	      ECHO	"Erroneous position value", 0
      3  1a3f				  -	      ERR
      4  1a3f					      ENDIF
      5  1a3f		       00		      .byte.b	0
    187  1a40
    188  1a40
    189  1a40
      0  1a40					      CHECK_BANK_SIZE	"BANK_EVAL"
      1  1a40		       02 40	   .TEMP      =	* - _BANK_START
 BANK_EVAL (1K) SIZE =  $240 , FREE= $1c0
      2  1a40					      ECHO	"BANK_EVAL", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1a40				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1a40				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_EVAL", " size=", * - ORIGIN
      5  1a40				  -	      ERR
      6  1a40					      ENDIF
    191  1a40
    192  1a40							;---------------------------------------------------------------------------------------------------
    193  1a40							; EOF
------- FILE ./chess.asm
------- FILE BANK_StateMachine@1#1.asm LEVEL 2 PASS 4
      0  1a40					      include	"BANK_StateMachine@1#1.asm"
      0  1a40					      SLOT	1
      1  1a40				  -	      IF	(1 < 0) || (1 > 3)
      2  1a40				  -	      ECHO	"Illegal bank address/segment location", 1
      3  1a40				  -	      ERR
      4  1a40					      ENDIF
      5  1a40				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  1a40				   _BANK_SLOT SET	1 * 64
      0  1a40					      ROMBANK	STATEMACHINE
      1  1fd1 ????				      SEG	STATEMACHINE
      2  1c00					      ORG	_ORIGIN
      3  1c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  1c00				   _BANK_START SET	*
      5  1c00				   STATEMACHINE_START SET	*
      6  1c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1c00				   STATEMACHINE SET	_BANK_SLOT + _CURRENT_BANK
      8  1c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  1c00
      4  1c00
      5  1c00							; Banks holding data (ply 0 doubles as WHITE, and ply 1 as BLACK)
      6  1c00
      7  1c00
      8  1c00		       00 10	   CURSOR_MOVE_SPEED =	16
      9  1c00		       00 14	   CAP_SPEED  =	20
     10  1c00		       00 28	   HOLD_DELAY =	40
     11  1c00
     12  1c00
     13  1c00							;---------------------------------------------------------------------------------------------------
     14  1c00
     15  1c00
     16  1c00							;---------------------------------------------------------------------------------------------------
     17  1c00
      0  1c00					      DEF	aiStartMoveGen
      1  1c00				   SLOT_aiStartMoveGen SET	_BANK_SLOT
      2  1c00				   BANK_aiStartMoveGen SET	SLOT_aiStartMoveGen + _CURRENT_BANK
      3  1c00				   aiStartMoveGen
      4  1c00				   TEMPORARY_VAR SET	Overlay
      5  1c00				   TEMPORARY_OFFSET SET	0
      6  1c00				   VAR_BOUNDARY_aiStartMoveGen SET	TEMPORARY_OFFSET
      7  1c00				   FUNCTION_NAME SET	aiStartMoveGen
     19  1c00					      SUBROUTINE
     20  1c00
      0  1c00					      REFER	AiStateMachine
      1  1c00					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c00				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c00					      ENDIF
      0  1c00					      VEND	aiStartMoveGen
      1  1c00				  -	      IFNCONST	aiStartMoveGen
      2  1c00				  -	      ECHO	"Incorrect VEND label", aiStartMoveGen
      3  1c00				  -	      ERR
      4  1c00					      ENDIF
      5  1c00		       00 a9	   VAREND_aiStartMoveGen =	TEMPORARY_VAR
     23  1c00
     24  1c00							; To assist with castling, generate the moves for the opponent, giving us effectively
     25  1c00							; a list of squares that are being attacked. The castling can't happen if the king is
     26  1c00							; in check or if the squares it would have to move over are in check
     27  1c00
     28  1c00							; we don't need to worry about this if K has moved, or relevant R has moved or if
     29  1c00							; the squares between are occupied. We can tell THAT by examining the movelist to see
     30  1c00							; if there are K-moves marked "FLAG_CASTLE" - and the relevant squares
     31  1c00
     32  1c00							;inc currentPly
     33  1c00							;jsr InitialiseMoveGeneration
     34  1c00
      0  1c00					      PHASE	AI_StepMoveGen
      1  1c00		       a9 0c		      lda	#AI_StepMoveGen
      2  1c02		       85 8b		      sta	aiState
     36  1c04		       60		      rts
     37  1c05
     38  1c05
     39  1c05							;---------------------------------------------------------------------------------------------------
     40  1c05
      0  1c05					      DEF	aiInCheckBackup
      1  1c05				   SLOT_aiInCheckBackup SET	_BANK_SLOT
      2  1c05				   BANK_aiInCheckBackup SET	SLOT_aiInCheckBackup + _CURRENT_BANK
      3  1c05				   aiInCheckBackup
      4  1c05				   TEMPORARY_VAR SET	Overlay
      5  1c05				   TEMPORARY_OFFSET SET	0
      6  1c05				   VAR_BOUNDARY_aiInCheckBackup SET	TEMPORARY_OFFSET
      7  1c05				   FUNCTION_NAME SET	aiInCheckBackup
     42  1c05					      SUBROUTINE
     43  1c05
      0  1c05					      REFER	AiStateMachine
      1  1c05					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c05				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c05					      ENDIF
      0  1c05					      VEND	aiInCheckBackup
      1  1c05				  -	      IFNCONST	aiInCheckBackup
      2  1c05				  -	      ECHO	"Incorrect VEND label", aiInCheckBackup
      3  1c05				  -	      ERR
      4  1c05					      ENDIF
      5  1c05		       00 a9	   VAREND_aiInCheckBackup =	TEMPORARY_VAR
     46  1c05
     47  1c05							; We're about to draw some large text on the screen
     48  1c05							; Make a backup copy of all of the row bitmaps, so that we can restore once text is done
     49  1c05
     50  1c05		       c6 84		      dec	drawCount
     51  1c07		       30 02		      bmi	.exit	; done all rows
     52  1c09		       a4 84		      ldy	drawCount
     53  1c0b				  -	      IF	0
     54  1c0b				  -	      jmp	SAFE_BackupBitmaps
     55  1c0b					      ENDIF
     56  1c0b
      0  1c0b				   .exit      PHASE	AI_InCheckDelay
      1  1c0b		       a9 1e		      lda	#AI_InCheckDelay
      2  1c0d		       85 8b		      sta	aiState
     58  1c0f		       60		      rts
     59  1c10
     60  1c10
     61  1c10							;---------------------------------------------------------------------------------------------------
     62  1c10
      0  1c10					      DEF	aiInCheckDelay
      1  1c10				   SLOT_aiInCheckDelay SET	_BANK_SLOT
      2  1c10				   BANK_aiInCheckDelay SET	SLOT_aiInCheckDelay + _CURRENT_BANK
      3  1c10				   aiInCheckDelay
      4  1c10				   TEMPORARY_VAR SET	Overlay
      5  1c10				   TEMPORARY_OFFSET SET	0
      6  1c10				   VAR_BOUNDARY_aiInCheckDelay SET	TEMPORARY_OFFSET
      7  1c10				   FUNCTION_NAME SET	aiInCheckDelay
     64  1c10					      SUBROUTINE
     65  1c10
      0  1c10					      REFER	AiStateMachine
      1  1c10					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c10				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c10					      ENDIF
      0  1c10					      VEND	aiInCheckDelay
      1  1c10				  -	      IFNCONST	aiInCheckDelay
      2  1c10				  -	      ECHO	"Incorrect VEND label", aiInCheckDelay
      3  1c10				  -	      ERR
      4  1c10					      ENDIF
      5  1c10		       00 a9	   VAREND_aiInCheckDelay =	TEMPORARY_VAR
     68  1c10
     69  1c10		       c6 89		      dec	mdelay
     70  1c12		       d0 08		      bne	.exit
     71  1c14
     72  1c14		       a9 00		      lda	#0
     73  1c16		       85 49		      sta	COLUBK
     74  1c18
      0  1c18					      PHASE	AI_BeginSelectMovePhase
      1  1c18		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  1c1a		       85 8b		      sta	aiState
     76  1c1c		       60	   .exit      rts
     77  1c1d
     78  1c1d
     79  1c1d							;---------------------------------------------------------------------------------------------------
     80  1c1d
      0  1c1d					      DEF	aiBeginSelectMovePhase
      1  1c1d				   SLOT_aiBeginSelectMovePhase SET	_BANK_SLOT
      2  1c1d				   BANK_aiBeginSelectMovePhase SET	SLOT_aiBeginSelectMovePhase + _CURRENT_BANK
      3  1c1d				   aiBeginSelectMovePhase
      4  1c1d				   TEMPORARY_VAR SET	Overlay
      5  1c1d				   TEMPORARY_OFFSET SET	0
      6  1c1d				   VAR_BOUNDARY_aiBeginSelectMovePhase SET	TEMPORARY_OFFSET
      7  1c1d				   FUNCTION_NAME SET	aiBeginSelectMovePhase
     82  1c1d					      SUBROUTINE
     83  1c1d
      0  1c1d					      REFER	AiStateMachine
      1  1c1d					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c1d				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c1d					      ENDIF
      0  1c1d					      VEND	aiBeginSelectMovePhase
      1  1c1d				  -	      IFNCONST	aiBeginSelectMovePhase
      2  1c1d				  -	      ECHO	"Incorrect VEND label", aiBeginSelectMovePhase
      3  1c1d				  -	      ERR
      4  1c1d					      ENDIF
      5  1c1d		       00 a9	   VAREND_aiBeginSelectMovePhase =	TEMPORARY_VAR
     86  1c1d
     87  1c1d
     88  1c1d		       a9 04		      lda	#$4
     89  1c1f		       85 46		      sta	COLUP0
     90  1c21		       a2 04		      ldx	#%100
     91  1c23		       86 4a		      stx	CTRLPF	; under
     92  1c25
     93  1c25		       a9 00		      lda	#0
     94  1c27		       85 89		      sta	mdelay	;?
     95  1c29		       85 8e		      sta	aiFlashPhase	; odd/even for flashing pieces
     96  1c2b
     97  1c2b		       a9 28		      lda	#CAP_SPEED*2
     98  1c2d		       85 8c		      sta	aiFlashDelay
     99  1c2f
    100  1c2f		       a9 ff		      lda	#-1
    101  1c31		       85 85		      sta	fromX12
    102  1c33		       85 86		      sta	toX12
    103  1c35
    104  1c35		       46 a1		      lsr	randomness
    105  1c37
    106  1c37
      0  1c37					      PHASE	AI_FlashComputerMove
      1  1c37		       a9 00		      lda	#AI_FlashComputerMove
      2  1c39		       85 8b		      sta	aiState
    108  1c3b		       60		      rts
    109  1c3c
    110  1c3c							;---------------------------------------------------------------------------------------------------
    111  1c3c
      0  1c3c					      DEF	aiFlashComputerMove
      1  1c3c				   SLOT_aiFlashComputerMove SET	_BANK_SLOT
      2  1c3c				   BANK_aiFlashComputerMove SET	SLOT_aiFlashComputerMove + _CURRENT_BANK
      3  1c3c				   aiFlashComputerMove
      4  1c3c				   TEMPORARY_VAR SET	Overlay
      5  1c3c				   TEMPORARY_OFFSET SET	0
      6  1c3c				   VAR_BOUNDARY_aiFlashComputerMove SET	TEMPORARY_OFFSET
      7  1c3c				   FUNCTION_NAME SET	aiFlashComputerMove
    113  1c3c					      SUBROUTINE
    114  1c3c
      0  1c3c					      REFER	AiStateMachine
      1  1c3c					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c3c				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c3c					      ENDIF
      0  1c3c					      VEND	aiFlashComputerMove
      1  1c3c				  -	      IFNCONST	aiFlashComputerMove
      2  1c3c				  -	      ECHO	"Incorrect VEND label", aiFlashComputerMove
      3  1c3c				  -	      ERR
      4  1c3c					      ENDIF
      5  1c3c		       00 a9	   VAREND_aiFlashComputerMove =	TEMPORARY_VAR
    117  1c3c
    118  1c3c		       a5 80		      lda	squareToDraw
    119  1c3e		       30 30		      bmi	.initial2	; startup - no computer move to show
    120  1c40
    121  1c40		       a5 8e		      lda	aiFlashPhase
    122  1c42		       4a		      lsr
    123  1c43		       b0 0c		      bcs	.noSwapside	; only check for SELECT/exit if piece is drawn
    124  1c45
    125  1c45		       ad 82 02 	      lda	SWCHB
    126  1c48		       29 02		      and	#SELECT_SWITCH
    127  1c4a		       d0 05		      bne	.noSwapside
    128  1c4c
      0  1c4c					      PHASE	AI_DebounceSelect
      1  1c4c		       a9 2b		      lda	#AI_DebounceSelect
      2  1c4e		       85 8b		      sta	aiState
    130  1c50		       60		      rts
    131  1c51				   .noSwapside
    132  1c51
    133  1c51							; "squareToDraw" is the piece that should flash while human waits
    134  1c51
    135  1c51		       ad 80 02 	      lda	SWCHA
    136  1c54		       29 f0		      and	#$F0	; UDLR bits
    137  1c56		       c9 f0		      cmp	#$F0	; all NOT pressed
    138  1c58		       f0 08		      beq	.nodir
    139  1c5a
    140  1c5a							; direction has been pressed, so transition out of flashing
    141  1c5a
    142  1c5a		       a9 01		      lda	#1
    143  1c5c		       85 8c		      sta	aiFlashDelay
    144  1c5e		       25 8e		      and	aiFlashPhase
    145  1c60		       f0 0e		      beq	.initial
    146  1c62
    147  1c62		       c6 8c	   .nodir     dec	aiFlashDelay
    148  1c64		       d0 0e		      bne	.exit	; don't flash
    149  1c66		       a9 28		      lda	#CAP_SPEED*2
    150  1c68		       85 8c		      sta	aiFlashDelay
    151  1c6a
    152  1c6a		       e6 8e		      inc	aiFlashPhase
    153  1c6c
    154  1c6c							; WARNING - local variables will not survive the following call...!
    155  1c6c		       20 cb f0 	      jsr	CopySinglePiece	;@0
    156  1c6f		       60		      rts
    157  1c70
    158  1c70				   .initial
    159  1c70
    160  1c70							;SWAP
      0  1c70				   .initial2  PHASE	AI_SelectStartSquare
      1  1c70		       a9 02		      lda	#AI_SelectStartSquare
      2  1c72		       85 8b		      sta	aiState
    162  1c74
    163  1c74		       60	   .exit      rts
    164  1c75
    165  1c75
    166  1c75							;---------------------------------------------------------------------------------------------------
    167  1c75
      0  1c75					      DEF	aiSelectStartSquare
      1  1c75				   SLOT_aiSelectStartSquare SET	_BANK_SLOT
      2  1c75				   BANK_aiSelectStartSquare SET	SLOT_aiSelectStartSquare + _CURRENT_BANK
      3  1c75				   aiSelectStartSquare
      4  1c75				   TEMPORARY_VAR SET	Overlay
      5  1c75				   TEMPORARY_OFFSET SET	0
      6  1c75				   VAR_BOUNDARY_aiSelectStartSquare SET	TEMPORARY_OFFSET
      7  1c75				   FUNCTION_NAME SET	aiSelectStartSquare
    169  1c75					      SUBROUTINE
    170  1c75
      0  1c75					      REFER	AiStateMachine
      1  1c75					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c75				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c75					      ENDIF
      0  1c75					      VEND	aiSelectStartSquare
      1  1c75				  -	      IFNCONST	aiSelectStartSquare
      2  1c75				  -	      ECHO	"Incorrect VEND label", aiSelectStartSquare
      3  1c75				  -	      ERR
      4  1c75					      ENDIF
      5  1c75		       00 a9	   VAREND_aiSelectStartSquare =	TEMPORARY_VAR
    173  1c75
      0  1c75					      NEXT_RANDOM
      1  1c75		       a5 81		      lda	rnd
      2  1c77		       4a		      lsr
      3  1c78		       90 02		      bcc	.skipEOR
      4  1c7a		       49 fe		      eor	#RND_EOR_VAL
      5  1c7c		       85 81	   .skipEOR   sta	rnd
    175  1c7e
    176  1c7e		       ad 82 02 	      lda	SWCHB
    177  1c81		       29 02		      and	#SELECT_SWITCH
    178  1c83		       f0 34		      beq	.swapside
    179  1c85
      0  1c85					      CALL	moveCursor	;@2
      1  1c85				  -	      IF	SLOT_moveCursor == _BANK_SLOT
      2  1c85				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1c85				  -	      ECHO	"Cannot switch bank in use for", moveCursor
      4  1c85				  -	      ERR
      5  1c85					      ENDIF
      6  1c85		       a9 93		      lda	#BANK_moveCursor
      7  1c87		       85 3f		      sta	SET_BANK
      8  1c89		       20 00 f8 	      jsr	moveCursor
    181  1c8c
    182  1c8c							; Search the player's movelist for the square, so we can set cursor colour
    183  1c8c
    184  1c8c		       a9 89		      lda	#RAMBANK_PLY+1	;currentPly
    185  1c8e		       85 3e		      sta	SET_BANK_RAM	;@2
    186  1c90
    187  1c90		       a5 88		      lda	cursorX12
    188  1c92		       85 85		      sta	fromX12
    189  1c94
      0  1c94					      ldy@PLY	moveIndex
      1  1c94		       ac cf f9 	      ldy	moveIndex
    191  1c97		       30 0d		      bmi	.done
    192  1c99
    193  1c99		       d9 00 f8    .scan      cmp	MoveFrom,y
    194  1c9c		       f0 03		      beq	.scanned
    195  1c9e		       88		      dey
    196  1c9f		       10 f8		      bpl	.scan
    197  1ca1
      0  1ca1				   .scanned   lda@PLY	MovePiece,y
      1  1ca1		       b9 00 f9 	      lda	MovePiece,y
    199  1ca4		       85 96		      sta	fromPiece
    200  1ca6
    201  1ca6		       c6 8a	   .done      dec	ccur	; pulse colour for valid squares
      0  1ca8					      CALL	setCursorColours
      1  1ca8				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  1ca8				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1ca8				  -	      ECHO	"Cannot switch bank in use for", setCursorColours
      4  1ca8				  -	      ERR
      5  1ca8					      ENDIF
      6  1ca8		       a9 93		      lda	#BANK_setCursorColours
      7  1caa		       85 3f		      sta	SET_BANK
      8  1cac		       20 4a f8 	      jsr	setCursorColours
    203  1caf
    204  1caf		       98		      tya
    205  1cb0		       05 4c		      ora	INPT4
    206  1cb2		       30 04		      bmi	.exit	; illegal square or no button press
    207  1cb4
      0  1cb4					      PHASE	AI_StartSquareSelected
      1  1cb4		       a9 03		      lda	#AI_StartSquareSelected
      2  1cb6		       85 8b		      sta	aiState
    209  1cb8
    210  1cb8		       60	   .exit      rts
    211  1cb9
    212  1cb9
    213  1cb9
    214  1cb9				   .swapside
    215  1cb9
      0  1cb9					      PHASE	AI_DebounceSelect
      1  1cb9		       a9 2b		      lda	#AI_DebounceSelect
      2  1cbb		       85 8b		      sta	aiState
    217  1cbd		       60		      rts
    218  1cbe
    219  1cbe							;---------------------------------------------------------------------------------------------------
    220  1cbe
      0  1cbe					      DEF	aiDebounceSelect
      1  1cbe				   SLOT_aiDebounceSelect SET	_BANK_SLOT
      2  1cbe				   BANK_aiDebounceSelect SET	SLOT_aiDebounceSelect + _CURRENT_BANK
      3  1cbe				   aiDebounceSelect
      4  1cbe				   TEMPORARY_VAR SET	Overlay
      5  1cbe				   TEMPORARY_OFFSET SET	0
      6  1cbe				   VAR_BOUNDARY_aiDebounceSelect SET	TEMPORARY_OFFSET
      7  1cbe				   FUNCTION_NAME SET	aiDebounceSelect
    222  1cbe					      SUBROUTINE
    223  1cbe
    224  1cbe		       ad 82 02 	      lda	SWCHB
    225  1cc1		       29 02		      and	#SELECT_SWITCH
    226  1cc3		       f0 17		      beq	.exit	; SELECT still pressed
    227  1cc5
    228  1cc5		       a5 95		      lda	sideToMove
    229  1cc7		       49 40		      eor	#HUMAN
    230  1cc9		       85 95		      sta	sideToMove
    231  1ccb
      0  1ccb					      NEGEVAL
      1  1ccb
      2  1ccb		       38		      sec
      3  1ccc		       a9 00		      lda	#0
      4  1cce		       e5 8f		      sbc	Evaluation
      5  1cd0		       85 8f		      sta	Evaluation
      6  1cd2		       a9 00		      lda	#0
      7  1cd4		       e5 90		      sbc	Evaluation+1
      8  1cd6		       85 90		      sta	Evaluation+1
    233  1cd8
      0  1cd8					      PHASE	AI_ComputerMove
      1  1cd8		       a9 13		      lda	#AI_ComputerMove
      2  1cda		       85 8b		      sta	aiState
    235  1cdc		       60	   .exit      rts
    236  1cdd
    237  1cdd
    238  1cdd							;---------------------------------------------------------------------------------------------------
    239  1cdd
      0  1cdd					      DEF	aiDrawMoves
      1  1cdd				   SLOT_aiDrawMoves SET	_BANK_SLOT
      2  1cdd				   BANK_aiDrawMoves SET	SLOT_aiDrawMoves + _CURRENT_BANK
      3  1cdd				   aiDrawMoves
      4  1cdd				   TEMPORARY_VAR SET	Overlay
      5  1cdd				   TEMPORARY_OFFSET SET	0
      6  1cdd				   VAR_BOUNDARY_aiDrawMoves SET	TEMPORARY_OFFSET
      7  1cdd				   FUNCTION_NAME SET	aiDrawMoves
    241  1cdd					      SUBROUTINE
    242  1cdd
      0  1cdd					      REFER	AiStateMachine
      1  1cdd					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1cdd				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1cdd					      ENDIF
      0  1cdd					      VEND	aiDrawMoves
      1  1cdd				  -	      IFNCONST	aiDrawMoves
      2  1cdd				  -	      ECHO	"Incorrect VEND label", aiDrawMoves
      3  1cdd				  -	      ERR
      4  1cdd					      ENDIF
      5  1cdd		       00 a9	   VAREND_aiDrawMoves =	TEMPORARY_VAR
    245  1cdd
    246  1cdd		       c6 8a		      dec	ccur
      0  1cdf					      CALL	setCursorColours
      1  1cdf				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  1cdf				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1cdf				  -	      ECHO	"Cannot switch bank in use for", setCursorColours
      4  1cdf				  -	      ERR
      5  1cdf					      ENDIF
      6  1cdf		       a9 93		      lda	#BANK_setCursorColours
      7  1ce1		       85 3f		      sta	SET_BANK
      8  1ce3		       20 4a f8 	      jsr	setCursorColours
    248  1ce6
    249  1ce6		       c6 89		      dec	mdelay
    250  1ce8		       d0 25		      bne	.exit
    251  1cea		       a9 01		      lda	#1	; larger number will slow the draw of available moves
    252  1cec		       85 89		      sta	mdelay	; once triggered, runs always
    253  1cee
    254  1cee		       a5 8d		      lda	aiMoveIndex
    255  1cf0		       10 09		      bpl	.valid
    256  1cf2
    257  1cf2		       a9 89		      lda	#RAMBANK_PLY+1
    258  1cf4		       85 3e		      sta	SET_BANK_RAM	;@2
      0  1cf6					      lda@PLY	moveIndex
      1  1cf6		       ad cf f9 	      lda	moveIndex
    260  1cf9		       85 8d		      sta	aiMoveIndex
    261  1cfb				   .valid
    262  1cfb
    263  1cfb		       20 1c f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    264  1cfe		       a5 8d		      lda	aiMoveIndex
    265  1d00		       10 19		      bpl	.unsure	; still drawing in this phase
    266  1d02
    267  1d02		       a9 14		      lda	#CAP_SPEED
    268  1d04		       85 89		      sta	mdelay
    269  1d06
    270  1d06		       a9 00		      lda	#0
    271  1d08		       85 8e		      sta	aiFlashPhase	; controls odd/even exit of flashing
    272  1d0a
      0  1d0a					      PHASE	AI_ShowMoveCaptures
      1  1d0a		       a9 05		      lda	#AI_ShowMoveCaptures
      2  1d0c		       85 8b		      sta	aiState
    274  1d0e		       60		      rts
    275  1d0f
    276  1d0f				   .exit
    277  1d0f
    278  1d0f							; Initial piece selection has happened, but the button hasn't been released yet
    279  1d0f							; AND we're still in the waiting phase to see if the button was held long enough for move show
    280  1d0f
    281  1d0f		       a5 4c		      lda	INPT4
    282  1d11		       10 08		      bpl	.unsure	; button still pressed, so still unsure what to do
    283  1d13
    284  1d13							; Aha! Button released, so we know the selected piece and can start flashing it
    285  1d13							; and allowing movement of the selector to a destination square...
    286  1d13
    287  1d13		       a9 18		      lda	#6*4
    288  1d15		       85 8a		      sta	ccur	; bright green square for selection
    289  1d17
      0  1d17					      PHASE	AI_SelectDestinationSquare
      1  1d17		       a9 08		      lda	#AI_SelectDestinationSquare
      2  1d19		       85 8b		      sta	aiState
    291  1d1b
    292  1d1b		       60	   .unsure    rts
    293  1d1c
    294  1d1c
    295  1d1c							;---------------------------------------------------------------------------------------------------
    296  1d1c
      0  1d1c					      DEF	showMoveOptions
      1  1d1c				   SLOT_showMoveOptions SET	_BANK_SLOT
      2  1d1c				   BANK_showMoveOptions SET	SLOT_showMoveOptions + _CURRENT_BANK
      3  1d1c				   showMoveOptions
      4  1d1c				   TEMPORARY_VAR SET	Overlay
      5  1d1c				   TEMPORARY_OFFSET SET	0
      6  1d1c				   VAR_BOUNDARY_showMoveOptions SET	TEMPORARY_OFFSET
      7  1d1c				   FUNCTION_NAME SET	showMoveOptions
    298  1d1c					      SUBROUTINE
    299  1d1c
      0  1d1c					      REFER	aiDrawMoves
      1  1d1c					      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  1d1c				   TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  1d1c					      ENDIF
      0  1d1c					      REFER	aiUnDrawTargetSquares
      1  1d1c				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  1d1c				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  1d1c					      ENDIF
    302  1d1c
      0  1d1c					      VAR	__saveIdx, 1
      1  1d1c		       00 a9	   __saveIdx  =	TEMPORARY_VAR
      2  1d1c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1d1c
      4  1d1c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1d1c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1d1c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1d1c					      ENDIF
      8  1d1c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1d1c				  -	      ECHO	"Temporary Variable", __saveIdx, "overflow!"
     10  1d1c				  -	      ERR
     11  1d1c					      ENDIF
     12  1d1c					      LIST	ON
      0  1d1c					      VAR	__piece, 1
      1  1d1c		       00 aa	   __piece    =	TEMPORARY_VAR
      2  1d1c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1d1c
      4  1d1c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1d1c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1d1c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1d1c					      ENDIF
      8  1d1c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1d1c				  -	      ECHO	"Temporary Variable", __piece, "overflow!"
     10  1d1c				  -	      ERR
     11  1d1c					      ENDIF
     12  1d1c					      LIST	ON
    305  1d1c
      0  1d1c					      VEND	showMoveOptions
      1  1d1c				  -	      IFNCONST	showMoveOptions
      2  1d1c				  -	      ECHO	"Incorrect VEND label", showMoveOptions
      3  1d1c				  -	      ERR
      4  1d1c					      ENDIF
      5  1d1c		       00 ab	   VAREND_showMoveOptions =	TEMPORARY_VAR
    307  1d1c
    308  1d1c							; place a marker on the board for any square matching the piece
    309  1d1c							; EXCEPT for squares which are occupied (we'll flash those later)
    310  1d1c
    311  1d1c		       a6 8d	   .next      ldx	aiMoveIndex
    312  1d1e		       86 a9		      stx	__saveIdx
    313  1d20		       30 4c		      bmi	.skip
    314  1d22
    315  1d22		       ad 84 02 	      lda	INTIM
    316  1d25		       c9 2b		      cmp	#2+SPEEDOF_COPYSINGLEPIECE
    317  1d27		       90 45		      bcc	.skip
    318  1d29
    319  1d29		       c6 8d		      dec	aiMoveIndex
    320  1d2b
    321  1d2b		       a9 89		      lda	#RAMBANK_PLY+1
    322  1d2d		       85 3e		      sta	SET_BANK_RAM	;@2
    323  1d2f
      0  1d2f					      lda@PLY	MoveFrom,x
      1  1d2f		       bd 00 f8 	      lda	MoveFrom,x
    325  1d32		       c5 85		      cmp	fromX12
    326  1d34		       d0 e6		      bne	.next
    327  1d36
      0  1d36					      lda@PLY	MoveTo,x
      1  1d36		       bd 64 f8 	      lda	MoveTo,x
    329  1d39		       85 80		      sta	squareToDraw
    330  1d3b
      0  1d3b					      lda@PLY	MovePiece,x
      1  1d3b		       bd 00 f9 	      lda	MovePiece,x
    332  1d3e		       85 aa		      sta	__piece
    333  1d40
    334  1d40							; If it's a pawn promote (duplicate "to" AND piece different (TODO) then skip others)
    335  1d40							; TODO this could/will fail on sorted lists. MMh.
    336  1d40
    337  1d40		       ca		      dex
    338  1d41		       30 16		      bmi	.prom
    339  1d43
      0  1d43					      lda@PLY	MoveTo,x
      1  1d43		       bd 64 f8 	      lda	MoveTo,x
    341  1d46		       c5 80		      cmp	squareToDraw
    342  1d48		       d0 0f		      bne	.prom
    343  1d4a
      0  1d4a					      lda@PLY	MovePiece,x
      1  1d4a		       bd 00 f9 	      lda	MovePiece,x
    345  1d4d		       45 aa		      eor	__piece
    346  1d4f		       29 0f		      and	#PIECE_MASK
    347  1d51		       f0 06		      beq	.prom	; same piece type so not a promote
    348  1d53
    349  1d53		       c6 8d		      dec	aiMoveIndex
    350  1d55		       c6 8d		      dec	aiMoveIndex
    351  1d57		       c6 8d		      dec	aiMoveIndex
    352  1d59				   .prom
    353  1d59
    354  1d59		       a4 80		      ldy	squareToDraw
    355  1d5b
    356  1d5b		       a9 d1		      lda	#RAMBANK_BOARD
    357  1d5d		       85 3e		      sta	SET_BANK_RAM	;@3
    358  1d5f		       b9 79 fc 	      lda	Board,y
    359  1d62		       29 0f		      and	#PIECE_MASK
    360  1d64		       d0 b6		      bne	.next	; don't draw dots on captures - they are flashed later
    361  1d66
    362  1d66
    363  1d66							;lda INTIM
    364  1d66							;cmp #SPEEDOF_COPYSINGLEPIECE
    365  1d66							;bcc .skip
    366  1d66
    367  1d66							;lda aiMoveIndex
    368  1d66							;sta __saveIdx
    369  1d66
    370  1d66							; Draw the marker..."?
    371  1d66							; WARNING - local variables will not survive the following call...!
    372  1d66
    373  1d66		       a0 1c		      ldy	#INDEX_WHITE_MARKER_on_WHITE_SQUARE_0
    374  1d68		       20 73 f5 	      jsr	CopySetupForMarker	;@this
    375  1d6b		       4c d2 f0 	      jmp	InterceptMarkerCopy	;@0
    376  1d6e
    377  1d6e
    378  1d6e
    379  1d6e		       a5 a9	   .skip      lda	__saveIdx
    380  1d70		       85 8d		      sta	aiMoveIndex
    381  1d72		       60		      rts
    382  1d73
    383  1d73
    384  1d73							;---------------------------------------------------------------------------------------------------
    385  1d73
      0  1d73					      DEF	CopySetupForMarker
      1  1d73				   SLOT_CopySetupForMarker SET	_BANK_SLOT
      2  1d73				   BANK_CopySetupForMarker SET	SLOT_CopySetupForMarker + _CURRENT_BANK
      3  1d73				   CopySetupForMarker
      4  1d73				   TEMPORARY_VAR SET	Overlay
      5  1d73				   TEMPORARY_OFFSET SET	0
      6  1d73				   VAR_BOUNDARY_CopySetupForMarker SET	TEMPORARY_OFFSET
      7  1d73				   FUNCTION_NAME SET	CopySetupForMarker
    387  1d73					      SUBROUTINE
    388  1d73
      0  1d73					      REFER	showMoveOptions
      1  1d73					      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  1d73				   TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  1d73					      ENDIF
      0  1d73					      REFER	showPromoteOptions
      1  1d73				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  1d73				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  1d73					      ENDIF
    391  1d73
      0  1d73					      VAR	__pieceColour2b, 1
      1  1d73		       00 ab	   __pieceColour2b =	TEMPORARY_VAR
      2  1d73				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1d73
      4  1d73				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1d73				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1d73				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1d73					      ENDIF
      8  1d73				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1d73				  -	      ECHO	"Temporary Variable", __pieceColour2b, "overflow!"
     10  1d73				  -	      ERR
     11  1d73					      ENDIF
     12  1d73					      LIST	ON
      0  1d73					      VAR	__tmpb, 1
      1  1d73		       00 ac	   __tmpb     =	TEMPORARY_VAR
      2  1d73				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1d73
      4  1d73				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1d73				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1d73				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1d73					      ENDIF
      8  1d73				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1d73				  -	      ECHO	"Temporary Variable", __tmpb, "overflow!"
     10  1d73				  -	      ERR
     11  1d73					      ENDIF
     12  1d73					      LIST	ON
      0  1d73					      VAR	__shiftxb, 1
      1  1d73		       00 ad	   __shiftxb  =	TEMPORARY_VAR
      2  1d73				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1d73
      4  1d73				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1d73				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1d73				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1d73					      ENDIF
      8  1d73				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1d73				  -	      ECHO	"Temporary Variable", __shiftxb, "overflow!"
     10  1d73				  -	      ERR
     11  1d73					      ENDIF
     12  1d73					      LIST	ON
    395  1d73
      0  1d73					      VEND	CopySetupForMarker
      1  1d73				  -	      IFNCONST	CopySetupForMarker
      2  1d73				  -	      ECHO	"Incorrect VEND label", CopySetupForMarker
      3  1d73				  -	      ERR
      4  1d73					      ENDIF
      5  1d73		       00 ae	   VAREND_CopySetupForMarker =	TEMPORARY_VAR
    397  1d73
    398  1d73
    399  1d73							; y = base shape
    400  1d73							; figure colouration of square
    401  1d73
    402  1d73		       a5 80		      lda	squareToDraw
    403  1d75
    404  1d75		       a2 0a		      ldx	#10
    405  1d77		       38		      sec
    406  1d78		       e9 0a	   .sub10     sbc	#10
    407  1d7a		       ca		      dex
    408  1d7b		       b0 fb		      bcs	.sub10
    409  1d7d		       69 08		      adc	#8
    410  1d7f		       85 ad		      sta	__shiftxb
    411  1d81		       86 ac		      stx	__tmpb
    412  1d83		       65 ac		      adc	__tmpb
    413  1d85
    414  1d85
    415  1d85		       29 01		      and	#1
    416  1d87							;eor #1
    417  1d87		       f0 02		      beq	.white
    418  1d89		       a9 24		      lda	#36
    419  1d8b				   .white
    420  1d8b		       85 ab		      sta	__pieceColour2b	; actually SQUARE black/white
    421  1d8d
    422  1d8d		       a5 95		      lda	sideToMove
    423  1d8f		       0a		      asl
    424  1d90		       90 02		      bcc	.blackAdjust
    425  1d92		       09 10		      ora	#16	; switch white pieces
    426  1d94		       4a	   .blackAdjust lsr
    427  1d95		       29 0f		      and	#%1111
    428  1d97		       aa		      tax
    429  1d98
    430  1d98		       a5 ad		      lda	__shiftxb
    431  1d9a		       29 03		      and	#3	; shift position in P
    432  1d9c		       85 ad		      sta	__shiftxb
    433  1d9e
    434  1d9e		       98		      tya
    435  1d9f		       18		      clc
    436  1da0		       65 ad		      adc	__shiftxb
    437  1da2		       18		      clc
    438  1da3		       65 ab		      adc	__pieceColour2b
    439  1da5		       a8		      tay
    440  1da6		       60		      rts
    441  1da7
    442  1da7
    443  1da7							;---------------------------------------------------------------------------------------------------
    444  1da7
      0  1da7					      DEF	aiUnDrawTargetSquares
      1  1da7				   SLOT_aiUnDrawTargetSquares SET	_BANK_SLOT
      2  1da7				   BANK_aiUnDrawTargetSquares SET	SLOT_aiUnDrawTargetSquares + _CURRENT_BANK
      3  1da7				   aiUnDrawTargetSquares
      4  1da7				   TEMPORARY_VAR SET	Overlay
      5  1da7				   TEMPORARY_OFFSET SET	0
      6  1da7				   VAR_BOUNDARY_aiUnDrawTargetSquares SET	TEMPORARY_OFFSET
      7  1da7				   FUNCTION_NAME SET	aiUnDrawTargetSquares
    446  1da7					      SUBROUTINE
    447  1da7
      0  1da7					      REFER	AiStateMachine
      1  1da7					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1da7				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1da7					      ENDIF
      0  1da7					      VEND	aiUnDrawTargetSquares
      1  1da7				  -	      IFNCONST	aiUnDrawTargetSquares
      2  1da7				  -	      ECHO	"Incorrect VEND label", aiUnDrawTargetSquares
      3  1da7				  -	      ERR
      4  1da7					      ENDIF
      5  1da7		       00 a9	   VAREND_aiUnDrawTargetSquares =	TEMPORARY_VAR
    450  1da7
    451  1da7
    452  1da7		       c6 8a		      dec	ccur
      0  1da9					      CALL	setCursorColours
      1  1da9				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  1da9				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1da9				  -	      ECHO	"Cannot switch bank in use for", setCursorColours
      4  1da9				  -	      ERR
      5  1da9					      ENDIF
      6  1da9		       a9 93		      lda	#BANK_setCursorColours
      7  1dab		       85 3f		      sta	SET_BANK
      8  1dad		       20 4a f8 	      jsr	setCursorColours
    454  1db0
    455  1db0		       c6 89		      dec	mdelay
    456  1db2		       d0 1c		      bne	.exit
    457  1db4		       a9 01		      lda	#1
    458  1db6		       85 89		      sta	mdelay	; once triggered, runs always
    459  1db8
    460  1db8		       a5 8d		      lda	aiMoveIndex
    461  1dba		       10 09		      bpl	.valid
    462  1dbc
    463  1dbc		       a9 89		      lda	#RAMBANK_PLY+1
    464  1dbe		       85 3e		      sta	SET_BANK_RAM	;@2
      0  1dc0					      lda@PLY	moveIndex
      1  1dc0		       ad cf f9 	      lda	moveIndex
    466  1dc3		       85 8d		      sta	aiMoveIndex
    467  1dc5				   .valid
    468  1dc5
    469  1dc5		       20 1c f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    470  1dc8		       a5 8d		      lda	aiMoveIndex
    471  1dca		       10 04		      bpl	.exit	; still drawing in this phase
    472  1dcc
      0  1dcc					      PHASE	AI_SelectStartSquare
      1  1dcc		       a9 02		      lda	#AI_SelectStartSquare
      2  1dce		       85 8b		      sta	aiState
    474  1dd0
    475  1dd0		       60	   .exit      rts
    476  1dd1
    477  1dd1
    478  1dd1							;---------------------------------------------------------------------------------------------------
    479  1dd1
    480  1dd1
      0  1dd1					      DEF	aiShowMoveCaptures
      1  1dd1				   SLOT_aiShowMoveCaptures SET	_BANK_SLOT
      2  1dd1				   BANK_aiShowMoveCaptures SET	SLOT_aiShowMoveCaptures + _CURRENT_BANK
      3  1dd1				   aiShowMoveCaptures
      4  1dd1				   TEMPORARY_VAR SET	Overlay
      5  1dd1				   TEMPORARY_OFFSET SET	0
      6  1dd1				   VAR_BOUNDARY_aiShowMoveCaptures SET	TEMPORARY_OFFSET
      7  1dd1				   FUNCTION_NAME SET	aiShowMoveCaptures
    482  1dd1					      SUBROUTINE
    483  1dd1
      0  1dd1					      REFER	AiStateMachine
      1  1dd1					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1dd1				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1dd1					      ENDIF
      0  1dd1					      VEND	aiShowMoveCaptures
      1  1dd1				  -	      IFNCONST	aiShowMoveCaptures
      2  1dd1				  -	      ECHO	"Incorrect VEND label", aiShowMoveCaptures
      3  1dd1				  -	      ERR
      4  1dd1					      ENDIF
      5  1dd1		       00 a9	   VAREND_aiShowMoveCaptures =	TEMPORARY_VAR
    486  1dd1
    487  1dd1							; draw/undraw ALL captured pieces
    488  1dd1							; we should do this an even number of times so that pieces don't disappEOR
    489  1dd1
    490  1dd1		       c6 8a		      dec	ccur
      0  1dd3					      CALL	setCursorColours
      1  1dd3				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  1dd3				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1dd3				  -	      ECHO	"Cannot switch bank in use for", setCursorColours
      4  1dd3				  -	      ERR
      5  1dd3					      ENDIF
      6  1dd3		       a9 93		      lda	#BANK_setCursorColours
      7  1dd5		       85 3f		      sta	SET_BANK
      8  1dd7		       20 4a f8 	      jsr	setCursorColours
    492  1dda
    493  1dda		       c6 89		      dec	mdelay	; flash speed UNVARYING despite draw happening
    494  1ddc
    495  1ddc		       a5 8d		      lda	aiMoveIndex
    496  1dde		       10 09		      bpl	.valid	; guaranteed -1 on 1st call
    497  1de0		       a9 89		      lda	#RAMBANK_PLY+1
    498  1de2		       85 3e		      sta	SET_BANK_RAM	;@2
      0  1de4					      lda@PLY	moveIndex
      1  1de4		       ad cf f9 	      lda	moveIndex
    500  1de7		       85 8d		      sta	aiMoveIndex
    501  1de9				   .valid
    502  1de9
    503  1de9							;lda #BANK_showMoveCaptures
    504  1de9							;sta SET_BANK;@0
    505  1de9
    506  1de9		       20 f7 f2 	      jsr	showMoveCaptures	;@0
    507  1dec		       a5 8d		      lda	aiMoveIndex
    508  1dee		       10 06		      bpl	.exit
    509  1df0
    510  1df0		       e6 8e		      inc	aiFlashPhase
    511  1df2
      0  1df2					      PHASE	AI_SlowFlash
      1  1df2		       a9 06		      lda	#AI_SlowFlash
      2  1df4		       85 8b		      sta	aiState
    513  1df6
    514  1df6		       60	   .exit      rts
    515  1df7
    516  1df7
    517  1df7							;---------------------------------------------------------------------------------------------------
    518  1df7
      0  1df7					      DEF	aiSlowFlash
      1  1df7				   SLOT_aiSlowFlash SET	_BANK_SLOT
      2  1df7				   BANK_aiSlowFlash SET	SLOT_aiSlowFlash + _CURRENT_BANK
      3  1df7				   aiSlowFlash
      4  1df7				   TEMPORARY_VAR SET	Overlay
      5  1df7				   TEMPORARY_OFFSET SET	0
      6  1df7				   VAR_BOUNDARY_aiSlowFlash SET	TEMPORARY_OFFSET
      7  1df7				   FUNCTION_NAME SET	aiSlowFlash
    520  1df7					      SUBROUTINE
    521  1df7
      0  1df7					      REFER	AiStateMachine
      1  1df7					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1df7				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1df7					      ENDIF
      0  1df7					      VEND	aiSlowFlash
      1  1df7				  -	      IFNCONST	aiSlowFlash
      2  1df7				  -	      ECHO	"Incorrect VEND label", aiSlowFlash
      3  1df7				  -	      ERR
      4  1df7					      ENDIF
      5  1df7		       00 a9	   VAREND_aiSlowFlash =	TEMPORARY_VAR
    524  1df7
    525  1df7							; Joystick button is held down, so we're displaying the available moves
    526  1df7							; They have all been drawn, so now we "slow" flash any pieces that can be captures
    527  1df7
    528  1df7		       c6 8a		      dec	ccur
      0  1df9					      CALL	setCursorColours
      1  1df9				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  1df9				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1df9				  -	      ECHO	"Cannot switch bank in use for", setCursorColours
      4  1df9				  -	      ERR
      5  1df9					      ENDIF
      6  1df9		       a9 93		      lda	#BANK_setCursorColours
      7  1dfb		       85 3f		      sta	SET_BANK
      8  1dfd		       20 4a f8 	      jsr	setCursorColours
    530  1e00
    531  1e00		       a5 8e		      lda	aiFlashPhase
    532  1e02		       29 01		      and	#1
    533  1e04		       d0 04		      bne	.notEven	; only exit after even # EOR-draws
    534  1e06
    535  1e06		       a5 4c		      lda	INPT4
    536  1e08		       30 0d		      bmi	.butpress	; exit on button release
    537  1e0a
    538  1e0a				   .notEven
    539  1e0a
    540  1e0a							; Wait for delay to expire then back and flash 'em again
    541  1e0a
    542  1e0a		       c6 89		      dec	mdelay
    543  1e0c		       10 08		      bpl	.slowWait
    544  1e0e
    545  1e0e		       a9 14		      lda	#CAP_SPEED
    546  1e10		       85 89		      sta	mdelay
    547  1e12
      0  1e12					      PHASE	AI_ShowMoveCaptures	; go back and rEORdraw all captures again
      1  1e12		       a9 05		      lda	#AI_ShowMoveCaptures
      2  1e14		       85 8b		      sta	aiState
    549  1e16
    550  1e16		       60	   .slowWait  rts
    551  1e17
    552  1e17
    553  1e17		       a9 01	   .butpress  lda	#1
    554  1e19		       85 89		      sta	mdelay
    555  1e1b
      0  1e1b					      PHASE	AI_UnDrawTargetSquares
      1  1e1b		       a9 07		      lda	#AI_UnDrawTargetSquares
      2  1e1d		       85 8b		      sta	aiState
    557  1e1f		       60		      rts
    558  1e20
    559  1e20
    560  1e20							;---------------------------------------------------------------------------------------------------
    561  1e20
      0  1e20					      DEF	aiSelectDestinationSquare
      1  1e20				   SLOT_aiSelectDestinationSquare SET	_BANK_SLOT
      2  1e20				   BANK_aiSelectDestinationSquare SET	SLOT_aiSelectDestinationSquare + _CURRENT_BANK
      3  1e20				   aiSelectDestinationSquare
      4  1e20				   TEMPORARY_VAR SET	Overlay
      5  1e20				   TEMPORARY_OFFSET SET	0
      6  1e20				   VAR_BOUNDARY_aiSelectDestinationSquare SET	TEMPORARY_OFFSET
      7  1e20				   FUNCTION_NAME SET	aiSelectDestinationSquare
    563  1e20					      SUBROUTINE
    564  1e20
      0  1e20					      REFER	AiStateMachine
      1  1e20					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1e20				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1e20					      ENDIF
      0  1e20					      VEND	aiSelectDestinationSquare
      1  1e20				  -	      IFNCONST	aiSelectDestinationSquare
      2  1e20				  -	      ECHO	"Incorrect VEND label", aiSelectDestinationSquare
      3  1e20				  -	      ERR
      4  1e20					      ENDIF
      5  1e20		       00 a9	   VAREND_aiSelectDestinationSquare =	TEMPORARY_VAR
    567  1e20
    568  1e20							; Piece is selected and now we're looking for a button press on a destination square
    569  1e20							; we flash the piece on-and-off while we're doing that
    570  1e20							; Flash the selected piece
    571  1e20
    572  1e20		       ad 84 02 	      lda	INTIM
    573  1e23		       c9 28		      cmp	#ONCEPERFRAME
    574  1e25		       90 0e		      bcc	.exit
    575  1e27
    576  1e27
    577  1e27		       c6 8c		      dec	aiFlashDelay
    578  1e29		       d0 0a		      bne	.exit	; don't flash
    579  1e2b		       a9 14		      lda	#CAP_SPEED
    580  1e2d		       85 8c		      sta	aiFlashDelay
    581  1e2f
    582  1e2f		       e6 8e		      inc	aiFlashPhase
    583  1e31
    584  1e31							; WARNING - local variables will not survive the following call...!
    585  1e31		       20 cb f0 	      jsr	CopySinglePiece	;@0
    586  1e34		       60		      rts
    587  1e35
    588  1e35				   .exit
      0  1e35					      CALL	moveCursor	;@2
      1  1e35				  -	      IF	SLOT_moveCursor == _BANK_SLOT
      2  1e35				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1e35				  -	      ECHO	"Cannot switch bank in use for", moveCursor
      4  1e35				  -	      ERR
      5  1e35					      ENDIF
      6  1e35		       a9 93		      lda	#BANK_moveCursor
      7  1e37		       85 3f		      sta	SET_BANK
      8  1e39		       20 00 f8 	      jsr	moveCursor
    590  1e3c
    591  1e3c		       ad 84 02 	      lda	INTIM
    592  1e3f		       c9 14		      cmp	#20
    593  1e41		       90 3d		      bcc	.noButton
    594  1e43
    595  1e43
    596  1e43		       a4 88		      ldy	cursorX12
    597  1e45		       84 86		      sty	toX12
    598  1e47
      0  1e47					      CALL	GetPiece	;@3
      1  1e47				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  1e47				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1e47				  -	      ECHO	"Cannot switch bank in use for", GetPiece
      4  1e47				  -	      ERR
      5  1e47					      ENDIF
      6  1e47		       a9 db		      lda	#BANK_GetPiece
      7  1e49		       85 3f		      sta	SET_BANK
      8  1e4b		       20 00 fc 	      jsr	GetPiece
      0  1e4e					      CALL	setCursorColours
      1  1e4e				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  1e4e				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1e4e				  -	      ECHO	"Cannot switch bank in use for", setCursorColours
      4  1e4e				  -	      ERR
      5  1e4e					      ENDIF
      6  1e4e		       a9 93		      lda	#BANK_setCursorColours
      7  1e50		       85 3f		      sta	SET_BANK
      8  1e52		       20 4a f8 	      jsr	setCursorColours
    601  1e55
    602  1e55
    603  1e55							; y = valid square
    604  1e55
    605  1e55		       a5 4c		      lda	INPT4
    606  1e57		       30 27		      bmi	.noButton
    607  1e59
    608  1e59		       a5 86		      lda	toX12
    609  1e5b		       c5 85		      cmp	fromX12
    610  1e5d		       f0 0d		      beq	.cancel
    611  1e5f
    612  1e5f		       c0 ff		      cpy	#-1
    613  1e61		       f0 1d		      beq	.noButton	; not a valid square
    614  1e63
    615  1e63		       a5 8e		      lda	aiFlashPhase
    616  1e65		       29 01		      and	#1
    617  1e67		       f0 13		      beq	.done
    618  1e69		       85 8c		      sta	aiFlashDelay	; EOR-phase incorrect - force quick fix to allow next-frame button detect
    619  1e6b		       60		      rts
    620  1e6c
    621  1e6c				   .cancel
    622  1e6c
    623  1e6c		       a5 8e		      lda	aiFlashPhase
    624  1e6e		       29 01		      and	#1
    625  1e70		       f0 05		      beq	.doCancel
    626  1e72
    627  1e72							; EOR-phase incorrect - force quick fix to allow next-frame button detect
    628  1e72
    629  1e72		       a9 01		      lda	#1
    630  1e74		       85 8c		      sta	aiFlashDelay
    631  1e76		       60		      rts
    632  1e77
    633  1e77
      0  1e77				   .doCancel  PHASE	AI_ReselectDebounce
      1  1e77		       a9 0a		      lda	#AI_ReselectDebounce
      2  1e79		       85 8b		      sta	aiState
    635  1e7b		       60		      rts
    636  1e7c
      0  1e7c				   .done      PHASE	AI_Quiescent	; destination selected!
      1  1e7c		       a9 09		      lda	#AI_Quiescent
      2  1e7e		       85 8b		      sta	aiState
    638  1e80		       60	   .noButton  rts
    639  1e81
    640  1e81
    641  1e81
    642  1e81
    643  1e81
    644  1e81							;---------------------------------------------------------------------------------------------------
    645  1e81
      0  1e81					      DEF	aiRollPromotionPiece
      1  1e81				   SLOT_aiRollPromotionPiece SET	_BANK_SLOT
      2  1e81				   BANK_aiRollPromotionPiece SET	SLOT_aiRollPromotionPiece + _CURRENT_BANK
      3  1e81				   aiRollPromotionPiece
      4  1e81				   TEMPORARY_VAR SET	Overlay
      5  1e81				   TEMPORARY_OFFSET SET	0
      6  1e81				   VAR_BOUNDARY_aiRollPromotionPiece SET	TEMPORARY_OFFSET
      7  1e81				   FUNCTION_NAME SET	aiRollPromotionPiece
    647  1e81					      SUBROUTINE
    648  1e81
      0  1e81					      REFER	AiStateMachine
      1  1e81					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1e81				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1e81					      ENDIF
      0  1e81					      VEND	aiRollPromotionPiece
      1  1e81				  -	      IFNCONST	aiRollPromotionPiece
      2  1e81				  -	      ECHO	"Incorrect VEND label", aiRollPromotionPiece
      3  1e81				  -	      ERR
      4  1e81					      ENDIF
      5  1e81		       00 a9	   VAREND_aiRollPromotionPiece =	TEMPORARY_VAR
    651  1e81
    652  1e81							; Flash the '?' and wait for an UDLR move
    653  1e81
    654  1e81		       ad 84 02 	      lda	INTIM
    655  1e84		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    656  1e86		       90 2b		      bcc	.exit
    657  1e88
    658  1e88		       ad 80 02 	      lda	SWCHA
    659  1e8b		       29 f0		      and	#$F0
    660  1e8d		       c9 f0		      cmp	#$F0
    661  1e8f		       f0 0a		      beq	.nojoy
    662  1e91
    663  1e91		       a9 00		      lda	#0
    664  1e93		       85 8c		      sta	aiFlashDelay
    665  1e95
    666  1e95		       a5 8e		      lda	aiFlashPhase
    667  1e97		       29 01		      and	#1
    668  1e99		       f0 19		      beq	.even
    669  1e9b
    670  1e9b		       a5 8c	   .nojoy     lda	aiFlashDelay
    671  1e9d		       f0 03		      beq	.do
    672  1e9f		       c6 8c		      dec	aiFlashDelay
    673  1ea1		       60		      rts
    674  1ea2
    675  1ea2				   .do
    676  1ea2		       a9 1e		      lda	#30
    677  1ea4		       85 8c		      sta	aiFlashDelay	; speed of "?" flashing
    678  1ea6
    679  1ea6
    680  1ea6		       a2 20		      ldx	#INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0
    681  1ea8		       a5 95		      lda	sideToMove
    682  1eaa		       10 02		      bpl	.wtm
    683  1eac		       a2 68		      ldx	#INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0
    684  1eae				   .wtm
    685  1eae		       20 c8 f6 	      jsr	showPromoteOptions	; draw the "?"
    686  1eb1
    687  1eb1		       e6 8e		      inc	aiFlashPhase
    688  1eb3
    689  1eb3		       60	   .exit      rts
    690  1eb4
    691  1eb4
    692  1eb4		       a9 03	   .even      lda	#3	; QUEEN
    693  1eb6		       85 96		      sta	fromPiece	; cycles as index to NBRQ
    694  1eb8
    695  1eb8							;inc aiFlashPhase
    696  1eb8
    697  1eb8		       a2 14		      ldx	#INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    698  1eba		       a5 95		      lda	sideToMove
    699  1ebc		       10 02		      bpl	.blackStuff
    700  1ebe		       a2 5c		      ldx	#INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    701  1ec0				   .blackStuff
    702  1ec0
    703  1ec0		       20 c8 f6 	      jsr	showPromoteOptions	; draw the initial Q
    704  1ec3
      0  1ec3					      PHASE	AI_ChooseDebounce
      1  1ec3		       a9 22		      lda	#AI_ChooseDebounce
      2  1ec5		       85 8b		      sta	aiState
    706  1ec7		       60		      rts
    707  1ec8
    708  1ec8
    709  1ec8							;---------------------------------------------------------------------------------------------------
    710  1ec8
      0  1ec8					      DEF	showPromoteOptions
      1  1ec8				   SLOT_showPromoteOptions SET	_BANK_SLOT
      2  1ec8				   BANK_showPromoteOptions SET	SLOT_showPromoteOptions + _CURRENT_BANK
      3  1ec8				   showPromoteOptions
      4  1ec8				   TEMPORARY_VAR SET	Overlay
      5  1ec8				   TEMPORARY_OFFSET SET	0
      6  1ec8				   VAR_BOUNDARY_showPromoteOptions SET	TEMPORARY_OFFSET
      7  1ec8				   FUNCTION_NAME SET	showPromoteOptions
    712  1ec8					      SUBROUTINE
    713  1ec8
      0  1ec8					      REFER	aiRollPromotionPiece	;✅
      1  1ec8					      IF	VAREND_aiRollPromotionPiece > TEMPORARY_VAR
      2  1ec8				   TEMPORARY_VAR SET	VAREND_aiRollPromotionPiece
      3  1ec8					      ENDIF
      0  1ec8					      REFER	aiChoosePromotePiece	;✅
      1  1ec8				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  1ec8				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  1ec8					      ENDIF
      0  1ec8					      VEND	showPromoteOptions
      1  1ec8				  -	      IFNCONST	showPromoteOptions
      2  1ec8				  -	      ECHO	"Incorrect VEND label", showPromoteOptions
      3  1ec8				  -	      ERR
      4  1ec8					      ENDIF
      5  1ec8		       00 a9	   VAREND_showPromoteOptions =	TEMPORARY_VAR
    717  1ec8
    718  1ec8							; X = character shape # (?/N/B/R/Q)
    719  1ec8
    720  1ec8		       a4 86		      ldy	toX12
    721  1eca		       84 80		      sty	squareToDraw
    722  1ecc
    723  1ecc		       8a		      txa
    724  1ecd		       a8		      tay
    725  1ece
    726  1ece		       20 73 f5 	      jsr	CopySetupForMarker	;@this
    727  1ed1		       4c d2 f0 	      jmp	InterceptMarkerCopy	;@0
    728  1ed4
    729  1ed4
    730  1ed4							;---------------------------------------------------------------------------------------------------
    731  1ed4
      0  1ed4					      DEF	aiChoosePromotePiece
      1  1ed4				   SLOT_aiChoosePromotePiece SET	_BANK_SLOT
      2  1ed4				   BANK_aiChoosePromotePiece SET	SLOT_aiChoosePromotePiece + _CURRENT_BANK
      3  1ed4				   aiChoosePromotePiece
      4  1ed4				   TEMPORARY_VAR SET	Overlay
      5  1ed4				   TEMPORARY_OFFSET SET	0
      6  1ed4				   VAR_BOUNDARY_aiChoosePromotePiece SET	TEMPORARY_OFFSET
      7  1ed4				   FUNCTION_NAME SET	aiChoosePromotePiece
    733  1ed4					      SUBROUTINE
    734  1ed4
      0  1ed4					      REFER	AiStateMachine
      1  1ed4					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1ed4				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1ed4					      ENDIF
      0  1ed4					      VEND	aiChoosePromotePiece
      1  1ed4				  -	      IFNCONST	aiChoosePromotePiece
      2  1ed4				  -	      ECHO	"Incorrect VEND label", aiChoosePromotePiece
      3  1ed4				  -	      ERR
      4  1ed4					      ENDIF
      5  1ed4		       00 a9	   VAREND_aiChoosePromotePiece =	TEMPORARY_VAR
    737  1ed4
    738  1ed4							; Question-mark phase has exited via joystick direction
    739  1ed4							; Now we cycle through the selectable pieces
    740  1ed4
    741  1ed4		       ad 84 02 	      lda	INTIM
    742  1ed7		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    743  1ed9		       90 4e		      bcc	.exit
    744  1edb
    745  1edb		       a5 4c		      lda	INPT4
    746  1edd		       30 0a		      bmi	.nobut	; no press
    747  1edf
    748  1edf							; button pressed but make sure phase is correct for exit
    749  1edf
    750  1edf		       a9 01		      lda	#1
    751  1ee1		       85 8c		      sta	aiFlashDelay	; force quick rehash to this if phase incorrect
    752  1ee3
    753  1ee3		       a5 8e		      lda	aiFlashPhase
    754  1ee5		       29 01		      and	#1
    755  1ee7		       f0 41		      beq	.chosen	; button pressed --> selection made
    756  1ee9				   .nobut
    757  1ee9
    758  1ee9		       ad 80 02 	      lda	SWCHA
    759  1eec		       29 f0		      and	#$F0
    760  1eee		       c9 f0		      cmp	#$F0
    761  1ef0		       f0 04		      beq	.nodir	; no direction pressed
    762  1ef2
    763  1ef2
    764  1ef2		       a9 01		      lda	#1
    765  1ef4		       85 8c		      sta	aiFlashDelay
    766  1ef6
    767  1ef6
    768  1ef6		       c6 8c	   .nodir     dec	aiFlashDelay
    769  1ef8		       d0 2f		      bne	.exit
    770  1efa
    771  1efa		       a9 1e		      lda	#30
    772  1efc		       85 8c		      sta	aiFlashDelay
    773  1efe
    774  1efe		       a5 8e		      lda	aiFlashPhase
    775  1f00		       4a		      lsr
    776  1f01		       b0 1c		      bcs	.odd	; must wait until piece undrawn
    777  1f03
    778  1f03		       ad 80 02 	      lda	SWCHA
    779  1f06		       29 f0		      and	#$F0
    780  1f08		       c9 f0		      cmp	#$F0
    781  1f0a		       f0 13		      beq	.odd	; no direction pressed
    782  1f0c
    783  1f0c		       4a		      lsr
    784  1f0d		       4a		      lsr
    785  1f0e		       4a		      lsr
    786  1f0f		       4a		      lsr
    787  1f10		       a8		      tay
    788  1f11
    789  1f11
    790  1f11							; cycle to the next promotable piece (N/B/R/Q)
    791  1f11							; TODO; use joy table for mod instead of just incrementing all the time
    792  1f11
    793  1f11		       18		      clc
    794  1f12		       a5 96		      lda	fromPiece
    795  1f14		       79 5d f8 	      adc	JoyCombined,y
    796  1f17		       29 03		      and	#3
    797  1f19		       85 96		      sta	fromPiece
    798  1f1b
      0  1f1b					      PHASE	AI_ChooseDebounce	; after draw, wait for release
      1  1f1b		       a9 22		      lda	#AI_ChooseDebounce
      2  1f1d		       85 8b		      sta	aiState
    800  1f1f
    801  1f1f				   .odd
    802  1f1f
    803  1f1f				   .force
    804  1f1f		       e6 8e		      inc	aiFlashPhase	; on/off toggle
    805  1f21
    806  1f21		       a4 96		      ldy	fromPiece
    807  1f23		       be 49 f7 	      ldx	promotePiece,y
    808  1f26		       20 c8 f6 	      jsr	showPromoteOptions	;@this
    809  1f29
    810  1f29		       60	   .exit      rts
    811  1f2a
    812  1f2a
    813  1f2a
    814  1f2a
    815  1f2a
    816  1f2a
    817  1f2a				   .chosen
    818  1f2a		       a5 96		      lda	fromPiece
    819  1f2c		       29 0f		      and	#PIECE_MASK
    820  1f2e		       aa		      tax
    821  1f2f
    822  1f2f		       bd 4d f7 	      lda	promoteType,x
    823  1f32		       85 96		      sta	fromPiece
    824  1f34
    825  1f34		       a4 86		      ldy	toX12
    826  1f36		       a9 d1		      lda	#RAMBANK_BOARD
    827  1f38		       85 3e		      sta	SET_BANK_RAM	;@3
    828  1f3a		       b9 79 fc 	      lda	Board,y
    829  1f3d		       29 0f		      and	#PIECE_MASK
    830  1f3f		       f0 03		      beq	.nothing
    831  1f41
    832  1f41		       20 cb f0 	      jsr	CopySinglePiece	;@0	      ; put back whatever was there to start
    833  1f44
      0  1f44				   .nothing   PHASE	AI_MoveIsSelected
      1  1f44		       a9 14		      lda	#AI_MoveIsSelected
      2  1f46		       85 8b		      sta	aiState
    835  1f48		       60		      rts
    836  1f49
      0  1f49					      ALLOCATE	promotePiece, 4
      0  1f49					      OPTIONAL_PAGEBREAK	"Table", 4
     12  1f49					      LIST	ON
      0  1f49					      DEF	promotePiece
      1  1f49				   SLOT_promotePiece SET	_BANK_SLOT
      2  1f49				   BANK_promotePiece SET	SLOT_promotePiece + _CURRENT_BANK
      3  1f49				   promotePiece
      4  1f49				   TEMPORARY_VAR SET	Overlay
      5  1f49				   TEMPORARY_OFFSET SET	0
      6  1f49				   VAR_BOUNDARY_promotePiece SET	TEMPORARY_OFFSET
      7  1f49				   FUNCTION_NAME SET	promotePiece
    838  1f49		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    839  1f4a		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    840  1f4b		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    841  1f4c		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    842  1f4d
      0  1f4d					      ALLOCATE	promoteType,4
      0  1f4d					      OPTIONAL_PAGEBREAK	"Table", 4
     12  1f4d					      LIST	ON
      0  1f4d					      DEF	promoteType
      1  1f4d				   SLOT_promoteType SET	_BANK_SLOT
      2  1f4d				   BANK_promoteType SET	SLOT_promoteType + _CURRENT_BANK
      3  1f4d				   promoteType
      4  1f4d				   TEMPORARY_VAR SET	Overlay
      5  1f4d				   TEMPORARY_OFFSET SET	0
      6  1f4d				   VAR_BOUNDARY_promoteType SET	TEMPORARY_OFFSET
      7  1f4d				   FUNCTION_NAME SET	promoteType
    844  1f4d		       03 04 05 06	      .byte.b	KNIGHT, BISHOP, ROOK, QUEEN
    845  1f51
    846  1f51
    847  1f51							;---------------------------------------------------------------------------------------------------
    848  1f51
      0  1f51					      DEF	aiMarchA2
      1  1f51				   SLOT_aiMarchA2 SET	_BANK_SLOT
      2  1f51				   BANK_aiMarchA2 SET	SLOT_aiMarchA2 + _CURRENT_BANK
      3  1f51				   aiMarchA2
      4  1f51				   TEMPORARY_VAR SET	Overlay
      5  1f51				   TEMPORARY_OFFSET SET	0
      6  1f51				   VAR_BOUNDARY_aiMarchA2 SET	TEMPORARY_OFFSET
      7  1f51				   FUNCTION_NAME SET	aiMarchA2
    850  1f51					      SUBROUTINE
    851  1f51
      0  1f51					      REFER	AiStateMachine
      1  1f51					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1f51				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1f51					      ENDIF
      0  1f51					      VEND	aiMarchA2
      1  1f51				  -	      IFNCONST	aiMarchA2
      2  1f51				  -	      ECHO	"Incorrect VEND label", aiMarchA2
      3  1f51				  -	      ERR
      4  1f51					      ENDIF
      5  1f51		       00 a9	   VAREND_aiMarchA2 =	TEMPORARY_VAR
    854  1f51
    855  1f51							; erase object in new sqare --> blank
    856  1f51
    857  1f51		       a4 85		      ldy	fromX12
    858  1f53		       84 80		      sty	squareToDraw
    859  1f55
    860  1f55		       a9 d1		      lda	#RAMBANK_BOARD
    861  1f57		       85 3e		      sta	SET_BANK_RAM	;@3
    862  1f59		       b9 79 fc 	      lda	Board,y
    863  1f5c		       f0 03		      beq	.skipbl
    864  1f5e
    865  1f5e							; WARNING - local variables will not survive the following call...!
    866  1f5e		       20 cb f0 	      jsr	CopySinglePiece	;@0	      ; erase next square along --> blank
    867  1f61
    868  1f61				   .skipbl
    869  1f61		       a4 85		      ldy	fromX12
    870  1f63		       84 aa		      sty	__boardIndex
    871  1f65
    872  1f65		       a9 d1		      lda	#RAMBANK_BOARD
    873  1f67		       85 3e		      sta	SET_BANK_RAM	;@3
    874  1f69		       b9 79 fc 	      lda	Board,y
    875  1f6c		       85 97		      sta	lastPiece	; what we are overwriting
    876  1f6e		       a5 96		      lda	fromPiece
    877  1f70		       09 40		      ora	#FLAG_MOVED	; prevents usage in castling for K/R
    878  1f72		       29 df		      and	#~FLAG_ENPASSANT
    879  1f74		       a4 aa		      ldy	__boardIndex
      0  1f76					      sta@RAM	Board,y	; and what's actually moving there
      1  1f76		       99 79 fe 	      sta	[RAM]+Board,y
    881  1f79
    882  1f79
      0  1f79					      PHASE	AI_MarchB
      1  1f79		       a9 18		      lda	#AI_MarchB
      2  1f7b		       85 8b		      sta	aiState
    884  1f7d		       60		      rts
    885  1f7e
    886  1f7e
    887  1f7e							;---------------------------------------------------------------------------------------------------
    888  1f7e
      0  1f7e					      DEF	aiMarchB2
      1  1f7e				   SLOT_aiMarchB2 SET	_BANK_SLOT
      2  1f7e				   BANK_aiMarchB2 SET	SLOT_aiMarchB2 + _CURRENT_BANK
      3  1f7e				   aiMarchB2
      4  1f7e				   TEMPORARY_VAR SET	Overlay
      5  1f7e				   TEMPORARY_OFFSET SET	0
      6  1f7e				   VAR_BOUNDARY_aiMarchB2 SET	TEMPORARY_OFFSET
      7  1f7e				   FUNCTION_NAME SET	aiMarchB2
    890  1f7e					      SUBROUTINE
    891  1f7e
      0  1f7e					      REFER	AiStateMachine
      1  1f7e					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1f7e				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1f7e					      ENDIF
      0  1f7e					      VEND	aiMarchB2
      1  1f7e				  -	      IFNCONST	aiMarchB2
      2  1f7e				  -	      ECHO	"Incorrect VEND label", aiMarchB2
      3  1f7e				  -	      ERR
      4  1f7e					      ENDIF
      5  1f7e		       00 a9	   VAREND_aiMarchB2 =	TEMPORARY_VAR
    894  1f7e
    895  1f7e		       a4 83		      ldy	lastSquareX12
    896  1f80		       84 80		      sty	squareToDraw
    897  1f82
    898  1f82		       a9 d1		      lda	#RAMBANK_BOARD
    899  1f84		       85 3e		      sta	SET_BANK_RAM	;@3
    900  1f86		       b9 79 fc 	      lda	Board,y
    901  1f89		       f0 03		      beq	.skipbl2
    902  1f8b
    903  1f8b							; WARNING - local variables will not survive the following call...!
    904  1f8b		       20 cb f0 	      jsr	CopySinglePiece	;@0	      ; draw previous piece back in old position
    905  1f8e				   .skipbl2
    906  1f8e
    907  1f8e		       a5 85		      lda	fromX12
    908  1f90		       c5 86		      cmp	toX12
    909  1f92		       f0 09		      beq	xhalt
    910  1f94
    911  1f94		       a9 02		      lda	#2	;??? inter-move segment speed (can be 0)
    912  1f96		       85 82		      sta	drawDelay
      0  1f98					      PHASE	AI_MarchToTargetA
      1  1f98		       a9 16		      lda	#AI_MarchToTargetA
      2  1f9a		       85 8b		      sta	aiState
    914  1f9c
    915  1f9c		       60		      rts
    916  1f9d
      0  1f9d				   xhalt      PHASE	AI_EPHandler
      1  1f9d		       a9 29		      lda	#AI_EPHandler
      2  1f9f		       85 8b		      sta	aiState
    918  1fa1		       60		      rts
    919  1fa2
    920  1fa2
    921  1fa2							;---------------------------------------------------------------------------------------------------
    922  1fa2
      0  1fa2					      DEF	aiEPHandler
      1  1fa2				   SLOT_aiEPHandler SET	_BANK_SLOT
      2  1fa2				   BANK_aiEPHandler SET	SLOT_aiEPHandler + _CURRENT_BANK
      3  1fa2				   aiEPHandler
      4  1fa2				   TEMPORARY_VAR SET	Overlay
      5  1fa2				   TEMPORARY_OFFSET SET	0
      6  1fa2				   VAR_BOUNDARY_aiEPHandler SET	TEMPORARY_OFFSET
      7  1fa2				   FUNCTION_NAME SET	aiEPHandler
    924  1fa2					      SUBROUTINE
    925  1fa2
    926  1fa2							;CALL EnPassantFixupDraw	  ; set enPassantPawn
    927  1fa2
    928  1fa2
    929  1fa2		       a5 96		      lda	fromPiece
    930  1fa4		       29 60		      and	#FLAG_ENPASSANT|FLAG_MOVED
    931  1fa6		       c9 60		      cmp	#FLAG_ENPASSANT|FLAG_MOVED
    932  1fa8		       d0 1a		      bne	.exit
    933  1faa
    934  1faa							; we have deteced a piece DOING an en passant capture
    935  1faa							; so do the actual removal of the captured pawn...
    936  1faa							; calculate the captured pawn's square based on piece colour
    937  1faa
    938  1faa		       a9 f6		      lda	#-10
    939  1fac		       a6 96		      ldx	fromPiece
    940  1fae		       10 02		      bpl	.white
    941  1fb0		       a9 0a		      lda	#10
    942  1fb2				   .white
    943  1fb2		       18		      clc
    944  1fb3		       65 85		      adc	fromX12	; attacker destination square
    945  1fb5		       85 93		      sta	enPassantPawn	; now this is the pawn to ERASE
    946  1fb7
    947  1fb7		       a9 05		      lda	#5	; on/off count (leave undrawn)
    948  1fb9		       85 84		      sta	drawCount	; flashing for piece about to move
    949  1fbb		       a9 00		      lda	#0
    950  1fbd		       85 82		      sta	drawDelay
    951  1fbf
      0  1fbf					      PHASE	AI_EPFlash
      1  1fbf		       a9 2a		      lda	#AI_EPFlash
      2  1fc1		       85 8b		      sta	aiState
    953  1fc3		       60		      rts
    954  1fc4
    955  1fc4
    956  1fc4				   .exit
    957  1fc4
    958  1fc4		       a9 04		      lda	#4	; on/off count (leave undrawn)
    959  1fc6		       85 84		      sta	drawCount	; flashing for piece about to move
    960  1fc8		       a9 00		      lda	#0
    961  1fca		       85 82		      sta	drawDelay
    962  1fcc
      0  1fcc					      PHASE	AI_FinalFlash
      1  1fcc		       a9 1b		      lda	#AI_FinalFlash
      2  1fce		       85 8b		      sta	aiState
    964  1fd0		       60		      rts
    965  1fd1
    966  1fd1
    967  1fd1							;---------------------------------------------------------------------------------------------------
    968  1fd1
    969  1fd1
    970  1fd1							;---------------------------------------------------------------------------------------------------
    971  1fd1
      0  1fd1					      CHECK_BANK_SIZE	"BANK_StateMachine@1#1"
      1  1fd1		       03 d1	   .TEMP      =	* - _BANK_START
 BANK_StateMachine@1#1 (1K) SIZE =  $3d1 , FREE= $2f
      2  1fd1					      ECHO	"BANK_StateMachine@1#1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1fd1				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1fd1				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_StateMachine@1#1", " size=", * - ORIGIN
      5  1fd1				  -	      ERR
      6  1fd1					      ENDIF
    973  1fd1
    974  1fd1
    975  1fd1							;---------------------------------------------------------------------------------------------------
    976  1fd1
    977  1fd1							; EOF
------- FILE ./chess.asm
------- FILE BANK_StateMachine@1#2.asm LEVEL 2 PASS 4
      0  1fd1					      include	"BANK_StateMachine@1#2.asm"
      0  1fd1					      SLOT	1
      1  1fd1				  -	      IF	(1 < 0) || (1 > 3)
      2  1fd1				  -	      ECHO	"Illegal bank address/segment location", 1
      3  1fd1				  -	      ERR
      4  1fd1					      ENDIF
      5  1fd1				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  1fd1				   _BANK_SLOT SET	1 * 64
      0  1fd1					      ROMBANK	STATEMACHINE2
      1  21f4 ????				      SEG	STATEMACHINE2
      2  2000					      ORG	_ORIGIN
      3  2000					      RORG	_BANK_ADDRESS_ORIGIN
      4  2000				   _BANK_START SET	*
      5  2000				   STATEMACHINE2_START SET	*
      6  2000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2000				   STATEMACHINE2 SET	_BANK_SLOT + _CURRENT_BANK
      8  2000				   _ORIGIN    SET	_ORIGIN + 1024
      3  2000
      4  2000
      5  2000							;---------------------------------------------------------------------------------------------------
      6  2000
      0  2000					      DEF	aiChooseDebounce
      1  2000				   SLOT_aiChooseDebounce SET	_BANK_SLOT
      2  2000				   BANK_aiChooseDebounce SET	SLOT_aiChooseDebounce + _CURRENT_BANK
      3  2000				   aiChooseDebounce
      4  2000				   TEMPORARY_VAR SET	Overlay
      5  2000				   TEMPORARY_OFFSET SET	0
      6  2000				   VAR_BOUNDARY_aiChooseDebounce SET	TEMPORARY_OFFSET
      7  2000				   FUNCTION_NAME SET	aiChooseDebounce
      8  2000					      SUBROUTINE
      9  2000
      0  2000					      REFER	AiStateMachine
      1  2000					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2000				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2000					      ENDIF
      0  2000					      VEND	aiChooseDebounce
      1  2000				  -	      IFNCONST	aiChooseDebounce
      2  2000				  -	      ECHO	"Incorrect VEND label", aiChooseDebounce
      3  2000				  -	      ERR
      4  2000					      ENDIF
      5  2000		       00 a9	   VAREND_aiChooseDebounce =	TEMPORARY_VAR
     12  2000
     13  2000							; We've changed promotion piece, and drawn it
     14  2000							; wait for joystick to be released before continuing
     15  2000
     16  2000		       ad 80 02 	      lda	SWCHA
     17  2003		       29 f0		      and	#$F0
     18  2005		       c9 f0		      cmp	#$F0
     19  2007		       d0 0a		      bne	.exit	; wait while joystick still pressed
     20  2009
     21  2009		       a9 01		      lda	#1
     22  200b		       85 8c		      sta	aiFlashDelay
     23  200d		       85 8e		      sta	aiFlashPhase
     24  200f
      0  200f					      PHASE	AI_ChoosePromotePiece
      1  200f		       a9 21		      lda	#AI_ChoosePromotePiece
      2  2011		       85 8b		      sta	aiState
     26  2013		       60	   .exit      rts
     27  2014
     28  2014
     29  2014							;---------------------------------------------------------------------------------------------------
     30  2014
      0  2014					      DEF	aiReselectDebounce
      1  2014				   SLOT_aiReselectDebounce SET	_BANK_SLOT
      2  2014				   BANK_aiReselectDebounce SET	SLOT_aiReselectDebounce + _CURRENT_BANK
      3  2014				   aiReselectDebounce
      4  2014				   TEMPORARY_VAR SET	Overlay
      5  2014				   TEMPORARY_OFFSET SET	0
      6  2014				   VAR_BOUNDARY_aiReselectDebounce SET	TEMPORARY_OFFSET
      7  2014				   FUNCTION_NAME SET	aiReselectDebounce
     32  2014					      SUBROUTINE
     33  2014
      0  2014					      REFER	AiStateMachine
      1  2014					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2014				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2014					      ENDIF
      0  2014					      VEND	aiReselectDebounce
      1  2014				  -	      IFNCONST	aiReselectDebounce
      2  2014				  -	      ECHO	"Incorrect VEND label", aiReselectDebounce
      3  2014				  -	      ERR
      4  2014					      ENDIF
      5  2014		       00 a9	   VAREND_aiReselectDebounce =	TEMPORARY_VAR
     36  2014
     37  2014							; We've just cancelled the move. Wait for the button to be released
     38  2014							; and then go back to selecting a piece to move
     39  2014
     40  2014		       a5 4c		      lda	INPT4
     41  2016		       10 04		      bpl	.exit	; button still pressed, so wait
     42  2018
      0  2018					      PHASE	AI_SelectStartSquare
      1  2018		       a9 02		      lda	#AI_SelectStartSquare
      2  201a		       85 8b		      sta	aiState
     44  201c		       60	   .exit      rts
     45  201d
     46  201d
     47  201d							;---------------------------------------------------------------------------------------------------
     48  201d
      0  201d					      DEF	aiDelayAfterMove
      1  201d				   SLOT_aiDelayAfterMove SET	_BANK_SLOT
      2  201d				   BANK_aiDelayAfterMove SET	SLOT_aiDelayAfterMove + _CURRENT_BANK
      3  201d				   aiDelayAfterMove
      4  201d				   TEMPORARY_VAR SET	Overlay
      5  201d				   TEMPORARY_OFFSET SET	0
      6  201d				   VAR_BOUNDARY_aiDelayAfterMove SET	TEMPORARY_OFFSET
      7  201d				   FUNCTION_NAME SET	aiDelayAfterMove
     50  201d					      SUBROUTINE
     51  201d
      0  201d					      REFER	AiStateMachine
      1  201d					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  201d				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  201d					      ENDIF
      0  201d					      VEND	aiDelayAfterMove
      1  201d				  -	      IFNCONST	aiDelayAfterMove
      2  201d				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  201d				  -	      ERR
      4  201d					      ENDIF
      5  201d		       00 a9	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
     54  201d
     55  201d		       a9 32		      lda	#50
     56  201f		       85 8c		      sta	aiFlashDelay
      0  2021					      PHASE	AI_DelayAfterMove2
      1  2021		       a9 26		      lda	#AI_DelayAfterMove2
      2  2023		       85 8b		      sta	aiState
     58  2025		       60	   .exit      rts
     59  2026
     60  2026
     61  2026							;---------------------------------------------------------------------------------------------------
     62  2026
      0  2026					      DEF	aiDelayAfterMove2
      1  2026				   SLOT_aiDelayAfterMove2 SET	_BANK_SLOT
      2  2026				   BANK_aiDelayAfterMove2 SET	SLOT_aiDelayAfterMove2 + _CURRENT_BANK
      3  2026				   aiDelayAfterMove2
      4  2026				   TEMPORARY_VAR SET	Overlay
      5  2026				   TEMPORARY_OFFSET SET	0
      6  2026				   VAR_BOUNDARY_aiDelayAfterMove2 SET	TEMPORARY_OFFSET
      7  2026				   FUNCTION_NAME SET	aiDelayAfterMove2
     64  2026					      SUBROUTINE
     65  2026
      0  2026					      REFER	AiStateMachine
      1  2026					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2026				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2026					      ENDIF
      0  2026					      VEND	aiDelayAfterMove
      1  2026				  -	      IFNCONST	aiDelayAfterMove
      2  2026				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  2026				  -	      ERR
      4  2026					      ENDIF
      5  2026		       00 a9	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
     68  2026
     69  2026		       c6 8c		      dec	aiFlashDelay
     70  2028		       d0 04		      bne	.exit
      0  202a					      PHASE	AI_MoveIsSelected
      1  202a		       a9 14		      lda	#AI_MoveIsSelected
      2  202c		       85 8b		      sta	aiState
     72  202e		       60	   .exit      rts
     73  202f
     74  202f
     75  202f							;---------------------------------------------------------------------------------------------------
     76  202f
      0  202f					      DEF	aiDelayAfterPlaced
      1  202f				   SLOT_aiDelayAfterPlaced SET	_BANK_SLOT
      2  202f				   BANK_aiDelayAfterPlaced SET	SLOT_aiDelayAfterPlaced + _CURRENT_BANK
      3  202f				   aiDelayAfterPlaced
      4  202f				   TEMPORARY_VAR SET	Overlay
      5  202f				   TEMPORARY_OFFSET SET	0
      6  202f				   VAR_BOUNDARY_aiDelayAfterPlaced SET	TEMPORARY_OFFSET
      7  202f				   FUNCTION_NAME SET	aiDelayAfterPlaced
     78  202f					      SUBROUTINE
     79  202f
      0  202f					      REFER	AiStateMachine
      1  202f					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  202f				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  202f					      ENDIF
      0  202f					      VEND	aiDelayAfterPlaced
      1  202f				  -	      IFNCONST	aiDelayAfterPlaced
      2  202f				  -	      ECHO	"Incorrect VEND label", aiDelayAfterPlaced
      3  202f				  -	      ERR
      4  202f					      ENDIF
      5  202f		       00 a9	   VAREND_aiDelayAfterPlaced =	TEMPORARY_VAR
     82  202f
     83  202f		       a2 4b		      ldx	#75	; delay after human move
     84  2031		       a5 95		      lda	sideToMove
     85  2033		       0a		      asl
     86  2034		       30 02		      bmi	.human
     87  2036		       a2 01		      ldx	#1	; delay after computer move
     88  2038		       86 8c	   .human     stx	aiFlashDelay
     89  203a
      0  203a					      PHASE	AI_DelayAfterPlaced2
      1  203a		       a9 28		      lda	#AI_DelayAfterPlaced2
      2  203c		       85 8b		      sta	aiState
     91  203e		       60		      rts
     92  203f
     93  203f
     94  203f							;---------------------------------------------------------------------------------------------------
     95  203f
      0  203f					      DEF	aiDelayAfterPlaced2
      1  203f				   SLOT_aiDelayAfterPlaced2 SET	_BANK_SLOT
      2  203f				   BANK_aiDelayAfterPlaced2 SET	SLOT_aiDelayAfterPlaced2 + _CURRENT_BANK
      3  203f				   aiDelayAfterPlaced2
      4  203f				   TEMPORARY_VAR SET	Overlay
      5  203f				   TEMPORARY_OFFSET SET	0
      6  203f				   VAR_BOUNDARY_aiDelayAfterPlaced2 SET	TEMPORARY_OFFSET
      7  203f				   FUNCTION_NAME SET	aiDelayAfterPlaced2
     97  203f					      SUBROUTINE
     98  203f
      0  203f					      REFER	AiStateMachine
      1  203f					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  203f				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  203f					      ENDIF
      0  203f					      VEND	aiDelayAfterPlaced2
      1  203f				  -	      IFNCONST	aiDelayAfterPlaced2
      2  203f				  -	      ECHO	"Incorrect VEND label", aiDelayAfterPlaced2
      3  203f				  -	      ERR
      4  203f					      ENDIF
      5  203f		       00 a9	   VAREND_aiDelayAfterPlaced2 =	TEMPORARY_VAR
    101  203f
    102  203f
    103  203f		       ad 82 02 	      lda	SWCHB
    104  2042		       29 02		      and	#SELECT_SWITCH
    105  2044		       d0 05		      bne	.noSwapside
    106  2046
      0  2046					      PHASE	AI_DebounceSelect
      1  2046		       a9 2b		      lda	#AI_DebounceSelect
      2  2048		       85 8b		      sta	aiState
    108  204a		       60		      rts
    109  204b				   .noSwapside
    110  204b
    111  204b
    112  204b		       c6 8c		      dec	aiFlashDelay
    113  204d		       d0 04		      bne	.exit
    114  204f
    115  204f							;SWAP
    116  204f
      0  204f					      PHASE	AI_GenerateMoves
      1  204f		       a9 12		      lda	#AI_GenerateMoves
      2  2051		       85 8b		      sta	aiState
    118  2053		       60	   .exit      rts
    119  2054
    120  2054
    121  2054							;---------------------------------------------------------------------------------------------------
    122  2054
      0  2054					      DEF	aiMarchToTargetB
      1  2054				   SLOT_aiMarchToTargetB SET	_BANK_SLOT
      2  2054				   BANK_aiMarchToTargetB SET	SLOT_aiMarchToTargetB + _CURRENT_BANK
      3  2054				   aiMarchToTargetB
      4  2054				   TEMPORARY_VAR SET	Overlay
      5  2054				   TEMPORARY_OFFSET SET	0
      6  2054				   VAR_BOUNDARY_aiMarchToTargetB SET	TEMPORARY_OFFSET
      7  2054				   FUNCTION_NAME SET	aiMarchToTargetB
    124  2054					      SUBROUTINE
    125  2054
      0  2054					      REFER	AiStateMachine
      1  2054					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2054				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2054					      ENDIF
      0  2054					      VEND	aiMarchToTargetB
      1  2054				  -	      IFNCONST	aiMarchToTargetB
      2  2054				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetB
      3  2054				  -	      ERR
      4  2054					      ENDIF
      5  2054		       00 a9	   VAREND_aiMarchToTargetB =	TEMPORARY_VAR
    128  2054
    129  2054							; now we want to undraw the piece in the old square
    130  2054
    131  2054		       a5 82		      lda	drawDelay
    132  2056		       f0 03		      beq	.stepOne
    133  2058		       c6 82		      dec	drawDelay
    134  205a		       60		      rts
    135  205b
    136  205b				   .stepOne
    137  205b		       a5 83		      lda	lastSquareX12
    138  205d		       85 80		      sta	squareToDraw
    139  205f
    140  205f							; WARNING - local variables will not survive the following call...!
    141  205f		       20 cb f0 	      jsr	CopySinglePiece	;@0	      ; erase whatever was on the previous square (completely blank)
    142  2062
    143  2062		       a4 83		      ldy	lastSquareX12
    144  2064		       a5 98		      lda	previousPiece
    145  2066
    146  2066		       a2 d1		      ldx	#RAMBANK_BOARD
    147  2068		       86 3e		      stx	SET_BANK_RAM	;@3
      0  206a					      sta@RAM	Board,y	; and what's actually moving there
      1  206a		       99 79 fe 	      sta	[RAM]+Board,y
    149  206d
    150  206d		       a5 97		      lda	lastPiece
    151  206f		       85 98		      sta	previousPiece
    152  2071
      0  2071					      PHASE	AI_MarchB2
      1  2071		       a9 1a		      lda	#AI_MarchB2
      2  2073		       85 8b		      sta	aiState
    154  2075		       60		      rts
    155  2076
    156  2076
    157  2076							;---------------------------------------------------------------------------------------------------
    158  2076
      0  2076					      DEF	aiPromotePawnStart
      1  2076				   SLOT_aiPromotePawnStart SET	_BANK_SLOT
      2  2076				   BANK_aiPromotePawnStart SET	SLOT_aiPromotePawnStart + _CURRENT_BANK
      3  2076				   aiPromotePawnStart
      4  2076				   TEMPORARY_VAR SET	Overlay
      5  2076				   TEMPORARY_OFFSET SET	0
      6  2076				   VAR_BOUNDARY_aiPromotePawnStart SET	TEMPORARY_OFFSET
      7  2076				   FUNCTION_NAME SET	aiPromotePawnStart
    160  2076					      SUBROUTINE
    161  2076
      0  2076					      REFER	AiStateMachine
      1  2076					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2076				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2076					      ENDIF
      0  2076					      VEND	aiPromotePawnStart
      1  2076				  -	      IFNCONST	aiPromotePawnStart
      2  2076				  -	      ECHO	"Incorrect VEND label", aiPromotePawnStart
      3  2076				  -	      ERR
      4  2076					      ENDIF
      5  2076		       00 a9	   VAREND_aiPromotePawnStart =	TEMPORARY_VAR
    164  2076
    165  2076
    166  2076		       ad 84 02 	      lda	INTIM
    167  2079		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    168  207b		       90 1c		      bcc	.exit
    169  207d
    170  207d		       a9 00		      lda	#0
    171  207f		       85 8e		      sta	aiFlashPhase
    172  2081		       85 8c		      sta	aiFlashDelay
    173  2083
    174  2083		       a4 86		      ldy	toX12
    175  2085		       84 80		      sty	squareToDraw
    176  2087
    177  2087		       a9 d1		      lda	#RAMBANK_BOARD
    178  2089		       85 3e		      sta	SET_BANK_RAM	;@3
    179  208b		       b9 79 fc 	      lda	Board,y
    180  208e		       29 0f		      and	#PIECE_MASK
    181  2090		       f0 03		      beq	.empty
    182  2092
    183  2092							; WARNING - local variables will not survive the following call...!
    184  2092		       20 cb f0 	      jsr	CopySinglePiece	;@0	      ; remove any capturable piece for display purposes
    185  2095
      0  2095				   .empty     PHASE	AI_RollPromotionPiece
      1  2095		       a9 20		      lda	#AI_RollPromotionPiece
      2  2097		       85 8b		      sta	aiState
    187  2099		       60	   .exit      rts
    188  209a
    189  209a
    190  209a							;---------------------------------------------------------------------------------------------------
    191  209a
      0  209a					      DEF	aiGenerateMoves
      1  209a				   SLOT_aiGenerateMoves SET	_BANK_SLOT
      2  209a				   BANK_aiGenerateMoves SET	SLOT_aiGenerateMoves + _CURRENT_BANK
      3  209a				   aiGenerateMoves
      4  209a				   TEMPORARY_VAR SET	Overlay
      5  209a				   TEMPORARY_OFFSET SET	0
      6  209a				   VAR_BOUNDARY_aiGenerateMoves SET	TEMPORARY_OFFSET
      7  209a				   FUNCTION_NAME SET	aiGenerateMoves
    193  209a					      SUBROUTINE
    194  209a
      0  209a					      REFER	AiStateMachine
      1  209a					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  209a				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  209a					      ENDIF
      0  209a					      VEND	aiGenerateMoves
      1  209a				  -	      IFNCONST	aiGenerateMoves
      2  209a				  -	      ECHO	"Incorrect VEND label", aiGenerateMoves
      3  209a				  -	      ERR
      4  209a					      ENDIF
      5  209a		       00 a9	   VAREND_aiGenerateMoves =	TEMPORARY_VAR
    197  209a
    198  209a		       a5 86		      lda	toX12
    199  209c		       85 80		      sta	squareToDraw	; for showing move (display square)
    200  209e
    201  209e		       a5 95		      lda	sideToMove
    202  20a0		       0a		      asl
    203  20a1		       30 05		      bmi	.player
    204  20a3
    205  20a3
      0  20a3				   .computer  PHASE	AI_ComputerMove	; computer select move
      1  20a3		       a9 13		      lda	#AI_ComputerMove
      2  20a5		       85 8b		      sta	aiState
    207  20a7		       60		      rts
    208  20a8
    209  20a8
      0  20a8				   .player    PHASE	AI_StartMoveGen
      1  20a8		       a9 0b		      lda	#AI_StartMoveGen
      2  20aa		       85 8b		      sta	aiState
    211  20ac		       60		      rts
    212  20ad
    213  20ad
    214  20ad							;---------------------------------------------------------------------------------------------------
    215  20ad
      0  20ad					      DEF	aiStepMoveGen
      1  20ad				   SLOT_aiStepMoveGen SET	_BANK_SLOT
      2  20ad				   BANK_aiStepMoveGen SET	SLOT_aiStepMoveGen + _CURRENT_BANK
      3  20ad				   aiStepMoveGen
      4  20ad				   TEMPORARY_VAR SET	Overlay
      5  20ad				   TEMPORARY_OFFSET SET	0
      6  20ad				   VAR_BOUNDARY_aiStepMoveGen SET	TEMPORARY_OFFSET
      7  20ad				   FUNCTION_NAME SET	aiStepMoveGen
    217  20ad					      SUBROUTINE
    218  20ad
      0  20ad					      REFER	AiStateMachine
      1  20ad					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  20ad				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  20ad					      ENDIF
      0  20ad					      VEND	aiStepMoveGen
      1  20ad				  -	      IFNCONST	aiStepMoveGen
      2  20ad				  -	      ECHO	"Incorrect VEND label", aiStepMoveGen
      3  20ad				  -	      ERR
      4  20ad					      ENDIF
      5  20ad		       00 a9	   VAREND_aiStepMoveGen =	TEMPORARY_VAR
    221  20ad
    222  20ad		       a5 87		      lda	originX12	; location of cursor (show move)
    223  20af		       85 88		      sta	cursorX12
      0  20b1					      PHASE	AI_BeginSelectMovePhase
      1  20b1		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  20b3		       85 8b		      sta	aiState
    225  20b5		       60		      rts
    226  20b6
    227  20b6
    228  20b6							;---------------------------------------------------------------------------------------------------
    229  20b6
    230  2100		       00 00 00 00*	      align	256	; TODO?
      0  2100					      DEF	PositionSprites
      1  2100				   SLOT_PositionSprites SET	_BANK_SLOT
      2  2100				   BANK_PositionSprites SET	SLOT_PositionSprites + _CURRENT_BANK
      3  2100				   PositionSprites
      4  2100				   TEMPORARY_VAR SET	Overlay
      5  2100				   TEMPORARY_OFFSET SET	0
      6  2100				   VAR_BOUNDARY_PositionSprites SET	TEMPORARY_OFFSET
      7  2100				   FUNCTION_NAME SET	PositionSprites
    232  2100					      SUBROUTINE
    233  2100
      0  2100					      REFER	StartupBankReset
      1  2100				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  2100				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  2100					      ENDIF
      0  2100					      VEND	PositionSprites
      1  2100				  -	      IFNCONST	PositionSprites
      2  2100				  -	      ECHO	"Incorrect VEND label", PositionSprites
      3  2100				  -	      ERR
      4  2100					      ENDIF
      5  2100		       00 a7	   VAREND_PositionSprites =	TEMPORARY_VAR
    236  2100
    237  2100
    238  2100		       a5 88		      lda	cursorX12
    239  2102		       38		      sec
    240  2103		       e9 0a	   .sub10     sbc	#10
    241  2105		       b0 fc		      bcs	.sub10
    242  2107		       69 08		      adc	#8
    243  2109		       a8		      tay
    244  210a
    245  210a		       85 42		      sta	WSYNC	; 00	  Sync to start of scanline.
    246  210c
    247  210c		       b9 30 f5 	      lda	colToPixel,y
    248  210f
    249  210f		       38		      sec		; 02	  Set the carry flag so no borrow will be applied during the division.
    250  2110		       e9 0f	   .divideby15 sbc	#15	; 04	  Waste the necessary amount of time dividing X-pos by 15!
    251  2112		       b0 fc		      bcs	.divideby15	; 06/07  11/16/21/26/31/36/41/46/51/56/61/66
    252  2114
    253  2114		       a8		      tay
    254  2115		       b9 30 f4 	      lda	fineAdjustTable,y	; 13 -> Consume 5 cycles by guaranteeing we cross a page boundary
    255  2118		       85 60		      sta	HMP0
    256  211a		       85 50		      sta	RESP0	; 21/ 26/31/36/41/46/51/56/61/66/71 - Set the rough position.
    257  211c
    258  211c		       85 42		      sta	WSYNC
    259  211e		       85 6a		      sta	HMOVE
    260  2120
    261  2120		       60		      rts
    262  2121
    263  2121							; This table converts the "remainder" of the division by 15 (-1 to -15) to the correct
    264  2121							; fine adjustment value. This table is on a page boundary to guarantee the processor
    265  2121							; will cross a page boundary and waste a cycle in order to be at the precise position
    266  2121							; for a RESP0,x write
    267  2121
    268  2121				   fineAdjustBegin
    269  2121
    270  2121		       70		      DC.B	%01110000	; Left 7
    271  2122		       60		      DC.B	%01100000	; Left 6
    272  2123		       50		      DC.B	%01010000	; Left 5
    273  2124		       40		      DC.B	%01000000	; Left 4
    274  2125		       30		      DC.B	%00110000	; Left 3
    275  2126		       20		      DC.B	%00100000	; Left 2
    276  2127		       10		      DC.B	%00010000	; Left 1
    277  2128		       00		      DC.B	%00000000	; No movement.
    278  2129		       f0		      DC.B	%11110000	; Right 1
    279  212a		       e0		      DC.B	%11100000	; Right 2
    280  212b		       d0		      DC.B	%11010000	; Right 3
    281  212c		       c0		      DC.B	%11000000	; Right 4
    282  212d		       b0		      DC.B	%10110000	; Right 5
    283  212e		       a0		      DC.B	%10100000	; Right 6
    284  212f		       90		      DC.B	%10010000	; Right 7
    285  2130
    286  2130		       f4 30	   fineAdjustTable EQU	fineAdjustBegin - %11110001	; NOTE: %11110001 = -15
    287  2130
    288  2130
      0  2130					      ALLOCATE	colToPixel, 8
      0  2130					      OPTIONAL_PAGEBREAK	"Table", 8
     12  2130					      LIST	ON
      0  2130					      DEF	colToPixel
      1  2130				   SLOT_colToPixel SET	_BANK_SLOT
      2  2130				   BANK_colToPixel SET	SLOT_colToPixel + _CURRENT_BANK
      3  2130				   colToPixel
      4  2130				   TEMPORARY_VAR SET	Overlay
      5  2130				   TEMPORARY_OFFSET SET	0
      6  2130				   VAR_BOUNDARY_colToPixel SET	TEMPORARY_OFFSET
      7  2130				   FUNCTION_NAME SET	colToPixel
    290  2130		       00 14 28 3c*	      .byte.b	0,20,40,60,80,100,120,140
    291  2138
    292  2138
    293  2138							;---------------------------------------------------------------------------------------------------
    294  2138
      0  2138					      DEF	aiMarchToTargetA
      1  2138				   SLOT_aiMarchToTargetA SET	_BANK_SLOT
      2  2138				   BANK_aiMarchToTargetA SET	SLOT_aiMarchToTargetA + _CURRENT_BANK
      3  2138				   aiMarchToTargetA
      4  2138				   TEMPORARY_VAR SET	Overlay
      5  2138				   TEMPORARY_OFFSET SET	0
      6  2138				   VAR_BOUNDARY_aiMarchToTargetA SET	TEMPORARY_OFFSET
      7  2138				   FUNCTION_NAME SET	aiMarchToTargetA
    296  2138					      SUBROUTINE
    297  2138
      0  2138					      REFER	AiStateMachine
      1  2138					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2138				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2138					      ENDIF
    299  2138
      0  2138					      VAR	__fromRow, 1
      1  2138		       00 a9	   __fromRow  =	TEMPORARY_VAR
      2  2138				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  2138
      4  2138				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  2138				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  2138				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  2138					      ENDIF
      8  2138				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  2138				  -	      ECHO	"Temporary Variable", __fromRow, "overflow!"
     10  2138				  -	      ERR
     11  2138					      ENDIF
     12  2138					      LIST	ON
      0  2138					      VAR	__boardIndex, 1
      1  2138		       00 aa	   __boardIndex =	TEMPORARY_VAR
      2  2138				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  2138
      4  2138				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  2138				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  2138				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  2138					      ENDIF
      8  2138				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  2138				  -	      ECHO	"Temporary Variable", __boardIndex, "overflow!"
     10  2138				  -	      ERR
     11  2138					      ENDIF
     12  2138					      LIST	ON
      0  2138					      VAR	__fromCol, 1
      1  2138		       00 ab	   __fromCol  =	TEMPORARY_VAR
      2  2138				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  2138
      4  2138				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  2138				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  2138				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  2138					      ENDIF
      8  2138				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  2138				  -	      ECHO	"Temporary Variable", __fromCol, "overflow!"
     10  2138				  -	      ERR
     11  2138					      ENDIF
     12  2138					      LIST	ON
      0  2138					      VAR	__toCol, 1
      1  2138		       00 ac	   __toCol    =	TEMPORARY_VAR
      2  2138				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  2138
      4  2138				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  2138				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  2138				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  2138					      ENDIF
      8  2138				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  2138				  -	      ECHO	"Temporary Variable", __toCol, "overflow!"
     10  2138				  -	      ERR
     11  2138					      ENDIF
     12  2138					      LIST	ON
    304  2138
      0  2138					      VEND	aiMarchToTargetA
      1  2138				  -	      IFNCONST	aiMarchToTargetA
      2  2138				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetA
      3  2138				  -	      ERR
      4  2138					      ENDIF
      5  2138		       00 ad	   VAREND_aiMarchToTargetA =	TEMPORARY_VAR
    306  2138
    307  2138
    308  2138		       a5 82		      lda	drawDelay
    309  213a		       f0 03		      beq	.nodelay
    310  213c		       c6 82		      dec	drawDelay
    311  213e		       60		      rts
    312  213f				   .nodelay
    313  213f
    314  213f							; Now we calculate move to new square
    315  213f
    316  213f		       a5 85		      lda	fromX12
    317  2141		       c5 86		      cmp	toX12
    318  2143		       f0 44		      beq	.unmovedx
    319  2145		       85 83		      sta	lastSquareX12
    320  2147
    321  2147		       38		      sec
    322  2148		       a2 fd		      ldx	#-3
    323  214a		       e9 0a	   .sub10     sbc	#10
    324  214c		       e8		      inx
    325  214d		       b0 fb		      bcs	.sub10
    326  214f		       69 08		      adc	#8
    327  2151		       85 ab		      sta	__fromCol
    328  2153		       86 a9		      stx	__fromRow
    329  2155
    330  2155		       a5 86		      lda	toX12
    331  2157		       38		      sec
    332  2158		       a2 fd		      ldx	#-3
    333  215a		       e9 0a	   .sub10b    sbc	#10
    334  215c		       e8		      inx
    335  215d		       b0 fb		      bcs	.sub10b
    336  215f		       69 08		      adc	#8
    337  2161		       85 ac		      sta	__toCol
    338  2163
    339  2163
    340  2163		       e4 a9		      cpx	__fromRow
    341  2165		       f0 13		      beq	.rowDone
    342  2167
    343  2167		       b0 0a		      bcs	.incRow
    344  2169
    345  2169		       38		      sec
    346  216a		       a5 85		      lda	fromX12
    347  216c		       e9 0a		      sbc	#10
    348  216e		       85 85		      sta	fromX12
    349  2170		       4c 7a f5 	      jmp	.rowDone
    350  2173
    351  2173		       18	   .incRow    clc
    352  2174		       a5 85		      lda	fromX12
    353  2176		       69 0a		      adc	#10
    354  2178		       85 85		      sta	fromX12
    355  217a
    356  217a				   .rowDone
    357  217a
    358  217a		       a5 ac		      lda	__toCol
    359  217c		       c5 ab		      cmp	__fromCol
    360  217e		       f0 09		      beq	.colDone
    361  2180
    362  2180		       b0 05		      bcs	.incCol
    363  2182
    364  2182		       c6 85		      dec	fromX12
    365  2184		       4c 89 f5 	      jmp	.colDone
    366  2187
    367  2187		       e6 85	   .incCol    inc	fromX12
    368  2189				   .colDone
    369  2189				   .unmovedx
    370  2189
    371  2189		       a5 87		      lda	originX12
    372  218b		       85 88		      sta	cursorX12
    373  218d
      0  218d					      PHASE	AI_MarchA2
      1  218d		       a9 17		      lda	#AI_MarchA2
      2  218f		       85 8b		      sta	aiState
    375  2191		       60		      rts
    376  2192
    377  2192
    378  2192							;---------------------------------------------------------------------------------------------------
    379  2192
      0  2192					      DEF	aiFinalFlash
      1  2192				   SLOT_aiFinalFlash SET	_BANK_SLOT
      2  2192				   BANK_aiFinalFlash SET	SLOT_aiFinalFlash + _CURRENT_BANK
      3  2192				   aiFinalFlash
      4  2192				   TEMPORARY_VAR SET	Overlay
      5  2192				   TEMPORARY_OFFSET SET	0
      6  2192				   VAR_BOUNDARY_aiFinalFlash SET	TEMPORARY_OFFSET
      7  2192				   FUNCTION_NAME SET	aiFinalFlash
    381  2192					      SUBROUTINE
    382  2192
      0  2192					      REFER	AiStateMachine
      1  2192					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2192				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2192					      ENDIF
      0  2192					      VEND	aiFinalFlash
      1  2192				  -	      IFNCONST	aiFinalFlash
      2  2192				  -	      ECHO	"Incorrect VEND label", aiFinalFlash
      3  2192				  -	      ERR
      4  2192					      ENDIF
      5  2192		       00 a9	   VAREND_aiFinalFlash =	TEMPORARY_VAR
    385  2192
    386  2192							; Piece has finished the animated move and is now in destination square.
    387  2192							; Flash the piece
    388  2192
    389  2192
    390  2192							; TODO: if en-passant, we can remove the piece being taken
    391  2192							; check movePiece for enPassant flag set (x)
    392  2192
    393  2192
    394  2192		       a5 82		      lda	drawDelay
    395  2194		       f0 03		      beq	.deCount
    396  2196		       c6 82		      dec	drawDelay
    397  2198		       60		      rts
    398  2199
    399  2199		       a5 84	   .deCount   lda	drawCount
    400  219b		       f0 0e		      beq	.flashDone2
    401  219d		       c6 84		      dec	drawCount
    402  219f
    403  219f		       a9 0a		      lda	#10
    404  21a1		       85 82		      sta	drawDelay	; "getting ready to move" flash
    405  21a3
    406  21a3		       a5 85		      lda	fromX12
    407  21a5		       85 80		      sta	squareToDraw
    408  21a7
    409  21a7							; WARNING - local variables will not survive the following call...!
    410  21a7		       20 cb f0 	      jsr	CopySinglePiece	;@0
    411  21aa		       60		      rts
    412  21ab
    413  21ab				   .flashDone2
    414  21ab
    415  21ab		       a9 64		      lda	#100
    416  21ad		       85 8c		      sta	aiFlashDelay
    417  21af
      0  21af					      PHASE	AI_SpecialMoveFixup
      1  21af		       a9 1c		      lda	#AI_SpecialMoveFixup
      2  21b1		       85 8b		      sta	aiState
    419  21b3		       60		      rts
    420  21b4
    421  21b4
    422  21b4							;---------------------------------------------------------------------------------------------------
    423  21b4
      0  21b4					      DEF	aiStartSquareSelected
      1  21b4				   SLOT_aiStartSquareSelected SET	_BANK_SLOT
      2  21b4				   BANK_aiStartSquareSelected SET	SLOT_aiStartSquareSelected + _CURRENT_BANK
      3  21b4				   aiStartSquareSelected
      4  21b4				   TEMPORARY_VAR SET	Overlay
      5  21b4				   TEMPORARY_OFFSET SET	0
      6  21b4				   VAR_BOUNDARY_aiStartSquareSelected SET	TEMPORARY_OFFSET
      7  21b4				   FUNCTION_NAME SET	aiStartSquareSelected
    425  21b4					      SUBROUTINE
    426  21b4
      0  21b4					      REFER	AiStateMachine
      1  21b4					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  21b4				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  21b4					      ENDIF
      0  21b4					      VEND	aiStartSquareSelected
      1  21b4				  -	      IFNCONST	aiStartSquareSelected
      2  21b4				  -	      ECHO	"Incorrect VEND label", aiStartSquareSelected
      3  21b4				  -	      ERR
      4  21b4					      ENDIF
      5  21b4		       00 a9	   VAREND_aiStartSquareSelected =	TEMPORARY_VAR
    429  21b4
    430  21b4
    431  21b4							; Mark all the valid moves for the selected piece on the board
    432  21b4							; and then start pulsing the piece
    433  21b4							; AND start choosing for selection of TO square
    434  21b4
    435  21b4							; Iterate the movelist and for all from squares which = drawPieceNumber
    436  21b4							; then draw a BLANK at that square
    437  21b4							; do 1 by one, when none found then increment state
    438  21b4
    439  21b4		       a5 88		      lda	cursorX12
    440  21b6		       85 80		      sta	squareToDraw
    441  21b8
    442  21b8		       a9 0a		      lda	#10
    443  21ba		       85 8c		      sta	aiFlashDelay
    444  21bc
    445  21bc		       a9 00		      lda	#0
    446  21be		       85 86		      sta	toX12	;aiToSquareX12
    447  21c0		       85 8e		      sta	aiFlashPhase	; for debounce exit timing
    448  21c2
    449  21c2		       a9 ff		      lda	#-1
    450  21c4		       85 8d		      sta	aiMoveIndex
    451  21c6
    452  21c6		       a9 28		      lda	#HOLD_DELAY
    453  21c8		       85 89		      sta	mdelay	; hold-down delay before moves are shown
    454  21ca
      0  21ca					      PHASE	AI_DrawMoves
      1  21ca		       a9 04		      lda	#AI_DrawMoves
      2  21cc		       85 8b		      sta	aiState
    456  21ce		       60		      rts
    457  21cf
    458  21cf
    459  21cf							;---------------------------------------------------------------------------------------------------
    460  21cf
      0  21cf					      DEF	aiWriteStartPieceBlank
      1  21cf				   SLOT_aiWriteStartPieceBlank SET	_BANK_SLOT
      2  21cf				   BANK_aiWriteStartPieceBlank SET	SLOT_aiWriteStartPieceBlank + _CURRENT_BANK
      3  21cf				   aiWriteStartPieceBlank
      4  21cf				   TEMPORARY_VAR SET	Overlay
      5  21cf				   TEMPORARY_OFFSET SET	0
      6  21cf				   VAR_BOUNDARY_aiWriteStartPieceBlank SET	TEMPORARY_OFFSET
      7  21cf				   FUNCTION_NAME SET	aiWriteStartPieceBlank
    462  21cf					      SUBROUTINE
    463  21cf
      0  21cf					      REFER	AiStateMachine
      1  21cf					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  21cf				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  21cf					      ENDIF
      0  21cf					      VEND	aiWriteStartPieceBlank
      1  21cf				  -	      IFNCONST	aiWriteStartPieceBlank
      2  21cf				  -	      ECHO	"Incorrect VEND label", aiWriteStartPieceBlank
      3  21cf				  -	      ERR
      4  21cf					      ENDIF
      5  21cf		       00 a9	   VAREND_aiWriteStartPieceBlank =	TEMPORARY_VAR
    466  21cf
    467  21cf							; Flash the piece in-place preparatory to moving it.
    468  21cf							; drawDelay = flash speed
    469  21cf							; drawCount = # of flashes
    470  21cf
    471  21cf
    472  21cf		       a9 04		      lda	#%100
    473  21d1		       85 4a		      sta	CTRLPF
    474  21d3		       a9 04		      lda	#4
    475  21d5		       85 46		      sta	COLUP0
    476  21d7
    477  21d7
    478  21d7		       a5 82		      lda	drawDelay
    479  21d9		       f0 03		      beq	deCount
    480  21db		       c6 82		      dec	drawDelay
    481  21dd		       60		      rts
    482  21de				   deCount
    483  21de
    484  21de		       a5 84		      lda	drawCount
    485  21e0		       f0 0d		      beq	flashDone
    486  21e2		       c6 84		      dec	drawCount
    487  21e4
    488  21e4		       a9 0a		      lda	#READY_TO_MOVE_FLASH
    489  21e6		       85 82		      sta	drawDelay	; "getting ready to move" flash
    490  21e8
    491  21e8		       a5 85		      lda	fromX12
    492  21ea		       85 80		      sta	squareToDraw
    493  21ec
    494  21ec							; WARNING - local variables will not survive the following call...!
    495  21ec		       4c cb f0 	      jmp	CopySinglePiece	;@0	      ; EOR-draw = flash
    496  21ef
    497  21ef				   flashDone
    498  21ef
    499  21ef							;lda #2
    500  21ef							;sta drawDelay
      0  21ef					      PHASE	AI_MarchToTargetA
      1  21ef		       a9 16		      lda	#AI_MarchToTargetA
      2  21f1		       85 8b		      sta	aiState
    502  21f3		       60		      rts
    503  21f4
    504  21f4
    505  21f4							;---------------------------------------------------------------------------------------------------
    506  21f4
      0  21f4					      CHECK_BANK_SIZE	"BANK_StateMachine2"
      1  21f4		       01 f4	   .TEMP      =	* - _BANK_START
 BANK_StateMachine2 (1K) SIZE =  $1f4 , FREE= $20c
      2  21f4					      ECHO	"BANK_StateMachine2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  21f4				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  21f4				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_StateMachine2", " size=", * - ORIGIN
      5  21f4				  -	      ERR
      6  21f4					      ENDIF
    508  21f4
    509  21f4							;---------------------------------------------------------------------------------------------------
    510  21f4
    511  21f4							; EOF
------- FILE ./chess.asm
------- FILE piece_graphics.asm LEVEL 2 PASS 4
      0  21f4					      include	"piece_graphics.asm"
      1  21f4							; Import the graphics definitions generated by ConvertChessPieces.py
      2  21f4
      0  21f4					      SLOT	2
      1  21f4				  -	      IF	(2 < 0) || (2 > 3)
      2  21f4				  -	      ECHO	"Illegal bank address/segment location", 2
      3  21f4				  -	      ERR
      4  21f4					      ENDIF
      5  21f4				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  21f4				   _BANK_SLOT SET	2 * 64
      0  21f4					      ROMBANK	PIECES_0
      1  27d8 ????				      SEG	PIECES_0
      2  2400					      ORG	_ORIGIN
      3  2400					      RORG	_BANK_ADDRESS_ORIGIN
      4  2400				   _BANK_START SET	*
      5  2400				   PIECES_0_START SET	*
      6  2400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2400				   PIECES_0   SET	_BANK_SLOT + _CURRENT_BANK
      8  2400				   _ORIGIN    SET	_ORIGIN + 1024
      5  2400
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2400					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm"
      0  2400					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_0", 72
     12  2400					      LIST	ON
      0  2400					      DEF	WHITE_BLANK_on_WHITE_SQUARE_0
      1  2400				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2400				   BANK_WHITE_BLANK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2400				   WHITE_BLANK_on_WHITE_SQUARE_0
      4  2400				   TEMPORARY_VAR SET	Overlay
      5  2400				   TEMPORARY_OFFSET SET	0
      6  2400				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2400				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_0
      3  2400		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  2418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  2430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2448					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm"
      0  2448					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_1", 72
     12  2448					      LIST	ON
      0  2448					      DEF	WHITE_BLANK_on_WHITE_SQUARE_1
      1  2448				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2448				   BANK_WHITE_BLANK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2448				   WHITE_BLANK_on_WHITE_SQUARE_1
      4  2448				   TEMPORARY_VAR SET	Overlay
      5  2448				   TEMPORARY_OFFSET SET	0
      6  2448				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2448				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_1
      3  2448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2460		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  2478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2490					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm"
      0  2490					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_2", 72
     12  2490					      LIST	ON
      0  2490					      DEF	WHITE_BLANK_on_WHITE_SQUARE_2
      1  2490				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2490				   BANK_WHITE_BLANK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2490				   WHITE_BLANK_on_WHITE_SQUARE_2
      4  2490				   TEMPORARY_VAR SET	Overlay
      5  2490				   TEMPORARY_OFFSET SET	0
      6  2490				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2490				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_2
      3  2490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  24a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  24c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  24d8					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm"
      0  24d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_3", 72
     12  2500					      LIST	ON
      0  2500					      DEF	WHITE_BLANK_on_WHITE_SQUARE_3
      1  2500				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2500				   BANK_WHITE_BLANK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2500				   WHITE_BLANK_on_WHITE_SQUARE_3
      4  2500				   TEMPORARY_VAR SET	Overlay
      5  2500				   TEMPORARY_OFFSET SET	0
      6  2500				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2500				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_3
      3  2500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2530		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2548					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm"
      0  2548					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_0", 72
     12  2548					      LIST	ON
      0  2548					      DEF	WHITE_PAWN_on_WHITE_SQUARE_0
      1  2548				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2548				   BANK_WHITE_PAWN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2548				   WHITE_PAWN_on_WHITE_SQUARE_0
      4  2548				   TEMPORARY_VAR SET	Overlay
      5  2548				   TEMPORARY_OFFSET SET	0
      6  2548				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2548				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_0
      3  2548		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2590					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm"
      0  2590					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_1", 72
     12  2590					      LIST	ON
      0  2590					      DEF	WHITE_PAWN_on_WHITE_SQUARE_1
      1  2590				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2590				   BANK_WHITE_PAWN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2590				   WHITE_PAWN_on_WHITE_SQUARE_1
      4  2590				   TEMPORARY_VAR SET	Overlay
      5  2590				   TEMPORARY_OFFSET SET	0
      6  2590				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2590				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_1
      3  2590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  25a8		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  25c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  25d8					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm"
      0  25d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_2", 72
     12  2600					      LIST	ON
      0  2600					      DEF	WHITE_PAWN_on_WHITE_SQUARE_2
      1  2600				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2600				   BANK_WHITE_PAWN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2600				   WHITE_PAWN_on_WHITE_SQUARE_2
      4  2600				   TEMPORARY_VAR SET	Overlay
      5  2600				   TEMPORARY_OFFSET SET	0
      6  2600				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2600				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_2
      3  2600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2618		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2630		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2648					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm"
      0  2648					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_3", 72
     12  2648					      LIST	ON
      0  2648					      DEF	WHITE_PAWN_on_WHITE_SQUARE_3
      1  2648				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2648				   BANK_WHITE_PAWN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2648				   WHITE_PAWN_on_WHITE_SQUARE_3
      4  2648				   TEMPORARY_VAR SET	Overlay
      5  2648				   TEMPORARY_OFFSET SET	0
      6  2648				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2648				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_3
      3  2648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2678		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2690					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  2690					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_0", 72
     12  2690					      LIST	ON
      0  2690					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_0
      1  2690				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2690				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2690				   WHITE_KNIGHT_on_WHITE_SQUARE_0
      4  2690				   TEMPORARY_VAR SET	Overlay
      5  2690				   TEMPORARY_OFFSET SET	0
      6  2690				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2690				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_0
      3  2690		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  26a8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  26c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  26d8					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  26d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_1", 72
     12  2700					      LIST	ON
      0  2700					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_1
      1  2700				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2700				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2700				   WHITE_KNIGHT_on_WHITE_SQUARE_1
      4  2700				   TEMPORARY_VAR SET	Overlay
      5  2700				   TEMPORARY_OFFSET SET	0
      6  2700				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2700				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_1
      3  2700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2718		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2748					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  2748					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_2", 72
     12  2748					      LIST	ON
      0  2748					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_2
      1  2748				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2748				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2748				   WHITE_KNIGHT_on_WHITE_SQUARE_2
      4  2748				   TEMPORARY_VAR SET	Overlay
      5  2748				   TEMPORARY_OFFSET SET	0
      6  2748				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2748				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_2
      3  2748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2760		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2778		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2790					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  2790					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_3", 72
     12  2790					      LIST	ON
      0  2790					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_3
      1  2790				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2790				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2790				   WHITE_KNIGHT_on_WHITE_SQUARE_3
      4  2790				   TEMPORARY_VAR SET	Overlay
      5  2790				   TEMPORARY_OFFSET SET	0
      6  2790				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2790				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_3
      3  2790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  27a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  27c0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  27d8					      CHECK_BANK_SIZE	"PIECES_0 (1K)"
      1  27d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_0 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  27d8					      ECHO	"PIECES_0 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  27d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  27d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_0 (1K)", " size=", * - ORIGIN
      5  27d8				  -	      ERR
      6  27d8					      ENDIF
     19  27d8
      0  27d8					      SLOT	2
      1  27d8				  -	      IF	(2 < 0) || (2 > 3)
      2  27d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  27d8				  -	      ERR
      4  27d8					      ENDIF
      5  27d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  27d8				   _BANK_SLOT SET	2 * 64
      0  27d8					      ROMBANK	PIECES_1
      1  2bd8 ????				      SEG	PIECES_1
      2  2800					      ORG	_ORIGIN
      3  2800					      RORG	_BANK_ADDRESS_ORIGIN
      4  2800				   _BANK_START SET	*
      5  2800				   PIECES_1_START SET	*
      6  2800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2800				   PIECES_1   SET	_BANK_SLOT + _CURRENT_BANK
      8  2800				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2800					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm"
      0  2800					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_0", 72
     12  2800					      LIST	ON
      0  2800					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_0
      1  2800				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2800				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2800				   WHITE_BISHOP_on_WHITE_SQUARE_0
      4  2800				   TEMPORARY_VAR SET	Overlay
      5  2800				   TEMPORARY_OFFSET SET	0
      6  2800				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2800				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_0
      3  2800		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$40,$20,$00,$00,$00	;PF0
      4  2818		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2848					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm"
      0  2848					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_1", 72
     12  2848					      LIST	ON
      0  2848					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_1
      1  2848				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2848				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2848				   WHITE_BISHOP_on_WHITE_SQUARE_1
      4  2848				   TEMPORARY_VAR SET	Overlay
      5  2848				   TEMPORARY_OFFSET SET	0
      6  2848				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2848				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_1
      3  2848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2860		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$10,$20,$00,$00,$00	;PF1
      5  2878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2890					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm"
      0  2890					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_2", 72
     12  2890					      LIST	ON
      0  2890					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_2
      1  2890				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2890				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2890				   WHITE_BISHOP_on_WHITE_SQUARE_2
      4  2890				   TEMPORARY_VAR SET	Overlay
      5  2890				   TEMPORARY_OFFSET SET	0
      6  2890				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2890				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_2
      3  2890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  28a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$01,$00,$00,$00	;PF1
      5  28c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$01,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  28d8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm"
      0  28d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_3", 72
     12  2900					      LIST	ON
      0  2900					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_3
      1  2900				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2900				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2900				   WHITE_BISHOP_on_WHITE_SQUARE_3
      4  2900				   TEMPORARY_VAR SET	Overlay
      5  2900				   TEMPORARY_OFFSET SET	0
      6  2900				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2900				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_3
      3  2900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2930		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$20,$10,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2948					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm"
      0  2948					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_0", 72
     12  2948					      LIST	ON
      0  2948					      DEF	WHITE_ROOK_on_WHITE_SQUARE_0
      1  2948				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2948				   BANK_WHITE_ROOK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2948				   WHITE_ROOK_on_WHITE_SQUARE_0
      4  2948				   TEMPORARY_VAR SET	Overlay
      5  2948				   TEMPORARY_OFFSET SET	0
      6  2948				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2948				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_0
      3  2948		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2960		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2990					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm"
      0  2990					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_1", 72
     12  2990					      LIST	ON
      0  2990					      DEF	WHITE_ROOK_on_WHITE_SQUARE_1
      1  2990				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2990				   BANK_WHITE_ROOK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2990				   WHITE_ROOK_on_WHITE_SQUARE_1
      4  2990				   TEMPORARY_VAR SET	Overlay
      5  2990				   TEMPORARY_OFFSET SET	0
      6  2990				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2990				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_1
      3  2990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  29a8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  29c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  29d8					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm"
      0  29d8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_2", 72
     12  2a00					      LIST	ON
      0  2a00					      DEF	WHITE_ROOK_on_WHITE_SQUARE_2
      1  2a00				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2a00				   BANK_WHITE_ROOK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2a00				   WHITE_ROOK_on_WHITE_SQUARE_2
      4  2a00				   TEMPORARY_VAR SET	Overlay
      5  2a00				   TEMPORARY_OFFSET SET	0
      6  2a00				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2a00				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_2
      3  2a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a18		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2a30		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2a48					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm"
      0  2a48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_3", 72
     12  2a48					      LIST	ON
      0  2a48					      DEF	WHITE_ROOK_on_WHITE_SQUARE_3
      1  2a48				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2a48				   BANK_WHITE_ROOK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2a48				   WHITE_ROOK_on_WHITE_SQUARE_3
      4  2a48				   TEMPORARY_VAR SET	Overlay
      5  2a48				   TEMPORARY_OFFSET SET	0
      6  2a48				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2a48				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_3
      3  2a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2a78		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2a90					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm"
      0  2a90					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_0", 72
     12  2a90					      LIST	ON
      0  2a90					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_0
      1  2a90				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2a90				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2a90				   WHITE_QUEEN_on_WHITE_SQUARE_0
      4  2a90				   TEMPORARY_VAR SET	Overlay
      5  2a90				   TEMPORARY_OFFSET SET	0
      6  2a90				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2a90				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_0
      3  2a90		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2aa8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2ad8					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm"
      0  2ad8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_1", 72
     12  2b00					      LIST	ON
      0  2b00					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_1
      1  2b00				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2b00				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2b00				   WHITE_QUEEN_on_WHITE_SQUARE_1
      4  2b00				   TEMPORARY_VAR SET	Overlay
      5  2b00				   TEMPORARY_OFFSET SET	0
      6  2b00				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2b00				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_1
      3  2b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b18		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2b48					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm"
      0  2b48					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_2", 72
     12  2b48					      LIST	ON
      0  2b48					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_2
      1  2b48				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2b48				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2b48				   WHITE_QUEEN_on_WHITE_SQUARE_2
      4  2b48				   TEMPORARY_VAR SET	Overlay
      5  2b48				   TEMPORARY_OFFSET SET	0
      6  2b48				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2b48				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_2
      3  2b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b60		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2b78		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2b90					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm"
      0  2b90					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_3", 72
     12  2b90					      LIST	ON
      0  2b90					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_3
      1  2b90				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2b90				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2b90				   WHITE_QUEEN_on_WHITE_SQUARE_3
      4  2b90				   TEMPORARY_VAR SET	Overlay
      5  2b90				   TEMPORARY_OFFSET SET	0
      6  2b90				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2b90				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_3
      3  2b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2bc0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  2bd8					      CHECK_BANK_SIZE	"PIECES_1 (1K)"
      1  2bd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_1 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  2bd8					      ECHO	"PIECES_1 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2bd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_1 (1K)", " size=", * - ORIGIN
      5  2bd8				  -	      ERR
      6  2bd8					      ENDIF
      0  2bd8					      SLOT	2
      1  2bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  2bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  2bd8				  -	      ERR
      4  2bd8					      ENDIF
      5  2bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  2bd8				   _BANK_SLOT SET	2 * 64
      0  2bd8					      ROMBANK	PIECES_2
      1  2fd8 ????				      SEG	PIECES_2
      2  2c00					      ORG	_ORIGIN
      3  2c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  2c00				   _BANK_START SET	*
      5  2c00				   PIECES_2_START SET	*
      6  2c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2c00				   PIECES_2   SET	_BANK_SLOT + _CURRENT_BANK
      8  2c00				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2c00					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_0.asm"
      0  2c00					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_0", 72
     12  2c00					      LIST	ON
      0  2c00					      DEF	WHITE_KING_on_WHITE_SQUARE_0
      1  2c00				   SLOT_WHITE_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2c00				   BANK_WHITE_KING_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2c00				   WHITE_KING_on_WHITE_SQUARE_0
      4  2c00				   TEMPORARY_VAR SET	Overlay
      5  2c00				   TEMPORARY_OFFSET SET	0
      6  2c00				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2c00				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_0
      3  2c00		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$80,$40,$00,$00	;PF0
      4  2c18		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2c48					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_1.asm"
      0  2c48					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_1", 72
     12  2c48					      LIST	ON
      0  2c48					      DEF	WHITE_KING_on_WHITE_SQUARE_1
      1  2c48				   SLOT_WHITE_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2c48				   BANK_WHITE_KING_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2c48				   WHITE_KING_on_WHITE_SQUARE_1
      4  2c48				   TEMPORARY_VAR SET	Overlay
      5  2c48				   TEMPORARY_OFFSET SET	0
      6  2c48				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2c48				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_1
      3  2c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c60		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$08,$10,$00,$00	;PF1
      5  2c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2c90					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_2.asm"
      0  2c90					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_2", 72
     12  2c90					      LIST	ON
      0  2c90					      DEF	WHITE_KING_on_WHITE_SQUARE_2
      1  2c90				   SLOT_WHITE_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2c90				   BANK_WHITE_KING_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2c90				   WHITE_KING_on_WHITE_SQUARE_2
      4  2c90				   TEMPORARY_VAR SET	Overlay
      5  2c90				   TEMPORARY_OFFSET SET	0
      6  2c90				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2c90				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_2
      3  2c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ca8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2cc0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$02,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2cd8					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_3.asm"
      0  2cd8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_3", 72
     12  2d00					      LIST	ON
      0  2d00					      DEF	WHITE_KING_on_WHITE_SQUARE_3
      1  2d00				   SLOT_WHITE_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2d00				   BANK_WHITE_KING_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2d00				   WHITE_KING_on_WHITE_SQUARE_3
      4  2d00				   TEMPORARY_VAR SET	Overlay
      5  2d00				   TEMPORARY_OFFSET SET	0
      6  2d00				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2d00				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_3
      3  2d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d30		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$40,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2d48					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm"
      0  2d48					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_0", 72
     12  2d48					      LIST	ON
      0  2d48					      DEF	WHITE_BLANK_on_BLACK_SQUARE_0
      1  2d48				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2d48				   BANK_WHITE_BLANK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2d48				   WHITE_BLANK_on_BLACK_SQUARE_0
      4  2d48				   TEMPORARY_VAR SET	Overlay
      5  2d48				   TEMPORARY_OFFSET SET	0
      6  2d48				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2d48				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_0
      3  2d48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2d90					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm"
      0  2d90					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_1", 72
     12  2d90					      LIST	ON
      0  2d90					      DEF	WHITE_BLANK_on_BLACK_SQUARE_1
      1  2d90				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2d90				   BANK_WHITE_BLANK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2d90				   WHITE_BLANK_on_BLACK_SQUARE_1
      4  2d90				   TEMPORARY_VAR SET	Overlay
      5  2d90				   TEMPORARY_OFFSET SET	0
      6  2d90				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2d90				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_1
      3  2d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2da8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2dd8					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm"
      0  2dd8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_2", 72
     12  2e00					      LIST	ON
      0  2e00					      DEF	WHITE_BLANK_on_BLACK_SQUARE_2
      1  2e00				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2e00				   BANK_WHITE_BLANK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2e00				   WHITE_BLANK_on_BLACK_SQUARE_2
      4  2e00				   TEMPORARY_VAR SET	Overlay
      5  2e00				   TEMPORARY_OFFSET SET	0
      6  2e00				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2e00				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_2
      3  2e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2e48					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm"
      0  2e48					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_3", 72
     12  2e48					      LIST	ON
      0  2e48					      DEF	WHITE_BLANK_on_BLACK_SQUARE_3
      1  2e48				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2e48				   BANK_WHITE_BLANK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2e48				   WHITE_BLANK_on_BLACK_SQUARE_3
      4  2e48				   TEMPORARY_VAR SET	Overlay
      5  2e48				   TEMPORARY_OFFSET SET	0
      6  2e48				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2e48				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_3
      3  2e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2e90					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm"
      0  2e90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_0", 72
     12  2e90					      LIST	ON
      0  2e90					      DEF	WHITE_PAWN_on_BLACK_SQUARE_0
      1  2e90				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2e90				   BANK_WHITE_PAWN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2e90				   WHITE_PAWN_on_BLACK_SQUARE_0
      4  2e90				   TEMPORARY_VAR SET	Overlay
      5  2e90				   TEMPORARY_OFFSET SET	0
      6  2e90				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2e90				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_0
      3  2e90		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  2ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2ed8					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm"
      0  2ed8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_1", 72
     12  2f00					      LIST	ON
      0  2f00					      DEF	WHITE_PAWN_on_BLACK_SQUARE_1
      1  2f00				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2f00				   BANK_WHITE_PAWN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2f00				   WHITE_PAWN_on_BLACK_SQUARE_1
      4  2f00				   TEMPORARY_VAR SET	Overlay
      5  2f00				   TEMPORARY_OFFSET SET	0
      6  2f00				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2f00				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_1
      3  2f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f18		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  2f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2f48					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm"
      0  2f48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_2", 72
     12  2f48					      LIST	ON
      0  2f48					      DEF	WHITE_PAWN_on_BLACK_SQUARE_2
      1  2f48				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2f48				   BANK_WHITE_PAWN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2f48				   WHITE_PAWN_on_BLACK_SQUARE_2
      4  2f48				   TEMPORARY_VAR SET	Overlay
      5  2f48				   TEMPORARY_OFFSET SET	0
      6  2f48				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2f48				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_2
      3  2f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f60		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  2f78		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2f90					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm"
      0  2f90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_3", 72
     12  2f90					      LIST	ON
      0  2f90					      DEF	WHITE_PAWN_on_BLACK_SQUARE_3
      1  2f90				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2f90				   BANK_WHITE_PAWN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2f90				   WHITE_PAWN_on_BLACK_SQUARE_3
      4  2f90				   TEMPORARY_VAR SET	Overlay
      5  2f90				   TEMPORARY_OFFSET SET	0
      6  2f90				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2f90				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_3
      3  2f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2fc0		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
      0  2fd8					      CHECK_BANK_SIZE	"PIECES_2 (1K)"
      1  2fd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_2 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  2fd8					      ECHO	"PIECES_2 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2fd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_2 (1K)", " size=", * - ORIGIN
      5  2fd8				  -	      ERR
      6  2fd8					      ENDIF
      0  2fd8					      SLOT	2
      1  2fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  2fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  2fd8				  -	      ERR
      4  2fd8					      ENDIF
      5  2fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  2fd8				   _BANK_SLOT SET	2 * 64
      0  2fd8					      ROMBANK	PIECES_3
      1  33d8 ????				      SEG	PIECES_3
      2  3000					      ORG	_ORIGIN
      3  3000					      RORG	_BANK_ADDRESS_ORIGIN
      4  3000				   _BANK_START SET	*
      5  3000				   PIECES_3_START SET	*
      6  3000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3000				   PIECES_3   SET	_BANK_SLOT + _CURRENT_BANK
      8  3000				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3000					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  3000					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_0", 72
     12  3000					      LIST	ON
      0  3000					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_0
      1  3000				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3000				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3000				   WHITE_KNIGHT_on_BLACK_SQUARE_0
      4  3000				   TEMPORARY_VAR SET	Overlay
      5  3000				   TEMPORARY_OFFSET SET	0
      6  3000				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3000				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_0
      3  3000		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$f0,$e0,$e0,$f0,$f0,$40,$00	;PF0
      4  3018		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  3030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3048					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  3048					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_1", 72
     12  3048					      LIST	ON
      0  3048					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_1
      1  3048				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3048				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3048				   WHITE_KNIGHT_on_BLACK_SQUARE_1
      4  3048				   TEMPORARY_VAR SET	Overlay
      5  3048				   TEMPORARY_OFFSET SET	0
      6  3048				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3048				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_1
      3  3048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3060		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$78,$38,$3c,$7c,$7c,$14,$00	;PF1
      5  3078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3090					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  3090					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_2", 72
     12  3090					      LIST	ON
      0  3090					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_2
      1  3090				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3090				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3090				   WHITE_KNIGHT_on_BLACK_SQUARE_2
      4  3090				   TEMPORARY_VAR SET	Overlay
      5  3090				   TEMPORARY_OFFSET SET	0
      6  3090				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3090				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_2
      3  3090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  30a8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$01,$03,$03,$00,$00	;PF1
      5  30c0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$03,$03,$07,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  30d8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  30d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_3", 72
     12  3100					      LIST	ON
      0  3100					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_3
      1  3100				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3100				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3100				   WHITE_KNIGHT_on_BLACK_SQUARE_3
      4  3100				   TEMPORARY_VAR SET	Overlay
      5  3100				   TEMPORARY_OFFSET SET	0
      6  3100				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3100				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_3
      3  3100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3130		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$78,$70,$f0,$f8,$f8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3148					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm"
      0  3148					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_0", 72
     12  3148					      LIST	ON
      0  3148					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_0
      1  3148				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3148				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3148				   WHITE_BISHOP_on_BLACK_SQUARE_0
      4  3148				   TEMPORARY_VAR SET	Overlay
      5  3148				   TEMPORARY_OFFSET SET	0
      6  3148				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3148				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_0
      3  3148		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$b0,$d0,$e0,$40,$40	;PF0
      4  3160		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  3178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3190					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm"
      0  3190					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_1", 72
     12  3190					      LIST	ON
      0  3190					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_1
      1  3190				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3190				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3190				   WHITE_BISHOP_on_BLACK_SQUARE_1
      4  3190				   TEMPORARY_VAR SET	Overlay
      5  3190				   TEMPORARY_OFFSET SET	0
      6  3190				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3190				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_1
      3  3190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  31a8		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$6c,$5c,$38,$10,$10	;PF1
      5  31c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  31d8					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm"
      0  31d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_2", 72
     12  3200					      LIST	ON
      0  3200					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_2
      1  3200				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3200				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3200				   WHITE_BISHOP_on_BLACK_SQUARE_2
      4  3200				   TEMPORARY_VAR SET	Overlay
      5  3200				   TEMPORARY_OFFSET SET	0
      6  3200				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3200				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_2
      3  3200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3218		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  3230		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$06,$07,$03,$01,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3248					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm"
      0  3248					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_3", 72
     12  3248					      LIST	ON
      0  3248					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_3
      1  3248				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3248				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3248				   WHITE_BISHOP_on_BLACK_SQUARE_3
      4  3248				   TEMPORARY_VAR SET	Overlay
      5  3248				   TEMPORARY_OFFSET SET	0
      6  3248				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3248				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_3
      3  3248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3278		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$d8,$e8,$70,$20,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3290					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm"
      0  3290					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_0", 72
     12  3290					      LIST	ON
      0  3290					      DEF	WHITE_ROOK_on_BLACK_SQUARE_0
      1  3290				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3290				   BANK_WHITE_ROOK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3290				   WHITE_ROOK_on_BLACK_SQUARE_0
      4  3290				   TEMPORARY_VAR SET	Overlay
      5  3290				   TEMPORARY_OFFSET SET	0
      6  3290				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3290				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_0
      3  3290		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$f0,$50,$00	;PF0
      4  32a8		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  32c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  32d8					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm"
      0  32d8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_1", 72
     12  3300					      LIST	ON
      0  3300					      DEF	WHITE_ROOK_on_BLACK_SQUARE_1
      1  3300				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3300				   BANK_WHITE_ROOK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3300				   WHITE_ROOK_on_BLACK_SQUARE_1
      4  3300				   TEMPORARY_VAR SET	Overlay
      5  3300				   TEMPORARY_OFFSET SET	0
      6  3300				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3300				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_1
      3  3300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3318		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$7c,$54,$00	;PF1
      5  3330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3348					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm"
      0  3348					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_2", 72
     12  3348					      LIST	ON
      0  3348					      DEF	WHITE_ROOK_on_BLACK_SQUARE_2
      1  3348				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3348				   BANK_WHITE_ROOK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3348				   WHITE_ROOK_on_BLACK_SQUARE_2
      4  3348				   TEMPORARY_VAR SET	Overlay
      5  3348				   TEMPORARY_OFFSET SET	0
      6  3348				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3348				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_2
      3  3348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3360		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$03,$02,$00	;PF1
      5  3378		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3390					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm"
      0  3390					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_3", 72
     12  3390					      LIST	ON
      0  3390					      DEF	WHITE_ROOK_on_BLACK_SQUARE_3
      1  3390				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3390				   BANK_WHITE_ROOK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3390				   WHITE_ROOK_on_BLACK_SQUARE_3
      4  3390				   TEMPORARY_VAR SET	Overlay
      5  3390				   TEMPORARY_OFFSET SET	0
      6  3390				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3390				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_3
      3  3390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  33a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  33c0		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$f8,$a8,$00	;PF2
------- FILE piece_graphics.asm
      0  33d8					      CHECK_BANK_SIZE	"PIECES_3 (1K)"
      1  33d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_3 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  33d8					      ECHO	"PIECES_3 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  33d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  33d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_3 (1K)", " size=", * - ORIGIN
      5  33d8				  -	      ERR
      6  33d8					      ENDIF
      0  33d8					      SLOT	2
      1  33d8				  -	      IF	(2 < 0) || (2 > 3)
      2  33d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  33d8				  -	      ERR
      4  33d8					      ENDIF
      5  33d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  33d8				   _BANK_SLOT SET	2 * 64
      0  33d8					      ROMBANK	PIECE_4
      1  37d8 ????				      SEG	PIECE_4
      2  3400					      ORG	_ORIGIN
      3  3400					      RORG	_BANK_ADDRESS_ORIGIN
      4  3400				   _BANK_START SET	*
      5  3400				   PIECE_4_START SET	*
      6  3400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3400				   PIECE_4    SET	_BANK_SLOT + _CURRENT_BANK
      8  3400				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3400					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm"
      0  3400					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_0", 72
     12  3400					      LIST	ON
      0  3400					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_0
      1  3400				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3400				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3400				   WHITE_QUEEN_on_BLACK_SQUARE_0
      4  3400				   TEMPORARY_VAR SET	Overlay
      5  3400				   TEMPORARY_OFFSET SET	0
      6  3400				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3400				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_0
      3  3400		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  3418		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00,$80,$00	;PF1
      5  3430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3448					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm"
      0  3448					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_1", 72
     12  3448					      LIST	ON
      0  3448					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_1
      1  3448				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3448				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3448				   WHITE_QUEEN_on_BLACK_SQUARE_1
      4  3448				   TEMPORARY_VAR SET	Overlay
      5  3448				   TEMPORARY_OFFSET SET	0
      6  3448				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3448				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_1
      3  3448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3460		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$7c,$7c,$54,$00,$54,$00	;PF1
      5  3478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3490					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm"
      0  3490					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_2", 72
     12  3490					      LIST	ON
      0  3490					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_2
      1  3490				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3490				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3490				   WHITE_QUEEN_on_BLACK_SQUARE_2
      4  3490				   TEMPORARY_VAR SET	Overlay
      5  3490				   TEMPORARY_OFFSET SET	0
      6  3490				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3490				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_2
      3  3490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  34a8		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  34c0		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$07,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  34d8					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm"
      0  34d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_3", 72
     12  3500					      LIST	ON
      0  3500					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_3
      1  3500				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3500				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3500				   WHITE_QUEEN_on_BLACK_SQUARE_3
      4  3500				   TEMPORARY_VAR SET	Overlay
      5  3500				   TEMPORARY_OFFSET SET	0
      6  3500				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3500				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_3
      3  3500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3530		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$f8,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3548					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_0.asm"
      0  3548					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_0", 72
     12  3548					      LIST	ON
      0  3548					      DEF	WHITE_KING_on_BLACK_SQUARE_0
      1  3548				   SLOT_WHITE_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3548				   BANK_WHITE_KING_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3548				   WHITE_KING_on_BLACK_SQUARE_0
      4  3548				   TEMPORARY_VAR SET	Overlay
      5  3548				   TEMPORARY_OFFSET SET	0
      6  3548				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3548				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_0
      3  3548		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$70,$00,$e0,$40	;PF0
      4  3560		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  3578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3590					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_1.asm"
      0  3590					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_1", 72
     12  3590					      LIST	ON
      0  3590					      DEF	WHITE_KING_on_BLACK_SQUARE_1
      1  3590				   SLOT_WHITE_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3590				   BANK_WHITE_KING_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3590				   WHITE_KING_on_BLACK_SQUARE_1
      4  3590				   TEMPORARY_VAR SET	Overlay
      5  3590				   TEMPORARY_OFFSET SET	0
      6  3590				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3590				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_1
      3  3590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  35a8		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$74,$00,$38,$10	;PF1
      5  35c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  35d8					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_2.asm"
      0  35d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_2", 72
     12  3600					      LIST	ON
      0  3600					      DEF	WHITE_KING_on_BLACK_SQUARE_2
      1  3600				   SLOT_WHITE_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3600				   BANK_WHITE_KING_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3600				   WHITE_KING_on_BLACK_SQUARE_2
      4  3600				   TEMPORARY_VAR SET	Overlay
      5  3600				   TEMPORARY_OFFSET SET	0
      6  3600				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3600				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_2
      3  3600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3618		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  3630		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$05,$00,$03,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3648					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_3.asm"
      0  3648					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_3", 72
     12  3648					      LIST	ON
      0  3648					      DEF	WHITE_KING_on_BLACK_SQUARE_3
      1  3648				   SLOT_WHITE_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3648				   BANK_WHITE_KING_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3648				   WHITE_KING_on_BLACK_SQUARE_3
      4  3648				   TEMPORARY_VAR SET	Overlay
      5  3648				   TEMPORARY_OFFSET SET	0
      6  3648				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3648				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_3
      3  3648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3678		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$b8,$00,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3690					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm"
      0  3690					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_0", 72
     12  3690					      LIST	ON
      0  3690					      DEF	BLACK_BLANK_on_WHITE_SQUARE_0
      1  3690				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3690				   BANK_BLACK_BLANK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3690				   BLACK_BLANK_on_WHITE_SQUARE_0
      4  3690				   TEMPORARY_VAR SET	Overlay
      5  3690				   TEMPORARY_OFFSET SET	0
      6  3690				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3690				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_0
      3  3690		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  36a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  36c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  36d8					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm"
      0  36d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_1", 72
     12  3700					      LIST	ON
      0  3700					      DEF	BLACK_BLANK_on_WHITE_SQUARE_1
      1  3700				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3700				   BANK_BLACK_BLANK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3700				   BLACK_BLANK_on_WHITE_SQUARE_1
      4  3700				   TEMPORARY_VAR SET	Overlay
      5  3700				   TEMPORARY_OFFSET SET	0
      6  3700				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3700				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_1
      3  3700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3718		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  3730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3748					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm"
      0  3748					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_2", 72
     12  3748					      LIST	ON
      0  3748					      DEF	BLACK_BLANK_on_WHITE_SQUARE_2
      1  3748				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3748				   BANK_BLACK_BLANK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3748				   BLACK_BLANK_on_WHITE_SQUARE_2
      4  3748				   TEMPORARY_VAR SET	Overlay
      5  3748				   TEMPORARY_OFFSET SET	0
      6  3748				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3748				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_2
      3  3748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3760		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  3778		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3790					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm"
      0  3790					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_3", 72
     12  3790					      LIST	ON
      0  3790					      DEF	BLACK_BLANK_on_WHITE_SQUARE_3
      1  3790				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3790				   BANK_BLACK_BLANK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3790				   BLACK_BLANK_on_WHITE_SQUARE_3
      4  3790				   TEMPORARY_VAR SET	Overlay
      5  3790				   TEMPORARY_OFFSET SET	0
      6  3790				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3790				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_3
      3  3790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  37a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  37c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
      0  37d8					      CHECK_BANK_SIZE	"PIECES_4 (1K)"
      1  37d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_4 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  37d8					      ECHO	"PIECES_4 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  37d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  37d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_4 (1K)", " size=", * - ORIGIN
      5  37d8				  -	      ERR
      6  37d8					      ENDIF
      0  37d8					      SLOT	2
      1  37d8				  -	      IF	(2 < 0) || (2 > 3)
      2  37d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  37d8				  -	      ERR
      4  37d8					      ENDIF
      5  37d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  37d8				   _BANK_SLOT SET	2 * 64
      0  37d8					      ROMBANK	PIECE_5
      1  3bd8 ????				      SEG	PIECE_5
      2  3800					      ORG	_ORIGIN
      3  3800					      RORG	_BANK_ADDRESS_ORIGIN
      4  3800				   _BANK_START SET	*
      5  3800				   PIECE_5_START SET	*
      6  3800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3800				   PIECE_5    SET	_BANK_SLOT + _CURRENT_BANK
      8  3800				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3800					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm"
      0  3800					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_0", 72
     12  3800					      LIST	ON
      0  3800					      DEF	BLACK_PAWN_on_WHITE_SQUARE_0
      1  3800				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3800				   BANK_BLACK_PAWN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3800				   BLACK_PAWN_on_WHITE_SQUARE_0
      4  3800				   TEMPORARY_VAR SET	Overlay
      5  3800				   TEMPORARY_OFFSET SET	0
      6  3800				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3800				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_0
      3  3800		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$00,$e0,$00,$40,$00,$00,$e0,$40,$00,$e0,$40,$40,$00	;PF0
      4  3818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3848					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm"
      0  3848					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_1", 72
     12  3848					      LIST	ON
      0  3848					      DEF	BLACK_PAWN_on_WHITE_SQUARE_1
      1  3848				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3848				   BANK_BLACK_PAWN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3848				   BLACK_PAWN_on_WHITE_SQUARE_1
      4  3848				   TEMPORARY_VAR SET	Overlay
      5  3848				   TEMPORARY_OFFSET SET	0
      6  3848				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3848				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_1
      3  3848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3860		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$00,$38,$00,$10,$00,$00,$38,$10,$00,$38,$10,$10,$00	;PF1
      5  3878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3890					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm"
      0  3890					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_2", 72
     12  3890					      LIST	ON
      0  3890					      DEF	BLACK_PAWN_on_WHITE_SQUARE_2
      1  3890				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3890				   BANK_BLACK_PAWN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3890				   BLACK_PAWN_on_WHITE_SQUARE_2
      4  3890				   TEMPORARY_VAR SET	Overlay
      5  3890				   TEMPORARY_OFFSET SET	0
      6  3890				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3890				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_2
      3  3890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  38a8		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  38c0		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$00,$03,$00,$01,$00,$00,$03,$01,$00,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  38d8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm"
      0  38d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_3", 72
     12  3900					      LIST	ON
      0  3900					      DEF	BLACK_PAWN_on_WHITE_SQUARE_3
      1  3900				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3900				   BANK_BLACK_PAWN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3900				   BLACK_PAWN_on_WHITE_SQUARE_3
      4  3900				   TEMPORARY_VAR SET	Overlay
      5  3900				   TEMPORARY_OFFSET SET	0
      6  3900				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3900				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_3
      3  3900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3930		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$00,$70,$00,$20,$00,$00,$70,$20,$00,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3948					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  3948					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_0", 72
     12  3948					      LIST	ON
      0  3948					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_0
      1  3948				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3948				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3948				   BLACK_KNIGHT_on_WHITE_SQUARE_0
      4  3948				   TEMPORARY_VAR SET	Overlay
      5  3948				   TEMPORARY_OFFSET SET	0
      6  3948				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3948				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_0
      3  3948		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00	;PF0
      4  3960		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  3978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3990					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  3990					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_1", 72
     12  3990					      LIST	ON
      0  3990					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_1
      1  3990				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3990				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3990				   BLACK_KNIGHT_on_WHITE_SQUARE_1
      4  3990				   TEMPORARY_VAR SET	Overlay
      5  3990				   TEMPORARY_OFFSET SET	0
      6  3990				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3990				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_1
      3  3990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  39a8		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$70,$38,$1c,$7c,$6c,$14,$00	;PF1
      5  39c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  39d8					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  39d8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_2", 72
     12  3a00					      LIST	ON
      0  3a00					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_2
      1  3a00				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3a00				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3a00				   BLACK_KNIGHT_on_WHITE_SQUARE_2
      4  3a00				   TEMPORARY_VAR SET	Overlay
      5  3a00				   TEMPORARY_OFFSET SET	0
      6  3a00				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3a00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_2
      3  3a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a18		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00	;PF1
      5  3a30		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$01,$03,$07,$07,$06,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3a48					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  3a48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_3", 72
     12  3a48					      LIST	ON
      0  3a48					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_3
      1  3a48				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3a48				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3a48				   BLACK_KNIGHT_on_WHITE_SQUARE_3
      4  3a48				   TEMPORARY_VAR SET	Overlay
      5  3a48				   TEMPORARY_OFFSET SET	0
      6  3a48				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3a48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_3
      3  3a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3a78		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$38,$70,$e0,$f8,$d8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3a90					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm"
      0  3a90					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_0", 72
     12  3a90					      LIST	ON
      0  3a90					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_0
      1  3a90				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3a90				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3a90				   BLACK_BISHOP_on_WHITE_SQUARE_0
      4  3a90				   TEMPORARY_VAR SET	Overlay
      5  3a90				   TEMPORARY_OFFSET SET	0
      6  3a90				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3a90				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_0
      3  3a90		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$f0,$f0,$e0,$00,$40	;PF0
      4  3aa8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  3ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ad8					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm"
      0  3ad8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_1", 72
     12  3b00					      LIST	ON
      0  3b00					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_1
      1  3b00				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3b00				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3b00				   BLACK_BISHOP_on_WHITE_SQUARE_1
      4  3b00				   TEMPORARY_VAR SET	Overlay
      5  3b00				   TEMPORARY_OFFSET SET	0
      6  3b00				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3b00				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_1
      3  3b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b18		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$7c,$7c,$38,$00,$10	;PF1
      5  3b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3b48					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm"
      0  3b48					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_2", 72
     12  3b48					      LIST	ON
      0  3b48					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_2
      1  3b48				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3b48				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3b48				   BLACK_BISHOP_on_WHITE_SQUARE_2
      4  3b48				   TEMPORARY_VAR SET	Overlay
      5  3b48				   TEMPORARY_OFFSET SET	0
      6  3b48				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3b48				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_2
      3  3b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b60		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$03,$01,$00,$00	;PF1
      5  3b78		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$07,$07,$03,$00,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3b90					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm"
      0  3b90					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_3", 72
     12  3b90					      LIST	ON
      0  3b90					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_3
      1  3b90				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3b90				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3b90				   BLACK_BISHOP_on_WHITE_SQUARE_3
      4  3b90				   TEMPORARY_VAR SET	Overlay
      5  3b90				   TEMPORARY_OFFSET SET	0
      6  3b90				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3b90				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_3
      3  3b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3bc0		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$f8,$f8,$70,$00,$20	;PF2
------- FILE piece_graphics.asm
      0  3bd8					      CHECK_BANK_SIZE	"PIECES_5 (1K)"
      1  3bd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_5 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  3bd8					      ECHO	"PIECES_5 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  3bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3bd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_5 (1K)", " size=", * - ORIGIN
      5  3bd8				  -	      ERR
      6  3bd8					      ENDIF
      0  3bd8					      SLOT	2
      1  3bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  3bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  3bd8				  -	      ERR
      4  3bd8					      ENDIF
      5  3bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  3bd8				   _BANK_SLOT SET	2 * 64
      0  3bd8					      ROMBANK	PIECE_6
      1  3f90 ????				      SEG	PIECE_6
      2  3c00					      ORG	_ORIGIN
      3  3c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  3c00				   _BANK_START SET	*
      5  3c00				   PIECE_6_START SET	*
      6  3c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3c00				   PIECE_6    SET	_BANK_SLOT + _CURRENT_BANK
      8  3c00				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3c00					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm"
      0  3c00					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_0", 72
     12  3c00					      LIST	ON
      0  3c00					      DEF	BLACK_ROOK_on_WHITE_SQUARE_0
      1  3c00				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3c00				   BANK_BLACK_ROOK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3c00				   BLACK_ROOK_on_WHITE_SQUARE_0
      4  3c00				   TEMPORARY_VAR SET	Overlay
      5  3c00				   TEMPORARY_OFFSET SET	0
      6  3c00				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3c00				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_0
      3  3c00		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$50,$50,$00	;PF0
      4  3c18		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  3c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3c48					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm"
      0  3c48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_1", 72
     12  3c48					      LIST	ON
      0  3c48					      DEF	BLACK_ROOK_on_WHITE_SQUARE_1
      1  3c48				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3c48				   BANK_BLACK_ROOK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3c48				   BLACK_ROOK_on_WHITE_SQUARE_1
      4  3c48				   TEMPORARY_VAR SET	Overlay
      5  3c48				   TEMPORARY_OFFSET SET	0
      6  3c48				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3c48				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_1
      3  3c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3c60		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$54,$54,$00	;PF1
      5  3c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3c90					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm"
      0  3c90					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_2", 72
     12  3c90					      LIST	ON
      0  3c90					      DEF	BLACK_ROOK_on_WHITE_SQUARE_2
      1  3c90				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3c90				   BANK_BLACK_ROOK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3c90				   BLACK_ROOK_on_WHITE_SQUARE_2
      4  3c90				   TEMPORARY_VAR SET	Overlay
      5  3c90				   TEMPORARY_OFFSET SET	0
      6  3c90				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3c90				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_2
      3  3c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ca8		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$02,$02,$00	;PF1
      5  3cc0		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$05,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3cd8					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm"
      0  3cd8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_3", 72
     12  3d00					      LIST	ON
      0  3d00					      DEF	BLACK_ROOK_on_WHITE_SQUARE_3
      1  3d00				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3d00				   BANK_BLACK_ROOK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3d00				   BLACK_ROOK_on_WHITE_SQUARE_3
      4  3d00				   TEMPORARY_VAR SET	Overlay
      5  3d00				   TEMPORARY_OFFSET SET	0
      6  3d00				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3d00				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_3
      3  3d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d30		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$a8,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3d48					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm"
      0  3d48					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_0", 72
     12  3d48					      LIST	ON
      0  3d48					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_0
      1  3d48				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3d48				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3d48				   BLACK_QUEEN_on_WHITE_SQUARE_0
      4  3d48				   TEMPORARY_VAR SET	Overlay
      5  3d48				   TEMPORARY_OFFSET SET	0
      6  3d48				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3d48				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_0
      3  3d48		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  3d60		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$80,$80,$00,$80,$00	;PF1
      5  3d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3d90					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm"
      0  3d90					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_1", 72
     12  3d90					      LIST	ON
      0  3d90					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_1
      1  3d90				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3d90				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3d90				   BLACK_QUEEN_on_WHITE_SQUARE_1
      4  3d90				   TEMPORARY_VAR SET	Overlay
      5  3d90				   TEMPORARY_OFFSET SET	0
      6  3d90				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3d90				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_1
      3  3d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3da8		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$78,$7c,$54,$00,$54,$00	;PF1
      5  3dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3dd8					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm"
      0  3dd8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_2", 72
     12  3e00					      LIST	ON
      0  3e00					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_2
      1  3e00				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3e00				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3e00				   BLACK_QUEEN_on_WHITE_SQUARE_2
      4  3e00				   TEMPORARY_VAR SET	Overlay
      5  3e00				   TEMPORARY_OFFSET SET	0
      6  3e00				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3e00				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_2
      3  3e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e18		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  3e30		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$03,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3e48					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm"
      0  3e48					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_3", 72
     12  3e48					      LIST	ON
      0  3e48					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_3
      1  3e48				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3e48				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3e48				   BLACK_QUEEN_on_WHITE_SQUARE_3
      4  3e48				   TEMPORARY_VAR SET	Overlay
      5  3e48				   TEMPORARY_OFFSET SET	0
      6  3e48				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3e48				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_3
      3  3e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e78		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$78,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3e90					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_0.asm"
      0  3e90					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_0", 72
     12  3e90					      LIST	ON
      0  3e90					      DEF	BLACK_KING_on_WHITE_SQUARE_0
      1  3e90				   SLOT_BLACK_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3e90				   BANK_BLACK_KING_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3e90				   BLACK_KING_on_WHITE_SQUARE_0
      4  3e90				   TEMPORARY_VAR SET	Overlay
      5  3e90				   TEMPORARY_OFFSET SET	0
      6  3e90				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3e90				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_0
      3  3e90		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$f0,$40,$e0,$40	;PF0
      4  3ea8		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  3ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ed8					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_1.asm"
      0  3ed8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_1", 72
     12  3f00					      LIST	ON
      0  3f00					      DEF	BLACK_KING_on_WHITE_SQUARE_1
      1  3f00				   SLOT_BLACK_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3f00				   BANK_BLACK_KING_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3f00				   BLACK_KING_on_WHITE_SQUARE_1
      4  3f00				   TEMPORARY_VAR SET	Overlay
      5  3f00				   TEMPORARY_OFFSET SET	0
      6  3f00				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3f00				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_1
      3  3f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f18		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$7c,$10,$38,$10	;PF1
      5  3f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3f48					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_2.asm"
      0  3f48					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_2", 72
     12  3f48					      LIST	ON
      0  3f48					      DEF	BLACK_KING_on_WHITE_SQUARE_2
      1  3f48				   SLOT_BLACK_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3f48				   BANK_BLACK_KING_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3f48				   BLACK_KING_on_WHITE_SQUARE_2
      4  3f48				   TEMPORARY_VAR SET	Overlay
      5  3f48				   TEMPORARY_OFFSET SET	0
      6  3f48				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3f48				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_2
      3  3f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f60		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  3f78		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$07,$01,$03,$01	;PF2
------- FILE piece_graphics.asm
      0  3f90					      CHECK_BANK_SIZE	"PIECES_6 (1K)"
      1  3f90		       03 90	   .TEMP      =	* - _BANK_START
 PIECES_6 (1K) (1K) SIZE =  $390 , FREE= $70
      2  3f90					      ECHO	"PIECES_6 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  3f90				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3f90				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_6 (1K)", " size=", * - ORIGIN
      5  3f90				  -	      ERR
      6  3f90					      ENDIF
      0  3f90					      SLOT	2
      1  3f90				  -	      IF	(2 < 0) || (2 > 3)
      2  3f90				  -	      ECHO	"Illegal bank address/segment location", 2
      3  3f90				  -	      ERR
      4  3f90					      ENDIF
      5  3f90				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  3f90				   _BANK_SLOT SET	2 * 64
      0  3f90					      ROMBANK	PIECE_7
      1  43d8 ????				      SEG	PIECE_7
      2  4000					      ORG	_ORIGIN
      3  4000					      RORG	_BANK_ADDRESS_ORIGIN
      4  4000				   _BANK_START SET	*
      5  4000				   PIECE_7_START SET	*
      6  4000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4000				   PIECE_7    SET	_BANK_SLOT + _CURRENT_BANK
      8  4000				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4000					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_3.asm"
      0  4000					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_3", 72
     12  4000					      LIST	ON
      0  4000					      DEF	BLACK_KING_on_WHITE_SQUARE_3
      1  4000				   SLOT_BLACK_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4000				   BANK_BLACK_KING_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4000				   BLACK_KING_on_WHITE_SQUARE_3
      4  4000				   TEMPORARY_VAR SET	Overlay
      5  4000				   TEMPORARY_OFFSET SET	0
      6  4000				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4000				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_3
      3  4000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4030		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$f8,$20,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4048					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm"
      0  4048					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_0", 72
     12  4048					      LIST	ON
      0  4048					      DEF	BLACK_BLANK_on_BLACK_SQUARE_0
      1  4048				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4048				   BANK_BLACK_BLANK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4048				   BLACK_BLANK_on_BLACK_SQUARE_0
      4  4048				   TEMPORARY_VAR SET	Overlay
      5  4048				   TEMPORARY_OFFSET SET	0
      6  4048				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4048				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_0
      3  4048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4060		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4090					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm"
      0  4090					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_1", 72
     12  4090					      LIST	ON
      0  4090					      DEF	BLACK_BLANK_on_BLACK_SQUARE_1
      1  4090				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4090				   BANK_BLACK_BLANK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4090				   BLACK_BLANK_on_BLACK_SQUARE_1
      4  4090				   TEMPORARY_VAR SET	Overlay
      5  4090				   TEMPORARY_OFFSET SET	0
      6  4090				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4090				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_1
      3  4090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  40a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  40c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  40d8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm"
      0  40d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_2", 72
     12  4100					      LIST	ON
      0  4100					      DEF	BLACK_BLANK_on_BLACK_SQUARE_2
      1  4100				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4100				   BANK_BLACK_BLANK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4100				   BLACK_BLANK_on_BLACK_SQUARE_2
      4  4100				   TEMPORARY_VAR SET	Overlay
      5  4100				   TEMPORARY_OFFSET SET	0
      6  4100				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4100				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_2
      3  4100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4130		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4148					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm"
      0  4148					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_3", 72
     12  4148					      LIST	ON
      0  4148					      DEF	BLACK_BLANK_on_BLACK_SQUARE_3
      1  4148				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4148				   BANK_BLACK_BLANK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4148				   BLACK_BLANK_on_BLACK_SQUARE_3
      4  4148				   TEMPORARY_VAR SET	Overlay
      5  4148				   TEMPORARY_OFFSET SET	0
      6  4148				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4148				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_3
      3  4148		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4160		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4190					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm"
      0  4190					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_0", 72
     12  4190					      LIST	ON
      0  4190					      DEF	BLACK_PAWN_on_BLACK_SQUARE_0
      1  4190				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4190				   BANK_BLACK_PAWN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4190				   BLACK_PAWN_on_BLACK_SQUARE_0
      4  4190				   TEMPORARY_VAR SET	Overlay
      5  4190				   TEMPORARY_OFFSET SET	0
      6  4190				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4190				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_0
      3  4190		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$00,$e0,$00,$40,$00,$00,$00,$00,$40,$00,$00,$00,$00	;PF0
      4  41a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  41c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  41d8					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm"
      0  41d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_1", 72
     12  4200					      LIST	ON
      0  4200					      DEF	BLACK_PAWN_on_BLACK_SQUARE_1
      1  4200				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4200				   BANK_BLACK_PAWN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4200				   BLACK_PAWN_on_BLACK_SQUARE_1
      4  4200				   TEMPORARY_VAR SET	Overlay
      5  4200				   TEMPORARY_OFFSET SET	0
      6  4200				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4200				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_1
      3  4200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4218		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$00,$38,$00,$10,$00,$00,$00,$00,$10,$00,$00,$00,$00	;PF1
      5  4230		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4248					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm"
      0  4248					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_2", 72
     12  4248					      LIST	ON
      0  4248					      DEF	BLACK_PAWN_on_BLACK_SQUARE_2
      1  4248				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4248				   BANK_BLACK_PAWN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4248				   BLACK_PAWN_on_BLACK_SQUARE_2
      4  4248				   TEMPORARY_VAR SET	Overlay
      5  4248				   TEMPORARY_OFFSET SET	0
      6  4248				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4248				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_2
      3  4248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4260		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4278		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$00,$03,$00,$01,$00,$00,$00,$00,$01,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4290					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm"
      0  4290					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_3", 72
     12  4290					      LIST	ON
      0  4290					      DEF	BLACK_PAWN_on_BLACK_SQUARE_3
      1  4290				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4290				   BANK_BLACK_PAWN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4290				   BLACK_PAWN_on_BLACK_SQUARE_3
      4  4290				   TEMPORARY_VAR SET	Overlay
      5  4290				   TEMPORARY_OFFSET SET	0
      6  4290				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4290				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_3
      3  4290		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  42a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  42c0		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$00,$70,$00,$20,$00,$00,$00,$00,$20,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  42d8					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  42d8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_0", 72
     12  4300					      LIST	ON
      0  4300					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_0
      1  4300				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4300				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4300				   BLACK_KNIGHT_on_BLACK_SQUARE_0
      4  4300				   TEMPORARY_VAR SET	Overlay
      5  4300				   TEMPORARY_OFFSET SET	0
      6  4300				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4300				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_0
      3  4300		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$40,$00,$00	;PF0
      4  4318		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4348					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  4348					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_1", 72
     12  4348					      LIST	ON
      0  4348					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_1
      1  4348				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4348				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4348				   BLACK_KNIGHT_on_BLACK_SQUARE_1
      4  4348				   TEMPORARY_VAR SET	Overlay
      5  4348				   TEMPORARY_OFFSET SET	0
      6  4348				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4348				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_1
      3  4348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4360		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$10,$00,$00	;PF1
      5  4378		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4390					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  4390					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_2", 72
     12  4390					      LIST	ON
      0  4390					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_2
      1  4390				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4390				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4390				   BLACK_KNIGHT_on_BLACK_SQUARE_2
      4  4390				   TEMPORARY_VAR SET	Overlay
      5  4390				   TEMPORARY_OFFSET SET	0
      6  4390				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4390				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_2
      3  4390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  43a8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  43c0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  43d8					      CHECK_BANK_SIZE	"PIECE_7 (1K)"
      1  43d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_7 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  43d8					      ECHO	"PIECE_7 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  43d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  43d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_7 (1K)", " size=", * - ORIGIN
      5  43d8				  -	      ERR
      6  43d8					      ENDIF
      0  43d8					      SLOT	2
      1  43d8				  -	      IF	(2 < 0) || (2 > 3)
      2  43d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  43d8				  -	      ERR
      4  43d8					      ENDIF
      5  43d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  43d8				   _BANK_SLOT SET	2 * 64
      0  43d8					      ROMBANK	PIECE_8
      1  4448 ????				      SEG	PIECE_8
      2  4400					      ORG	_ORIGIN
      3  4400					      RORG	_BANK_ADDRESS_ORIGIN
      4  4400				   _BANK_START SET	*
      5  4400				   PIECE_8_START SET	*
      6  4400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4400				   PIECE_8    SET	_BANK_SLOT + _CURRENT_BANK
      8  4400				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4400					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  4400					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_3", 72
     12  4400					      LIST	ON
      0  4400					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_3
      1  4400				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4400				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4400				   BLACK_KNIGHT_on_BLACK_SQUARE_3
      4  4400				   TEMPORARY_VAR SET	Overlay
      5  4400				   TEMPORARY_OFFSET SET	0
      6  4400				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4400				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_3
      3  4400		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4430		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
    127  4448
      0  4448					      CHECK_BANK_SIZE	"PIECES_8 (1K)"
      1  4448		       00 48	   .TEMP      =	* - _BANK_START
 PIECES_8 (1K) (1K) SIZE =  $48 , FREE= $3b8
      2  4448					      ECHO	"PIECES_8 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4448				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4448				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_8 (1K)", " size=", * - ORIGIN
      5  4448				  -	      ERR
      6  4448					      ENDIF
    129  4448
    130  4448							;    ROMBANK PIECES_5
    131  4448
    132  4448							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
    133  4448							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
    134  4448							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
    135  4448							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
    136  4448							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
    137  4448							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
    138  4448							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
    139  4448							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
    140  4448
    141  4448
    142  4448				  -	      IF	0
    143  4448				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    144  4448				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    145  4448				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    146  4448				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    147  4448				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    148  4448				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    149  4448				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    150  4448				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    151  4448				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    152  4448				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    153  4448				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    154  4448				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    155  4448				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    156  4448				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    157  4448				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    158  4448				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    159  4448					      ENDIF
    160  4448
    161  4448							;    CHECK_BANK_SIZE "PIECES_5 (2K)"
    162  4448
    163  4448				  -	      IF	0
    164  4448				  -	      ROMBANK	PIECES_6
    165  4448				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    166  4448				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    167  4448				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    168  4448				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    169  4448				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    170  4448				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    171  4448				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    172  4448				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    173  4448				  -
    174  4448				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_0.asm"
    175  4448				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_1.asm"
    176  4448				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_2.asm"
    177  4448				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_3.asm"
    178  4448				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    179  4448				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    180  4448				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    181  4448				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    182  4448				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    183  4448				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    184  4448				  -
    185  4448				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    186  4448				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    187  4448				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    188  4448				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    189  4448				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    190  4448				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    191  4448				  -	      CHECK_BANK_SIZE	"PIECES_6 (2K)"
    192  4448				  -
    193  4448				  -
    194  4448				  -	      ROMBANK	PIECES_7
    195  4448				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    196  4448				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    197  4448				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    198  4448				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    199  4448				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    200  4448				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    201  4448				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    202  4448				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    203  4448				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    204  4448				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    205  4448				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    206  4448				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    207  4448				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_0.asm"
    208  4448				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_1.asm"
    209  4448				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_2.asm"
    210  4448				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_3.asm"
    211  4448				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    212  4448				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    213  4448				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    214  4448				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    215  4448				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    216  4448				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    217  4448				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    218  4448				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    219  4448				  -	      CHECK_BANK_SIZE	"PIECES_7 (2K)"
    220  4448				  -
    221  4448				  -
    222  4448				  -	      ROMBANK	PIECES_8
    223  4448				  -
    224  4448				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    225  4448				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    226  4448				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    227  4448				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    228  4448				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    229  4448				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    230  4448				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    231  4448				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    232  4448				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    233  4448				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    234  4448				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    235  4448				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    236  4448				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    237  4448				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    238  4448				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    239  4448				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    240  4448				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_0.asm"
    241  4448				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_1.asm"
    242  4448				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_2.asm"
    243  4448				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_3.asm"
    244  4448				  -
    245  4448				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    246  4448				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    247  4448				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    248  4448				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    249  4448				  -	      CHECK_BANK_SIZE	"PIECES_8 (2K)"
    250  4448				  -
    251  4448					      ENDIF
    252  4448
    253  4448							;    ROMBANK PIECES_9
    254  4448
    255  4448							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    256  4448							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    257  4448							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    258  4448							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    259  4448							; include "gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    260  4448
    261  4448				  -	      IF	0
    262  4448				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    263  4448				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    264  4448				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    265  4448					      ENDIF
    266  4448
    267  4448							;    CHECK_BANK_SIZE "PIECES_9 (2K)"
    268  4448
    269  4448				  -	      IF	0
    270  4448				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    271  4448				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    272  4448				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    273  4448				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    274  4448				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    275  4448				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    276  4448				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    277  4448				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    278  4448				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    279  4448				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    280  4448				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    281  4448				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    282  4448				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_0.asm"
    283  4448				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_1.asm"
    284  4448				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_2.asm"
    285  4448				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_3.asm"
    286  4448					      ENDIF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@2#1.asm LEVEL 2 PASS 4
      0  4448					      include	"BANK_GENERIC@2#1.asm"
      1  4448
      0  4448					      SLOT	2
      1  4448				  -	      IF	(2 < 0) || (2 > 3)
      2  4448				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4448				  -	      ERR
      4  4448					      ENDIF
      5  4448				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4448				   _BANK_SLOT SET	2 * 64
      0  4448					      ROMBANK	GENERIC_BANK@2#1
      1  4b95 ????				      SEG	GENERIC_BANK@2#1
      2  4800					      ORG	_ORIGIN
      3  4800					      RORG	_BANK_ADDRESS_ORIGIN
      4  4800				   _BANK_START SET	*
      5  4800				   GENERIC_BANK@2#1_START SET	*
      6  4800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4800				   GENERIC_BANK@2#1 SET	_BANK_SLOT + _CURRENT_BANK
      8  4800				   _ORIGIN    SET	_ORIGIN + 1024
      4  4800
      5  4800							;    DEFINE_1K_SEGMENT DECODE_LEVEL_SHADOW
      6  4800
      7  4800				  -	      IF	0
      8  4800				  -	      IF	PLUSCART = YES
      9  4800				  -	      .byte	"ChessAPI.php", #0 //TODO: change!
     10  4800				  -	      .byte	"pluscart.firmaplus.de", #0
     11  4800				  -	      ENDIF
     12  4800					      ENDIF
     13  4800
     14  4800		       54 4a 33 45 STELLA_AUTODETECT dc	"TJ3E"	; 3E+ autodetect
     15  4804
     16  4804
     17  4804							;---------------------------------------------------------------------------------------------------
     18  4804
      0  4804					      DEF	tidySc
      1  4804				   SLOT_tidySc SET	_BANK_SLOT
      2  4804				   BANK_tidySc SET	SLOT_tidySc + _CURRENT_BANK
      3  4804				   tidySc
      4  4804				   TEMPORARY_VAR SET	Overlay
      5  4804				   TEMPORARY_OFFSET SET	0
      6  4804				   VAR_BOUNDARY_tidySc SET	TEMPORARY_OFFSET
      7  4804				   FUNCTION_NAME SET	tidySc
     20  4804					      SUBROUTINE
     21  4804
      0  4804					      REFER	StartupBankReset	;✅
      1  4804				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  4804				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  4804					      ENDIF
      0  4804					      VEND	tidySc
      1  4804				  -	      IFNCONST	tidySc
      2  4804				  -	      ECHO	"Incorrect VEND label", tidySc
      3  4804				  -	      ERR
      4  4804					      ENDIF
      5  4804		       00 a7	   VAREND_tidySc =	TEMPORARY_VAR
     24  4804
     25  4804		       a9 00		      lda	#0
     26  4806		       85 4d		      sta	PF0
     27  4808		       85 4e		      sta	PF1
     28  480a		       85 4f		      sta	PF2
     29  480c		       85 5b		      sta	GRP0
     30  480e
     31  480e		       a9 42		      lda	#%01000010	; bit6 is not required
     32  4810							;sta VBLANK			  ; end of screen - enter blanking
     33  4810
     34  4810
     35  4810							; END OF VISIBLE SCREEN
     36  4810							; HERE'S SOME TIME TO DO STUFF
     37  4810
     38  4810		       a9 2e		      lda	#TIME_PART_2
     39  4812		       8d 96 02 	      sta	TIM64T
     40  4815		       60		      rts
     41  4816
     42  4816
     43  4816							;---------------------------------------------------------------------------------------------------
     44  4816
      0  4816					      DEF	longD
      1  4816				   SLOT_longD SET	_BANK_SLOT
      2  4816				   BANK_longD SET	SLOT_longD + _CURRENT_BANK
      3  4816				   longD
      4  4816				   TEMPORARY_VAR SET	Overlay
      5  4816				   TEMPORARY_OFFSET SET	0
      6  4816				   VAR_BOUNDARY_longD SET	TEMPORARY_OFFSET
      7  4816				   FUNCTION_NAME SET	longD
     46  4816					      SUBROUTINE
     47  4816
      0  4816					      REFER	StartupBankReset	;✅
      1  4816				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  4816				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  4816					      ENDIF
      0  4816					      VEND	longD
      1  4816				  -	      IFNCONST	longD
      2  4816				  -	      ECHO	"Incorrect VEND label", longD
      3  4816				  -	      ERR
      4  4816					      ENDIF
      5  4816		       00 a7	   VAREND_longD =	TEMPORARY_VAR
     50  4816
     51  4816		       85 42		      sta	WSYNC
     52  4818
     53  4818		       20 29 f8 	      jsr	_rts
     54  481b		       20 29 f8 	      jsr	_rts
     55  481e		       20 29 f8 	      jsr	_rts
      0  4821					      SLEEP	7
      1  4821				   .CYCLES    SET	7
      2  4821
      3  4821				  -	      IF	.CYCLES < 2
      4  4821				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4821				  -	      ERR
      6  4821					      ENDIF
      7  4821
      8  4821					      IF	.CYCLES & 1
      9  4821					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4821		       04 00		      nop	0
     11  4823				  -	      ELSE
     12  4823				  -	      bit	VSYNC
     13  4823					      ENDIF
     14  4823				   .CYCLES    SET	.CYCLES - 3
     15  4823					      ENDIF
     16  4823
     17  4823					      REPEAT	.CYCLES / 2
     18  4823		       ea		      nop
     17  4823					      REPEND
     18  4824		       ea		      nop
     19  4825					      REPEND
     57  4825
     58  4825		       a2 00		      ldx	#0
     59  4827		       86 41		      stx	VBLANK
     60  4829		       60	   _rts       rts
     61  482a
     62  482a
     63  482a							;---------------------------------------------------------------------------------------------------
     64  482a
      0  482a					      DEF	aiStartClearBoard
      1  482a				   SLOT_aiStartClearBoard SET	_BANK_SLOT
      2  482a				   BANK_aiStartClearBoard SET	SLOT_aiStartClearBoard + _CURRENT_BANK
      3  482a				   aiStartClearBoard
      4  482a				   TEMPORARY_VAR SET	Overlay
      5  482a				   TEMPORARY_OFFSET SET	0
      6  482a				   VAR_BOUNDARY_aiStartClearBoard SET	TEMPORARY_OFFSET
      7  482a				   FUNCTION_NAME SET	aiStartClearBoard
     66  482a					      SUBROUTINE
     67  482a
      0  482a					      REFER	AiStateMachine	;✅
      1  482a					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  482a				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  482a					      ENDIF
      0  482a					      VEND	aiStartClearBoard
      1  482a				  -	      IFNCONST	aiStartClearBoard
      2  482a				  -	      ECHO	"Incorrect VEND label", aiStartClearBoard
      3  482a				  -	      ERR
      4  482a					      ENDIF
      5  482a		       00 a9	   VAREND_aiStartClearBoard =	TEMPORARY_VAR
     70  482a
     71  482a		       a2 08		      ldx	#8
     72  482c		       86 84		      stx	drawCount	; = bank
     73  482e
     74  482e		       a9 ff		      lda	#-1
     75  4830		       85 88		      sta	cursorX12
     76  4832
      0  4832					      PHASE	AI_ClearEachRow
      1  4832		       a9 0e		      lda	#AI_ClearEachRow
      2  4834		       85 8b		      sta	aiState
     78  4836		       60		      rts
     79  4837
     80  4837
     81  4837							;---------------------------------------------------------------------------------------------------
     82  4837
      0  4837					      DEF	aiClearEachRow
      1  4837				   SLOT_aiClearEachRow SET	_BANK_SLOT
      2  4837				   BANK_aiClearEachRow SET	SLOT_aiClearEachRow + _CURRENT_BANK
      3  4837				   aiClearEachRow
      4  4837				   TEMPORARY_VAR SET	Overlay
      5  4837				   TEMPORARY_OFFSET SET	0
      6  4837				   VAR_BOUNDARY_aiClearEachRow SET	TEMPORARY_OFFSET
      7  4837				   FUNCTION_NAME SET	aiClearEachRow
     84  4837					      SUBROUTINE
     85  4837
      0  4837					      REFER	AiStateMachine	;✅
      1  4837					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  4837				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  4837					      ENDIF
      0  4837					      VEND	aiClearEachRow
      1  4837				  -	      IFNCONST	aiClearEachRow
      2  4837				  -	      ECHO	"Incorrect VEND label", aiClearEachRow
      3  4837				  -	      ERR
      4  4837					      ENDIF
      5  4837		       00 a9	   VAREND_aiClearEachRow =	TEMPORARY_VAR
     88  4837
     89  4837		       c6 84		      dec	drawCount
     90  4839		       30 00		      bmi	.bitmapCleared
     91  483b							;TODOldy drawCount
     92  483b							;TODO jmp CallClear
     93  483b
     94  483b				   .bitmapCleared
     95  483b
     96  483b		       a9 63		      lda	#99
     97  483d		       85 80		      sta	squareToDraw
     98  483f
      0  483f					      PHASE	AI_DrawEntireBoard
      1  483f		       a9 0f		      lda	#AI_DrawEntireBoard
      2  4841		       85 8b		      sta	aiState
    100  4843		       60		      rts
    101  4844
    102  4844
    103  4844							;---------------------------------------------------------------------------------------------------
    104  4844
      0  4844					      DEF	aiMoveIsSelected
      1  4844				   SLOT_aiMoveIsSelected SET	_BANK_SLOT
      2  4844				   BANK_aiMoveIsSelected SET	SLOT_aiMoveIsSelected + _CURRENT_BANK
      3  4844				   aiMoveIsSelected
      4  4844				   TEMPORARY_VAR SET	Overlay
      5  4844				   TEMPORARY_OFFSET SET	0
      6  4844				   VAR_BOUNDARY_aiMoveIsSelected SET	TEMPORARY_OFFSET
      7  4844				   FUNCTION_NAME SET	aiMoveIsSelected
    106  4844					      SUBROUTINE
    107  4844
      0  4844					      COMMON_VARS
      1  4844
      0  4844					      VAR	__thinkbar, 1
      1  4844		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  4844				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4844
      4  4844				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4844				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4844				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4844					      ENDIF
      8  4844				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4844				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  4844				  -	      ERR
     11  4844					      ENDIF
     12  4844					      LIST	ON
      0  4844					      VAR	__toggle, 1
      1  4844		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  4844				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4844
      4  4844				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4844				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4844				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4844					      ENDIF
      8  4844				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4844				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  4844				  -	      ERR
     11  4844					      ENDIF
     12  4844					      LIST	ON
      4  4844
      0  4844					      VAR	__bestMove, 1
      1  4844		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  4844				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4844
      4  4844				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4844				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4844				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4844					      ENDIF
      8  4844				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4844				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  4844				  -	      ERR
     11  4844					      ENDIF
     12  4844					      LIST	ON
      0  4844					      VAR	__alpha, 2
      1  4844		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  4844				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4844
      4  4844				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4844				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4844				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4844					      ENDIF
      8  4844				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4844				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  4844				  -	      ERR
     11  4844					      ENDIF
     12  4844					      LIST	ON
      0  4844					      VAR	__beta, 2
      1  4844		       00 ac	   __beta     =	TEMPORARY_VAR
      2  4844				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4844
      4  4844				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4844				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4844				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4844					      ENDIF
      8  4844				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4844				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  4844				  -	      ERR
     11  4844					      ENDIF
     12  4844					      LIST	ON
      0  4844					      VAR	__negaMax, 2
      1  4844		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  4844				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4844
      4  4844				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4844				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4844				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4844					      ENDIF
      8  4844				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4844				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  4844				  -	      ERR
     11  4844					      ENDIF
     12  4844					      LIST	ON
      0  4844					      VAR	__value, 2
      1  4844		       00 b0	   __value    =	TEMPORARY_VAR
      2  4844				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4844
      4  4844				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4844				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4844				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4844					      ENDIF
      8  4844				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4844				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  4844				  -	      ERR
     11  4844					      ENDIF
     12  4844					      LIST	ON
     10  4844
      0  4844					      VAR	__quiesceCapOnly, 1
      1  4844		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  4844				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4844
      4  4844				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4844				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4844				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4844					      ENDIF
      8  4844				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4844				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  4844				  -	      ERR
     11  4844					      ENDIF
     12  4844					      LIST	ON
     12  4844
      0  4844					      VAR	__originalPiece, 1
      1  4844		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  4844				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4844
      4  4844				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4844				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4844				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4844					      ENDIF
      8  4844				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4844				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  4844				  -	      ERR
     11  4844					      ENDIF
     12  4844					      LIST	ON
      0  4844					      VAR	__capturedPiece, 1
      1  4844		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  4844				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4844
      4  4844				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4844				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4844				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4844					      ENDIF
      8  4844				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4844				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  4844				  -	      ERR
     11  4844					      ENDIF
     12  4844					      LIST	ON
     15  4844
      0  4844					      REFER	AiStateMachine	;✅
      1  4844				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  4844				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  4844					      ENDIF
      0  4844					      VEND	aiMoveIsSelected
      1  4844				  -	      IFNCONST	aiMoveIsSelected
      2  4844				  -	      ECHO	"Incorrect VEND label", aiMoveIsSelected
      3  4844				  -	      ERR
      4  4844					      ENDIF
      5  4844		       00 b5	   VAREND_aiMoveIsSelected =	TEMPORARY_VAR
    111  4844
    112  4844							; Both computer and human have now seleted a move, and converge here
    113  4844
    114  4844
    115  4844							; fromPiece	 piece doing the move
    116  4844							; fromX12	 current square X12
    117  4844							; originX12	 starting square X12
    118  4844							; toX12	 ending square X12
    119  4844
    120  4844		       20 6b f8 	      jsr	EnPassantFixupDraw
    121  4847
    122  4847							; get the piece types from the board
    123  4847
    124  4847		       a9 d1		      lda	#RAMBANK_BOARD
    125  4849		       85 3e		      sta	SET_BANK_RAM	;@3
    126  484b		       a4 87		      ldy	originX12
    127  484d		       b9 79 fc 	      lda	Board,y
    128  4850		       85 b3		      sta	__originalPiece
    129  4852		       a4 86		      ldy	toX12
    130  4854		       b9 79 fc 	      lda	Board,y
    131  4857		       85 b4		      sta	__capturedPiece
    132  4859
    133  4859
    134  4859		       20 e5 f8 	      jsr	AdjustMaterialPositionalValue	;@this
    135  485c
    136  485c		       a9 00		      lda	#0
    137  485e		       85 98		      sta	previousPiece
    138  4860		       85 82		      sta	drawDelay
    139  4862
    140  4862		       a9 0a		      lda	#10	; on/off count
    141  4864		       85 84		      sta	drawCount	; flashing for piece about to move
    142  4866
      0  4866					      PHASE	AI_WriteStartPieceBlank
      1  4866		       a9 15		      lda	#AI_WriteStartPieceBlank
      2  4868		       85 8b		      sta	aiState
    144  486a		       60	   .idleErase rts
    145  486b
    146  486b
    147  486b							;---------------------------------------------------------------------------------------------------
    148  486b
      0  486b					      DEF	EnPassantFixupDraw
      1  486b				   SLOT_EnPassantFixupDraw SET	_BANK_SLOT
      2  486b				   BANK_EnPassantFixupDraw SET	SLOT_EnPassantFixupDraw + _CURRENT_BANK
      3  486b				   EnPassantFixupDraw
      4  486b				   TEMPORARY_VAR SET	Overlay
      5  486b				   TEMPORARY_OFFSET SET	0
      6  486b				   VAR_BOUNDARY_EnPassantFixupDraw SET	TEMPORARY_OFFSET
      7  486b				   FUNCTION_NAME SET	EnPassantFixupDraw
    150  486b					      SUBROUTINE
    151  486b
    152  486b							; {
    153  486b							; With en-passant flag, it is essentially dual-use.
    154  486b							; First, it marks if the move is *involved* somehow in an en-passant
    155  486b							; if the piece has MOVED already, then it's an en-passant capture
    156  486b							; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
    157  486b
    158  486b		       a2 00		      ldx	#0	; (probably) NO en-passant this time
    159  486d		       a5 96		      lda	fromPiece
    160  486f		       a8		      tay
    161  4870
    162  4870		       29 60		      and	#FLAG_ENPASSANT|FLAG_MOVED
    163  4872		       c9 20		      cmp	#FLAG_ENPASSANT
    164  4874		       d0 13		      bne	.noep	; HAS moved, or not en-passant
    165  4876
    166  4876		       45 96		      eor	fromPiece	; clear FLAG_ENPASSANT
    167  4878		       85 96		      sta	fromPiece
    168  487a
    169  487a		       a6 86		      ldx	toX12	; this IS an en-passantable opening, so record the square
    170  487c		       86 93		      stx	enPassantPawn	; capturable square for en-passant move (or none)
    171  487e
    172  487e							; set the secondary piece movement info - this allows move/unmakemove to work for enpassant
    173  487e
    174  487e		       a9 00		      lda	#0
      0  4880					      sta@PLY	secondaryBlank
      1  4880		       8d ce fb 	      sta	[RAM]+secondaryBlank
      0  4883					      stx@PLY	secondarySquare
      1  4883		       8e cd fb 	      stx	[RAM]+secondarySquare
      0  4886					      sty@PLY	secondaryPiece
      1  4886		       8c cc fb 	      sty	[RAM]+secondaryPiece
    178  4889
    179  4889				   .noep
    180  4889							; }
    181  4889
    182  4889		       60		      rts
    183  488a
    184  488a							;---------------------------------------------------------------------------------------------------
    185  488a
      0  488a					      DEF	CopySetup
      1  488a				   SLOT_CopySetup SET	_BANK_SLOT
      2  488a				   BANK_CopySetup SET	SLOT_CopySetup + _CURRENT_BANK
      3  488a				   CopySetup
      4  488a				   TEMPORARY_VAR SET	Overlay
      5  488a				   TEMPORARY_OFFSET SET	0
      6  488a				   VAR_BOUNDARY_CopySetup SET	TEMPORARY_OFFSET
      7  488a				   FUNCTION_NAME SET	CopySetup
    187  488a					      SUBROUTINE
    188  488a
      0  488a					      REFER	CopySinglePiece	;✅
      1  488a					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  488a				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  488a					      ENDIF
    190  488a
      0  488a					      VAR	__tmp, 1
      1  488a		       00 ac	   __tmp      =	TEMPORARY_VAR
      2  488a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  488a
      4  488a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  488a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  488a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  488a					      ENDIF
      8  488a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  488a				  -	      ECHO	"Temporary Variable", __tmp, "overflow!"
     10  488a				  -	      ERR
     11  488a					      ENDIF
     12  488a					      LIST	ON
      0  488a					      VAR	__shiftx, 1
      1  488a		       00 ad	   __shiftx   =	TEMPORARY_VAR
      2  488a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  488a
      4  488a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  488a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  488a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  488a					      ENDIF
      8  488a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  488a				  -	      ECHO	"Temporary Variable", __shiftx, "overflow!"
     10  488a				  -	      ERR
     11  488a					      ENDIF
     12  488a					      LIST	ON
      0  488a					      VAR	__pieceColour2, 1
      1  488a		       00 ae	   __pieceColour2 =	TEMPORARY_VAR
      2  488a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  488a
      4  488a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  488a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  488a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  488a					      ENDIF
      8  488a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  488a				  -	      ECHO	"Temporary Variable", __pieceColour2, "overflow!"
     10  488a				  -	      ERR
     11  488a					      ENDIF
     12  488a					      LIST	ON
    194  488a
      0  488a					      VEND	CopySetup
      1  488a				  -	      IFNCONST	CopySetup
      2  488a				  -	      ECHO	"Incorrect VEND label", CopySetup
      3  488a				  -	      ERR
      4  488a					      ENDIF
      5  488a		       00 af	   VAREND_CopySetup =	TEMPORARY_VAR
    196  488a
    197  488a							; figure colouration of square
    198  488a
    199  488a		       a5 80		      lda	squareToDraw
    200  488c
    201  488c					      IF	DIAGNOSTICS
    202  488c							; Catch out-of-range piece square
    203  488c							; will not catch off left/right edge
    204  488c
    205  488c		       c9 64	   .fail      cmp	#100
    206  488e		       b0 fc		      bcs	.fail
    207  4890		       c9 16		      cmp	#22
    208  4892		       90 f8		      bcc	.fail
    209  4894					      ENDIF
    210  4894
    211  4894
    212  4894		       a2 0a		      ldx	#10
    213  4896		       38		      sec
    214  4897		       e9 0a	   .sub10     sbc	#10
    215  4899		       ca		      dex
    216  489a		       b0 fb		      bcs	.sub10
    217  489c		       69 08		      adc	#8
    218  489e		       85 ad		      sta	__shiftx
    219  48a0					      IF	DIAGNOSTICS
    220  48a0		       c9 08	   .fail2     cmp	#8
    221  48a2		       b0 fc		      bcs	.fail2
    222  48a4		       e0 08		      cpx	#8
    223  48a6		       b0 f8		      bcs	.fail2
    224  48a8					      ENDIF
    225  48a8		       86 ac		      stx	__tmp
    226  48aa		       65 ac		      adc	__tmp
    227  48ac
    228  48ac
    229  48ac		       29 01		      and	#1
    230  48ae		       49 01		      eor	#1
    231  48b0		       f0 02		      beq	.white
    232  48b2		       a9 24		      lda	#36
    233  48b4				   .white
    234  48b4		       85 ae		      sta	__pieceColour2	; actually SQUARE black/white
    235  48b6
    236  48b6							; PieceColour = 0 for white square, 36 for black square
    237  48b6
    238  48b6		       a9 d1		      lda	#RAMBANK_BOARD
    239  48b8		       85 3e		      sta	SET_BANK_RAM	;@3
    240  48ba
    241  48ba		       a4 80		      ldy	squareToDraw
    242  48bc		       b9 79 fc 	      lda	Board,y
    243  48bf							;and #$87
    244  48bf		       0a		      asl
    245  48c0		       90 02		      bcc	.blackAdjust
    246  48c2		       09 10		      ora	#16	; switch white pieces
    247  48c4		       4a	   .blackAdjust lsr
    248  48c5		       29 0f		      and	#%1111
    249  48c7		       aa		      tax
    250  48c8
    251  48c8		       a5 ad		      lda	__shiftx
    252  48ca		       29 03		      and	#3	; shift position in P
    253  48cc
    254  48cc		       18		      clc
    255  48cd		       7d d5 f8 	      adc	PieceToShape,x
    256  48d0		       18		      clc
    257  48d1		       65 ae		      adc	__pieceColour2
    258  48d3		       a8		      tay
    259  48d4		       60		      rts
    260  48d5
    261  48d5				   PieceToShape
    262  48d5
    263  48d5		       00		      .byte.b	INDEX_WHITE_BLANK_on_WHITE_SQUARE_0
    264  48d6		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    265  48d7		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (black P)
    266  48d8		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    267  48d9		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    268  48da		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    269  48db		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    270  48dc		       18		      .byte.b	INDEX_WHITE_KING_on_WHITE_SQUARE_0
    271  48dd
    272  48dd		       48		      .byte.b	INDEX_BLACK_BLANK_on_WHITE_SQUARE_0
    273  48de		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (white P)
    274  48df		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    275  48e0		       50		      .byte.b	INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0
    276  48e1		       54		      .byte.b	INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0
    277  48e2		       58		      .byte.b	INDEX_BLACK_ROOK_on_WHITE_SQUARE_0
    278  48e3		       5c		      .byte.b	INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    279  48e4		       60		      .byte.b	INDEX_BLACK_KING_on_WHITE_SQUARE_0
    280  48e5
    281  48e5
    282  48e5							;---------------------------------------------------------------------------------------------------
    283  48e5
      0  48e5					      DEF	AdjustMaterialPositionalValue
      1  48e5				   SLOT_AdjustMaterialPositionalValue SET	_BANK_SLOT
      2  48e5				   BANK_AdjustMaterialPositionalValue SET	SLOT_AdjustMaterialPositionalValue + _CURRENT_BANK
      3  48e5				   AdjustMaterialPositionalValue
      4  48e5				   TEMPORARY_VAR SET	Overlay
      5  48e5				   TEMPORARY_OFFSET SET	0
      6  48e5				   VAR_BOUNDARY_AdjustMaterialPositionalValue SET	TEMPORARY_OFFSET
      7  48e5				   FUNCTION_NAME SET	AdjustMaterialPositionalValue
    285  48e5					      SUBROUTINE
    286  48e5
    287  48e5							; A move is about to be made, so  adjust material and positional values based on from/to and
    288  48e5							; capture.
    289  48e5
    290  48e5							; First, nominate referencing subroutines so that local variables can be adjusted properly
    291  48e5
      0  48e5					      COMMON_VARS
      1  48e5
      0  48e5					      VAR	__thinkbar, 1
      1  48e5		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  48e5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  48e5
      4  48e5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  48e5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  48e5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  48e5					      ENDIF
      8  48e5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  48e5				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  48e5				  -	      ERR
     11  48e5					      ENDIF
     12  48e5					      LIST	ON
      0  48e5					      VAR	__toggle, 1
      1  48e5		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  48e5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  48e5
      4  48e5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  48e5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  48e5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  48e5					      ENDIF
      8  48e5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  48e5				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  48e5				  -	      ERR
     11  48e5					      ENDIF
     12  48e5					      LIST	ON
      4  48e5
      0  48e5					      VAR	__bestMove, 1
      1  48e5		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  48e5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  48e5
      4  48e5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  48e5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  48e5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  48e5					      ENDIF
      8  48e5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  48e5				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  48e5				  -	      ERR
     11  48e5					      ENDIF
     12  48e5					      LIST	ON
      0  48e5					      VAR	__alpha, 2
      1  48e5		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  48e5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  48e5
      4  48e5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  48e5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  48e5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  48e5					      ENDIF
      8  48e5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  48e5				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  48e5				  -	      ERR
     11  48e5					      ENDIF
     12  48e5					      LIST	ON
      0  48e5					      VAR	__beta, 2
      1  48e5		       00 ac	   __beta     =	TEMPORARY_VAR
      2  48e5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  48e5
      4  48e5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  48e5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  48e5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  48e5					      ENDIF
      8  48e5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  48e5				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  48e5				  -	      ERR
     11  48e5					      ENDIF
     12  48e5					      LIST	ON
      0  48e5					      VAR	__negaMax, 2
      1  48e5		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  48e5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  48e5
      4  48e5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  48e5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  48e5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  48e5					      ENDIF
      8  48e5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  48e5				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  48e5				  -	      ERR
     11  48e5					      ENDIF
     12  48e5					      LIST	ON
      0  48e5					      VAR	__value, 2
      1  48e5		       00 b0	   __value    =	TEMPORARY_VAR
      2  48e5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  48e5
      4  48e5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  48e5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  48e5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  48e5					      ENDIF
      8  48e5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  48e5				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  48e5				  -	      ERR
     11  48e5					      ENDIF
     12  48e5					      LIST	ON
     10  48e5
      0  48e5					      VAR	__quiesceCapOnly, 1
      1  48e5		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  48e5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  48e5
      4  48e5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  48e5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  48e5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  48e5					      ENDIF
      8  48e5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  48e5				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  48e5				  -	      ERR
     11  48e5					      ENDIF
     12  48e5					      LIST	ON
     12  48e5
      0  48e5					      VAR	__originalPiece, 1
      1  48e5		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  48e5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  48e5
      4  48e5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  48e5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  48e5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  48e5					      ENDIF
      8  48e5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  48e5				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  48e5				  -	      ERR
     11  48e5					      ENDIF
     12  48e5					      LIST	ON
      0  48e5					      VAR	__capturedPiece, 1
      1  48e5		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  48e5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  48e5
      4  48e5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  48e5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  48e5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  48e5					      ENDIF
      8  48e5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  48e5				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  48e5				  -	      ERR
     11  48e5					      ENDIF
     12  48e5					      LIST	ON
     15  48e5
      0  48e5					      REFER	MakeMove	;✅
      1  48e5				  -	      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  48e5				  -TEMPORARY_VAR SET	VAREND_MakeMove
      3  48e5					      ENDIF
      0  48e5					      REFER	aiMoveIsSelected	;✅
      1  48e5				  -	      IF	VAREND_aiMoveIsSelected > TEMPORARY_VAR
      2  48e5				  -TEMPORARY_VAR SET	VAREND_aiMoveIsSelected
      3  48e5					      ENDIF
      0  48e5					      VEND	AdjustMaterialPositionalValue
      1  48e5				  -	      IFNCONST	AdjustMaterialPositionalValue
      2  48e5				  -	      ECHO	"Incorrect VEND label", AdjustMaterialPositionalValue
      3  48e5				  -	      ERR
      4  48e5					      ENDIF
      5  48e5		       00 b5	   VAREND_AdjustMaterialPositionalValue =	TEMPORARY_VAR
    296  48e5
    297  48e5							; fromPiece	 piece doing the move (promoted type)
    298  48e5							; fromX12	 current square
    299  48e5							; originX12	 starting square
    300  48e5							; toX12	 ending square
    301  48e5
    302  48e5
    303  48e5							; {
    304  48e5							;   adjust the positional value  (originX12 --> fromX12)
    305  48e5
    306  48e5		       a4 86		      ldy	toX12	; already loaded
    307  48e7		       a5 96		      lda	fromPiece
    308  48e9		       20 54 f9 	      jsr	AddPiecePositionValue	; add pos value for new position
    309  48ec
    310  48ec
    311  48ec		       a5 b3		      lda	__originalPiece
    312  48ee		       45 96		      eor	fromPiece	; the new piece
    313  48f0		       29 0f		      and	#PIECE_MASK
    314  48f2		       f0 05		      beq	.same1	; unchanged, so skip
    315  48f4
    316  48f4		       a5 96		      lda	fromPiece	; new piece
    317  48f6		       20 31 f9 	      jsr	AddPieceMaterialValue
    318  48f9
    319  48f9				   .same1
    320  48f9
    321  48f9							; and now the 'subtracts'
    322  48f9
      0  48f9					      NEGEVAL
      1  48f9
      2  48f9		       38		      sec
      3  48fa		       a9 00		      lda	#0
      4  48fc		       e5 8f		      sbc	Evaluation
      5  48fe		       85 8f		      sta	Evaluation
      6  4900		       a9 00		      lda	#0
      7  4902		       e5 90		      sbc	Evaluation+1
      8  4904		       85 90		      sta	Evaluation+1
    324  4906
    325  4906		       a4 87		      ldy	originX12
    326  4908		       a5 b3		      lda	__originalPiece
    327  490a		       20 54 f9 	      jsr	AddPiecePositionValue	; remove pos value for original position
    328  490d
    329  490d
    330  490d		       a5 b3		      lda	__originalPiece
    331  490f		       45 96		      eor	fromPiece	; the new piece
    332  4911		       29 0f		      and	#PIECE_MASK
    333  4913		       f0 05		      beq	.same2	; unchanged, so skip
    334  4915
    335  4915		       a5 b3		      lda	__originalPiece
    336  4917		       20 31 f9 	      jsr	AddPieceMaterialValue	; remove material for original type
    337  491a				   .same2
    338  491a
      0  491a					      NEGEVAL
      1  491a
      2  491a		       38		      sec
      3  491b		       a9 00		      lda	#0
      4  491d		       e5 8f		      sbc	Evaluation
      5  491f		       85 8f		      sta	Evaluation
      6  4921		       a9 00		      lda	#0
      7  4923		       e5 90		      sbc	Evaluation+1
      8  4925		       85 90		      sta	Evaluation+1
    340  4927
    341  4927							; If there's a capture, we adjust the material value
    342  4927
    343  4927							;		      lda __capturedPiece
    344  4927							;		      eor __originalPiece
    345  4927							;		      bpl .noCapture		      ; special-case capture rook castling onto king
    346  4927
    347  4927
    348  4927		       a5 b4		      lda	__capturedPiece
    349  4929		       29 0f		      and	#PIECE_MASK
    350  492b		       f0 03		      beq	.noCapture
    351  492d		       20 31 f9 	      jsr	AddPieceMaterialValue	; -other colour = + my colour!
    352  4930				   .noCapture
    353  4930
    354  4930							; }
    355  4930		       60		      rts
    356  4931
    357  4931
    358  4931							;---------------------------------------------------------------------------------------------------
    359  4931
      0  4931					      DEF	AddPieceMaterialValue
      1  4931				   SLOT_AddPieceMaterialValue SET	_BANK_SLOT
      2  4931				   BANK_AddPieceMaterialValue SET	SLOT_AddPieceMaterialValue + _CURRENT_BANK
      3  4931				   AddPieceMaterialValue
      4  4931				   TEMPORARY_VAR SET	Overlay
      5  4931				   TEMPORARY_OFFSET SET	0
      6  4931				   VAR_BOUNDARY_AddPieceMaterialValue SET	TEMPORARY_OFFSET
      7  4931				   FUNCTION_NAME SET	AddPieceMaterialValue
    361  4931					      SUBROUTINE
    362  4931
      0  4931					      COMMON_VARS
      1  4931
      0  4931					      VAR	__thinkbar, 1
      1  4931		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  4931				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4931
      4  4931				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4931				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4931				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4931					      ENDIF
      8  4931				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4931				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  4931				  -	      ERR
     11  4931					      ENDIF
     12  4931					      LIST	ON
      0  4931					      VAR	__toggle, 1
      1  4931		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  4931				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4931
      4  4931				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4931				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4931				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4931					      ENDIF
      8  4931				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4931				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  4931				  -	      ERR
     11  4931					      ENDIF
     12  4931					      LIST	ON
      4  4931
      0  4931					      VAR	__bestMove, 1
      1  4931		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  4931				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4931
      4  4931				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4931				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4931				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4931					      ENDIF
      8  4931				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4931				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  4931				  -	      ERR
     11  4931					      ENDIF
     12  4931					      LIST	ON
      0  4931					      VAR	__alpha, 2
      1  4931		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  4931				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4931
      4  4931				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4931				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4931				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4931					      ENDIF
      8  4931				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4931				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  4931				  -	      ERR
     11  4931					      ENDIF
     12  4931					      LIST	ON
      0  4931					      VAR	__beta, 2
      1  4931		       00 ac	   __beta     =	TEMPORARY_VAR
      2  4931				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4931
      4  4931				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4931				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4931				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4931					      ENDIF
      8  4931				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4931				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  4931				  -	      ERR
     11  4931					      ENDIF
     12  4931					      LIST	ON
      0  4931					      VAR	__negaMax, 2
      1  4931		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  4931				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4931
      4  4931				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4931				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4931				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4931					      ENDIF
      8  4931				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4931				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  4931				  -	      ERR
     11  4931					      ENDIF
     12  4931					      LIST	ON
      0  4931					      VAR	__value, 2
      1  4931		       00 b0	   __value    =	TEMPORARY_VAR
      2  4931				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4931
      4  4931				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4931				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4931				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4931					      ENDIF
      8  4931				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4931				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  4931				  -	      ERR
     11  4931					      ENDIF
     12  4931					      LIST	ON
     10  4931
      0  4931					      VAR	__quiesceCapOnly, 1
      1  4931		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  4931				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4931
      4  4931				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4931				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4931				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4931					      ENDIF
      8  4931				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4931				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  4931				  -	      ERR
     11  4931					      ENDIF
     12  4931					      LIST	ON
     12  4931
      0  4931					      VAR	__originalPiece, 1
      1  4931		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  4931				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4931
      4  4931				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4931				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4931				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4931					      ENDIF
      8  4931				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4931				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  4931				  -	      ERR
     11  4931					      ENDIF
     12  4931					      LIST	ON
      0  4931					      VAR	__capturedPiece, 1
      1  4931		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  4931				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4931
      4  4931				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4931				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4931				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4931					      ENDIF
      8  4931				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4931				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  4931				  -	      ERR
     11  4931					      ENDIF
     12  4931					      LIST	ON
     15  4931
      0  4931					      REFER	InitialisePieceSquares	;✅
      1  4931					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  4931				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  4931					      ENDIF
      0  4931					      REFER	AdjustMaterialPositionalValue	;✅
      1  4931				  -	      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  4931				  -TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  4931					      ENDIF
    366  4931							;REFER EnPassantRemovePiece ;✅
      0  4931					      VEND	AddPieceMaterialValue
      1  4931				  -	      IFNCONST	AddPieceMaterialValue
      2  4931				  -	      ECHO	"Incorrect VEND label", AddPieceMaterialValue
      3  4931				  -	      ERR
      4  4931					      ENDIF
      5  4931		       00 b9	   VAREND_AddPieceMaterialValue =	TEMPORARY_VAR
    368  4931
    369  4931							; Adjust the material score based on the piece
    370  4931							; a = piece type + flags
    371  4931
    372  4931		       29 0f		      and	#PIECE_MASK
    373  4933		       a8		      tay
    374  4934
    375  4934		       18		      clc
    376  4935		       b9 44 f9 	      lda	PieceValueLO,y
    377  4938		       65 8f		      adc	Evaluation
    378  493a		       85 8f		      sta	Evaluation
    379  493c		       b9 4c f9 	      lda	PieceValueHI,y
    380  493f		       65 90		      adc	Evaluation+1
    381  4941		       85 90		      sta	Evaluation+1
    382  4943		       60		      rts
    383  4944
    384  4944
    385  4944					      MAC	valuetable
    386  4944					      .byte	{1}0	; blank
    387  4944					      .byte	{1}100	; white P
    388  4944					      .byte	{1}100	; black P
    389  4944					      .byte	{1}320	; N
    390  4944					      .byte	{1}375	; B
    391  4944					      .byte	{1}575	; R
    392  4944					      .byte	{1}900	; Q
    393  4944					      .byte	{1}10000	; K
    394  4944					      ENDM
    395  4944
    396  4944				   PieceValueLO
      0  4944					      VALUETABLE	<
      1  4944		       00		      .byte.b	<0
      2  4945		       64		      .byte.b	<100
      3  4946		       64		      .byte.b	<100
      4  4947		       40		      .byte.b	<320
      5  4948		       77		      .byte.b	<375
      6  4949		       3f		      .byte.b	<575
      7  494a		       84		      .byte.b	<900
      8  494b		       10		      .byte.b	<10000
    398  494c
    399  494c				   PieceValueHI
      0  494c					      VALUETABLE	>
      1  494c		       00		      .byte.b	>0
      2  494d		       00		      .byte.b	>100
      3  494e		       00		      .byte.b	>100
      4  494f		       01		      .byte.b	>320
      5  4950		       01		      .byte.b	>375
      6  4951		       02		      .byte.b	>575
      7  4952		       03		      .byte.b	>900
      8  4953		       27		      .byte.b	>10000
    401  4954
    402  4954
    403  4954							;---------------------------------------------------------------------------------------------------
    404  4954
      0  4954					      DEF	AddPiecePositionValue
      1  4954				   SLOT_AddPiecePositionValue SET	_BANK_SLOT
      2  4954				   BANK_AddPiecePositionValue SET	SLOT_AddPiecePositionValue + _CURRENT_BANK
      3  4954				   AddPiecePositionValue
      4  4954				   TEMPORARY_VAR SET	Overlay
      5  4954				   TEMPORARY_OFFSET SET	0
      6  4954				   VAR_BOUNDARY_AddPiecePositionValue SET	TEMPORARY_OFFSET
      7  4954				   FUNCTION_NAME SET	AddPiecePositionValue
    406  4954					      SUBROUTINE
    407  4954
      0  4954					      REFER	InitialisePieceSquares	;✅
      1  4954					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  4954				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  4954					      ENDIF
      0  4954					      REFER	AdjustMaterialPositionalValue	;✅
      1  4954				  -	      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  4954				  -TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  4954					      ENDIF
    410  4954							;REFER EnPassantRemovePiece ;✅
      0  4954					      VAR	__valPtr, 2
      1  4954		       00 b9	   __valPtr   =	TEMPORARY_VAR
      2  4954				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4954
      4  4954				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4954					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4954				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4954					      ENDIF
      8  4954				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4954				  -	      ECHO	"Temporary Variable", __valPtr, "overflow!"
     10  4954				  -	      ERR
     11  4954					      ENDIF
     12  4954					      LIST	ON
      0  4954					      VEND	AddPiecePositionValue
      1  4954				  -	      IFNCONST	AddPiecePositionValue
      2  4954				  -	      ECHO	"Incorrect VEND label", AddPiecePositionValue
      3  4954				  -	      ERR
      4  4954					      ENDIF
      5  4954		       00 bb	   VAREND_AddPiecePositionValue =	TEMPORARY_VAR
    413  4954
    414  4954
    415  4954							; adds value of square piece is on to the evaluation
    416  4954							; note to do the subtraction as -( -x + val) == x - val
    417  4954
    418  4954							; y = square
    419  4954							; a = piece type (+flags)
    420  4954
    421  4954
    422  4954
    423  4954		       c9 80		      cmp	#128	; black = CS
    424  4956		       29 0f		      and	#PIECE_MASK
    425  4958		       aa		      tax
    426  4959
    427  4959		       a9 c6		      lda	#EVAL
    428  495b		       85 3f		      sta	SET_BANK	;@3
    429  495d
    430  495d							; black pieces flip rows so we can use the same eval tables
    431  495d
    432  495d		       98		      tya
    433  495e		       90 03		      bcc	.white
    434  4960		       b9 81 f9 	      lda	FlipSquareIndex,y
    435  4963							;clc
    436  4963				   .white
    437  4963		       7d 00 fc 	      adc	PosValVecLO,x
    438  4966		       85 b9		      sta	__valPtr
    439  4968		       bd 08 fc 	      lda	PosValVecHI,x
    440  496b		       69 00		      adc	#0
    441  496d		       85 ba		      sta	__valPtr+1
    442  496f
    443  496f		       a0 00		      ldy	#0
    444  4971		       b1 b9		      lda	(__valPtr),y
    445  4973		       10 01		      bpl	.sum
    446  4975		       88		      dey
    447  4976
    448  4976		       18	   .sum       clc
    449  4977		       65 8f		      adc	Evaluation
    450  4979		       85 8f		      sta	Evaluation
    451  497b		       98		      tya
    452  497c		       65 90		      adc	Evaluation+1
    453  497e		       85 90		      sta	Evaluation+1
    454  4980		       60		      rts
    455  4981
    456  4981
    457  4981				   FlipSquareIndex
    458  4981
    459  4981		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    460  498b		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    461  4995
    462  4995				   .SQBASE    SET	90-1
    463  4995					      REPEAT	8
    464  4995		       00 00		      .byte.b	0,0
    465  4995				   .SQX       SET	2
    466  4997					      REPEAT	8
    467  4997		       5b		      .byte.b	(.SQBASE+.SQX)
    468  4997				   .SQX       SET	.SQX + 1
    466  4997					      REPEND
    467  4998		       5c		      .byte.b	(.SQBASE+.SQX)
    468  4998				   .SQX       SET	.SQX + 1
    466  4998					      REPEND
    467  4999		       5d		      .byte.b	(.SQBASE+.SQX)
    468  4999				   .SQX       SET	.SQX + 1
    466  4999					      REPEND
    467  499a		       5e		      .byte.b	(.SQBASE+.SQX)
    468  499a				   .SQX       SET	.SQX + 1
    466  499a					      REPEND
    467  499b		       5f		      .byte.b	(.SQBASE+.SQX)
    468  499b				   .SQX       SET	.SQX + 1
    466  499b					      REPEND
    467  499c		       60		      .byte.b	(.SQBASE+.SQX)
    468  499c				   .SQX       SET	.SQX + 1
    466  499c					      REPEND
    467  499d		       61		      .byte.b	(.SQBASE+.SQX)
    468  499d				   .SQX       SET	.SQX + 1
    466  499d					      REPEND
    467  499e		       62		      .byte.b	(.SQBASE+.SQX)
    468  499e				   .SQX       SET	.SQX + 1
    469  499f					      REPEND
    470  499f				   .SQBASE    SET	.SQBASE - 10
    463  499f					      REPEND
    464  499f		       00 00		      .byte.b	0,0
    465  499f				   .SQX       SET	2
    466  49a1					      REPEAT	8
    467  49a1		       51		      .byte.b	(.SQBASE+.SQX)
    468  49a1				   .SQX       SET	.SQX + 1
    466  49a1					      REPEND
    467  49a2		       52		      .byte.b	(.SQBASE+.SQX)
    468  49a2				   .SQX       SET	.SQX + 1
    466  49a2					      REPEND
    467  49a3		       53		      .byte.b	(.SQBASE+.SQX)
    468  49a3				   .SQX       SET	.SQX + 1
    466  49a3					      REPEND
    467  49a4		       54		      .byte.b	(.SQBASE+.SQX)
    468  49a4				   .SQX       SET	.SQX + 1
    466  49a4					      REPEND
    467  49a5		       55		      .byte.b	(.SQBASE+.SQX)
    468  49a5				   .SQX       SET	.SQX + 1
    466  49a5					      REPEND
    467  49a6		       56		      .byte.b	(.SQBASE+.SQX)
    468  49a6				   .SQX       SET	.SQX + 1
    466  49a6					      REPEND
    467  49a7		       57		      .byte.b	(.SQBASE+.SQX)
    468  49a7				   .SQX       SET	.SQX + 1
    466  49a7					      REPEND
    467  49a8		       58		      .byte.b	(.SQBASE+.SQX)
    468  49a8				   .SQX       SET	.SQX + 1
    469  49a9					      REPEND
    470  49a9				   .SQBASE    SET	.SQBASE - 10
    463  49a9					      REPEND
    464  49a9		       00 00		      .byte.b	0,0
    465  49a9				   .SQX       SET	2
    466  49ab					      REPEAT	8
    467  49ab		       47		      .byte.b	(.SQBASE+.SQX)
    468  49ab				   .SQX       SET	.SQX + 1
    466  49ab					      REPEND
    467  49ac		       48		      .byte.b	(.SQBASE+.SQX)
    468  49ac				   .SQX       SET	.SQX + 1
    466  49ac					      REPEND
    467  49ad		       49		      .byte.b	(.SQBASE+.SQX)
    468  49ad				   .SQX       SET	.SQX + 1
    466  49ad					      REPEND
    467  49ae		       4a		      .byte.b	(.SQBASE+.SQX)
    468  49ae				   .SQX       SET	.SQX + 1
    466  49ae					      REPEND
    467  49af		       4b		      .byte.b	(.SQBASE+.SQX)
    468  49af				   .SQX       SET	.SQX + 1
    466  49af					      REPEND
    467  49b0		       4c		      .byte.b	(.SQBASE+.SQX)
    468  49b0				   .SQX       SET	.SQX + 1
    466  49b0					      REPEND
    467  49b1		       4d		      .byte.b	(.SQBASE+.SQX)
    468  49b1				   .SQX       SET	.SQX + 1
    466  49b1					      REPEND
    467  49b2		       4e		      .byte.b	(.SQBASE+.SQX)
    468  49b2				   .SQX       SET	.SQX + 1
    469  49b3					      REPEND
    470  49b3				   .SQBASE    SET	.SQBASE - 10
    463  49b3					      REPEND
    464  49b3		       00 00		      .byte.b	0,0
    465  49b3				   .SQX       SET	2
    466  49b5					      REPEAT	8
    467  49b5		       3d		      .byte.b	(.SQBASE+.SQX)
    468  49b5				   .SQX       SET	.SQX + 1
    466  49b5					      REPEND
    467  49b6		       3e		      .byte.b	(.SQBASE+.SQX)
    468  49b6				   .SQX       SET	.SQX + 1
    466  49b6					      REPEND
    467  49b7		       3f		      .byte.b	(.SQBASE+.SQX)
    468  49b7				   .SQX       SET	.SQX + 1
    466  49b7					      REPEND
    467  49b8		       40		      .byte.b	(.SQBASE+.SQX)
    468  49b8				   .SQX       SET	.SQX + 1
    466  49b8					      REPEND
    467  49b9		       41		      .byte.b	(.SQBASE+.SQX)
    468  49b9				   .SQX       SET	.SQX + 1
    466  49b9					      REPEND
    467  49ba		       42		      .byte.b	(.SQBASE+.SQX)
    468  49ba				   .SQX       SET	.SQX + 1
    466  49ba					      REPEND
    467  49bb		       43		      .byte.b	(.SQBASE+.SQX)
    468  49bb				   .SQX       SET	.SQX + 1
    466  49bb					      REPEND
    467  49bc		       44		      .byte.b	(.SQBASE+.SQX)
    468  49bc				   .SQX       SET	.SQX + 1
    469  49bd					      REPEND
    470  49bd				   .SQBASE    SET	.SQBASE - 10
    463  49bd					      REPEND
    464  49bd		       00 00		      .byte.b	0,0
    465  49bd				   .SQX       SET	2
    466  49bf					      REPEAT	8
    467  49bf		       33		      .byte.b	(.SQBASE+.SQX)
    468  49bf				   .SQX       SET	.SQX + 1
    466  49bf					      REPEND
    467  49c0		       34		      .byte.b	(.SQBASE+.SQX)
    468  49c0				   .SQX       SET	.SQX + 1
    466  49c0					      REPEND
    467  49c1		       35		      .byte.b	(.SQBASE+.SQX)
    468  49c1				   .SQX       SET	.SQX + 1
    466  49c1					      REPEND
    467  49c2		       36		      .byte.b	(.SQBASE+.SQX)
    468  49c2				   .SQX       SET	.SQX + 1
    466  49c2					      REPEND
    467  49c3		       37		      .byte.b	(.SQBASE+.SQX)
    468  49c3				   .SQX       SET	.SQX + 1
    466  49c3					      REPEND
    467  49c4		       38		      .byte.b	(.SQBASE+.SQX)
    468  49c4				   .SQX       SET	.SQX + 1
    466  49c4					      REPEND
    467  49c5		       39		      .byte.b	(.SQBASE+.SQX)
    468  49c5				   .SQX       SET	.SQX + 1
    466  49c5					      REPEND
    467  49c6		       3a		      .byte.b	(.SQBASE+.SQX)
    468  49c6				   .SQX       SET	.SQX + 1
    469  49c7					      REPEND
    470  49c7				   .SQBASE    SET	.SQBASE - 10
    463  49c7					      REPEND
    464  49c7		       00 00		      .byte.b	0,0
    465  49c7				   .SQX       SET	2
    466  49c9					      REPEAT	8
    467  49c9		       29		      .byte.b	(.SQBASE+.SQX)
    468  49c9				   .SQX       SET	.SQX + 1
    466  49c9					      REPEND
    467  49ca		       2a		      .byte.b	(.SQBASE+.SQX)
    468  49ca				   .SQX       SET	.SQX + 1
    466  49ca					      REPEND
    467  49cb		       2b		      .byte.b	(.SQBASE+.SQX)
    468  49cb				   .SQX       SET	.SQX + 1
    466  49cb					      REPEND
    467  49cc		       2c		      .byte.b	(.SQBASE+.SQX)
    468  49cc				   .SQX       SET	.SQX + 1
    466  49cc					      REPEND
    467  49cd		       2d		      .byte.b	(.SQBASE+.SQX)
    468  49cd				   .SQX       SET	.SQX + 1
    466  49cd					      REPEND
    467  49ce		       2e		      .byte.b	(.SQBASE+.SQX)
    468  49ce				   .SQX       SET	.SQX + 1
    466  49ce					      REPEND
    467  49cf		       2f		      .byte.b	(.SQBASE+.SQX)
    468  49cf				   .SQX       SET	.SQX + 1
    466  49cf					      REPEND
    467  49d0		       30		      .byte.b	(.SQBASE+.SQX)
    468  49d0				   .SQX       SET	.SQX + 1
    469  49d1					      REPEND
    470  49d1				   .SQBASE    SET	.SQBASE - 10
    463  49d1					      REPEND
    464  49d1		       00 00		      .byte.b	0,0
    465  49d1				   .SQX       SET	2
    466  49d3					      REPEAT	8
    467  49d3		       1f		      .byte.b	(.SQBASE+.SQX)
    468  49d3				   .SQX       SET	.SQX + 1
    466  49d3					      REPEND
    467  49d4		       20		      .byte.b	(.SQBASE+.SQX)
    468  49d4				   .SQX       SET	.SQX + 1
    466  49d4					      REPEND
    467  49d5		       21		      .byte.b	(.SQBASE+.SQX)
    468  49d5				   .SQX       SET	.SQX + 1
    466  49d5					      REPEND
    467  49d6		       22		      .byte.b	(.SQBASE+.SQX)
    468  49d6				   .SQX       SET	.SQX + 1
    466  49d6					      REPEND
    467  49d7		       23		      .byte.b	(.SQBASE+.SQX)
    468  49d7				   .SQX       SET	.SQX + 1
    466  49d7					      REPEND
    467  49d8		       24		      .byte.b	(.SQBASE+.SQX)
    468  49d8				   .SQX       SET	.SQX + 1
    466  49d8					      REPEND
    467  49d9		       25		      .byte.b	(.SQBASE+.SQX)
    468  49d9				   .SQX       SET	.SQX + 1
    466  49d9					      REPEND
    467  49da		       26		      .byte.b	(.SQBASE+.SQX)
    468  49da				   .SQX       SET	.SQX + 1
    469  49db					      REPEND
    470  49db				   .SQBASE    SET	.SQBASE - 10
    463  49db					      REPEND
    464  49db		       00 00		      .byte.b	0,0
    465  49db				   .SQX       SET	2
    466  49dd					      REPEAT	8
    467  49dd		       15		      .byte.b	(.SQBASE+.SQX)
    468  49dd				   .SQX       SET	.SQX + 1
    466  49dd					      REPEND
    467  49de		       16		      .byte.b	(.SQBASE+.SQX)
    468  49de				   .SQX       SET	.SQX + 1
    466  49de					      REPEND
    467  49df		       17		      .byte.b	(.SQBASE+.SQX)
    468  49df				   .SQX       SET	.SQX + 1
    466  49df					      REPEND
    467  49e0		       18		      .byte.b	(.SQBASE+.SQX)
    468  49e0				   .SQX       SET	.SQX + 1
    466  49e0					      REPEND
    467  49e1		       19		      .byte.b	(.SQBASE+.SQX)
    468  49e1				   .SQX       SET	.SQX + 1
    466  49e1					      REPEND
    467  49e2		       1a		      .byte.b	(.SQBASE+.SQX)
    468  49e2				   .SQX       SET	.SQX + 1
    466  49e2					      REPEND
    467  49e3		       1b		      .byte.b	(.SQBASE+.SQX)
    468  49e3				   .SQX       SET	.SQX + 1
    466  49e3					      REPEND
    467  49e4		       1c		      .byte.b	(.SQBASE+.SQX)
    468  49e4				   .SQX       SET	.SQX + 1
    469  49e5					      REPEND
    470  49e5				   .SQBASE    SET	.SQBASE - 10
    471  49e5					      REPEND
    472  49e5
    473  49e5
    474  49e5							;---------------------------------------------------------------------------------------------------
    475  49e5
------- FILE piece_vectors.asm LEVEL 3 PASS 4
      0  49e5					      include	"piece_vectors.asm"
      1  49e5							; Created by ConvertChessPieces.py
      0  49e5					      DEF	PIECE_VECTOR_LO
      1  49e5				   SLOT_PIECE_VECTOR_LO SET	_BANK_SLOT
      2  49e5				   BANK_PIECE_VECTOR_LO SET	SLOT_PIECE_VECTOR_LO + _CURRENT_BANK
      3  49e5				   PIECE_VECTOR_LO
      4  49e5				   TEMPORARY_VAR SET	Overlay
      5  49e5				   TEMPORARY_OFFSET SET	0
      6  49e5				   VAR_BOUNDARY_PIECE_VECTOR_LO SET	TEMPORARY_OFFSET
      7  49e5				   FUNCTION_NAME SET	PIECE_VECTOR_LO
      3  49e5		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_0
      4  49e6		       48		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_1
      5  49e7		       90		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_2
      6  49e8		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_3
      7  49e9		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_0
      8  49ea		       90		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_1
      9  49eb		       00		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_2
     10  49ec		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_3
     11  49ed		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_0
     12  49ee		       00		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_1
     13  49ef		       48		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_2
     14  49f0		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_3
     15  49f1		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_0
     16  49f2		       48		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_1
     17  49f3		       90		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_2
     18  49f4		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_3
     19  49f5		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_0
     20  49f6		       90		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_1
     21  49f7		       00		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_2
     22  49f8		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_3
     23  49f9		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_0
     24  49fa		       00		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_1
     25  49fb		       48		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_2
     26  49fc		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_3
     27  49fd		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_0
     28  49fe		       48		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_1
     29  49ff		       90		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_2
     30  4a00		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_3
     31  4a01		       00		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_0
     32  4a02		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_1
     33  4a03		       90		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_2
     34  4a04		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_3
     35  4a05		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_0
     36  4a06		       00		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_1
     37  4a07		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_2
     38  4a08		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_3
     39  4a09		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_0
     40  4a0a		       90		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_1
     41  4a0b		       00		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_2
     42  4a0c		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_3
     43  4a0d		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_0
     44  4a0e		       00		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_1
     45  4a0f		       48		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_2
     46  4a10		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_3
     47  4a11		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_0
     48  4a12		       48		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_1
     49  4a13		       90		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_2
     50  4a14		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_3
     51  4a15		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_0
     52  4a16		       90		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_1
     53  4a17		       00		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_2
     54  4a18		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_3
     55  4a19		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_0
     56  4a1a		       00		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_1
     57  4a1b		       48		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_2
     58  4a1c		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_3
     59  4a1d		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_0
     60  4a1e		       48		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_1
     61  4a1f		       90		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_2
     62  4a20		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_3
     63  4a21		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_0
     64  4a22		       90		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_1
     65  4a23		       00		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_2
     66  4a24		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_3
     67  4a25		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_0
     68  4a26		       00		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_1
     69  4a27		       48		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_2
     70  4a28		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_3
     71  4a29		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_0
     72  4a2a		       90		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_1
     73  4a2b		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_2
     74  4a2c		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_3
     75  4a2d		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_0
     76  4a2e		       00		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_1
     77  4a2f		       48		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_2
     78  4a30		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_3
     79  4a31		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_0
     80  4a32		       48		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_1
     81  4a33		       90		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_2
     82  4a34		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_3
     83  4a35		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_0
     84  4a36		       90		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_1
     85  4a37		       00		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_2
     86  4a38		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_3
     87  4a39		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_0
     88  4a3a		       00		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_1
     89  4a3b		       48		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_2
     90  4a3c		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_3
     91  4a3d		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_0
     92  4a3e		       48		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_1
     93  4a3f		       90		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_2
     94  4a40		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_3
     95  4a41		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_0
     96  4a42		       90		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_1
     97  4a43		       00		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_2
     98  4a44		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_3
     99  4a45		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_0
    100  4a46		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_1
    101  4a47		       48		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_2
    102  4a48		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_3
    103  4a49		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_0
    104  4a4a		       48		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_1
    105  4a4b		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_2
    106  4a4c		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_3
    107  4a4d		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_0
    108  4a4e		       90		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_1
    109  4a4f		       00		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_2
    110  4a50		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_3
    111  4a51		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_0
    112  4a52		       90		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_1
    113  4a53		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_2
    114  4a54		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_3
    115  4a55		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_0
    116  4a56		       00		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_1
    117  4a57		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_2
    118  4a58		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_3
    119  4a59		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_0
    120  4a5a		       48		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_1
    121  4a5b		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_2
    122  4a5c		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_3
    123  4a5d		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_0
    124  4a5e		       48		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_1
    125  4a5f		       90		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_2
    126  4a60		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_3
    127  4a61		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_0
    128  4a62		       90		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_1
    129  4a63		       00		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_2
    130  4a64		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_3
    131  4a65		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_0
    132  4a66		       00		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_1
    133  4a67		       48		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_2
    134  4a68		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_3
    135  4a69		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_0
    136  4a6a		       48		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_1
    137  4a6b		       90		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_2
    138  4a6c		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_3
    139  4a6d		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_0
    140  4a6e		       00		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_1
    141  4a6f		       48		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_2
    142  4a70		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_3
    143  4a71		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_0
    144  4a72		       48		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_1
    145  4a73		       90		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_2
    146  4a74		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  4a75					      DEF	PIECE_VECTOR_HI
      1  4a75				   SLOT_PIECE_VECTOR_HI SET	_BANK_SLOT
      2  4a75				   BANK_PIECE_VECTOR_HI SET	SLOT_PIECE_VECTOR_HI + _CURRENT_BANK
      3  4a75				   PIECE_VECTOR_HI
      4  4a75				   TEMPORARY_VAR SET	Overlay
      5  4a75				   TEMPORARY_OFFSET SET	0
      6  4a75				   VAR_BOUNDARY_PIECE_VECTOR_HI SET	TEMPORARY_OFFSET
      7  4a75				   FUNCTION_NAME SET	PIECE_VECTOR_HI
    148  4a75		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_0
    149  4a76		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_1
    150  4a77		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_2
    151  4a78		       f9		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_3
    152  4a79		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_0
    153  4a7a		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_1
    154  4a7b		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_2
    155  4a7c		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_3
    156  4a7d		       fa		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_0
    157  4a7e		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_1
    158  4a7f		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_2
    159  4a80		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_3
    160  4a81		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_0
    161  4a82		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_1
    162  4a83		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_2
    163  4a84		       f9		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_3
    164  4a85		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_0
    165  4a86		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_1
    166  4a87		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_2
    167  4a88		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_3
    168  4a89		       fa		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_0
    169  4a8a		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_1
    170  4a8b		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_2
    171  4a8c		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_3
    172  4a8d		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_0
    173  4a8e		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_1
    174  4a8f		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_2
    175  4a90		       f9		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_3
    176  4a91		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_0
    177  4a92		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_1
    178  4a93		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_2
    179  4a94		       fa		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_3
    180  4a95		       fa		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_0
    181  4a96		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_1
    182  4a97		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_2
    183  4a98		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_3
    184  4a99		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_0
    185  4a9a		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_1
    186  4a9b		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_2
    187  4a9c		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_3
    188  4a9d		       fa		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_0
    189  4a9e		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_1
    190  4a9f		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_2
    191  4aa0		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_3
    192  4aa1		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_0
    193  4aa2		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_1
    194  4aa3		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_2
    195  4aa4		       f9		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_3
    196  4aa5		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_0
    197  4aa6		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_1
    198  4aa7		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_2
    199  4aa8		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_3
    200  4aa9		       fa		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_0
    201  4aaa		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_1
    202  4aab		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_2
    203  4aac		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_3
    204  4aad		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_0
    205  4aae		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_1
    206  4aaf		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_2
    207  4ab0		       f9		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_3
    208  4ab1		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_0
    209  4ab2		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_1
    210  4ab3		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_2
    211  4ab4		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_3
    212  4ab5		       fa		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_0
    213  4ab6		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_1
    214  4ab7		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_2
    215  4ab8		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_3
    216  4ab9		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_0
    217  4aba		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_1
    218  4abb		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_2
    219  4abc		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_3
    220  4abd		       fa		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_0
    221  4abe		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_1
    222  4abf		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_2
    223  4ac0		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_3
    224  4ac1		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_0
    225  4ac2		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_1
    226  4ac3		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_2
    227  4ac4		       f9		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_3
    228  4ac5		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_0
    229  4ac6		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_1
    230  4ac7		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_2
    231  4ac8		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_3
    232  4ac9		       fa		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_0
    233  4aca		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_1
    234  4acb		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_2
    235  4acc		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_3
    236  4acd		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_0
    237  4ace		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_1
    238  4acf		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_2
    239  4ad0		       f9		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_3
    240  4ad1		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_0
    241  4ad2		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_1
    242  4ad3		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_2
    243  4ad4		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_3
    244  4ad5		       fa		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_0
    245  4ad6		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_1
    246  4ad7		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_2
    247  4ad8		       f8		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_3
    248  4ad9		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_0
    249  4ada		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_1
    250  4adb		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_2
    251  4adc		       f9		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_3
    252  4add		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_0
    253  4ade		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_1
    254  4adf		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_2
    255  4ae0		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_3
    256  4ae1		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_0
    257  4ae2		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_1
    258  4ae3		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_2
    259  4ae4		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_3
    260  4ae5		       f9		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_0
    261  4ae6		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_1
    262  4ae7		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_2
    263  4ae8		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_3
    264  4ae9		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_0
    265  4aea		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_1
    266  4aeb		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_2
    267  4aec		       f8		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_3
    268  4aed		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_0
    269  4aee		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_1
    270  4aef		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_2
    271  4af0		       fa		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_3
    272  4af1		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_0
    273  4af2		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_1
    274  4af3		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_2
    275  4af4		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_3
    276  4af5		       fb		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_0
    277  4af6		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_1
    278  4af7		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_2
    279  4af8		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_3
    280  4af9		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_0
    281  4afa		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_1
    282  4afb		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_2
    283  4afc		       fa		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_3
    284  4afd		       fa		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_0
    285  4afe		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_1
    286  4aff		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_2
    287  4b00		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_3
    288  4b01		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_0
    289  4b02		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_1
    290  4b03		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_2
    291  4b04		       f9		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  4b05					      DEF	PIECE_VECTOR_BANK
      1  4b05				   SLOT_PIECE_VECTOR_BANK SET	_BANK_SLOT
      2  4b05				   BANK_PIECE_VECTOR_BANK SET	SLOT_PIECE_VECTOR_BANK + _CURRENT_BANK
      3  4b05				   PIECE_VECTOR_BANK
      4  4b05				   TEMPORARY_VAR SET	Overlay
      5  4b05				   TEMPORARY_OFFSET SET	0
      6  4b05				   VAR_BOUNDARY_PIECE_VECTOR_BANK SET	TEMPORARY_OFFSET
      7  4b05				   FUNCTION_NAME SET	PIECE_VECTOR_BANK
    293  4b05		       89		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_0
    294  4b06		       89		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_1
    295  4b07		       89		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_2
    296  4b08		       89		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_3
    297  4b09		       89		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_0
    298  4b0a		       89		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_1
    299  4b0b		       89		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_2
    300  4b0c		       89		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_3
    301  4b0d		       89		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0
    302  4b0e		       89		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1
    303  4b0f		       89		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2
    304  4b10		       89		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3
    305  4b11		       8a		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_0
    306  4b12		       8a		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_1
    307  4b13		       8a		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_2
    308  4b14		       8a		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_3
    309  4b15		       8a		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_0
    310  4b16		       8a		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_1
    311  4b17		       8a		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_2
    312  4b18		       8a		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_3
    313  4b19		       8a		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_0
    314  4b1a		       8a		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_1
    315  4b1b		       8a		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_2
    316  4b1c		       8a		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_3
    317  4b1d		       8b		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_0
    318  4b1e		       8b		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_1
    319  4b1f		       8b		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_2
    320  4b20		       8b		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_3
    321  4b21		       95		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_0
    322  4b22		       95		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_1
    323  4b23		       95		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_2
    324  4b24		       96		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_3
    325  4b25		       97		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0
    326  4b26		       97		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1
    327  4b27		       97		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2
    328  4b28		       97		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3
    329  4b29		       8b		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_0
    330  4b2a		       8b		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_1
    331  4b2b		       8b		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_2
    332  4b2c		       8b		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_3
    333  4b2d		       8b		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_0
    334  4b2e		       8b		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_1
    335  4b2f		       8b		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_2
    336  4b30		       8b		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_3
    337  4b31		       8c		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0
    338  4b32		       8c		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1
    339  4b33		       8c		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2
    340  4b34		       8c		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3
    341  4b35		       8c		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_0
    342  4b36		       8c		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_1
    343  4b37		       8c		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_2
    344  4b38		       8c		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_3
    345  4b39		       8c		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_0
    346  4b3a		       8c		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_1
    347  4b3b		       8c		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_2
    348  4b3c		       8c		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_3
    349  4b3d		       8d		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_0
    350  4b3e		       8d		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_1
    351  4b3f		       8d		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_2
    352  4b40		       8d		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_3
    353  4b41		       8d		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_0
    354  4b42		       8d		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_1
    355  4b43		       8d		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_2
    356  4b44		       8d		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_3
    357  4b45		       94		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_0
    358  4b46		       94		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_1
    359  4b47		       94		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_2
    360  4b48		       94		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_3
    361  4b49		       97		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0
    362  4b4a		       97		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1
    363  4b4b		       97		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2
    364  4b4c		       97		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3
    365  4b4d		       8d		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_0
    366  4b4e		       8d		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_1
    367  4b4f		       8d		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_2
    368  4b50		       8d		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_3
    369  4b51		       8e		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_0
    370  4b52		       8e		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_1
    371  4b53		       8e		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_2
    372  4b54		       8e		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_3
    373  4b55		       8e		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0
    374  4b56		       8e		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1
    375  4b57		       8e		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2
    376  4b58		       8e		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3
    377  4b59		       8e		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_0
    378  4b5a		       8e		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_1
    379  4b5b		       8e		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_2
    380  4b5c		       8e		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_3
    381  4b5d		       8f		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_0
    382  4b5e		       8f		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_1
    383  4b5f		       8f		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_2
    384  4b60		       8f		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_3
    385  4b61		       8f		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_0
    386  4b62		       8f		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_1
    387  4b63		       8f		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_2
    388  4b64		       8f		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_3
    389  4b65		       8f		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_0
    390  4b66		       8f		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_1
    391  4b67		       8f		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_2
    392  4b68		       90		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_3
    393  4b69		       97		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_0
    394  4b6a		       97		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_1
    395  4b6b		       97		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_2
    396  4b6c		       97		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_3
    397  4b6d		       94		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0
    398  4b6e		       94		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1
    399  4b6f		       94		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2
    400  4b70		       94		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3
    401  4b71		       90		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_0
    402  4b72		       90		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_1
    403  4b73		       90		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_2
    404  4b74		       90		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_3
    405  4b75		       90		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_0
    406  4b76		       90		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_1
    407  4b77		       90		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_2
    408  4b78		       90		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_3
    409  4b79		       90		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0
    410  4b7a		       90		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1
    411  4b7b		       90		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2
    412  4b7c		       91		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3
    413  4b7d		       95		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_0
    414  4b7e		       95		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_1
    415  4b7f		       95		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_2
    416  4b80		       95		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_3
    417  4b81		       95		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_0
    418  4b82		       95		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_1
    419  4b83		       95		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_2
    420  4b84		       95		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_3
    421  4b85		       95		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_0
    422  4b86		       96		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_1
    423  4b87		       96		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_2
    424  4b88		       96		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_3
    425  4b89		       96		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_0
    426  4b8a		       96		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_1
    427  4b8b		       96		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_2
    428  4b8c		       96		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_3
    429  4b8d		       96		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_0
    430  4b8e		       96		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_1
    431  4b8f		       96		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_2
    432  4b90		       96		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_3
    433  4b91		       94		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0
    434  4b92		       94		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1
    435  4b93		       94		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2
    436  4b94		       94		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3
    437  4b95
    438  4b95							; piece index equates...
    439  4b95		       00 00	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_0 =	0
    440  4b95		       00 01	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_1 =	1
    441  4b95		       00 02	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_2 =	2
    442  4b95		       00 03	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_3 =	3
    443  4b95		       00 04	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_0 =	4
    444  4b95		       00 05	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_1 =	5
    445  4b95		       00 06	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_2 =	6
    446  4b95		       00 07	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_3 =	7
    447  4b95		       00 08	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0 =	8
    448  4b95		       00 09	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_1 =	9
    449  4b95		       00 0a	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_2 =	10
    450  4b95		       00 0b	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_3 =	11
    451  4b95		       00 0c	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0 =	12
    452  4b95		       00 0d	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_1 =	13
    453  4b95		       00 0e	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_2 =	14
    454  4b95		       00 0f	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_3 =	15
    455  4b95		       00 10	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_0 =	16
    456  4b95		       00 11	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_1 =	17
    457  4b95		       00 12	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_2 =	18
    458  4b95		       00 13	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_3 =	19
    459  4b95		       00 14	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0 =	20
    460  4b95		       00 15	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_1 =	21
    461  4b95		       00 16	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_2 =	22
    462  4b95		       00 17	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_3 =	23
    463  4b95		       00 18	   INDEX_WHITE_KING_on_WHITE_SQUARE_0 =	24
    464  4b95		       00 19	   INDEX_WHITE_KING_on_WHITE_SQUARE_1 =	25
    465  4b95		       00 1a	   INDEX_WHITE_KING_on_WHITE_SQUARE_2 =	26
    466  4b95		       00 1b	   INDEX_WHITE_KING_on_WHITE_SQUARE_3 =	27
    467  4b95		       00 1c	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_0 =	28
    468  4b95		       00 1d	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_1 =	29
    469  4b95		       00 1e	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_2 =	30
    470  4b95		       00 1f	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_3 =	31
    471  4b95		       00 20	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0 =	32
    472  4b95		       00 21	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_1 =	33
    473  4b95		       00 22	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_2 =	34
    474  4b95		       00 23	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_3 =	35
    475  4b95		       00 24	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_0 =	36
    476  4b95		       00 25	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_1 =	37
    477  4b95		       00 26	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_2 =	38
    478  4b95		       00 27	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_3 =	39
    479  4b95		       00 28	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_0 =	40
    480  4b95		       00 29	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_1 =	41
    481  4b95		       00 2a	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_2 =	42
    482  4b95		       00 2b	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_3 =	43
    483  4b95		       00 2c	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_0 =	44
    484  4b95		       00 2d	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_1 =	45
    485  4b95		       00 2e	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_2 =	46
    486  4b95		       00 2f	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_3 =	47
    487  4b95		       00 30	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_0 =	48
    488  4b95		       00 31	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_1 =	49
    489  4b95		       00 32	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_2 =	50
    490  4b95		       00 33	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_3 =	51
    491  4b95		       00 34	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_0 =	52
    492  4b95		       00 35	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_1 =	53
    493  4b95		       00 36	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_2 =	54
    494  4b95		       00 37	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_3 =	55
    495  4b95		       00 38	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_0 =	56
    496  4b95		       00 39	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_1 =	57
    497  4b95		       00 3a	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_2 =	58
    498  4b95		       00 3b	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_3 =	59
    499  4b95		       00 3c	   INDEX_WHITE_KING_on_BLACK_SQUARE_0 =	60
    500  4b95		       00 3d	   INDEX_WHITE_KING_on_BLACK_SQUARE_1 =	61
    501  4b95		       00 3e	   INDEX_WHITE_KING_on_BLACK_SQUARE_2 =	62
    502  4b95		       00 3f	   INDEX_WHITE_KING_on_BLACK_SQUARE_3 =	63
    503  4b95		       00 40	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_0 =	64
    504  4b95		       00 41	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_1 =	65
    505  4b95		       00 42	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_2 =	66
    506  4b95		       00 43	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_3 =	67
    507  4b95		       00 44	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_0 =	68
    508  4b95		       00 45	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_1 =	69
    509  4b95		       00 46	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_2 =	70
    510  4b95		       00 47	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_3 =	71
    511  4b95		       00 48	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_0 =	72
    512  4b95		       00 49	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_1 =	73
    513  4b95		       00 4a	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_2 =	74
    514  4b95		       00 4b	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_3 =	75
    515  4b95		       00 4c	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_0 =	76
    516  4b95		       00 4d	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_1 =	77
    517  4b95		       00 4e	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_2 =	78
    518  4b95		       00 4f	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_3 =	79
    519  4b95		       00 50	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0 =	80
    520  4b95		       00 51	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_1 =	81
    521  4b95		       00 52	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_2 =	82
    522  4b95		       00 53	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_3 =	83
    523  4b95		       00 54	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0 =	84
    524  4b95		       00 55	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_1 =	85
    525  4b95		       00 56	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_2 =	86
    526  4b95		       00 57	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_3 =	87
    527  4b95		       00 58	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_0 =	88
    528  4b95		       00 59	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_1 =	89
    529  4b95		       00 5a	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_2 =	90
    530  4b95		       00 5b	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_3 =	91
    531  4b95		       00 5c	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0 =	92
    532  4b95		       00 5d	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_1 =	93
    533  4b95		       00 5e	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_2 =	94
    534  4b95		       00 5f	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_3 =	95
    535  4b95		       00 60	   INDEX_BLACK_KING_on_WHITE_SQUARE_0 =	96
    536  4b95		       00 61	   INDEX_BLACK_KING_on_WHITE_SQUARE_1 =	97
    537  4b95		       00 62	   INDEX_BLACK_KING_on_WHITE_SQUARE_2 =	98
    538  4b95		       00 63	   INDEX_BLACK_KING_on_WHITE_SQUARE_3 =	99
    539  4b95		       00 64	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_0 =	100
    540  4b95		       00 65	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_1 =	101
    541  4b95		       00 66	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_2 =	102
    542  4b95		       00 67	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_3 =	103
    543  4b95		       00 68	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0 =	104
    544  4b95		       00 69	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_1 =	105
    545  4b95		       00 6a	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_2 =	106
    546  4b95		       00 6b	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_3 =	107
    547  4b95		       00 6c	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_0 =	108
    548  4b95		       00 6d	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_1 =	109
    549  4b95		       00 6e	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_2 =	110
    550  4b95		       00 6f	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_3 =	111
    551  4b95		       00 70	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_0 =	112
    552  4b95		       00 71	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_1 =	113
    553  4b95		       00 72	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_2 =	114
    554  4b95		       00 73	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_3 =	115
    555  4b95		       00 74	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_0 =	116
    556  4b95		       00 75	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_1 =	117
    557  4b95		       00 76	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_2 =	118
    558  4b95		       00 77	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_3 =	119
    559  4b95		       00 78	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_0 =	120
    560  4b95		       00 79	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_1 =	121
    561  4b95		       00 7a	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_2 =	122
    562  4b95		       00 7b	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_3 =	123
    563  4b95		       00 7c	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_0 =	124
    564  4b95		       00 7d	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_1 =	125
    565  4b95		       00 7e	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_2 =	126
    566  4b95		       00 7f	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_3 =	127
    567  4b95		       00 80	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_0 =	128
    568  4b95		       00 81	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_1 =	129
    569  4b95		       00 82	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_2 =	130
    570  4b95		       00 83	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_3 =	131
    571  4b95		       00 84	   INDEX_BLACK_KING_on_BLACK_SQUARE_0 =	132
    572  4b95		       00 85	   INDEX_BLACK_KING_on_BLACK_SQUARE_1 =	133
    573  4b95		       00 86	   INDEX_BLACK_KING_on_BLACK_SQUARE_2 =	134
    574  4b95		       00 87	   INDEX_BLACK_KING_on_BLACK_SQUARE_3 =	135
    575  4b95		       00 88	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_0 =	136
    576  4b95		       00 89	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_1 =	137
    577  4b95		       00 8a	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_2 =	138
    578  4b95		       00 8b	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_3 =	139
    579  4b95		       00 8c	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_0 =	140
    580  4b95		       00 8d	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_1 =	141
    581  4b95		       00 8e	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_2 =	142
    582  4b95		       00 8f	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_3 =	143
------- FILE BANK_GENERIC@2#1.asm
    477  4b95
    478  4b95
    479  4b95							;---------------------------------------------------------------------------------------------------
    480  4b95
      0  4b95					      CHECK_BANK_SIZE	"BANK_GENERIC@2#1"
      1  4b95		       03 95	   .TEMP      =	* - _BANK_START
 BANK_GENERIC@2#1 (1K) SIZE =  $395 , FREE= $6b
      2  4b95					      ECHO	"BANK_GENERIC@2#1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4b95				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4b95				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC@2#1", " size=", * - ORIGIN
      5  4b95				  -	      ERR
      6  4b95					      ENDIF
    482  4b95
    483  4b95							;---------------------------------------------------------------------------------------------------
    484  4b95							;EOF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@2#2.asm LEVEL 2 PASS 4
      0  4b95					      include	"BANK_GENERIC@2#2.asm"
      1  4b95
      0  4b95					      SLOT	2
      1  4b95				  -	      IF	(2 < 0) || (2 > 3)
      2  4b95				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4b95				  -	      ERR
      4  4b95					      ENDIF
      5  4b95				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4b95				   _BANK_SLOT SET	2 * 64
      0  4b95					      ROMBANK	GENERIC_BANK@2#2
      1  4c7d ????				      SEG	GENERIC_BANK@2#2
      2  4c00					      ORG	_ORIGIN
      3  4c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  4c00				   _BANK_START SET	*
      5  4c00				   GENERIC_BANK@2#2_START SET	*
      6  4c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4c00				   GENERIC_BANK@2#2 SET	_BANK_SLOT + _CURRENT_BANK
      8  4c00				   _ORIGIN    SET	_ORIGIN + 1024
      4  4c00
      5  4c00
      6  4c00							;---------------------------------------------------------------------------------------------------
      7  4c00
      8  4c00
      0  4c00					      DEF	moveCursor
      1  4c00				   SLOT_moveCursor SET	_BANK_SLOT
      2  4c00				   BANK_moveCursor SET	SLOT_moveCursor + _CURRENT_BANK
      3  4c00				   moveCursor
      4  4c00				   TEMPORARY_VAR SET	Overlay
      5  4c00				   TEMPORARY_OFFSET SET	0
      6  4c00				   VAR_BOUNDARY_moveCursor SET	TEMPORARY_OFFSET
      7  4c00				   FUNCTION_NAME SET	moveCursor
     10  4c00					      SUBROUTINE
     11  4c00
      0  4c00					      REFER	aiSelectStartSquare
      1  4c00					      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  4c00				   TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  4c00					      ENDIF
      0  4c00					      REFER	aiSelectDestinationSquare
      1  4c00				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  4c00				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  4c00					      ENDIF
     14  4c00
      0  4c00					      VAR	__newCursor, 1
      1  4c00		       00 a9	   __newCursor =	TEMPORARY_VAR
      2  4c00				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4c00
      4  4c00				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4c00				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4c00				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4c00					      ENDIF
      8  4c00				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4c00				  -	      ECHO	"Temporary Variable", __newCursor, "overflow!"
     10  4c00				  -	      ERR
     11  4c00					      ENDIF
     12  4c00					      LIST	ON
     16  4c00
      0  4c00					      VEND	moveCursor
      1  4c00				  -	      IFNCONST	moveCursor
      2  4c00				  -	      ECHO	"Incorrect VEND label", moveCursor
      3  4c00				  -	      ERR
      4  4c00					      ENDIF
      5  4c00		       00 aa	   VAREND_moveCursor =	TEMPORARY_VAR
     18  4c00
     19  4c00							; Part (a) move cursor around the board waiting for joystick press
     20  4c00
     21  4c00		       a2 00		      ldx	#0	; delay
     22  4c02
     23  4c02		       ad 80 02 	      lda	SWCHA
     24  4c05		       4a		      lsr
     25  4c06		       4a		      lsr
     26  4c07		       4a		      lsr
     27  4c08		       4a		      lsr
     28  4c09		       a8		      tay
     29  4c0a
     30  4c0a		       c9 0f		      cmp	#15
     31  4c0c		       f0 1e		      beq	.cursor	; nothing pressed - skip delays
     32  4c0e
     33  4c0e		       c6 89		      dec	mdelay
     34  4c10		       10 1f		      bpl	.delaym
     35  4c12
     36  4c12		       18		      clc
     37  4c13		       a5 88		      lda	cursorX12
     38  4c15		       79 6d f8 	      adc	JoyMoveCursor,y
     39  4c18		       85 a9		      sta	__newCursor
     40  4c1a		       a8		      tay
     41  4c1b
     42  4c1b		       a9 d1		      lda	#RAMBANK_BOARD
     43  4c1d		       85 3e		      sta	SET_BANK_RAM	;@3
     44  4c1f		       b9 15 fc 	      lda	ValidSquare,y
     45  4c22		       c9 ff		      cmp	#-1
     46  4c24		       f0 04		      beq	.invalid
     47  4c26		       a5 a9		      lda	__newCursor
     48  4c28		       85 88		      sta	cursorX12
     49  4c2a				   .invalid
     50  4c2a
     51  4c2a		       a2 10		      ldx	#CURSOR_MOVE_SPEED
     52  4c2c		       86 89	   .cursor    stx	mdelay
     53  4c2e		       20 32 f8 	      jsr	setCursorPriority
     54  4c31		       60	   .delaym    rts
     55  4c32
     56  4c32
     57  4c32							;---------------------------------------------------------------------------------------------------
     58  4c32
      0  4c32					      DEF	setCursorPriority
      1  4c32				   SLOT_setCursorPriority SET	_BANK_SLOT
      2  4c32				   BANK_setCursorPriority SET	SLOT_setCursorPriority + _CURRENT_BANK
      3  4c32				   setCursorPriority
      4  4c32				   TEMPORARY_VAR SET	Overlay
      5  4c32				   TEMPORARY_OFFSET SET	0
      6  4c32				   VAR_BOUNDARY_setCursorPriority SET	TEMPORARY_OFFSET
      7  4c32				   FUNCTION_NAME SET	setCursorPriority
     60  4c32					      SUBROUTINE
     61  4c32
      0  4c32					      REFER	moveCursor
      1  4c32					      IF	VAREND_moveCursor > TEMPORARY_VAR
      2  4c32				   TEMPORARY_VAR SET	VAREND_moveCursor
      3  4c32					      ENDIF
      0  4c32					      VEND	setCursorPriority
      1  4c32				  -	      IFNCONST	setCursorPriority
      2  4c32				  -	      ECHO	"Incorrect VEND label", setCursorPriority
      3  4c32				  -	      ERR
      4  4c32					      ENDIF
      5  4c32		       00 aa	   VAREND_setCursorPriority =	TEMPORARY_VAR
     64  4c32
     65  4c32		       98		      tya
     66  4c33		       48		      pha
     67  4c34
     68  4c34		       a2 04		      ldx	#%100
     69  4c36
     70  4c36		       a4 88		      ldy	cursorX12
     71  4c38		       30 0b		      bmi	.under
     72  4c3a
     73  4c3a		       a9 d1		      lda	#RAMBANK_BOARD
     74  4c3c		       85 3e		      sta	SET_BANK_RAM	;@3
     75  4c3e		       b9 79 fc 	      lda	Board,y
     76  4c41		       d0 02		      bne	.under
     77  4c43		       a2 00		      ldx	#0
     78  4c45		       86 4a	   .under     stx	CTRLPF	; UNDER
     79  4c47
     80  4c47		       68		      pla
     81  4c48		       a8		      tay
     82  4c49		       60		      rts
     83  4c4a
     84  4c4a
     85  4c4a							;---------------------------------------------------------------------------------------------------
     86  4c4a
      0  4c4a					      DEF	setCursorColours
      1  4c4a				   SLOT_setCursorColours SET	_BANK_SLOT
      2  4c4a				   BANK_setCursorColours SET	SLOT_setCursorColours + _CURRENT_BANK
      3  4c4a				   setCursorColours
      4  4c4a				   TEMPORARY_VAR SET	Overlay
      5  4c4a				   TEMPORARY_OFFSET SET	0
      6  4c4a				   VAR_BOUNDARY_setCursorColours SET	TEMPORARY_OFFSET
      7  4c4a				   FUNCTION_NAME SET	setCursorColours
     88  4c4a					      SUBROUTINE
     89  4c4a
      0  4c4a					      REFER	aiSelectStartSquare
      1  4c4a					      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  4c4a				   TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  4c4a					      ENDIF
      0  4c4a					      REFER	aiDrawMoves
      1  4c4a				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  4c4a				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  4c4a					      ENDIF
      0  4c4a					      REFER	aiUnDrawTargetSquares
      1  4c4a				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  4c4a				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  4c4a					      ENDIF
      0  4c4a					      REFER	aiShowMoveCaptures
      1  4c4a				  -	      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  4c4a				  -TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  4c4a					      ENDIF
      0  4c4a					      REFER	aiSlowFlash
      1  4c4a				  -	      IF	VAREND_aiSlowFlash > TEMPORARY_VAR
      2  4c4a				  -TEMPORARY_VAR SET	VAREND_aiSlowFlash
      3  4c4a					      ENDIF
      0  4c4a					      REFER	aiSelectDestinationSquare
      1  4c4a				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  4c4a				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  4c4a					      ENDIF
      0  4c4a					      VEND	setCursorColours
      1  4c4a				  -	      IFNCONST	setCursorColours
      2  4c4a				  -	      ECHO	"Incorrect VEND label", setCursorColours
      3  4c4a				  -	      ERR
      4  4c4a					      ENDIF
      5  4c4a		       00 a9	   VAREND_setCursorColours =	TEMPORARY_VAR
     97  4c4a
     98  4c4a							; pass y=-1 if move is NOT in the movelist
     99  4c4a							; preserve y
    100  4c4a
    101  4c4a		       a9 42		      lda	#$42
    102  4c4c
    103  4c4c		       c0 ff		      cpy	#-1
    104  4c4e		       f0 0a		      beq	.writeCursorCol	; NOT in the movelist
    105  4c50
    106  4c50		       a5 8a		      lda	ccur
    107  4c52		       4a		      lsr
    108  4c53		       4a		      lsr
    109  4c54		       4a		      lsr
    110  4c55		       29 06		      and	#6
    111  4c57		       18		      clc
    112  4c58		       69 d2		      adc	#$D2	;COLOUR_LINE_1
    113  4c5a
    114  4c5a		       85 46	   .writeCursorCol sta	COLUP0
    115  4c5c		       60		      rts
    116  4c5d
    117  4c5d
    118  4c5d							;---------------------------------------------------------------------------------------------------
    119  4c5d
    120  4c5d							;	    RLDU RLD  RL U RL	R DU R D  R  U R     LDU  LD   L U  L	  DU   D     U
    121  4c5d							;	    0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    122  4c5d
      0  4c5d					      ALLOCATE	JoyCombined, 16
      0  4c5d					      OPTIONAL_PAGEBREAK	"Table", 16
     12  4c5d					      LIST	ON
      0  4c5d					      DEF	JoyCombined
      1  4c5d				   SLOT_JoyCombined SET	_BANK_SLOT
      2  4c5d				   BANK_JoyCombined SET	SLOT_JoyCombined + _CURRENT_BANK
      3  4c5d				   JoyCombined
      4  4c5d				   TEMPORARY_VAR SET	Overlay
      5  4c5d				   TEMPORARY_OFFSET SET	0
      6  4c5d				   VAR_BOUNDARY_JoyCombined SET	TEMPORARY_OFFSET
      7  4c5d				   FUNCTION_NAME SET	JoyCombined
    124  4c5d		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, -1, 0
    125  4c6d
      0  4c6d					      ALLOCATE	JoyMoveCursor, 16
      0  4c6d					      OPTIONAL_PAGEBREAK	"Table", 16
     12  4c6d					      LIST	ON
      0  4c6d					      DEF	JoyMoveCursor
      1  4c6d				   SLOT_JoyMoveCursor SET	_BANK_SLOT
      2  4c6d				   BANK_JoyMoveCursor SET	SLOT_JoyMoveCursor + _CURRENT_BANK
      3  4c6d				   JoyMoveCursor
      4  4c6d				   TEMPORARY_VAR SET	Overlay
      5  4c6d				   TEMPORARY_OFFSET SET	0
      6  4c6d				   VAR_BOUNDARY_JoyMoveCursor SET	TEMPORARY_OFFSET
      7  4c6d				   FUNCTION_NAME SET	JoyMoveCursor
    127  4c6d		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, -9, 11, 1, 0, -11, 9, -1, 0, -10, 10, 0
    128  4c7d
    129  4c7d
    130  4c7d							;---------------------------------------------------------------------------------------------------
    131  4c7d
      0  4c7d					      CHECK_BANK_SIZE	"BANK_GENERIC@2#2"
      1  4c7d		       00 7d	   .TEMP      =	* - _BANK_START
 BANK_GENERIC@2#2 (1K) SIZE =  $7d , FREE= $383
      2  4c7d					      ECHO	"BANK_GENERIC@2#2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4c7d				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4c7d				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC@2#2", " size=", * - ORIGIN
      5  4c7d				  -	      ERR
      6  4c7d					      ENDIF
    133  4c7d
    134  4c7d							;---------------------------------------------------------------------------------------------------
    135  4c7d							;EOF
------- FILE ./chess.asm
------- FILE GFX1.asm LEVEL 2 PASS 4
      0  4c7d					      include	"GFX1.asm"
      0  4c7d					      SLOT	2
      1  4c7d				  -	      IF	(2 < 0) || (2 > 3)
      2  4c7d				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4c7d				  -	      ERR
      4  4c7d					      ENDIF
      5  4c7d				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4c7d				   _BANK_SLOT SET	2 * 64
      0  4c7d					      ROMBANK	GFX1
      1  53d8 ????				      SEG	GFX1
      2  5000					      ORG	_ORIGIN
      3  5000					      RORG	_BANK_ADDRESS_ORIGIN
      4  5000				   _BANK_START SET	*
      5  5000				   GFX1_START SET	*
      6  5000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5000				   GFX1       SET	_BANK_SLOT + _CURRENT_BANK
      8  5000				   _ORIGIN    SET	_ORIGIN + 1024
      3  5000
      4  5000
      5  5000							;---------------------------------------------------------------------------------------------------
      6  5000
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5000					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  5000					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_0", 72
     12  5000					      LIST	ON
      0  5000					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_0
      1  5000				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5000				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5000				   BLACK_PROMOTE_on_BLACK_SQUARE_0
      4  5000				   TEMPORARY_VAR SET	Overlay
      5  5000				   TEMPORARY_OFFSET SET	0
      6  5000				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5000				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_0
      3  5000		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5048					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  5048					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_1", 72
     12  5048					      LIST	ON
      0  5048					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_1
      1  5048				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5048				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5048				   BLACK_PROMOTE_on_BLACK_SQUARE_1
      4  5048				   TEMPORARY_VAR SET	Overlay
      5  5048				   TEMPORARY_OFFSET SET	0
      6  5048				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5048				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_1
      3  5048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5060		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5090					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  5090					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_2", 72
     12  5090					      LIST	ON
      0  5090					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_2
      1  5090				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5090				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5090				   BLACK_PROMOTE_on_BLACK_SQUARE_2
      4  5090				   TEMPORARY_VAR SET	Overlay
      5  5090				   TEMPORARY_OFFSET SET	0
      6  5090				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5090				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_2
      3  5090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  50a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  50c0		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  50d8					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  50d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_3", 72
     12  5100					      LIST	ON
      0  5100					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_3
      1  5100				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5100				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5100				   BLACK_PROMOTE_on_BLACK_SQUARE_3
      4  5100				   TEMPORARY_VAR SET	Overlay
      5  5100				   TEMPORARY_OFFSET SET	0
      6  5100				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5100				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_3
      3  5100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5130		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5148					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  5148					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_0", 72
     12  5148					      LIST	ON
      0  5148					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_0
      1  5148				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5148				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5148				   BLACK_PROMOTE_on_WHITE_SQUARE_0
      4  5148				   TEMPORARY_VAR SET	Overlay
      5  5148				   TEMPORARY_OFFSET SET	0
      6  5148				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5148				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_0
      3  5148		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  5160		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5190					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  5190					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_1", 72
     12  5190					      LIST	ON
      0  5190					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_1
      1  5190				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5190				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5190				   BLACK_PROMOTE_on_WHITE_SQUARE_1
      4  5190				   TEMPORARY_VAR SET	Overlay
      5  5190				   TEMPORARY_OFFSET SET	0
      6  5190				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5190				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_1
      3  5190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  51a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  51c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  51d8					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  51d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_2", 72
     12  5200					      LIST	ON
      0  5200					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_2
      1  5200				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5200				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5200				   BLACK_PROMOTE_on_WHITE_SQUARE_2
      4  5200				   TEMPORARY_VAR SET	Overlay
      5  5200				   TEMPORARY_OFFSET SET	0
      6  5200				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5200				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_2
      3  5200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5218		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  5230		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5248					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  5248					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_3", 72
     12  5248					      LIST	ON
      0  5248					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_3
      1  5248				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5248				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5248				   BLACK_PROMOTE_on_WHITE_SQUARE_3
      4  5248				   TEMPORARY_VAR SET	Overlay
      5  5248				   TEMPORARY_OFFSET SET	0
      6  5248				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5248				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_3
      3  5248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5278		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE GFX1.asm
     15  5290
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5290					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm"
      0  5290					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_0", 72
     12  5290					      LIST	ON
      0  5290					      DEF	WHITE_MARKER_on_BLACK_SQUARE_0
      1  5290				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5290				   BANK_WHITE_MARKER_on_BLACK_SQUARE_0 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5290				   WHITE_MARKER_on_BLACK_SQUARE_0
      4  5290				   TEMPORARY_VAR SET	Overlay
      5  5290				   TEMPORARY_OFFSET SET	0
      6  5290				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5290				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_0
      3  5290		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  52a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  52c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  52d8					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm"
      0  52d8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_1", 72
     12  5300					      LIST	ON
      0  5300					      DEF	WHITE_MARKER_on_BLACK_SQUARE_1
      1  5300				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5300				   BANK_WHITE_MARKER_on_BLACK_SQUARE_1 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5300				   WHITE_MARKER_on_BLACK_SQUARE_1
      4  5300				   TEMPORARY_VAR SET	Overlay
      5  5300				   TEMPORARY_OFFSET SET	0
      6  5300				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5300				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_1
      3  5300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5318		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5348					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm"
      0  5348					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_2", 72
     12  5348					      LIST	ON
      0  5348					      DEF	WHITE_MARKER_on_BLACK_SQUARE_2
      1  5348				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5348				   BANK_WHITE_MARKER_on_BLACK_SQUARE_2 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5348				   WHITE_MARKER_on_BLACK_SQUARE_2
      4  5348				   TEMPORARY_VAR SET	Overlay
      5  5348				   TEMPORARY_OFFSET SET	0
      6  5348				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5348				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_2
      3  5348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5378		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5390					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm"
      0  5390					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_3", 72
     12  5390					      LIST	ON
      0  5390					      DEF	WHITE_MARKER_on_BLACK_SQUARE_3
      1  5390				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5390				   BANK_WHITE_MARKER_on_BLACK_SQUARE_3 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5390				   WHITE_MARKER_on_BLACK_SQUARE_3
      4  5390				   TEMPORARY_VAR SET	Overlay
      5  5390				   TEMPORARY_OFFSET SET	0
      6  5390				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5390				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_3
      3  5390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  53a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  53c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
     20  53d8
     21  53d8
     22  53d8							;---------------------------------------------------------------------------------------------------
     23  53d8
      0  53d8					      CHECK_BANK_SIZE	"BANK_GFX1"
      1  53d8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX1 (1K) SIZE =  $3d8 , FREE= $28
      2  53d8					      ECHO	"BANK_GFX1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  53d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  53d8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX1", " size=", * - ORIGIN
      5  53d8				  -	      ERR
      6  53d8					      ENDIF
     25  53d8
     26  53d8							;---------------------------------------------------------------------------------------------------
     27  53d8							;EOF
------- FILE ./chess.asm
------- FILE GFX2.asm LEVEL 2 PASS 4
      0  53d8					      include	"GFX2.asm"
      0  53d8					      SLOT	2
      1  53d8				  -	      IF	(2 < 0) || (2 > 3)
      2  53d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  53d8				  -	      ERR
      4  53d8					      ENDIF
      5  53d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  53d8				   _BANK_SLOT SET	2 * 64
      0  53d8					      ROMBANK	GFX2
      1  57d8 ????				      SEG	GFX2
      2  5400					      ORG	_ORIGIN
      3  5400					      RORG	_BANK_ADDRESS_ORIGIN
      4  5400				   _BANK_START SET	*
      5  5400				   GFX2_START SET	*
      6  5400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5400				   GFX2       SET	_BANK_SLOT + _CURRENT_BANK
      8  5400				   _ORIGIN    SET	_ORIGIN + 1024
      3  5400
      4  5400							;---------------------------------------------------------------------------------------------------
      5  5400
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5400					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm"
      0  5400					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_0", 72
     12  5400					      LIST	ON
      0  5400					      DEF	WHITE_MARKER_on_WHITE_SQUARE_0
      1  5400				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5400				   BANK_WHITE_MARKER_on_WHITE_SQUARE_0 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5400				   WHITE_MARKER_on_WHITE_SQUARE_0
      4  5400				   TEMPORARY_VAR SET	Overlay
      5  5400				   TEMPORARY_OFFSET SET	0
      6  5400				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5400				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_0
      3  5400		       00 40 e0 e0*	      .byte.b	$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00	;PF0
      4  5418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5448					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm"
      0  5448					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_1", 72
     12  5448					      LIST	ON
      0  5448					      DEF	WHITE_MARKER_on_WHITE_SQUARE_1
      1  5448				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5448				   BANK_WHITE_MARKER_on_WHITE_SQUARE_1 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5448				   WHITE_MARKER_on_WHITE_SQUARE_1
      4  5448				   TEMPORARY_VAR SET	Overlay
      5  5448				   TEMPORARY_OFFSET SET	0
      6  5448				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5448				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_1
      3  5448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5460		       00 10 38 38*	      .byte.b	$00,$10,$38,$38,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00	;PF1
      5  5478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5490					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm"
      0  5490					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_2", 72
     12  5490					      LIST	ON
      0  5490					      DEF	WHITE_MARKER_on_WHITE_SQUARE_2
      1  5490				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5490				   BANK_WHITE_MARKER_on_WHITE_SQUARE_2 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5490				   WHITE_MARKER_on_WHITE_SQUARE_2
      4  5490				   TEMPORARY_VAR SET	Overlay
      5  5490				   TEMPORARY_OFFSET SET	0
      6  5490				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5490				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_2
      3  5490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  54a8		       00 00 01 01*	      .byte.b	$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00	;PF1
      5  54c0		       00 01 03 03*	      .byte.b	$00,$01,$03,$03,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00	;PF2
------- FILE GFX2.asm
      9  54d8
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  54d8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm"
      0  54d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_0", 72
     12  5500					      LIST	ON
      0  5500					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_0
      1  5500				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5500				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5500				   BLACK_BISHOP_on_BLACK_SQUARE_0
      4  5500				   TEMPORARY_VAR SET	Overlay
      5  5500				   TEMPORARY_OFFSET SET	0
      6  5500				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5500				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_0
      3  5500		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$40,$00	;PF0
      4  5518		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5530		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5548					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm"
      0  5548					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_1", 72
     12  5548					      LIST	ON
      0  5548					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_1
      1  5548				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5548				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5548				   BLACK_BISHOP_on_BLACK_SQUARE_1
      4  5548				   TEMPORARY_VAR SET	Overlay
      5  5548				   TEMPORARY_OFFSET SET	0
      6  5548				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5548				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_1
      3  5548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5560		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$00,$00,$00,$10,$00	;PF1
      5  5578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5590					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm"
      0  5590					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_2", 72
     12  5590					      LIST	ON
      0  5590					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_2
      1  5590				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5590				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5590				   BLACK_BISHOP_on_BLACK_SQUARE_2
      4  5590				   TEMPORARY_VAR SET	Overlay
      5  5590				   TEMPORARY_OFFSET SET	0
      6  5590				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5590				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_2
      3  5590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  55a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  55c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$00,$00,$00,$01,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  55d8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm"
      0  55d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_3", 72
     12  5600					      LIST	ON
      0  5600					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_3
      1  5600				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5600				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5600				   BLACK_BISHOP_on_BLACK_SQUARE_3
      4  5600				   TEMPORARY_VAR SET	Overlay
      5  5600				   TEMPORARY_OFFSET SET	0
      6  5600				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5600				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_3
      3  5600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5630		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$00,$00,$00,$20,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5648					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm"
      0  5648					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_0", 72
     12  5648					      LIST	ON
      0  5648					      DEF	BLACK_ROOK_on_BLACK_SQUARE_0
      1  5648				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5648				   BANK_BLACK_ROOK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5648				   BLACK_ROOK_on_BLACK_SQUARE_0
      4  5648				   TEMPORARY_VAR SET	Overlay
      5  5648				   TEMPORARY_OFFSET SET	0
      6  5648				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5648				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_0
      3  5648		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$a0,$00,$00	;PF0
      4  5660		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5678		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5690					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm"
      0  5690					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_1", 72
     12  5690					      LIST	ON
      0  5690					      DEF	BLACK_ROOK_on_BLACK_SQUARE_1
      1  5690				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5690				   BANK_BLACK_ROOK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5690				   BLACK_ROOK_on_BLACK_SQUARE_1
      4  5690				   TEMPORARY_VAR SET	Overlay
      5  5690				   TEMPORARY_OFFSET SET	0
      6  5690				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5690				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_1
      3  5690		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  56a8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$28,$00,$00	;PF1
      5  56c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  56d8					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm"
      0  56d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_2", 72
     12  5700					      LIST	ON
      0  5700					      DEF	BLACK_ROOK_on_BLACK_SQUARE_2
      1  5700				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5700				   BANK_BLACK_ROOK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5700				   BLACK_ROOK_on_BLACK_SQUARE_2
      4  5700				   TEMPORARY_VAR SET	Overlay
      5  5700				   TEMPORARY_OFFSET SET	0
      6  5700				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5700				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_2
      3  5700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5718		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF1
      5  5730		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$02,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5748					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm"
      0  5748					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_3", 72
     12  5748					      LIST	ON
      0  5748					      DEF	BLACK_ROOK_on_BLACK_SQUARE_3
      1  5748				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5748				   BANK_BLACK_ROOK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5748				   BLACK_ROOK_on_BLACK_SQUARE_3
      4  5748				   TEMPORARY_VAR SET	Overlay
      5  5748				   TEMPORARY_OFFSET SET	0
      6  5748				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5748				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_3
      3  5748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5760		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5778		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00	;PF2
------- FILE GFX2.asm
     18  5790
     19  5790
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5790					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm"
      0  5790					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_0", 72
     12  5790					      LIST	ON
      0  5790					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_0
      1  5790				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5790				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5790				   BLACK_QUEEN_on_BLACK_SQUARE_0
      4  5790				   TEMPORARY_VAR SET	Overlay
      5  5790				   TEMPORARY_OFFSET SET	0
      6  5790				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5790				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_0
      3  5790		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  57a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  57c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
     21  57d8
     22  57d8
     23  57d8							;---------------------------------------------------------------------------------------------------
     24  57d8
      0  57d8					      CHECK_BANK_SIZE	"BANK_GFX2"
      1  57d8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX2 (1K) SIZE =  $3d8 , FREE= $28
      2  57d8					      ECHO	"BANK_GFX2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  57d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  57d8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX2", " size=", * - ORIGIN
      5  57d8				  -	      ERR
      6  57d8					      ENDIF
     26  57d8
     27  57d8							;---------------------------------------------------------------------------------------------------
     28  57d8							;EOF
------- FILE ./chess.asm
------- FILE GFX3.asm LEVEL 2 PASS 4
      0  57d8					      include	"GFX3.asm"
      0  57d8					      SLOT	2
      1  57d8				  -	      IF	(2 < 0) || (2 > 3)
      2  57d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  57d8				  -	      ERR
      4  57d8					      ENDIF
      5  57d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  57d8				   _BANK_SLOT SET	2 * 64
      0  57d8					      ROMBANK	GFX3
      1  5bd8 ????				      SEG	GFX3
      2  5800					      ORG	_ORIGIN
      3  5800					      RORG	_BANK_ADDRESS_ORIGIN
      4  5800				   _BANK_START SET	*
      5  5800				   GFX3_START SET	*
      6  5800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5800				   GFX3       SET	_BANK_SLOT + _CURRENT_BANK
      8  5800				   _ORIGIN    SET	_ORIGIN + 1024
      3  5800
      4  5800							;---------------------------------------------------------------------------------------------------
      5  5800
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5800					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm"
      0  5800					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_1", 72
     12  5800					      LIST	ON
      0  5800					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_1
      1  5800				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5800				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5800				   BLACK_QUEEN_on_BLACK_SQUARE_1
      4  5800				   TEMPORARY_VAR SET	Overlay
      5  5800				   TEMPORARY_OFFSET SET	0
      6  5800				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5800				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_1
      3  5800		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5818		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
      7  5848
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5848					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm"
      0  5848					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_2", 72
     12  5848					      LIST	ON
      0  5848					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_2
      1  5848				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5848				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5848				   BLACK_QUEEN_on_BLACK_SQUARE_2
      4  5848				   TEMPORARY_VAR SET	Overlay
      5  5848				   TEMPORARY_OFFSET SET	0
      6  5848				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5848				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_2
      3  5848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5860		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5878		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5890					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm"
      0  5890					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_3", 72
     12  5890					      LIST	ON
      0  5890					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_3
      1  5890				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5890				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5890				   BLACK_QUEEN_on_BLACK_SQUARE_3
      4  5890				   TEMPORARY_VAR SET	Overlay
      5  5890				   TEMPORARY_OFFSET SET	0
      6  5890				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5890				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_3
      3  5890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  58a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  58c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     10  58d8
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  58d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_0.asm"
      0  58d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_0", 72
     12  5900					      LIST	ON
      0  5900					      DEF	BLACK_KING_on_BLACK_SQUARE_0
      1  5900				   SLOT_BLACK_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5900				   BANK_BLACK_KING_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5900				   BLACK_KING_on_BLACK_SQUARE_0
      4  5900				   TEMPORARY_VAR SET	Overlay
      5  5900				   TEMPORARY_OFFSET SET	0
      6  5900				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5900				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_0
      3  5900		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5918		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5930		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5948					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_1.asm"
      0  5948					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_1", 72
     12  5948					      LIST	ON
      0  5948					      DEF	BLACK_KING_on_BLACK_SQUARE_1
      1  5948				   SLOT_BLACK_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5948				   BANK_BLACK_KING_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5948				   BLACK_KING_on_BLACK_SQUARE_1
      4  5948				   TEMPORARY_VAR SET	Overlay
      5  5948				   TEMPORARY_OFFSET SET	0
      6  5948				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5948				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_1
      3  5948		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5960		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5990					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_2.asm"
      0  5990					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_2", 72
     12  5990					      LIST	ON
      0  5990					      DEF	BLACK_KING_on_BLACK_SQUARE_2
      1  5990				   SLOT_BLACK_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5990				   BANK_BLACK_KING_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5990				   BLACK_KING_on_BLACK_SQUARE_2
      4  5990				   TEMPORARY_VAR SET	Overlay
      5  5990				   TEMPORARY_OFFSET SET	0
      6  5990				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5990				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_2
      3  5990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  59a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  59c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  59d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_3.asm"
      0  59d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_3", 72
     12  5a00					      LIST	ON
      0  5a00					      DEF	BLACK_KING_on_BLACK_SQUARE_3
      1  5a00				   SLOT_BLACK_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5a00				   BANK_BLACK_KING_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5a00				   BLACK_KING_on_BLACK_SQUARE_3
      4  5a00				   TEMPORARY_VAR SET	Overlay
      5  5a00				   TEMPORARY_OFFSET SET	0
      6  5a00				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5a00				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_3
      3  5a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5a30		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     15  5a48
     16  5a48
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5a48					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm"
      0  5a48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_3", 72
     12  5a48					      LIST	ON
      0  5a48					      DEF	WHITE_MARKER_on_WHITE_SQUARE_3
      1  5a48				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5a48				   BANK_WHITE_MARKER_on_WHITE_SQUARE_3 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5a48				   WHITE_MARKER_on_WHITE_SQUARE_3
      4  5a48				   TEMPORARY_VAR SET	Overlay
      5  5a48				   TEMPORARY_OFFSET SET	0
      6  5a48				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5a48				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_3
      3  5a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5a78		       00 20 70 70*	      .byte.b	$00,$20,$70,$70,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00	;PF2
------- FILE GFX3.asm
     18  5a90
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5a90					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
      0  5a90					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_0", 72
     12  5a90					      LIST	ON
      0  5a90					      DEF	BLACK_MARKER_on_BLACK_SQUARE_0
      1  5a90				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5a90				   BANK_BLACK_MARKER_on_BLACK_SQUARE_0 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5a90				   BLACK_MARKER_on_BLACK_SQUARE_0
      4  5a90				   TEMPORARY_VAR SET	Overlay
      5  5a90				   TEMPORARY_OFFSET SET	0
      6  5a90				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5a90				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_0
      3  5a90		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5ad8					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
      0  5ad8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_1", 72
     12  5b00					      LIST	ON
      0  5b00					      DEF	BLACK_MARKER_on_BLACK_SQUARE_1
      1  5b00				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5b00				   BANK_BLACK_MARKER_on_BLACK_SQUARE_1 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5b00				   BLACK_MARKER_on_BLACK_SQUARE_1
      4  5b00				   TEMPORARY_VAR SET	Overlay
      5  5b00				   TEMPORARY_OFFSET SET	0
      6  5b00				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5b00				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_1
      3  5b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5b18		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5b48					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
      0  5b48					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_2", 72
     12  5b48					      LIST	ON
      0  5b48					      DEF	BLACK_MARKER_on_BLACK_SQUARE_2
      1  5b48				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5b48				   BANK_BLACK_MARKER_on_BLACK_SQUARE_2 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5b48				   BLACK_MARKER_on_BLACK_SQUARE_2
      4  5b48				   TEMPORARY_VAR SET	Overlay
      5  5b48				   TEMPORARY_OFFSET SET	0
      6  5b48				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5b48				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_2
      3  5b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5b60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5b78		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5b90					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
      0  5b90					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_3", 72
     12  5b90					      LIST	ON
      0  5b90					      DEF	BLACK_MARKER_on_BLACK_SQUARE_3
      1  5b90				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5b90				   BANK_BLACK_MARKER_on_BLACK_SQUARE_3 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5b90				   BLACK_MARKER_on_BLACK_SQUARE_3
      4  5b90				   TEMPORARY_VAR SET	Overlay
      5  5b90				   TEMPORARY_OFFSET SET	0
      6  5b90				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5b90				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_3
      3  5b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5bc0		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     23  5bd8
     24  5bd8							;---------------------------------------------------------------------------------------------------
     25  5bd8
      0  5bd8					      CHECK_BANK_SIZE	"BANK_GFX3"
      1  5bd8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX3 (1K) SIZE =  $3d8 , FREE= $28
      2  5bd8					      ECHO	"BANK_GFX3", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5bd8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX3", " size=", * - ORIGIN
      5  5bd8				  -	      ERR
      6  5bd8					      ENDIF
     27  5bd8
     28  5bd8							;---------------------------------------------------------------------------------------------------
     29  5bd8							;EOF
------- FILE ./chess.asm
------- FILE GFX4.asm LEVEL 2 PASS 4
      0  5bd8					      include	"GFX4.asm"
      0  5bd8					      SLOT	2
      1  5bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  5bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  5bd8				  -	      ERR
      4  5bd8					      ENDIF
      5  5bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  5bd8				   _BANK_SLOT SET	2 * 64
      0  5bd8					      ROMBANK	GFX4
      1  5fd8 ????				      SEG	GFX4
      2  5c00					      ORG	_ORIGIN
      3  5c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  5c00				   _BANK_START SET	*
      5  5c00				   GFX4_START SET	*
      6  5c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5c00				   GFX4       SET	_BANK_SLOT + _CURRENT_BANK
      8  5c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  5c00
      4  5c00							;---------------------------------------------------------------------------------------------------
      5  5c00
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5c00					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
      0  5c00					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_0", 72
     12  5c00					      LIST	ON
      0  5c00					      DEF	BLACK_MARKER_on_WHITE_SQUARE_0
      1  5c00				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5c00				   BANK_BLACK_MARKER_on_WHITE_SQUARE_0 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5c00				   BLACK_MARKER_on_WHITE_SQUARE_0
      4  5c00				   TEMPORARY_VAR SET	Overlay
      5  5c00				   TEMPORARY_OFFSET SET	0
      6  5c00				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5c00				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_0
      3  5c00		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00	;PF0
      4  5c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5c48					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
      0  5c48					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_1", 72
     12  5c48					      LIST	ON
      0  5c48					      DEF	BLACK_MARKER_on_WHITE_SQUARE_1
      1  5c48				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5c48				   BANK_BLACK_MARKER_on_WHITE_SQUARE_1 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5c48				   BLACK_MARKER_on_WHITE_SQUARE_1
      4  5c48				   TEMPORARY_VAR SET	Overlay
      5  5c48				   TEMPORARY_OFFSET SET	0
      6  5c48				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5c48				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_1
      3  5c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5c60		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00	;PF1
      5  5c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5c90					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
      0  5c90					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_2", 72
     12  5c90					      LIST	ON
      0  5c90					      DEF	BLACK_MARKER_on_WHITE_SQUARE_2
      1  5c90				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5c90				   BANK_BLACK_MARKER_on_WHITE_SQUARE_2 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5c90				   BLACK_MARKER_on_WHITE_SQUARE_2
      4  5c90				   TEMPORARY_VAR SET	Overlay
      5  5c90				   TEMPORARY_OFFSET SET	0
      6  5c90				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5c90				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_2
      3  5c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5cc0		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5cd8					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
      0  5cd8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_3", 72
     12  5d00					      LIST	ON
      0  5d00					      DEF	BLACK_MARKER_on_WHITE_SQUARE_3
      1  5d00				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5d00				   BANK_BLACK_MARKER_on_WHITE_SQUARE_3 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5d00				   BLACK_MARKER_on_WHITE_SQUARE_3
      4  5d00				   TEMPORARY_VAR SET	Overlay
      5  5d00				   TEMPORARY_OFFSET SET	0
      6  5d00				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5d00				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_3
      3  5d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5d30		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00	;PF2
------- FILE GFX4.asm
     10  5d48
     11  5d48
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5d48					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  5d48					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_0", 72
     12  5d48					      LIST	ON
      0  5d48					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_0
      1  5d48				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5d48				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5d48				   WHITE_PROMOTE_on_BLACK_SQUARE_0
      4  5d48				   TEMPORARY_VAR SET	Overlay
      5  5d48				   TEMPORARY_OFFSET SET	0
      6  5d48				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5d48				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_0
      3  5d48		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  5d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5d90					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  5d90					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_1", 72
     12  5d90					      LIST	ON
      0  5d90					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_1
      1  5d90				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5d90				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5d90				   WHITE_PROMOTE_on_BLACK_SQUARE_1
      4  5d90				   TEMPORARY_VAR SET	Overlay
      5  5d90				   TEMPORARY_OFFSET SET	0
      6  5d90				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5d90				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_1
      3  5d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5da8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  5dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5dd8					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  5dd8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_2", 72
     12  5e00					      LIST	ON
      0  5e00					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_2
      1  5e00				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5e00				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5e00				   WHITE_PROMOTE_on_BLACK_SQUARE_2
      4  5e00				   TEMPORARY_VAR SET	Overlay
      5  5e00				   TEMPORARY_OFFSET SET	0
      6  5e00				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5e00				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_2
      3  5e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5e18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  5e30		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5e48					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  5e48					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_3", 72
     12  5e48					      LIST	ON
      0  5e48					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_3
      1  5e48				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5e48				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5e48				   WHITE_PROMOTE_on_BLACK_SQUARE_3
      4  5e48				   TEMPORARY_VAR SET	Overlay
      5  5e48				   TEMPORARY_OFFSET SET	0
      6  5e48				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5e48				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_3
      3  5e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5e78		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5e90					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  5e90					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_0", 72
     12  5e90					      LIST	ON
      0  5e90					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_0
      1  5e90				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5e90				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5e90				   WHITE_PROMOTE_on_WHITE_SQUARE_0
      4  5e90				   TEMPORARY_VAR SET	Overlay
      5  5e90				   TEMPORARY_OFFSET SET	0
      6  5e90				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5e90				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_0
      3  5e90		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5ed8					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  5ed8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_1", 72
     12  5f00					      LIST	ON
      0  5f00					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_1
      1  5f00				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5f00				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5f00				   WHITE_PROMOTE_on_WHITE_SQUARE_1
      4  5f00				   TEMPORARY_VAR SET	Overlay
      5  5f00				   TEMPORARY_OFFSET SET	0
      6  5f00				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5f00				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_1
      3  5f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5f18		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5f48					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  5f48					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_2", 72
     12  5f48					      LIST	ON
      0  5f48					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_2
      1  5f48				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5f48				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5f48				   WHITE_PROMOTE_on_WHITE_SQUARE_2
      4  5f48				   TEMPORARY_VAR SET	Overlay
      5  5f48				   TEMPORARY_OFFSET SET	0
      6  5f48				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5f48				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_2
      3  5f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5f78		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5f90					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  5f90					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_3", 72
     12  5f90					      LIST	ON
      0  5f90					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_3
      1  5f90				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5f90				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5f90				   WHITE_PROMOTE_on_WHITE_SQUARE_3
      4  5f90				   TEMPORARY_VAR SET	Overlay
      5  5f90				   TEMPORARY_OFFSET SET	0
      6  5f90				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5f90				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_3
      3  5f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5fc0		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
     20  5fd8
     21  5fd8
     22  5fd8							;---------------------------------------------------------------------------------------------------
     23  5fd8
      0  5fd8					      CHECK_BANK_SIZE	"BANK_GFX4"
      1  5fd8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX4 (1K) SIZE =  $3d8 , FREE= $28
      2  5fd8					      ECHO	"BANK_GFX4", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5fd8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX4", " size=", * - ORIGIN
      5  5fd8				  -	      ERR
      6  5fd8					      ENDIF
     25  5fd8
     26  5fd8							;---------------------------------------------------------------------------------------------------
     27  5fd8							;EOF
------- FILE ./chess.asm
------- FILE NEGAMAX@1.asm LEVEL 2 PASS 4
      0  5fd8					      include	"NEGAMAX@1.asm"
      1  5fd8							; Chess
      2  5fd8							; Copyright (c) 2019-2020 Andrew Davie
      3  5fd8							; andrew@taswegian.com
      4  5fd8
      0  5fd8					      SLOT	1
      1  5fd8				  -	      IF	(1 < 0) || (1 > 3)
      2  5fd8				  -	      ECHO	"Illegal bank address/segment location", 1
      3  5fd8				  -	      ERR
      4  5fd8					      ENDIF
      5  5fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  5fd8				   _BANK_SLOT SET	1 * 64
      0  5fd8					      ROMBANK	NEGAMAX
      1  638a ????				      SEG	NEGAMAX
      2  6000					      ORG	_ORIGIN
      3  6000					      RORG	_BANK_ADDRESS_ORIGIN
      4  6000				   _BANK_START SET	*
      5  6000				   NEGAMAX_START SET	*
      6  6000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6000				   NEGAMAX    SET	_BANK_SLOT + _CURRENT_BANK
      8  6000				   _ORIGIN    SET	_ORIGIN + 1024
      7  6000
      8  6000							;---------------------------------------------------------------------------------------------------
      9  6000
      0  6000					      DEF	aiComputerMove
      1  6000				   SLOT_aiComputerMove SET	_BANK_SLOT
      2  6000				   BANK_aiComputerMove SET	SLOT_aiComputerMove + _CURRENT_BANK
      3  6000				   aiComputerMove
      4  6000				   TEMPORARY_VAR SET	Overlay
      5  6000				   TEMPORARY_OFFSET SET	0
      6  6000				   VAR_BOUNDARY_aiComputerMove SET	TEMPORARY_OFFSET
      7  6000				   FUNCTION_NAME SET	aiComputerMove
     11  6000					      SUBROUTINE
     12  6000
      0  6000					      REFER	AiStateMachine	;✅
      1  6000					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  6000				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  6000					      ENDIF
      0  6000					      VEND	aiComputerMove
      1  6000				  -	      IFNCONST	aiComputerMove
      2  6000				  -	      ECHO	"Incorrect VEND label", aiComputerMove
      3  6000				  -	      ERR
      4  6000					      ENDIF
      5  6000		       00 a9	   VAREND_aiComputerMove =	TEMPORARY_VAR
     15  6000
     16  6000							; Computer is about to select a move
     17  6000
     18  6000
     19  6000		       a9 88		      lda	#RAMBANK_PLY
     20  6002		       85 94		      sta	currentPly
     21  6004		       85 3e		      sta	SET_BANK_RAM	;@2		 ; switch in movelist
     22  6006
     23  6006		       a9 01		      lda	#1
     24  6008		       85 4a		      sta	CTRLPF	; mirroring for thinkbars
     25  600a
     26  600a		       20 3a f4 	      jsr	selectmove	;@this
     27  600d
     28  600d		       a9 00		      lda	#0
     29  600f		       85 4a		      sta	CTRLPF	; clear mirroring
     30  6011		       85 4e		      sta	PF1
     31  6013		       85 4f		      sta	PF2
     32  6015
     33  6015							; correct ply is already switched
     34  6015
      0  6015					      lda@PLY	bestMove
      1  6015		       ad d1 f9 	      lda	bestMove
     36  6018		       10 17		      bpl	.notComputer
     37  601a
     38  601a							; Computer could not find a valid move. It's checkmate or stalemate. Find which...
     39  601a
      0  601a					      SWAP
      1  601a		       a5 95		      lda	sideToMove
      2  601c		       49 c0		      eor	#SWAP_SIDE|HUMAN
      3  601e		       85 95		      sta	sideToMove
      4  6020
      5  6020
     41  6020		       20 9e f1 	      jsr	GenerateAllMoves	;@0
     42  6023		       a5 9f		      lda	flagCheck
     43  6025		       f0 05		      beq	.gameDrawn
     44  6027
      0  6027					      PHASE	AI_CheckMate
      1  6027		       a9 23		      lda	#AI_CheckMate
      2  6029		       85 8b		      sta	aiState
     46  602b		       60		      rts
     47  602c
     48  602c
      0  602c				   .gameDrawn PHASE	AI_Draw
      1  602c		       a9 24		      lda	#AI_Draw
      2  602e		       85 8b		      sta	aiState
     50  6030		       60		      rts
     51  6031
     52  6031				   .notComputer
     53  6031
     54  6031
     55  6031		       a9 ff		      lda	#-1
     56  6033		       85 88		      sta	cursorX12
     57  6035
      0  6035					      PHASE	AI_DelayAfterMove
      1  6035		       a9 25		      lda	#AI_DelayAfterMove
      2  6037		       85 8b		      sta	aiState
     59  6039		       60	   .halted    rts
     60  603a
     61  603a
     62  603a							;---------------------------------------------------------------------------------------------------
     63  603a
      0  603a					      DEF	selectmove
      1  603a				   SLOT_selectmove SET	_BANK_SLOT
      2  603a				   BANK_selectmove SET	SLOT_selectmove + _CURRENT_BANK
      3  603a				   selectmove
      4  603a				   TEMPORARY_VAR SET	Overlay
      5  603a				   TEMPORARY_OFFSET SET	0
      6  603a				   VAR_BOUNDARY_selectmove SET	TEMPORARY_OFFSET
      7  603a				   FUNCTION_NAME SET	selectmove
     65  603a					      SUBROUTINE
     66  603a
      0  603a					      COMMON_VARS
      1  603a
      0  603a					      VAR	__thinkbar, 1
      1  603a		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  603a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  603a
      4  603a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  603a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  603a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  603a					      ENDIF
      8  603a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  603a				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  603a				  -	      ERR
     11  603a					      ENDIF
     12  603a					      LIST	ON
      0  603a					      VAR	__toggle, 1
      1  603a		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  603a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  603a
      4  603a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  603a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  603a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  603a					      ENDIF
      8  603a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  603a				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  603a				  -	      ERR
     11  603a					      ENDIF
     12  603a					      LIST	ON
      4  603a
      0  603a					      VAR	__bestMove, 1
      1  603a		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  603a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  603a
      4  603a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  603a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  603a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  603a					      ENDIF
      8  603a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  603a				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  603a				  -	      ERR
     11  603a					      ENDIF
     12  603a					      LIST	ON
      0  603a					      VAR	__alpha, 2
      1  603a		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  603a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  603a
      4  603a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  603a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  603a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  603a					      ENDIF
      8  603a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  603a				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  603a				  -	      ERR
     11  603a					      ENDIF
     12  603a					      LIST	ON
      0  603a					      VAR	__beta, 2
      1  603a		       00 ac	   __beta     =	TEMPORARY_VAR
      2  603a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  603a
      4  603a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  603a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  603a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  603a					      ENDIF
      8  603a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  603a				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  603a				  -	      ERR
     11  603a					      ENDIF
     12  603a					      LIST	ON
      0  603a					      VAR	__negaMax, 2
      1  603a		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  603a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  603a
      4  603a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  603a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  603a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  603a					      ENDIF
      8  603a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  603a				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  603a				  -	      ERR
     11  603a					      ENDIF
     12  603a					      LIST	ON
      0  603a					      VAR	__value, 2
      1  603a		       00 b0	   __value    =	TEMPORARY_VAR
      2  603a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  603a
      4  603a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  603a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  603a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  603a					      ENDIF
      8  603a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  603a				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  603a				  -	      ERR
     11  603a					      ENDIF
     12  603a					      LIST	ON
     10  603a
      0  603a					      VAR	__quiesceCapOnly, 1
      1  603a		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  603a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  603a
      4  603a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  603a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  603a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  603a					      ENDIF
      8  603a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  603a				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  603a				  -	      ERR
     11  603a					      ENDIF
     12  603a					      LIST	ON
     12  603a
      0  603a					      VAR	__originalPiece, 1
      1  603a		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  603a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  603a
      4  603a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  603a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  603a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  603a					      ENDIF
      8  603a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  603a				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  603a				  -	      ERR
     11  603a					      ENDIF
     12  603a					      LIST	ON
      0  603a					      VAR	__capturedPiece, 1
      1  603a		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  603a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  603a
      4  603a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  603a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  603a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  603a					      ENDIF
      8  603a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  603a				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  603a				  -	      ERR
     11  603a					      ENDIF
     12  603a					      LIST	ON
     15  603a
      0  603a					      REFER	aiComputerMove	;✅
      1  603a				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  603a				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  603a					      ENDIF
      0  603a					      VEND	selectmove
      1  603a				  -	      IFNCONST	selectmove
      2  603a				  -	      ECHO	"Incorrect VEND label", selectmove
      3  603a				  -	      ERR
      4  603a					      ENDIF
      5  603a		       00 b5	   VAREND_selectmove =	TEMPORARY_VAR
     70  603a
     71  603a
     72  603a							; RAM bank already switched in!!!
     73  603a							; returns with RAM bank switched
     74  603a
     75  603a
     76  603a					      IF	DIAGNOSTICS
     77  603a
     78  603a		       a9 00		      lda	#0
     79  603c		       85 9c		      sta	positionCount
     80  603e		       85 9d		      sta	positionCount+1
     81  6040		       85 9e		      sta	positionCount+2
     82  6042							;sta maxPly
     83  6042					      ENDIF
     84  6042
     85  6042		       a9 00		      lda	#<INFINITY
     86  6044		       85 ac		      sta	__beta
     87  6046		       a9 70		      lda	#>INFINITY
     88  6048		       85 ad		      sta	__beta+1
     89  604a
     90  604a		       a9 00		      lda	#<-INFINITY
     91  604c		       85 aa		      sta	__alpha
     92  604e		       a9 90		      lda	#>-INFINITY
     93  6050		       85 ab		      sta	__alpha+1	; player tries to maximise
     94  6052
     95  6052		       a2 03		      ldx	#SEARCH_DEPTH
     96  6054		       a9 00		      lda	#0	; no captured piece
     97  6056		       85 b2		      sta	__quiesceCapOnly	; ALL moves to be generated
     98  6058
     99  6058		       20 29 f5 	      jsr	negaMax
    100  605b
    101  605b		       a5 94		      lda	currentPly
    102  605d		       85 3e		      sta	SET_BANK_RAM	;tmp?
    103  605f
      0  605f					      ldx@PLY	bestMove
      1  605f		       ae d1 f9 	      ldx	bestMove
    105  6062		       30 26		      bmi	.nomove
    106  6064
    107  6064							; Generate player's moves in reply
    108  6064							; Make the computer move, list player moves (PLY+1), unmake computer move
    109  6064
      0  6064					      stx@PLY	movePtr
      1  6064		       8e d0 fb 	      stx	[RAM]+movePtr
    111  6067		       20 8b f4 	      jsr	MakeMove	;@this
    112  606a		       20 48 f2 	      jsr	ListPlayerMoves	;@0
    113  606d
    114  606d		       c6 94		      dec	currentPly
    115  606f		       20 a5 f2 	      jsr	unmakeMove	;@0
    116  6072
    117  6072							; Grab the computer move details for the UI animation
    118  6072
    119  6072		       a9 88		      lda	#RAMBANK_PLY
    120  6074		       85 3e		      sta	SET_BANK_RAM
    121  6076
      0  6076					      ldx@PLY	bestMove
      1  6076		       ae d1 f9 	      ldx	bestMove
      0  6079					      lda@PLY	MoveTo,x
      1  6079		       bd 64 f8 	      lda	MoveTo,x
    124  607c		       85 86		      sta	toX12
      0  607e					      lda@PLY	MoveFrom,x
      1  607e		       bd 00 f8 	      lda	MoveFrom,x
    126  6081		       85 87		      sta	originX12
    127  6083		       85 85		      sta	fromX12
      0  6085					      lda@PLY	MovePiece,x
      1  6085		       bd 00 f9 	      lda	MovePiece,x
    129  6088		       85 96		      sta	fromPiece
    130  608a
    131  608a				   .nomove
    132  608a		       60		      rts
    133  608b
    134  608b
    135  608b							;---------------------------------------------------------------------------------------------------
    136  608b
      0  608b					      DEF	MakeMove
      1  608b				   SLOT_MakeMove SET	_BANK_SLOT
      2  608b				   BANK_MakeMove SET	SLOT_MakeMove + _CURRENT_BANK
      3  608b				   MakeMove
      4  608b				   TEMPORARY_VAR SET	Overlay
      5  608b				   TEMPORARY_OFFSET SET	0
      6  608b				   VAR_BOUNDARY_MakeMove SET	TEMPORARY_OFFSET
      7  608b				   FUNCTION_NAME SET	MakeMove
    138  608b					      SUBROUTINE
    139  608b
      0  608b					      COMMON_VARS
      1  608b
      0  608b					      VAR	__thinkbar, 1
      1  608b		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  608b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  608b
      4  608b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  608b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  608b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  608b					      ENDIF
      8  608b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  608b				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  608b				  -	      ERR
     11  608b					      ENDIF
     12  608b					      LIST	ON
      0  608b					      VAR	__toggle, 1
      1  608b		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  608b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  608b
      4  608b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  608b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  608b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  608b					      ENDIF
      8  608b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  608b				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  608b				  -	      ERR
     11  608b					      ENDIF
     12  608b					      LIST	ON
      4  608b
      0  608b					      VAR	__bestMove, 1
      1  608b		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  608b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  608b
      4  608b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  608b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  608b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  608b					      ENDIF
      8  608b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  608b				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  608b				  -	      ERR
     11  608b					      ENDIF
     12  608b					      LIST	ON
      0  608b					      VAR	__alpha, 2
      1  608b		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  608b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  608b
      4  608b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  608b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  608b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  608b					      ENDIF
      8  608b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  608b				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  608b				  -	      ERR
     11  608b					      ENDIF
     12  608b					      LIST	ON
      0  608b					      VAR	__beta, 2
      1  608b		       00 ac	   __beta     =	TEMPORARY_VAR
      2  608b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  608b
      4  608b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  608b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  608b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  608b					      ENDIF
      8  608b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  608b				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  608b				  -	      ERR
     11  608b					      ENDIF
     12  608b					      LIST	ON
      0  608b					      VAR	__negaMax, 2
      1  608b		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  608b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  608b
      4  608b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  608b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  608b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  608b					      ENDIF
      8  608b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  608b				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  608b				  -	      ERR
     11  608b					      ENDIF
     12  608b					      LIST	ON
      0  608b					      VAR	__value, 2
      1  608b		       00 b0	   __value    =	TEMPORARY_VAR
      2  608b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  608b
      4  608b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  608b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  608b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  608b					      ENDIF
      8  608b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  608b				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  608b				  -	      ERR
     11  608b					      ENDIF
     12  608b					      LIST	ON
     10  608b
      0  608b					      VAR	__quiesceCapOnly, 1
      1  608b		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  608b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  608b
      4  608b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  608b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  608b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  608b					      ENDIF
      8  608b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  608b				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  608b				  -	      ERR
     11  608b					      ENDIF
     12  608b					      LIST	ON
     12  608b
      0  608b					      VAR	__originalPiece, 1
      1  608b		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  608b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  608b
      4  608b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  608b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  608b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  608b					      ENDIF
      8  608b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  608b				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  608b				  -	      ERR
     11  608b					      ENDIF
     12  608b					      LIST	ON
      0  608b					      VAR	__capturedPiece, 1
      1  608b		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  608b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  608b
      4  608b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  608b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  608b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  608b					      ENDIF
      8  608b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  608b				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  608b				  -	      ERR
     11  608b					      ENDIF
     12  608b					      LIST	ON
     15  608b
      0  608b					      REFER	selectmove	;✅
      1  608b				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  608b				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  608b					      ENDIF
      0  608b					      REFER	ListPlayerMoves	;✅
      1  608b				  -	      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  608b				  -TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  608b					      ENDIF
      0  608b					      REFER	quiesce	;✅
      1  608b				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  608b				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  608b					      ENDIF
      0  608b					      REFER	negaMax	;✅
      1  608b				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  608b				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  608b					      ENDIF
      0  608b					      VEND	MakeMove
      1  608b				  -	      IFNCONST	MakeMove
      2  608b				  -	      ECHO	"Incorrect VEND label", MakeMove
      3  608b				  -	      ERR
      4  608b					      ENDIF
      5  608b		       00 b5	   VAREND_MakeMove =	TEMPORARY_VAR
    146  608b
    147  608b							; Do a move without any GUI stuff
    148  608b							; This function is ALWAYS paired with "unmakeMove" - a call to both will leave board
    149  608b							; and all relevant flags in original state. This is NOT used for the visible move on the
    150  608b							; screen.
    151  608b
    152  608b
    153  608b							; fromPiece	 piece doing the move
    154  608b							; fromX12	 current square X12
    155  608b							; originX12	 starting square X12
    156  608b							; toX12	 ending square X12
    157  608b
    158  608b							; BANK:SLOT2 = currentPly
    159  608b
    160  608b
    161  608b							; There are potentially "two" moves, with the following
    162  608b							; a) Castling, moving both rook and king
    163  608b							; b) en-Passant, capturing pawn on "odd" square
    164  608b							; These both set "secondary" movers which are used for restoring during unmakeMove
    165  608b
    166  608b		       a0 d1		      ldy	#RAMBANK_BOARD
    167  608d		       84 3e		      sty	SET_BANK_RAM	;@3
    168  608f
      0  608f					      ldx@PLY	movePtr
      1  608f		       ae d0 f9 	      ldx	movePtr
      0  6092					      ldy@PLY	MoveFrom,x
      1  6092		       bc 00 f8 	      ldy	MoveFrom,x
    171  6095		       84 85		      sty	fromX12
    172  6097		       84 87		      sty	originX12
    173  6099
      0  6099					      lda@RAM	Board,y
      1  6099		       b9 79 fc 	      lda	Board,y
    175  609c		       85 b3		      sta	__originalPiece
      0  609e					      sta@PLY	restorePiece
      1  609e		       8d d9 fb 	      sta	[RAM]+restorePiece
    177  60a1
    178  60a1		       a9 00		      lda	#0
      0  60a3					      sta@RAM	Board,y
      1  60a3		       99 79 fe 	      sta	[RAM]+Board,y
      0  60a6					      sta@PLY	secondaryPiece
      1  60a6		       8d cc fb 	      sta	[RAM]+secondaryPiece
    181  60a9
    182  60a9		       85 a4		      sta	vkSquare
    183  60ab		       85 a5		      sta	vkSquare+1
    184  60ad
      0  60ad					      ldy@PLY	MoveTo,x
      1  60ad		       bc 64 f8 	      ldy	MoveTo,x
    186  60b0		       84 86		      sty	toX12
    187  60b2
      0  60b2					      lda@RAM	Board,y
      1  60b2		       b9 79 fc 	      lda	Board,y
    189  60b5		       85 b4		      sta	__capturedPiece
      0  60b7					      sta@PLY	capturedPiece
      1  60b7		       8d cb fb 	      sta	[RAM]+capturedPiece
    191  60ba
      0  60ba					      lda@PLY	MovePiece,x
      1  60ba		       bd 00 f9 	      lda	MovePiece,x
    193  60bd		       85 96		      sta	fromPiece
    194  60bf
    195  60bf		       29 8f		      and	#PIECE_MASK|FLAG_COLOUR
    196  60c1		       09 40		      ora	#FLAG_MOVED
      0  60c3					      sta@RAM	Board,y
      1  60c3		       99 79 fe 	      sta	[RAM]+Board,y
    198  60c6
    199  60c6
      0  60c6				   .move      CALL	AdjustMaterialPositionalValue	;@2
      1  60c6				  -	      IF	SLOT_AdjustMaterialPositionalValue == _BANK_SLOT
      2  60c6				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  60c6				  -	      ECHO	"Cannot switch bank in use for", AdjustMaterialPositionalValue
      4  60c6				  -	      ERR
      5  60c6					      ENDIF
      6  60c6		       a9 92		      lda	#BANK_AdjustMaterialPositionalValue
      7  60c8		       85 3f		      sta	SET_BANK
      8  60ca		       20 e5 f8 	      jsr	AdjustMaterialPositionalValue
    201  60cd
    202  60cd
    203  60cd					      IF	CASTLING_ENABLED
    204  60cd
    205  60cd							; If the FROM piece has the castle bit set (i.e., it's a king that's just moved 2 squares)
    206  60cd							; then we find the appropriate ROOK, set the secondary piece "undo" information, and then
    207  60cd							; redo the moving code (for the rook, this time).
    208  60cd
    209  60cd							; Set the squares that need to be checked for "virtual check" - preventing the king
    210  60cd							; from castling from/across check.
    211  60cd
    212  60cd		       a5 96		      lda	fromPiece
    213  60cf		       29 17		      and	#FLAG_CASTLE|KING
    214  60d1		       c9 17		      cmp	#FLAG_CASTLE|KING
    215  60d3		       d0 13		      bne	.exit	; NOT involved in castle!
    216  60d5
    217  60d5							; Must be a king, castling. Calculate the virtual squares which need to be checked for
    218  60d5							; invalid castling. Prevents moving in/across check.
    219  60d5
    220  60d5		       18		      clc
    221  60d6		       a5 87		      lda	originX12
    222  60d8		       85 a5		      sta	vkSquare+1	; king origin
    223  60da		       65 86		      adc	toX12
    224  60dc		       4a		      lsr
    225  60dd		       85 a4		      sta	vkSquare	; intermediate square
    226  60df
    227  60df
    228  60df							; Now generate a new move for the rook
    229  60df
      0  60df					      CALL	GenCastleMoveForRook	;@3
      1  60df				  -	      IF	SLOT_GenCastleMoveForRook == _BANK_SLOT
      2  60df				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  60df				  -	      ECHO	"Cannot switch bank in use for", GenCastleMoveForRook
      4  60df				  -	      ERR
      5  60df					      ENDIF
      6  60df		       a9 db		      lda	#BANK_GenCastleMoveForRook
      7  60e1		       85 3f		      sta	SET_BANK
      8  60e3		       20 21 fc 	      jsr	GenCastleMoveForRook
    231  60e6		       b0 de		      bcs	.move	; move the rook!
    232  60e8
    233  60e8				   .exit
    234  60e8					      ENDIF
    235  60e8
    236  60e8
    237  60e8					      IF	ENPASSANT_ENABLED
    238  60e8
      0  60e8					      CALL	EnPassantFixupDraw	; generate enPassantPawn value
      1  60e8				  -	      IF	SLOT_EnPassantFixupDraw == _BANK_SLOT
      2  60e8				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  60e8				  -	      ECHO	"Cannot switch bank in use for", EnPassantFixupDraw
      4  60e8				  -	      ERR
      5  60e8					      ENDIF
      6  60e8		       a9 92		      lda	#BANK_EnPassantFixupDraw
      7  60ea		       85 3f		      sta	SET_BANK
      8  60ec		       20 6b f8 	      jsr	EnPassantFixupDraw
    240  60ef							;CALL EnPassantRemoveCapturedPawn
    241  60ef
    242  60ef					      ENDIF
    243  60ef
    244  60ef
    245  60ef
    246  60ef							; Swap over sides
    247  60ef
      0  60ef					      NEGEVAL
      1  60ef
      2  60ef		       38		      sec
      3  60f0		       a9 00		      lda	#0
      4  60f2		       e5 8f		      sbc	Evaluation
      5  60f4		       85 8f		      sta	Evaluation
      6  60f6		       a9 00		      lda	#0
      7  60f8		       e5 90		      sbc	Evaluation+1
      8  60fa		       85 90		      sta	Evaluation+1
      0  60fc					      SWAP
      1  60fc		       a5 95		      lda	sideToMove
      2  60fe		       49 c0		      eor	#SWAP_SIDE|HUMAN
      3  6100		       85 95		      sta	sideToMove
      4  6102
      5  6102
    250  6102
    251  6102		       a5 94		      lda	currentPly
    252  6104		       85 3e		      sta	SET_BANK_RAM
    253  6106		       60		      rts
    254  6107
    255  6107
    256  6107							;---------------------------------------------------------------------------------------------------
    257  6107
    258  6107							;function negaMax(node, depth, α, β, color) is
    259  6107							;    if depth = 0 or node is a terminal node then
    260  6107							;	  return color × the heuristic value of node
    261  6107
    262  6107							;    childNodes := generateMoves(node)
    263  6107							;    childNodes := orderMoves(childNodes)
    264  6107							;    value := −∞
    265  6107							;    foreach child in childNodes do
    266  6107							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    267  6107							;	  α := max(α, value)
    268  6107							;	  if α ≥ β then
    269  6107							;	      break (* cut-off *)
    270  6107							;    return value
    271  6107							;(* Initial call for Player A's root node *)
    272  6107							;negaMax(rootNode, depth, −∞, +∞, 1)
    273  6107
    274  6107
    275  6107					      SUBROUTINE
    276  6107
    277  6107		       a9 ff	   .doQ       lda	#-1
    278  6109		       85 b2		      sta	__quiesceCapOnly
    279  610b		       20 a3 f6 	      jsr	quiesce
    280  610e		       e6 b2		      inc	__quiesceCapOnly
    281  6110		       60		      rts
    282  6111
    283  6111
      0  6111				   .exit      lda@PLY	value
      1  6111		       ad d6 f9 	      lda	value
    285  6114		       85 ae		      sta	__negaMax
      0  6116					      lda@PLY	value+1
      1  6116		       ad d7 f9 	      lda	value+1
    287  6119		       85 af		      sta	__negaMax+1
    288  611b		       60		      rts
    289  611c
    290  611c
    291  611c				   .terminal
    292  611c
    293  611c					      IF	QUIESCE_EXTRA_DEPTH > 0
    294  611c		       c9 00		      cmp	#0	; captured piece
    295  611e		       d0 e7		      bne	.doQ	; last move was capture, so quiesce
    296  6120					      ENDIF
    297  6120
    298  6120
    299  6120		       a5 8f		      lda	Evaluation
    300  6122		       85 ae		      sta	__negaMax
    301  6124		       a5 90		      lda	Evaluation+1
    302  6126		       85 af		      sta	__negaMax+1
    303  6128
    304  6128		       60	   .inCheck2  rts
    305  6129
    306  6129
    307  6129
      0  6129					      DEF	negaMax
      1  6129				   SLOT_negaMax SET	_BANK_SLOT
      2  6129				   BANK_negaMax SET	SLOT_negaMax + _CURRENT_BANK
      3  6129				   negaMax
      4  6129				   TEMPORARY_VAR SET	Overlay
      5  6129				   TEMPORARY_OFFSET SET	0
      6  6129				   VAR_BOUNDARY_negaMax SET	TEMPORARY_OFFSET
      7  6129				   FUNCTION_NAME SET	negaMax
    309  6129
    310  6129							; PARAMS depth-1, -beta, -alpha
    311  6129							; pased through temporary variables (__alpha, __beta) and X reg
    312  6129
    313  6129							; pass...
    314  6129							; x = depthleft
    315  6129							; a = captured piece
    316  6129							; SET_BANK_RAM      --> current ply
    317  6129							; __alpha[2] = param alpha
    318  6129							; __beta[2] = param beta
    319  6129
    320  6129
      0  6129					      COMMON_VARS
      1  6129
      0  6129					      VAR	__thinkbar, 1
      1  6129		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  6129				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6129
      4  6129				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6129				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6129				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6129					      ENDIF
      8  6129				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6129				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  6129				  -	      ERR
     11  6129					      ENDIF
     12  6129					      LIST	ON
      0  6129					      VAR	__toggle, 1
      1  6129		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  6129				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6129
      4  6129				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6129				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6129				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6129					      ENDIF
      8  6129				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6129				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  6129				  -	      ERR
     11  6129					      ENDIF
     12  6129					      LIST	ON
      4  6129
      0  6129					      VAR	__bestMove, 1
      1  6129		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  6129				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6129
      4  6129				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6129				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6129				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6129					      ENDIF
      8  6129				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6129				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  6129				  -	      ERR
     11  6129					      ENDIF
     12  6129					      LIST	ON
      0  6129					      VAR	__alpha, 2
      1  6129		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  6129				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6129
      4  6129				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6129				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6129				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6129					      ENDIF
      8  6129				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6129				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  6129				  -	      ERR
     11  6129					      ENDIF
     12  6129					      LIST	ON
      0  6129					      VAR	__beta, 2
      1  6129		       00 ac	   __beta     =	TEMPORARY_VAR
      2  6129				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6129
      4  6129				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6129				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6129				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6129					      ENDIF
      8  6129				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6129				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  6129				  -	      ERR
     11  6129					      ENDIF
     12  6129					      LIST	ON
      0  6129					      VAR	__negaMax, 2
      1  6129		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  6129				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6129
      4  6129				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6129				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6129				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6129					      ENDIF
      8  6129				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6129				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  6129				  -	      ERR
     11  6129					      ENDIF
     12  6129					      LIST	ON
      0  6129					      VAR	__value, 2
      1  6129		       00 b0	   __value    =	TEMPORARY_VAR
      2  6129				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6129
      4  6129				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6129				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6129				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6129					      ENDIF
      8  6129				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6129				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  6129				  -	      ERR
     11  6129					      ENDIF
     12  6129					      LIST	ON
     10  6129
      0  6129					      VAR	__quiesceCapOnly, 1
      1  6129		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  6129				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6129
      4  6129				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6129				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6129				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6129					      ENDIF
      8  6129				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6129				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  6129				  -	      ERR
     11  6129					      ENDIF
     12  6129					      LIST	ON
     12  6129
      0  6129					      VAR	__originalPiece, 1
      1  6129		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  6129				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6129
      4  6129				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6129				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6129				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6129					      ENDIF
      8  6129				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6129				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  6129				  -	      ERR
     11  6129					      ENDIF
     12  6129					      LIST	ON
      0  6129					      VAR	__capturedPiece, 1
      1  6129		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  6129				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6129
      4  6129				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6129				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6129				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6129					      ENDIF
      8  6129				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6129				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  6129				  -	      ERR
     11  6129					      ENDIF
     12  6129					      LIST	ON
     15  6129
      0  6129					      REFER	selectmove	;✅
      1  6129				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  6129				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  6129					      ENDIF
      0  6129					      VEND	negaMax
      1  6129				  -	      IFNCONST	negaMax
      2  6129				  -	      ECHO	"Incorrect VEND label", negaMax
      3  6129				  -	      ERR
      4  6129					      ENDIF
      5  6129		       00 b5	   VAREND_negaMax =	TEMPORARY_VAR
    324  6129
    325  6129		       48		      pha
    326  612a
    327  612a		       20 81 f0 	      jsr	ThinkBar	;@0
    328  612d
    329  612d		       a5 94		      lda	currentPly
    330  612f		       85 3e		      sta	SET_BANK_RAM	;@2
    331  6131
    332  6131		       68		      pla
    333  6132		       ca		      dex
    334  6133		       30 e7		      bmi	.terminal
      0  6135					      stx@PLY	depthLeft
      1  6135		       8e d8 fb 	      stx	[RAM]+depthLeft
    336  6138
    337  6138
    338  6138							; Allow the player to force computer to select a move. Press the SELECT switch
    339  6138
      0  6138					      lda@PLY	bestMove
      1  6138		       ad d1 f9 	      lda	bestMove
    341  613b		       30 07		      bmi	.noCheat	; can't force if no move chosen!
    342  613d		       ad 82 02 	      lda	SWCHB
    343  6140		       29 02		      and	#SELECT_SWITCH
    344  6142		       f0 cd		      beq	.exit	; SELECT abort
    345  6144				   .noCheat
    346  6144
    347  6144
      0  6144					      NEXT_RANDOM
      1  6144		       a5 81		      lda	rnd
      2  6146		       4a		      lsr
      3  6147		       90 02		      bcc	.skipEOR
      4  6149		       49 fe		      eor	#RND_EOR_VAL
      5  614b		       85 81	   .skipEOR   sta	rnd
    349  614d		       25 a1		      and	randomness
    350  614f		       65 8f		      adc	Evaluation
    351  6151		       85 8f		      sta	Evaluation	; since it's random we don't care about HI
    352  6153							;bcc .evOK
    353  6153							;inc Evaluation+1
    354  6153				   .evOK
    355  6153
    356  6153
    357  6153
    358  6153							;lda #2
    359  6153							;sta COLUPF			  ; grey thinkbars
    360  6153
    361  6153		       a5 aa		      lda	__alpha
      0  6155					      sta@PLY	alpha
      1  6155		       8d d2 fb 	      sta	[RAM]+alpha
    363  6158		       a5 ab		      lda	__alpha+1
      0  615a					      sta@PLY	alpha+1
      1  615a		       8d d3 fb 	      sta	[RAM]+alpha+1
    365  615d
    366  615d		       a5 ac		      lda	__beta
      0  615f					      sta@PLY	beta
      1  615f		       8d d4 fb 	      sta	[RAM]+beta
    368  6162		       a5 ad		      lda	__beta+1
      0  6164					      sta@PLY	beta+1
      1  6164		       8d d5 fb 	      sta	[RAM]+beta+1
    370  6167
    371  6167
    372  6167		       20 9e f1 	      jsr	GenerateAllMoves	;@0
    373  616a
    374  616a		       a5 9f		      lda	flagCheck
    375  616c		       d0 ba		      bne	.inCheck2	; OTHER guy in check
    376  616e
    377  616e		       a9 00		      lda	#<-INFINITY
      0  6170					      sta@PLY	value
      1  6170		       8d d6 fb 	      sta	[RAM]+value
    379  6173		       a9 90		      lda	#>-INFINITY
      0  6175					      sta@PLY	value+1
      1  6175		       8d d7 fb 	      sta	[RAM]+value+1
    381  6178
      0  6178					      ldx@PLY	moveIndex
      1  6178		       ae cf f9 	      ldx	moveIndex
    383  617b		       10 03		      bpl	.forChild
    384  617d		       4c 11 f5 	      jmp	.exit
    385  6180
      0  6180				   .forChild  stx@PLY	movePtr
      1  6180		       8e d0 fb 	      stx	[RAM]+movePtr
    387  6183
    388  6183		       20 8b f4 	      jsr	MakeMove	;@this
    389  6186
    390  6186
    391  6186							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    392  6186
    393  6186							; PARAMS depth-1, -beta, -alpha
    394  6186							; pased through temporary variables (__alpha, __beta) and X reg
    395  6186
    396  6186		       38		      sec
    397  6187		       a9 00		      lda	#0
      0  6189					      sbc@PLY	beta
      1  6189		       ed d4 f9 	      sbc	beta
    399  618c		       85 aa		      sta	__alpha
    400  618e		       a9 00		      lda	#0
      0  6190					      sbc@PLY	beta+1
      1  6190		       ed d5 f9 	      sbc	beta+1
    402  6193		       85 ab		      sta	__alpha+1
    403  6195
    404  6195		       38		      sec
    405  6196		       a9 00		      lda	#0
      0  6198					      sbc@PLY	alpha
      1  6198		       ed d2 f9 	      sbc	alpha
    407  619b		       85 ac		      sta	__beta
    408  619d		       a9 00		      lda	#0
      0  619f					      sbc@PLY	alpha+1
      1  619f		       ed d3 f9 	      sbc	alpha+1
    410  61a2		       85 ad		      sta	__beta+1
    411  61a4
    412  61a4
      0  61a4					      ldx@PLY	depthLeft
      1  61a4		       ae d8 f9 	      ldx	depthLeft
      0  61a7					      lda@PLY	capturedPiece
      1  61a7		       ad cb f9 	      lda	capturedPiece
    415  61aa
    416  61aa		       e6 94		      inc	currentPly
    417  61ac		       a4 94		      ldy	currentPly
    418  61ae		       84 3e		      sty	SET_BANK_RAM	; self-switch
    419  61b0
    420  61b0		       20 29 f5 	      jsr	negaMax	;@this
    421  61b3
    422  61b3		       c6 94		      dec	currentPly
    423  61b5		       a5 94		      lda	currentPly
    424  61b7		       85 3e		      sta	SET_BANK_RAM
    425  61b9
    426  61b9		       20 a5 f2 	      jsr	unmakeMove	;@0
    427  61bc
    428  61bc		       38		      sec
    429  61bd		       a9 00		      lda	#0
    430  61bf		       e5 ae		      sbc	__negaMax
    431  61c1		       85 ae		      sta	__negaMax
    432  61c3		       a9 00		      lda	#0
    433  61c5		       e5 af		      sbc	__negaMax+1
    434  61c7		       85 af		      sta	__negaMax+1	; -negaMax(...)
    435  61c9
    436  61c9					      IF	1
    437  61c9		       a5 9f		      lda	flagCheck
    438  61cb		       f0 06		      beq	.notCheck
    439  61cd
    440  61cd							; at this point we've determined that the move was illegal, because the next ply detected
    441  61cd							; a king capture. So, the move should be totally discounted
    442  61cd
    443  61cd		       a9 00		      lda	#0
    444  61cf		       85 9f		      sta	flagCheck	; so we don't retrigger in future - it's been handled!
    445  61d1		       f0 53		      beq	.nextMove	; unconditional - move is not considered!
    446  61d3					      ENDIF
    447  61d3
    448  61d3		       38	   .notCheck  sec
      0  61d4					      lda@PLY	value
      1  61d4		       ad d6 f9 	      lda	value
    450  61d7		       e5 ae		      sbc	__negaMax
      0  61d9					      lda@PLY	value+1
      1  61d9		       ad d7 f9 	      lda	value+1
    452  61dc		       e5 af		      sbc	__negaMax+1
    453  61de		       50 02		      bvc	.lab0
    454  61e0		       49 80		      eor	#$80
    455  61e2		       10 10	   .lab0      bpl	.lt0	; branch if value >= negaMax
    456  61e4
    457  61e4							; so, negaMax > value!
    458  61e4
    459  61e4		       a5 ae		      lda	__negaMax
      0  61e6					      sta@PLY	value
      1  61e6		       8d d6 fb 	      sta	[RAM]+value
    461  61e9		       a5 af		      lda	__negaMax+1
      0  61eb					      sta@PLY	value+1	; max(value, -negaMax)
      1  61eb		       8d d7 fb 	      sta	[RAM]+value+1
    463  61ee
      0  61ee					      lda@PLY	movePtr
      1  61ee		       ad d0 f9 	      lda	movePtr
      0  61f1					      sta@PLY	bestMove
      1  61f1		       8d d1 fb 	      sta	[RAM]+bestMove
    466  61f4				   .lt0
    467  61f4
    468  61f4							;	  α := max(α, value)
    469  61f4
    470  61f4		       38		      sec
      0  61f5					      lda@PLY	value
      1  61f5		       ad d6 f9 	      lda	value
      0  61f8					      sbc@PLY	alpha
      1  61f8		       ed d2 f9 	      sbc	alpha
      0  61fb					      lda@PLY	value+1
      1  61fb		       ad d7 f9 	      lda	value+1
      0  61fe					      sbc@PLY	alpha+1
      1  61fe		       ed d3 f9 	      sbc	alpha+1
    475  6201		       50 02		      bvc	.lab1
    476  6203		       49 80		      eor	#$80
    477  6205		       30 0c	   .lab1      bmi	.lt1	; value < alpha
    478  6207
      0  6207					      lda@PLY	value
      1  6207		       ad d6 f9 	      lda	value
      0  620a					      sta@PLY	alpha
      1  620a		       8d d2 fb 	      sta	[RAM]+alpha
      0  620d					      lda@PLY	value+1
      1  620d		       ad d7 f9 	      lda	value+1
      0  6210					      sta@PLY	alpha+1	; alpha = max(alpha, value)
      1  6210		       8d d3 fb 	      sta	[RAM]+alpha+1
    483  6213
    484  6213				   .lt1
    485  6213
    486  6213							;	  if α ≥ β then
    487  6213							;	      break (* cut-off *)
    488  6213
    489  6213		       38		      sec
      0  6214					      lda@PLY	alpha
      1  6214		       ad d2 f9 	      lda	alpha
      0  6217					      sbc@PLY	beta
      1  6217		       ed d4 f9 	      sbc	beta
      0  621a					      lda@PLY	alpha+1
      1  621a		       ad d3 f9 	      lda	alpha+1
      0  621d					      sbc@PLY	beta+1
      1  621d		       ed d5 f9 	      sbc	beta+1
    494  6220		       50 02		      bvc	.lab2
    495  6222		       49 80		      eor	#$80
    496  6224		       10 09	   .lab2      bpl	.retrn	; alpha >= beta
    497  6226
    498  6226
      0  6226				   .nextMove  ldx@PLY	movePtr
      1  6226		       ae d0 f9 	      ldx	movePtr
    500  6229		       ca	   .nextX     dex
    501  622a		       30 03		      bmi	.retrn
    502  622c		       4c 80 f5 	      jmp	.forChild
    503  622f
    504  622f		       4c 11 f5    .retrn     jmp	.exit
    505  6232
    506  6232							;---------------------------------------------------------------------------------------------------
    507  6232
    508  6232					      MAC	xchg
    509  6232					      lda@PLY	{1},x
    510  6232					      pha		;sta __xchg
    511  6232					      lda@PLY	{1},y
    512  6232					      sta@PLY	{1},x
    513  6232					      pla		;lda __xchg
    514  6232					      sta@PLY	{1},y
    515  6232					      ENDM		;{name}
    516  6232
    517  6232
      0  6232					      DEF	Sort
      1  6232				   SLOT_Sort  SET	_BANK_SLOT
      2  6232				   BANK_Sort  SET	SLOT_Sort + _CURRENT_BANK
      3  6232				   Sort
      4  6232				   TEMPORARY_VAR SET	Overlay
      5  6232				   TEMPORARY_OFFSET SET	0
      6  6232				   VAR_BOUNDARY_Sort SET	TEMPORARY_OFFSET
      7  6232				   FUNCTION_NAME SET	Sort
    519  6232					      SUBROUTINE
    520  6232
      0  6232					      REFER	GenerateAllMoves
      1  6232					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6232				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6232					      ENDIF
      0  6232					      VAR	__xchg, 1
      1  6232		       00 b8	   __xchg     =	TEMPORARY_VAR
      2  6232				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6232
      4  6232				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6232				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6232				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6232					      ENDIF
      8  6232				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6232				  -	      ECHO	"Temporary Variable", __xchg, "overflow!"
     10  6232				  -	      ERR
     11  6232					      ENDIF
     12  6232					      LIST	ON
      0  6232					      VEND	Sort
      1  6232				  -	      IFNCONST	Sort
      2  6232				  -	      ECHO	"Incorrect VEND label", Sort
      3  6232				  -	      ERR
      4  6232					      ENDIF
      5  6232		       00 b9	   VAREND_Sort =	TEMPORARY_VAR
    524  6232
    525  6232		       a5 b2		      lda	__quiesceCapOnly
    526  6234		       d0 4a		      bne	.exit	; only caps present so already sorted!
    527  6236
      0  6236					      ldx@PLY	moveIndex
      1  6236		       ae cf f9 	      ldx	moveIndex
      0  6239					      ldy@PLY	moveIndex
      1  6239		       ac cf f9 	      ldy	moveIndex
    530  623c		       c8		      iny		; this is OK - swaps "1st" with itself if it's a capture
    531  623d
    532  623d		       88	   .next      dey
    533  623e		       30 40		      bmi	.exit
    534  6240
      0  6240					      lda@PLY	MoveCapture,y
      1  6240		       b9 64 f9 	      lda	MoveCapture,y
    536  6243		       f0 f8		      beq	.next
    537  6245
      0  6245					      XCHG	MoveFrom
      0  6245					      lda@PLY	MoveFrom,x
      1  6245		       bd 00 f8 	      lda	MoveFrom,x
      2  6248		       48		      pha
      0  6249					      lda@PLY	MoveFrom,y
      1  6249		       b9 00 f8 	      lda	MoveFrom,y
      0  624c					      sta@PLY	MoveFrom,x
      1  624c		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
      5  624f		       68		      pla
      0  6250					      sta@PLY	MoveFrom,y
      1  6250		       99 00 fa 	      sta	[RAM]+MoveFrom,y
      0  6253					      XCHG	MoveTo
      0  6253					      lda@PLY	MoveTo,x
      1  6253		       bd 64 f8 	      lda	MoveTo,x
      2  6256		       48		      pha
      0  6257					      lda@PLY	MoveTo,y
      1  6257		       b9 64 f8 	      lda	MoveTo,y
      0  625a					      sta@PLY	MoveTo,x
      1  625a		       9d 64 fa 	      sta	[RAM]+MoveTo,x
      5  625d		       68		      pla
      0  625e					      sta@PLY	MoveTo,y
      1  625e		       99 64 fa 	      sta	[RAM]+MoveTo,y
      0  6261					      XCHG	MovePiece
      0  6261					      lda@PLY	MovePiece,x
      1  6261		       bd 00 f9 	      lda	MovePiece,x
      2  6264		       48		      pha
      0  6265					      lda@PLY	MovePiece,y
      1  6265		       b9 00 f9 	      lda	MovePiece,y
      0  6268					      sta@PLY	MovePiece,x
      1  6268		       9d 00 fb 	      sta	[RAM]+MovePiece,x
      5  626b		       68		      pla
      0  626c					      sta@PLY	MovePiece,y
      1  626c		       99 00 fb 	      sta	[RAM]+MovePiece,y
      0  626f					      XCHG	MoveCapture
      0  626f					      lda@PLY	MoveCapture,x
      1  626f		       bd 64 f9 	      lda	MoveCapture,x
      2  6272		       48		      pha
      0  6273					      lda@PLY	MoveCapture,y
      1  6273		       b9 64 f9 	      lda	MoveCapture,y
      0  6276					      sta@PLY	MoveCapture,x
      1  6276		       9d 64 fb 	      sta	[RAM]+MoveCapture,x
      5  6279		       68		      pla
      0  627a					      sta@PLY	MoveCapture,y
      1  627a		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    542  627d
    543  627d		       ca		      dex
    544  627e		       10 bd		      bpl	.next
    545  6280
    546  6280				   .exit
    547  6280
    548  6280
    549  6280
    550  6280
    551  6280							; Scan for capture of king
    552  6280							; Also scan for virtual king captures (squares involved in castling)
    553  6280
      0  6280					      ldx@PLY	moveIndex
      1  6280		       ae cf f9 	      ldx	moveIndex
    555  6283		       30 19		      bmi	.notCheck	; OK if no captures in quiesce!
    556  6285
      0  6285				   .scanCheck lda@PLY	MoveCapture,x
      1  6285		       bd 64 f9 	      lda	MoveCapture,x
    558  6288		       29 0f		      and	#PIECE_MASK
    559  628a		       c9 07		      cmp	#KING
    560  628c		       f0 12		      beq	.check
    561  628e
    562  628e							; If the squares the king is crossing for castling are capturable, then that's an illegal
    563  628e							; castle move and it's treated as if the king were in check.
    564  628e
      0  628e					      lda@PLY	MoveTo,x
      1  628e		       bd 64 f8 	      lda	MoveTo,x
      0  6291					      cmp@PLY	virtualKingSquare
      1  6291		       cd da f9 	      cmp	virtualKingSquare
    567  6294		       f0 0a		      beq	.check
      0  6296					      cmp@PLY	virtualKingSquare+1
      1  6296		       cd db f9 	      cmp	virtualKingSquare+1
    569  6299		       f0 05		      beq	.check
    570  629b
    571  629b		       ca	   .nextScan  dex
    572  629c		       10 e7		      bpl	.scanCheck
    573  629e
    574  629e		       a9 00	   .notCheck  lda	#0
    575  62a0		       85 9f	   .check     sta	flagCheck
    576  62a2		       60		      rts
    577  62a3
    578  62a3
    579  62a3							;---------------------------------------------------------------------------------------------------
    580  62a3							; QUIESCE!
    581  62a3
    582  62a3							;int Quiesce( int alpha, int beta ) {
    583  62a3							;    int stand_pat = Evaluate();
    584  62a3							;    if( stand_pat >= beta )
    585  62a3							;	  return beta;
    586  62a3							;    if( alpha < stand_pat )
    587  62a3							;	  alpha = stand_pat;
    588  62a3
    589  62a3							;    until( every_capture_has_been_examined )	{
    590  62a3							;	  MakeCapture();
    591  62a3							;	  score = -Quiesce( -beta, -alpha );
    592  62a3							;	  TakeBackMove();
    593  62a3
    594  62a3							;	  if( score >= beta )
    595  62a3							;	      return beta;
    596  62a3							;	  if( score > alpha )
    597  62a3							;	     alpha = score;
    598  62a3							;    }
    599  62a3							;    return alpha;
    600  62a3							;}
    601  62a3
    602  62a3
    603  62a3							;---------------------------------------------------------------------------------------------------
    604  62a3
      0  62a3					      DEF	quiesce
      1  62a3				   SLOT_quiesce SET	_BANK_SLOT
      2  62a3				   BANK_quiesce SET	SLOT_quiesce + _CURRENT_BANK
      3  62a3				   quiesce
      4  62a3				   TEMPORARY_VAR SET	Overlay
      5  62a3				   TEMPORARY_OFFSET SET	0
      6  62a3				   VAR_BOUNDARY_quiesce SET	TEMPORARY_OFFSET
      7  62a3				   FUNCTION_NAME SET	quiesce
    606  62a3					      SUBROUTINE
    607  62a3
    608  62a3							; pass...
    609  62a3							; x = depthleft
    610  62a3							; SET_BANK_RAM      --> current ply
    611  62a3							; __alpha[2] = param alpha
    612  62a3							; __beta[2] = param beta
    613  62a3
    614  62a3
      0  62a3					      COMMON_VARS
      1  62a3
      0  62a3					      VAR	__thinkbar, 1
      1  62a3		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  62a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  62a3
      4  62a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  62a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  62a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  62a3					      ENDIF
      8  62a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  62a3				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  62a3				  -	      ERR
     11  62a3					      ENDIF
     12  62a3					      LIST	ON
      0  62a3					      VAR	__toggle, 1
      1  62a3		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  62a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  62a3
      4  62a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  62a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  62a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  62a3					      ENDIF
      8  62a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  62a3				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  62a3				  -	      ERR
     11  62a3					      ENDIF
     12  62a3					      LIST	ON
      4  62a3
      0  62a3					      VAR	__bestMove, 1
      1  62a3		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  62a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  62a3
      4  62a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  62a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  62a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  62a3					      ENDIF
      8  62a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  62a3				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  62a3				  -	      ERR
     11  62a3					      ENDIF
     12  62a3					      LIST	ON
      0  62a3					      VAR	__alpha, 2
      1  62a3		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  62a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  62a3
      4  62a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  62a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  62a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  62a3					      ENDIF
      8  62a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  62a3				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  62a3				  -	      ERR
     11  62a3					      ENDIF
     12  62a3					      LIST	ON
      0  62a3					      VAR	__beta, 2
      1  62a3		       00 ac	   __beta     =	TEMPORARY_VAR
      2  62a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  62a3
      4  62a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  62a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  62a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  62a3					      ENDIF
      8  62a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  62a3				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  62a3				  -	      ERR
     11  62a3					      ENDIF
     12  62a3					      LIST	ON
      0  62a3					      VAR	__negaMax, 2
      1  62a3		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  62a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  62a3
      4  62a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  62a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  62a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  62a3					      ENDIF
      8  62a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  62a3				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  62a3				  -	      ERR
     11  62a3					      ENDIF
     12  62a3					      LIST	ON
      0  62a3					      VAR	__value, 2
      1  62a3		       00 b0	   __value    =	TEMPORARY_VAR
      2  62a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  62a3
      4  62a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  62a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  62a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  62a3					      ENDIF
      8  62a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  62a3				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  62a3				  -	      ERR
     11  62a3					      ENDIF
     12  62a3					      LIST	ON
     10  62a3
      0  62a3					      VAR	__quiesceCapOnly, 1
      1  62a3		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  62a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  62a3
      4  62a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  62a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  62a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  62a3					      ENDIF
      8  62a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  62a3				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  62a3				  -	      ERR
     11  62a3					      ENDIF
     12  62a3					      LIST	ON
     12  62a3
      0  62a3					      VAR	__originalPiece, 1
      1  62a3		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  62a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  62a3
      4  62a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  62a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  62a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  62a3					      ENDIF
      8  62a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  62a3				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  62a3				  -	      ERR
     11  62a3					      ENDIF
     12  62a3					      LIST	ON
      0  62a3					      VAR	__capturedPiece, 1
      1  62a3		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  62a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  62a3
      4  62a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  62a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  62a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  62a3					      ENDIF
      8  62a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  62a3				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  62a3				  -	      ERR
     11  62a3					      ENDIF
     12  62a3					      LIST	ON
     15  62a3
      0  62a3					      REFER	negaMax
      1  62a3				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  62a3				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  62a3					      ENDIF
      0  62a3					      VEND	quiesce
      1  62a3				  -	      IFNCONST	quiesce
      2  62a3				  -	      ECHO	"Incorrect VEND label", quiesce
      3  62a3				  -	      ERR
      4  62a3					      ENDIF
      5  62a3		       00 b5	   VAREND_quiesce =	TEMPORARY_VAR
    618  62a3
    619  62a3		       a5 94		      lda	currentPly
    620  62a5		       c9 90		      cmp	#RAMBANK_PLY + PLY_BANKS -1
    621  62a7		       b0 28		      bcs	.retBeta
    622  62a9							;sta SET_BANK_RAM ;tmp
    623  62a9
    624  62a9
    625  62a9		       20 81 f0 	      jsr	ThinkBar	;@0
    626  62ac
    627  62ac		       a5 ac		      lda	__beta
      0  62ae					      sta@PLY	beta
      1  62ae		       8d d4 fb 	      sta	[RAM]+beta
    629  62b1		       a5 ad		      lda	__beta+1
      0  62b3					      sta@PLY	beta+1
      1  62b3		       8d d5 fb 	      sta	[RAM]+beta+1
    631  62b6
    632  62b6		       a5 aa		      lda	__alpha
      0  62b8					      sta@PLY	alpha
      1  62b8		       8d d2 fb 	      sta	[RAM]+alpha
    634  62bb		       a5 ab		      lda	__alpha+1
      0  62bd					      sta@PLY	alpha+1
      1  62bd		       8d d3 fb 	      sta	[RAM]+alpha+1
    636  62c0
    637  62c0
    638  62c0							;    int stand_pat = Evaluate();
    639  62c0							;    if( stand_pat >= beta )
    640  62c0							;	  return beta;
    641  62c0
    642  62c0		       38		      sec
    643  62c1		       a5 8f		      lda	Evaluation
      0  62c3					      sbc@PLY	beta
      1  62c3		       ed d4 f9 	      sbc	beta
    645  62c6		       a5 90		      lda	Evaluation+1
      0  62c8					      sbc@PLY	beta+1
      1  62c8		       ed d5 f9 	      sbc	beta+1
    647  62cb		       50 02		      bvc	.spat0
    648  62cd		       49 80		      eor	#$80
    649  62cf		       30 0b	   .spat0     bmi	.norb	;pl .retBeta			 ; branch if stand_pat >= beta
    650  62d1
    651  62d1		       ad d4 f9    .retBeta   lda	beta
    652  62d4		       85 ae		      sta	__negaMax
    653  62d6		       ad d5 f9 	      lda	beta+1
    654  62d9		       85 af		      sta	__negaMax+1
    655  62db
    656  62db		       60	   .abort     rts
    657  62dc
    658  62dc				   .norb
    659  62dc
    660  62dc
    661  62dc							;    if( alpha < stand_pat )
    662  62dc							;	  alpha = stand_pat;
    663  62dc
    664  62dc		       38		      sec
    665  62dd		       ad d2 f9 	      lda	alpha
    666  62e0		       e5 8f		      sbc	Evaluation
    667  62e2		       ad d3 f9 	      lda	alpha+1
    668  62e5		       e5 90		      sbc	Evaluation+1
    669  62e7		       50 02		      bvc	.spat1
    670  62e9		       49 80		      eor	#$80
    671  62eb		       10 0a	   .spat1     bpl	.alpha	; branch if alpha >= stand_pat
    672  62ed
    673  62ed							; alpha < stand_pat
    674  62ed
    675  62ed		       a5 8f		      lda	Evaluation
      0  62ef					      sta@PLY	alpha
      1  62ef		       8d d2 fb 	      sta	[RAM]+alpha
    677  62f2		       a5 90		      lda	Evaluation+1
      0  62f4					      sta@PLY	alpha+1
      1  62f4		       8d d3 fb 	      sta	[RAM]+alpha+1
    679  62f7
    680  62f7				   .alpha
    681  62f7		       20 9e f1 	      jsr	GenerateAllMoves
    682  62fa		       a5 9f		      lda	flagCheck
    683  62fc		       d0 dd		      bne	.abort	; pure abort
    684  62fe
      0  62fe					      ldx@PLY	moveIndex
      1  62fe		       ae cf f9 	      ldx	moveIndex
    686  6301		       30 76		      bmi	.exit
    687  6303
      0  6303				   .forChild  stx@PLY	movePtr
      1  6303		       8e d0 fb 	      stx	[RAM]+movePtr
    689  6306
    690  6306							; The movelist has captures ONLY (ref: __quiesceCapOnly != 0)
    691  6306
    692  6306		       20 8b f4 	      jsr	MakeMove	;@this
    693  6309
    694  6309		       38		      sec
    695  630a		       a9 00		      lda	#0
      0  630c					      sbc@PLY	beta
      1  630c		       ed d4 f9 	      sbc	beta
    697  630f		       85 aa		      sta	__alpha
    698  6311		       a9 00		      lda	#0
      0  6313					      sbc@PLY	beta+1
      1  6313		       ed d5 f9 	      sbc	beta+1
    700  6316		       85 ab		      sta	__alpha+1
    701  6318
    702  6318		       38		      sec
    703  6319		       a9 00		      lda	#0
      0  631b					      sbc@PLY	alpha
      1  631b		       ed d2 f9 	      sbc	alpha
    705  631e		       85 ac		      sta	__beta
    706  6320		       a9 00		      lda	#0
      0  6322					      sbc@PLY	alpha+1
      1  6322		       ed d3 f9 	      sbc	alpha+1
    708  6325		       85 ad		      sta	__beta+1
    709  6327
    710  6327		       e6 94		      inc	currentPly
    711  6329		       a5 94		      lda	currentPly
    712  632b		       85 3e		      sta	SET_BANK_RAM	; self-switch
    713  632d
    714  632d		       20 a3 f6 	      jsr	quiesce	;@this
    715  6330
    716  6330		       c6 94		      dec	currentPly
    717  6332
    718  6332		       20 a5 f2 	      jsr	unmakeMove	;@0
    719  6335
    720  6335		       a5 9f		      lda	flagCheck	; don't consider moves which leave us in check
    721  6337		       d0 4b		      bne	.inCheck
    722  6339
    723  6339		       38		      sec
    724  633a							;lda #0			 ; already 0
    725  633a		       e5 ae		      sbc	__negaMax
    726  633c		       85 ae		      sta	__negaMax
    727  633e		       a9 00		      lda	#0
    728  6340		       e5 af		      sbc	__negaMax+1
    729  6342		       85 af		      sta	__negaMax+1	; -negaMax(...)
    730  6344
    731  6344
    732  6344
    733  6344							;	  if( score >= beta )
    734  6344							;	      return beta;
    735  6344
    736  6344
    737  6344		       38		      sec
    738  6345		       a5 ae		      lda	__negaMax
      0  6347					      sbc@PLY	beta
      1  6347		       ed d4 f9 	      sbc	beta
    740  634a		       a5 af		      lda	__negaMax+1
      0  634c					      sbc@PLY	beta+1
      1  634c		       ed d5 f9 	      sbc	beta+1
    742  634f		       50 02		      bvc	.lab0
    743  6351		       49 80		      eor	#$80
    744  6353		       30 03	   .lab0      bmi	.nrb2	; .retBeta		       ; branch if score >= beta
    745  6355		       4c d1 f6 	      jmp	.retBeta
    746  6358				   .nrb2
    747  6358
    748  6358							;	  if( score > alpha )
    749  6358							;	     alpha = score;
    750  6358							;    }
    751  6358
    752  6358		       38		      sec
      0  6359					      lda@PLY	alpha
      1  6359		       ad d2 f9 	      lda	alpha
    754  635c		       e5 ae		      sbc	__negaMax
      0  635e					      lda@PLY	alpha+1
      1  635e		       ad d3 f9 	      lda	alpha+1
    756  6361		       e5 af		      sbc	__negaMax+1
    757  6363		       50 02		      bvc	.lab2
    758  6365		       49 80		      eor	#$80
    759  6367		       10 0a	   .lab2      bpl	.nextMove	; alpha >= score
    760  6369
    761  6369							; score > alpha
    762  6369
    763  6369		       a5 ae		      lda	__negaMax
      0  636b					      sta@PLY	alpha
      1  636b		       8d d2 fb 	      sta	[RAM]+alpha
    765  636e		       a5 af		      lda	__negaMax+1
      0  6370					      sta@PLY	alpha+1
      1  6370		       8d d3 fb 	      sta	[RAM]+alpha+1
    767  6373
      0  6373				   .nextMove  ldx@PLY	movePtr
      1  6373		       ae d0 f9 	      ldx	movePtr
    769  6376		       ca		      dex
    770  6377		       10 8a		      bpl	.forChild
    771  6379
    772  6379							;    return alpha;
    773  6379
    774  6379				   .exit
      0  6379					      lda@PLY	alpha
      1  6379		       ad d2 f9 	      lda	alpha
    776  637c		       85 ae		      sta	__negaMax
      0  637e					      lda@PLY	alpha+1
      1  637e		       ad d3 f9 	      lda	alpha+1
    778  6381		       85 af		      sta	__negaMax+1
    779  6383		       60		      rts
    780  6384
    781  6384		       a9 00	   .inCheck   lda	#0
    782  6386		       85 9f		      sta	flagCheck
    783  6388		       f0 e9		      beq	.nextMove
    784  638a
    785  638a
    786  638a							;---------------------------------------------------------------------------------------------------
    787  638a
      0  638a					      CHECK_BANK_SIZE	"NEGAMAX"
      1  638a		       03 8a	   .TEMP      =	* - _BANK_START
 NEGAMAX (1K) SIZE =  $38a , FREE= $76
      2  638a					      ECHO	"NEGAMAX", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  638a				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  638a				  -	      ECHO	"BANK OVERFLOW @ ", "NEGAMAX", " size=", * - ORIGIN
      5  638a				  -	      ERR
      6  638a					      ENDIF
    789  638a
    790  638a							;---------------------------------------------------------------------------------------------------
    791  638a							; EOF
------- FILE ./chess.asm
    613  638a
------- FILE PIECE_MACROS.asm LEVEL 2 PASS 4
      0  638a					      include	"PIECE_MACROS.asm"
      1  638a							; Copyright (C)2020 Andrew Davie
      2  638a							; Common macros for piece move handlers
      3  638a
      4  638a							;---------------------------------------------------------------------------------------------------
      5  638a							; Looks at a square offset {1} to see if piece can move to it
      6  638a							; Adds the square to the movelist if it can
      7  638a							; Keeps moving in the same direction until it's blocked/off=board
      8  638a
      9  638a					      MAC	move_towards
     10  638a					      SUBROUTINE
     11  638a
     12  638a							; = 76 for single square (empty/take)
     13  638a
     14  638a					      lda	#0
     15  638a					      sta	capture
     16  638a
     17  638a					      ldx	currentSquare	; 3
     18  638a					      bne	.project	; 3   unconditional
     19  638a
     20  638a				   .empty     jsr	AddMove	; 57
     21  638a				   .project   ldy	ValidSquare+{1},x	; 4
     22  638a					      bmi	.invalid	; 2/3 off board!
     23  638a					      lda	Board,y	; 4   piece @ destination
     24  638a					      beq	.empty	; 2/3
     25  638a					      sta	capture
     26  638a					      eor	currentPiece	; 3
     27  638a					      bpl	.invalid	; 2/3 same colour
     28  638a					      jsr	AddMove	; 57  and exit
     29  638a
     30  638a				   .invalid
     31  638a					      ENDM
     32  638a
     33  638a
     34  638a							;---------------------------------------------------------------------------------------------------
     35  638a
     36  638a					      MAC	move_to
     37  638a					      SUBROUTINE
     38  638a					      ldy	ValidSquare+{1},x
     39  638a					      bmi	.invalid	; off board!
     40  638a					      lda	Board,y	; piece @ destination
     41  638a					      sta	capture
     42  638a					      beq	.squareEmpty
     43  638a					      eor	currentPiece
     44  638a					      bpl	.invalid	; same colour
     45  638a				   .squareEmpty jsr	AddMove
     46  638a				   .invalid
     47  638a					      ENDM
     48  638a
     49  638a
     50  638a							;---------------------------------------------------------------------------------------------------
     51  638a
     52  638a					      MAC	move_to_x
     53  638a					      ldx	currentSquare
     54  638a					      MOVE_TO	{1}
     55  638a					      ENDM
     56  638a
     57  638a
     58  638a							;---------------------------------------------------------------------------------------------------
     59  638a							; EOF
------- FILE ./chess.asm
    615  638a
------- FILE PIECE_HANDLER@1#1.asm LEVEL 2 PASS 4
      0  638a					      include	"PIECE_HANDLER@1#1.asm"
      0  638a					      SLOT	1
      1  638a				  -	      IF	(1 < 0) || (1 > 3)
      2  638a				  -	      ECHO	"Illegal bank address/segment location", 1
      3  638a				  -	      ERR
      4  638a					      ENDIF
      5  638a				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  638a				   _BANK_SLOT SET	1 * 64
      0  638a					      ROMBANK	PIECE_HANDLER_1
      1  66cc ????				      SEG	PIECE_HANDLER_1
      2  6400					      ORG	_ORIGIN
      3  6400					      RORG	_BANK_ADDRESS_ORIGIN
      4  6400				   _BANK_START SET	*
      5  6400				   PIECE_HANDLER_1_START SET	*
      6  6400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6400				   PIECE_HANDLER_1 SET	_BANK_SLOT + _CURRENT_BANK
      8  6400				   _ORIGIN    SET	_ORIGIN + 1024
      3  6400
------- FILE PIECE_PAWN.asm LEVEL 3 PASS 4
      0  6400					      include	"PIECE_PAWN.asm"
      1  6400							; Copyright (C)2020 Andrew Davie
      2  6400							; Pawn move handlers
      3  6400
      4  6400							;---------------------------------------------------------------------------------------------------
      5  6400							; WHITE PAWN
      6  6400							;---------------------------------------------------------------------------------------------------
      7  6400
      8  6400		       00 28	   WHITE_HOME_ROW =	40	; < this, on home row
      9  6400		       00 52	   BLACK_HOME_ROW =	82	; >= this, on home row
     10  6400
     11  6400							;---------------------------------------------------------------------------------------------------
     12  6400
     13  6400					      MAC	en_passant
     14  6400					      SUBROUTINE
     15  6400							; {1} = _LEFT or _RIGHT
     16  6400
     17  6400					      ldx	currentSquare
     18  6400					      ldy	ValidSquare+{1},x
     19  6400					      cpy	enPassantPawn
     20  6400					      bne	.invalid
     21  6400					      ldy	ValidSquare+{1}+{2},x	; en-passant endpoint must be blank
     22  6400					      lda	Board,y
     23  6400					      bne	.invalid
     24  6400					      jsr	AddMove	; the MOVE will need to deal with the details of en-passant??
     25  6400				   .invalid
     26  6400					      ENDM
     27  6400
     28  6400							;---------------------------------------------------------------------------------------------------
     29  6400
     30  6400					      MAC	promote_pawn
     31  6400							;SUBROUTINE
     32  6400
     33  6400							;{1} = BLACK or WHITE
     34  6400
     35  6400
     36  6400					      sty	__temp
     37  6400					      lda	#{1}|QUEEN
     38  6400					      sta	currentPiece
     39  6400					      jsr	AddMove
     40  6400
     41  6400					      lda	#{1}|ROOK
     42  6400					      sta	currentPiece
     43  6400					      ldy	__temp
     44  6400					      jsr	AddMove
     45  6400
     46  6400					      lda	#{1}|BISHOP
     47  6400					      sta	currentPiece
     48  6400					      ldy	__temp
     49  6400					      jsr	AddMove
     50  6400
     51  6400					      lda	#{1}|KNIGHT
     52  6400					      sta	currentPiece
     53  6400					      ldy	__temp
     54  6400					      jsr	AddMove
     55  6400
     56  6400					      IF	{1} = WHITE
     57  6400					      lda	#WHITE|WP
     58  6400					      ENDIF
     59  6400					      IF	{1} = BLACK
     60  6400					      lda	#BLACK|BP
     61  6400					      ENDIF
     62  6400					      sta	currentPiece
     63  6400					      ENDM
     64  6400
     65  6400							;---------------------------------------------------------------------------------------------------
     66  6400
     67  6400					      MAC	move_or_promote_pawn
     68  6400							;SUBROUTINE
     69  6400							; {1} = BLACK or WHITE
     70  6400
     71  6400					      IF	{1} = WHITE
     72  6400					      cpy	#90	; last rank?
     73  6400					      bcc	.standard
     74  6400					      jsr	PromoteWhitePawn
     75  6400					      jmp	.pMoved
     76  6400					      ENDIF
     77  6400
     78  6400					      IF	{1} = BLACK
     79  6400					      cpy	#30	; last rank?
     80  6400					      bcs	.standard
     81  6400					      jsr	PromoteBlackPawn
     82  6400					      jmp	.pMoved
     83  6400					      ENDIF
     84  6400
     85  6400				   .standard  jsr	AddMove	; add +1UP move
     86  6400				   .pMoved
     87  6400
     88  6400					      ENDM
     89  6400
     90  6400							;---------------------------------------------------------------------------------------------------
     91  6400
     92  6400					      MAC	take
     93  6400							;SUBROUTINE
     94  6400							; {1} = capture square offset
     95  6400
     96  6400					      ldx	currentSquare
     97  6400					      ldy	ValidSquare+{1},x
     98  6400					      bmi	.invalid2
     99  6400					      lda	Board,y
    100  6400					      beq	.invalid2	; square empty
    101  6400					      sta	capture
    102  6400					      eor	currentPiece
    103  6400					      bpl	.invalid	; same colour
    104  6400
    105  6400					      MOVE_OR_PROMOTE_PAWN	{2}
    106  6400
    107  6400					      jmp	.invalid2
    108  6400				   .invalid   inc	protecting
    109  6400				   .invalid2
    110  6400					      ENDM
    111  6400
    112  6400							;---------------------------------------------------------------------------------------------------
    113  6400
      0  6400					      DEF	PromoteWhitePawn
      1  6400				   SLOT_PromoteWhitePawn SET	_BANK_SLOT
      2  6400				   BANK_PromoteWhitePawn SET	SLOT_PromoteWhitePawn + _CURRENT_BANK
      3  6400				   PromoteWhitePawn
      4  6400				   TEMPORARY_VAR SET	Overlay
      5  6400				   TEMPORARY_OFFSET SET	0
      6  6400				   VAR_BOUNDARY_PromoteWhitePawn SET	TEMPORARY_OFFSET
      7  6400				   FUNCTION_NAME SET	PromoteWhitePawn
    115  6400					      SUBROUTINE
    116  6400
      0  6400					      REFER	Handle_WHITE_PAWN
      1  6400					      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  6400				   TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  6400					      ENDIF
      0  6400					      VAR	__temp, 1
      1  6400		       00 b8	   __temp     =	TEMPORARY_VAR
      2  6400				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6400
      4  6400				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6400				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6400				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6400					      ENDIF
      8  6400				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6400				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  6400				  -	      ERR
     11  6400					      ENDIF
     12  6400					      LIST	ON
      0  6400					      VEND	PromoteWhitePawn
      1  6400				  -	      IFNCONST	PromoteWhitePawn
      2  6400				  -	      ECHO	"Incorrect VEND label", PromoteWhitePawn
      3  6400				  -	      ERR
      4  6400					      ENDIF
      5  6400		       00 b9	   VAREND_PromoteWhitePawn =	TEMPORARY_VAR
    120  6400
      0  6400					      PROMOTE_PAWN	WHITE
      1  6400
      2  6400
      3  6400
      4  6400
      5  6400
      6  6400		       84 b8		      sty	__temp
      7  6402		       a9 06		      lda	#WHITE|QUEEN
      8  6404		       85 91		      sta	currentPiece
      9  6406		       20 7d f2 	      jsr	AddMove
     10  6409
     11  6409		       a9 05		      lda	#WHITE|ROOK
     12  640b		       85 91		      sta	currentPiece
     13  640d		       a4 b8		      ldy	__temp
     14  640f		       20 7d f2 	      jsr	AddMove
     15  6412
     16  6412		       a9 04		      lda	#WHITE|BISHOP
     17  6414		       85 91		      sta	currentPiece
     18  6416		       a4 b8		      ldy	__temp
     19  6418		       20 7d f2 	      jsr	AddMove
     20  641b
     21  641b		       a9 03		      lda	#WHITE|KNIGHT
     22  641d		       85 91		      sta	currentPiece
     23  641f		       a4 b8		      ldy	__temp
     24  6421		       20 7d f2 	      jsr	AddMove
     25  6424
     26  6424					      IF	WHITE = WHITE
     27  6424		       a9 01		      lda	#WHITE|WP
     28  6426					      ENDIF
     29  6426				  -	      IF	WHITE = BLACK
     30  6426				  -	      lda	#BLACK|BP
     31  6426					      ENDIF
     32  6426		       85 91		      sta	currentPiece
    122  6428		       60		      rts
    123  6429
    124  6429							;---------------------------------------------------------------------------------------------------
    125  6429
      0  6429					      DEF	Handle_WHITE_PAWN
      1  6429				   SLOT_Handle_WHITE_PAWN SET	_BANK_SLOT
      2  6429				   BANK_Handle_WHITE_PAWN SET	SLOT_Handle_WHITE_PAWN + _CURRENT_BANK
      3  6429				   Handle_WHITE_PAWN
      4  6429				   TEMPORARY_VAR SET	Overlay
      5  6429				   TEMPORARY_OFFSET SET	0
      6  6429				   VAR_BOUNDARY_Handle_WHITE_PAWN SET	TEMPORARY_OFFSET
      7  6429				   FUNCTION_NAME SET	Handle_WHITE_PAWN
    127  6429					      SUBROUTINE
    128  6429
      0  6429					      REFER	GenerateAllMoves
      1  6429					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6429				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6429					      ENDIF
      0  6429					      VEND	Handle_WHITE_PAWN
      1  6429				  -	      IFNCONST	Handle_WHITE_PAWN
      2  6429				  -	      ECHO	"Incorrect VEND label", Handle_WHITE_PAWN
      3  6429				  -	      ERR
      4  6429					      ENDIF
      5  6429		       00 b8	   VAREND_Handle_WHITE_PAWN =	TEMPORARY_VAR
    131  6429
    132  6429		       bc 1f fc 	      ldy	ValidSquare+_UP,x	; square above must be blank (WILL NOT EVER be off-board!)
    133  642c		       b9 79 fc 	      lda	Board,y
    134  642f		       d0 26		      bne	.pMoved	; occupied
    135  6431		       85 9b		      sta	capture
    136  6433
    137  6433							; we may need to promote the pawn
    138  6433							; All possibilites (Q/R/B/N) are added as individual moves
    139  6433
      0  6433					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  6433
      2  6433
      3  6433
      4  6433					      IF	WHITE = WHITE
      5  6433		       c0 5a		      cpy	#90
      6  6435		       90 06		      bcc	.standard
      7  6437		       20 00 f4 	      jsr	PromoteWhitePawn
      8  643a		       4c 40 f4 	      jmp	.pMoved
      9  643d					      ENDIF
     10  643d
     11  643d				  -	      IF	WHITE = BLACK
     12  643d				  -	      cpy	#30
     13  643d				  -	      bcs	.standard
     14  643d				  -	      jsr	PromoteBlackPawn
     15  643d				  -	      jmp	.pMoved
     16  643d					      ENDIF
     17  643d
     18  643d		       20 7d f2    .standard  jsr	AddMove
     19  6440				   .pMoved
     20  6440
    141  6440
    142  6440							; the +2 move off the home rank...
    143  6440
    144  6440		       a6 92		      ldx	currentSquare
    145  6442		       e0 28		      cpx	#WHITE_HOME_ROW
    146  6444		       b0 11		      bcs	.pMoved	; pawn has moved so can't do +2
    147  6446		       bc 29 fc 	      ldy	ValidSquare+_UP+_UP,x	; WILL be a valid square
    148  6449		       b9 79 fc 	      lda	Board,y
    149  644c		       d0 09		      bne	.pMoved	; destination square occupied
    150  644e
    151  644e		       a5 91		      lda	currentPiece
    152  6450		       09 20		      ora	#FLAG_ENPASSANT
    153  6452		       85 91		      sta	currentPiece	; GENERATE en-passant opportunity
    154  6454
    155  6454		       20 7d f2 	      jsr	AddMove	; add the +2UP move off home row
    156  6457
    157  6457				   .pMoved
    158  6457
    159  6457							; regular captures...
    160  6457
      0  6457					      TAKE	_UP+_LEFT, WHITE
      1  6457
      2  6457
      3  6457
      4  6457		       a6 92		      ldx	currentSquare
      5  6459		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      6  645c		       30 1d		      bmi	.invalid2
      7  645e		       b9 79 fc 	      lda	Board,y
      8  6461		       f0 18		      beq	.invalid2
      9  6463		       85 9b		      sta	capture
     10  6465		       45 91		      eor	currentPiece
     11  6467		       10 10		      bpl	.invalid
     12  6469
      0  6469					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  6469
      2  6469
      3  6469
      4  6469					      IF	WHITE = WHITE
      5  6469		       c0 5a		      cpy	#90
      6  646b		       90 06		      bcc	.standard
      7  646d		       20 00 f4 	      jsr	PromoteWhitePawn
      8  6470		       4c 76 f4 	      jmp	.pMoved
      9  6473					      ENDIF
     10  6473
     11  6473				  -	      IF	WHITE = BLACK
     12  6473				  -	      cpy	#30
     13  6473				  -	      bcs	.standard
     14  6473				  -	      jsr	PromoteBlackPawn
     15  6473				  -	      jmp	.pMoved
     16  6473					      ENDIF
     17  6473
     18  6473		       20 7d f2    .standard  jsr	AddMove
     19  6476				   .pMoved
     20  6476
     14  6476
     15  6476		       4c 7b f4 	      jmp	.invalid2
     16  6479		       e6 a0	   .invalid   inc	protecting
     17  647b				   .invalid2
      0  647b					      TAKE	_UP+_RIGHT, WHITE
      1  647b
      2  647b
      3  647b
      4  647b		       a6 92		      ldx	currentSquare
      5  647d		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      6  6480		       30 1d		      bmi	.invalid2
      7  6482		       b9 79 fc 	      lda	Board,y
      8  6485		       f0 18		      beq	.invalid2
      9  6487		       85 9b		      sta	capture
     10  6489		       45 91		      eor	currentPiece
     11  648b		       10 10		      bpl	.invalid
     12  648d
      0  648d					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  648d
      2  648d
      3  648d
      4  648d					      IF	WHITE = WHITE
      5  648d		       c0 5a		      cpy	#90
      6  648f		       90 06		      bcc	.standard
      7  6491		       20 00 f4 	      jsr	PromoteWhitePawn
      8  6494		       4c 9a f4 	      jmp	.pMoved
      9  6497					      ENDIF
     10  6497
     11  6497				  -	      IF	WHITE = BLACK
     12  6497				  -	      cpy	#30
     13  6497				  -	      bcs	.standard
     14  6497				  -	      jsr	PromoteBlackPawn
     15  6497				  -	      jmp	.pMoved
     16  6497					      ENDIF
     17  6497
     18  6497		       20 7d f2    .standard  jsr	AddMove
     19  649a				   .pMoved
     20  649a
     14  649a
     15  649a		       4c 9f f4 	      jmp	.invalid2
     16  649d		       e6 a0	   .invalid   inc	protecting
     17  649f				   .invalid2
    163  649f
    164  649f
    165  649f					      IF	ENPASSANT_ENABLED
    166  649f							; en-passant captures...
    167  649f
    168  649f		       a5 93		      lda	enPassantPawn
    169  64a1		       f0 2e		      beq	.noEnPassant	; previous move (opponent) enpassant square?
    170  64a3
    171  64a3		       a5 91		      lda	currentPiece
    172  64a5		       09 20		      ora	#FLAG_ENPASSANT
    173  64a7		       85 91		      sta	currentPiece	; CONSUME en-passant opportunity
    174  64a9
      0  64a9					      EN_PASSANT	_LEFT, _UP
      1  64a9					      SUBROUTINE
      2  64a9
      3  64a9
      4  64a9		       a6 92		      ldx	currentSquare
      5  64ab		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      6  64ae		       c4 93		      cpy	enPassantPawn
      7  64b0		       d0 0b		      bne	.invalid
      8  64b2		       bc 1e fc 	      ldy	ValidSquare+_LEFT+_UP,x
      9  64b5		       b9 79 fc 	      lda	Board,y
     10  64b8		       d0 03		      bne	.invalid
     11  64ba		       20 7d f2 	      jsr	AddMove
     12  64bd				   .invalid
      0  64bd					      EN_PASSANT	_RIGHT, _UP
      1  64bd					      SUBROUTINE
      2  64bd
      3  64bd
      4  64bd		       a6 92		      ldx	currentSquare
      5  64bf		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      6  64c2		       c4 93		      cpy	enPassantPawn
      7  64c4		       d0 0b		      bne	.invalid
      8  64c6		       bc 20 fc 	      ldy	ValidSquare+_RIGHT+_UP,x
      9  64c9		       b9 79 fc 	      lda	Board,y
     10  64cc		       d0 03		      bne	.invalid
     11  64ce		       20 7d f2 	      jsr	AddMove
     12  64d1				   .invalid
    177  64d1
    178  64d1				   .noEnPassant
    179  64d1					      ENDIF
    180  64d1
    181  64d1		       4c e0 f1 	      jmp	MoveReturn
    182  64d4
    183  64d4
    184  64d4							;---------------------------------------------------------------------------------------------------
    185  64d4							; BLACK PAWN
    186  64d4							;---------------------------------------------------------------------------------------------------
    187  64d4
      0  64d4					      DEF	PromoteBlackPawn
      1  64d4				   SLOT_PromoteBlackPawn SET	_BANK_SLOT
      2  64d4				   BANK_PromoteBlackPawn SET	SLOT_PromoteBlackPawn + _CURRENT_BANK
      3  64d4				   PromoteBlackPawn
      4  64d4				   TEMPORARY_VAR SET	Overlay
      5  64d4				   TEMPORARY_OFFSET SET	0
      6  64d4				   VAR_BOUNDARY_PromoteBlackPawn SET	TEMPORARY_OFFSET
      7  64d4				   FUNCTION_NAME SET	PromoteBlackPawn
    189  64d4					      SUBROUTINE
    190  64d4
      0  64d4					      REFER	Handle_BLACK_PAWN
      1  64d4					      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  64d4				   TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  64d4					      ENDIF
      0  64d4					      VAR	__temp, 1
      1  64d4		       00 b8	   __temp     =	TEMPORARY_VAR
      2  64d4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  64d4
      4  64d4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  64d4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  64d4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  64d4					      ENDIF
      8  64d4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  64d4				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  64d4				  -	      ERR
     11  64d4					      ENDIF
     12  64d4					      LIST	ON
      0  64d4					      VEND	PromoteBlackPawn
      1  64d4				  -	      IFNCONST	PromoteBlackPawn
      2  64d4				  -	      ECHO	"Incorrect VEND label", PromoteBlackPawn
      3  64d4				  -	      ERR
      4  64d4					      ENDIF
      5  64d4		       00 b9	   VAREND_PromoteBlackPawn =	TEMPORARY_VAR
    194  64d4
      0  64d4					      PROMOTE_PAWN	BLACK
      1  64d4
      2  64d4
      3  64d4
      4  64d4
      5  64d4
      6  64d4		       84 b8		      sty	__temp
      7  64d6		       a9 86		      lda	#BLACK|QUEEN
      8  64d8		       85 91		      sta	currentPiece
      9  64da		       20 7d f2 	      jsr	AddMove
     10  64dd
     11  64dd		       a9 85		      lda	#BLACK|ROOK
     12  64df		       85 91		      sta	currentPiece
     13  64e1		       a4 b8		      ldy	__temp
     14  64e3		       20 7d f2 	      jsr	AddMove
     15  64e6
     16  64e6		       a9 84		      lda	#BLACK|BISHOP
     17  64e8		       85 91		      sta	currentPiece
     18  64ea		       a4 b8		      ldy	__temp
     19  64ec		       20 7d f2 	      jsr	AddMove
     20  64ef
     21  64ef		       a9 83		      lda	#BLACK|KNIGHT
     22  64f1		       85 91		      sta	currentPiece
     23  64f3		       a4 b8		      ldy	__temp
     24  64f5		       20 7d f2 	      jsr	AddMove
     25  64f8
     26  64f8				  -	      IF	BLACK = WHITE
     27  64f8				  -	      lda	#WHITE|WP
     28  64f8					      ENDIF
     29  64f8					      IF	BLACK = BLACK
     30  64f8		       a9 82		      lda	#BLACK|BP
     31  64fa					      ENDIF
     32  64fa		       85 91		      sta	currentPiece
    196  64fc		       60		      rts
    197  64fd
      0  64fd					      DEF	Handle_BLACK_PAWN
      1  64fd				   SLOT_Handle_BLACK_PAWN SET	_BANK_SLOT
      2  64fd				   BANK_Handle_BLACK_PAWN SET	SLOT_Handle_BLACK_PAWN + _CURRENT_BANK
      3  64fd				   Handle_BLACK_PAWN
      4  64fd				   TEMPORARY_VAR SET	Overlay
      5  64fd				   TEMPORARY_OFFSET SET	0
      6  64fd				   VAR_BOUNDARY_Handle_BLACK_PAWN SET	TEMPORARY_OFFSET
      7  64fd				   FUNCTION_NAME SET	Handle_BLACK_PAWN
    199  64fd					      SUBROUTINE
    200  64fd
      0  64fd					      REFER	GenerateAllMoves
      1  64fd					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  64fd				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  64fd					      ENDIF
      0  64fd					      VEND	Handle_BLACK_PAWN
      1  64fd				  -	      IFNCONST	Handle_BLACK_PAWN
      2  64fd				  -	      ECHO	"Incorrect VEND label", Handle_BLACK_PAWN
      3  64fd				  -	      ERR
      4  64fd					      ENDIF
      5  64fd		       00 b8	   VAREND_Handle_BLACK_PAWN =	TEMPORARY_VAR
    203  64fd
    204  64fd		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x	; square below must be blank (WILL NOT EVER be off-board!)
    205  6500		       b9 79 fc 	      lda	Board,y
    206  6503		       d0 26		      bne	.pMoved	; occupied
    207  6505		       85 9b		      sta	capture
    208  6507
    209  6507							; we may need to promote the pawn
    210  6507							; All possibilites (Q/R/B/N) are added as individual moves
    211  6507
      0  6507					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  6507
      2  6507
      3  6507
      4  6507				  -	      IF	BLACK = WHITE
      5  6507				  -	      cpy	#90
      6  6507				  -	      bcc	.standard
      7  6507				  -	      jsr	PromoteWhitePawn
      8  6507				  -	      jmp	.pMoved
      9  6507					      ENDIF
     10  6507
     11  6507					      IF	BLACK = BLACK
     12  6507		       c0 1e		      cpy	#30
     13  6509		       b0 06		      bcs	.standard
     14  650b		       20 d4 f4 	      jsr	PromoteBlackPawn
     15  650e		       4c 14 f5 	      jmp	.pMoved
     16  6511					      ENDIF
     17  6511
     18  6511		       20 7d f2    .standard  jsr	AddMove
     19  6514				   .pMoved
     20  6514
    213  6514
    214  6514							; the +2 move off the home rank...
    215  6514
    216  6514		       a6 92		      ldx	currentSquare
    217  6516		       e0 52		      cpx	#BLACK_HOME_ROW
    218  6518		       90 11		      bcc	.pMoved	; pawn has moved so can't do +2
    219  651a
    220  651a
    221  651a		       bc 01 fc 	      ldy	ValidSquare+_DOWN+_DOWN,x	; WILL be a valid square
    222  651d		       b9 79 fc 	      lda	Board,y
    223  6520		       d0 09		      bne	.pMoved	; destination square occupied
    224  6522
    225  6522		       a5 91		      lda	currentPiece
    226  6524		       09 20		      ora	#FLAG_ENPASSANT
    227  6526		       85 91		      sta	currentPiece	; CAN en-passant
    228  6528
    229  6528		       20 7d f2 	      jsr	AddMove	; add the +2DOWN move off home row
    230  652b
    231  652b				   .pMoved
    232  652b
    233  652b							; regular captures... (with promotion)
    234  652b
      0  652b					      TAKE	_DOWN+_LEFT, BLACK
      1  652b
      2  652b
      3  652b
      4  652b		       a6 92		      ldx	currentSquare
      5  652d		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      6  6530		       30 1d		      bmi	.invalid2
      7  6532		       b9 79 fc 	      lda	Board,y
      8  6535		       f0 18		      beq	.invalid2
      9  6537		       85 9b		      sta	capture
     10  6539		       45 91		      eor	currentPiece
     11  653b		       10 10		      bpl	.invalid
     12  653d
      0  653d					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  653d
      2  653d
      3  653d
      4  653d				  -	      IF	BLACK = WHITE
      5  653d				  -	      cpy	#90
      6  653d				  -	      bcc	.standard
      7  653d				  -	      jsr	PromoteWhitePawn
      8  653d				  -	      jmp	.pMoved
      9  653d					      ENDIF
     10  653d
     11  653d					      IF	BLACK = BLACK
     12  653d		       c0 1e		      cpy	#30
     13  653f		       b0 06		      bcs	.standard
     14  6541		       20 d4 f4 	      jsr	PromoteBlackPawn
     15  6544		       4c 4a f5 	      jmp	.pMoved
     16  6547					      ENDIF
     17  6547
     18  6547		       20 7d f2    .standard  jsr	AddMove
     19  654a				   .pMoved
     20  654a
     14  654a
     15  654a		       4c 4f f5 	      jmp	.invalid2
     16  654d		       e6 a0	   .invalid   inc	protecting
     17  654f				   .invalid2
      0  654f					      TAKE	_DOWN+_RIGHT, BLACK
      1  654f
      2  654f
      3  654f
      4  654f		       a6 92		      ldx	currentSquare
      5  6551		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      6  6554		       30 1d		      bmi	.invalid2
      7  6556		       b9 79 fc 	      lda	Board,y
      8  6559		       f0 18		      beq	.invalid2
      9  655b		       85 9b		      sta	capture
     10  655d		       45 91		      eor	currentPiece
     11  655f		       10 10		      bpl	.invalid
     12  6561
      0  6561					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  6561
      2  6561
      3  6561
      4  6561				  -	      IF	BLACK = WHITE
      5  6561				  -	      cpy	#90
      6  6561				  -	      bcc	.standard
      7  6561				  -	      jsr	PromoteWhitePawn
      8  6561				  -	      jmp	.pMoved
      9  6561					      ENDIF
     10  6561
     11  6561					      IF	BLACK = BLACK
     12  6561		       c0 1e		      cpy	#30
     13  6563		       b0 06		      bcs	.standard
     14  6565		       20 d4 f4 	      jsr	PromoteBlackPawn
     15  6568		       4c 6e f5 	      jmp	.pMoved
     16  656b					      ENDIF
     17  656b
     18  656b		       20 7d f2    .standard  jsr	AddMove
     19  656e				   .pMoved
     20  656e
     14  656e
     15  656e		       4c 73 f5 	      jmp	.invalid2
     16  6571		       e6 a0	   .invalid   inc	protecting
     17  6573				   .invalid2
    237  6573
    238  6573
    239  6573					      IF	ENPASSANT_ENABLED
    240  6573							; en-passant captures...
    241  6573
    242  6573		       a5 93		      lda	enPassantPawn
    243  6575		       f0 2e		      beq	.noEnPassant	; was last move en-passantable?
    244  6577
    245  6577		       a5 91		      lda	currentPiece
    246  6579		       09 20		      ora	#FLAG_ENPASSANT
    247  657b		       85 91		      sta	currentPiece	; any en-passant move added will have flag set
    248  657d
      0  657d					      EN_PASSANT	_LEFT, _DOWN
      1  657d					      SUBROUTINE
      2  657d
      3  657d
      4  657d		       a6 92		      ldx	currentSquare
      5  657f		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      6  6582		       c4 93		      cpy	enPassantPawn
      7  6584		       d0 0b		      bne	.invalid
      8  6586		       bc 0a fc 	      ldy	ValidSquare+_LEFT+_DOWN,x
      9  6589		       b9 79 fc 	      lda	Board,y
     10  658c		       d0 03		      bne	.invalid
     11  658e		       20 7d f2 	      jsr	AddMove
     12  6591				   .invalid
      0  6591					      EN_PASSANT	_RIGHT, _DOWN
      1  6591					      SUBROUTINE
      2  6591
      3  6591
      4  6591		       a6 92		      ldx	currentSquare
      5  6593		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      6  6596		       c4 93		      cpy	enPassantPawn
      7  6598		       d0 0b		      bne	.invalid
      8  659a		       bc 0c fc 	      ldy	ValidSquare+_RIGHT+_DOWN,x
      9  659d		       b9 79 fc 	      lda	Board,y
     10  65a0		       d0 03		      bne	.invalid
     11  65a2		       20 7d f2 	      jsr	AddMove
     12  65a5				   .invalid
    251  65a5
    252  65a5				   .noEnPassant
    253  65a5					      ENDIF
    254  65a5
    255  65a5		       4c e0 f1 	      jmp	MoveReturn
    256  65a8
    257  65a8							; EOF
------- FILE PIECE_HANDLER@1#1.asm
------- FILE PIECE_KNIGHT.asm LEVEL 3 PASS 4
      0  65a8					      include	"PIECE_KNIGHT.asm"
      1  65a8							; Copyright (C)2020 Andrew Davie
      2  65a8							; Knight move handler
      3  65a8
      4  65a8							;---------------------------------------------------------------------------------------------------
      5  65a8							; KNIGHT
      6  65a8							;---------------------------------------------------------------------------------------------------
      7  65a8
      0  65a8					      DEF	Handle_KNIGHT
      1  65a8				   SLOT_Handle_KNIGHT SET	_BANK_SLOT
      2  65a8				   BANK_Handle_KNIGHT SET	SLOT_Handle_KNIGHT + _CURRENT_BANK
      3  65a8				   Handle_KNIGHT
      4  65a8				   TEMPORARY_VAR SET	Overlay
      5  65a8				   TEMPORARY_OFFSET SET	0
      6  65a8				   VAR_BOUNDARY_Handle_KNIGHT SET	TEMPORARY_OFFSET
      7  65a8				   FUNCTION_NAME SET	Handle_KNIGHT
      9  65a8					      SUBROUTINE
     10  65a8
      0  65a8					      REFER	GenerateAllMoves	;✅
      1  65a8					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  65a8				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  65a8					      ENDIF
      0  65a8					      VEND	Handle_KNIGHT
      1  65a8				  -	      IFNCONST	Handle_KNIGHT
      2  65a8				  -	      ECHO	"Incorrect VEND label", Handle_KNIGHT
      3  65a8				  -	      ERR
      4  65a8					      ENDIF
      5  65a8		       00 b8	   VAREND_Handle_KNIGHT =	TEMPORARY_VAR
     13  65a8
     14  65a8							; x = currentSquare (square the piece is on)
     15  65a8							; currentPiece (with flags/colour attached)
     16  65a8
      0  65a8					      MOVE_TO	_DOWN+_DOWN+_LEFT
      1  65a8					      SUBROUTINE
      2  65a8		       bc 00 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_LEFT,x
      3  65ab		       30 0e		      bmi	.invalid
      4  65ad		       b9 79 fc 	      lda	Board,y
      5  65b0		       85 9b		      sta	capture
      6  65b2		       f0 04		      beq	.squareEmpty
      7  65b4		       45 91		      eor	currentPiece
      8  65b6		       10 03		      bpl	.invalid
      9  65b8		       20 7d f2    .squareEmpty jsr	AddMove
     10  65bb				   .invalid
      0  65bb					      MOVE_TO_X	_DOWN+_DOWN+_RIGHT
      1  65bb		       a6 92		      ldx	currentSquare
      0  65bd					      MOVE_TO	_DOWN+_DOWN+_RIGHT
      1  65bd					      SUBROUTINE
      2  65bd		       bc 02 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_RIGHT,x
      3  65c0		       30 0e		      bmi	.invalid
      4  65c2		       b9 79 fc 	      lda	Board,y
      5  65c5		       85 9b		      sta	capture
      6  65c7		       f0 04		      beq	.squareEmpty
      7  65c9		       45 91		      eor	currentPiece
      8  65cb		       10 03		      bpl	.invalid
      9  65cd		       20 7d f2    .squareEmpty jsr	AddMove
     10  65d0				   .invalid
      0  65d0					      MOVE_TO_X	_UP+_UP+_LEFT
      1  65d0		       a6 92		      ldx	currentSquare
      0  65d2					      MOVE_TO	_UP+_UP+_LEFT
      1  65d2					      SUBROUTINE
      2  65d2		       bc 28 fc 	      ldy	ValidSquare+_UP+_UP+_LEFT,x
      3  65d5		       30 0e		      bmi	.invalid
      4  65d7		       b9 79 fc 	      lda	Board,y
      5  65da		       85 9b		      sta	capture
      6  65dc		       f0 04		      beq	.squareEmpty
      7  65de		       45 91		      eor	currentPiece
      8  65e0		       10 03		      bpl	.invalid
      9  65e2		       20 7d f2    .squareEmpty jsr	AddMove
     10  65e5				   .invalid
      0  65e5					      MOVE_TO_X	_UP+_UP+_RIGHT
      1  65e5		       a6 92		      ldx	currentSquare
      0  65e7					      MOVE_TO	_UP+_UP+_RIGHT
      1  65e7					      SUBROUTINE
      2  65e7		       bc 2a fc 	      ldy	ValidSquare+_UP+_UP+_RIGHT,x
      3  65ea		       30 0e		      bmi	.invalid
      4  65ec		       b9 79 fc 	      lda	Board,y
      5  65ef		       85 9b		      sta	capture
      6  65f1		       f0 04		      beq	.squareEmpty
      7  65f3		       45 91		      eor	currentPiece
      8  65f5		       10 03		      bpl	.invalid
      9  65f7		       20 7d f2    .squareEmpty jsr	AddMove
     10  65fa				   .invalid
     21  65fa
      0  65fa					      MOVE_TO_X	_DOWN+_LEFT+_LEFT
      1  65fa		       a6 92		      ldx	currentSquare
      0  65fc					      MOVE_TO	_DOWN+_LEFT+_LEFT
      1  65fc					      SUBROUTINE
      2  65fc		       bc 09 fc 	      ldy	ValidSquare+_DOWN+_LEFT+_LEFT,x
      3  65ff		       30 0e		      bmi	.invalid
      4  6601		       b9 79 fc 	      lda	Board,y
      5  6604		       85 9b		      sta	capture
      6  6606		       f0 04		      beq	.squareEmpty
      7  6608		       45 91		      eor	currentPiece
      8  660a		       10 03		      bpl	.invalid
      9  660c		       20 7d f2    .squareEmpty jsr	AddMove
     10  660f				   .invalid
      0  660f					      MOVE_TO_X	_DOWN+_RIGHT+_RIGHT
      1  660f		       a6 92		      ldx	currentSquare
      0  6611					      MOVE_TO	_DOWN+_RIGHT+_RIGHT
      1  6611					      SUBROUTINE
      2  6611		       bc 0d fc 	      ldy	ValidSquare+_DOWN+_RIGHT+_RIGHT,x
      3  6614		       30 0e		      bmi	.invalid
      4  6616		       b9 79 fc 	      lda	Board,y
      5  6619		       85 9b		      sta	capture
      6  661b		       f0 04		      beq	.squareEmpty
      7  661d		       45 91		      eor	currentPiece
      8  661f		       10 03		      bpl	.invalid
      9  6621		       20 7d f2    .squareEmpty jsr	AddMove
     10  6624				   .invalid
      0  6624					      MOVE_TO_X	_UP+_LEFT+_LEFT
      1  6624		       a6 92		      ldx	currentSquare
      0  6626					      MOVE_TO	_UP+_LEFT+_LEFT
      1  6626					      SUBROUTINE
      2  6626		       bc 1d fc 	      ldy	ValidSquare+_UP+_LEFT+_LEFT,x
      3  6629		       30 0e		      bmi	.invalid
      4  662b		       b9 79 fc 	      lda	Board,y
      5  662e		       85 9b		      sta	capture
      6  6630		       f0 04		      beq	.squareEmpty
      7  6632		       45 91		      eor	currentPiece
      8  6634		       10 03		      bpl	.invalid
      9  6636		       20 7d f2    .squareEmpty jsr	AddMove
     10  6639				   .invalid
      0  6639					      MOVE_TO_X	_UP+_RIGHT+_RIGHT
      1  6639		       a6 92		      ldx	currentSquare
      0  663b					      MOVE_TO	_UP+_RIGHT+_RIGHT
      1  663b					      SUBROUTINE
      2  663b		       bc 21 fc 	      ldy	ValidSquare+_UP+_RIGHT+_RIGHT,x
      3  663e		       30 0e		      bmi	.invalid
      4  6640		       b9 79 fc 	      lda	Board,y
      5  6643		       85 9b		      sta	capture
      6  6645		       f0 04		      beq	.squareEmpty
      7  6647		       45 91		      eor	currentPiece
      8  6649		       10 03		      bpl	.invalid
      9  664b		       20 7d f2    .squareEmpty jsr	AddMove
     10  664e				   .invalid
     26  664e
     27  664e		       4c e0 f1 	      jmp	MoveReturn
     28  6651
     29  6651							; EOF
------- FILE PIECE_HANDLER@1#1.asm
------- FILE PIECE_BISHOP.asm LEVEL 3 PASS 4
      0  6651					      include	"PIECE_BISHOP.asm"
      1  6651							; Copyright (C)2020 Andrew Davie
      2  6651
      3  6651							;---------------------------------------------------------------------------------------------------
      4  6651							; BISHOP
      5  6651							;---------------------------------------------------------------------------------------------------
      6  6651
      0  6651					      DEF	Handle_BISHOP
      1  6651				   SLOT_Handle_BISHOP SET	_BANK_SLOT
      2  6651				   BANK_Handle_BISHOP SET	SLOT_Handle_BISHOP + _CURRENT_BANK
      3  6651				   Handle_BISHOP
      4  6651				   TEMPORARY_VAR SET	Overlay
      5  6651				   TEMPORARY_OFFSET SET	0
      6  6651				   VAR_BOUNDARY_Handle_BISHOP SET	TEMPORARY_OFFSET
      7  6651				   FUNCTION_NAME SET	Handle_BISHOP
      8  6651					      SUBROUTINE
      9  6651
      0  6651					      REFER	GenerateAllMoves	;✅
      1  6651					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6651				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6651					      ENDIF
      0  6651					      VEND	Handle_BISHOP
      1  6651				  -	      IFNCONST	Handle_BISHOP
      2  6651				  -	      ECHO	"Incorrect VEND label", Handle_BISHOP
      3  6651				  -	      ERR
      4  6651					      ENDIF
      5  6651		       00 b8	   VAREND_Handle_BISHOP =	TEMPORARY_VAR
     12  6651
     13  6651							; x = currentSquare (square the piece is on)
     14  6651							; currentPiece (with flags/colour attached)
     15  6651
      0  6651					      MOVE_TOWARDS	_DOWN+_LEFT
      1  6651					      SUBROUTINE
      2  6651
      3  6651
      4  6651
      5  6651		       a9 00		      lda	#0
      6  6653		       85 9b		      sta	capture
      7  6655
      8  6655		       a6 92		      ldx	currentSquare
      9  6657		       d0 03		      bne	.project
     10  6659
     11  6659		       20 7d f2    .empty     jsr	AddMove
     12  665c		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  665f		       30 0e		      bmi	.invalid
     14  6661		       b9 79 fc 	      lda	Board,y
     15  6664		       f0 f3		      beq	.empty
     16  6666		       85 9b		      sta	capture
     17  6668		       45 91		      eor	currentPiece
     18  666a		       10 03		      bpl	.invalid
     19  666c		       20 7d f2 	      jsr	AddMove
     20  666f
     21  666f				   .invalid
      0  666f					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  666f					      SUBROUTINE
      2  666f
      3  666f
      4  666f
      5  666f		       a9 00		      lda	#0
      6  6671		       85 9b		      sta	capture
      7  6673
      8  6673		       a6 92		      ldx	currentSquare
      9  6675		       d0 03		      bne	.project
     10  6677
     11  6677		       20 7d f2    .empty     jsr	AddMove
     12  667a		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  667d		       30 0e		      bmi	.invalid
     14  667f		       b9 79 fc 	      lda	Board,y
     15  6682		       f0 f3		      beq	.empty
     16  6684		       85 9b		      sta	capture
     17  6686		       45 91		      eor	currentPiece
     18  6688		       10 03		      bpl	.invalid
     19  668a		       20 7d f2 	      jsr	AddMove
     20  668d
     21  668d				   .invalid
      0  668d					      MOVE_TOWARDS	_UP+_LEFT
      1  668d					      SUBROUTINE
      2  668d
      3  668d
      4  668d
      5  668d		       a9 00		      lda	#0
      6  668f		       85 9b		      sta	capture
      7  6691
      8  6691		       a6 92		      ldx	currentSquare
      9  6693		       d0 03		      bne	.project
     10  6695
     11  6695		       20 7d f2    .empty     jsr	AddMove
     12  6698		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  669b		       30 0e		      bmi	.invalid
     14  669d		       b9 79 fc 	      lda	Board,y
     15  66a0		       f0 f3		      beq	.empty
     16  66a2		       85 9b		      sta	capture
     17  66a4		       45 91		      eor	currentPiece
     18  66a6		       10 03		      bpl	.invalid
     19  66a8		       20 7d f2 	      jsr	AddMove
     20  66ab
     21  66ab				   .invalid
      0  66ab					      MOVE_TOWARDS	_UP+_RIGHT
      1  66ab					      SUBROUTINE
      2  66ab
      3  66ab
      4  66ab
      5  66ab		       a9 00		      lda	#0
      6  66ad		       85 9b		      sta	capture
      7  66af
      8  66af		       a6 92		      ldx	currentSquare
      9  66b1		       d0 03		      bne	.project
     10  66b3
     11  66b3		       20 7d f2    .empty     jsr	AddMove
     12  66b6		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  66b9		       30 0e		      bmi	.invalid
     14  66bb		       b9 79 fc 	      lda	Board,y
     15  66be		       f0 f3		      beq	.empty
     16  66c0		       85 9b		      sta	capture
     17  66c2		       45 91		      eor	currentPiece
     18  66c4		       10 03		      bpl	.invalid
     19  66c6		       20 7d f2 	      jsr	AddMove
     20  66c9
     21  66c9				   .invalid
     20  66c9
     21  66c9		       4c e0 f1 	      jmp	MoveReturn
     22  66cc
     23  66cc							;---------------------------------------------------------------------------------------------------
     24  66cc							; EOF
------- FILE PIECE_HANDLER@1#1.asm
      7  66cc
      8  66cc							;---------------------------------------------------------------------------------------------------
      9  66cc
      0  66cc					      CHECK_BANK_SIZE	"PIECE_HANDLER_1"
      1  66cc		       02 cc	   .TEMP      =	* - _BANK_START
 PIECE_HANDLER_1 (1K) SIZE =  $2cc , FREE= $134
      2  66cc					      ECHO	"PIECE_HANDLER_1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  66cc				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  66cc				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_HANDLER_1", " size=", * - ORIGIN
      5  66cc				  -	      ERR
      6  66cc					      ENDIF
     11  66cc
     12  66cc							;---------------------------------------------------------------------------------------------------
     13  66cc							; EOF
------- FILE ./chess.asm
------- FILE PIECE_HANDLER@1#2.asm LEVEL 2 PASS 4
      0  66cc					      include	"PIECE_HANDLER@1#2.asm"
      0  66cc					      SLOT	1
      1  66cc				  -	      IF	(1 < 0) || (1 > 3)
      2  66cc				  -	      ECHO	"Illegal bank address/segment location", 1
      3  66cc				  -	      ERR
      4  66cc					      ENDIF
      5  66cc				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  66cc				   _BANK_SLOT SET	1 * 64
      0  66cc					      ROMBANK	PIECE_HANDLER_2
      1  6a5c ????				      SEG	PIECE_HANDLER_2
      2  6800					      ORG	_ORIGIN
      3  6800					      RORG	_BANK_ADDRESS_ORIGIN
      4  6800				   _BANK_START SET	*
      5  6800				   PIECE_HANDLER_2_START SET	*
      6  6800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6800				   PIECE_HANDLER_2 SET	_BANK_SLOT + _CURRENT_BANK
      8  6800				   _ORIGIN    SET	_ORIGIN + 1024
      3  6800
------- FILE PIECE_ROOK.asm LEVEL 3 PASS 4
      0  6800					      include	"PIECE_ROOK.asm"
      1  6800							; Copyright (C)2020 Andrew Davie
      2  6800							; Rook move handler
      3  6800
      4  6800							;---------------------------------------------------------------------------------------------------
      5  6800							; ROOK
      6  6800							;---------------------------------------------------------------------------------------------------
      7  6800
      0  6800					      DEF	Handle_ROOK
      1  6800				   SLOT_Handle_ROOK SET	_BANK_SLOT
      2  6800				   BANK_Handle_ROOK SET	SLOT_Handle_ROOK + _CURRENT_BANK
      3  6800				   Handle_ROOK
      4  6800				   TEMPORARY_VAR SET	Overlay
      5  6800				   TEMPORARY_OFFSET SET	0
      6  6800				   VAR_BOUNDARY_Handle_ROOK SET	TEMPORARY_OFFSET
      7  6800				   FUNCTION_NAME SET	Handle_ROOK
      9  6800					      SUBROUTINE
     10  6800
      0  6800					      REFER	GenerateAllMoves	;✅
      1  6800					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6800				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6800					      ENDIF
      0  6800					      VEND	Handle_ROOK
      1  6800				  -	      IFNCONST	Handle_ROOK
      2  6800				  -	      ECHO	"Incorrect VEND label", Handle_ROOK
      3  6800				  -	      ERR
      4  6800					      ENDIF
      5  6800		       00 b8	   VAREND_Handle_ROOK =	TEMPORARY_VAR
     13  6800
     14  6800							; Pass...
     15  6800							; x = currentSquare (square the piece is on)
     16  6800							; currentPiece (with flags/colour attached)
     17  6800
     18  6800
      0  6800					      MOVE_TOWARDS	_DOWN
      1  6800					      SUBROUTINE
      2  6800
      3  6800
      4  6800
      5  6800		       a9 00		      lda	#0
      6  6802		       85 9b		      sta	capture
      7  6804
      8  6804		       a6 92		      ldx	currentSquare
      9  6806		       d0 03		      bne	.project
     10  6808
     11  6808		       20 7d f2    .empty     jsr	AddMove
     12  680b		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  680e		       30 0e		      bmi	.invalid
     14  6810		       b9 79 fc 	      lda	Board,y
     15  6813		       f0 f3		      beq	.empty
     16  6815		       85 9b		      sta	capture
     17  6817		       45 91		      eor	currentPiece
     18  6819		       10 03		      bpl	.invalid
     19  681b		       20 7d f2 	      jsr	AddMove
     20  681e
     21  681e				   .invalid
      0  681e					      MOVE_TOWARDS	_RIGHT
      1  681e					      SUBROUTINE
      2  681e
      3  681e
      4  681e
      5  681e		       a9 00		      lda	#0
      6  6820		       85 9b		      sta	capture
      7  6822
      8  6822		       a6 92		      ldx	currentSquare
      9  6824		       d0 03		      bne	.project
     10  6826
     11  6826		       20 7d f2    .empty     jsr	AddMove
     12  6829		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  682c		       30 0e		      bmi	.invalid
     14  682e		       b9 79 fc 	      lda	Board,y
     15  6831		       f0 f3		      beq	.empty
     16  6833		       85 9b		      sta	capture
     17  6835		       45 91		      eor	currentPiece
     18  6837		       10 03		      bpl	.invalid
     19  6839		       20 7d f2 	      jsr	AddMove
     20  683c
     21  683c				   .invalid
      0  683c					      MOVE_TOWARDS	_UP
      1  683c					      SUBROUTINE
      2  683c
      3  683c
      4  683c
      5  683c		       a9 00		      lda	#0
      6  683e		       85 9b		      sta	capture
      7  6840
      8  6840		       a6 92		      ldx	currentSquare
      9  6842		       d0 03		      bne	.project
     10  6844
     11  6844		       20 7d f2    .empty     jsr	AddMove
     12  6847		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  684a		       30 0e		      bmi	.invalid
     14  684c		       b9 79 fc 	      lda	Board,y
     15  684f		       f0 f3		      beq	.empty
     16  6851		       85 9b		      sta	capture
     17  6853		       45 91		      eor	currentPiece
     18  6855		       10 03		      bpl	.invalid
     19  6857		       20 7d f2 	      jsr	AddMove
     20  685a
     21  685a				   .invalid
      0  685a					      MOVE_TOWARDS	_LEFT
      1  685a					      SUBROUTINE
      2  685a
      3  685a
      4  685a
      5  685a		       a9 00		      lda	#0
      6  685c		       85 9b		      sta	capture
      7  685e
      8  685e		       a6 92		      ldx	currentSquare
      9  6860		       d0 03		      bne	.project
     10  6862
     11  6862		       20 7d f2    .empty     jsr	AddMove
     12  6865		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  6868		       30 0e		      bmi	.invalid
     14  686a		       b9 79 fc 	      lda	Board,y
     15  686d		       f0 f3		      beq	.empty
     16  686f		       85 9b		      sta	capture
     17  6871		       45 91		      eor	currentPiece
     18  6873		       10 03		      bpl	.invalid
     19  6875		       20 7d f2 	      jsr	AddMove
     20  6878
     21  6878				   .invalid
     23  6878
     24  6878		       4c e0 f1 	      jmp	MoveReturn
     25  687b
     26  687b							;---------------------------------------------------------------------------------------------------
     27  687b							; EOF
------- FILE PIECE_HANDLER@1#2.asm
------- FILE PIECE_QUEEN.asm LEVEL 3 PASS 4
      0  687b					      include	"PIECE_QUEEN.asm"
      1  687b							; Copyright (C)2020 Andrew Davie
      2  687b
      3  687b							;---------------------------------------------------------------------------------------------------
      4  687b							; QUEEN
      5  687b							;---------------------------------------------------------------------------------------------------
      6  687b
      0  687b					      DEF	Handle_QUEEN
      1  687b				   SLOT_Handle_QUEEN SET	_BANK_SLOT
      2  687b				   BANK_Handle_QUEEN SET	SLOT_Handle_QUEEN + _CURRENT_BANK
      3  687b				   Handle_QUEEN
      4  687b				   TEMPORARY_VAR SET	Overlay
      5  687b				   TEMPORARY_OFFSET SET	0
      6  687b				   VAR_BOUNDARY_Handle_QUEEN SET	TEMPORARY_OFFSET
      7  687b				   FUNCTION_NAME SET	Handle_QUEEN
      8  687b					      SUBROUTINE
      9  687b
      0  687b					      REFER	GenerateAllMoves	;✅
      1  687b					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  687b				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  687b					      ENDIF
      0  687b					      VEND	Handle_QUEEN
      1  687b				  -	      IFNCONST	Handle_QUEEN
      2  687b				  -	      ECHO	"Incorrect VEND label", Handle_QUEEN
      3  687b				  -	      ERR
      4  687b					      ENDIF
      5  687b		       00 b8	   VAREND_Handle_QUEEN =	TEMPORARY_VAR
     12  687b
     13  687b							; Pass...
     14  687b							; x = currentSquare (square the piece is on)
     15  687b							; currentPiece (with flags/colour attached)
     16  687b
      0  687b					      MOVE_TOWARDS	_DOWN+_LEFT
      1  687b					      SUBROUTINE
      2  687b
      3  687b
      4  687b
      5  687b		       a9 00		      lda	#0
      6  687d		       85 9b		      sta	capture
      7  687f
      8  687f		       a6 92		      ldx	currentSquare
      9  6881		       d0 03		      bne	.project
     10  6883
     11  6883		       20 7d f2    .empty     jsr	AddMove
     12  6886		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  6889		       30 0e		      bmi	.invalid
     14  688b		       b9 79 fc 	      lda	Board,y
     15  688e		       f0 f3		      beq	.empty
     16  6890		       85 9b		      sta	capture
     17  6892		       45 91		      eor	currentPiece
     18  6894		       10 03		      bpl	.invalid
     19  6896		       20 7d f2 	      jsr	AddMove
     20  6899
     21  6899				   .invalid
      0  6899					      MOVE_TOWARDS	_DOWN
      1  6899					      SUBROUTINE
      2  6899
      3  6899
      4  6899
      5  6899		       a9 00		      lda	#0
      6  689b		       85 9b		      sta	capture
      7  689d
      8  689d		       a6 92		      ldx	currentSquare
      9  689f		       d0 03		      bne	.project
     10  68a1
     11  68a1		       20 7d f2    .empty     jsr	AddMove
     12  68a4		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  68a7		       30 0e		      bmi	.invalid
     14  68a9		       b9 79 fc 	      lda	Board,y
     15  68ac		       f0 f3		      beq	.empty
     16  68ae		       85 9b		      sta	capture
     17  68b0		       45 91		      eor	currentPiece
     18  68b2		       10 03		      bpl	.invalid
     19  68b4		       20 7d f2 	      jsr	AddMove
     20  68b7
     21  68b7				   .invalid
      0  68b7					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  68b7					      SUBROUTINE
      2  68b7
      3  68b7
      4  68b7
      5  68b7		       a9 00		      lda	#0
      6  68b9		       85 9b		      sta	capture
      7  68bb
      8  68bb		       a6 92		      ldx	currentSquare
      9  68bd		       d0 03		      bne	.project
     10  68bf
     11  68bf		       20 7d f2    .empty     jsr	AddMove
     12  68c2		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  68c5		       30 0e		      bmi	.invalid
     14  68c7		       b9 79 fc 	      lda	Board,y
     15  68ca		       f0 f3		      beq	.empty
     16  68cc		       85 9b		      sta	capture
     17  68ce		       45 91		      eor	currentPiece
     18  68d0		       10 03		      bpl	.invalid
     19  68d2		       20 7d f2 	      jsr	AddMove
     20  68d5
     21  68d5				   .invalid
      0  68d5					      MOVE_TOWARDS	_RIGHT
      1  68d5					      SUBROUTINE
      2  68d5
      3  68d5
      4  68d5
      5  68d5		       a9 00		      lda	#0
      6  68d7		       85 9b		      sta	capture
      7  68d9
      8  68d9		       a6 92		      ldx	currentSquare
      9  68db		       d0 03		      bne	.project
     10  68dd
     11  68dd		       20 7d f2    .empty     jsr	AddMove
     12  68e0		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  68e3		       30 0e		      bmi	.invalid
     14  68e5		       b9 79 fc 	      lda	Board,y
     15  68e8		       f0 f3		      beq	.empty
     16  68ea		       85 9b		      sta	capture
     17  68ec		       45 91		      eor	currentPiece
     18  68ee		       10 03		      bpl	.invalid
     19  68f0		       20 7d f2 	      jsr	AddMove
     20  68f3
     21  68f3				   .invalid
      0  68f3					      MOVE_TOWARDS	_UP+_RIGHT
      1  68f3					      SUBROUTINE
      2  68f3
      3  68f3
      4  68f3
      5  68f3		       a9 00		      lda	#0
      6  68f5		       85 9b		      sta	capture
      7  68f7
      8  68f7		       a6 92		      ldx	currentSquare
      9  68f9		       d0 03		      bne	.project
     10  68fb
     11  68fb		       20 7d f2    .empty     jsr	AddMove
     12  68fe		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  6901		       30 0e		      bmi	.invalid
     14  6903		       b9 79 fc 	      lda	Board,y
     15  6906		       f0 f3		      beq	.empty
     16  6908		       85 9b		      sta	capture
     17  690a		       45 91		      eor	currentPiece
     18  690c		       10 03		      bpl	.invalid
     19  690e		       20 7d f2 	      jsr	AddMove
     20  6911
     21  6911				   .invalid
      0  6911					      MOVE_TOWARDS	_UP
      1  6911					      SUBROUTINE
      2  6911
      3  6911
      4  6911
      5  6911		       a9 00		      lda	#0
      6  6913		       85 9b		      sta	capture
      7  6915
      8  6915		       a6 92		      ldx	currentSquare
      9  6917		       d0 03		      bne	.project
     10  6919
     11  6919		       20 7d f2    .empty     jsr	AddMove
     12  691c		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  691f		       30 0e		      bmi	.invalid
     14  6921		       b9 79 fc 	      lda	Board,y
     15  6924		       f0 f3		      beq	.empty
     16  6926		       85 9b		      sta	capture
     17  6928		       45 91		      eor	currentPiece
     18  692a		       10 03		      bpl	.invalid
     19  692c		       20 7d f2 	      jsr	AddMove
     20  692f
     21  692f				   .invalid
      0  692f					      MOVE_TOWARDS	_UP+_LEFT
      1  692f					      SUBROUTINE
      2  692f
      3  692f
      4  692f
      5  692f		       a9 00		      lda	#0
      6  6931		       85 9b		      sta	capture
      7  6933
      8  6933		       a6 92		      ldx	currentSquare
      9  6935		       d0 03		      bne	.project
     10  6937
     11  6937		       20 7d f2    .empty     jsr	AddMove
     12  693a		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  693d		       30 0e		      bmi	.invalid
     14  693f		       b9 79 fc 	      lda	Board,y
     15  6942		       f0 f3		      beq	.empty
     16  6944		       85 9b		      sta	capture
     17  6946		       45 91		      eor	currentPiece
     18  6948		       10 03		      bpl	.invalid
     19  694a		       20 7d f2 	      jsr	AddMove
     20  694d
     21  694d				   .invalid
      0  694d					      MOVE_TOWARDS	_LEFT
      1  694d					      SUBROUTINE
      2  694d
      3  694d
      4  694d
      5  694d		       a9 00		      lda	#0
      6  694f		       85 9b		      sta	capture
      7  6951
      8  6951		       a6 92		      ldx	currentSquare
      9  6953		       d0 03		      bne	.project
     10  6955
     11  6955		       20 7d f2    .empty     jsr	AddMove
     12  6958		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  695b		       30 0e		      bmi	.invalid
     14  695d		       b9 79 fc 	      lda	Board,y
     15  6960		       f0 f3		      beq	.empty
     16  6962		       85 9b		      sta	capture
     17  6964		       45 91		      eor	currentPiece
     18  6966		       10 03		      bpl	.invalid
     19  6968		       20 7d f2 	      jsr	AddMove
     20  696b
     21  696b				   .invalid
     25  696b
     26  696b		       4c e0 f1 	      jmp	MoveReturn
     27  696e
     28  696e							; EOF
------- FILE PIECE_HANDLER@1#2.asm
------- FILE PIECE_KING.asm LEVEL 3 PASS 4
      0  696e					      include	"PIECE_KING.asm"
      1  696e							; Copyright (C)2020 Andrew Davie
      2  696e
      3  696e							;---------------------------------------------------------------------------------------------------
      4  696e							; KING
      5  696e							; This is the move handler for a KING
      6  696e							; "Check" is detected in the next ply of the search.
      7  696e
      8  696e
      9  696e							;---------------------------------------------------------------------------------------------------
     10  696e
     11  696e							; MACRO - Castling
     12  696e
     13  696e		       00 03	   KINGSIDE   =	3
     14  696e		       ff ff ff fc QUEENSIDE  =	-4
     15  696e
     16  696e					      MAC	castle
     17  696e							; {1} = "KINGSIDE" or "QUEENSIDE"
     18  696e
     19  696e					      ldx	currentSquare
     20  696e					      lda	Board+{1},x	; kingside/queenside R position
     21  696e					      and	#PIECE_MASK|FLAG_MOVED
     22  696e					      cmp	#ROOK
     23  696e					      bne	.noCastle	; not a R that hasn't moved
     24  696e
     25  696e							; It's a R and it *HAS* to be correct colour because it hasn't moved!
     26  696e							; AND the K hasn't moved (earlier check), so check for vacant squares between K and R
     27  696e
     28  696e					      IF	{1} = QUEENSIDE
     29  696e					      lda	Board-3,x	; N pos
     30  696e					      ora	Board-2,x	; B pos
     31  696e					      ora	Board-1,x	; Q pos
     32  696e					      bne	.noCastle	; not vacant?
     33  696e
     34  696e					      ENDIF
     35  696e
     36  696e					      IF	{1} = KINGSIDE
     37  696e					      lda	Board+2,x	; N pos
     38  696e					      ora	Board+1,x	; B pos
     39  696e					      bne	.noCastle	; not vacant?
     40  696e					      ENDIF
     41  696e
     42  696e							; appropriate N/B/(Q) squares are vacant so we proceed...
     43  696e
     44  696e							; FINALLY -- king can castle
     45  696e							; note: when we actually DO the move we MUST insert "Phantom" kings onto the board over the
     46  696e							; squares the king traverses so that "check" (and thus illegal moves) can be detected on the
     47  696e							; next move. Castling will be detected by K moving > 1 square. (TODO: FIX?? not CASTLE flag??)
     48  696e
     49  696e					      lda	currentPiece
     50  696e					      ora	#FLAG_CASTLE	; flag it's a castling move
     51  696e					      sta	currentPiece
     52  696e
     53  696e					      IF	{1} = KINGSIDE
     54  696e					      ldy	ValidSquare+2,x
     55  696e					      ENDIF
     56  696e
     57  696e					      IF	{1} = QUEENSIDE
     58  696e					      ldy	ValidSquare-2,x
     59  696e					      ENDIF
     60  696e
     61  696e
     62  696e					      jsr	AddMove	; 57
     63  696e				   .noCastle
     64  696e					      ENDM
     65  696e
     66  696e
     67  696e							;---------------------------------------------------------------------------------------------------
     68  696e
      0  696e					      DEF	Handle_KING
      1  696e				   SLOT_Handle_KING SET	_BANK_SLOT
      2  696e				   BANK_Handle_KING SET	SLOT_Handle_KING + _CURRENT_BANK
      3  696e				   Handle_KING
      4  696e				   TEMPORARY_VAR SET	Overlay
      5  696e				   TEMPORARY_OFFSET SET	0
      6  696e				   VAR_BOUNDARY_Handle_KING SET	TEMPORARY_OFFSET
      7  696e				   FUNCTION_NAME SET	Handle_KING
     70  696e					      SUBROUTINE
     71  696e
      0  696e					      REFER	GenerateAllMoves	;✅
      1  696e					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  696e				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  696e					      ENDIF
      0  696e					      VEND	Handle_KING
      1  696e				  -	      IFNCONST	Handle_KING
      2  696e				  -	      ECHO	"Incorrect VEND label", Handle_KING
      3  696e				  -	      ERR
      4  696e					      ENDIF
      5  696e		       00 b8	   VAREND_Handle_KING =	TEMPORARY_VAR
     74  696e
     75  696e							; x = currentSquare (square the KING is on)
     76  696e							; currentPiece (KING of course, but with flags/colour attached)
     77  696e
      0  696e					      MOVE_TO	_DOWN+_LEFT
      1  696e					      SUBROUTINE
      2  696e		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      3  6971		       30 0e		      bmi	.invalid
      4  6973		       b9 79 fc 	      lda	Board,y
      5  6976		       85 9b		      sta	capture
      6  6978		       f0 04		      beq	.squareEmpty
      7  697a		       45 91		      eor	currentPiece
      8  697c		       10 03		      bpl	.invalid
      9  697e		       20 7d f2    .squareEmpty jsr	AddMove
     10  6981				   .invalid
      0  6981					      MOVE_TO_X	_DOWN
      1  6981		       a6 92		      ldx	currentSquare
      0  6983					      MOVE_TO	_DOWN
      1  6983					      SUBROUTINE
      2  6983		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x
      3  6986		       30 0e		      bmi	.invalid
      4  6988		       b9 79 fc 	      lda	Board,y
      5  698b		       85 9b		      sta	capture
      6  698d		       f0 04		      beq	.squareEmpty
      7  698f		       45 91		      eor	currentPiece
      8  6991		       10 03		      bpl	.invalid
      9  6993		       20 7d f2    .squareEmpty jsr	AddMove
     10  6996				   .invalid
      0  6996					      MOVE_TO_X	_DOWN+_RIGHT
      1  6996		       a6 92		      ldx	currentSquare
      0  6998					      MOVE_TO	_DOWN+_RIGHT
      1  6998					      SUBROUTINE
      2  6998		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      3  699b		       30 0e		      bmi	.invalid
      4  699d		       b9 79 fc 	      lda	Board,y
      5  69a0		       85 9b		      sta	capture
      6  69a2		       f0 04		      beq	.squareEmpty
      7  69a4		       45 91		      eor	currentPiece
      8  69a6		       10 03		      bpl	.invalid
      9  69a8		       20 7d f2    .squareEmpty jsr	AddMove
     10  69ab				   .invalid
      0  69ab					      MOVE_TO_X	_RIGHT
      1  69ab		       a6 92		      ldx	currentSquare
      0  69ad					      MOVE_TO	_RIGHT
      1  69ad					      SUBROUTINE
      2  69ad		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      3  69b0		       30 0e		      bmi	.invalid
      4  69b2		       b9 79 fc 	      lda	Board,y
      5  69b5		       85 9b		      sta	capture
      6  69b7		       f0 04		      beq	.squareEmpty
      7  69b9		       45 91		      eor	currentPiece
      8  69bb		       10 03		      bpl	.invalid
      9  69bd		       20 7d f2    .squareEmpty jsr	AddMove
     10  69c0				   .invalid
      0  69c0					      MOVE_TO_X	_UP+_RIGHT
      1  69c0		       a6 92		      ldx	currentSquare
      0  69c2					      MOVE_TO	_UP+_RIGHT
      1  69c2					      SUBROUTINE
      2  69c2		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      3  69c5		       30 0e		      bmi	.invalid
      4  69c7		       b9 79 fc 	      lda	Board,y
      5  69ca		       85 9b		      sta	capture
      6  69cc		       f0 04		      beq	.squareEmpty
      7  69ce		       45 91		      eor	currentPiece
      8  69d0		       10 03		      bpl	.invalid
      9  69d2		       20 7d f2    .squareEmpty jsr	AddMove
     10  69d5				   .invalid
      0  69d5					      MOVE_TO_X	_UP
      1  69d5		       a6 92		      ldx	currentSquare
      0  69d7					      MOVE_TO	_UP
      1  69d7					      SUBROUTINE
      2  69d7		       bc 1f fc 	      ldy	ValidSquare+_UP,x
      3  69da		       30 0e		      bmi	.invalid
      4  69dc		       b9 79 fc 	      lda	Board,y
      5  69df		       85 9b		      sta	capture
      6  69e1		       f0 04		      beq	.squareEmpty
      7  69e3		       45 91		      eor	currentPiece
      8  69e5		       10 03		      bpl	.invalid
      9  69e7		       20 7d f2    .squareEmpty jsr	AddMove
     10  69ea				   .invalid
      0  69ea					      MOVE_TO_X	_UP+_LEFT
      1  69ea		       a6 92		      ldx	currentSquare
      0  69ec					      MOVE_TO	_UP+_LEFT
      1  69ec					      SUBROUTINE
      2  69ec		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      3  69ef		       30 0e		      bmi	.invalid
      4  69f1		       b9 79 fc 	      lda	Board,y
      5  69f4		       85 9b		      sta	capture
      6  69f6		       f0 04		      beq	.squareEmpty
      7  69f8		       45 91		      eor	currentPiece
      8  69fa		       10 03		      bpl	.invalid
      9  69fc		       20 7d f2    .squareEmpty jsr	AddMove
     10  69ff				   .invalid
      0  69ff					      MOVE_TO_X	_LEFT
      1  69ff		       a6 92		      ldx	currentSquare
      0  6a01					      MOVE_TO	_LEFT
      1  6a01					      SUBROUTINE
      2  6a01		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      3  6a04		       30 0e		      bmi	.invalid
      4  6a06		       b9 79 fc 	      lda	Board,y
      5  6a09		       85 9b		      sta	capture
      6  6a0b		       f0 04		      beq	.squareEmpty
      7  6a0d		       45 91		      eor	currentPiece
      8  6a0f		       10 03		      bpl	.invalid
      9  6a11		       20 7d f2    .squareEmpty jsr	AddMove
     10  6a14				   .invalid
     86  6a14
     87  6a14					      IF	CASTLING_ENABLED
     88  6a14
     89  6a14		       24 91		      bit	currentPiece
     90  6a16		       70 41		      bvs	.exit	; king has moved, so no castling
     91  6a18
      0  6a18					      CASTLE	KINGSIDE
      1  6a18
      2  6a18
      3  6a18		       a6 92		      ldx	currentSquare
      4  6a1a		       bd 7c fc 	      lda	Board+KINGSIDE,x
      5  6a1d		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  6a1f		       c9 05		      cmp	#ROOK
      7  6a21		       d0 14		      bne	.noCastle
      8  6a23
      9  6a23
     10  6a23
     11  6a23
     12  6a23				  -	      IF	KINGSIDE = QUEENSIDE
     13  6a23				  -	      lda	Board-3,x
     14  6a23				  -	      ora	Board-2,x
     15  6a23				  -	      ora	Board-1,x
     16  6a23				  -	      bne	.noCastle
     17  6a23				  -
     18  6a23					      ENDIF
     19  6a23
     20  6a23					      IF	KINGSIDE = KINGSIDE
     21  6a23		       bd 7b fc 	      lda	Board+2,x
     22  6a26		       1d 7a fc 	      ora	Board+1,x
     23  6a29		       d0 0c		      bne	.noCastle
     24  6a2b					      ENDIF
     25  6a2b
     26  6a2b
     27  6a2b
     28  6a2b
     29  6a2b
     30  6a2b
     31  6a2b
     32  6a2b
     33  6a2b		       a5 91		      lda	currentPiece
     34  6a2d		       09 10		      ora	#FLAG_CASTLE
     35  6a2f		       85 91		      sta	currentPiece
     36  6a31
     37  6a31					      IF	KINGSIDE = KINGSIDE
     38  6a31		       bc 17 fc 	      ldy	ValidSquare+2,x
     39  6a34					      ENDIF
     40  6a34
     41  6a34				  -	      IF	KINGSIDE = QUEENSIDE
     42  6a34				  -	      ldy	ValidSquare-2,x
     43  6a34					      ENDIF
     44  6a34
     45  6a34
     46  6a34		       20 7d f2 	      jsr	AddMove
     47  6a37				   .noCastle
      0  6a37					      CASTLE	QUEENSIDE
      1  6a37
      2  6a37
      3  6a37		       a6 92		      ldx	currentSquare
      4  6a39		       bd 75 fc 	      lda	Board+QUEENSIDE,x
      5  6a3c		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  6a3e		       c9 05		      cmp	#ROOK
      7  6a40		       d0 17		      bne	.noCastle
      8  6a42
      9  6a42
     10  6a42
     11  6a42
     12  6a42					      IF	QUEENSIDE = QUEENSIDE
     13  6a42		       bd 76 fc 	      lda	Board-3,x
     14  6a45		       1d 77 fc 	      ora	Board-2,x
     15  6a48		       1d 78 fc 	      ora	Board-1,x
     16  6a4b		       d0 0c		      bne	.noCastle
     17  6a4d
     18  6a4d					      ENDIF
     19  6a4d
     20  6a4d				  -	      IF	QUEENSIDE = KINGSIDE
     21  6a4d				  -	      lda	Board+2,x
     22  6a4d				  -	      ora	Board+1,x
     23  6a4d				  -	      bne	.noCastle
     24  6a4d					      ENDIF
     25  6a4d
     26  6a4d
     27  6a4d
     28  6a4d
     29  6a4d
     30  6a4d
     31  6a4d
     32  6a4d
     33  6a4d		       a5 91		      lda	currentPiece
     34  6a4f		       09 10		      ora	#FLAG_CASTLE
     35  6a51		       85 91		      sta	currentPiece
     36  6a53
     37  6a53				  -	      IF	QUEENSIDE = KINGSIDE
     38  6a53				  -	      ldy	ValidSquare+2,x
     39  6a53					      ENDIF
     40  6a53
     41  6a53					      IF	QUEENSIDE = QUEENSIDE
     42  6a53		       bc 13 fc 	      ldy	ValidSquare-2,x
     43  6a56					      ENDIF
     44  6a56
     45  6a56
     46  6a56		       20 7d f2 	      jsr	AddMove
     47  6a59				   .noCastle
     94  6a59
     95  6a59					      ENDIF
     96  6a59
     97  6a59		       4c e0 f1    .exit      jmp	MoveReturn
     98  6a5c
     99  6a5c							;---------------------------------------------------------------------------------------------------
    100  6a5c							; EOF
------- FILE PIECE_HANDLER@1#2.asm
      7  6a5c
      8  6a5c							;---------------------------------------------------------------------------------------------------
      9  6a5c
      0  6a5c					      CHECK_BANK_SIZE	"PIECE_HANDLER_2"
      1  6a5c		       02 5c	   .TEMP      =	* - _BANK_START
 PIECE_HANDLER_2 (1K) SIZE =  $25c , FREE= $1a4
      2  6a5c					      ECHO	"PIECE_HANDLER_2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  6a5c				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6a5c				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_HANDLER_2", " size=", * - ORIGIN
      5  6a5c				  -	      ERR
      6  6a5c					      ENDIF
     11  6a5c
     12  6a5c							;---------------------------------------------------------------------------------------------------
     13  6a5c							; EOF
------- FILE ./chess.asm
------- FILE BANK_3.asm LEVEL 2 PASS 4
      0  6a5c					      include	"BANK_3.asm"
      1  6a5c							; Chess
      2  6a5c							; Copyright (c) 2019-2020 Andrew Davie
      3  6a5c							; andrew@taswegian.com
      4  6a5c
      0  6a5c					      SLOT	3	; this code assembles for bank #1
      1  6a5c				  -	      IF	(3 < 0) || (3 > 3)
      2  6a5c				  -	      ECHO	"Illegal bank address/segment location", 3
      3  6a5c				  -	      ERR
      4  6a5c					      ENDIF
      5  6a5c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  6a5c				   _BANK_SLOT SET	3 * 64
      0  6a5c					      ROMBANK	THREE
      1  6c67 ????				      SEG	THREE
      2  6c00					      ORG	_ORIGIN
      3  6c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  6c00				   _BANK_START SET	*
      5  6c00				   THREE_START SET	*
      6  6c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6c00				   THREE      SET	_BANK_SLOT + _CURRENT_BANK
      8  6c00				   _ORIGIN    SET	_ORIGIN + 1024
      7  6c00
      8  6c00							;---------------------------------------------------------------------------------------------------
      9  6c00
      0  6c00					      DEF	GetPiece
      1  6c00				   SLOT_GetPiece SET	_BANK_SLOT
      2  6c00				   BANK_GetPiece SET	SLOT_GetPiece + _CURRENT_BANK
      3  6c00				   GetPiece
      4  6c00				   TEMPORARY_VAR SET	Overlay
      5  6c00				   TEMPORARY_OFFSET SET	0
      6  6c00				   VAR_BOUNDARY_GetPiece SET	TEMPORARY_OFFSET
      7  6c00				   FUNCTION_NAME SET	GetPiece
     11  6c00					      SUBROUTINE
     12  6c00
      0  6c00					      REFER	aiSelectDestinationSquare	;✅
      1  6c00					      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  6c00				   TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  6c00					      ENDIF
      0  6c00					      REFER	aiQuiescent	;✅
      1  6c00				  -	      IF	VAREND_aiQuiescent > TEMPORARY_VAR
      2  6c00				  -TEMPORARY_VAR SET	VAREND_aiQuiescent
      3  6c00					      ENDIF
      0  6c00					      VEND	GetPiece
      1  6c00				  -	      IFNCONST	GetPiece
      2  6c00				  -	      ECHO	"Incorrect VEND label", GetPiece
      3  6c00				  -	      ERR
      4  6c00					      ENDIF
      5  6c00		       00 a9	   VAREND_GetPiece =	TEMPORARY_VAR
     16  6c00
     17  6c00							; Retrieve the piece+flags from the movelist, given from/to squares
     18  6c00							; Required as moves have different flags but same origin squares (e.g., castling)
     19  6c00
     20  6c00		       a9 89		      lda	#RAMBANK_PLY+1	;currentPly
     21  6c02							;lda currentPly
     22  6c02		       85 3e		      sta	SET_BANK_RAM	;@2
     23  6c04
     24  6c04							; returns piece in A+fromPiece
     25  6c04							; or Y=-1 if not found
     26  6c04
     27  6c04							; We need to get the piece from the movelist because it contains flags (e.g., castling) about
     28  6c04							; the move. We need to do from/to checks because moves can have multiple origin/desinations.
     29  6c04							; This fixes the move with/without castle flag
     30  6c04
     31  6c04
      0  6c04					      ldy@PLY	moveIndex
      1  6c04		       ac cf f9 	      ldy	moveIndex
     33  6c07		       30 11		      bmi	.fail	; shouldn't happen
     34  6c09
     35  6c09		       a5 85	   .scan      lda	fromX12
      0  6c0b					      cmp@PLY	MoveFrom,y
      1  6c0b		       d9 00 f8 	      cmp	MoveFrom,y
     37  6c0e		       d0 07		      bne	.next
     38  6c10		       a5 86		      lda	toX12
      0  6c12					      cmp@PLY	MoveTo,y
      1  6c12		       d9 64 f8 	      cmp	MoveTo,y
     40  6c15		       f0 04		      beq	.found
     41  6c17		       88	   .next      dey
     42  6c18		       10 ef		      bpl	.scan
     43  6c1a		       60	   .fail      rts
     44  6c1b
      0  6c1b				   .found     lda@PLY	MovePiece,y
      1  6c1b		       b9 00 f9 	      lda	MovePiece,y
     46  6c1e		       85 96		      sta	fromPiece
     47  6c20
     48  6c20		       60		      rts
     49  6c21
     50  6c21
     51  6c21							;---------------------------------------------------------------------------------------------------
     52  6c21
     53  6c21							;     DEF GenCastleMoveForRook_ENPASSANT
     54  6c21							;     SUBROUTINE
     55  6c21
     56  6c21							;	   REFER MakeMove ;✅
     57  6c21							;	   REFER CastleFixupDraw_ENPASSANT ;✅
     58  6c21							;	   VEND GenCastleMoveForRook_ENPASSANT
     59  6c21
     60  6c21							;	   rts ;tmp
     61  6c21							;	   jsr debug ;tmp
     62  6c21
     63  6c21							;     ; Like castling, this generates the acutal extra-move for the en-passant
     64  6c21
     65  6c21
     66  6c21							;     ; Check to see if we are doing an actual en-passant capture...
     67  6c21
     68  6c21							;     ; NOTE: If using test boards for debugging, the FLAG_MOVED flag is IMPORTANT
     69  6c21							;     ;  as the en-passant will fail if the taking piece does not have this flag set correctly
     70  6c21
     71  6c21
     72  6c21
     73  6c21							;     ; {
     74  6c21							;     ; With en-passant flag, it is essentially dual-use.
     75  6c21							;     ; First, it marks if the move is *involved* somehow in an en-passant
     76  6c21							;     ; if the piece has MOVED already, then it's an en-passant capture
     77  6c21							;     ; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
     78  6c21
     79  6c21							;		       ldy enPassantPawn	       ; save from previous side move
     80  6c21
     81  6c21							;		       ldx #0			       ; (probably) NO en-passant this time
     82  6c21							;		       lda fromPiece
     83  6c21							;		       and #FLAG_ENPASSANT|FLAG_MOVED
     84  6c21							;		       cmp #FLAG_ENPASSANT
     85  6c21							;		       bne .noep		       ; HAS moved, or not en-passant
     86  6c21
     87  6c21							;		       eor fromPiece		       ; clear FLAG_ENPASSANT
     88  6c21							;		       sta fromPiece
     89  6c21
     90  6c21							;		       ldx toX12		       ; this IS an en-passantable opening, so record the square
     91  6c21							; .noep	       stx enPassantPawn	       ; capturable square for en-passant move (or none)
     92  6c21
     93  6c21							;     ; }
     94  6c21
     95  6c21							;		       clc
     96  6c21
     97  6c21							;		       lda fromPiece
     98  6c21							;		       and #FLAG_ENPASSANT
     99  6c21							;		       beq .notEnPassant	       ; not an en-passant, or it's enpassant by a MOVED piece
    100  6c21
    101  6c21
    102  6c21							;     ; at this point the attacking pawn has finished moving to the "take" square
    103  6c21							;     ; the loser-pawn is marked with enPassantPawn
    104  6c21							;     ; we want to generate a 'blank' move to take the pawn
    105  6c21
    106  6c21							;		       lda originX12		       ; we need a blank square to move FROM
    107  6c21							;		       sta fromX12		       ; use the square the attacker pawn just left
    108  6c21
    109  6c21							;     ; calculate the captured pawn's square based on move colour
    110  6c21
    111  6c21							;		       lda #-10
    112  6c21							;		       ldx fromPiece
    113  6c21							;		       bpl .white
    114  6c21							;		       lda #10
    115  6c21							; .white
    116  6c21							;		       clc
    117  6c21							;		       adc fromX12		       ; attacker destination square
    118  6c21							;		       sta toX12		       ; now we have the captured pawn square!
    119  6c21							;		       sta@PLY secondarySquare	       ; square to which we RESTORE the captured pawn on unmakemove
    120  6c21
    121  6c21							;		       sta@PLY secondaryBlank
    122  6c21							;		       lda fromPiece
    123  6c21							;		       eor #$80 		       ; opponent pawn
    124  6c21							;		       sta@PLY secondaryPiece	       ; a capture!
    125  6c21
    126  6c21
    127  6c21							;		       sec			       ; double-move, so don't change sides
    128  6c21							; .notEnPassant       rts
    129  6c21
    130  6c21
    131  6c21							;---------------------------------------------------------------------------------------------------
    132  6c21
      0  6c21					      DEF	GenCastleMoveForRook
      1  6c21				   SLOT_GenCastleMoveForRook SET	_BANK_SLOT
      2  6c21				   BANK_GenCastleMoveForRook SET	SLOT_GenCastleMoveForRook + _CURRENT_BANK
      3  6c21				   GenCastleMoveForRook
      4  6c21				   TEMPORARY_VAR SET	Overlay
      5  6c21				   TEMPORARY_OFFSET SET	0
      6  6c21				   VAR_BOUNDARY_GenCastleMoveForRook SET	TEMPORARY_OFFSET
      7  6c21				   FUNCTION_NAME SET	GenCastleMoveForRook
    134  6c21					      SUBROUTINE
    135  6c21
      0  6c21					      REFER	MakeMove	;✅
      1  6c21					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  6c21				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  6c21					      ENDIF
      0  6c21					      REFER	CastleFixupDraw	;✅
      1  6c21				  -	      IF	VAREND_CastleFixupDraw > TEMPORARY_VAR
      2  6c21				  -TEMPORARY_VAR SET	VAREND_CastleFixupDraw
      3  6c21					      ENDIF
      0  6c21					      VEND	GenCastleMoveForRook
      1  6c21				  -	      IFNCONST	GenCastleMoveForRook
      2  6c21				  -	      ECHO	"Incorrect VEND label", GenCastleMoveForRook
      3  6c21				  -	      ERR
      4  6c21					      ENDIF
      5  6c21		       00 b5	   VAREND_GenCastleMoveForRook =	TEMPORARY_VAR
    139  6c21
    140  6c21							; Generate secondary move for the rook, involved in a castling move
    141  6c21							; Returns:
    142  6c21							;   CC --> not a castle/secondary
    143  6c21							;   CS --> secondary move valid
    144  6c21
    145  6c21
    146  6c21		       18		      clc
    147  6c22
    148  6c22		       a5 96		      lda	fromPiece
    149  6c24		       29 10		      and	#FLAG_CASTLE
    150  6c26		       f0 2e		      beq	.exit	; NOT involved in castle!
    151  6c28
    152  6c28		       20 a4 f2 	      jsr	debug	;tmp
    153  6c2b		       a2 04		      ldx	#4
    154  6c2d		       a5 86		      lda	toX12	; *destination*
    155  6c2f		       18	   .findCast  clc
    156  6c30		       ca		      dex
    157  6c31		       30 23		      bmi	.exit
    158  6c33		       dd 57 fc 	      cmp	KSquare,x
    159  6c36		       d0 f7		      bne	.findCast
    160  6c38
    161  6c38		       bd 5f fc 	      lda	RSquareEnd,x
    162  6c3b		       85 86		      sta	toX12
      0  6c3d					      sta@PLY	secondaryBlank
      1  6c3d		       8d ce fb 	      sta	[RAM]+secondaryBlank
    164  6c40		       bc 5b fc 	      ldy	RSquareStart,x
    165  6c43		       84 85		      sty	fromX12
    166  6c45		       84 87		      sty	originX12
      0  6c47					      sty@PLY	secondarySquare
      1  6c47		       8c cd fb 	      sty	[RAM]+secondarySquare
    168  6c4a
    169  6c4a		       a5 96		      lda	fromPiece
    170  6c4c		       29 80		      and	#128	; colour bit
    171  6c4e		       09 05		      ora	#ROOK	; preserve colour
    172  6c50		       85 96		      sta	fromPiece
      0  6c52					      sta@PLY	secondaryPiece
      1  6c52		       8d cc fb 	      sta	[RAM]+secondaryPiece
    174  6c55
    175  6c55		       38		      sec
    176  6c56		       60	   .exit      rts
    177  6c57
    178  6c57
    179  6c57		       18 1c 5e 62 KSquare    .byte.b	24,28,94,98
    180  6c5b		       16 1d 5c 63 RSquareStart .byte.b	22,29,92,99
    181  6c5f		       19 1b 5f 61 RSquareEnd .byte.b	25,27,95,97
    182  6c63		       19 1b 5f 61 virtualSquare1 .byte.b	25,27,95,97
    183  6c67							;virtualSquare2      .byte 26,26,96,96
    184  6c67
    185  6c67							;---------------------------------------------------------------------------------------------------
    186  6c67
    187  6c67							; DEF GenEnPassantMove
    188  6c67							; SUBROUTINE
    189  6c67
    190  6c67							;     REFER EnPassantCheck
    191  6c67							;     REFER MakeMove
    192  6c67							;     VEND GenEnPassantMove
    193  6c67
    194  6c67
    195  6c67							;		   rts
    196  6c67
    197  6c67
    198  6c67
    199  6c67							;---------------------------------------------------------------------------------------------------
    200  6c67
      0  6c67					      CHECK_BANK_SIZE	"BANK_3"
      1  6c67		       00 67	   .TEMP      =	* - _BANK_START
 BANK_3 (1K) SIZE =  $67 , FREE= $399
      2  6c67					      ECHO	"BANK_3", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  6c67				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6c67				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_3", " size=", * - ORIGIN
      5  6c67				  -	      ERR
      6  6c67					      ENDIF
    202  6c67
    203  6c67							;---------------------------------------------------------------------------------------------------
    204  6c67							; EOF
------- FILE ./chess.asm
    619  6c67
------- FILE TitleScreen.asm LEVEL 2 PASS 4
      0  6c67					      include	"TitleScreen.asm"
      0  6c67					      SLOT	1
      1  6c67				  -	      IF	(1 < 0) || (1 > 3)
      2  6c67				  -	      ECHO	"Illegal bank address/segment location", 1
      3  6c67				  -	      ERR
      4  6c67					      ENDIF
      5  6c67				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  6c67				   _BANK_SLOT SET	1 * 64
      0  6c67					      ROMBANK	TITLESCREEN
      1  72b0 ????				      SEG	TITLESCREEN
      2  7000					      ORG	_ORIGIN
      3  7000					      RORG	_BANK_ADDRESS_ORIGIN
      4  7000				   _BANK_START SET	*
      5  7000				   TITLESCREEN_START SET	*
      6  7000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7000				   TITLESCREEN SET	_BANK_SLOT + _CURRENT_BANK
      8  7000				   _ORIGIN    SET	_ORIGIN + 1024
      3  7000
      4  7000				   OverscanTime2
      5  7000		       27 1a		      .byte.b	39, 26
      6  7002		       10 20		      .byte.b	16, 32
      7  7004
      8  7004							;colvec
      9  7004							;    .word colr_ntsc2, colr_pal
     10  7004
     11  7004
     12  7004		       2a 32	   VBlankTime .byte.b	42,50
     13  7006
      0  7006					      DEF	TitleScreen
      1  7006				   SLOT_TitleScreen SET	_BANK_SLOT
      2  7006				   BANK_TitleScreen SET	SLOT_TitleScreen + _CURRENT_BANK
      3  7006				   TitleScreen
      4  7006				   TEMPORARY_VAR SET	Overlay
      5  7006				   TEMPORARY_OFFSET SET	0
      6  7006				   VAR_BOUNDARY_TitleScreen SET	TEMPORARY_OFFSET
      7  7006				   FUNCTION_NAME SET	TitleScreen
     15  7006					      SUBROUTINE
     16  7006
      0  7006					      VAR	__colour_table, 2
      1  7006		       00 a7	   __colour_table =	TEMPORARY_VAR
      2  7006				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7006
      4  7006				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7006				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7006				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7006					      ENDIF
      8  7006				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7006				  -	      ECHO	"Temporary Variable", __colour_table, "overflow!"
     10  7006				  -	      ERR
     11  7006					      ENDIF
     12  7006					      LIST	ON
     18  7006
     19  7006							; Start of new frame
     20  7006
     21  7006							; Start of vertical blank processing
     22  7006
     23  7006				   TitleSequence
     24  7006
     25  7006
     26  7006		       a9 9d		      lda	#BANK_TitleData
     27  7008		       85 3f		      sta	SET_BANK
     28  700a
     29  700a
     30  700a		       a9 00		      lda	#%00000000
     31  700c		       85 4a		      sta	CTRLPF
     32  700e
     33  700e		       a9 c0		      lda	#$C0
     34  7010		       85 49		      sta	COLUBK
     35  7012
     36  7012		       a2 00		      ldx	#0	;Platform
     37  7014		       a9 00		      lda	#<colr_ntsc2	;colvec,x
     38  7016		       85 a7		      sta	__colour_table
     39  7018		       a9 f5		      lda	#>colr_ntsc2	;colvec+1,x
     40  701a		       85 a8		      sta	__colour_table+1
     41  701c
     42  701c							;		  sta rndHi
     43  701c							;		  sta rnd
     44  701c
     45  701c
     46  701c				  -	      IF	0
     47  701c				  -	      lda	#0
     48  701c				  -	      sta	digit
     49  701c				  -	      lda	#$10
     50  701c				  -	      sta	digit+1
     51  701c				  -	      lda	#$20
     52  701c				  -	      sta	digit+2
     53  701c					      ENDIF
     54  701c
     55  701c
     56  701c
     57  701c
     58  701c							;RESYNC
     59  701c
     60  701c				   RestartFrame0
     61  701c
     62  701c				  -	      IF	0
     63  701c				  -	      ldx	#2
     64  701c				  -rollcols   clc
     65  701c				  -	      lda	digit+2
     66  701c				  -	      adc	#$10
     67  701c				  -	      sta	digit+2
     68  701c				  -	      bcc	finxc
     69  701c				  -	      dex
     70  701c				  -	      bpl	rollcols
     71  701c				  -finxc
     72  701c					      ENDIF
     73  701c
      0  701c					      DEF	RestartFrame
      1  701c				   SLOT_RestartFrame SET	_BANK_SLOT
      2  701c				   BANK_RestartFrame SET	SLOT_RestartFrame + _CURRENT_BANK
      3  701c				   RestartFrame
      4  701c				   TEMPORARY_VAR SET	Overlay
      5  701c				   TEMPORARY_OFFSET SET	0
      6  701c				   VAR_BOUNDARY_RestartFrame SET	TEMPORARY_OFFSET
      7  701c				   FUNCTION_NAME SET	RestartFrame
     75  701c		       a9 00		      LDA	#0
     76  701e		       a9 0e		      lda	#%1110	; VSYNC ON
     77  7020		       85 42	   .loopVSync2 sta	WSYNC
     78  7022		       85 40		      sta	VSYNC
     79  7024		       4a		      lsr
     80  7025		       d0 f9		      bne	.loopVSync2	; branch until VYSNC has been reset
     81  7027
     82  7027							;------------------------------------------------------------------
     83  7027
     84  7027		       a2 00		      ldx	#0	;Platform
     85  7029		       bc 04 f4 	      ldy	VBlankTime,x
     86  702c		       8c 96 02 	      sty	TIM64T
     87  702f
     88  702f
     89  702f				  -	      IF	0
     90  702f				  -	      lda	SWCHB
     91  702f				  -	      rol
     92  702f				  -	      rol
     93  702f				  -	      rol
     94  702f				  -	      and	#%11
     95  702f				  -	      eor	#PAL
     96  702f				  -	      cmp	#0	;Platform
     97  702f				  -	      beq	platOK
     98  702f				  -			;sta Platform
     99  702f				  -	      jmp	TitleSequence
    100  702f				  -platOK
    101  702f					      ENDIF
    102  702f
    103  702f		       e6 81	   k2	      inc	rnd
    104  7031		       f0 fc		      beq	k2
    105  7033
    106  7033
    107  7033		       85 42	   VerticalBlank sta	WSYNC
    108  7035		       ad 84 02 	      lda	INTIM
    109  7038		       d0 f9		      bne	VerticalBlank
    110  703a		       85 41		      sta	VBLANK
    111  703c
    112  703c		       a9 00		      lda	#$0
    113  703e		       85 49		      sta	COLUBK
    114  7040
    115  7040							;------------------------------------------------------------------
    116  7040
    117  7040							; Do X scanlines of color-changing (our picture)
    118  7040
    119  7040		       a0 c9		      ldy	#67*3	; this counts our scanline number
    120  7042				   SokoLogo
    121  7042
    122  7042
    123  7042		       a9 24		      lda	#$24
    124  7044
    125  7044		       85 42		      sta	WSYNC
    126  7046		       85 48		      sta	COLUPF	; 3
    127  7048
    128  7048		       b9 00 f8 	      lda	COL_0,y	; 5
    129  704b		       85 4d		      sta	PF0	; 3   @11
    130  704d		       b9 cc f8 	      lda	COL_1,y	; 5
    131  7050		       85 4e		      sta	PF1	; 3   @19
    132  7052		       b9 98 f9 	      lda	COL_2,y	; 5
    133  7055		       85 4f		      sta	PF2	; 3   @27
    134  7057
    135  7057		       b9 00 f8 	      lda	COL_0,y	; 5
    136  705a		       0a		      asl
    137  705b		       0a		      asl
    138  705c		       0a		      asl
    139  705d		       0a		      asl
    140  705e		       85 4d		      sta	PF0	; 3   @35
    141  7060							;		  SLEEP 2      ; @37
    142  7060		       b9 64 fa 	      lda	COL_3,y	; 5
    143  7063		       85 4e		      sta	PF1	; 3   @45
    144  7065							;		  SLEEP 3      ; @45
    145  7065		       b9 30 fb 	      lda	COL_4,y	; 5
    146  7068		       85 4f		      sta	PF2	; 3
    147  706a
    148  706a		       88		      dey
    149  706b
    150  706b		       a9 68		      lda	#$68
    151  706d
    152  706d		       85 42		      sta	WSYNC
    153  706f		       85 48		      sta	COLUPF	; 3
    154  7071
    155  7071		       b9 00 f8 	      lda	COL_0,y	; 5
    156  7074		       85 4d		      sta	PF0	; 3   @11
    157  7076		       b9 cc f8 	      lda	COL_1,y	; 5
    158  7079		       85 4e		      sta	PF1	; 3   @19
    159  707b		       b9 98 f9 	      lda	COL_2,y	; 5
    160  707e		       85 4f		      sta	PF2	; 3   @27
    161  7080
    162  7080		       b9 00 f8 	      lda	COL_0,y	; 5
    163  7083		       0a		      asl
    164  7084		       0a		      asl
    165  7085		       0a		      asl
    166  7086		       0a		      asl
    167  7087		       85 4d		      sta	PF0	; 3   @35
    168  7089							;		  SLEEP 2      ; @37
    169  7089		       b9 64 fa 	      lda	COL_3,y	; 5
    170  708c		       85 4e		      sta	PF1	; 3   @45
    171  708e							;		  SLEEP 3      ; @45
    172  708e		       b9 30 fb 	      lda	COL_4,y	; 5
    173  7091		       85 4f		      sta	PF2	; 3
    174  7093
    175  7093		       88		      dey
    176  7094
    177  7094
    178  7094		       a9 d6		      lda	#$D6
    179  7096
    180  7096		       85 42		      sta	WSYNC
    181  7098		       85 48		      sta	COLUPF	; 3
    182  709a
    183  709a		       b9 00 f8 	      lda	COL_0,y	; 5
    184  709d		       85 4d		      sta	PF0	; 3   @11
    185  709f		       b9 cc f8 	      lda	COL_1,y	; 5
    186  70a2		       85 4e		      sta	PF1	; 3   @19
    187  70a4		       b9 98 f9 	      lda	COL_2,y	; 5
    188  70a7		       85 4f		      sta	PF2	; 3   @27
    189  70a9
    190  70a9		       b9 00 f8 	      lda	COL_0,y	; 5
    191  70ac		       0a		      asl
    192  70ad		       0a		      asl
    193  70ae		       0a		      asl
    194  70af		       0a		      asl
    195  70b0		       85 4d		      sta	PF0	; 3   @35
    196  70b2							;		  SLEEP 2      ; @37
    197  70b2		       b9 64 fa 	      lda	COL_3,y	; 5
    198  70b5		       85 4e		      sta	PF1	; 3   @45
    199  70b7							;		  SLEEP 3      ; @45
    200  70b7		       b9 30 fb 	      lda	COL_4,y	; 5
    201  70ba		       85 4f		      sta	PF2	; 3
    202  70bc
    203  70bc
    204  70bc
    205  70bc		       88		      dey		; 2
    206  70bd		       d0 83		      bne	SokoLogo	; 2(3)
    207  70bf
    208  70bf							;lda #0
    209  70bf							;sta PF0
    210  70bf							;sta PF1
    211  70bf							;sta PF2
    212  70bf
    213  70bf		       a2 00		      ldx	#0	;Platform
    214  70c1		       86 4d		      stx	PF0
    215  70c3		       86 4e		      stx	PF1
    216  70c5		       86 4f		      stx	PF2
    217  70c7
    218  70c7		       85 42		      sta	WSYNC
    219  70c9		       85 42		      sta	WSYNC
    220  70cb		       85 42		      sta	WSYNC
    221  70cd		       85 42		      sta	WSYNC
    222  70cf
    223  70cf		       86 49		      stx	COLUBK
    224  70d1		       bd 00 f4 	      lda	OverscanTime2,x
    225  70d4		       8d 96 02 	      sta	TIM64T
    226  70d7
    227  70d7				  -	      IF	0
    228  70d7				  -	      sta	WSYNC
    229  70d7				  -	      sta	WSYNC
    230  70d7				  -	      sta	WSYNC
    231  70d7				  -	      sta	WSYNC
    232  70d7				  -	      sta	WSYNC
    233  70d7				  -	      SLEEP	8
    234  70d7				  -	      jsr	SokoScreen
    235  70d7				  -
    236  70d7				  -	      lda	#0
    237  70d7				  -	      sta	BoardScrollX
    238  70d7				  -	      sta	BoardScrollY
    239  70d7					      ENDIF
    240  70d7
    241  70d7							;		ldy #63
    242  70d7							;bot2		 sta WSYNC
    243  70d7							;		dey
    244  70d7							;		bpl bot2
    245  70d7
    246  70d7							;--------------------------------------------------------------------------
    247  70d7
    248  70d7		       a9 00		      lda	#0
    249  70d9		       85 4d		      sta	PF0
    250  70db		       85 4e		      sta	PF1
    251  70dd		       85 4f		      sta	PF2
    252  70df
    253  70df
      0  70df					      NEXT_RANDOM
      1  70df		       a5 81		      lda	rnd
      2  70e1		       4a		      lsr
      3  70e2		       90 02		      bcc	.skipEOR
      4  70e4		       49 fe		      eor	#RND_EOR_VAL
      5  70e6		       85 81	   .skipEOR   sta	rnd
    255  70e8
    256  70e8							; D1 VBLANK turns off beam
    257  70e8							; It needs to be turned on 37 scanlines later
    258  70e8
    259  70e8				   oscan
    260  70e8		       ad 84 02 	      lda	INTIM
    261  70eb		       d0 fb		      bne	oscan
    262  70ed
    263  70ed		       a9 42		      lda	#%01000010	; bit6 is not required
    264  70ef		       85 41		      sta	VBLANK	; end of screen - enter blanking
    265  70f1
    266  70f1				  -	      IF	0
    267  70f1				  -	      inc	rnd
    268  70f1				  -	      bne	rdd
    269  70f1				  -	      inc	rndHi
    270  70f1				  -rdd
    271  70f1				  -
    272  70f1				  -	      dec	digitick
    273  70f1				  -	      bpl	ret2
    274  70f1				  -	      lda	#40
    275  70f1				  -	      sta	digitick
    276  70f1				  -
    277  70f1				  -	      jsr	Random
    278  70f1				  -	      and	#3
    279  70f1				  -	      beq	ret2
    280  70f1				  -	      tax
    281  70f1				  -	      jsr	Random
    282  70f1				  -	      and	#$F0
    283  70f1				  -	      sta	digit-1,x
    284  70f1				  -	      jmp	RestartFrame0
    285  70f1				  -
    286  70f1				  -ret2
    287  70f1					      ENDIF
    288  70f1
    289  70f1
    290  70f1		       a5 4c		      lda	INPT4
    291  70f3		       10 03		      bpl	ret
    292  70f5
    293  70f5		       4c 1c f4 	      jmp	RestartFrame
    294  70f8
    295  70f8				   ret
    296  70f8		       60		      rts
    297  70f9
    298  70f9
    299  70f9
    300  70f9					      MAC	lumtable
    301  70f9							; {4} MIN LUM 1
    302  70f9							; {5} MIN LUM 2
    303  70f9							; {6} MIN LUM 3
    304  70f9
    305  70f9				   .LUM1      SET	{4}*256
    306  70f9				   .LUM2      SET	{5}*256
    307  70f9				   .LUM3      SET	{6}*256
    308  70f9
    309  70f9				   .STEP1     =	(256*({7}-{4}))/72
    310  70f9				   .STEP2     =	(256*({8}-{5}))/72
    311  70f9				   .STEP3     =	(256*({9}-{6}))/72
    312  70f9
    313  70f9					      REPEAT	72
    314  70f9					      .byte	{1}+(.LUM1/256)
    315  70f9					      .byte	{2}+(.LUM2/256)
    316  70f9					      .byte	{3}+(.LUM3/256)
    317  70f9
    318  70f9							;    ECHO {1}+(.LUM1/256)
    319  70f9							;    ECHO {2}+(.LUM1/256)
    320  70f9							;    ECHO {3}+(.LUM1/256)
    321  70f9
    322  70f9				   .LUM1      SET	.LUM1 + .STEP1
    323  70f9				   .LUM2      SET	.LUM2 + .STEP2
    324  70f9				   .LUM3      SET	.LUM3 + .STEP3
    325  70f9					      REPEND
    326  70f9					      ENDM		;{1}{2}{3} base colours
    327  70f9
    328  70f9							;colr_pal    LUMTABLE $B0,$30,$A0,0,8,4 ;2,4,6
    329  70f9							;    OPTIONAL_PAGEBREAK "colr_ntsc", 72*3
    330  70f9
    331  7100		       00 00 00 00*	      align	256
    332  7100							;    ECHO "NTSC LUMS"
    333  7100				   colr_ntsc2
      0  7100					      LUMTABLE	$90,$10,$20,$4,$6,$8,$4,$6,$8
      1  7100
      2  7100
      3  7100
      4  7100
      5  7100				   .LUM1      SET	$4*256
      6  7100				   .LUM2      SET	$6*256
      7  7100				   .LUM3      SET	$8*256
      8  7100
      9  7100		       00 00	   .STEP1     =	(256*($4-$4))/72
     10  7100		       00 00	   .STEP2     =	(256*($6-$6))/72
     11  7100		       00 00	   .STEP3     =	(256*($8-$8))/72
     12  7100
     13  7100					      REPEAT	72
     14  7100		       94		      .byte.b	$90+(.LUM1/256)
     15  7101		       16		      .byte.b	$10+(.LUM2/256)
     16  7102		       28		      .byte.b	$20+(.LUM3/256)
     17  7103
     18  7103
     19  7103
     20  7103
     21  7103
     22  7103				   .LUM1      SET	.LUM1 + .STEP1
     23  7103				   .LUM2      SET	.LUM2 + .STEP2
     24  7103				   .LUM3      SET	.LUM3 + .STEP3
     13  7103					      REPEND
     14  7103		       94		      .byte.b	$90+(.LUM1/256)
     15  7104		       16		      .byte.b	$10+(.LUM2/256)
     16  7105		       28		      .byte.b	$20+(.LUM3/256)
     17  7106
     18  7106
     19  7106
     20  7106
     21  7106
     22  7106				   .LUM1      SET	.LUM1 + .STEP1
     23  7106				   .LUM2      SET	.LUM2 + .STEP2
     24  7106				   .LUM3      SET	.LUM3 + .STEP3
     13  7106					      REPEND
     14  7106		       94		      .byte.b	$90+(.LUM1/256)
     15  7107		       16		      .byte.b	$10+(.LUM2/256)
     16  7108		       28		      .byte.b	$20+(.LUM3/256)
     17  7109
     18  7109
     19  7109
     20  7109
     21  7109
     22  7109				   .LUM1      SET	.LUM1 + .STEP1
     23  7109				   .LUM2      SET	.LUM2 + .STEP2
     24  7109				   .LUM3      SET	.LUM3 + .STEP3
     13  7109					      REPEND
     14  7109		       94		      .byte.b	$90+(.LUM1/256)
     15  710a		       16		      .byte.b	$10+(.LUM2/256)
     16  710b		       28		      .byte.b	$20+(.LUM3/256)
     17  710c
     18  710c
     19  710c
     20  710c
     21  710c
     22  710c				   .LUM1      SET	.LUM1 + .STEP1
     23  710c				   .LUM2      SET	.LUM2 + .STEP2
     24  710c				   .LUM3      SET	.LUM3 + .STEP3
     13  710c					      REPEND
     14  710c		       94		      .byte.b	$90+(.LUM1/256)
     15  710d		       16		      .byte.b	$10+(.LUM2/256)
     16  710e		       28		      .byte.b	$20+(.LUM3/256)
     17  710f
     18  710f
     19  710f
     20  710f
     21  710f
     22  710f				   .LUM1      SET	.LUM1 + .STEP1
     23  710f				   .LUM2      SET	.LUM2 + .STEP2
     24  710f				   .LUM3      SET	.LUM3 + .STEP3
     13  710f					      REPEND
     14  710f		       94		      .byte.b	$90+(.LUM1/256)
     15  7110		       16		      .byte.b	$10+(.LUM2/256)
     16  7111		       28		      .byte.b	$20+(.LUM3/256)
     17  7112
     18  7112
     19  7112
     20  7112
     21  7112
     22  7112				   .LUM1      SET	.LUM1 + .STEP1
     23  7112				   .LUM2      SET	.LUM2 + .STEP2
     24  7112				   .LUM3      SET	.LUM3 + .STEP3
     13  7112					      REPEND
     14  7112		       94		      .byte.b	$90+(.LUM1/256)
     15  7113		       16		      .byte.b	$10+(.LUM2/256)
     16  7114		       28		      .byte.b	$20+(.LUM3/256)
     17  7115
     18  7115
     19  7115
     20  7115
     21  7115
     22  7115				   .LUM1      SET	.LUM1 + .STEP1
     23  7115				   .LUM2      SET	.LUM2 + .STEP2
     24  7115				   .LUM3      SET	.LUM3 + .STEP3
     13  7115					      REPEND
     14  7115		       94		      .byte.b	$90+(.LUM1/256)
     15  7116		       16		      .byte.b	$10+(.LUM2/256)
     16  7117		       28		      .byte.b	$20+(.LUM3/256)
     17  7118
     18  7118
     19  7118
     20  7118
     21  7118
     22  7118				   .LUM1      SET	.LUM1 + .STEP1
     23  7118				   .LUM2      SET	.LUM2 + .STEP2
     24  7118				   .LUM3      SET	.LUM3 + .STEP3
     13  7118					      REPEND
     14  7118		       94		      .byte.b	$90+(.LUM1/256)
     15  7119		       16		      .byte.b	$10+(.LUM2/256)
     16  711a		       28		      .byte.b	$20+(.LUM3/256)
     17  711b
     18  711b
     19  711b
     20  711b
     21  711b
     22  711b				   .LUM1      SET	.LUM1 + .STEP1
     23  711b				   .LUM2      SET	.LUM2 + .STEP2
     24  711b				   .LUM3      SET	.LUM3 + .STEP3
     13  711b					      REPEND
     14  711b		       94		      .byte.b	$90+(.LUM1/256)
     15  711c		       16		      .byte.b	$10+(.LUM2/256)
     16  711d		       28		      .byte.b	$20+(.LUM3/256)
     17  711e
     18  711e
     19  711e
     20  711e
     21  711e
     22  711e				   .LUM1      SET	.LUM1 + .STEP1
     23  711e				   .LUM2      SET	.LUM2 + .STEP2
     24  711e				   .LUM3      SET	.LUM3 + .STEP3
     13  711e					      REPEND
     14  711e		       94		      .byte.b	$90+(.LUM1/256)
     15  711f		       16		      .byte.b	$10+(.LUM2/256)
     16  7120		       28		      .byte.b	$20+(.LUM3/256)
     17  7121
     18  7121
     19  7121
     20  7121
     21  7121
     22  7121				   .LUM1      SET	.LUM1 + .STEP1
     23  7121				   .LUM2      SET	.LUM2 + .STEP2
     24  7121				   .LUM3      SET	.LUM3 + .STEP3
     13  7121					      REPEND
     14  7121		       94		      .byte.b	$90+(.LUM1/256)
     15  7122		       16		      .byte.b	$10+(.LUM2/256)
     16  7123		       28		      .byte.b	$20+(.LUM3/256)
     17  7124
     18  7124
     19  7124
     20  7124
     21  7124
     22  7124				   .LUM1      SET	.LUM1 + .STEP1
     23  7124				   .LUM2      SET	.LUM2 + .STEP2
     24  7124				   .LUM3      SET	.LUM3 + .STEP3
     13  7124					      REPEND
     14  7124		       94		      .byte.b	$90+(.LUM1/256)
     15  7125		       16		      .byte.b	$10+(.LUM2/256)
     16  7126		       28		      .byte.b	$20+(.LUM3/256)
     17  7127
     18  7127
     19  7127
     20  7127
     21  7127
     22  7127				   .LUM1      SET	.LUM1 + .STEP1
     23  7127				   .LUM2      SET	.LUM2 + .STEP2
     24  7127				   .LUM3      SET	.LUM3 + .STEP3
     13  7127					      REPEND
     14  7127		       94		      .byte.b	$90+(.LUM1/256)
     15  7128		       16		      .byte.b	$10+(.LUM2/256)
     16  7129		       28		      .byte.b	$20+(.LUM3/256)
     17  712a
     18  712a
     19  712a
     20  712a
     21  712a
     22  712a				   .LUM1      SET	.LUM1 + .STEP1
     23  712a				   .LUM2      SET	.LUM2 + .STEP2
     24  712a				   .LUM3      SET	.LUM3 + .STEP3
     13  712a					      REPEND
     14  712a		       94		      .byte.b	$90+(.LUM1/256)
     15  712b		       16		      .byte.b	$10+(.LUM2/256)
     16  712c		       28		      .byte.b	$20+(.LUM3/256)
     17  712d
     18  712d
     19  712d
     20  712d
     21  712d
     22  712d				   .LUM1      SET	.LUM1 + .STEP1
     23  712d				   .LUM2      SET	.LUM2 + .STEP2
     24  712d				   .LUM3      SET	.LUM3 + .STEP3
     13  712d					      REPEND
     14  712d		       94		      .byte.b	$90+(.LUM1/256)
     15  712e		       16		      .byte.b	$10+(.LUM2/256)
     16  712f		       28		      .byte.b	$20+(.LUM3/256)
     17  7130
     18  7130
     19  7130
     20  7130
     21  7130
     22  7130				   .LUM1      SET	.LUM1 + .STEP1
     23  7130				   .LUM2      SET	.LUM2 + .STEP2
     24  7130				   .LUM3      SET	.LUM3 + .STEP3
     13  7130					      REPEND
     14  7130		       94		      .byte.b	$90+(.LUM1/256)
     15  7131		       16		      .byte.b	$10+(.LUM2/256)
     16  7132		       28		      .byte.b	$20+(.LUM3/256)
     17  7133
     18  7133
     19  7133
     20  7133
     21  7133
     22  7133				   .LUM1      SET	.LUM1 + .STEP1
     23  7133				   .LUM2      SET	.LUM2 + .STEP2
     24  7133				   .LUM3      SET	.LUM3 + .STEP3
     13  7133					      REPEND
     14  7133		       94		      .byte.b	$90+(.LUM1/256)
     15  7134		       16		      .byte.b	$10+(.LUM2/256)
     16  7135		       28		      .byte.b	$20+(.LUM3/256)
     17  7136
     18  7136
     19  7136
     20  7136
     21  7136
     22  7136				   .LUM1      SET	.LUM1 + .STEP1
     23  7136				   .LUM2      SET	.LUM2 + .STEP2
     24  7136				   .LUM3      SET	.LUM3 + .STEP3
     13  7136					      REPEND
     14  7136		       94		      .byte.b	$90+(.LUM1/256)
     15  7137		       16		      .byte.b	$10+(.LUM2/256)
     16  7138		       28		      .byte.b	$20+(.LUM3/256)
     17  7139
     18  7139
     19  7139
     20  7139
     21  7139
     22  7139				   .LUM1      SET	.LUM1 + .STEP1
     23  7139				   .LUM2      SET	.LUM2 + .STEP2
     24  7139				   .LUM3      SET	.LUM3 + .STEP3
     13  7139					      REPEND
     14  7139		       94		      .byte.b	$90+(.LUM1/256)
     15  713a		       16		      .byte.b	$10+(.LUM2/256)
     16  713b		       28		      .byte.b	$20+(.LUM3/256)
     17  713c
     18  713c
     19  713c
     20  713c
     21  713c
     22  713c				   .LUM1      SET	.LUM1 + .STEP1
     23  713c				   .LUM2      SET	.LUM2 + .STEP2
     24  713c				   .LUM3      SET	.LUM3 + .STEP3
     13  713c					      REPEND
     14  713c		       94		      .byte.b	$90+(.LUM1/256)
     15  713d		       16		      .byte.b	$10+(.LUM2/256)
     16  713e		       28		      .byte.b	$20+(.LUM3/256)
     17  713f
     18  713f
     19  713f
     20  713f
     21  713f
     22  713f				   .LUM1      SET	.LUM1 + .STEP1
     23  713f				   .LUM2      SET	.LUM2 + .STEP2
     24  713f				   .LUM3      SET	.LUM3 + .STEP3
     13  713f					      REPEND
     14  713f		       94		      .byte.b	$90+(.LUM1/256)
     15  7140		       16		      .byte.b	$10+(.LUM2/256)
     16  7141		       28		      .byte.b	$20+(.LUM3/256)
     17  7142
     18  7142
     19  7142
     20  7142
     21  7142
     22  7142				   .LUM1      SET	.LUM1 + .STEP1
     23  7142				   .LUM2      SET	.LUM2 + .STEP2
     24  7142				   .LUM3      SET	.LUM3 + .STEP3
     13  7142					      REPEND
     14  7142		       94		      .byte.b	$90+(.LUM1/256)
     15  7143		       16		      .byte.b	$10+(.LUM2/256)
     16  7144		       28		      .byte.b	$20+(.LUM3/256)
     17  7145
     18  7145
     19  7145
     20  7145
     21  7145
     22  7145				   .LUM1      SET	.LUM1 + .STEP1
     23  7145				   .LUM2      SET	.LUM2 + .STEP2
     24  7145				   .LUM3      SET	.LUM3 + .STEP3
     13  7145					      REPEND
     14  7145		       94		      .byte.b	$90+(.LUM1/256)
     15  7146		       16		      .byte.b	$10+(.LUM2/256)
     16  7147		       28		      .byte.b	$20+(.LUM3/256)
     17  7148
     18  7148
     19  7148
     20  7148
     21  7148
     22  7148				   .LUM1      SET	.LUM1 + .STEP1
     23  7148				   .LUM2      SET	.LUM2 + .STEP2
     24  7148				   .LUM3      SET	.LUM3 + .STEP3
     13  7148					      REPEND
     14  7148		       94		      .byte.b	$90+(.LUM1/256)
     15  7149		       16		      .byte.b	$10+(.LUM2/256)
     16  714a		       28		      .byte.b	$20+(.LUM3/256)
     17  714b
     18  714b
     19  714b
     20  714b
     21  714b
     22  714b				   .LUM1      SET	.LUM1 + .STEP1
     23  714b				   .LUM2      SET	.LUM2 + .STEP2
     24  714b				   .LUM3      SET	.LUM3 + .STEP3
     13  714b					      REPEND
     14  714b		       94		      .byte.b	$90+(.LUM1/256)
     15  714c		       16		      .byte.b	$10+(.LUM2/256)
     16  714d		       28		      .byte.b	$20+(.LUM3/256)
     17  714e
     18  714e
     19  714e
     20  714e
     21  714e
     22  714e				   .LUM1      SET	.LUM1 + .STEP1
     23  714e				   .LUM2      SET	.LUM2 + .STEP2
     24  714e				   .LUM3      SET	.LUM3 + .STEP3
     13  714e					      REPEND
     14  714e		       94		      .byte.b	$90+(.LUM1/256)
     15  714f		       16		      .byte.b	$10+(.LUM2/256)
     16  7150		       28		      .byte.b	$20+(.LUM3/256)
     17  7151
     18  7151
     19  7151
     20  7151
     21  7151
     22  7151				   .LUM1      SET	.LUM1 + .STEP1
     23  7151				   .LUM2      SET	.LUM2 + .STEP2
     24  7151				   .LUM3      SET	.LUM3 + .STEP3
     13  7151					      REPEND
     14  7151		       94		      .byte.b	$90+(.LUM1/256)
     15  7152		       16		      .byte.b	$10+(.LUM2/256)
     16  7153		       28		      .byte.b	$20+(.LUM3/256)
     17  7154
     18  7154
     19  7154
     20  7154
     21  7154
     22  7154				   .LUM1      SET	.LUM1 + .STEP1
     23  7154				   .LUM2      SET	.LUM2 + .STEP2
     24  7154				   .LUM3      SET	.LUM3 + .STEP3
     13  7154					      REPEND
     14  7154		       94		      .byte.b	$90+(.LUM1/256)
     15  7155		       16		      .byte.b	$10+(.LUM2/256)
     16  7156		       28		      .byte.b	$20+(.LUM3/256)
     17  7157
     18  7157
     19  7157
     20  7157
     21  7157
     22  7157				   .LUM1      SET	.LUM1 + .STEP1
     23  7157				   .LUM2      SET	.LUM2 + .STEP2
     24  7157				   .LUM3      SET	.LUM3 + .STEP3
     13  7157					      REPEND
     14  7157		       94		      .byte.b	$90+(.LUM1/256)
     15  7158		       16		      .byte.b	$10+(.LUM2/256)
     16  7159		       28		      .byte.b	$20+(.LUM3/256)
     17  715a
     18  715a
     19  715a
     20  715a
     21  715a
     22  715a				   .LUM1      SET	.LUM1 + .STEP1
     23  715a				   .LUM2      SET	.LUM2 + .STEP2
     24  715a				   .LUM3      SET	.LUM3 + .STEP3
     13  715a					      REPEND
     14  715a		       94		      .byte.b	$90+(.LUM1/256)
     15  715b		       16		      .byte.b	$10+(.LUM2/256)
     16  715c		       28		      .byte.b	$20+(.LUM3/256)
     17  715d
     18  715d
     19  715d
     20  715d
     21  715d
     22  715d				   .LUM1      SET	.LUM1 + .STEP1
     23  715d				   .LUM2      SET	.LUM2 + .STEP2
     24  715d				   .LUM3      SET	.LUM3 + .STEP3
     13  715d					      REPEND
     14  715d		       94		      .byte.b	$90+(.LUM1/256)
     15  715e		       16		      .byte.b	$10+(.LUM2/256)
     16  715f		       28		      .byte.b	$20+(.LUM3/256)
     17  7160
     18  7160
     19  7160
     20  7160
     21  7160
     22  7160				   .LUM1      SET	.LUM1 + .STEP1
     23  7160				   .LUM2      SET	.LUM2 + .STEP2
     24  7160				   .LUM3      SET	.LUM3 + .STEP3
     13  7160					      REPEND
     14  7160		       94		      .byte.b	$90+(.LUM1/256)
     15  7161		       16		      .byte.b	$10+(.LUM2/256)
     16  7162		       28		      .byte.b	$20+(.LUM3/256)
     17  7163
     18  7163
     19  7163
     20  7163
     21  7163
     22  7163				   .LUM1      SET	.LUM1 + .STEP1
     23  7163				   .LUM2      SET	.LUM2 + .STEP2
     24  7163				   .LUM3      SET	.LUM3 + .STEP3
     13  7163					      REPEND
     14  7163		       94		      .byte.b	$90+(.LUM1/256)
     15  7164		       16		      .byte.b	$10+(.LUM2/256)
     16  7165		       28		      .byte.b	$20+(.LUM3/256)
     17  7166
     18  7166
     19  7166
     20  7166
     21  7166
     22  7166				   .LUM1      SET	.LUM1 + .STEP1
     23  7166				   .LUM2      SET	.LUM2 + .STEP2
     24  7166				   .LUM3      SET	.LUM3 + .STEP3
     13  7166					      REPEND
     14  7166		       94		      .byte.b	$90+(.LUM1/256)
     15  7167		       16		      .byte.b	$10+(.LUM2/256)
     16  7168		       28		      .byte.b	$20+(.LUM3/256)
     17  7169
     18  7169
     19  7169
     20  7169
     21  7169
     22  7169				   .LUM1      SET	.LUM1 + .STEP1
     23  7169				   .LUM2      SET	.LUM2 + .STEP2
     24  7169				   .LUM3      SET	.LUM3 + .STEP3
     13  7169					      REPEND
     14  7169		       94		      .byte.b	$90+(.LUM1/256)
     15  716a		       16		      .byte.b	$10+(.LUM2/256)
     16  716b		       28		      .byte.b	$20+(.LUM3/256)
     17  716c
     18  716c
     19  716c
     20  716c
     21  716c
     22  716c				   .LUM1      SET	.LUM1 + .STEP1
     23  716c				   .LUM2      SET	.LUM2 + .STEP2
     24  716c				   .LUM3      SET	.LUM3 + .STEP3
     13  716c					      REPEND
     14  716c		       94		      .byte.b	$90+(.LUM1/256)
     15  716d		       16		      .byte.b	$10+(.LUM2/256)
     16  716e		       28		      .byte.b	$20+(.LUM3/256)
     17  716f
     18  716f
     19  716f
     20  716f
     21  716f
     22  716f				   .LUM1      SET	.LUM1 + .STEP1
     23  716f				   .LUM2      SET	.LUM2 + .STEP2
     24  716f				   .LUM3      SET	.LUM3 + .STEP3
     13  716f					      REPEND
     14  716f		       94		      .byte.b	$90+(.LUM1/256)
     15  7170		       16		      .byte.b	$10+(.LUM2/256)
     16  7171		       28		      .byte.b	$20+(.LUM3/256)
     17  7172
     18  7172
     19  7172
     20  7172
     21  7172
     22  7172				   .LUM1      SET	.LUM1 + .STEP1
     23  7172				   .LUM2      SET	.LUM2 + .STEP2
     24  7172				   .LUM3      SET	.LUM3 + .STEP3
     13  7172					      REPEND
     14  7172		       94		      .byte.b	$90+(.LUM1/256)
     15  7173		       16		      .byte.b	$10+(.LUM2/256)
     16  7174		       28		      .byte.b	$20+(.LUM3/256)
     17  7175
     18  7175
     19  7175
     20  7175
     21  7175
     22  7175				   .LUM1      SET	.LUM1 + .STEP1
     23  7175				   .LUM2      SET	.LUM2 + .STEP2
     24  7175				   .LUM3      SET	.LUM3 + .STEP3
     13  7175					      REPEND
     14  7175		       94		      .byte.b	$90+(.LUM1/256)
     15  7176		       16		      .byte.b	$10+(.LUM2/256)
     16  7177		       28		      .byte.b	$20+(.LUM3/256)
     17  7178
     18  7178
     19  7178
     20  7178
     21  7178
     22  7178				   .LUM1      SET	.LUM1 + .STEP1
     23  7178				   .LUM2      SET	.LUM2 + .STEP2
     24  7178				   .LUM3      SET	.LUM3 + .STEP3
     13  7178					      REPEND
     14  7178		       94		      .byte.b	$90+(.LUM1/256)
     15  7179		       16		      .byte.b	$10+(.LUM2/256)
     16  717a		       28		      .byte.b	$20+(.LUM3/256)
     17  717b
     18  717b
     19  717b
     20  717b
     21  717b
     22  717b				   .LUM1      SET	.LUM1 + .STEP1
     23  717b				   .LUM2      SET	.LUM2 + .STEP2
     24  717b				   .LUM3      SET	.LUM3 + .STEP3
     13  717b					      REPEND
     14  717b		       94		      .byte.b	$90+(.LUM1/256)
     15  717c		       16		      .byte.b	$10+(.LUM2/256)
     16  717d		       28		      .byte.b	$20+(.LUM3/256)
     17  717e
     18  717e
     19  717e
     20  717e
     21  717e
     22  717e				   .LUM1      SET	.LUM1 + .STEP1
     23  717e				   .LUM2      SET	.LUM2 + .STEP2
     24  717e				   .LUM3      SET	.LUM3 + .STEP3
     13  717e					      REPEND
     14  717e		       94		      .byte.b	$90+(.LUM1/256)
     15  717f		       16		      .byte.b	$10+(.LUM2/256)
     16  7180		       28		      .byte.b	$20+(.LUM3/256)
     17  7181
     18  7181
     19  7181
     20  7181
     21  7181
     22  7181				   .LUM1      SET	.LUM1 + .STEP1
     23  7181				   .LUM2      SET	.LUM2 + .STEP2
     24  7181				   .LUM3      SET	.LUM3 + .STEP3
     13  7181					      REPEND
     14  7181		       94		      .byte.b	$90+(.LUM1/256)
     15  7182		       16		      .byte.b	$10+(.LUM2/256)
     16  7183		       28		      .byte.b	$20+(.LUM3/256)
     17  7184
     18  7184
     19  7184
     20  7184
     21  7184
     22  7184				   .LUM1      SET	.LUM1 + .STEP1
     23  7184				   .LUM2      SET	.LUM2 + .STEP2
     24  7184				   .LUM3      SET	.LUM3 + .STEP3
     13  7184					      REPEND
     14  7184		       94		      .byte.b	$90+(.LUM1/256)
     15  7185		       16		      .byte.b	$10+(.LUM2/256)
     16  7186		       28		      .byte.b	$20+(.LUM3/256)
     17  7187
     18  7187
     19  7187
     20  7187
     21  7187
     22  7187				   .LUM1      SET	.LUM1 + .STEP1
     23  7187				   .LUM2      SET	.LUM2 + .STEP2
     24  7187				   .LUM3      SET	.LUM3 + .STEP3
     13  7187					      REPEND
     14  7187		       94		      .byte.b	$90+(.LUM1/256)
     15  7188		       16		      .byte.b	$10+(.LUM2/256)
     16  7189		       28		      .byte.b	$20+(.LUM3/256)
     17  718a
     18  718a
     19  718a
     20  718a
     21  718a
     22  718a				   .LUM1      SET	.LUM1 + .STEP1
     23  718a				   .LUM2      SET	.LUM2 + .STEP2
     24  718a				   .LUM3      SET	.LUM3 + .STEP3
     13  718a					      REPEND
     14  718a		       94		      .byte.b	$90+(.LUM1/256)
     15  718b		       16		      .byte.b	$10+(.LUM2/256)
     16  718c		       28		      .byte.b	$20+(.LUM3/256)
     17  718d
     18  718d
     19  718d
     20  718d
     21  718d
     22  718d				   .LUM1      SET	.LUM1 + .STEP1
     23  718d				   .LUM2      SET	.LUM2 + .STEP2
     24  718d				   .LUM3      SET	.LUM3 + .STEP3
     13  718d					      REPEND
     14  718d		       94		      .byte.b	$90+(.LUM1/256)
     15  718e		       16		      .byte.b	$10+(.LUM2/256)
     16  718f		       28		      .byte.b	$20+(.LUM3/256)
     17  7190
     18  7190
     19  7190
     20  7190
     21  7190
     22  7190				   .LUM1      SET	.LUM1 + .STEP1
     23  7190				   .LUM2      SET	.LUM2 + .STEP2
     24  7190				   .LUM3      SET	.LUM3 + .STEP3
     13  7190					      REPEND
     14  7190		       94		      .byte.b	$90+(.LUM1/256)
     15  7191		       16		      .byte.b	$10+(.LUM2/256)
     16  7192		       28		      .byte.b	$20+(.LUM3/256)
     17  7193
     18  7193
     19  7193
     20  7193
     21  7193
     22  7193				   .LUM1      SET	.LUM1 + .STEP1
     23  7193				   .LUM2      SET	.LUM2 + .STEP2
     24  7193				   .LUM3      SET	.LUM3 + .STEP3
     13  7193					      REPEND
     14  7193		       94		      .byte.b	$90+(.LUM1/256)
     15  7194		       16		      .byte.b	$10+(.LUM2/256)
     16  7195		       28		      .byte.b	$20+(.LUM3/256)
     17  7196
     18  7196
     19  7196
     20  7196
     21  7196
     22  7196				   .LUM1      SET	.LUM1 + .STEP1
     23  7196				   .LUM2      SET	.LUM2 + .STEP2
     24  7196				   .LUM3      SET	.LUM3 + .STEP3
     13  7196					      REPEND
     14  7196		       94		      .byte.b	$90+(.LUM1/256)
     15  7197		       16		      .byte.b	$10+(.LUM2/256)
     16  7198		       28		      .byte.b	$20+(.LUM3/256)
     17  7199
     18  7199
     19  7199
     20  7199
     21  7199
     22  7199				   .LUM1      SET	.LUM1 + .STEP1
     23  7199				   .LUM2      SET	.LUM2 + .STEP2
     24  7199				   .LUM3      SET	.LUM3 + .STEP3
     13  7199					      REPEND
     14  7199		       94		      .byte.b	$90+(.LUM1/256)
     15  719a		       16		      .byte.b	$10+(.LUM2/256)
     16  719b		       28		      .byte.b	$20+(.LUM3/256)
     17  719c
     18  719c
     19  719c
     20  719c
     21  719c
     22  719c				   .LUM1      SET	.LUM1 + .STEP1
     23  719c				   .LUM2      SET	.LUM2 + .STEP2
     24  719c				   .LUM3      SET	.LUM3 + .STEP3
     13  719c					      REPEND
     14  719c		       94		      .byte.b	$90+(.LUM1/256)
     15  719d		       16		      .byte.b	$10+(.LUM2/256)
     16  719e		       28		      .byte.b	$20+(.LUM3/256)
     17  719f
     18  719f
     19  719f
     20  719f
     21  719f
     22  719f				   .LUM1      SET	.LUM1 + .STEP1
     23  719f				   .LUM2      SET	.LUM2 + .STEP2
     24  719f				   .LUM3      SET	.LUM3 + .STEP3
     13  719f					      REPEND
     14  719f		       94		      .byte.b	$90+(.LUM1/256)
     15  71a0		       16		      .byte.b	$10+(.LUM2/256)
     16  71a1		       28		      .byte.b	$20+(.LUM3/256)
     17  71a2
     18  71a2
     19  71a2
     20  71a2
     21  71a2
     22  71a2				   .LUM1      SET	.LUM1 + .STEP1
     23  71a2				   .LUM2      SET	.LUM2 + .STEP2
     24  71a2				   .LUM3      SET	.LUM3 + .STEP3
     13  71a2					      REPEND
     14  71a2		       94		      .byte.b	$90+(.LUM1/256)
     15  71a3		       16		      .byte.b	$10+(.LUM2/256)
     16  71a4		       28		      .byte.b	$20+(.LUM3/256)
     17  71a5
     18  71a5
     19  71a5
     20  71a5
     21  71a5
     22  71a5				   .LUM1      SET	.LUM1 + .STEP1
     23  71a5				   .LUM2      SET	.LUM2 + .STEP2
     24  71a5				   .LUM3      SET	.LUM3 + .STEP3
     13  71a5					      REPEND
     14  71a5		       94		      .byte.b	$90+(.LUM1/256)
     15  71a6		       16		      .byte.b	$10+(.LUM2/256)
     16  71a7		       28		      .byte.b	$20+(.LUM3/256)
     17  71a8
     18  71a8
     19  71a8
     20  71a8
     21  71a8
     22  71a8				   .LUM1      SET	.LUM1 + .STEP1
     23  71a8				   .LUM2      SET	.LUM2 + .STEP2
     24  71a8				   .LUM3      SET	.LUM3 + .STEP3
     13  71a8					      REPEND
     14  71a8		       94		      .byte.b	$90+(.LUM1/256)
     15  71a9		       16		      .byte.b	$10+(.LUM2/256)
     16  71aa		       28		      .byte.b	$20+(.LUM3/256)
     17  71ab
     18  71ab
     19  71ab
     20  71ab
     21  71ab
     22  71ab				   .LUM1      SET	.LUM1 + .STEP1
     23  71ab				   .LUM2      SET	.LUM2 + .STEP2
     24  71ab				   .LUM3      SET	.LUM3 + .STEP3
     13  71ab					      REPEND
     14  71ab		       94		      .byte.b	$90+(.LUM1/256)
     15  71ac		       16		      .byte.b	$10+(.LUM2/256)
     16  71ad		       28		      .byte.b	$20+(.LUM3/256)
     17  71ae
     18  71ae
     19  71ae
     20  71ae
     21  71ae
     22  71ae				   .LUM1      SET	.LUM1 + .STEP1
     23  71ae				   .LUM2      SET	.LUM2 + .STEP2
     24  71ae				   .LUM3      SET	.LUM3 + .STEP3
     13  71ae					      REPEND
     14  71ae		       94		      .byte.b	$90+(.LUM1/256)
     15  71af		       16		      .byte.b	$10+(.LUM2/256)
     16  71b0		       28		      .byte.b	$20+(.LUM3/256)
     17  71b1
     18  71b1
     19  71b1
     20  71b1
     21  71b1
     22  71b1				   .LUM1      SET	.LUM1 + .STEP1
     23  71b1				   .LUM2      SET	.LUM2 + .STEP2
     24  71b1				   .LUM3      SET	.LUM3 + .STEP3
     13  71b1					      REPEND
     14  71b1		       94		      .byte.b	$90+(.LUM1/256)
     15  71b2		       16		      .byte.b	$10+(.LUM2/256)
     16  71b3		       28		      .byte.b	$20+(.LUM3/256)
     17  71b4
     18  71b4
     19  71b4
     20  71b4
     21  71b4
     22  71b4				   .LUM1      SET	.LUM1 + .STEP1
     23  71b4				   .LUM2      SET	.LUM2 + .STEP2
     24  71b4				   .LUM3      SET	.LUM3 + .STEP3
     13  71b4					      REPEND
     14  71b4		       94		      .byte.b	$90+(.LUM1/256)
     15  71b5		       16		      .byte.b	$10+(.LUM2/256)
     16  71b6		       28		      .byte.b	$20+(.LUM3/256)
     17  71b7
     18  71b7
     19  71b7
     20  71b7
     21  71b7
     22  71b7				   .LUM1      SET	.LUM1 + .STEP1
     23  71b7				   .LUM2      SET	.LUM2 + .STEP2
     24  71b7				   .LUM3      SET	.LUM3 + .STEP3
     13  71b7					      REPEND
     14  71b7		       94		      .byte.b	$90+(.LUM1/256)
     15  71b8		       16		      .byte.b	$10+(.LUM2/256)
     16  71b9		       28		      .byte.b	$20+(.LUM3/256)
     17  71ba
     18  71ba
     19  71ba
     20  71ba
     21  71ba
     22  71ba				   .LUM1      SET	.LUM1 + .STEP1
     23  71ba				   .LUM2      SET	.LUM2 + .STEP2
     24  71ba				   .LUM3      SET	.LUM3 + .STEP3
     13  71ba					      REPEND
     14  71ba		       94		      .byte.b	$90+(.LUM1/256)
     15  71bb		       16		      .byte.b	$10+(.LUM2/256)
     16  71bc		       28		      .byte.b	$20+(.LUM3/256)
     17  71bd
     18  71bd
     19  71bd
     20  71bd
     21  71bd
     22  71bd				   .LUM1      SET	.LUM1 + .STEP1
     23  71bd				   .LUM2      SET	.LUM2 + .STEP2
     24  71bd				   .LUM3      SET	.LUM3 + .STEP3
     13  71bd					      REPEND
     14  71bd		       94		      .byte.b	$90+(.LUM1/256)
     15  71be		       16		      .byte.b	$10+(.LUM2/256)
     16  71bf		       28		      .byte.b	$20+(.LUM3/256)
     17  71c0
     18  71c0
     19  71c0
     20  71c0
     21  71c0
     22  71c0				   .LUM1      SET	.LUM1 + .STEP1
     23  71c0				   .LUM2      SET	.LUM2 + .STEP2
     24  71c0				   .LUM3      SET	.LUM3 + .STEP3
     13  71c0					      REPEND
     14  71c0		       94		      .byte.b	$90+(.LUM1/256)
     15  71c1		       16		      .byte.b	$10+(.LUM2/256)
     16  71c2		       28		      .byte.b	$20+(.LUM3/256)
     17  71c3
     18  71c3
     19  71c3
     20  71c3
     21  71c3
     22  71c3				   .LUM1      SET	.LUM1 + .STEP1
     23  71c3				   .LUM2      SET	.LUM2 + .STEP2
     24  71c3				   .LUM3      SET	.LUM3 + .STEP3
     13  71c3					      REPEND
     14  71c3		       94		      .byte.b	$90+(.LUM1/256)
     15  71c4		       16		      .byte.b	$10+(.LUM2/256)
     16  71c5		       28		      .byte.b	$20+(.LUM3/256)
     17  71c6
     18  71c6
     19  71c6
     20  71c6
     21  71c6
     22  71c6				   .LUM1      SET	.LUM1 + .STEP1
     23  71c6				   .LUM2      SET	.LUM2 + .STEP2
     24  71c6				   .LUM3      SET	.LUM3 + .STEP3
     13  71c6					      REPEND
     14  71c6		       94		      .byte.b	$90+(.LUM1/256)
     15  71c7		       16		      .byte.b	$10+(.LUM2/256)
     16  71c8		       28		      .byte.b	$20+(.LUM3/256)
     17  71c9
     18  71c9
     19  71c9
     20  71c9
     21  71c9
     22  71c9				   .LUM1      SET	.LUM1 + .STEP1
     23  71c9				   .LUM2      SET	.LUM2 + .STEP2
     24  71c9				   .LUM3      SET	.LUM3 + .STEP3
     13  71c9					      REPEND
     14  71c9		       94		      .byte.b	$90+(.LUM1/256)
     15  71ca		       16		      .byte.b	$10+(.LUM2/256)
     16  71cb		       28		      .byte.b	$20+(.LUM3/256)
     17  71cc
     18  71cc
     19  71cc
     20  71cc
     21  71cc
     22  71cc				   .LUM1      SET	.LUM1 + .STEP1
     23  71cc				   .LUM2      SET	.LUM2 + .STEP2
     24  71cc				   .LUM3      SET	.LUM3 + .STEP3
     13  71cc					      REPEND
     14  71cc		       94		      .byte.b	$90+(.LUM1/256)
     15  71cd		       16		      .byte.b	$10+(.LUM2/256)
     16  71ce		       28		      .byte.b	$20+(.LUM3/256)
     17  71cf
     18  71cf
     19  71cf
     20  71cf
     21  71cf
     22  71cf				   .LUM1      SET	.LUM1 + .STEP1
     23  71cf				   .LUM2      SET	.LUM2 + .STEP2
     24  71cf				   .LUM3      SET	.LUM3 + .STEP3
     13  71cf					      REPEND
     14  71cf		       94		      .byte.b	$90+(.LUM1/256)
     15  71d0		       16		      .byte.b	$10+(.LUM2/256)
     16  71d1		       28		      .byte.b	$20+(.LUM3/256)
     17  71d2
     18  71d2
     19  71d2
     20  71d2
     21  71d2
     22  71d2				   .LUM1      SET	.LUM1 + .STEP1
     23  71d2				   .LUM2      SET	.LUM2 + .STEP2
     24  71d2				   .LUM3      SET	.LUM3 + .STEP3
     13  71d2					      REPEND
     14  71d2		       94		      .byte.b	$90+(.LUM1/256)
     15  71d3		       16		      .byte.b	$10+(.LUM2/256)
     16  71d4		       28		      .byte.b	$20+(.LUM3/256)
     17  71d5
     18  71d5
     19  71d5
     20  71d5
     21  71d5
     22  71d5				   .LUM1      SET	.LUM1 + .STEP1
     23  71d5				   .LUM2      SET	.LUM2 + .STEP2
     24  71d5				   .LUM3      SET	.LUM3 + .STEP3
     13  71d5					      REPEND
     14  71d5		       94		      .byte.b	$90+(.LUM1/256)
     15  71d6		       16		      .byte.b	$10+(.LUM2/256)
     16  71d7		       28		      .byte.b	$20+(.LUM3/256)
     17  71d8
     18  71d8
     19  71d8
     20  71d8
     21  71d8
     22  71d8				   .LUM1      SET	.LUM1 + .STEP1
     23  71d8				   .LUM2      SET	.LUM2 + .STEP2
     24  71d8				   .LUM3      SET	.LUM3 + .STEP3
     25  71d8					      REPEND
    335  71d8							;colr_ntsc   LUMTABLE $70,$40,$a0,$A,$2,$E,$8,$E,$8
    336  71d8
    337  71d8							;    ECHO "PAL LUMS"
    338  71d8							;    OPTIONAL_PAGEBREAK "colr_pal", 72*3
      0  71d8				   colr_pal   LUMTABLE	$60, $80, $10, $6,$4,$8,$6,$4,$8
      1  71d8
      2  71d8
      3  71d8
      4  71d8
      5  71d8				   .LUM1      SET	$6*256
      6  71d8				   .LUM2      SET	$4*256
      7  71d8				   .LUM3      SET	$8*256
      8  71d8
      9  71d8		       00 00	   .STEP1     =	(256*($6-$6))/72
     10  71d8		       00 00	   .STEP2     =	(256*($4-$4))/72
     11  71d8		       00 00	   .STEP3     =	(256*($8-$8))/72
     12  71d8
     13  71d8					      REPEAT	72
     14  71d8		       66		      .byte.b	$60+(.LUM1/256)
     15  71d9		       84		      .byte.b	$80+(.LUM2/256)
     16  71da		       18		      .byte.b	$10+(.LUM3/256)
     17  71db
     18  71db
     19  71db
     20  71db
     21  71db
     22  71db				   .LUM1      SET	.LUM1 + .STEP1
     23  71db				   .LUM2      SET	.LUM2 + .STEP2
     24  71db				   .LUM3      SET	.LUM3 + .STEP3
     13  71db					      REPEND
     14  71db		       66		      .byte.b	$60+(.LUM1/256)
     15  71dc		       84		      .byte.b	$80+(.LUM2/256)
     16  71dd		       18		      .byte.b	$10+(.LUM3/256)
     17  71de
     18  71de
     19  71de
     20  71de
     21  71de
     22  71de				   .LUM1      SET	.LUM1 + .STEP1
     23  71de				   .LUM2      SET	.LUM2 + .STEP2
     24  71de				   .LUM3      SET	.LUM3 + .STEP3
     13  71de					      REPEND
     14  71de		       66		      .byte.b	$60+(.LUM1/256)
     15  71df		       84		      .byte.b	$80+(.LUM2/256)
     16  71e0		       18		      .byte.b	$10+(.LUM3/256)
     17  71e1
     18  71e1
     19  71e1
     20  71e1
     21  71e1
     22  71e1				   .LUM1      SET	.LUM1 + .STEP1
     23  71e1				   .LUM2      SET	.LUM2 + .STEP2
     24  71e1				   .LUM3      SET	.LUM3 + .STEP3
     13  71e1					      REPEND
     14  71e1		       66		      .byte.b	$60+(.LUM1/256)
     15  71e2		       84		      .byte.b	$80+(.LUM2/256)
     16  71e3		       18		      .byte.b	$10+(.LUM3/256)
     17  71e4
     18  71e4
     19  71e4
     20  71e4
     21  71e4
     22  71e4				   .LUM1      SET	.LUM1 + .STEP1
     23  71e4				   .LUM2      SET	.LUM2 + .STEP2
     24  71e4				   .LUM3      SET	.LUM3 + .STEP3
     13  71e4					      REPEND
     14  71e4		       66		      .byte.b	$60+(.LUM1/256)
     15  71e5		       84		      .byte.b	$80+(.LUM2/256)
     16  71e6		       18		      .byte.b	$10+(.LUM3/256)
     17  71e7
     18  71e7
     19  71e7
     20  71e7
     21  71e7
     22  71e7				   .LUM1      SET	.LUM1 + .STEP1
     23  71e7				   .LUM2      SET	.LUM2 + .STEP2
     24  71e7				   .LUM3      SET	.LUM3 + .STEP3
     13  71e7					      REPEND
     14  71e7		       66		      .byte.b	$60+(.LUM1/256)
     15  71e8		       84		      .byte.b	$80+(.LUM2/256)
     16  71e9		       18		      .byte.b	$10+(.LUM3/256)
     17  71ea
     18  71ea
     19  71ea
     20  71ea
     21  71ea
     22  71ea				   .LUM1      SET	.LUM1 + .STEP1
     23  71ea				   .LUM2      SET	.LUM2 + .STEP2
     24  71ea				   .LUM3      SET	.LUM3 + .STEP3
     13  71ea					      REPEND
     14  71ea		       66		      .byte.b	$60+(.LUM1/256)
     15  71eb		       84		      .byte.b	$80+(.LUM2/256)
     16  71ec		       18		      .byte.b	$10+(.LUM3/256)
     17  71ed
     18  71ed
     19  71ed
     20  71ed
     21  71ed
     22  71ed				   .LUM1      SET	.LUM1 + .STEP1
     23  71ed				   .LUM2      SET	.LUM2 + .STEP2
     24  71ed				   .LUM3      SET	.LUM3 + .STEP3
     13  71ed					      REPEND
     14  71ed		       66		      .byte.b	$60+(.LUM1/256)
     15  71ee		       84		      .byte.b	$80+(.LUM2/256)
     16  71ef		       18		      .byte.b	$10+(.LUM3/256)
     17  71f0
     18  71f0
     19  71f0
     20  71f0
     21  71f0
     22  71f0				   .LUM1      SET	.LUM1 + .STEP1
     23  71f0				   .LUM2      SET	.LUM2 + .STEP2
     24  71f0				   .LUM3      SET	.LUM3 + .STEP3
     13  71f0					      REPEND
     14  71f0		       66		      .byte.b	$60+(.LUM1/256)
     15  71f1		       84		      .byte.b	$80+(.LUM2/256)
     16  71f2		       18		      .byte.b	$10+(.LUM3/256)
     17  71f3
     18  71f3
     19  71f3
     20  71f3
     21  71f3
     22  71f3				   .LUM1      SET	.LUM1 + .STEP1
     23  71f3				   .LUM2      SET	.LUM2 + .STEP2
     24  71f3				   .LUM3      SET	.LUM3 + .STEP3
     13  71f3					      REPEND
     14  71f3		       66		      .byte.b	$60+(.LUM1/256)
     15  71f4		       84		      .byte.b	$80+(.LUM2/256)
     16  71f5		       18		      .byte.b	$10+(.LUM3/256)
     17  71f6
     18  71f6
     19  71f6
     20  71f6
     21  71f6
     22  71f6				   .LUM1      SET	.LUM1 + .STEP1
     23  71f6				   .LUM2      SET	.LUM2 + .STEP2
     24  71f6				   .LUM3      SET	.LUM3 + .STEP3
     13  71f6					      REPEND
     14  71f6		       66		      .byte.b	$60+(.LUM1/256)
     15  71f7		       84		      .byte.b	$80+(.LUM2/256)
     16  71f8		       18		      .byte.b	$10+(.LUM3/256)
     17  71f9
     18  71f9
     19  71f9
     20  71f9
     21  71f9
     22  71f9				   .LUM1      SET	.LUM1 + .STEP1
     23  71f9				   .LUM2      SET	.LUM2 + .STEP2
     24  71f9				   .LUM3      SET	.LUM3 + .STEP3
     13  71f9					      REPEND
     14  71f9		       66		      .byte.b	$60+(.LUM1/256)
     15  71fa		       84		      .byte.b	$80+(.LUM2/256)
     16  71fb		       18		      .byte.b	$10+(.LUM3/256)
     17  71fc
     18  71fc
     19  71fc
     20  71fc
     21  71fc
     22  71fc				   .LUM1      SET	.LUM1 + .STEP1
     23  71fc				   .LUM2      SET	.LUM2 + .STEP2
     24  71fc				   .LUM3      SET	.LUM3 + .STEP3
     13  71fc					      REPEND
     14  71fc		       66		      .byte.b	$60+(.LUM1/256)
     15  71fd		       84		      .byte.b	$80+(.LUM2/256)
     16  71fe		       18		      .byte.b	$10+(.LUM3/256)
     17  71ff
     18  71ff
     19  71ff
     20  71ff
     21  71ff
     22  71ff				   .LUM1      SET	.LUM1 + .STEP1
     23  71ff				   .LUM2      SET	.LUM2 + .STEP2
     24  71ff				   .LUM3      SET	.LUM3 + .STEP3
     13  71ff					      REPEND
     14  71ff		       66		      .byte.b	$60+(.LUM1/256)
     15  7200		       84		      .byte.b	$80+(.LUM2/256)
     16  7201		       18		      .byte.b	$10+(.LUM3/256)
     17  7202
     18  7202
     19  7202
     20  7202
     21  7202
     22  7202				   .LUM1      SET	.LUM1 + .STEP1
     23  7202				   .LUM2      SET	.LUM2 + .STEP2
     24  7202				   .LUM3      SET	.LUM3 + .STEP3
     13  7202					      REPEND
     14  7202		       66		      .byte.b	$60+(.LUM1/256)
     15  7203		       84		      .byte.b	$80+(.LUM2/256)
     16  7204		       18		      .byte.b	$10+(.LUM3/256)
     17  7205
     18  7205
     19  7205
     20  7205
     21  7205
     22  7205				   .LUM1      SET	.LUM1 + .STEP1
     23  7205				   .LUM2      SET	.LUM2 + .STEP2
     24  7205				   .LUM3      SET	.LUM3 + .STEP3
     13  7205					      REPEND
     14  7205		       66		      .byte.b	$60+(.LUM1/256)
     15  7206		       84		      .byte.b	$80+(.LUM2/256)
     16  7207		       18		      .byte.b	$10+(.LUM3/256)
     17  7208
     18  7208
     19  7208
     20  7208
     21  7208
     22  7208				   .LUM1      SET	.LUM1 + .STEP1
     23  7208				   .LUM2      SET	.LUM2 + .STEP2
     24  7208				   .LUM3      SET	.LUM3 + .STEP3
     13  7208					      REPEND
     14  7208		       66		      .byte.b	$60+(.LUM1/256)
     15  7209		       84		      .byte.b	$80+(.LUM2/256)
     16  720a		       18		      .byte.b	$10+(.LUM3/256)
     17  720b
     18  720b
     19  720b
     20  720b
     21  720b
     22  720b				   .LUM1      SET	.LUM1 + .STEP1
     23  720b				   .LUM2      SET	.LUM2 + .STEP2
     24  720b				   .LUM3      SET	.LUM3 + .STEP3
     13  720b					      REPEND
     14  720b		       66		      .byte.b	$60+(.LUM1/256)
     15  720c		       84		      .byte.b	$80+(.LUM2/256)
     16  720d		       18		      .byte.b	$10+(.LUM3/256)
     17  720e
     18  720e
     19  720e
     20  720e
     21  720e
     22  720e				   .LUM1      SET	.LUM1 + .STEP1
     23  720e				   .LUM2      SET	.LUM2 + .STEP2
     24  720e				   .LUM3      SET	.LUM3 + .STEP3
     13  720e					      REPEND
     14  720e		       66		      .byte.b	$60+(.LUM1/256)
     15  720f		       84		      .byte.b	$80+(.LUM2/256)
     16  7210		       18		      .byte.b	$10+(.LUM3/256)
     17  7211
     18  7211
     19  7211
     20  7211
     21  7211
     22  7211				   .LUM1      SET	.LUM1 + .STEP1
     23  7211				   .LUM2      SET	.LUM2 + .STEP2
     24  7211				   .LUM3      SET	.LUM3 + .STEP3
     13  7211					      REPEND
     14  7211		       66		      .byte.b	$60+(.LUM1/256)
     15  7212		       84		      .byte.b	$80+(.LUM2/256)
     16  7213		       18		      .byte.b	$10+(.LUM3/256)
     17  7214
     18  7214
     19  7214
     20  7214
     21  7214
     22  7214				   .LUM1      SET	.LUM1 + .STEP1
     23  7214				   .LUM2      SET	.LUM2 + .STEP2
     24  7214				   .LUM3      SET	.LUM3 + .STEP3
     13  7214					      REPEND
     14  7214		       66		      .byte.b	$60+(.LUM1/256)
     15  7215		       84		      .byte.b	$80+(.LUM2/256)
     16  7216		       18		      .byte.b	$10+(.LUM3/256)
     17  7217
     18  7217
     19  7217
     20  7217
     21  7217
     22  7217				   .LUM1      SET	.LUM1 + .STEP1
     23  7217				   .LUM2      SET	.LUM2 + .STEP2
     24  7217				   .LUM3      SET	.LUM3 + .STEP3
     13  7217					      REPEND
     14  7217		       66		      .byte.b	$60+(.LUM1/256)
     15  7218		       84		      .byte.b	$80+(.LUM2/256)
     16  7219		       18		      .byte.b	$10+(.LUM3/256)
     17  721a
     18  721a
     19  721a
     20  721a
     21  721a
     22  721a				   .LUM1      SET	.LUM1 + .STEP1
     23  721a				   .LUM2      SET	.LUM2 + .STEP2
     24  721a				   .LUM3      SET	.LUM3 + .STEP3
     13  721a					      REPEND
     14  721a		       66		      .byte.b	$60+(.LUM1/256)
     15  721b		       84		      .byte.b	$80+(.LUM2/256)
     16  721c		       18		      .byte.b	$10+(.LUM3/256)
     17  721d
     18  721d
     19  721d
     20  721d
     21  721d
     22  721d				   .LUM1      SET	.LUM1 + .STEP1
     23  721d				   .LUM2      SET	.LUM2 + .STEP2
     24  721d				   .LUM3      SET	.LUM3 + .STEP3
     13  721d					      REPEND
     14  721d		       66		      .byte.b	$60+(.LUM1/256)
     15  721e		       84		      .byte.b	$80+(.LUM2/256)
     16  721f		       18		      .byte.b	$10+(.LUM3/256)
     17  7220
     18  7220
     19  7220
     20  7220
     21  7220
     22  7220				   .LUM1      SET	.LUM1 + .STEP1
     23  7220				   .LUM2      SET	.LUM2 + .STEP2
     24  7220				   .LUM3      SET	.LUM3 + .STEP3
     13  7220					      REPEND
     14  7220		       66		      .byte.b	$60+(.LUM1/256)
     15  7221		       84		      .byte.b	$80+(.LUM2/256)
     16  7222		       18		      .byte.b	$10+(.LUM3/256)
     17  7223
     18  7223
     19  7223
     20  7223
     21  7223
     22  7223				   .LUM1      SET	.LUM1 + .STEP1
     23  7223				   .LUM2      SET	.LUM2 + .STEP2
     24  7223				   .LUM3      SET	.LUM3 + .STEP3
     13  7223					      REPEND
     14  7223		       66		      .byte.b	$60+(.LUM1/256)
     15  7224		       84		      .byte.b	$80+(.LUM2/256)
     16  7225		       18		      .byte.b	$10+(.LUM3/256)
     17  7226
     18  7226
     19  7226
     20  7226
     21  7226
     22  7226				   .LUM1      SET	.LUM1 + .STEP1
     23  7226				   .LUM2      SET	.LUM2 + .STEP2
     24  7226				   .LUM3      SET	.LUM3 + .STEP3
     13  7226					      REPEND
     14  7226		       66		      .byte.b	$60+(.LUM1/256)
     15  7227		       84		      .byte.b	$80+(.LUM2/256)
     16  7228		       18		      .byte.b	$10+(.LUM3/256)
     17  7229
     18  7229
     19  7229
     20  7229
     21  7229
     22  7229				   .LUM1      SET	.LUM1 + .STEP1
     23  7229				   .LUM2      SET	.LUM2 + .STEP2
     24  7229				   .LUM3      SET	.LUM3 + .STEP3
     13  7229					      REPEND
     14  7229		       66		      .byte.b	$60+(.LUM1/256)
     15  722a		       84		      .byte.b	$80+(.LUM2/256)
     16  722b		       18		      .byte.b	$10+(.LUM3/256)
     17  722c
     18  722c
     19  722c
     20  722c
     21  722c
     22  722c				   .LUM1      SET	.LUM1 + .STEP1
     23  722c				   .LUM2      SET	.LUM2 + .STEP2
     24  722c				   .LUM3      SET	.LUM3 + .STEP3
     13  722c					      REPEND
     14  722c		       66		      .byte.b	$60+(.LUM1/256)
     15  722d		       84		      .byte.b	$80+(.LUM2/256)
     16  722e		       18		      .byte.b	$10+(.LUM3/256)
     17  722f
     18  722f
     19  722f
     20  722f
     21  722f
     22  722f				   .LUM1      SET	.LUM1 + .STEP1
     23  722f				   .LUM2      SET	.LUM2 + .STEP2
     24  722f				   .LUM3      SET	.LUM3 + .STEP3
     13  722f					      REPEND
     14  722f		       66		      .byte.b	$60+(.LUM1/256)
     15  7230		       84		      .byte.b	$80+(.LUM2/256)
     16  7231		       18		      .byte.b	$10+(.LUM3/256)
     17  7232
     18  7232
     19  7232
     20  7232
     21  7232
     22  7232				   .LUM1      SET	.LUM1 + .STEP1
     23  7232				   .LUM2      SET	.LUM2 + .STEP2
     24  7232				   .LUM3      SET	.LUM3 + .STEP3
     13  7232					      REPEND
     14  7232		       66		      .byte.b	$60+(.LUM1/256)
     15  7233		       84		      .byte.b	$80+(.LUM2/256)
     16  7234		       18		      .byte.b	$10+(.LUM3/256)
     17  7235
     18  7235
     19  7235
     20  7235
     21  7235
     22  7235				   .LUM1      SET	.LUM1 + .STEP1
     23  7235				   .LUM2      SET	.LUM2 + .STEP2
     24  7235				   .LUM3      SET	.LUM3 + .STEP3
     13  7235					      REPEND
     14  7235		       66		      .byte.b	$60+(.LUM1/256)
     15  7236		       84		      .byte.b	$80+(.LUM2/256)
     16  7237		       18		      .byte.b	$10+(.LUM3/256)
     17  7238
     18  7238
     19  7238
     20  7238
     21  7238
     22  7238				   .LUM1      SET	.LUM1 + .STEP1
     23  7238				   .LUM2      SET	.LUM2 + .STEP2
     24  7238				   .LUM3      SET	.LUM3 + .STEP3
     13  7238					      REPEND
     14  7238		       66		      .byte.b	$60+(.LUM1/256)
     15  7239		       84		      .byte.b	$80+(.LUM2/256)
     16  723a		       18		      .byte.b	$10+(.LUM3/256)
     17  723b
     18  723b
     19  723b
     20  723b
     21  723b
     22  723b				   .LUM1      SET	.LUM1 + .STEP1
     23  723b				   .LUM2      SET	.LUM2 + .STEP2
     24  723b				   .LUM3      SET	.LUM3 + .STEP3
     13  723b					      REPEND
     14  723b		       66		      .byte.b	$60+(.LUM1/256)
     15  723c		       84		      .byte.b	$80+(.LUM2/256)
     16  723d		       18		      .byte.b	$10+(.LUM3/256)
     17  723e
     18  723e
     19  723e
     20  723e
     21  723e
     22  723e				   .LUM1      SET	.LUM1 + .STEP1
     23  723e				   .LUM2      SET	.LUM2 + .STEP2
     24  723e				   .LUM3      SET	.LUM3 + .STEP3
     13  723e					      REPEND
     14  723e		       66		      .byte.b	$60+(.LUM1/256)
     15  723f		       84		      .byte.b	$80+(.LUM2/256)
     16  7240		       18		      .byte.b	$10+(.LUM3/256)
     17  7241
     18  7241
     19  7241
     20  7241
     21  7241
     22  7241				   .LUM1      SET	.LUM1 + .STEP1
     23  7241				   .LUM2      SET	.LUM2 + .STEP2
     24  7241				   .LUM3      SET	.LUM3 + .STEP3
     13  7241					      REPEND
     14  7241		       66		      .byte.b	$60+(.LUM1/256)
     15  7242		       84		      .byte.b	$80+(.LUM2/256)
     16  7243		       18		      .byte.b	$10+(.LUM3/256)
     17  7244
     18  7244
     19  7244
     20  7244
     21  7244
     22  7244				   .LUM1      SET	.LUM1 + .STEP1
     23  7244				   .LUM2      SET	.LUM2 + .STEP2
     24  7244				   .LUM3      SET	.LUM3 + .STEP3
     13  7244					      REPEND
     14  7244		       66		      .byte.b	$60+(.LUM1/256)
     15  7245		       84		      .byte.b	$80+(.LUM2/256)
     16  7246		       18		      .byte.b	$10+(.LUM3/256)
     17  7247
     18  7247
     19  7247
     20  7247
     21  7247
     22  7247				   .LUM1      SET	.LUM1 + .STEP1
     23  7247				   .LUM2      SET	.LUM2 + .STEP2
     24  7247				   .LUM3      SET	.LUM3 + .STEP3
     13  7247					      REPEND
     14  7247		       66		      .byte.b	$60+(.LUM1/256)
     15  7248		       84		      .byte.b	$80+(.LUM2/256)
     16  7249		       18		      .byte.b	$10+(.LUM3/256)
     17  724a
     18  724a
     19  724a
     20  724a
     21  724a
     22  724a				   .LUM1      SET	.LUM1 + .STEP1
     23  724a				   .LUM2      SET	.LUM2 + .STEP2
     24  724a				   .LUM3      SET	.LUM3 + .STEP3
     13  724a					      REPEND
     14  724a		       66		      .byte.b	$60+(.LUM1/256)
     15  724b		       84		      .byte.b	$80+(.LUM2/256)
     16  724c		       18		      .byte.b	$10+(.LUM3/256)
     17  724d
     18  724d
     19  724d
     20  724d
     21  724d
     22  724d				   .LUM1      SET	.LUM1 + .STEP1
     23  724d				   .LUM2      SET	.LUM2 + .STEP2
     24  724d				   .LUM3      SET	.LUM3 + .STEP3
     13  724d					      REPEND
     14  724d		       66		      .byte.b	$60+(.LUM1/256)
     15  724e		       84		      .byte.b	$80+(.LUM2/256)
     16  724f		       18		      .byte.b	$10+(.LUM3/256)
     17  7250
     18  7250
     19  7250
     20  7250
     21  7250
     22  7250				   .LUM1      SET	.LUM1 + .STEP1
     23  7250				   .LUM2      SET	.LUM2 + .STEP2
     24  7250				   .LUM3      SET	.LUM3 + .STEP3
     13  7250					      REPEND
     14  7250		       66		      .byte.b	$60+(.LUM1/256)
     15  7251		       84		      .byte.b	$80+(.LUM2/256)
     16  7252		       18		      .byte.b	$10+(.LUM3/256)
     17  7253
     18  7253
     19  7253
     20  7253
     21  7253
     22  7253				   .LUM1      SET	.LUM1 + .STEP1
     23  7253				   .LUM2      SET	.LUM2 + .STEP2
     24  7253				   .LUM3      SET	.LUM3 + .STEP3
     13  7253					      REPEND
     14  7253		       66		      .byte.b	$60+(.LUM1/256)
     15  7254		       84		      .byte.b	$80+(.LUM2/256)
     16  7255		       18		      .byte.b	$10+(.LUM3/256)
     17  7256
     18  7256
     19  7256
     20  7256
     21  7256
     22  7256				   .LUM1      SET	.LUM1 + .STEP1
     23  7256				   .LUM2      SET	.LUM2 + .STEP2
     24  7256				   .LUM3      SET	.LUM3 + .STEP3
     13  7256					      REPEND
     14  7256		       66		      .byte.b	$60+(.LUM1/256)
     15  7257		       84		      .byte.b	$80+(.LUM2/256)
     16  7258		       18		      .byte.b	$10+(.LUM3/256)
     17  7259
     18  7259
     19  7259
     20  7259
     21  7259
     22  7259				   .LUM1      SET	.LUM1 + .STEP1
     23  7259				   .LUM2      SET	.LUM2 + .STEP2
     24  7259				   .LUM3      SET	.LUM3 + .STEP3
     13  7259					      REPEND
     14  7259		       66		      .byte.b	$60+(.LUM1/256)
     15  725a		       84		      .byte.b	$80+(.LUM2/256)
     16  725b		       18		      .byte.b	$10+(.LUM3/256)
     17  725c
     18  725c
     19  725c
     20  725c
     21  725c
     22  725c				   .LUM1      SET	.LUM1 + .STEP1
     23  725c				   .LUM2      SET	.LUM2 + .STEP2
     24  725c				   .LUM3      SET	.LUM3 + .STEP3
     13  725c					      REPEND
     14  725c		       66		      .byte.b	$60+(.LUM1/256)
     15  725d		       84		      .byte.b	$80+(.LUM2/256)
     16  725e		       18		      .byte.b	$10+(.LUM3/256)
     17  725f
     18  725f
     19  725f
     20  725f
     21  725f
     22  725f				   .LUM1      SET	.LUM1 + .STEP1
     23  725f				   .LUM2      SET	.LUM2 + .STEP2
     24  725f				   .LUM3      SET	.LUM3 + .STEP3
     13  725f					      REPEND
     14  725f		       66		      .byte.b	$60+(.LUM1/256)
     15  7260		       84		      .byte.b	$80+(.LUM2/256)
     16  7261		       18		      .byte.b	$10+(.LUM3/256)
     17  7262
     18  7262
     19  7262
     20  7262
     21  7262
     22  7262				   .LUM1      SET	.LUM1 + .STEP1
     23  7262				   .LUM2      SET	.LUM2 + .STEP2
     24  7262				   .LUM3      SET	.LUM3 + .STEP3
     13  7262					      REPEND
     14  7262		       66		      .byte.b	$60+(.LUM1/256)
     15  7263		       84		      .byte.b	$80+(.LUM2/256)
     16  7264		       18		      .byte.b	$10+(.LUM3/256)
     17  7265
     18  7265
     19  7265
     20  7265
     21  7265
     22  7265				   .LUM1      SET	.LUM1 + .STEP1
     23  7265				   .LUM2      SET	.LUM2 + .STEP2
     24  7265				   .LUM3      SET	.LUM3 + .STEP3
     13  7265					      REPEND
     14  7265		       66		      .byte.b	$60+(.LUM1/256)
     15  7266		       84		      .byte.b	$80+(.LUM2/256)
     16  7267		       18		      .byte.b	$10+(.LUM3/256)
     17  7268
     18  7268
     19  7268
     20  7268
     21  7268
     22  7268				   .LUM1      SET	.LUM1 + .STEP1
     23  7268				   .LUM2      SET	.LUM2 + .STEP2
     24  7268				   .LUM3      SET	.LUM3 + .STEP3
     13  7268					      REPEND
     14  7268		       66		      .byte.b	$60+(.LUM1/256)
     15  7269		       84		      .byte.b	$80+(.LUM2/256)
     16  726a		       18		      .byte.b	$10+(.LUM3/256)
     17  726b
     18  726b
     19  726b
     20  726b
     21  726b
     22  726b				   .LUM1      SET	.LUM1 + .STEP1
     23  726b				   .LUM2      SET	.LUM2 + .STEP2
     24  726b				   .LUM3      SET	.LUM3 + .STEP3
     13  726b					      REPEND
     14  726b		       66		      .byte.b	$60+(.LUM1/256)
     15  726c		       84		      .byte.b	$80+(.LUM2/256)
     16  726d		       18		      .byte.b	$10+(.LUM3/256)
     17  726e
     18  726e
     19  726e
     20  726e
     21  726e
     22  726e				   .LUM1      SET	.LUM1 + .STEP1
     23  726e				   .LUM2      SET	.LUM2 + .STEP2
     24  726e				   .LUM3      SET	.LUM3 + .STEP3
     13  726e					      REPEND
     14  726e		       66		      .byte.b	$60+(.LUM1/256)
     15  726f		       84		      .byte.b	$80+(.LUM2/256)
     16  7270		       18		      .byte.b	$10+(.LUM3/256)
     17  7271
     18  7271
     19  7271
     20  7271
     21  7271
     22  7271				   .LUM1      SET	.LUM1 + .STEP1
     23  7271				   .LUM2      SET	.LUM2 + .STEP2
     24  7271				   .LUM3      SET	.LUM3 + .STEP3
     13  7271					      REPEND
     14  7271		       66		      .byte.b	$60+(.LUM1/256)
     15  7272		       84		      .byte.b	$80+(.LUM2/256)
     16  7273		       18		      .byte.b	$10+(.LUM3/256)
     17  7274
     18  7274
     19  7274
     20  7274
     21  7274
     22  7274				   .LUM1      SET	.LUM1 + .STEP1
     23  7274				   .LUM2      SET	.LUM2 + .STEP2
     24  7274				   .LUM3      SET	.LUM3 + .STEP3
     13  7274					      REPEND
     14  7274		       66		      .byte.b	$60+(.LUM1/256)
     15  7275		       84		      .byte.b	$80+(.LUM2/256)
     16  7276		       18		      .byte.b	$10+(.LUM3/256)
     17  7277
     18  7277
     19  7277
     20  7277
     21  7277
     22  7277				   .LUM1      SET	.LUM1 + .STEP1
     23  7277				   .LUM2      SET	.LUM2 + .STEP2
     24  7277				   .LUM3      SET	.LUM3 + .STEP3
     13  7277					      REPEND
     14  7277		       66		      .byte.b	$60+(.LUM1/256)
     15  7278		       84		      .byte.b	$80+(.LUM2/256)
     16  7279		       18		      .byte.b	$10+(.LUM3/256)
     17  727a
     18  727a
     19  727a
     20  727a
     21  727a
     22  727a				   .LUM1      SET	.LUM1 + .STEP1
     23  727a				   .LUM2      SET	.LUM2 + .STEP2
     24  727a				   .LUM3      SET	.LUM3 + .STEP3
     13  727a					      REPEND
     14  727a		       66		      .byte.b	$60+(.LUM1/256)
     15  727b		       84		      .byte.b	$80+(.LUM2/256)
     16  727c		       18		      .byte.b	$10+(.LUM3/256)
     17  727d
     18  727d
     19  727d
     20  727d
     21  727d
     22  727d				   .LUM1      SET	.LUM1 + .STEP1
     23  727d				   .LUM2      SET	.LUM2 + .STEP2
     24  727d				   .LUM3      SET	.LUM3 + .STEP3
     13  727d					      REPEND
     14  727d		       66		      .byte.b	$60+(.LUM1/256)
     15  727e		       84		      .byte.b	$80+(.LUM2/256)
     16  727f		       18		      .byte.b	$10+(.LUM3/256)
     17  7280
     18  7280
     19  7280
     20  7280
     21  7280
     22  7280				   .LUM1      SET	.LUM1 + .STEP1
     23  7280				   .LUM2      SET	.LUM2 + .STEP2
     24  7280				   .LUM3      SET	.LUM3 + .STEP3
     13  7280					      REPEND
     14  7280		       66		      .byte.b	$60+(.LUM1/256)
     15  7281		       84		      .byte.b	$80+(.LUM2/256)
     16  7282		       18		      .byte.b	$10+(.LUM3/256)
     17  7283
     18  7283
     19  7283
     20  7283
     21  7283
     22  7283				   .LUM1      SET	.LUM1 + .STEP1
     23  7283				   .LUM2      SET	.LUM2 + .STEP2
     24  7283				   .LUM3      SET	.LUM3 + .STEP3
     13  7283					      REPEND
     14  7283		       66		      .byte.b	$60+(.LUM1/256)
     15  7284		       84		      .byte.b	$80+(.LUM2/256)
     16  7285		       18		      .byte.b	$10+(.LUM3/256)
     17  7286
     18  7286
     19  7286
     20  7286
     21  7286
     22  7286				   .LUM1      SET	.LUM1 + .STEP1
     23  7286				   .LUM2      SET	.LUM2 + .STEP2
     24  7286				   .LUM3      SET	.LUM3 + .STEP3
     13  7286					      REPEND
     14  7286		       66		      .byte.b	$60+(.LUM1/256)
     15  7287		       84		      .byte.b	$80+(.LUM2/256)
     16  7288		       18		      .byte.b	$10+(.LUM3/256)
     17  7289
     18  7289
     19  7289
     20  7289
     21  7289
     22  7289				   .LUM1      SET	.LUM1 + .STEP1
     23  7289				   .LUM2      SET	.LUM2 + .STEP2
     24  7289				   .LUM3      SET	.LUM3 + .STEP3
     13  7289					      REPEND
     14  7289		       66		      .byte.b	$60+(.LUM1/256)
     15  728a		       84		      .byte.b	$80+(.LUM2/256)
     16  728b		       18		      .byte.b	$10+(.LUM3/256)
     17  728c
     18  728c
     19  728c
     20  728c
     21  728c
     22  728c				   .LUM1      SET	.LUM1 + .STEP1
     23  728c				   .LUM2      SET	.LUM2 + .STEP2
     24  728c				   .LUM3      SET	.LUM3 + .STEP3
     13  728c					      REPEND
     14  728c		       66		      .byte.b	$60+(.LUM1/256)
     15  728d		       84		      .byte.b	$80+(.LUM2/256)
     16  728e		       18		      .byte.b	$10+(.LUM3/256)
     17  728f
     18  728f
     19  728f
     20  728f
     21  728f
     22  728f				   .LUM1      SET	.LUM1 + .STEP1
     23  728f				   .LUM2      SET	.LUM2 + .STEP2
     24  728f				   .LUM3      SET	.LUM3 + .STEP3
     13  728f					      REPEND
     14  728f		       66		      .byte.b	$60+(.LUM1/256)
     15  7290		       84		      .byte.b	$80+(.LUM2/256)
     16  7291		       18		      .byte.b	$10+(.LUM3/256)
     17  7292
     18  7292
     19  7292
     20  7292
     21  7292
     22  7292				   .LUM1      SET	.LUM1 + .STEP1
     23  7292				   .LUM2      SET	.LUM2 + .STEP2
     24  7292				   .LUM3      SET	.LUM3 + .STEP3
     13  7292					      REPEND
     14  7292		       66		      .byte.b	$60+(.LUM1/256)
     15  7293		       84		      .byte.b	$80+(.LUM2/256)
     16  7294		       18		      .byte.b	$10+(.LUM3/256)
     17  7295
     18  7295
     19  7295
     20  7295
     21  7295
     22  7295				   .LUM1      SET	.LUM1 + .STEP1
     23  7295				   .LUM2      SET	.LUM2 + .STEP2
     24  7295				   .LUM3      SET	.LUM3 + .STEP3
     13  7295					      REPEND
     14  7295		       66		      .byte.b	$60+(.LUM1/256)
     15  7296		       84		      .byte.b	$80+(.LUM2/256)
     16  7297		       18		      .byte.b	$10+(.LUM3/256)
     17  7298
     18  7298
     19  7298
     20  7298
     21  7298
     22  7298				   .LUM1      SET	.LUM1 + .STEP1
     23  7298				   .LUM2      SET	.LUM2 + .STEP2
     24  7298				   .LUM3      SET	.LUM3 + .STEP3
     13  7298					      REPEND
     14  7298		       66		      .byte.b	$60+(.LUM1/256)
     15  7299		       84		      .byte.b	$80+(.LUM2/256)
     16  729a		       18		      .byte.b	$10+(.LUM3/256)
     17  729b
     18  729b
     19  729b
     20  729b
     21  729b
     22  729b				   .LUM1      SET	.LUM1 + .STEP1
     23  729b				   .LUM2      SET	.LUM2 + .STEP2
     24  729b				   .LUM3      SET	.LUM3 + .STEP3
     13  729b					      REPEND
     14  729b		       66		      .byte.b	$60+(.LUM1/256)
     15  729c		       84		      .byte.b	$80+(.LUM2/256)
     16  729d		       18		      .byte.b	$10+(.LUM3/256)
     17  729e
     18  729e
     19  729e
     20  729e
     21  729e
     22  729e				   .LUM1      SET	.LUM1 + .STEP1
     23  729e				   .LUM2      SET	.LUM2 + .STEP2
     24  729e				   .LUM3      SET	.LUM3 + .STEP3
     13  729e					      REPEND
     14  729e		       66		      .byte.b	$60+(.LUM1/256)
     15  729f		       84		      .byte.b	$80+(.LUM2/256)
     16  72a0		       18		      .byte.b	$10+(.LUM3/256)
     17  72a1
     18  72a1
     19  72a1
     20  72a1
     21  72a1
     22  72a1				   .LUM1      SET	.LUM1 + .STEP1
     23  72a1				   .LUM2      SET	.LUM2 + .STEP2
     24  72a1				   .LUM3      SET	.LUM3 + .STEP3
     13  72a1					      REPEND
     14  72a1		       66		      .byte.b	$60+(.LUM1/256)
     15  72a2		       84		      .byte.b	$80+(.LUM2/256)
     16  72a3		       18		      .byte.b	$10+(.LUM3/256)
     17  72a4
     18  72a4
     19  72a4
     20  72a4
     21  72a4
     22  72a4				   .LUM1      SET	.LUM1 + .STEP1
     23  72a4				   .LUM2      SET	.LUM2 + .STEP2
     24  72a4				   .LUM3      SET	.LUM3 + .STEP3
     13  72a4					      REPEND
     14  72a4		       66		      .byte.b	$60+(.LUM1/256)
     15  72a5		       84		      .byte.b	$80+(.LUM2/256)
     16  72a6		       18		      .byte.b	$10+(.LUM3/256)
     17  72a7
     18  72a7
     19  72a7
     20  72a7
     21  72a7
     22  72a7				   .LUM1      SET	.LUM1 + .STEP1
     23  72a7				   .LUM2      SET	.LUM2 + .STEP2
     24  72a7				   .LUM3      SET	.LUM3 + .STEP3
     13  72a7					      REPEND
     14  72a7		       66		      .byte.b	$60+(.LUM1/256)
     15  72a8		       84		      .byte.b	$80+(.LUM2/256)
     16  72a9		       18		      .byte.b	$10+(.LUM3/256)
     17  72aa
     18  72aa
     19  72aa
     20  72aa
     21  72aa
     22  72aa				   .LUM1      SET	.LUM1 + .STEP1
     23  72aa				   .LUM2      SET	.LUM2 + .STEP2
     24  72aa				   .LUM3      SET	.LUM3 + .STEP3
     13  72aa					      REPEND
     14  72aa		       66		      .byte.b	$60+(.LUM1/256)
     15  72ab		       84		      .byte.b	$80+(.LUM2/256)
     16  72ac		       18		      .byte.b	$10+(.LUM3/256)
     17  72ad
     18  72ad
     19  72ad
     20  72ad
     21  72ad
     22  72ad				   .LUM1      SET	.LUM1 + .STEP1
     23  72ad				   .LUM2      SET	.LUM2 + .STEP2
     24  72ad				   .LUM3      SET	.LUM3 + .STEP3
     13  72ad					      REPEND
     14  72ad		       66		      .byte.b	$60+(.LUM1/256)
     15  72ae		       84		      .byte.b	$80+(.LUM2/256)
     16  72af		       18		      .byte.b	$10+(.LUM3/256)
     17  72b0
     18  72b0
     19  72b0
     20  72b0
     21  72b0
     22  72b0				   .LUM1      SET	.LUM1 + .STEP1
     23  72b0				   .LUM2      SET	.LUM2 + .STEP2
     24  72b0				   .LUM3      SET	.LUM3 + .STEP3
     25  72b0					      REPEND
    340  72b0							;colr_pal	  LUMTABLE $90, $20, $60, $6,$A,$a,$C,$6,$8
    341  72b0
    342  72b0							;    include "pizza.asm"
    343  72b0
      0  72b0					      CHECK_BANK_SIZE	"TITLESCREEN"
      1  72b0		       02 b0	   .TEMP      =	* - _BANK_START
 TITLESCREEN (1K) SIZE =  $2b0 , FREE= $150
      2  72b0					      ECHO	"TITLESCREEN", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  72b0				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  72b0				  -	      ECHO	"BANK OVERFLOW @ ", "TITLESCREEN", " size=", * - ORIGIN
      5  72b0				  -	      ERR
      6  72b0					      ENDIF
------- FILE ./chess.asm
------- FILE TitleScreen@2.asm LEVEL 2 PASS 4
      0  72b0					      include	"TitleScreen@2.asm"
      0  72b0					      SLOT	2
      1  72b0				  -	      IF	(2 < 0) || (2 > 3)
      2  72b0				  -	      ECHO	"Illegal bank address/segment location", 2
      3  72b0				  -	      ERR
      4  72b0					      ENDIF
      5  72b0				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  72b0				   _BANK_SLOT SET	2 * 64
      0  72b0					      ROMBANK	TITLEDATA2
      1  77fc ????				      SEG	TITLEDATA2
      2  7400					      ORG	_ORIGIN
      3  7400					      RORG	_BANK_ADDRESS_ORIGIN
      4  7400				   _BANK_START SET	*
      5  7400				   TITLEDATA2_START SET	*
      6  7400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7400				   TITLEDATA2 SET	_BANK_SLOT + _CURRENT_BANK
      8  7400				   _ORIGIN    SET	_ORIGIN + 1024
      3  7400
      0  7400					      DEF	TitleData
      1  7400				   SLOT_TitleData SET	_BANK_SLOT
      2  7400				   BANK_TitleData SET	SLOT_TitleData + _CURRENT_BANK
      3  7400				   TitleData
      4  7400				   TEMPORARY_VAR SET	Overlay
      5  7400				   TEMPORARY_OFFSET SET	0
      6  7400				   VAR_BOUNDARY_TitleData SET	TEMPORARY_OFFSET
      7  7400				   FUNCTION_NAME SET	TitleData
------- FILE titleData.asm LEVEL 3 PASS 4
      0  7400					      include	"titleData.asm"
      1  7400				   COL_0
      2  7400		       07		      .byte.b	7	;R (67)
      3  7401		       06		      .byte.b	6	;G
      4  7402		       00		      .byte.b	0	;B
      5  7403		       02		      .byte.b	2	;R (66)
      6  7404		       00		      .byte.b	0	;G
      7  7405		       00		      .byte.b	0	;B
      8  7406		       00		      .byte.b	0	;R (65)
      9  7407		       00		      .byte.b	0	;G
     10  7408		       0b		      .byte.b	11	;B
     11  7409		       00		      .byte.b	0	;R (64)
     12  740a		       00		      .byte.b	0	;G
     13  740b		       00		      .byte.b	0	;B
     14  740c		       00		      .byte.b	0	;R (63)
     15  740d		       00		      .byte.b	0	;G
     16  740e		       0b		      .byte.b	11	;B
     17  740f		       00		      .byte.b	0	;R (62)
     18  7410		       00		      .byte.b	0	;G
     19  7411		       08		      .byte.b	8	;B
     20  7412		       00		      .byte.b	0	;R (61)
     21  7413		       00		      .byte.b	0	;G
     22  7414		       0b		      .byte.b	11	;B
     23  7415		       00		      .byte.b	0	;R (60)
     24  7416		       00		      .byte.b	0	;G
     25  7417		       00		      .byte.b	0	;B
     26  7418		       00		      .byte.b	0	;R (59)
     27  7419		       00		      .byte.b	0	;G
     28  741a		       00		      .byte.b	0	;B
     29  741b		       04		      .byte.b	4	;R (58)
     30  741c		       04		      .byte.b	4	;G
     31  741d		       00		      .byte.b	0	;B
     32  741e		       0f		      .byte.b	15	;R (57)
     33  741f		       00		      .byte.b	0	;G
     34  7420		       00		      .byte.b	0	;B
     35  7421		       0f		      .byte.b	15	;R (56)
     36  7422		       00		      .byte.b	0	;G
     37  7423		       00		      .byte.b	0	;B
     38  7424		       8f		      .byte.b	143	;R (55)
     39  7425		       80		      .byte.b	128	;G
     40  7426		       00		      .byte.b	0	;B
     41  7427		       8f		      .byte.b	143	;R (54)
     42  7428		       00		      .byte.b	0	;G
     43  7429		       00		      .byte.b	0	;B
     44  742a		       cf		      .byte.b	207	;R (53)
     45  742b		       40		      .byte.b	64	;G
     46  742c		       00		      .byte.b	0	;B
     47  742d		       0f		      .byte.b	15	;R (52)
     48  742e		       00		      .byte.b	0	;G
     49  742f		       00		      .byte.b	0	;B
     50  7430		       0f		      .byte.b	15	;R (51)
     51  7431		       00		      .byte.b	0	;G
     52  7432		       00		      .byte.b	0	;B
     53  7433		       0f		      .byte.b	15	;R (50)
     54  7434		       00		      .byte.b	0	;G
     55  7435		       00		      .byte.b	0	;B
     56  7436		       0f		      .byte.b	15	;R (49)
     57  7437		       08		      .byte.b	8	;G
     58  7438		       00		      .byte.b	0	;B
     59  7439		       07		      .byte.b	7	;R (48)
     60  743a		       00		      .byte.b	0	;G
     61  743b		       00		      .byte.b	0	;B
     62  743c		       07		      .byte.b	7	;R (47)
     63  743d		       00		      .byte.b	0	;G
     64  743e		       00		      .byte.b	0	;B
     65  743f		       07		      .byte.b	7	;R (46)
     66  7440		       00		      .byte.b	0	;G
     67  7441		       00		      .byte.b	0	;B
     68  7442		       07		      .byte.b	7	;R (45)
     69  7443		       00		      .byte.b	0	;G
     70  7444		       00		      .byte.b	0	;B
     71  7445		       07		      .byte.b	7	;R (44)
     72  7446		       00		      .byte.b	0	;G
     73  7447		       00		      .byte.b	0	;B
     74  7448		       07		      .byte.b	7	;R (43)
     75  7449		       00		      .byte.b	0	;G
     76  744a		       00		      .byte.b	0	;B
     77  744b		       8f		      .byte.b	143	;R (42)
     78  744c		       88		      .byte.b	136	;G
     79  744d		       00		      .byte.b	0	;B
     80  744e		       cf		      .byte.b	207	;R (41)
     81  744f		       40		      .byte.b	64	;G
     82  7450		       00		      .byte.b	0	;B
     83  7451		       0f		      .byte.b	15	;R (40)
     84  7452		       00		      .byte.b	0	;G
     85  7453		       00		      .byte.b	0	;B
     86  7454		       0f		      .byte.b	15	;R (39)
     87  7455		       00		      .byte.b	0	;G
     88  7456		       00		      .byte.b	0	;B
     89  7457		       0f		      .byte.b	15	;R (38)
     90  7458		       02		      .byte.b	2	;G
     91  7459		       00		      .byte.b	0	;B
     92  745a		       cf		      .byte.b	207	;R (37)
     93  745b		       c0		      .byte.b	192	;G
     94  745c		       00		      .byte.b	0	;B
     95  745d		       ef		      .byte.b	239	;R (36)
     96  745e		       a0		      .byte.b	160	;G
     97  745f		       00		      .byte.b	0	;B
     98  7460		       ef		      .byte.b	239	;R (35)
     99  7461		       ea		      .byte.b	234	;G
    100  7462		       00		      .byte.b	0	;B
    101  7463		       6f		      .byte.b	111	;R (34)
    102  7464		       40		      .byte.b	64	;G
    103  7465		       00		      .byte.b	0	;B
    104  7466		       0f		      .byte.b	15	;R (33)
    105  7467		       0a		      .byte.b	10	;G
    106  7468		       00		      .byte.b	0	;B
    107  7469		       0f		      .byte.b	15	;R (32)
    108  746a		       00		      .byte.b	0	;G
    109  746b		       00		      .byte.b	0	;B
    110  746c		       4f		      .byte.b	79	;R (31)
    111  746d		       41		      .byte.b	65	;G
    112  746e		       00		      .byte.b	0	;B
    113  746f		       67		      .byte.b	103	;R (30)
    114  7470		       63		      .byte.b	99	;G
    115  7471		       08		      .byte.b	8	;B
    116  7472		       6f		      .byte.b	111	;R (29)
    117  7473		       41		      .byte.b	65	;G
    118  7474		       00		      .byte.b	0	;B
    119  7475		       af		      .byte.b	175	;R (28)
    120  7476		       89		      .byte.b	137	;G
    121  7477		       00		      .byte.b	0	;B
    122  7478		       3f		      .byte.b	63	;R (27)
    123  7479		       33		      .byte.b	51	;G
    124  747a		       00		      .byte.b	0	;B
    125  747b		       0f		      .byte.b	15	;R (26)
    126  747c		       01		      .byte.b	1	;G
    127  747d		       00		      .byte.b	0	;B
    128  747e		       cd		      .byte.b	205	;R (25)
    129  747f		       c9		      .byte.b	201	;G
    130  7480		       02		      .byte.b	2	;B
    131  7481		       cf		      .byte.b	207	;R (24)
    132  7482		       81		      .byte.b	129	;G
    133  7483		       00		      .byte.b	0	;B
    134  7484		       ef		      .byte.b	239	;R (23)
    135  7485		       e5		      .byte.b	229	;G
    136  7486		       00		      .byte.b	0	;B
    137  7487		       4f		      .byte.b	79	;R (22)
    138  7488		       01		      .byte.b	1	;G
    139  7489		       00		      .byte.b	0	;B
    140  748a		       4f		      .byte.b	79	;R (21)
    141  748b		       40		      .byte.b	64	;G
    142  748c		       00		      .byte.b	0	;B
    143  748d		       8f		      .byte.b	143	;R (20)
    144  748e		       8e		      .byte.b	142	;G
    145  748f		       00		      .byte.b	0	;B
    146  7490		       87		      .byte.b	135	;R (19)
    147  7491		       84		      .byte.b	132	;G
    148  7492		       00		      .byte.b	0	;B
    149  7493		       87		      .byte.b	135	;R (18)
    150  7494		       04		      .byte.b	4	;G
    151  7495		       00		      .byte.b	0	;B
    152  7496		       8f		      .byte.b	143	;R (17)
    153  7497		       0e		      .byte.b	14	;G
    154  7498		       00		      .byte.b	0	;B
    155  7499		       8a		      .byte.b	138	;R (16)
    156  749a		       8a		      .byte.b	138	;G
    157  749b		       00		      .byte.b	0	;B
    158  749c		       06		      .byte.b	6	;R (15)
    159  749d		       06		      .byte.b	6	;G
    160  749e		       00		      .byte.b	0	;B
    161  749f		       02		      .byte.b	2	;R (14)
    162  74a0		       02		      .byte.b	2	;G
    163  74a1		       00		      .byte.b	0	;B
    164  74a2		       00		      .byte.b	0	;R (13)
    165  74a3		       00		      .byte.b	0	;G
    166  74a4		       00		      .byte.b	0	;B
    167  74a5		       00		      .byte.b	0	;R (12)
    168  74a6		       00		      .byte.b	0	;G
    169  74a7		       00		      .byte.b	0	;B
    170  74a8		       00		      .byte.b	0	;R (11)
    171  74a9		       00		      .byte.b	0	;G
    172  74aa		       00		      .byte.b	0	;B
    173  74ab		       00		      .byte.b	0	;R (10)
    174  74ac		       00		      .byte.b	0	;G
    175  74ad		       00		      .byte.b	0	;B
    176  74ae		       00		      .byte.b	0	;R (9)
    177  74af		       00		      .byte.b	0	;G
    178  74b0		       00		      .byte.b	0	;B
    179  74b1		       00		      .byte.b	0	;R (8)
    180  74b2		       00		      .byte.b	0	;G
    181  74b3		       07		      .byte.b	7	;B
    182  74b4		       00		      .byte.b	0	;R (7)
    183  74b5		       00		      .byte.b	0	;G
    184  74b6		       05		      .byte.b	5	;B
    185  74b7		       00		      .byte.b	0	;R (6)
    186  74b8		       00		      .byte.b	0	;G
    187  74b9		       05		      .byte.b	5	;B
    188  74ba		       00		      .byte.b	0	;R (5)
    189  74bb		       00		      .byte.b	0	;G
    190  74bc		       05		      .byte.b	5	;B
    191  74bd		       00		      .byte.b	0	;R (4)
    192  74be		       00		      .byte.b	0	;G
    193  74bf		       05		      .byte.b	5	;B
    194  74c0		       00		      .byte.b	0	;R (3)
    195  74c1		       00		      .byte.b	0	;G
    196  74c2		       07		      .byte.b	7	;B
    197  74c3		       00		      .byte.b	0	;R (2)
    198  74c4		       00		      .byte.b	0	;G
    199  74c5		       00		      .byte.b	0	;B
    200  74c6		       00		      .byte.b	0	;R (1)
    201  74c7		       00		      .byte.b	0	;G
    202  74c8		       00		      .byte.b	0	;B
    203  74c9		       00		      .byte.b	0	;R (0)
    204  74ca		       00		      .byte.b	0	;G
    205  74cb		       00		      .byte.b	0	;B
    206  74cc				   COL_1
    207  74cc		       00		      .byte.b	0	;R (67)
    208  74cd		       00		      .byte.b	0	;G
    209  74ce		       00		      .byte.b	0	;B
    210  74cf		       00		      .byte.b	0	;R (66)
    211  74d0		       00		      .byte.b	0	;G
    212  74d1		       00		      .byte.b	0	;B
    213  74d2		       04		      .byte.b	4	;R (65)
    214  74d3		       00		      .byte.b	0	;G
    215  74d4		       00		      .byte.b	0	;B
    216  74d5		       1c		      .byte.b	28	;R (64)
    217  74d6		       18		      .byte.b	24	;G
    218  74d7		       01		      .byte.b	1	;B
    219  74d8		       3c		      .byte.b	60	;R (63)
    220  74d9		       30		      .byte.b	48	;G
    221  74da		       01		      .byte.b	1	;B
    222  74db		       1c		      .byte.b	28	;R (62)
    223  74dc		       00		      .byte.b	0	;G
    224  74dd		       01		      .byte.b	1	;B
    225  74de		       1c		      .byte.b	28	;R (61)
    226  74df		       04		      .byte.b	4	;G
    227  74e0		       21		      .byte.b	33	;B
    228  74e1		       1c		      .byte.b	28	;R (60)
    229  74e2		       08		      .byte.b	8	;G
    230  74e3		       01		      .byte.b	1	;B
    231  74e4		       1c		      .byte.b	28	;R (59)
    232  74e5		       00		      .byte.b	0	;G
    233  74e6		       00		      .byte.b	0	;B
    234  74e7		       1b		      .byte.b	27	;R (58)
    235  74e8		       0b		      .byte.b	11	;G
    236  74e9		       04		      .byte.b	4	;B
    237  74ea		       1f		      .byte.b	31	;R (57)
    238  74eb		       1d		      .byte.b	29	;G
    239  74ec		       00		      .byte.b	0	;B
    240  74ed		       df		      .byte.b	223	;R (56)
    241  74ee		       d2		      .byte.b	210	;G
    242  74ef		       20		      .byte.b	32	;B
    243  74f0		       ff		      .byte.b	255	;R (55)
    244  74f1		       3c		      .byte.b	60	;G
    245  74f2		       00		      .byte.b	0	;B
    246  74f3		       ff		      .byte.b	255	;R (54)
    247  74f4		       4f		      .byte.b	79	;G
    248  74f5		       00		      .byte.b	0	;B
    249  74f6		       ff		      .byte.b	255	;R (53)
    250  74f7		       93		      .byte.b	147	;G
    251  74f8		       00		      .byte.b	0	;B
    252  74f9		       1f		      .byte.b	31	;R (52)
    253  74fa		       1f		      .byte.b	31	;G
    254  74fb		       00		      .byte.b	0	;B
    255  74fc		       00		      .byte.b	0	;R (51)
    256  74fd		       00		      .byte.b	0	;G
    257  74fe		       00		      .byte.b	0	;B
    258  74ff		       00		      .byte.b	0	;R (50)
    259  7500		       00		      .byte.b	0	;G
    260  7501		       00		      .byte.b	0	;B
    261  7502		       1a		      .byte.b	26	;R (49)
    262  7503		       1a		      .byte.b	26	;G
    263  7504		       00		      .byte.b	0	;B
    264  7505		       38		      .byte.b	56	;R (48)
    265  7506		       28		      .byte.b	40	;G
    266  7507		       00		      .byte.b	0	;B
    267  7508		       71		      .byte.b	113	;R (47)
    268  7509		       51		      .byte.b	81	;G
    269  750a		       00		      .byte.b	0	;B
    270  750b		       0b		      .byte.b	11	;R (46)
    271  750c		       0b		      .byte.b	11	;G
    272  750d		       00		      .byte.b	0	;B
    273  750e		       03		      .byte.b	3	;R (45)
    274  750f		       03		      .byte.b	3	;G
    275  7510		       00		      .byte.b	0	;B
    276  7511		       ca		      .byte.b	202	;R (44)
    277  7512		       ca		      .byte.b	202	;G
    278  7513		       00		      .byte.b	0	;B
    279  7514		       c8		      .byte.b	200	;R (43)
    280  7515		       c8		      .byte.b	200	;G
    281  7516		       00		      .byte.b	0	;B
    282  7517		       c8		      .byte.b	200	;R (42)
    283  7518		       40		      .byte.b	64	;G
    284  7519		       00		      .byte.b	0	;B
    285  751a		       48		      .byte.b	72	;R (41)
    286  751b		       40		      .byte.b	64	;G
    287  751c		       00		      .byte.b	0	;B
    288  751d		       08		      .byte.b	8	;R (40)
    289  751e		       08		      .byte.b	8	;G
    290  751f		       00		      .byte.b	0	;B
    291  7520		       a0		      .byte.b	160	;R (39)
    292  7521		       a0		      .byte.b	160	;G
    293  7522		       00		      .byte.b	0	;B
    294  7523		       20		      .byte.b	32	;R (38)
    295  7524		       00		      .byte.b	0	;G
    296  7525		       00		      .byte.b	0	;B
    297  7526		       20		      .byte.b	32	;R (37)
    298  7527		       00		      .byte.b	0	;G
    299  7528		       00		      .byte.b	0	;B
    300  7529		       20		      .byte.b	32	;R (36)
    301  752a		       20		      .byte.b	32	;G
    302  752b		       00		      .byte.b	0	;B
    303  752c		       40		      .byte.b	64	;R (35)
    304  752d		       40		      .byte.b	64	;G
    305  752e		       00		      .byte.b	0	;B
    306  752f		       c0		      .byte.b	192	;R (34)
    307  7530		       c0		      .byte.b	192	;G
    308  7531		       00		      .byte.b	0	;B
    309  7532		       40		      .byte.b	64	;R (33)
    310  7533		       00		      .byte.b	0	;G
    311  7534		       00		      .byte.b	0	;B
    312  7535		       40		      .byte.b	64	;R (32)
    313  7536		       40		      .byte.b	64	;G
    314  7537		       00		      .byte.b	0	;B
    315  7538		       00		      .byte.b	0	;R (31)
    316  7539		       00		      .byte.b	0	;G
    317  753a		       00		      .byte.b	0	;B
    318  753b		       80		      .byte.b	128	;R (30)
    319  753c		       80		      .byte.b	128	;G
    320  753d		       00		      .byte.b	0	;B
    321  753e		       c0		      .byte.b	192	;R (29)
    322  753f		       40		      .byte.b	64	;G
    323  7540		       00		      .byte.b	0	;B
    324  7541		       c0		      .byte.b	192	;R (28)
    325  7542		       c0		      .byte.b	192	;G
    326  7543		       00		      .byte.b	0	;B
    327  7544		       40		      .byte.b	64	;R (27)
    328  7545		       40		      .byte.b	64	;G
    329  7546		       00		      .byte.b	0	;B
    330  7547		       00		      .byte.b	0	;R (26)
    331  7548		       00		      .byte.b	0	;G
    332  7549		       00		      .byte.b	0	;B
    333  754a		       00		      .byte.b	0	;R (25)
    334  754b		       00		      .byte.b	0	;G
    335  754c		       00		      .byte.b	0	;B
    336  754d		       60		      .byte.b	96	;R (24)
    337  754e		       20		      .byte.b	32	;G
    338  754f		       00		      .byte.b	0	;B
    339  7550		       60		      .byte.b	96	;R (23)
    340  7551		       60		      .byte.b	96	;G
    341  7552		       00		      .byte.b	0	;B
    342  7553		       00		      .byte.b	0	;R (22)
    343  7554		       00		      .byte.b	0	;G
    344  7555		       00		      .byte.b	0	;B
    345  7556		       a0		      .byte.b	160	;R (21)
    346  7557		       a0		      .byte.b	160	;G
    347  7558		       00		      .byte.b	0	;B
    348  7559		       70		      .byte.b	112	;R (20)
    349  755a		       50		      .byte.b	80	;G
    350  755b		       00		      .byte.b	0	;B
    351  755c		       c0		      .byte.b	192	;R (19)
    352  755d		       c0		      .byte.b	192	;G
    353  755e		       00		      .byte.b	0	;B
    354  755f		       80		      .byte.b	128	;R (18)
    355  7560		       80		      .byte.b	128	;G
    356  7561		       00		      .byte.b	0	;B
    357  7562		       4c		      .byte.b	76	;R (17)
    358  7563		       4c		      .byte.b	76	;G
    359  7564		       00		      .byte.b	0	;B
    360  7565		       5c		      .byte.b	92	;R (16)
    361  7566		       1c		      .byte.b	28	;G
    362  7567		       00		      .byte.b	0	;B
    363  7568		       60		      .byte.b	96	;R (15)
    364  7569		       60		      .byte.b	96	;G
    365  756a		       00		      .byte.b	0	;B
    366  756b		       60		      .byte.b	96	;R (14)
    367  756c		       20		      .byte.b	32	;G
    368  756d		       00		      .byte.b	0	;B
    369  756e		       50		      .byte.b	80	;R (13)
    370  756f		       50		      .byte.b	80	;G
    371  7570		       06		      .byte.b	6	;B
    372  7571		       40		      .byte.b	64	;R (12)
    373  7572		       40		      .byte.b	64	;G
    374  7573		       08		      .byte.b	8	;B
    375  7574		       00		      .byte.b	0	;R (11)
    376  7575		       00		      .byte.b	0	;G
    377  7576		       08		      .byte.b	8	;B
    378  7577		       00		      .byte.b	0	;R (10)
    379  7578		       00		      .byte.b	0	;G
    380  7579		       08		      .byte.b	8	;B
    381  757a		       00		      .byte.b	0	;R (9)
    382  757b		       00		      .byte.b	0	;G
    383  757c		       08		      .byte.b	8	;B
    384  757d		       00		      .byte.b	0	;R (8)
    385  757e		       00		      .byte.b	0	;G
    386  757f		       06		      .byte.b	6	;B
    387  7580		       00		      .byte.b	0	;R (7)
    388  7581		       00		      .byte.b	0	;G
    389  7582		       00		      .byte.b	0	;B
    390  7583		       00		      .byte.b	0	;R (6)
    391  7584		       00		      .byte.b	0	;G
    392  7585		       00		      .byte.b	0	;B
    393  7586		       00		      .byte.b	0	;R (5)
    394  7587		       00		      .byte.b	0	;G
    395  7588		       00		      .byte.b	0	;B
    396  7589		       00		      .byte.b	0	;R (4)
    397  758a		       00		      .byte.b	0	;G
    398  758b		       00		      .byte.b	0	;B
    399  758c		       00		      .byte.b	0	;R (3)
    400  758d		       00		      .byte.b	0	;G
    401  758e		       00		      .byte.b	0	;B
    402  758f		       00		      .byte.b	0	;R (2)
    403  7590		       00		      .byte.b	0	;G
    404  7591		       00		      .byte.b	0	;B
    405  7592		       00		      .byte.b	0	;R (1)
    406  7593		       00		      .byte.b	0	;G
    407  7594		       00		      .byte.b	0	;B
    408  7595		       00		      .byte.b	0	;R (0)
    409  7596		       00		      .byte.b	0	;G
    410  7597		       00		      .byte.b	0	;B
    411  7598				   COL_2
    412  7598		       f0		      .byte.b	240	;R (67)
    413  7599		       f0		      .byte.b	240	;G
    414  759a		       00		      .byte.b	0	;B
    415  759b		       7f		      .byte.b	127	;R (66)
    416  759c		       21		      .byte.b	33	;G
    417  759d		       00		      .byte.b	0	;B
    418  759e		       00		      .byte.b	0	;R (65)
    419  759f		       00		      .byte.b	0	;G
    420  75a0		       a8		      .byte.b	168	;B
    421  75a1		       00		      .byte.b	0	;R (64)
    422  75a2		       00		      .byte.b	0	;G
    423  75a3		       ab		      .byte.b	171	;B
    424  75a4		       00		      .byte.b	0	;R (63)
    425  75a5		       00		      .byte.b	0	;G
    426  75a6		       b8		      .byte.b	184	;B
    427  75a7		       00		      .byte.b	0	;R (62)
    428  75a8		       00		      .byte.b	0	;G
    429  75a9		       a8		      .byte.b	168	;B
    430  75aa		       00		      .byte.b	0	;R (61)
    431  75ab		       00		      .byte.b	0	;G
    432  75ac		       a8		      .byte.b	168	;B
    433  75ad		       00		      .byte.b	0	;R (60)
    434  75ae		       00		      .byte.b	0	;G
    435  75af		       03		      .byte.b	3	;B
    436  75b0		       01		      .byte.b	1	;R (59)
    437  75b1		       01		      .byte.b	1	;G
    438  75b2		       00		      .byte.b	0	;B
    439  75b3		       89		      .byte.b	137	;R (58)
    440  75b4		       89		      .byte.b	137	;G
    441  75b5		       00		      .byte.b	0	;B
    442  75b6		       fd		      .byte.b	253	;R (57)
    443  75b7		       00		      .byte.b	0	;G
    444  75b8		       00		      .byte.b	0	;B
    445  75b9		       fd		      .byte.b	253	;R (56)
    446  75ba		       00		      .byte.b	0	;G
    447  75bb		       00		      .byte.b	0	;B
    448  75bc		       fd		      .byte.b	253	;R (55)
    449  75bd		       00		      .byte.b	0	;G
    450  75be		       00		      .byte.b	0	;B
    451  75bf		       fd		      .byte.b	253	;R (54)
    452  75c0		       00		      .byte.b	0	;G
    453  75c1		       00		      .byte.b	0	;B
    454  75c2		       fd		      .byte.b	253	;R (53)
    455  75c3		       01		      .byte.b	1	;G
    456  75c4		       00		      .byte.b	0	;B
    457  75c5		       fe		      .byte.b	254	;R (52)
    458  75c6		       06		      .byte.b	6	;G
    459  75c7		       00		      .byte.b	0	;B
    460  75c8		       f9		      .byte.b	249	;R (51)
    461  75c9		       09		      .byte.b	9	;G
    462  75ca		       00		      .byte.b	0	;B
    463  75cb		       f8		      .byte.b	248	;R (50)
    464  75cc		       08		      .byte.b	8	;G
    465  75cd		       00		      .byte.b	0	;B
    466  75ce		       f8		      .byte.b	248	;R (49)
    467  75cf		       00		      .byte.b	0	;G
    468  75d0		       00		      .byte.b	0	;B
    469  75d1		       f8		      .byte.b	248	;R (48)
    470  75d2		       00		      .byte.b	0	;G
    471  75d3		       00		      .byte.b	0	;B
    472  75d4		       fc		      .byte.b	252	;R (47)
    473  75d5		       04		      .byte.b	4	;G
    474  75d6		       00		      .byte.b	0	;B
    475  75d7		       fc		      .byte.b	252	;R (46)
    476  75d8		       04		      .byte.b	4	;G
    477  75d9		       00		      .byte.b	0	;B
    478  75da		       fc		      .byte.b	252	;R (45)
    479  75db		       04		      .byte.b	4	;G
    480  75dc		       00		      .byte.b	0	;B
    481  75dd		       fc		      .byte.b	252	;R (44)
    482  75de		       84		      .byte.b	132	;G
    483  75df		       00		      .byte.b	0	;B
    484  75e0		       fc		      .byte.b	252	;R (43)
    485  75e1		       00		      .byte.b	0	;G
    486  75e2		       00		      .byte.b	0	;B
    487  75e3		       fc		      .byte.b	252	;R (42)
    488  75e4		       00		      .byte.b	0	;G
    489  75e5		       00		      .byte.b	0	;B
    490  75e6		       fc		      .byte.b	252	;R (41)
    491  75e7		       00		      .byte.b	0	;G
    492  75e8		       00		      .byte.b	0	;B
    493  75e9		       fc		      .byte.b	252	;R (40)
    494  75ea		       04		      .byte.b	4	;G
    495  75eb		       00		      .byte.b	0	;B
    496  75ec		       f8		      .byte.b	248	;R (39)
    497  75ed		       00		      .byte.b	0	;G
    498  75ee		       00		      .byte.b	0	;B
    499  75ef		       f8		      .byte.b	248	;R (38)
    500  75f0		       00		      .byte.b	0	;G
    501  75f1		       00		      .byte.b	0	;B
    502  75f2		       f8		      .byte.b	248	;R (37)
    503  75f3		       08		      .byte.b	8	;G
    504  75f4		       00		      .byte.b	0	;B
    505  75f5		       f0		      .byte.b	240	;R (36)
    506  75f6		       00		      .byte.b	0	;G
    507  75f7		       00		      .byte.b	0	;B
    508  75f8		       e0		      .byte.b	224	;R (35)
    509  75f9		       20		      .byte.b	32	;G
    510  75fa		       00		      .byte.b	0	;B
    511  75fb		       c0		      .byte.b	192	;R (34)
    512  75fc		       40		      .byte.b	64	;G
    513  75fd		       00		      .byte.b	0	;B
    514  75fe		       00		      .byte.b	0	;R (33)
    515  75ff		       00		      .byte.b	0	;G
    516  7600		       80		      .byte.b	128	;B
    517  7601		       02		      .byte.b	2	;R (32)
    518  7602		       02		      .byte.b	2	;G
    519  7603		       00		      .byte.b	0	;B
    520  7604		       67		      .byte.b	103	;R (31)
    521  7605		       07		      .byte.b	7	;G
    522  7606		       10		      .byte.b	16	;B
    523  7607		       7f		      .byte.b	127	;R (30)
    524  7608		       0a		      .byte.b	10	;G
    525  7609		       80		      .byte.b	128	;B
    526  760a		       ff		      .byte.b	255	;R (29)
    527  760b		       20		      .byte.b	32	;G
    528  760c		       00		      .byte.b	0	;B
    529  760d		       ff		      .byte.b	255	;R (28)
    530  760e		       12		      .byte.b	18	;G
    531  760f		       00		      .byte.b	0	;B
    532  7610		       ff		      .byte.b	255	;R (27)
    533  7611		       44		      .byte.b	68	;G
    534  7612		       00		      .byte.b	0	;B
    535  7613		       fc		      .byte.b	252	;R (26)
    536  7614		       20		      .byte.b	32	;G
    537  7615		       00		      .byte.b	0	;B
    538  7616		       f8		      .byte.b	248	;R (25)
    539  7617		       e8		      .byte.b	232	;G
    540  7618		       00		      .byte.b	0	;B
    541  7619		       b0		      .byte.b	176	;R (24)
    542  761a		       a0		      .byte.b	160	;G
    543  761b		       00		      .byte.b	0	;B
    544  761c		       40		      .byte.b	64	;R (23)
    545  761d		       40		      .byte.b	64	;G
    546  761e		       80		      .byte.b	128	;B
    547  761f		       e0		      .byte.b	224	;R (22)
    548  7620		       00		      .byte.b	0	;G
    549  7621		       00		      .byte.b	0	;B
    550  7622		       b0		      .byte.b	176	;R (21)
    551  7623		       10		      .byte.b	16	;G
    552  7624		       40		      .byte.b	64	;B
    553  7625		       e0		      .byte.b	224	;R (20)
    554  7626		       20		      .byte.b	32	;G
    555  7627		       00		      .byte.b	0	;B
    556  7628		       c0		      .byte.b	192	;R (19)
    557  7629		       c0		      .byte.b	192	;G
    558  762a		       00		      .byte.b	0	;B
    559  762b		       80		      .byte.b	128	;R (18)
    560  762c		       00		      .byte.b	0	;G
    561  762d		       00		      .byte.b	0	;B
    562  762e		       c0		      .byte.b	192	;R (17)
    563  762f		       c0		      .byte.b	192	;G
    564  7630		       00		      .byte.b	0	;B
    565  7631		       00		      .byte.b	0	;R (16)
    566  7632		       00		      .byte.b	0	;G
    567  7633		       00		      .byte.b	0	;B
    568  7634		       00		      .byte.b	0	;R (15)
    569  7635		       00		      .byte.b	0	;G
    570  7636		       00		      .byte.b	0	;B
    571  7637		       00		      .byte.b	0	;R (14)
    572  7638		       00		      .byte.b	0	;G
    573  7639		       00		      .byte.b	0	;B
    574  763a		       00		      .byte.b	0	;R (13)
    575  763b		       00		      .byte.b	0	;G
    576  763c		       00		      .byte.b	0	;B
    577  763d		       00		      .byte.b	0	;R (12)
    578  763e		       00		      .byte.b	0	;G
    579  763f		       00		      .byte.b	0	;B
    580  7640		       00		      .byte.b	0	;R (11)
    581  7641		       00		      .byte.b	0	;G
    582  7642		       00		      .byte.b	0	;B
    583  7643		       00		      .byte.b	0	;R (10)
    584  7644		       00		      .byte.b	0	;G
    585  7645		       07		      .byte.b	7	;B
    586  7646		       00		      .byte.b	0	;R (9)
    587  7647		       00		      .byte.b	0	;G
    588  7648		       05		      .byte.b	5	;B
    589  7649		       00		      .byte.b	0	;R (8)
    590  764a		       00		      .byte.b	0	;G
    591  764b		       55		      .byte.b	85	;B
    592  764c		       00		      .byte.b	0	;R (7)
    593  764d		       00		      .byte.b	0	;G
    594  764e		       55		      .byte.b	85	;B
    595  764f		       00		      .byte.b	0	;R (6)
    596  7650		       00		      .byte.b	0	;G
    597  7651		       35		      .byte.b	53	;B
    598  7652		       00		      .byte.b	0	;R (5)
    599  7653		       00		      .byte.b	0	;G
    600  7654		       57		      .byte.b	87	;B
    601  7655		       00		      .byte.b	0	;R (4)
    602  7656		       00		      .byte.b	0	;G
    603  7657		       50		      .byte.b	80	;B
    604  7658		       00		      .byte.b	0	;R (3)
    605  7659		       00		      .byte.b	0	;G
    606  765a		       30		      .byte.b	48	;B
    607  765b		       00		      .byte.b	0	;R (2)
    608  765c		       00		      .byte.b	0	;G
    609  765d		       00		      .byte.b	0	;B
    610  765e		       00		      .byte.b	0	;R (1)
    611  765f		       00		      .byte.b	0	;G
    612  7660		       00		      .byte.b	0	;B
    613  7661		       00		      .byte.b	0	;R (0)
    614  7662		       00		      .byte.b	0	;G
    615  7663		       00		      .byte.b	0	;B
    616  7664				   COL_3
    617  7664		       80		      .byte.b	128	;R (67)
    618  7665		       80		      .byte.b	128	;G
    619  7666		       00		      .byte.b	0	;B
    620  7667		       78		      .byte.b	120	;R (66)
    621  7668		       10		      .byte.b	16	;G
    622  7669		       00		      .byte.b	0	;B
    623  766a		       02		      .byte.b	2	;R (65)
    624  766b		       02		      .byte.b	2	;G
    625  766c		       c0		      .byte.b	192	;B
    626  766d		       03		      .byte.b	3	;R (64)
    627  766e		       00		      .byte.b	0	;G
    628  766f		       5c		      .byte.b	92	;B
    629  7670		       01		      .byte.b	1	;R (63)
    630  7671		       00		      .byte.b	0	;G
    631  7672		       c4		      .byte.b	196	;B
    632  7673		       01		      .byte.b	1	;R (62)
    633  7674		       00		      .byte.b	0	;G
    634  7675		       1c		      .byte.b	28	;B
    635  7676		       01		      .byte.b	1	;R (61)
    636  7677		       00		      .byte.b	0	;G
    637  7678		       d0		      .byte.b	208	;B
    638  7679		       01		      .byte.b	1	;R (60)
    639  767a		       00		      .byte.b	0	;G
    640  767b		       1c		      .byte.b	28	;B
    641  767c		       01		      .byte.b	1	;R (59)
    642  767d		       00		      .byte.b	0	;G
    643  767e		       00		      .byte.b	0	;B
    644  767f		       1f		      .byte.b	31	;R (58)
    645  7680		       1f		      .byte.b	31	;G
    646  7681		       00		      .byte.b	0	;B
    647  7682		       df		      .byte.b	223	;R (57)
    648  7683		       53		      .byte.b	83	;G
    649  7684		       00		      .byte.b	0	;B
    650  7685		       df		      .byte.b	223	;R (56)
    651  7686		       14		      .byte.b	20	;G
    652  7687		       00		      .byte.b	0	;B
    653  7688		       df		      .byte.b	223	;R (55)
    654  7689		       13		      .byte.b	19	;G
    655  768a		       00		      .byte.b	0	;B
    656  768b		       df		      .byte.b	223	;R (54)
    657  768c		       1f		      .byte.b	31	;G
    658  768d		       00		      .byte.b	0	;B
    659  768e		       cf		      .byte.b	207	;R (53)
    660  768f		       4e		      .byte.b	78	;G
    661  7690		       00		      .byte.b	0	;B
    662  7691		       ef		      .byte.b	239	;R (52)
    663  7692		       6f		      .byte.b	111	;G
    664  7693		       00		      .byte.b	0	;B
    665  7694		       90		      .byte.b	144	;R (51)
    666  7695		       10		      .byte.b	16	;G
    667  7696		       00		      .byte.b	0	;B
    668  7697		       88		      .byte.b	136	;R (50)
    669  7698		       88		      .byte.b	136	;G
    670  7699		       00		      .byte.b	0	;B
    671  769a		       01		      .byte.b	1	;R (49)
    672  769b		       01		      .byte.b	1	;G
    673  769c		       00		      .byte.b	0	;B
    674  769d		       03		      .byte.b	3	;R (48)
    675  769e		       03		      .byte.b	3	;G
    676  769f		       00		      .byte.b	0	;B
    677  76a0		       09		      .byte.b	9	;R (47)
    678  76a1		       09		      .byte.b	9	;G
    679  76a2		       00		      .byte.b	0	;B
    680  76a3		       08		      .byte.b	8	;R (46)
    681  76a4		       08		      .byte.b	8	;G
    682  76a5		       00		      .byte.b	0	;B
    683  76a6		       0c		      .byte.b	12	;R (45)
    684  76a7		       0c		      .byte.b	12	;G
    685  76a8		       00		      .byte.b	0	;B
    686  76a9		       05		      .byte.b	5	;R (44)
    687  76aa		       05		      .byte.b	5	;G
    688  76ab		       00		      .byte.b	0	;B
    689  76ac		       01		      .byte.b	1	;R (43)
    690  76ad		       00		      .byte.b	0	;G
    691  76ae		       00		      .byte.b	0	;B
    692  76af		       01		      .byte.b	1	;R (42)
    693  76b0		       00		      .byte.b	0	;G
    694  76b1		       00		      .byte.b	0	;B
    695  76b2		       01		      .byte.b	1	;R (41)
    696  76b3		       00		      .byte.b	0	;G
    697  76b4		       00		      .byte.b	0	;B
    698  76b5		       81		      .byte.b	129	;R (40)
    699  76b6		       81		      .byte.b	129	;G
    700  76b7		       00		      .byte.b	0	;B
    701  76b8		       c0		      .byte.b	192	;R (39)
    702  76b9		       40		      .byte.b	64	;G
    703  76ba		       00		      .byte.b	0	;B
    704  76bb		       c0		      .byte.b	192	;R (38)
    705  76bc		       00		      .byte.b	0	;G
    706  76bd		       00		      .byte.b	0	;B
    707  76be		       e0		      .byte.b	224	;R (37)
    708  76bf		       20		      .byte.b	32	;G
    709  76c0		       00		      .byte.b	0	;B
    710  76c1		       e0		      .byte.b	224	;R (36)
    711  76c2		       00		      .byte.b	0	;G
    712  76c3		       00		      .byte.b	0	;B
    713  76c4		       f0		      .byte.b	240	;R (35)
    714  76c5		       10		      .byte.b	16	;G
    715  76c6		       00		      .byte.b	0	;B
    716  76c7		       f0		      .byte.b	240	;R (34)
    717  76c8		       00		      .byte.b	0	;G
    718  76c9		       00		      .byte.b	0	;B
    719  76ca		       f8		      .byte.b	248	;R (33)
    720  76cb		       08		      .byte.b	8	;G
    721  76cc		       00		      .byte.b	0	;B
    722  76cd		       f8		      .byte.b	248	;R (32)
    723  76ce		       08		      .byte.b	8	;G
    724  76cf		       00		      .byte.b	0	;B
    725  76d0		       f0		      .byte.b	240	;R (31)
    726  76d1		       80		      .byte.b	128	;G
    727  76d2		       00		      .byte.b	0	;B
    728  76d3		       f0		      .byte.b	240	;R (30)
    729  76d4		       00		      .byte.b	0	;G
    730  76d5		       00		      .byte.b	0	;B
    731  76d6		       f8		      .byte.b	248	;R (29)
    732  76d7		       88		      .byte.b	136	;G
    733  76d8		       00		      .byte.b	0	;B
    734  76d9		       f8		      .byte.b	248	;R (28)
    735  76da		       08		      .byte.b	8	;G
    736  76db		       00		      .byte.b	0	;B
    737  76dc		       f8		      .byte.b	248	;R (27)
    738  76dd		       08		      .byte.b	8	;G
    739  76de		       00		      .byte.b	0	;B
    740  76df		       f8		      .byte.b	248	;R (26)
    741  76e0		       88		      .byte.b	136	;G
    742  76e1		       00		      .byte.b	0	;B
    743  76e2		       f8		      .byte.b	248	;R (25)
    744  76e3		       08		      .byte.b	8	;G
    745  76e4		       00		      .byte.b	0	;B
    746  76e5		       f8		      .byte.b	248	;R (24)
    747  76e6		       08		      .byte.b	8	;G
    748  76e7		       00		      .byte.b	0	;B
    749  76e8		       f8		      .byte.b	248	;R (23)
    750  76e9		       08		      .byte.b	8	;G
    751  76ea		       00		      .byte.b	0	;B
    752  76eb		       f0		      .byte.b	240	;R (22)
    753  76ec		       00		      .byte.b	0	;G
    754  76ed		       00		      .byte.b	0	;B
    755  76ee		       f0		      .byte.b	240	;R (21)
    756  76ef		       10		      .byte.b	16	;G
    757  76f0		       00		      .byte.b	0	;B
    758  76f1		       e0		      .byte.b	224	;R (20)
    759  76f2		       20		      .byte.b	32	;G
    760  76f3		       00		      .byte.b	0	;B
    761  76f4		       c0		      .byte.b	192	;R (19)
    762  76f5		       00		      .byte.b	0	;G
    763  76f6		       00		      .byte.b	0	;B
    764  76f7		       c0		      .byte.b	192	;R (18)
    765  76f8		       40		      .byte.b	64	;G
    766  76f9		       00		      .byte.b	0	;B
    767  76fa		       83		      .byte.b	131	;R (17)
    768  76fb		       83		      .byte.b	131	;G
    769  76fc		       00		      .byte.b	0	;B
    770  76fd		       03		      .byte.b	3	;R (16)
    771  76fe		       03		      .byte.b	3	;G
    772  76ff		       00		      .byte.b	0	;B
    773  7700		       01		      .byte.b	1	;R (15)
    774  7701		       01		      .byte.b	1	;G
    775  7702		       00		      .byte.b	0	;B
    776  7703		       00		      .byte.b	0	;R (14)
    777  7704		       00		      .byte.b	0	;G
    778  7705		       00		      .byte.b	0	;B
    779  7706		       00		      .byte.b	0	;R (13)
    780  7707		       00		      .byte.b	0	;G
    781  7708		       0a		      .byte.b	10	;B
    782  7709		       00		      .byte.b	0	;R (12)
    783  770a		       00		      .byte.b	0	;G
    784  770b		       0a		      .byte.b	10	;B
    785  770c		       00		      .byte.b	0	;R (11)
    786  770d		       00		      .byte.b	0	;G
    787  770e		       0e		      .byte.b	14	;B
    788  770f		       00		      .byte.b	0	;R (10)
    789  7710		       00		      .byte.b	0	;G
    790  7711		       aa		      .byte.b	170	;B
    791  7712		       00		      .byte.b	0	;R (9)
    792  7713		       00		      .byte.b	0	;G
    793  7714		       ae		      .byte.b	174	;B
    794  7715		       00		      .byte.b	0	;R (8)
    795  7716		       00		      .byte.b	0	;G
    796  7717		       a4		      .byte.b	164	;B
    797  7718		       00		      .byte.b	0	;R (7)
    798  7719		       00		      .byte.b	0	;G
    799  771a		       a0		      .byte.b	160	;B
    800  771b		       00		      .byte.b	0	;R (6)
    801  771c		       00		      .byte.b	0	;G
    802  771d		       a0		      .byte.b	160	;B
    803  771e		       00		      .byte.b	0	;R (5)
    804  771f		       00		      .byte.b	0	;G
    805  7720		       c0		      .byte.b	192	;B
    806  7721		       00		      .byte.b	0	;R (4)
    807  7722		       00		      .byte.b	0	;G
    808  7723		       00		      .byte.b	0	;B
    809  7724		       00		      .byte.b	0	;R (3)
    810  7725		       00		      .byte.b	0	;G
    811  7726		       00		      .byte.b	0	;B
    812  7727		       00		      .byte.b	0	;R (2)
    813  7728		       00		      .byte.b	0	;G
    814  7729		       00		      .byte.b	0	;B
    815  772a		       00		      .byte.b	0	;R (1)
    816  772b		       00		      .byte.b	0	;G
    817  772c		       00		      .byte.b	0	;B
    818  772d		       00		      .byte.b	0	;R (0)
    819  772e		       00		      .byte.b	0	;G
    820  772f		       00		      .byte.b	0	;B
    821  7730				   COL_4
    822  7730		       00		      .byte.b	0	;R (67)
    823  7731		       00		      .byte.b	0	;G
    824  7732		       00		      .byte.b	0	;B
    825  7733		       00		      .byte.b	0	;R (66)
    826  7734		       00		      .byte.b	0	;G
    827  7735		       00		      .byte.b	0	;B
    828  7736		       00		      .byte.b	0	;R (65)
    829  7737		       00		      .byte.b	0	;G
    830  7738		       00		      .byte.b	0	;B
    831  7739		       01		      .byte.b	1	;R (64)
    832  773a		       01		      .byte.b	1	;G
    833  773b		       00		      .byte.b	0	;B
    834  773c		       03		      .byte.b	3	;R (63)
    835  773d		       02		      .byte.b	2	;G
    836  773e		       00		      .byte.b	0	;B
    837  773f		       03		      .byte.b	3	;R (62)
    838  7740		       03		      .byte.b	3	;G
    839  7741		       00		      .byte.b	0	;B
    840  7742		       03		      .byte.b	3	;R (61)
    841  7743		       02		      .byte.b	2	;G
    842  7744		       00		      .byte.b	0	;B
    843  7745		       03		      .byte.b	3	;R (60)
    844  7746		       03		      .byte.b	3	;G
    845  7747		       00		      .byte.b	0	;B
    846  7748		       03		      .byte.b	3	;R (59)
    847  7749		       02		      .byte.b	2	;G
    848  774a		       00		      .byte.b	0	;B
    849  774b		       03		      .byte.b	3	;R (58)
    850  774c		       03		      .byte.b	3	;G
    851  774d		       00		      .byte.b	0	;B
    852  774e		       03		      .byte.b	3	;R (57)
    853  774f		       03		      .byte.b	3	;G
    854  7750		       00		      .byte.b	0	;B
    855  7751		       0d		      .byte.b	13	;R (56)
    856  7752		       0d		      .byte.b	13	;G
    857  7753		       00		      .byte.b	0	;B
    858  7754		       1f		      .byte.b	31	;R (55)
    859  7755		       0b		      .byte.b	11	;G
    860  7756		       00		      .byte.b	0	;B
    861  7757		       3f		      .byte.b	63	;R (54)
    862  7758		       25		      .byte.b	37	;G
    863  7759		       00		      .byte.b	0	;B
    864  775a		       3f		      .byte.b	63	;R (53)
    865  775b		       30		      .byte.b	48	;G
    866  775c		       00		      .byte.b	0	;B
    867  775d		       21		      .byte.b	33	;R (52)
    868  775e		       21		      .byte.b	33	;G
    869  775f		       00		      .byte.b	0	;B
    870  7760		       00		      .byte.b	0	;R (51)
    871  7761		       00		      .byte.b	0	;G
    872  7762		       00		      .byte.b	0	;B
    873  7763		       00		      .byte.b	0	;R (50)
    874  7764		       00		      .byte.b	0	;G
    875  7765		       00		      .byte.b	0	;B
    876  7766		       01		      .byte.b	1	;R (49)
    877  7767		       01		      .byte.b	1	;G
    878  7768		       00		      .byte.b	0	;B
    879  7769		       03		      .byte.b	3	;R (48)
    880  776a		       02		      .byte.b	2	;G
    881  776b		       00		      .byte.b	0	;B
    882  776c		       07		      .byte.b	7	;R (47)
    883  776d		       07		      .byte.b	7	;G
    884  776e		       00		      .byte.b	0	;B
    885  776f		       00		      .byte.b	0	;R (46)
    886  7770		       00		      .byte.b	0	;G
    887  7771		       00		      .byte.b	0	;B
    888  7772		       00		      .byte.b	0	;R (45)
    889  7773		       00		      .byte.b	0	;G
    890  7774		       00		      .byte.b	0	;B
    891  7775		       06		      .byte.b	6	;R (44)
    892  7776		       06		      .byte.b	6	;G
    893  7777		       00		      .byte.b	0	;B
    894  7778		       0c		      .byte.b	12	;R (43)
    895  7779		       04		      .byte.b	4	;G
    896  777a		       00		      .byte.b	0	;B
    897  777b		       1c		      .byte.b	28	;R (42)
    898  777c		       1c		      .byte.b	28	;G
    899  777d		       00		      .byte.b	0	;B
    900  777e		       38		      .byte.b	56	;R (41)
    901  777f		       38		      .byte.b	56	;G
    902  7780		       00		      .byte.b	0	;B
    903  7781		       00		      .byte.b	0	;R (40)
    904  7782		       00		      .byte.b	0	;G
    905  7783		       00		      .byte.b	0	;B
    906  7784		       0a		      .byte.b	10	;R (39)
    907  7785		       0a		      .byte.b	10	;G
    908  7786		       00		      .byte.b	0	;B
    909  7787		       02		      .byte.b	2	;R (38)
    910  7788		       00		      .byte.b	0	;G
    911  7789		       00		      .byte.b	0	;B
    912  778a		       32		      .byte.b	50	;R (37)
    913  778b		       30		      .byte.b	48	;G
    914  778c		       00		      .byte.b	0	;B
    915  778d		       72		      .byte.b	114	;R (36)
    916  778e		       72		      .byte.b	114	;G
    917  778f		       00		      .byte.b	0	;B
    918  7790		       74		      .byte.b	116	;R (35)
    919  7791		       54		      .byte.b	84	;G
    920  7792		       00		      .byte.b	0	;B
    921  7793		       54		      .byte.b	84	;R (34)
    922  7794		       10		      .byte.b	16	;G
    923  7795		       00		      .byte.b	0	;B
    924  7796		       04		      .byte.b	4	;R (33)
    925  7797		       00		      .byte.b	0	;G
    926  7798		       00		      .byte.b	0	;B
    927  7799		       02		      .byte.b	2	;R (32)
    928  779a		       02		      .byte.b	2	;G
    929  779b		       00		      .byte.b	0	;B
    930  779c		       10		      .byte.b	16	;R (31)
    931  779d		       10		      .byte.b	16	;G
    932  779e		       00		      .byte.b	0	;B
    933  779f		       68		      .byte.b	104	;R (30)
    934  77a0		       68		      .byte.b	104	;G
    935  77a1		       00		      .byte.b	0	;B
    936  77a2		       6c		      .byte.b	108	;R (29)
    937  77a3		       24		      .byte.b	36	;G
    938  77a4		       00		      .byte.b	0	;B
    939  77a5		       4c		      .byte.b	76	;R (28)
    940  77a6		       08		      .byte.b	8	;G
    941  77a7		       00		      .byte.b	0	;B
    942  77a8		       d4		      .byte.b	212	;R (27)
    943  77a9		       d4		      .byte.b	212	;G
    944  77aa		       00		      .byte.b	0	;B
    945  77ab		       00		      .byte.b	0	;R (26)
    946  77ac		       00		      .byte.b	0	;G
    947  77ad		       00		      .byte.b	0	;B
    948  77ae		       2c		      .byte.b	44	;R (25)
    949  77af		       2c		      .byte.b	44	;G
    950  77b0		       00		      .byte.b	0	;B
    951  77b1		       36		      .byte.b	54	;R (24)
    952  77b2		       16		      .byte.b	22	;G
    953  77b3		       00		      .byte.b	0	;B
    954  77b4		       2e		      .byte.b	46	;R (23)
    955  77b5		       0e		      .byte.b	14	;G
    956  77b6		       00		      .byte.b	0	;B
    957  77b7		       60		      .byte.b	96	;R (22)
    958  77b8		       40		      .byte.b	64	;G
    959  77b9		       00		      .byte.b	0	;B
    960  77ba		       28		      .byte.b	40	;R (21)
    961  77bb		       28		      .byte.b	40	;G
    962  77bc		       00		      .byte.b	0	;B
    963  77bd		       0f		      .byte.b	15	;R (20)
    964  77be		       0d		      .byte.b	13	;G
    965  77bf		       00		      .byte.b	0	;B
    966  77c0		       1a		      .byte.b	26	;R (19)
    967  77c1		       1a		      .byte.b	26	;G
    968  77c2		       00		      .byte.b	0	;B
    969  77c3		       18		      .byte.b	24	;R (18)
    970  77c4		       08		      .byte.b	8	;G
    971  77c5		       00		      .byte.b	0	;B
    972  77c6		       14		      .byte.b	20	;R (17)
    973  77c7		       04		      .byte.b	4	;G
    974  77c8		       00		      .byte.b	0	;B
    975  77c9		       16		      .byte.b	22	;R (16)
    976  77ca		       16		      .byte.b	22	;G
    977  77cb		       00		      .byte.b	0	;B
    978  77cc		       04		      .byte.b	4	;R (15)
    979  77cd		       00		      .byte.b	0	;G
    980  77ce		       00		      .byte.b	0	;B
    981  77cf		       06		      .byte.b	6	;R (14)
    982  77d0		       02		      .byte.b	2	;G
    983  77d1		       00		      .byte.b	0	;B
    984  77d2		       05		      .byte.b	5	;R (13)
    985  77d3		       05		      .byte.b	5	;G
    986  77d4		       00		      .byte.b	0	;B
    987  77d5		       05		      .byte.b	5	;R (12)
    988  77d6		       05		      .byte.b	5	;G
    989  77d7		       00		      .byte.b	0	;B
    990  77d8		       00		      .byte.b	0	;R (11)
    991  77d9		       00		      .byte.b	0	;G
    992  77da		       00		      .byte.b	0	;B
    993  77db		       00		      .byte.b	0	;R (10)
    994  77dc		       00		      .byte.b	0	;G
    995  77dd		       00		      .byte.b	0	;B
    996  77de		       00		      .byte.b	0	;R (9)
    997  77df		       00		      .byte.b	0	;G
    998  77e0		       00		      .byte.b	0	;B
    999  77e1		       00		      .byte.b	0	;R (8)
   1000  77e2		       00		      .byte.b	0	;G
   1001  77e3		       00		      .byte.b	0	;B
   1002  77e4		       00		      .byte.b	0	;R (7)
   1003  77e5		       00		      .byte.b	0	;G
   1004  77e6		       00		      .byte.b	0	;B
   1005  77e7		       00		      .byte.b	0	;R (6)
   1006  77e8		       00		      .byte.b	0	;G
   1007  77e9		       00		      .byte.b	0	;B
   1008  77ea		       00		      .byte.b	0	;R (5)
   1009  77eb		       00		      .byte.b	0	;G
   1010  77ec		       00		      .byte.b	0	;B
   1011  77ed		       00		      .byte.b	0	;R (4)
   1012  77ee		       00		      .byte.b	0	;G
   1013  77ef		       00		      .byte.b	0	;B
   1014  77f0		       00		      .byte.b	0	;R (3)
   1015  77f1		       00		      .byte.b	0	;G
   1016  77f2		       00		      .byte.b	0	;B
   1017  77f3		       00		      .byte.b	0	;R (2)
   1018  77f4		       00		      .byte.b	0	;G
   1019  77f5		       00		      .byte.b	0	;B
   1020  77f6		       00		      .byte.b	0	;R (1)
   1021  77f7		       00		      .byte.b	0	;G
   1022  77f8		       00		      .byte.b	0	;B
   1023  77f9		       00		      .byte.b	0	;R (0)
   1024  77fa		       00		      .byte.b	0	;G
   1025  77fb		       00		      .byte.b	0	;B
------- FILE TitleScreen@2.asm
      6  77fc
      0  77fc					      CHECK_BANK_SIZE	"TITLEDATA2"
      1  77fc		       03 fc	   .TEMP      =	* - _BANK_START
 TITLEDATA2 (1K) SIZE =  $3fc , FREE= $4
      2  77fc					      ECHO	"TITLEDATA2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  77fc				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  77fc				  -	      ECHO	"BANK OVERFLOW @ ", "TITLEDATA2", " size=", * - ORIGIN
      5  77fc				  -	      ERR
      6  77fc					      ENDIF
------- FILE ./chess.asm
    622  77fc
------- FILE BANK_LAST.asm LEVEL 2 PASS 4
      0  77fc					      include	"BANK_LAST.asm"
      1  77fc							; Chess
      2  77fc							; Copyright (c) 2019-2020 Andrew Davie
      3  77fc							; andrew@taswegian.com
      4  77fc
      0  77fc					      SLOT	3
      1  77fc				  -	      IF	(3 < 0) || (3 > 3)
      2  77fc				  -	      ECHO	"Illegal bank address/segment location", 3
      3  77fc				  -	      ERR
      4  77fc					      ENDIF
      5  77fc				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  77fc				   _BANK_SLOT SET	3 * 64
      0  77fc					      ROMBANK	LAST
      1  7c00 ????				      SEG	LAST
      2  7800					      ORG	_ORIGIN
      3  7800					      RORG	_BANK_ADDRESS_ORIGIN
      4  7800				   _BANK_START SET	*
      5  7800				   LAST_START SET	*
      6  7800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7800				   LAST       SET	_BANK_SLOT + _CURRENT_BANK
      8  7800				   _ORIGIN    SET	_ORIGIN + 1024
      7  7800
      8  7800
      9  7800		       00 00 00 00*	      ds	1024
     10  7c00
     11  7c00							; EOF
------- FILE ./chess.asm
    624  7c00
    625  7c00							;---------------------------------------------------------------------------------------------------
    626  7c00							;EOF
