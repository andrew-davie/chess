------- FILE ./chess.asm LEVEL 1 PASS 4
      1  7c00 ????						; Chess
      2  7c00 ????						; Atari 2600 Chess display system
      3  7c00 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  7c00 ????						; andrew@taswegian.com
      5  7c00 ????
      6  7c00 ????
      7  7c00 ????	       00 40	   TIA_BASE_ADDRESS =	$40
      8  7c00 ????
      9  7c00 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 4
      0  7c00 ????				      include	"vcs.h"
      1  7c00 ????						; VCS.H
      2  7c00 ????						; Version 1.05, 13/November/2003
      3  7c00 ????
      4  7c00 ????	       00 69	   VERSION_VCS =	105
      5  7c00 ????
      6  7c00 ????						; This file defines hardware registers and memory mapping for the
      7  7c00 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  7c00 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  7c00 ????						; available at at http://www.atari2600.org/dasm
     10  7c00 ????						;
     11  7c00 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  7c00 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  7c00 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  7c00 ????						; with your views.  Please contribute, if you think you can improve this
     15  7c00 ????						; file!
     16  7c00 ????						;
     17  7c00 ????						; Latest Revisions...
     18  7c00 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  7c00 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  7c00 ????						;			    This will allow conditional code to verify VCS.H being
     21  7c00 ????						;			    used for code assembly.
     22  7c00 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  7c00 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  7c00 ????						;			 mirrored reading/writing differences.	This is more a
     25  7c00 ????						;			 readability issue, and binary compatibility with disassembled
     26  7c00 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  7c00 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  7c00 ????						;			 which was broken by the use of segments in this file, as
     29  7c00 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  7c00 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  7c00 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  7c00 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  7c00 ????						;						   it is safe to leave it undefined, and the base address will
     34  7c00 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  7c00 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  7c00 ????						;			  - register definitions are now generated through assignment
     37  7c00 ????						;			    in uninitialised segments.	This allows a changeable base
     38  7c00 ????						;			    address architecture.
     39  7c00 ????						; 1.0	22/MAR/2003		Initial release
     40  7c00 ????
     41  7c00 ????
     42  7c00 ????						;-------------------------------------------------------------------------------
     43  7c00 ????
     44  7c00 ????						; TIA_BASE_ADDRESS
     45  7c00 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  7c00 ????						; Normally 0, the base address should (externally, before including this file)
     47  7c00 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  7c00 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  7c00 ????						; < $40 as a bankswitch.
     50  7c00 ????
     51  7c00 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  7c00 ????			  -TIA_BASE_ADDRESS =	0
     53  7c00 ????				      ENDIF
     54  7c00 ????
     55  7c00 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  7c00 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  7c00 ????						; *OR* by declaring the label before including this file, eg:
     58  7c00 ????						; TIA_BASE_ADDRESS = $40
     59  7c00 ????						;   include "vcs.h"
     60  7c00 ????
     61  7c00 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  7c00 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  7c00 ????						; for the mirrored ROM hardware registers.
     64  7c00 ????
     65  7c00 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  7c00 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  7c00 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  7c00 ????
     69  7c00 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  7c00 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  7c00 ????				      ENDIF
     72  7c00 ????
     73  7c00 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  7c00 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  7c00 ????				      ENDIF
     76  7c00 ????
     77  7c00 ????						;-------------------------------------------------------------------------------
     78  7c00 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE macro.h LEVEL 2 PASS 4
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE piece_defines.h LEVEL 2 PASS 4
      0  0000 ????				      include	"piece_defines.h"
      1  0000 ????						; Copyright (C)2020 Andrew Davie
      2  0000 ????
      3  0000 ????	       00 80	   BLACK      =	128
      4  0000 ????	       00 00	   WHITE      =	0
      5  0000 ????
      6  0000 ????	       00 80	   FLAG_COLOUR =	128	; mask
      7  0000 ????	       00 40	   FLAG_MOVED =	64	; mark ALL pieces when moved. Used for castling
      8  0000 ????						; but maybe useful for evaluation of development
      9  0000 ????	       00 20	   FLAG_ENPASSANT =	32
     10  0000 ????	       00 10	   FLAG_CASTLE =	16
     11  0000 ????
     12  0000 ????						;---------------------------------------------------------------------------------------------------
     13  0000 ????						; DEFINE THE PIECES
     14  0000 ????						; ID lives in bits 0-2
     15  0000 ????
     16  0000 ????	       00 00	   BLANK      =	0
     17  0000 ????	       00 00	   ███  =	BLANK
     18  0000 ????
     19  0000 ????	       00 01	   WPAWN      =	1
     20  0000 ????	       00 01	   WP	      =	WPAWN
     21  0000 ????	       00 02	   BPAWN      =	2
     22  0000 ????	       00 02	   BP	      =	BPAWN
     23  0000 ????	       00 03	   KNIGHT     =	3
     24  0000 ????	       00 03	   N	      =	KNIGHT
     25  0000 ????	       00 04	   BISHOP     =	4
     26  0000 ????	       00 04	   B	      =	BISHOP
     27  0000 ????	       00 05	   ROOK       =	5
     28  0000 ????	       00 05	   R	      =	ROOK
     29  0000 ????	       00 06	   QUEEN      =	6
     30  0000 ????	       00 06	   Q	      =	QUEEN
     31  0000 ????	       00 07	   KING       =	7
     32  0000 ????	       00 07	   K	      =	KING
     33  0000 ????
     34  0000 ????	       00 0f	   PIECE_MASK =	15	; trim off the flags leaving just piece ID
     35  0000 ????
     36  0000 ????						;---------------------------------------------------------------------------------------------------
     37  0000 ????
     38  0000 ????						; Movements
     39  0000 ????
     40  0000 ????	       00 0a	   _UP	      =	10	; up
     41  0000 ????	       ff ff ff ff _LEFT      =	-1	; left
     42  0000 ????	       ff ff ff f6 _DOWN      =	-10	; down
     43  0000 ????	       00 01	   _RIGHT     =	1	; right
     44  0000 ????
     45  0000 ????						; EOF
------- FILE ./chess.asm
     13  0000 ????
     14  0000 ????	       00 00	   VERBOSE    =	0	; set to 1 for compile messages
     15  0000 ????
     16  0000 ????			   ORIGIN     SET	0
     17  0000 ????			   ORIGIN_RAM SET	0
     18  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	segtime_c
     89  0000 ????			   {1}	      SET	({2}+32)/64 + 2
     90  0000 ????			   TEST_{1}   =	0
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????						; Pathways
     94  0000 ????						; StealPart3, not enough time for SCD_SLOW --> 79✅
     95  0000 ????						; if QuickDraw does immediate exit, 58✅
     96  0000 ????
     97  0000 ????						;---------------------------------------------------------------------------------------------------
     98  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_MINIMUM_TIMESLICE, 54	;✅ abort time maximum requirement for timeslice
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	(54+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    100  0000 ????
    101  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    102  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    103  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    104  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    105  0000 ????						; uses ...
    106  0000 ????
    107  0000 ????
    108  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    109  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    110  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    111  0000 ????
    112  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    113  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    114  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,22	;18 ;12	  ;NFI
      1  0000 ????			   SEGTIME_MAN SET	22
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
------- FILE ./chess.asm
     20  0000 ????
     21  0000 ????
     22  0000 ????	       00 00	   _FIRST_BANK =	0	; 3E+ 1st bank holds reset vectors
     23  0000 ????
     24  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     25  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     26  0000 ????						;FIXED_BANK		 = 15 * 2048	       ; ->> 32K
     27  0000 ????						;FIXED_BANK		 = 31 * 2048	       ; ->> 64K
     28  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     29  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     30  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     31  0000 ????
     32  0000 ????	       00 01	   YES	      =	1
     33  0000 ????	       00 00	   NO	      =	0
     34  0000 ????
     35  0000 ????	       70 00	   INFINITY   =	$7000	;32767
     36  0000 ????
     37  0000 ????
     38  0000 ????						; assemble diagnostics. Remove for release.
     39  0000 ????
     40  0000 ????	       00 00	   TEST_POSITION =	0	; 0=normal, 1 = setup test position
     41  0000 ????	       00 00	   DIAGNOSTICS =	0
     42  0000 ????	       00 01	   QUIESCENCE =	1
     43  0000 ????	       00 00	   ASSERTS    =	0
     44  0000 ????	       00 00	   PVSP       =	0	; player versus player =1
     45  0000 ????	       00 01	   ENPASSANT_ENABLED =	1
     46  0000 ????	       00 01	   CASTLING_ENABLED =	1
     47  0000 ????
     48  0000 ????	       00 03	   SEARCH_DEPTH =	3
     49  0000 ????	       00 04	   QUIESCE_EXTRA_DEPTH =	4
     50  0000 ????
     51  0000 ????
     52  0000 ????	       00 07	   PLY_BANKS  =	SEARCH_DEPTH + QUIESCE_EXTRA_DEPTH
     53  0000 ????	       00 07	   MAX_PLY_DEPTH_BANK =	PLY_BANKS	;TODO -- RAMBANK_PLY + PLY_BANKS
     54  0000 ????
     55  0000 ????						;IF RAMBANK_PLY + MAX_PLY_DEPTH_BANK > 31
     56  0000 ????						;    ERR "Not enough RAM for PLY banks"
     57  0000 ????						;ENDIF
     58  0000 ????
     59  0000 ????
     60  0000 ????
     61  0000 ????
     62  0000 ????	       00 80	   SWAP_SIDE  =	128	;TODO + (RAMBANK_PLY ^ (RAMBANK_PLY+1))
     63  0000 ????
     64  0000 ????
     65  0000 ????
     66  0000 ????						; DELAYS
     67  0000 ????
     68  0000 ????	       00 0a	   READY_TO_MOVE_FLASH =	10
     69  0000 ????
     70  0000 ????						;===================================
     71  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     72  0000 ????						;===================================
     73  0000 ????
     74  0000 ????						;-------------------------------------------------------------------------------
     75  0000 ????						; The following are optional YES/NO depending on phase of the moon
     76  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     77  0000 ????						;-------------------------------------------------------------------------------
     78  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     79  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     80  0000 ????			  -	      IF	FINAL_VERSION = YES
     81  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     82  0000 ????				      ENDIF
     83  0000 ????
     84  0000 ????						;-------------------------------------------------------------------------------
     85  0000 ????
     86  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     87  0000 ????
     88  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
     89  0000 ????
     90  0000 ????						;------------------------------------------------------------------------------
     91  0000 ????
     92  0000 ????	       00 01	   PLUSCART   =	YES
     93  0000 ????
     94  0000 ????						;------------------------------------------------------------------------------
     95  0000 ????
     96  0000 ????
     97  0000 ????	       00 08	   CHESSBOARD_ROWS =	8	; number of ROWS of chessboard
     98  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
     99  0000 ????	       00 48	   PIECE_SHAPE_SIZE =	72	; 3 PF bytes x 24 scanlines
    100  0000 ????
    101  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    102  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    103  0000 ????
    104  0000 ????
    105  0000 ????	       02 00	   RAM_SIZE   =	$200
    106  0000 ????	       02 00	   RAM_WRITE  =	$200	; add this to RAM address when doing writes
    107  0000 ????	       02 00	   RAM	      =	RAM_WRITE
    108  0000 ????
    109  0000 ????
    110  0000 ????
    111  0000 ????						; Platform constants:
    112  0000 ????	       00 02	   PAL	      =	%10
    113  0000 ????	       00 02	   PAL_50     =	PAL|0
    114  0000 ????	       00 03	   PAL_60     =	PAL|1
    115  0000 ????
    116  0000 ????
    117  0000 ????				      IF	L276
    118  0000 ????	       00 30	   VBLANK_TIM_NTSC =	48	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    119  0000 ????			  -	      ELSE
    120  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    121  0000 ????				      ENDIF
    122  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    123  0000 ????
    124  0000 ????				      IF	L276
    125  0000 ????	       00 23	   OVERSCAN_TIM_NTSC =	35	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    126  0000 ????			  -	      ELSE
    127  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    128  0000 ????				      ENDIF
    129  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    130  0000 ????
    131  0000 ????				      IF	L276
    132  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    133  0000 ????			  -	      ELSE
    134  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    135  0000 ????				      ENDIF
    136  0000 ????	       01 38	   SCANLINES_PAL =	312
    137  0000 ????
    138  0000 ????
    139  0000 ????	       00 2e	   TIME_PART_2 =	46
    140  0000 ????	       00 2e	   TIME_PART_1 =	46
    141  0000 ????
    142  0000 ????
    143  0000 ????	       00 00	   SLOT0      =	0
    144  0000 ????	       00 40	   SLOT1      =	64
    145  0000 ????	       00 80	   SLOT2      =	128
    146  0000 ????	       00 c0	   SLOT3      =	192
    147  0000 ????
    148  0000 ????						;------------------------------------------------------------------------------
    149  0000 ????						; MACRO definitions
    150  0000 ????
    151  0000 ????
    152  0000 ????	       04 00	   _ROM_BANK_SIZE =	$400
    153  0000 ????	       02 00	   _RAM_BANK_SIZE =	$200
    154  0000 ????
    155  0000 ????				      MAC	newbank
    156  0000 ????				      SEG	{1}
    157  0000 ????				      ORG	_ORIGIN
    158  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    159  0000 ????			   _BANK_START SET	*
    160  0000 ????			   {1}_START  SET	*
    161  0000 ????			   _CURRENT_BANK SET	_ORIGIN/1024
    162  0000 ????			   {1}	      SET	_BANK_SLOT + _CURRENT_BANK
    163  0000 ????			   _ORIGIN    SET	_ORIGIN + 1024
    164  0000 ????				      ENDM		; bank name
    165  0000 ????
    166  0000 ????						;	      MAC DEFINE_1K_SEGMENT ; {seg name}
    167  0000 ????						;		  ALIGN $400
    168  0000 ????						;SEGMENT_{1}	  SET *
    169  0000 ????						;BANK_{1}	  SET _CURRENT_BANK
    170  0000 ????						;	      ENDM
    171  0000 ????
    172  0000 ????				      MAC	check_bank_size
    173  0000 ????			   .TEMP      =	* - _BANK_START
    174  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
    175  0000 ????				      IF	( .TEMP ) > _ROM_BANK_SIZE
    176  0000 ????				      ECHO	"BANK OVERFLOW @ ", {1}, " size=", * - ORIGIN
    177  0000 ????				      ERR
    178  0000 ????				      ENDIF
    179  0000 ????				      ENDM		; name
    180  0000 ????
    181  0000 ????				      MAC	check_ram_bank_size
    182  0000 ????			   .TEMP      =	* - _BANK_START
    183  0000 ????				      ECHO	{1}, "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
    184  0000 ????				      IF	( .TEMP ) > _RAM_BANK_SIZE
    185  0000 ????				      ECHO	"BANK OVERFLOW @ ", {1}, " size=", * - ORIGIN
    186  0000 ????				      ERR
    187  0000 ????				      ENDIF
    188  0000 ????				      ENDM		; name
    189  0000 ????
    190  0000 ????						;---------------------------------------------------------------------------------------------------
    191  0000 ????
    192  0000 ????						; Macro inserts a page break if the object would overlap a page
    193  0000 ????
    194  0000 ????				      MAC	optional_pagebreak
    195  0000 ????				      LIST	OFF
    196  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    197  0000 ????			   EARLY_LOCATION SET	*
    198  0000 ????				      ALIGN	256
    199  0000 ????				      IF	VERBOSE=1
    200  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR", {1}
    201  0000 ????				      ECHO	"REQUESTED SIZE =", {2}
    202  0000 ????				      ECHO	"WASTED SPACE =", *-EARLY_LOCATION
    203  0000 ????				      ECHO	"PAGEBREAK LOCATION =", *
    204  0000 ????				      ENDIF
    205  0000 ????				      ENDIF
    206  0000 ????				      LIST	ON
    207  0000 ????				      ENDM		; { string, size }
    208  0000 ????
    209  0000 ????
    210  0000 ????				      MAC	check_page_crossing
    211  0000 ????				      LIST	OFF
    212  0000 ????				      IF	( >BLOCK_END != >BLOCK_START )
    213  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    214  0000 ????				      ENDIF
    215  0000 ????				      LIST	ON
    216  0000 ????				      ENDM
    217  0000 ????
    218  0000 ????				      MAC	checkpage
    219  0000 ????				      LIST	OFF
    220  0000 ????				      IF	>. != >{1}
    221  0000 ????				      ECHO	""
    222  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    223  0000 ????				      ECHO	""
    224  0000 ????				      ERR
    225  0000 ????				      ENDIF
    226  0000 ????				      LIST	ON
    227  0000 ????				      ENDM
    228  0000 ????
    229  0000 ????				      MAC	checkpagex
    230  0000 ????				      LIST	OFF
    231  0000 ????				      IF	>. != >{1}
    232  0000 ????				      ECHO	""
    233  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    234  0000 ????				      ECHO	{2}
    235  0000 ????				      ECHO	""
    236  0000 ????				      ERR
    237  0000 ????				      ENDIF
    238  0000 ????				      LIST	ON
    239  0000 ????				      ENDM
    240  0000 ????
    241  0000 ????						;---------------------------------------------------------------------------------------------------
    242  0000 ????
    243  0000 ????						; Defines a variable of the given size, making sure it doesn't cross a page
    244  0000 ????				      MAC	variable
    245  0000 ????				      OPTIONAL_PAGEBREAK	"Variable", {2}
    246  0000 ????			   {1}	      ds	{2}
    247  0000 ????				      ENDM		; {name, size}
    248  0000 ????
    249  0000 ????
    250  0000 ????						;---------------------------------------------------------------------------------------------------
    251  0000 ????
    252  0000 ????				      MAC	def
    253  0000 ????			   SLOT_{1}   SET	_BANK_SLOT
    254  0000 ????			   BANK_{1}   SET	SLOT_{1} + _CURRENT_BANK	; bank in which this subroutine resides
    255  0000 ????			   {1}			; entry point
    256  0000 ????			   TEMPORARY_VAR SET	Overlay
    257  0000 ????			   TEMPORARY_OFFSET SET	0
    258  0000 ????			   VAR_BOUNDARY_{1} SET	TEMPORARY_OFFSET
    259  0000 ????			   FUNCTION_NAME SET	{1}
    260  0000 ????				      ENDM		; name of subroutine
    261  0000 ????
    262  0000 ????
    263  0000 ????						;---------------------------------------------------------------------------------------------------
    264  0000 ????
    265  0000 ????				      MAC	allocate
    266  0000 ????				      OPTIONAL_PAGEBREAK	"Table", {2}
    267  0000 ????				      DEF	{1}
    268  0000 ????				      ENDM
    269  0000 ????
    270  0000 ????						;---------------------------------------------------------------------------------------------------
    271  0000 ????
    272  0000 ????				      MAC	slot
    273  0000 ????				      IF	({1} < 0) || ({1} > 3)
    274  0000 ????				      ECHO	"Illegal bank address/segment location", {1}
    275  0000 ????				      ERR
    276  0000 ????				      ENDIF
    277  0000 ????			   _BANK_ADDRESS_ORIGIN SET	$F000 + ({1} * _ROM_BANK_SIZE)
    278  0000 ????			   _BANK_SLOT SET	{1} * 64	; D7/D6 selector
    279  0000 ????				      ENDM		; {1}
    280  0000 ????
    281  0000 ????
    282  0000 ????						;---------------------------------------------------------------------------------------------------
    283  0000 ????
    284  0000 ????				      MAC	negeval
    285  0000 ????
    286  0000 ????				      sec
    287  0000 ????				      lda	#0
    288  0000 ????				      sbc	Evaluation
    289  0000 ????				      sta	Evaluation
    290  0000 ????				      lda	#0
    291  0000 ????				      sbc	Evaluation+1
    292  0000 ????				      sta	Evaluation+1
    293  0000 ????				      ENDM
    294  0000 ????
    295  0000 ????
    296  0000 ????				      MAC	swap
    297  0000 ????				      lda	sideToMove
    298  0000 ????				      eor	#SWAP_SIDE
    299  0000 ????				      sta	sideToMove
    300  0000 ????				      ENDM
    301  0000 ????
    302  0000 ????
    303  0000 ????						;---------------------------------------------------------------------------------------------------
    304  0000 ????
    305  0000 ????			   TEMPORARY_OFFSET SET	0
    306  0000 ????
    307  0000 ????
    308  0000 ????				      MAC	vend
    309  0000 ????				      IFNCONST	{1}
    310  0000 ????				      ECHO	"Incorrect VEND label", {1}
    311  0000 ????				      ERR
    312  0000 ????				      ENDIF
    313  0000 ????			   VAREND_{1} =	TEMPORARY_VAR
    314  0000 ????				      ENDM		; {1}
    315  0000 ????
    316  0000 ????
    317  0000 ????				      MAC	refer
    318  0000 ????				      IF	VAREND_{1} > TEMPORARY_VAR
    319  0000 ????			   TEMPORARY_VAR SET	VAREND_{1}
    320  0000 ????				      ENDIF
    321  0000 ????				      ENDM		; {1}
    322  0000 ????
    323  0000 ????
    324  0000 ????
    325  0000 ????						; Define a temporary variable for use in a subroutine
    326  0000 ????						; Will allocate appropriate bytes, and also check for overflow of the available overlay buffer
    327  0000 ????
    328  0000 ????				      MAC	var
    329  0000 ????			   {1}	      =	TEMPORARY_VAR
    330  0000 ????			   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + {2}
    331  0000 ????
    332  0000 ????			   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
    333  0000 ????				      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
    334  0000 ????			   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
    335  0000 ????				      ENDIF
    336  0000 ????				      IF	OVERLAY_DELTA > OVERLAY_SIZE
    337  0000 ????				      ECHO	"Temporary Variable", {1}, "overflow!"
    338  0000 ????				      ERR
    339  0000 ????				      ENDIF
    340  0000 ????				      LIST	ON
    341  0000 ????				      ENDM		; { name, size }
    342  0000 ????
    343  0000 ????
    344  0000 ????						;---------------------------------------------------------------------------------------------------
    345  0000 ????
    346  0000 ????				      MAC	tag
    347  0000 ????						; {0}
    348  0000 ????				      ENDM		; {ident/tag}
    349  0000 ????
    350  0000 ????						;---------------------------------------------------------------------------------------------------
    351  0000 ????
    352  0000 ????				      MAC	sta@ram
    353  0000 ????				      sta	[RAM]+{0}
    354  0000 ????				      ENDM		;{}
    355  0000 ????
    356  0000 ????				      MAC	stx@ram
    357  0000 ????				      stx	[RAM]+{0}
    358  0000 ????				      ENDM
    359  0000 ????
    360  0000 ????				      MAC	sty@ram
    361  0000 ????				      sty	[RAM]+{0}
    362  0000 ????				      ENDM
    363  0000 ????
    364  0000 ????				      MAC	sta@ply
    365  0000 ????				      sta	[RAM]+{0}
    366  0000 ????				      ENDM		;{}
    367  0000 ????
    368  0000 ????				      MAC	stx@ply
    369  0000 ????				      stx	[RAM]+{0}
    370  0000 ????				      ENDM
    371  0000 ????
    372  0000 ????				      MAC	sty@ply
    373  0000 ????				      sty	[RAM]+{0}
    374  0000 ????				      ENDM
    375  0000 ????
    376  0000 ????
    377  0000 ????				      MAC	lda@ram
    378  0000 ????				      lda	{0}
    379  0000 ????				      ENDM		;{}
    380  0000 ????
    381  0000 ????				      MAC	ldx@ram
    382  0000 ????				      ldx	{0}
    383  0000 ????				      ENDM		;{}
    384  0000 ????
    385  0000 ????				      MAC	ldy@ram
    386  0000 ????				      ldy	{0}
    387  0000 ????				      ENDM		;{}
    388  0000 ????
    389  0000 ????
    390  0000 ????				      MAC	lda@ply
    391  0000 ????				      lda	{0}
    392  0000 ????				      ENDM		;{}
    393  0000 ????
    394  0000 ????				      MAC	ldx@ply
    395  0000 ????				      ldx	{0}
    396  0000 ????				      ENDM		;{}
    397  0000 ????
    398  0000 ????				      MAC	ldy@ply
    399  0000 ????				      ldy	{0}
    400  0000 ????				      ENDM		;{}
    401  0000 ????
    402  0000 ????
    403  0000 ????				      MAC	adc@ply
    404  0000 ????				      adc	{0}
    405  0000 ????				      ENDM		;{}
    406  0000 ????
    407  0000 ????				      MAC	sbc@ply
    408  0000 ????				      sbc	{0}
    409  0000 ????				      ENDM		;{}
    410  0000 ????
    411  0000 ????				      MAC	cmp@ply
    412  0000 ????				      cmp	{0}
    413  0000 ????				      ENDM		;{}
    414  0000 ????
    415  0000 ????						;---------------------------------------------------------------------------------------------------
    416  0000 ????
    417  0000 ????				      MAC	newrambank
    418  0000 ????						; {1}	     bank name
    419  0000 ????						; {2}	     RAM bank number
    420  0000 ????
    421  0000 ????				      SEG.U	{1}
    422  0000 ????				      ORG	ORIGIN_RAM
    423  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    424  0000 ????			   _BANK_START SET	*
    425  0000 ????			   RAMBANK_{1} SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
    426  0000 ????			   _CURRENT_RAMBANK SET	RAMBANK_{1}
    427  0000 ????			   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    428  0000 ????				      ENDM		; bank name
    429  0000 ????
    430  0000 ????						;---------------------------------------------------------------------------------------------------
    431  0000 ????
    432  0000 ????				      MAC	resync
    433  0000 ????						; resync screen, X and Y == 0 afterwards
    434  0000 ????				      lda	#%10	; make sure VBLANK is ON
    435  0000 ????				      sta	VBLANK
    436  0000 ????
    437  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    438  0000 ????			   .loopResync
    439  0000 ????				      VERTICAL_SYNC
    440  0000 ????
    441  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    442  0000 ????				      lda	Platform
    443  0000 ????				      eor	#PAL_50	; PAL-50?
    444  0000 ????				      bne	.ntsc
    445  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    446  0000 ????			   .ntsc
    447  0000 ????			   .loopWait
    448  0000 ????				      sta	WSYNC
    449  0000 ????				      sta	WSYNC
    450  0000 ????				      dey
    451  0000 ????				      bne	.loopWait
    452  0000 ????				      dex
    453  0000 ????				      bne	.loopResync
    454  0000 ????				      ENDM
    455  0000 ????
    456  0000 ????				      MAC	set_platform
    457  0000 ????						; 00 = NTSC
    458  0000 ????						; 01 = NTSC
    459  0000 ????						; 10 = PAL-50
    460  0000 ????						; 11 = PAL-60
    461  0000 ????				      lda	SWCHB
    462  0000 ????				      rol
    463  0000 ????				      rol
    464  0000 ????				      rol
    465  0000 ????				      and	#%11
    466  0000 ????				      eor	#PAL
    467  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    468  0000 ????				      ENDM
    469  0000 ????
    470  0000 ????
    471  0000 ????						;---------------------------------------------------------------------------------------------------
    472  0000 ????
    473  0000 ????						;    MAC JSROM_SAFE ; {routine}
    474  0000 ????						;    ; Saves bank of routine to variable for later restore.
    475  0000 ????						;    ; Switches to the bank and does a JSR to the routine.
    476  0000 ????
    477  0000 ????						;		  lda #BANK_{1}
    478  0000 ????						;		  sta savedBank
    479  0000 ????						;		  sta SET_BANK
    480  0000 ????						;		  jsr {1}
    481  0000 ????						;    ENDM
    482  0000 ????
    483  0000 ????
    484  0000 ????						;    MAC JSROM ; {routine}
    485  0000 ????
    486  0000 ????						;		  lda #BANK_{1}
    487  0000 ????						;		  sta SET_BANK
    488  0000 ????						;		  jsr {1}
    489  0000 ????						;    ENDM
    490  0000 ????
    491  0000 ????
    492  0000 ????						;    MAC JSRAM
    493  0000 ????						;		  lda #BANK_{1}
    494  0000 ????						;		  sta SET_BANK_RAM
    495  0000 ????						;		  jsr {1}
    496  0000 ????						;    ENDM
    497  0000 ????
    498  0000 ????
    499  0000 ????
    500  0000 ????				      MAC	timecheck
    501  0000 ????				      lda	INTIM
    502  0000 ????				      cmp	#SPEEDOF_{1}
    503  0000 ????				      bcc	{2}
    504  0000 ????				      ENDM		; {ident}, {branch if out of time}
    505  0000 ????
    506  0000 ????
    507  0000 ????				      MAC	timing
    508  0000 ????			   SPEEDOF_{1} =	({2}/64) + 1
    509  0000 ????				      ENDM		; {label}, {cycles}
    510  0000 ????
    511  0000 ????
    512  0000 ????						;---------------------------------------------------------------------------------------------------
    513  0000 ????
    514  0000 ????						; Failsafe call of function in another bank
    515  0000 ????						; This will check the slot #s for current, call to make sure they're not the same!
    516  0000 ????
    517  0000 ????				      MAC	call
    518  0000 ????				      IF	SLOT_{1} == _BANK_SLOT
    519  0000 ????				      ECHO	"ERROR: Incompatible call to function requiring same slot..."
    520  0000 ????				      ECHO	"Cannot switch bank in use for", {0}
    521  0000 ????				      ERR
    522  0000 ????				      ENDIF
    523  0000 ????				      lda	#BANK_{1}
    524  0000 ????				      sta	SET_BANK
    525  0000 ????				      jsr	{1}
    526  0000 ????				      ENDM		; function name
    527  0000 ????
    528  0000 ????
    529  0000 ????
    530  0000 ????						;---------------------------------------------------------------------------------------------------
    531  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						; Chess
      2  0000 ????						; Atari 2600 Chess display system
      3  0000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  0000 ????						; andrew@taswegian.com
      5  0000 ????
      6 U00fa ????				      SEG.U	variables
      7 U0080					      ORG	$80
      8 U0080
      9 U0080		       00	   squareToDraw ds	1
     10 U0081		       00	   rnd	      ds	1	; random
     11 U0082		       00	   drawDelay  ds	1
     12 U0083		       00	   lastSquareX12 ds	1
     13 U0084
     14 U0084		       00	   drawCount  ds	1
     15 U0085		       00	   fromX12    ds	1
     16 U0086		       00	   toX12      ds	1
     17 U0087		       00	   originX12  ds	1
     18 U0088
     19 U0088		       00	   cursorX12  ds	1
     20 U0089
     21 U0089		       00	   mdelay     ds	1
     22 U008a		       00	   ccur       ds	1
     23 U008b		       00	   savedBank  ds	1	; switched-in bank for FIXED returns
     24 U008c		       00	   aiState    ds	1	; state
     25 U008d		       00	   aiFlashDelay ds	1
     26 U008e
     27 U008e		       00	   aiMoveIndex ds	1
     28 U008f
     29 U008f		       00	   aiFlashPhase ds	1
     30 U0090
     31 U0090		       00 00	   Evaluation ds	2	; tracks value of the board position
     32 U0092
     33 U0092		       00	   currentPiece ds	1
     34 U0093		       00	   currentSquare ds	1
     35 U0094		       00	   enPassantPawn ds	1	; TODO - this belongs in PLY bank
     36 U0095		       00	   currentPly ds	1
     37 U0096
     38 U0096		       00	   sideToMove ds	1	; d7 == side, 0=white, 128 = black
     39 U0097		       00	   fromPiece  ds	1
     40 U0098		       00	   lastPiece  ds	1
     41 U0099		       00	   previousPiece ds	1
     42 U009a
     43 U009a		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     44 U009b		       00 00	   speech_addr ds	2
     45 U009d		       00	   bg	      ds	1
     46 U009e
     47 U009e		       00	   capture    ds	1
     48 U009f
     49 U009f				  -	      IF	DIAGNOSTICS
     50 U009f				  -positionCount ds	3
     51 U009f					      ENDIF
     52 U009f
     53 U009f							;maxPly			  ds 1
     54 U009f		       00	   flagCheck  ds	1	; -1 = no, #KING = yes
     55 U00a0		       00	   protecting ds	1
     56 U00a1		       00	   randomness ds	1
------- FILE ./chess.asm
------- FILE overlays.asm LEVEL 2 PASS 4
      0 U00a2					      include	"overlays.asm"
      1 U00a2							; Chess
      2 U00a2							; Atari 2600 Chess display system
      3 U00a2							; Copyright (c) 2019-2020 Andrew Davie
      4 U00a2							; andrew@taswegian.com
      5 U00a2
      6 U00a2							;---------------------------------------------------------------------------------------------------
      7 U00a2							; OVERLAYS!
      8 U00a2							; These variables are overlays, and should be managed with care
      9 U00a2							; They co-exist (each "OVERLAY" starts at the zero-page variable "Overlay"
     10 U00a2							; and thus, overlays cannot be used at the same time (that is, you cannot
     11 U00a2							; use a variable in overlay #1 while at the same time using a variable in
     12 U00a2							; overlay #2
     13 U00a2
     14 U00a2							; for clarity, prefix ALL overlay variables with double-underscore (__)
     15 U00a2
     16 U00a2							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
     17 U00a2							; ensure this by using the VALIDATE_OVERLAY macro
     18 U00a2							;---------------------------------------------------------------------------------------------------
     19 U00a2
     20 U00a2					      MAC	overlay
     21 U00a2				   OVERLAY_NAME SET	{1}
     22 U00a2					      SEG.U	OVERLAY_{1}
     23 U00a2					      org	Overlay
     24 U00a2					      ENDM		; {name}
     25 U00a2
     26 U00a2							;---------------------------------------------------------------------------------------------------
     27 U00a2
     28 U00a2					      MAC	validate_overlay
     29 U00a2					      LIST	OFF
     30 U00a2				   OVERLAY_DELTA SET	* - Overlay
     31 U00a2					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
     32 U00a2				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
     33 U00a2					      ENDIF
     34 U00a2					      IF	OVERLAY_DELTA > OVERLAY_SIZE
     35 U00a2					      ECHO	"Overlay", OVERLAY_NAME, "is too big!"
     36 U00a2					      ECHO	"REQUIRED SIZE =", OVERLAY_DELTA
     37 U00a2					      ERR
     38 U00a2					      ENDIF
     39 U00a2					      LIST	ON
     40 U00a2					      ECHO	OVERLAY_NAME, "-", OVERLAY_SIZE - ( * - Overlay ), "bytes available"
     41 U00a2					      ENDM
     42 U00a2
     43 U00a2							;---------------------------------------------------------------------------------------------------
     44 U00a2
     45 U00a2				   OVERLAY_SIZE SET	$4C	; maximum size
     46 U00a2				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	0
     47 U00a2
     48 U00a2
     49 U00a2							; This overlay variable is used for the overlay variables.  That's OK.
     50 U00a2							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
     51 U00a2							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
     52 U00a2							; (especially the latter ones) are only used in rare occasions.
     53 U00a2
     54 U00a2							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
     55 U00a2							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
     56 U00a2
      0 U00a2					      DEF	Overlay
      1 U00a2				   SLOT_Overlay SET	_BANK_SLOT
      2 U00a2				   BANK_Overlay SET	SLOT_Overlay + _CURRENT_BANK
      3 U00a2				   Overlay
      4 U00a2				   TEMPORARY_VAR SET	Overlay
      5 U00a2				   TEMPORARY_OFFSET SET	0
      6 U00a2				   VAR_BOUNDARY_Overlay SET	TEMPORARY_OFFSET
      7 U00a2				   FUNCTION_NAME SET	Overlay
     58 U00a2		       00 00 00 00*	      ds	OVERLAY_SIZE	;--> overlay (share) variables
     59 U00ee				   END_OF_OVERLAY
     60 U00ee
     61 U00ee							;---------------------------------------------------------------------------------------------------
     62 U00ee							; And now... the overlays....
     63 U00ee
 ---- OVERLAYS ( $4c bytes ) ----
     64 U00ee					      ECHO	"---- OVERLAYS (", OVERLAY_SIZE, "bytes ) ----"
     65 U00ee
     66 U00ee							;---------------------------------------------------------------------------------------------------
     67 U00ee
     68 U00ee							; Some overlays are used across multiple routines/calls, and they will need to be defined
     69 U00ee							; "globally" in this file.
     70 U00ee
      0 U00ee					      VAR	__pieceShapeBuffer, PIECE_SHAPE_SIZE
      1 U00ee		       00 a2	   __pieceShapeBuffer =	TEMPORARY_VAR
      2 U00ee				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + PIECE_SHAPE_SIZE
      3 U00ee
      4 U00ee				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00ee					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00ee				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00ee					      ENDIF
      8 U00ee				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00ee				  -	      ECHO	"Temporary Variable", __pieceShapeBuffer, "overflow!"
     10 U00ee				  -	      ERR
     11 U00ee					      ENDIF
     12 U00ee					      LIST	ON
      0 U00ee					      VAR	__ptr, 2
      1 U00ee		       00 ea	   __ptr      =	TEMPORARY_VAR
      2 U00ee				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3 U00ee
      4 U00ee				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00ee					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00ee				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00ee					      ENDIF
      8 U00ee				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00ee				  -	      ECHO	"Temporary Variable", __ptr, "overflow!"
     10 U00ee				  -	      ERR
     11 U00ee					      ENDIF
     12 U00ee					      LIST	ON
      0 U00ee					      VAR	__ptr2, 2
      1 U00ee		       00 ec	   __ptr2     =	TEMPORARY_VAR
      2 U00ee				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3 U00ee
      4 U00ee				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00ee					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00ee				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00ee					      ENDIF
      8 U00ee				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00ee				  -	      ECHO	"Temporary Variable", __ptr2, "overflow!"
     10 U00ee				  -	      ERR
     11 U00ee					      ENDIF
     12 U00ee					      LIST	ON
     74 U00ee
     75 U00ee							;---------------------------------------------------------------------------------------------------
     76 U00ee
     77 U00ee
     78 U00ee					      ORG	END_OF_OVERLAY
 ---- END OF OVERLAYS ----
     79 U00ee					      ECHO	"---- END OF OVERLAYS ----"
 MAXIMUM OVERLAY SIZE NEEDED =  $4c
     80 U00ee					      ECHO	"MAXIMUM OVERLAY SIZE NEEDED = ", MAXIMUM_REQUIRED_OVERLAY_SIZE
     81 U00ee
     82 U00ee							;EOF
------- FILE ./chess.asm
------- FILE stack.asm LEVEL 2 PASS 4
      0 U00ee					      include	"stack.asm"
      1 U00ee							; Chess
      2 U00ee							; Atari 2600 Chess display system
      3 U00ee							; Copyright (c) 2019-2020 Andrew Davie
      4 U00ee							; andrew@taswegian.com
      5 U00ee
      6 U00ee
      7 U00ee		       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
      8 U00ee
      9 U00ee		       00 00 00 00*	      ds	RESERVED_FOR_STACK
     10 U00fa
     11 U00fa							; WARNING/NOTE - the alphabeta search violates the above size constraints
     12 U00fa							; HOWEVER, the "OVERLAY" segment is beneath this, and will be stomped, depending on # plys
     13 U00fa							;  but since overlay is not generally stressed during alphabeta, we're good.
------- FILE ./chess.asm
    535 U00fa
 FREE BYTES IN ZERO PAGE =  $5
    536 U00fa					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    537 U00fa				  -	      IF	* > $FF
    538 U00fa				  -	      ERR	"Zero Page overflow!"
    539 U00fa					      ENDIF
    540 U00fa
    541 U00fa							;------------------------------------------------------------------------------
    542 U00fa							;##############################################################################
    543 U00fa							;------------------------------------------------------------------------------
    544 U00fa
    545 U00fa							; NOW THE VERY INTERESTING '3E' RAM BANKS
    546 U00fa							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 512 bytes TOTAL ACCESSIBLE
    547 U00fa							; IN A 1K MEMORY SPACE
    548 U00fa
      0 U00fa					      SLOT	0
      1 U00fa				  -	      IF	(0 < 0) || (0 > 3)
      2 U00fa				  -	      ECHO	"Illegal bank address/segment location", 0
      3 U00fa				  -	      ERR
      4 U00fa					      ENDIF
      5 U00fa				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      6 U00fa				   _BANK_SLOT SET	0 * 64
      0 U00fa					      NEWRAMBANK	CHESS_BOARD_ROW
      1 U00fa
      2 U00fa
      3 U00fa
      4 U0000 ????				      SEG.U	CHESS_BOARD_ROW
      5 U0000					      ORG	ORIGIN_RAM
      6 U0000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0000				   _BANK_START SET	*
      8 U0000				   RAMBANK_CHESS_BOARD_ROW SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0000				   _CURRENT_RAMBANK SET	RAMBANK_CHESS_BOARD_ROW
     10 U0000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U0000					      REPEAT	(CHESSBOARD_ROWS) - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U0000
      2 U0000
      3 U0000
      4 U0e00 ????				      SEG.U	.DUMMY
      5 U0200					      ORG	ORIGIN_RAM
      6 U0200					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0200				   _BANK_START SET	*
      8 U0200				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0200				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0200				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U0200					      REPEND
      0 U0200					      NEWRAMBANK	.DUMMY
      1 U0200
      2 U0200
      3 U0200
      4 U0200					      SEG.U	.DUMMY
      5 U0400					      ORG	ORIGIN_RAM
      6 U0400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0400				   _BANK_START SET	*
      8 U0400				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400
      2 U0400
      3 U0400
      4 U0400					      SEG.U	.DUMMY
      5 U0600					      ORG	ORIGIN_RAM
      6 U0600					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0600				   _BANK_START SET	*
      8 U0600				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0600				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0600				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U0600					      REPEND
      0 U0600					      NEWRAMBANK	.DUMMY
      1 U0600
      2 U0600
      3 U0600
      4 U0600					      SEG.U	.DUMMY
      5 U0800					      ORG	ORIGIN_RAM
      6 U0800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0800				   _BANK_START SET	*
      8 U0800				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800
      2 U0800
      3 U0800
      4 U0800					      SEG.U	.DUMMY
      5 U0a00					      ORG	ORIGIN_RAM
      6 U0a00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0a00				   _BANK_START SET	*
      8 U0a00				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0a00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0a00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U0a00					      REPEND
      0 U0a00					      NEWRAMBANK	.DUMMY
      1 U0a00
      2 U0a00
      3 U0a00
      4 U0a00					      SEG.U	.DUMMY
      5 U0c00					      ORG	ORIGIN_RAM
      6 U0c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0c00				   _BANK_START SET	*
      8 U0c00				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00
      2 U0c00
      3 U0c00
      4 U0c00					      SEG.U	.DUMMY
      5 U0e00					      ORG	ORIGIN_RAM
      6 U0e00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0e00				   _BANK_START SET	*
      8 U0e00				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0e00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0e00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    553 U0e00					      REPEND
    554 U0e00
    555 U0e00							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    556 U0e00							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    557 U0e00							; The variable definitions are also in that ROM bank (even though they're RAM :)
    558 U0e00
    559 U0e00							; Now we have the actual graphics data for each of the rows.  This consists of an
    560 U0e00							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    561 U0e00							; character shapes are masked/copied. The depth of the character shapes may be
    562 U0e00							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    563 U0e00							; a multiple of 3, so that the RGB scanlines match at character joins.
    564 U0e00
    565 U0e00							; We have one bank for each chessboard row.  These banks are duplicates of the above,
    566 U0e00							; accessed via the above labels but with the appropriate bank switched in.
    567 U0e00
    568 U0e00							;---------------------------------------------------------------------------------------------------
    569 U0e00
    570 U0e00
    571 U0e00		       00 fe	   RND_EOR_VAL =	$FE	;B4
    572 U0e00
    573 U0e00					      MAC	next_random
    574 U0e00					      lda	rnd
    575 U0e00					      lsr
    576 U0e00					      bcc	.skipEOR
    577 U0e00					      eor	#RND_EOR_VAL
    578 U0e00				   .skipEOR   sta	rnd
    579 U0e00					      ENDM
    580 U0e00
    581 U0e00							;--------------------------------------------------------------------------------
    582 U0e00
    583 U0e00					      MAC	phase
    584 U0e00					      lda	#{1}
    585 U0e00					      sta	aiState
    586 U0e00					      ENDM		;#
    587 U0e00
    588 U0e00
    589 U0e00							;--------------------------------------------------------------------------------
    590 U0e00
    591 U0e00					      MAC	common_vars_alphabeta
    592 U0e00
    593 U0e00					      VAR	__thinkbar, 1
    594 U0e00					      VAR	__toggle, 1
    595 U0e00
    596 U0e00					      VAR	__bestMove, 1
    597 U0e00					      VAR	__alpha, 2
    598 U0e00					      VAR	__beta, 2
    599 U0e00					      VAR	__negaMax, 2
    600 U0e00					      VAR	__value, 2
    601 U0e00
    602 U0e00					      VAR	__quiesceCapOnly, 1
    603 U0e00
    604 U0e00					      ENDM
    605 U0e00
    606 U0e00
    607 U0e00							;--------------------------------------------------------------------------------
    608 U0e00
------- FILE BANK_FIRST@0.asm LEVEL 2 PASS 4
      0 U0e00					      include	"BANK_FIRST@0.asm"	; MUST be first in ROM - contains reset vectors
      1 U0e00							; Chess
      2 U0e00							; Copyright (c) 2019-2020 Andrew Davie
      3 U0e00							; andrew@taswegian.com
      4 U0e00
      5 U0e00
      6 U0e00							; SLOT0 - screen draw, state machine dispatcher
      7 U0e00							; SLOT1 - anything
      8 U0e00							; SLOT2 - moves/ply
      9 U0e00							; SLOT3 - board
     10 U0e00
     11 U0e00
     12 U0e00
     13 U0e00
     14 U0e00
     15 U0e00
      0 U0e00					      SLOT	0
      1 U0e00				  -	      IF	(0 < 0) || (0 > 3)
      2 U0e00				  -	      ECHO	"Illegal bank address/segment location", 0
      3 U0e00				  -	      ERR
      4 U0e00					      ENDIF
      5 U0e00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      6 U0e00				   _BANK_SLOT SET	0 * 64
     17 U0e00
     18 U0e00							;---------------------------------------------------------------------------------------------------
     19 U0e00							;#########################################  FIXED BANK  ############################################
     20 U0e00							;---------------------------------------------------------------------------------------------------
     21 U0e00
     22 U0e00				   _ORIGIN    SET	_FIRST_BANK
     23 U0e00
      0 U0e00					      NEWBANK	THE_FIRST_BANK
      1  0153 ????				      SEG	THE_FIRST_BANK
      2  0000					      ORG	_ORIGIN
      3  0000					      RORG	_BANK_ADDRESS_ORIGIN
      4  0000				   _BANK_START SET	*
      5  0000				   THE_FIRST_BANK_START SET	*
      6  0000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0000				   THE_FIRST_BANK SET	_BANK_SLOT + _CURRENT_BANK
      8  0000				   _ORIGIN    SET	_ORIGIN + 1024
     25  0000					      RORG	$f000
     26  0000
     27  0000							;---------------------------------------------------------------------------------------------------
     28  0000
      0  0000					      DEF	StartupBankReset
      1  0000				   SLOT_StartupBankReset SET	_BANK_SLOT
      2  0000				   BANK_StartupBankReset SET	SLOT_StartupBankReset + _CURRENT_BANK
      3  0000				   StartupBankReset
      4  0000				   TEMPORARY_VAR SET	Overlay
      5  0000				   TEMPORARY_OFFSET SET	0
      6  0000				   VAR_BOUNDARY_StartupBankReset SET	TEMPORARY_OFFSET
      7  0000				   FUNCTION_NAME SET	StartupBankReset
     30  0000					      SUBROUTINE
     31  0000
      0  0000					      VEND	StartupBankReset
      1  0000				  -	      IFNCONST	StartupBankReset
      2  0000				  -	      ECHO	"Incorrect VEND label", StartupBankReset
      3  0000				  -	      ERR
      4  0000					      ENDIF
      5  0000		       00 a2	   VAREND_StartupBankReset =	TEMPORARY_VAR
     33  0000
     34  0000							; On startup, 3E+ switches banks 0 and 3 to the 1st ROM bank (1K), from which the reset
     35  0000							; vector is obtained from bank 0 (+$FFC). Chess3E+ (maybe) will leave this bank (3) alone
     36  0000							; so that a system reset will always have the reset vectors available at FFFC, where expected
     37  0000
     38  0000		       a2 ff		      ldx	#$FF
     39  0002		       9a		      txs
     40  0003
     41  0003
     42  0003							;		      ldx #0
     43  0003							;joy		      cpx #0
     44  0003							;		      beq joy
     45  0003
      0  0003					      CALL	CartInit
      1  0003				  -	      IF	SLOT_CartInit == _BANK_SLOT
      2  0003				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0003				  -	      ECHO	"Cannot switch bank in use for", CartInit
      4  0003				  -	      ERR
      5  0003					      ENDIF
      6  0003		       a9 41		      lda	#BANK_CartInit
      7  0005		       85 3f		      sta	SET_BANK
      8  0007		       20 00 f4 	      jsr	CartInit
      0  000a					      CALL	SetupBanks
      1  000a				  -	      IF	SLOT_SetupBanks == _BANK_SLOT
      2  000a				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  000a				  -	      ECHO	"Cannot switch bank in use for", SetupBanks
      4  000a				  -	      ERR
      5  000a					      ENDIF
      6  000a		       a9 41		      lda	#BANK_SetupBanks
      7  000c		       85 3f		      sta	SET_BANK
      8  000e		       20 3a f4 	      jsr	SetupBanks
      0  0011					      CALL	InitialisePieceSquares
      1  0011				  -	      IF	SLOT_InitialisePieceSquares == _BANK_SLOT
      2  0011				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0011				  -	      ECHO	"Cannot switch bank in use for", InitialisePieceSquares
      4  0011				  -	      ERR
      5  0011					      ENDIF
      6  0011		       a9 41		      lda	#BANK_InitialisePieceSquares
      7  0013		       85 3f		      sta	SET_BANK
      8  0015		       20 cb f4 	      jsr	InitialisePieceSquares
     49  0018
     50  0018							;CALL ListPlayerMoves
     51  0018
     52  0018
     53  0018				   .StartFrame
     54  0018
     55  0018
     56  0018							; START OF FRAME
     57  0018
     58  0018		       a9 0e		      lda	#%1110	; VSYNC ON
     59  001a		       85 42	   .loopVSync3 sta	WSYNC
     60  001c		       85 40		      sta	VSYNC
     61  001e		       4a		      lsr
     62  001f		       d0 f9		      bne	.loopVSync3	; branch until VYSNC has been reset
     63  0021
     64  0021		       85 41		      sta	VBLANK
     65  0023
     66  0023		       a0 2e		      ldy	#TIME_PART_1
     67  0025		       8c 96 02 	      sty	TIM64T
     68  0028
     69  0028							; LOTS OF PROCESSING TIME - USE IT
     70  0028
     71  0028
     72  0028
     73  0028		       20 3d f1 	      jsr	AiStateMachine
     74  002b
     75  002b				  -	      IF	ASSERTS
     76  002b				  -			; Catch timer expired already
     77  002b				  -			;		      bit TIMINT
     78  002b				  -			;.whoops	      bmi .whoops
     79  002b					      ENDIF
     80  002b
     81  002b
     82  002b		       2c 85 02    .wait      bit	TIMINT
     83  002e		       10 fb		      bpl	.wait
     84  0030
     85  0030
     86  0030							; START OF VISIBLE SCANLINES
     87  0030
     88  0030
      0  0030					      CALL	longD
      1  0030				  -	      IF	SLOT_longD == _BANK_SLOT
      2  0030				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0030				  -	      ECHO	"Cannot switch bank in use for", longD
      4  0030				  -	      ERR
      5  0030					      ENDIF
      6  0030		       a9 94		      lda	#BANK_longD
      7  0032		       85 3f		      sta	SET_BANK
      8  0034		       20 14 f8 	      jsr	longD
     90  0037
     91  0037
     92  0037		       a2 80		      ldx	#SLOT_DrawRow	; + BANK_DrawRow
     93  0039		       86 3e		      stx	SET_BANK_RAM
     94  003b		       20 03 f9 	      jsr	DrawRow	; draw the ENTIRE visible screen!
     95  003e
      0  003e					      CALL	tidySc
      1  003e				  -	      IF	SLOT_tidySc == _BANK_SLOT
      2  003e				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  003e				  -	      ECHO	"Cannot switch bank in use for", tidySc
      4  003e				  -	      ERR
      5  003e					      ENDIF
      6  003e		       a9 94		      lda	#BANK_tidySc
      7  0040		       85 3f		      sta	SET_BANK
      8  0042		       20 00 f8 	      jsr	tidySc
     97  0045
     98  0045		       20 3d f1 	      jsr	AiStateMachine
     99  0048
    100  0048		       ad 84 02 	      lda	INTIM
    101  004b		       c9 14		      cmp	#20
    102  004d		       90 07		      bcc	.notnow
    103  004f
    104  004f							;CALL GameSpeak
      0  004f					      CALL	PositionSprites
      1  004f				  -	      IF	SLOT_PositionSprites == _BANK_SLOT
      2  004f				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  004f				  -	      ECHO	"Cannot switch bank in use for", PositionSprites
      4  004f				  -	      ERR
      5  004f					      ENDIF
      6  004f		       a9 49		      lda	#BANK_PositionSprites
      7  0051		       85 3f		      sta	SET_BANK
      8  0053		       20 00 f5 	      jsr	PositionSprites
    106  0056
    107  0056
    108  0056				  -	      IF	0
    109  0056				  -			; "draw" sprite shapes into row banks
    110  0056				  -
    111  0056				  -	      ldx	#SLOT_DrawRow + 7
    112  0056				  -zapem      stx	SET_BANK_RAM
    113  0056				  -	      jsr	WriteBlank
    114  0056				  -	      dex
    115  0056				  -	      bpl	zapem
    116  0056				  -
    117  0056				  -	      jsr	WriteCursor
    118  0056					      ENDIF
    119  0056
    120  0056				   .notnow
    121  0056
    122  0056		       2c 85 02    .waitTime  bit	TIMINT
    123  0059		       10 fb		      bpl	.waitTime
    124  005b
    125  005b		       4c 18 f0 	      jmp	.StartFrame
    126  005e
    127  005e
    128  005e							;---------------------------------------------------------------------------------------------------
    129  005e
      0  005e					      DEF	ThinkBar
      1  005e				   SLOT_ThinkBar SET	_BANK_SLOT
      2  005e				   BANK_ThinkBar SET	SLOT_ThinkBar + _CURRENT_BANK
      3  005e				   ThinkBar
      4  005e				   TEMPORARY_VAR SET	Overlay
      5  005e				   TEMPORARY_OFFSET SET	0
      6  005e				   VAR_BOUNDARY_ThinkBar SET	TEMPORARY_OFFSET
      7  005e				   FUNCTION_NAME SET	ThinkBar
    131  005e					      SUBROUTINE
    132  005e
    133  005e				  -	      IF	DIAGNOSTICS
    134  005e				  -
    135  005e				  -	      inc	positionCount
    136  005e				  -	      bne	.p1
    137  005e				  -	      inc	positionCount+1
    138  005e				  -	      bne	.p1
    139  005e				  -	      inc	positionCount+2
    140  005e				  -.p1
    141  005e					      ENDIF
    142  005e
    143  005e							; The 'thinkbar' pattern...
    144  005e
    145  005e		       a9 00		      lda	#0
    146  0060		       a4 4c		      ldy	INPT4
    147  0062		       30 0a		      bmi	.doThink
    148  0064
    149  0064		       e6 a2		      inc	__thinkbar
    150  0066		       a5 a2		      lda	__thinkbar
    151  0068		       29 0f		      and	#15
    152  006a		       a8		      tay
    153  006b		       b9 73 f0 	      lda	SynapsePattern,y
    154  006e
    155  006e		       85 4f	   .doThink   sta	PF2
    156  0070		       85 4e		      sta	PF1
    157  0072		       60		      rts
    158  0073
    159  0073
    160  0073
    161  0073				   SynapsePattern
    162  0073
    163  0073		       c1		      .byte.b	%11000001
    164  0074		       60		      .byte.b	%01100000
    165  0075		       30		      .byte.b	%00110000
    166  0076		       18		      .byte.b	%00011000
    167  0077		       0c		      .byte.b	%00001100
    168  0078		       06		      .byte.b	%00000110
    169  0079		       83		      .byte.b	%10000011
    170  007a		       c1		      .byte.b	%11000001
    171  007b
    172  007b		       83		      .byte.b	%10000011
    173  007c		       06		      .byte.b	%00000110
    174  007d		       0c		      .byte.b	%00001100
    175  007e		       18		      .byte.b	%00011000
    176  007f		       30		      .byte.b	%00110000
    177  0080		       60		      .byte.b	%01100000
    178  0081		       c1		      .byte.b	%11000001
    179  0082		       83		      .byte.b	%10000011
    180  0083
    181  0083
    182  0083							;---------------------------------------------------------------------------------------------------
    183  0083
      0  0083					      DEF	CopySinglePiece	;@0 - uses @2
      1  0083				   SLOT_CopySinglePiece SET	_BANK_SLOT
      2  0083				   BANK_CopySinglePiece SET	SLOT_CopySinglePiece + _CURRENT_BANK
      3  0083				   CopySinglePiece
      4  0083				   TEMPORARY_VAR SET	Overlay
      5  0083				   TEMPORARY_OFFSET SET	0
      6  0083				   VAR_BOUNDARY_CopySinglePiece SET	TEMPORARY_OFFSET
      7  0083				   FUNCTION_NAME SET	CopySinglePiece
    185  0083					      SUBROUTINE
      0  0083					      TIMING	COPYSINGLEPIECE, (2600)
      1  0083		       00 29	   SPEEDOF_COPYSINGLEPIECE =	((2600)/64) + 1
    187  0083
      0  0083					      REFER	aiDrawEntireBoard
      1  0083				  -	      IF	VAREND_aiDrawEntireBoard > TEMPORARY_VAR
      2  0083				  -TEMPORARY_VAR SET	VAREND_aiDrawEntireBoard
      3  0083					      ENDIF
      0  0083					      REFER	aiSpecialMoveFixup
      1  0083					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  0083				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  0083					      ENDIF
      0  0083					      REFER	aiWriteStartPieceBlank
      1  0083				  -	      IF	VAREND_aiWriteStartPieceBlank > TEMPORARY_VAR
      2  0083				  -TEMPORARY_VAR SET	VAREND_aiWriteStartPieceBlank
      3  0083					      ENDIF
      0  0083					      REFER	aiDrawPart2
      1  0083				  -	      IF	VAREND_aiDrawPart2 > TEMPORARY_VAR
      2  0083				  -TEMPORARY_VAR SET	VAREND_aiDrawPart2
      3  0083					      ENDIF
      0  0083					      REFER	aiMarchB
      1  0083				  -	      IF	VAREND_aiMarchB > TEMPORARY_VAR
      2  0083				  -TEMPORARY_VAR SET	VAREND_aiMarchB
      3  0083					      ENDIF
      0  0083					      REFER	aiFinalFlash
      1  0083				  -	      IF	VAREND_aiFinalFlash > TEMPORARY_VAR
      2  0083				  -TEMPORARY_VAR SET	VAREND_aiFinalFlash
      3  0083					      ENDIF
      0  0083					      REFER	UNSAFE_showMoveCaptures
      1  0083				  -	      IF	VAREND_UNSAFE_showMoveCaptures > TEMPORARY_VAR
      2  0083				  -TEMPORARY_VAR SET	VAREND_UNSAFE_showMoveCaptures
      3  0083					      ENDIF
      0  0083					      REFER	aiMarchToTargetA
      1  0083				  -	      IF	VAREND_aiMarchToTargetA > TEMPORARY_VAR
      2  0083				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetA
      3  0083					      ENDIF
      0  0083					      REFER	aiMarchB2
      1  0083				  -	      IF	VAREND_aiMarchB2 > TEMPORARY_VAR
      2  0083				  -TEMPORARY_VAR SET	VAREND_aiMarchB2
      3  0083					      ENDIF
      0  0083					      REFER	aiMarchToTargetB
      1  0083				  -	      IF	VAREND_aiMarchToTargetB > TEMPORARY_VAR
      2  0083				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetB
      3  0083					      ENDIF
      0  0083					      REFER	aiSelectDestinationSquare
      1  0083				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  0083				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  0083					      ENDIF
      0  0083					      REFER	aiPromotePawnStart
      1  0083				  -	      IF	VAREND_aiPromotePawnStart > TEMPORARY_VAR
      2  0083				  -TEMPORARY_VAR SET	VAREND_aiPromotePawnStart
      3  0083					      ENDIF
      0  0083					      REFER	aiChoosePromotePiece
      1  0083				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  0083				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  0083					      ENDIF
      0  0083					      VEND	CopySinglePiece
      1  0083				  -	      IFNCONST	CopySinglePiece
      2  0083				  -	      ECHO	"Incorrect VEND label", CopySinglePiece
      3  0083				  -	      ERR
      4  0083					      ENDIF
      5  0083		       00 ae	   VAREND_CopySinglePiece =	TEMPORARY_VAR
    202  0083
    203  0083							; WARNING: CANNOT USE VAR/OVERLAY IN ANY ROUTINE CALLING THIS!!
    204  0083							; ALSO CAN'T USE IN THIS ROUTINE
    205  0083							; This routine will STOMP on those vars due to __pieceShapeBuffer occupying whole overlay
    206  0083							; @2150 max
    207  0083							; = 33 TIM64T
    208  0083
    209  0083							; Board is [SLOT3]
    210  0083
    211  0083
      0  0083					      CALL	CopySetup	;@2
      1  0083				  -	      IF	SLOT_CopySetup == _BANK_SLOT
      2  0083				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0083				  -	      ECHO	"Cannot switch bank in use for", CopySetup
      4  0083				  -	      ERR
      5  0083					      ENDIF
      6  0083		       a9 94		      lda	#BANK_CopySetup
      7  0085		       85 3f		      sta	SET_BANK
      8  0087		       20 54 f8 	      jsr	CopySetup
    213  008a
    214  008a
      0  008a					      DEF	InterceptMarkerCopy
      1  008a				   SLOT_InterceptMarkerCopy SET	_BANK_SLOT
      2  008a				   BANK_InterceptMarkerCopy SET	SLOT_InterceptMarkerCopy + _CURRENT_BANK
      3  008a				   InterceptMarkerCopy
      4  008a				   TEMPORARY_VAR SET	Overlay
      5  008a				   TEMPORARY_OFFSET SET	0
      6  008a				   VAR_BOUNDARY_InterceptMarkerCopy SET	TEMPORARY_OFFSET
      7  008a				   FUNCTION_NAME SET	InterceptMarkerCopy
    216  008a					      SUBROUTINE
    217  008a
    218  008a
    219  008a							; Copy a piece shape (3 PF bytes wide x 24 lines) to the RAM buffer
    220  008a							; y = piece index
    221  008a
    222  008a		       a9 94		      lda	#BANK_PIECE_VECTOR_BANK
    223  008c		       85 3f		      sta	SET_BANK	;@2
    224  008e
    225  008e		       b9 9f f8 	      lda	PIECE_VECTOR_LO,y
    226  0091		       85 ea		      sta	__ptr
    227  0093		       b9 2f f9 	      lda	PIECE_VECTOR_HI,y
    228  0096		       85 eb		      sta	__ptr+1
    229  0098		       b9 bf f9 	      lda	PIECE_VECTOR_BANK,y
    230  009b		       85 3f		      sta	SET_BANK	;@2
    231  009d
    232  009d		       a0 47		      ldy	#PIECE_SHAPE_SIZE-1
    233  009f		       b1 ea	   .copy      lda	(__ptr),y
    234  00a1		       99 a2 00 	      sta	__pieceShapeBuffer,y
    235  00a4		       88		      dey
    236  00a5		       10 f8		      bpl	.copy
    237  00a7
    238  00a7		       a5 80		      lda	squareToDraw
    239  00a9		       38		      sec
    240  00aa		       a2 0a		      ldx	#10
    241  00ac		       e9 0a	   .sub10     sbc	#10
    242  00ae		       ca		      dex
    243  00af		       b0 fb		      bcs	.sub10
    244  00b1
    245  00b1		       69 08		      adc	#8
    246  00b3		       c9 04		      cmp	#4	; CS = right side of screen
    247  00b5
    248  00b5		       8a		      txa
    249  00b6		       09 80		      ora	#[SLOT2]
    250  00b8		       85 3e		      sta	SET_BANK_RAM	;@2		 ; bank row
    251  00ba
      0  00ba					      CALL	CopyPieceToRowBitmap	;@3
      1  00ba				  -	      IF	SLOT_CopyPieceToRowBitmap == _BANK_SLOT
      2  00ba				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  00ba				  -	      ECHO	"Cannot switch bank in use for", CopyPieceToRowBitmap
      4  00ba				  -	      ERR
      5  00ba					      ENDIF
      6  00ba		       a9 c3		      lda	#BANK_CopyPieceToRowBitmap
      7  00bc		       85 3f		      sta	SET_BANK
      8  00be		       20 0b fc 	      jsr	CopyPieceToRowBitmap
    253  00c1		       60		      rts
    254  00c2
    255  00c2
    256  00c2							;---------------------------------------------------------------------------------------------------
    257  00c2
    258  00c2				   P	      SET	0
    259  00c2					      MAC	ain
    260  00c2				   AI_{1}     SET	P
    261  00c2				   P	      SET	P+1
    262  00c2					      ENDM
    263  00c2
    264  00c2					      MAC	lo
    265  00c2					      .byte	<ai{1}
    266  00c2					      ENDM
    267  00c2
    268  00c2					      MAC	hi
    269  00c2					      .byte	>ai{1}
    270  00c2					      ENDM
    271  00c2
    272  00c2					      MAC	bk
    273  00c2					      .byte	BANK_ai{1}
    274  00c2					      ENDM
    275  00c2
    276  00c2
    277  00c2		       00 28	   ONCEPERFRAME =	40
    278  00c2
    279  00c2					      MAC	tabdef
    280  00c2
    281  00c2					      {1}	FlashComputerMove
    282  00c2					      {1}	BeginSelectMovePhase
    283  00c2					      {1}	SelectStartSquare
    284  00c2					      {1}	StartSquareSelected
    285  00c2					      {1}	DrawMoves
    286  00c2					      {1}	ShowMoveCaptures
    287  00c2					      {1}	SlowFlash
    288  00c2					      {1}	UnDrawTargetSquares
    289  00c2					      {1}	SelectDestinationSquare
    290  00c2					      {1}	Quiescent
    291  00c2					      {1}	ReselectDebounce
    292  00c2					      {1}	StartMoveGen
    293  00c2					      {1}	StepMoveGen
    294  00c2					      {1}	StartClearBoard
    295  00c2					      {1}	ClearEachRow
    296  00c2					      {1}	DrawEntireBoard
    297  00c2					      {1}	DrawPart2
    298  00c2					      {1}	DrawPart3
    299  00c2					      {1}	GenerateMoves
    300  00c2					      {1}	ComputerMove
    301  00c2					      {1}	MoveIsSelected
    302  00c2					      {1}	WriteStartPieceBlank
    303  00c2					      {1}	MarchToTargetA
    304  00c2					      {1}	MarchA2
    305  00c2					      {1}	MarchB
    306  00c2					      {1}	MarchToTargetB
    307  00c2					      {1}	MarchB2
    308  00c2					      {1}	FinalFlash
    309  00c2					      {1}	SpecialMoveFixup
    310  00c2					      {1}	InCheckBackup
    311  00c2					      {1}	InCheckDelay
    312  00c2					      {1}	PromotePawnStart
    313  00c2					      {1}	RollPromotionPiece
    314  00c2					      {1}	ChoosePromotePiece
    315  00c2					      {1}	ChooseDebounce
    316  00c2					      {1}	CheckMate
    317  00c2					      {1}	Draw
    318  00c2					      {1}	DelayAfterMove
    319  00c2					      {1}	DelayAfterMove2
    320  00c2					      {1}	DelayAfterPlaced
    321  00c2					      {1}	DelayAfterPlaced2
    322  00c2
    323  00c2					      ENDM		; {1} = macro to use
    324  00c2
      0  00c2					      TABDEF	AIN
      1  00c2
      0  00c2					      AIN	FlashComputerMove
      1  00c2				   AI_FlashComputerMove SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	BeginSelectMovePhase
      1  00c2				   AI_BeginSelectMovePhase SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	SelectStartSquare
      1  00c2				   AI_SelectStartSquare SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	StartSquareSelected
      1  00c2				   AI_StartSquareSelected SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	DrawMoves
      1  00c2				   AI_DrawMoves SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	ShowMoveCaptures
      1  00c2				   AI_ShowMoveCaptures SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	SlowFlash
      1  00c2				   AI_SlowFlash SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	UnDrawTargetSquares
      1  00c2				   AI_UnDrawTargetSquares SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	SelectDestinationSquare
      1  00c2				   AI_SelectDestinationSquare SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	Quiescent
      1  00c2				   AI_Quiescent SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	ReselectDebounce
      1  00c2				   AI_ReselectDebounce SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	StartMoveGen
      1  00c2				   AI_StartMoveGen SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	StepMoveGen
      1  00c2				   AI_StepMoveGen SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	StartClearBoard
      1  00c2				   AI_StartClearBoard SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	ClearEachRow
      1  00c2				   AI_ClearEachRow SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	DrawEntireBoard
      1  00c2				   AI_DrawEntireBoard SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	DrawPart2
      1  00c2				   AI_DrawPart2 SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	DrawPart3
      1  00c2				   AI_DrawPart3 SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	GenerateMoves
      1  00c2				   AI_GenerateMoves SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	ComputerMove
      1  00c2				   AI_ComputerMove SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	MoveIsSelected
      1  00c2				   AI_MoveIsSelected SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	WriteStartPieceBlank
      1  00c2				   AI_WriteStartPieceBlank SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	MarchToTargetA
      1  00c2				   AI_MarchToTargetA SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	MarchA2
      1  00c2				   AI_MarchA2 SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	MarchB
      1  00c2				   AI_MarchB  SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	MarchToTargetB
      1  00c2				   AI_MarchToTargetB SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	MarchB2
      1  00c2				   AI_MarchB2 SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	FinalFlash
      1  00c2				   AI_FinalFlash SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	SpecialMoveFixup
      1  00c2				   AI_SpecialMoveFixup SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	InCheckBackup
      1  00c2				   AI_InCheckBackup SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	InCheckDelay
      1  00c2				   AI_InCheckDelay SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	PromotePawnStart
      1  00c2				   AI_PromotePawnStart SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	RollPromotionPiece
      1  00c2				   AI_RollPromotionPiece SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	ChoosePromotePiece
      1  00c2				   AI_ChoosePromotePiece SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	ChooseDebounce
      1  00c2				   AI_ChooseDebounce SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	CheckMate
      1  00c2				   AI_CheckMate SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	Draw
      1  00c2				   AI_Draw    SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	DelayAfterMove
      1  00c2				   AI_DelayAfterMove SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	DelayAfterMove2
      1  00c2				   AI_DelayAfterMove2 SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	DelayAfterPlaced
      1  00c2				   AI_DelayAfterPlaced SET	P
      2  00c2				   P	      SET	P+1
      0  00c2					      AIN	DelayAfterPlaced2
      1  00c2				   AI_DelayAfterPlaced2 SET	P
      2  00c2				   P	      SET	P+1
     43  00c2
    326  00c2
      0  00c2					      DEF	AiVectorLO
      1  00c2				   SLOT_AiVectorLO SET	_BANK_SLOT
      2  00c2				   BANK_AiVectorLO SET	SLOT_AiVectorLO + _CURRENT_BANK
      3  00c2				   AiVectorLO
      4  00c2				   TEMPORARY_VAR SET	Overlay
      5  00c2				   TEMPORARY_OFFSET SET	0
      6  00c2				   VAR_BOUNDARY_AiVectorLO SET	TEMPORARY_OFFSET
      7  00c2				   FUNCTION_NAME SET	AiVectorLO
      0  00c2					      TABDEF	LO
      1  00c2
      0  00c2					      LO	FlashComputerMove
      1  00c2		       3a		      .byte.b	<aiFlashComputerMove
      0  00c3					      LO	BeginSelectMovePhase
      1  00c3		       1d		      .byte.b	<aiBeginSelectMovePhase
      0  00c4					      LO	SelectStartSquare
      1  00c4		       62		      .byte.b	<aiSelectStartSquare
      0  00c5					      LO	StartSquareSelected
      1  00c5		       c9		      .byte.b	<aiStartSquareSelected
      0  00c6					      LO	DrawMoves
      1  00c6		       e4		      .byte.b	<aiDrawMoves
      0  00c7					      LO	ShowMoveCaptures
      1  00c7		       88		      .byte.b	<aiShowMoveCaptures
      0  00c8					      LO	SlowFlash
      1  00c8		       a6		      .byte.b	<aiSlowFlash
      0  00c9					      LO	UnDrawTargetSquares
      1  00c9		       66		      .byte.b	<aiUnDrawTargetSquares
      0  00ca					      LO	SelectDestinationSquare
      1  00ca		       f9		      .byte.b	<aiSelectDestinationSquare
      0  00cb					      LO	Quiescent
      1  00cb		       57		      .byte.b	<aiQuiescent
      0  00cc					      LO	ReselectDebounce
      1  00cc		       4e		      .byte.b	<aiReselectDebounce
      0  00cd					      LO	StartMoveGen
      1  00cd		       00		      .byte.b	<aiStartMoveGen
      0  00ce					      LO	StepMoveGen
      1  00ce		       f1		      .byte.b	<aiStepMoveGen
      0  00cf					      LO	StartClearBoard
      1  00cf		       28		      .byte.b	<aiStartClearBoard
      0  00d0					      LO	ClearEachRow
      1  00d0		       35		      .byte.b	<aiClearEachRow
      0  00d1					      LO	DrawEntireBoard
      1  00d1		       39		      .byte.b	<aiDrawEntireBoard
      0  00d2					      LO	DrawPart2
      1  00d2		       2a		      .byte.b	<aiDrawPart2
      0  00d3					      LO	DrawPart3
      1  00d3		       2d		      .byte.b	<aiDrawPart3
      0  00d4					      LO	GenerateMoves
      1  00d4		       de		      .byte.b	<aiGenerateMoves
      0  00d5					      LO	ComputerMove
      1  00d5		       e0		      .byte.b	<aiComputerMove
      0  00d6					      LO	MoveIsSelected
      1  00d6		       42		      .byte.b	<aiMoveIsSelected
      0  00d7					      LO	WriteStartPieceBlank
      1  00d7		       00		      .byte.b	<aiWriteStartPieceBlank
      0  00d8					      LO	MarchToTargetA
      1  00d8		       bd		      .byte.b	<aiMarchToTargetA
      0  00d9					      LO	MarchA2
      1  00d9		       0c		      .byte.b	<aiMarchA2
      0  00da					      LO	MarchB
      1  00da		       47		      .byte.b	<aiMarchB
      0  00db					      LO	MarchToTargetB
      1  00db		       a7		      .byte.b	<aiMarchToTargetB
      0  00dc					      LO	MarchB2
      1  00dc		       33		      .byte.b	<aiMarchB2
      0  00dd					      LO	FinalFlash
      1  00dd		       57		      .byte.b	<aiFinalFlash
      0  00de					      LO	SpecialMoveFixup
      1  00de		       1a		      .byte.b	<aiSpecialMoveFixup
      0  00df					      LO	InCheckBackup
      1  00df		       05		      .byte.b	<aiInCheckBackup
      0  00e0					      LO	InCheckDelay
      1  00e0		       10		      .byte.b	<aiInCheckDelay
      0  00e1					      LO	PromotePawnStart
      1  00e1		       be		      .byte.b	<aiPromotePawnStart
      0  00e2					      LO	RollPromotionPiece
      1  00e2		       77		      .byte.b	<aiRollPromotionPiece
      0  00e3					      LO	ChoosePromotePiece
      1  00e3		       00		      .byte.b	<aiChoosePromotePiece
      0  00e4					      LO	ChooseDebounce
      1  00e4		       6b		      .byte.b	<aiChooseDebounce
      0  00e5					      LO	CheckMate
      1  00e5		       7e		      .byte.b	<aiCheckMate
      0  00e6					      LO	Draw
      1  00e6		       79		      .byte.b	<aiDraw
      0  00e7					      LO	DelayAfterMove
      1  00e7		       7d		      .byte.b	<aiDelayAfterMove
      0  00e8					      LO	DelayAfterMove2
      1  00e8		       86		      .byte.b	<aiDelayAfterMove2
      0  00e9					      LO	DelayAfterPlaced
      1  00e9		       8f		      .byte.b	<aiDelayAfterPlaced
      0  00ea					      LO	DelayAfterPlaced2
      1  00ea		       9e		      .byte.b	<aiDelayAfterPlaced2
     43  00eb
    329  00eb
      0  00eb					      DEF	AiVectorHI
      1  00eb				   SLOT_AiVectorHI SET	_BANK_SLOT
      2  00eb				   BANK_AiVectorHI SET	SLOT_AiVectorHI + _CURRENT_BANK
      3  00eb				   AiVectorHI
      4  00eb				   TEMPORARY_VAR SET	Overlay
      5  00eb				   TEMPORARY_OFFSET SET	0
      6  00eb				   VAR_BOUNDARY_AiVectorHI SET	TEMPORARY_OFFSET
      7  00eb				   FUNCTION_NAME SET	AiVectorHI
      0  00eb					      TABDEF	HI
      1  00eb
      0  00eb					      HI	FlashComputerMove
      1  00eb		       f4		      .byte.b	>aiFlashComputerMove
      0  00ec					      HI	BeginSelectMovePhase
      1  00ec		       f4		      .byte.b	>aiBeginSelectMovePhase
      0  00ed					      HI	SelectStartSquare
      1  00ed		       f4		      .byte.b	>aiSelectStartSquare
      0  00ee					      HI	StartSquareSelected
      1  00ee		       f4		      .byte.b	>aiStartSquareSelected
      0  00ef					      HI	DrawMoves
      1  00ef		       f4		      .byte.b	>aiDrawMoves
      0  00f0					      HI	ShowMoveCaptures
      1  00f0		       f5		      .byte.b	>aiShowMoveCaptures
      0  00f1					      HI	SlowFlash
      1  00f1		       f5		      .byte.b	>aiSlowFlash
      0  00f2					      HI	UnDrawTargetSquares
      1  00f2		       f5		      .byte.b	>aiUnDrawTargetSquares
      0  00f3					      HI	SelectDestinationSquare
      1  00f3		       f5		      .byte.b	>aiSelectDestinationSquare
      0  00f4					      HI	Quiescent
      1  00f4		       f6		      .byte.b	>aiQuiescent
      0  00f5					      HI	ReselectDebounce
      1  00f5		       f6		      .byte.b	>aiReselectDebounce
      0  00f6					      HI	StartMoveGen
      1  00f6		       f4		      .byte.b	>aiStartMoveGen
      0  00f7					      HI	StepMoveGen
      1  00f7		       f4		      .byte.b	>aiStepMoveGen
      0  00f8					      HI	StartClearBoard
      1  00f8		       f8		      .byte.b	>aiStartClearBoard
      0  00f9					      HI	ClearEachRow
      1  00f9		       f8		      .byte.b	>aiClearEachRow
      0  00fa					      HI	DrawEntireBoard
      1  00fa		       f6		      .byte.b	>aiDrawEntireBoard
      0  00fb					      HI	DrawPart2
      1  00fb		       f4		      .byte.b	>aiDrawPart2
      0  00fc					      HI	DrawPart3
      1  00fc		       f4		      .byte.b	>aiDrawPart3
      0  00fd					      HI	GenerateMoves
      1  00fd		       f4		      .byte.b	>aiGenerateMoves
      0  00fe					      HI	ComputerMove
      1  00fe		       f5		      .byte.b	>aiComputerMove
      0  00ff					      HI	MoveIsSelected
      1  00ff		       f8		      .byte.b	>aiMoveIsSelected
      0  0100					      HI	WriteStartPieceBlank
      1  0100		       f4		      .byte.b	>aiWriteStartPieceBlank
      0  0101					      HI	MarchToTargetA
      1  0101		       f6		      .byte.b	>aiMarchToTargetA
      0  0102					      HI	MarchA2
      1  0102		       f7		      .byte.b	>aiMarchA2
      0  0103					      HI	MarchB
      1  0103		       f4		      .byte.b	>aiMarchB
      0  0104					      HI	MarchToTargetB
      1  0104		       f4		      .byte.b	>aiMarchToTargetB
      0  0105					      HI	MarchB2
      1  0105		       f7		      .byte.b	>aiMarchB2
      0  0106					      HI	FinalFlash
      1  0106		       f4		      .byte.b	>aiFinalFlash
      0  0107					      HI	SpecialMoveFixup
      1  0107		       f6		      .byte.b	>aiSpecialMoveFixup
      0  0108					      HI	InCheckBackup
      1  0108		       f4		      .byte.b	>aiInCheckBackup
      0  0109					      HI	InCheckDelay
      1  0109		       f4		      .byte.b	>aiInCheckDelay
      0  010a					      HI	PromotePawnStart
      1  010a		       f4		      .byte.b	>aiPromotePawnStart
      0  010b					      HI	RollPromotionPiece
      1  010b		       f6		      .byte.b	>aiRollPromotionPiece
      0  010c					      HI	ChoosePromotePiece
      1  010c		       f4		      .byte.b	>aiChoosePromotePiece
      0  010d					      HI	ChooseDebounce
      1  010d		       f4		      .byte.b	>aiChooseDebounce
      0  010e					      HI	CheckMate
      1  010e		       f4		      .byte.b	>aiCheckMate
      0  010f					      HI	Draw
      1  010f		       f4		      .byte.b	>aiDraw
      0  0110					      HI	DelayAfterMove
      1  0110		       f4		      .byte.b	>aiDelayAfterMove
      0  0111					      HI	DelayAfterMove2
      1  0111		       f4		      .byte.b	>aiDelayAfterMove2
      0  0112					      HI	DelayAfterPlaced
      1  0112		       f4		      .byte.b	>aiDelayAfterPlaced
      0  0113					      HI	DelayAfterPlaced2
      1  0113		       f4		      .byte.b	>aiDelayAfterPlaced2
     43  0114
    332  0114
      0  0114					      DEF	AiVectorBANK
      1  0114				   SLOT_AiVectorBANK SET	_BANK_SLOT
      2  0114				   BANK_AiVectorBANK SET	SLOT_AiVectorBANK + _CURRENT_BANK
      3  0114				   AiVectorBANK
      4  0114				   TEMPORARY_VAR SET	Overlay
      5  0114				   TEMPORARY_OFFSET SET	0
      6  0114				   VAR_BOUNDARY_AiVectorBANK SET	TEMPORARY_OFFSET
      7  0114				   FUNCTION_NAME SET	AiVectorBANK
      0  0114					      TABDEF	BK
      1  0114
      0  0114					      BK	FlashComputerMove
      1  0114		       48		      .byte.b	BANK_aiFlashComputerMove
      0  0115					      BK	BeginSelectMovePhase
      1  0115		       48		      .byte.b	BANK_aiBeginSelectMovePhase
      0  0116					      BK	SelectStartSquare
      1  0116		       48		      .byte.b	BANK_aiSelectStartSquare
      0  0117					      BK	StartSquareSelected
      1  0117		       48		      .byte.b	BANK_aiStartSquareSelected
      0  0118					      BK	DrawMoves
      1  0118		       48		      .byte.b	BANK_aiDrawMoves
      0  0119					      BK	ShowMoveCaptures
      1  0119		       48		      .byte.b	BANK_aiShowMoveCaptures
      0  011a					      BK	SlowFlash
      1  011a		       48		      .byte.b	BANK_aiSlowFlash
      0  011b					      BK	UnDrawTargetSquares
      1  011b		       48		      .byte.b	BANK_aiUnDrawTargetSquares
      0  011c					      BK	SelectDestinationSquare
      1  011c		       48		      .byte.b	BANK_aiSelectDestinationSquare
      0  011d					      BK	Quiescent
      1  011d		       48		      .byte.b	BANK_aiQuiescent
      0  011e					      BK	ReselectDebounce
      1  011e		       48		      .byte.b	BANK_aiReselectDebounce
      0  011f					      BK	StartMoveGen
      1  011f		       48		      .byte.b	BANK_aiStartMoveGen
      0  0120					      BK	StepMoveGen
      1  0120		       49		      .byte.b	BANK_aiStepMoveGen
      0  0121					      BK	StartClearBoard
      1  0121		       94		      .byte.b	BANK_aiStartClearBoard
      0  0122					      BK	ClearEachRow
      1  0122		       94		      .byte.b	BANK_aiClearEachRow
      0  0123					      BK	DrawEntireBoard
      1  0123		       5d		      .byte.b	BANK_aiDrawEntireBoard
      0  0124					      BK	DrawPart2
      1  0124		       55		      .byte.b	BANK_aiDrawPart2
      0  0125					      BK	DrawPart3
      1  0125		       55		      .byte.b	BANK_aiDrawPart3
      0  0126					      BK	GenerateMoves
      1  0126		       49		      .byte.b	BANK_aiGenerateMoves
      0  0127					      BK	ComputerMove
      1  0127		       5d		      .byte.b	BANK_aiComputerMove
      0  0128					      BK	MoveIsSelected
      1  0128		       94		      .byte.b	BANK_aiMoveIsSelected
      0  0129					      BK	WriteStartPieceBlank
      1  0129		       55		      .byte.b	BANK_aiWriteStartPieceBlank
      0  012a					      BK	MarchToTargetA
      1  012a		       48		      .byte.b	BANK_aiMarchToTargetA
      0  012b					      BK	MarchA2
      1  012b		       48		      .byte.b	BANK_aiMarchA2
      0  012c					      BK	MarchB
      1  012c		       55		      .byte.b	BANK_aiMarchB
      0  012d					      BK	MarchToTargetB
      1  012d		       49		      .byte.b	BANK_aiMarchToTargetB
      0  012e					      BK	MarchB2
      1  012e		       48		      .byte.b	BANK_aiMarchB2
      0  012f					      BK	FinalFlash
      1  012f		       55		      .byte.b	BANK_aiFinalFlash
      0  0130					      BK	SpecialMoveFixup
      1  0130		       5d		      .byte.b	BANK_aiSpecialMoveFixup
      0  0131					      BK	InCheckBackup
      1  0131		       48		      .byte.b	BANK_aiInCheckBackup
      0  0132					      BK	InCheckDelay
      1  0132		       48		      .byte.b	BANK_aiInCheckDelay
      0  0133					      BK	PromotePawnStart
      1  0133		       49		      .byte.b	BANK_aiPromotePawnStart
      0  0134					      BK	RollPromotionPiece
      1  0134		       48		      .byte.b	BANK_aiRollPromotionPiece
      0  0135					      BK	ChoosePromotePiece
      1  0135		       49		      .byte.b	BANK_aiChoosePromotePiece
      0  0136					      BK	ChooseDebounce
      1  0136		       49		      .byte.b	BANK_aiChooseDebounce
      0  0137					      BK	CheckMate
      1  0137		       55		      .byte.b	BANK_aiCheckMate
      0  0138					      BK	Draw
      1  0138		       55		      .byte.b	BANK_aiDraw
      0  0139					      BK	DelayAfterMove
      1  0139		       49		      .byte.b	BANK_aiDelayAfterMove
      0  013a					      BK	DelayAfterMove2
      1  013a		       49		      .byte.b	BANK_aiDelayAfterMove2
      0  013b					      BK	DelayAfterPlaced
      1  013b		       49		      .byte.b	BANK_aiDelayAfterPlaced
      0  013c					      BK	DelayAfterPlaced2
      1  013c		       49		      .byte.b	BANK_aiDelayAfterPlaced2
     43  013d
    335  013d
    336  013d
    337  013d							;---------------------------------------------------------------------------------------------------
    338  013d
      0  013d					      DEF	AiStateMachine
      1  013d				   SLOT_AiStateMachine SET	_BANK_SLOT
      2  013d				   BANK_AiStateMachine SET	SLOT_AiStateMachine + _CURRENT_BANK
      3  013d				   AiStateMachine
      4  013d				   TEMPORARY_VAR SET	Overlay
      5  013d				   TEMPORARY_OFFSET SET	0
      6  013d				   VAR_BOUNDARY_AiStateMachine SET	TEMPORARY_OFFSET
      7  013d				   FUNCTION_NAME SET	AiStateMachine
    340  013d					      SUBROUTINE
    341  013d
      0  013d					      REFER	StartupBankReset
      1  013d				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  013d				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  013d					      ENDIF
      0  013d					      VEND	AiStateMachine
      1  013d				  -	      IFNCONST	AiStateMachine
      2  013d				  -	      ECHO	"Incorrect VEND label", AiStateMachine
      3  013d				  -	      ERR
      4  013d					      ENDIF
      5  013d		       00 a2	   VAREND_AiStateMachine =	TEMPORARY_VAR
    344  013d
    345  013d
    346  013d							; State machine vector setup - points to current routine to execute
    347  013d
    348  013d		       a6 8c		      ldx	aiState
    349  013f		       bd c2 f0 	      lda	AiVectorLO,x
    350  0142		       85 ea		      sta	__ptr
    351  0144		       bd eb f0 	      lda	AiVectorHI,x
    352  0147		       85 eb		      sta	__ptr+1
    353  0149
    354  0149		       bd 14 f1 	      lda	AiVectorBANK,x
    355  014c		       85 8b		      sta	savedBank
    356  014e
    357  014e		       85 3f		      sta	SET_BANK
    358  0150		       6c ea 00 	      jmp	(__ptr)	; NOTE: could branch back to squeeze cycles
    359  0153
    360  0153
    361  0153							;---------------------------------------------------------------------------------------------------
    362  0153
 FREE BYTES IN STARTUP BANK =  $ffffffffffffffa9
    363  0153					      ECHO	"FREE BYTES IN STARTUP BANK = ", $F0FC - *
    364  0153
    365  0153							;---------------------------------------------------------------------------------------------------
    366  0153							; The reset vectors
    367  0153							; these must live in the first 1K bank of the ROM
    368  0153
    369  0400 ????				      SEG	StartupInterruptVectors
    370  03fc					      ORG	_FIRST_BANK + $3FC
    371  03fc
    372  03fc		       00 f0		      .word.w	StartupBankReset	; RESET
    373  03fe		       00 f0		      .word.w	StartupBankReset	; IRQ	      (not used)
    374  0400
    375  0400							;---------------------------------------------------------------------------------------------------
    376  0400
    377  0400
    378  0400							; EOF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@1#1.asm LEVEL 2 PASS 4
      0  0400					      include	"BANK_GENERIC@1#1.asm"
      1  0400							; Chess
      2  0400							; Copyright (c) 2019-2020 Andrew Davie
      3  0400							; andrew@taswegian.com
      4  0400
      0  0400					      SLOT	1	; which bank this code switches to
      1  0400				  -	      IF	(1 < 0) || (1 > 3)
      2  0400				  -	      ECHO	"Illegal bank address/segment location", 1
      3  0400				  -	      ERR
      4  0400					      ENDIF
      5  0400				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  0400				   _BANK_SLOT SET	1 * 64
      0  0400					      NEWBANK	ONE
      1  0682 ????				      SEG	ONE
      2  0400					      ORG	_ORIGIN
      3  0400					      RORG	_BANK_ADDRESS_ORIGIN
      4  0400				   _BANK_START SET	*
      5  0400				   ONE_START  SET	*
      6  0400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0400				   ONE	      SET	_BANK_SLOT + _CURRENT_BANK
      8  0400				   _ORIGIN    SET	_ORIGIN + 1024
      7  0400
      8  0400
      9  0400							;---------------------------------------------------------------------------------------------------
     10  0400							; ... the above is a (potentially) RAM-copied section -- the following is ROM-only.  Note that
     11  0400							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     12  0400							; bank finishes.  Just continue on from where it left off...
     13  0400							;---------------------------------------------------------------------------------------------------
     14  0400
      0  0400					      DEF	CartInit
      1  0400				   SLOT_CartInit SET	_BANK_SLOT
      2  0400				   BANK_CartInit SET	SLOT_CartInit + _CURRENT_BANK
      3  0400				   CartInit
      4  0400				   TEMPORARY_VAR SET	Overlay
      5  0400				   TEMPORARY_OFFSET SET	0
      6  0400				   VAR_BOUNDARY_CartInit SET	TEMPORARY_OFFSET
      7  0400				   FUNCTION_NAME SET	CartInit
     16  0400					      SUBROUTINE
     17  0400
      0  0400					      REFER	StartupBankReset
      1  0400				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0400				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0400					      ENDIF
      0  0400					      VEND	CartInit
      1  0400				  -	      IFNCONST	CartInit
      2  0400				  -	      ECHO	"Incorrect VEND label", CartInit
      3  0400				  -	      ERR
      4  0400					      ENDIF
      5  0400		       00 a2	   VAREND_CartInit =	TEMPORARY_VAR
     20  0400
     21  0400		       78		      sei
     22  0401		       d8		      cld
     23  0402							; See if we can come up with something 'random' for startup
     24  0402
     25  0402		       ac 84 02 	      ldy	INTIM
     26  0405		       d0 02		      bne	.toR
     27  0407		       a0 9a		      ldy	#$9A
     28  0409		       84 81	   .toR       sty	rnd
     29  040b
     30  040b		       a9 ff		      lda	#255
     31  040d		       85 a1		      sta	randomness
     32  040f
     33  040f		       a9 00		      lda	#0
     34  0411		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     35  0414		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     36  0417		       85 6b		      sta	HMCLR
     37  0419
     38  0419							; cleanup remains of title screen
     39  0419		       85 5b		      sta	GRP0
     40  041b		       85 5c		      sta	GRP1
     41  041d
     42  041d		       a9 10		      lda	#%00010000	; double width missile, double width player
     43  041f		       85 44		      sta	NUSIZ0
     44  0421		       85 45		      sta	NUSIZ1
     45  0423
     46  0423		       a9 04		      lda	#%100	; players/missiles BEHIND BG
     47  0425		       85 4a		      sta	CTRLPF
     48  0427		       a9 07		      lda	#%111
     49  0429		       85 44		      sta	NUSIZ0
     50  042b		       85 45		      sta	NUSIZ1	; quad-width
     51  042d
     52  042d		       a9 04		      lda	#%00000100
     53  042f		       85 4a		      sta	CTRLPF
     54  0431		       a9 00		      lda	#BACKGCOL
     55  0433		       85 49		      sta	COLUBK
     56  0435
     57  0435
     58  0435		       a9 00		      lda	#WHITE	;tmp+RAMBANK_PLY
     59  0437		       85 96		      sta	sideToMove
     60  0439
     61  0439		       60		      rts
     62  043a
     63  043a
     64  043a							;---------------------------------------------------------------------------------------------------
     65  043a
      0  043a					      DEF	SetupBanks
      1  043a				   SLOT_SetupBanks SET	_BANK_SLOT
      2  043a				   BANK_SetupBanks SET	SLOT_SetupBanks + _CURRENT_BANK
      3  043a				   SetupBanks
      4  043a				   TEMPORARY_VAR SET	Overlay
      5  043a				   TEMPORARY_OFFSET SET	0
      6  043a				   VAR_BOUNDARY_SetupBanks SET	TEMPORARY_OFFSET
      7  043a				   FUNCTION_NAME SET	SetupBanks
     67  043a					      SUBROUTINE
     68  043a
     69  043a							; Move a copy of the row bank template to the first 8 banks of RAM
     70  043a							; and then terminate the draw subroutine by substituting in a RTS on the last one
     71  043a
      0  043a					      REFER	StartupBankReset
      1  043a				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  043a				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  043a					      ENDIF
      0  043a					      VAR	__plyBank, 1
      1  043a		       00 a2	   __plyBank  =	TEMPORARY_VAR
      2  043a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  043a
      4  043a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  043a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  043a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  043a					      ENDIF
      8  043a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  043a				  -	      ECHO	"Temporary Variable", __plyBank, "overflow!"
     10  043a				  -	      ERR
     11  043a					      ENDIF
     12  043a					      LIST	ON
      0  043a					      VEND	SetupBanks
      1  043a				  -	      IFNCONST	SetupBanks
      2  043a				  -	      ECHO	"Incorrect VEND label", SetupBanks
      3  043a				  -	      ERR
      4  043a					      ENDIF
      5  043a		       00 a3	   VAREND_SetupBanks =	TEMPORARY_VAR
     75  043a
     76  043a							; Copy the bitmap shadow into the first 8 RAM banks via x(SLOT3)-->y(SLOT2)
     77  043a
     78  043a				   .ROWBANK   SET	0
     79  043a					      REPEAT	8
     80  043a		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  043c		       a0 c0		      ldy	#[SLOT3] + .ROWBANK
     82  043e		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
     83  043e				   .ROWBANK   SET	.ROWBANK+1
     79  043e					      REPEND
     80  0441		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  0443		       a0 c1		      ldy	#[SLOT3] + .ROWBANK
     82  0445		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
     83  0445				   .ROWBANK   SET	.ROWBANK+1
     79  0445					      REPEND
     80  0448		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  044a		       a0 c2		      ldy	#[SLOT3] + .ROWBANK
     82  044c		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
     83  044c				   .ROWBANK   SET	.ROWBANK+1
     79  044c					      REPEND
     80  044f		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  0451		       a0 c3		      ldy	#[SLOT3] + .ROWBANK
     82  0453		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
     83  0453				   .ROWBANK   SET	.ROWBANK+1
     79  0453					      REPEND
     80  0456		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  0458		       a0 c4		      ldy	#[SLOT3] + .ROWBANK
     82  045a		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
     83  045a				   .ROWBANK   SET	.ROWBANK+1
     79  045a					      REPEND
     80  045d		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  045f		       a0 c5		      ldy	#[SLOT3] + .ROWBANK
     82  0461		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
     83  0461				   .ROWBANK   SET	.ROWBANK+1
     79  0461					      REPEND
     80  0464		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  0466		       a0 c6		      ldy	#[SLOT3] + .ROWBANK
     82  0468		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
     83  0468				   .ROWBANK   SET	.ROWBANK+1
     79  0468					      REPEND
     80  046b		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  046d		       a0 c7		      ldy	#[SLOT3] + .ROWBANK
     82  046f		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
     83  046f				   .ROWBANK   SET	.ROWBANK+1
     84  0472					      REPEND
     85  0472
     86  0472
     87  0472							; Patch the final row's "loop" to a RTS
     88  0472
     89  0472		       a2 87		      ldx	#[SLOT2] + 7	; last ROW BITMAP bank
     90  0474		       86 3e		      stx	SET_BANK_RAM
     91  0476		       a9 60		      lda	#$60	; "rts"
      0  0478					      sta@RAM	SELFMOD_RTS_ON_LAST_ROW
      1  0478		       8d 00 fb 	      sta	[RAM]+SELFMOD_RTS_ON_LAST_ROW
     93  047b
     94  047b
     95  047b
     96  047b							; copy the BOARD/MOVES bank
     97  047b
     98  047b		       a2 86		      ldx	#SHADOW_BOARD
     99  047d		       a0 cf		      ldy	#RAMBANK_BOARD
    100  047f		       20 b4 f4 	      jsr	CopyShadowROMtoRAM	; this auto-initialises Board too
    101  0482
    102  0482
    103  0482							; copy the PLY banks
    104  0482							; If there's no content (only variable decs) then we don't really need to do this.
    105  0482
    106  0482				   .PLY       SET	0
    107  0482					      REPEAT	PLY_BANKS
    108  0482
    109  0482		       a2 c5		      ldx	#SHADOW_PLY
    110  0484		       a0 c8		      ldy	#RAMBANK_PLY + .PLY
    111  0486		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
    112  0486				   .PLY       SET	.PLY + 1
    107  0486					      REPEND
    108  0489
    109  0489		       a2 c5		      ldx	#SHADOW_PLY
    110  048b		       a0 c9		      ldy	#RAMBANK_PLY + .PLY
    111  048d		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
    112  048d				   .PLY       SET	.PLY + 1
    107  048d					      REPEND
    108  0490
    109  0490		       a2 c5		      ldx	#SHADOW_PLY
    110  0492		       a0 ca		      ldy	#RAMBANK_PLY + .PLY
    111  0494		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
    112  0494				   .PLY       SET	.PLY + 1
    107  0494					      REPEND
    108  0497
    109  0497		       a2 c5		      ldx	#SHADOW_PLY
    110  0499		       a0 cb		      ldy	#RAMBANK_PLY + .PLY
    111  049b		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
    112  049b				   .PLY       SET	.PLY + 1
    107  049b					      REPEND
    108  049e
    109  049e		       a2 c5		      ldx	#SHADOW_PLY
    110  04a0		       a0 cc		      ldy	#RAMBANK_PLY + .PLY
    111  04a2		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
    112  04a2				   .PLY       SET	.PLY + 1
    107  04a2					      REPEND
    108  04a5
    109  04a5		       a2 c5		      ldx	#SHADOW_PLY
    110  04a7		       a0 cd		      ldy	#RAMBANK_PLY + .PLY
    111  04a9		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
    112  04a9				   .PLY       SET	.PLY + 1
    107  04a9					      REPEND
    108  04ac
    109  04ac		       a2 c5		      ldx	#SHADOW_PLY
    110  04ae		       a0 ce		      ldy	#RAMBANK_PLY + .PLY
    111  04b0		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
    112  04b0				   .PLY       SET	.PLY + 1
    113  04b3					      REPEND
    114  04b3
    115  04b3							; copy the evaluation code/tables
    116  04b3							; 3E+ moved from RAM to ROM
    117  04b3
    118  04b3							;		      ldx #[SLOT2] + SHADOW_EVAL
    119  04b3							;		      ldy #[SLOT3] + EVAL
    120  04b3							;		      jsr CopyShadowROMtoRAM
    121  04b3
    122  04b3
    123  04b3							;		      ldy #RAMBANK_RAM_PIECELIST
    124  04b3							;		      ldx #ROM_PIECELIST
    125  04b3							;		      jsr CopyShadowROMtoRAM
    126  04b3
    127  04b3		       60		      rts
    128  04b4
    129  04b4
    130  04b4							;---------------------------------------------------------------------------------------------------
    131  04b4
      0  04b4					      DEF	CopyShadowROMtoRAM
      1  04b4				   SLOT_CopyShadowROMtoRAM SET	_BANK_SLOT
      2  04b4				   BANK_CopyShadowROMtoRAM SET	SLOT_CopyShadowROMtoRAM + _CURRENT_BANK
      3  04b4				   CopyShadowROMtoRAM
      4  04b4				   TEMPORARY_VAR SET	Overlay
      5  04b4				   TEMPORARY_OFFSET SET	0
      6  04b4				   VAR_BOUNDARY_CopyShadowROMtoRAM SET	TEMPORARY_OFFSET
      7  04b4				   FUNCTION_NAME SET	CopyShadowROMtoRAM
    133  04b4					      SUBROUTINE
    134  04b4
      0  04b4					      REFER	SetupBanks
      1  04b4					      IF	VAREND_SetupBanks > TEMPORARY_VAR
      2  04b4				   TEMPORARY_VAR SET	VAREND_SetupBanks
      3  04b4					      ENDIF
      0  04b4					      VEND	CopyShadowROMtoRAM
      1  04b4				  -	      IFNCONST	CopyShadowROMtoRAM
      2  04b4				  -	      ECHO	"Incorrect VEND label", CopyShadowROMtoRAM
      3  04b4				  -	      ERR
      4  04b4					      ENDIF
      5  04b4		       00 a3	   VAREND_CopyShadowROMtoRAM =	TEMPORARY_VAR
    137  04b4
    138  04b4							; Copy a whole ROM SHADOW into a destination RAM 512 byte bank
    139  04b4							; used to setup callable RAM code from ROM templates
    140  04b4
    141  04b4							; x = source ROM bank
    142  04b4							; y = destination RAM bank (preserved)
    143  04b4
    144  04b4		       86 3f		      stx	SET_BANK
    145  04b6		       84 3e		      sty	SET_BANK_RAM
    146  04b8
    147  04b8		       a2 00		      ldx	#0
    148  04ba		       bd 00 f8    .copyPage  lda	$F800,x
      0  04bd					      sta@RAM	$FC00,x
      1  04bd		       9d 00 fe 	      sta	[RAM]+$FC00,x
    150  04c0		       bd 00 f9 	      lda	$F900,x
      0  04c3					      sta@RAM	$FD00,x
      1  04c3		       9d 00 ff 	      sta	[RAM]+$FD00,x
    152  04c6		       ca		      dex
    153  04c7		       d0 f1		      bne	.copyPage
    154  04c9		       60		      rts
    155  04ca
    156  04ca
    157  04ca							;---------------------------------------------------------------------------------------------------
    158  04ca
      0  04ca					      DEF	CallClear
      1  04ca				   SLOT_CallClear SET	_BANK_SLOT
      2  04ca				   BANK_CallClear SET	SLOT_CallClear + _CURRENT_BANK
      3  04ca				   CallClear
      4  04ca				   TEMPORARY_VAR SET	Overlay
      5  04ca				   TEMPORARY_OFFSET SET	0
      6  04ca				   VAR_BOUNDARY_CallClear SET	TEMPORARY_OFFSET
      7  04ca				   FUNCTION_NAME SET	CallClear
    160  04ca					      SUBROUTINE
    161  04ca
    162  04ca				  -	      IF	0
    163  04ca				  -	      REFER	aiClearEachRow
    164  04ca					      ENDIF
      0  04ca					      VEND	CallClear
      1  04ca				  -	      IFNCONST	CallClear
      2  04ca				  -	      ECHO	"Incorrect VEND label", CallClear
      3  04ca				  -	      ERR
      4  04ca					      ENDIF
      5  04ca		       00 a2	   VAREND_CallClear =	TEMPORARY_VAR
    166  04ca
    167  04ca				  -	      IF	0
    168  04ca				  -			; No transient variable dependencies/calls
    169  04ca				  -
    170  04ca				  -	      sty	SET_BANK_RAM
    171  04ca				  -	      jsr	ClearRowBitmap
    172  04ca					      ENDIF
    173  04ca		       60		      rts
    174  04cb
    175  04cb
    176  04cb							;---------------------------------------------------------------------------------------------------
    177  04cb
      0  04cb					      DEF	InitialisePieceSquares
      1  04cb				   SLOT_InitialisePieceSquares SET	_BANK_SLOT
      2  04cb				   BANK_InitialisePieceSquares SET	SLOT_InitialisePieceSquares + _CURRENT_BANK
      3  04cb				   InitialisePieceSquares
      4  04cb				   TEMPORARY_VAR SET	Overlay
      5  04cb				   TEMPORARY_OFFSET SET	0
      6  04cb				   VAR_BOUNDARY_InitialisePieceSquares SET	TEMPORARY_OFFSET
      7  04cb				   FUNCTION_NAME SET	InitialisePieceSquares
    179  04cb					      SUBROUTINE
    180  04cb
      0  04cb					      REFER	StartupBankReset
      1  04cb				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  04cb				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  04cb					      ENDIF
      0  04cb					      VAR	__initPiece, 1
      1  04cb		       00 a2	   __initPiece =	TEMPORARY_VAR
      2  04cb				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  04cb
      4  04cb				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  04cb				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  04cb				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  04cb					      ENDIF
      8  04cb				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  04cb				  -	      ECHO	"Temporary Variable", __initPiece, "overflow!"
     10  04cb				  -	      ERR
     11  04cb					      ENDIF
     12  04cb					      LIST	ON
      0  04cb					      VAR	__initSquare, 1
      1  04cb		       00 a3	   __initSquare =	TEMPORARY_VAR
      2  04cb				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  04cb
      4  04cb				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  04cb				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  04cb				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  04cb					      ENDIF
      8  04cb				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  04cb				  -	      ECHO	"Temporary Variable", __initSquare, "overflow!"
     10  04cb				  -	      ERR
     11  04cb					      ENDIF
     12  04cb					      LIST	ON
      0  04cb					      VAR	__initListPtr, 1
      1  04cb		       00 a4	   __initListPtr =	TEMPORARY_VAR
      2  04cb				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  04cb
      4  04cb				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  04cb				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  04cb				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  04cb					      ENDIF
      8  04cb				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  04cb				  -	      ECHO	"Temporary Variable", __initListPtr, "overflow!"
     10  04cb				  -	      ERR
     11  04cb					      ENDIF
     12  04cb					      LIST	ON
      0  04cb					      VEND	InitialisePieceSquares
      1  04cb				  -	      IFNCONST	InitialisePieceSquares
      2  04cb				  -	      ECHO	"Incorrect VEND label", InitialisePieceSquares
      3  04cb				  -	      ERR
      4  04cb					      ENDIF
      5  04cb		       00 a5	   VAREND_InitialisePieceSquares =	TEMPORARY_VAR
    186  04cb
    187  04cb							;---------------------------------------------------------------------------------------------------
    188  04cb
      0  04cb					      DEF	InitPieceLists
      1  04cb				   SLOT_InitPieceLists SET	_BANK_SLOT
      2  04cb				   BANK_InitPieceLists SET	SLOT_InitPieceLists + _CURRENT_BANK
      3  04cb				   InitPieceLists
      4  04cb				   TEMPORARY_VAR SET	Overlay
      5  04cb				   TEMPORARY_OFFSET SET	0
      6  04cb				   VAR_BOUNDARY_InitPieceLists SET	TEMPORARY_OFFSET
      7  04cb				   FUNCTION_NAME SET	InitPieceLists
    190  04cb					      SUBROUTINE
    191  04cb
      0  04cb					      REFER	InitialisePieceSquares
      1  04cb					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  04cb				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  04cb					      ENDIF
      0  04cb					      VEND	InitPieceLists
      1  04cb				  -	      IFNCONST	InitPieceLists
      2  04cb				  -	      ECHO	"Incorrect VEND label", InitPieceLists
      3  04cb				  -	      ERR
      4  04cb					      ENDIF
      5  04cb		       00 a5	   VAREND_InitPieceLists =	TEMPORARY_VAR
    194  04cb
    195  04cb
    196  04cb		       a9 00		      lda	#0
    197  04cd		       85 90		      sta	Evaluation
    198  04cf		       85 91		      sta	Evaluation+1	; tracks CURRENT value of everything (signed 16-bit)
    199  04d1		       85 94		      sta	enPassantPawn	; no en-passant
    200  04d3
    201  04d3
      0  04d3					      PHASE	AI_StartClearBoard
      1  04d3		       a9 0d		      lda	#AI_StartClearBoard
      2  04d5		       85 8c		      sta	aiState
    203  04d7
    204  04d7		       a2 00		      ldx	#0
    205  04d9				   .fillPieceLists
    206  04d9
    207  04d9
    208  04d9		       bd 23 f5 	      lda	InitPieceList,x	; colour/-1
    209  04dc		       f0 44		      beq	.exit
    210  04de		       85 a2		      sta	__originalPiece	; type
    211  04e0		       bc 24 f5 	      ldy	InitPieceList+1,x	; square
    212  04e3		       84 a3		      sty	__initSquare
    213  04e5
    214  04e5		       a9 cf		      lda	#RAMBANK_BOARD
    215  04e7		       85 3e		      sta	SET_BANK_RAM
    216  04e9		       a5 a2		      lda	__originalPiece
      0  04eb					      sta@RAM	Board,y
      1  04eb		       99 79 fe 	      sta	[RAM]+Board,y
    218  04ee		       10 0d		      bpl	.white
    219  04f0
      0  04f0					      NEGEVAL
      1  04f0
      2  04f0		       38		      sec
      3  04f1		       a9 00		      lda	#0
      4  04f3		       e5 90		      sbc	Evaluation
      5  04f5		       85 90		      sta	Evaluation
      6  04f7		       a9 00		      lda	#0
      7  04f9		       e5 91		      sbc	Evaluation+1
      8  04fb		       85 91		      sta	Evaluation+1
    221  04fd				   .white
    222  04fd
    223  04fd							; Add the material value of the piece to the evaluation
    224  04fd
    225  04fd		       a5 a2		      lda	__originalPiece
    226  04ff
    227  04ff							;lda #RAMBANK_BANK_EVAL ;BANK_AddPiecePositionValue
    228  04ff							;sta SET_BANK_RAM
    229  04ff		       20 0b f6 	      jsr	AddPieceMaterialValue
    230  0502
    231  0502		       86 a4		      stx	__initListPtr
    232  0504
    233  0504							; add the positional value of the piece to the evaluation
    234  0504
    235  0504		       a4 a3		      ldy	__initSquare
    236  0506		       a5 a2		      lda	__originalPiece
    237  0508
    238  0508							;ldx #BANK_AddPiecePositionValue
    239  0508							;stx SET_BANK
    240  0508		       20 c8 f5 	      jsr	AddPiecePositionValue
    241  050b
    242  050b		       a5 a2		      lda	__originalPiece	; type/colour
    243  050d		       10 0d		      bpl	.white2
      0  050f					      NEGEVAL
      1  050f
      2  050f		       38		      sec
      3  0510		       a9 00		      lda	#0
      4  0512		       e5 90		      sbc	Evaluation
      5  0514		       85 90		      sta	Evaluation
      6  0516		       a9 00		      lda	#0
      7  0518		       e5 91		      sbc	Evaluation+1
      8  051a		       85 91		      sta	Evaluation+1
    245  051c				   .white2
    246  051c
    247  051c		       a6 a4		      ldx	__initListPtr
    248  051e		       e8		      inx
    249  051f		       e8		      inx
    250  0520		       10 b7		      bpl	.fillPieceLists
    251  0522
    252  0522				   .exit
    253  0522		       60		      rts
    254  0523
    255  0523
    256  0523				   InitPieceList
    257  0523
    258  0523
    259  0523					      IF	!TEST_POSITION
    260  0523
    261  0523		       06 19		      .byte.b	WHITE|Q, 25
    262  0525		       04 18		      .byte.b	WHITE|B, 24
    263  0527		       04 1b		      .byte.b	WHITE|B, 27
    264  0529		       05 16		      .byte.b	WHITE|R, 22
    265  052b		       05 1d		      .byte.b	WHITE|R, 29
    266  052d		       03 17		      .byte.b	WHITE|N, 23
    267  052f		       03 1c		      .byte.b	WHITE|N, 28
    268  0531
    269  0531		       01 23		      .byte.b	WHITE|WP, 35
    270  0533		       01 24		      .byte.b	WHITE|WP, 36
    271  0535		       01 22		      .byte.b	WHITE|WP, 34
    272  0537		       01 25		      .byte.b	WHITE|WP, 37
    273  0539		       01 21		      .byte.b	WHITE|WP, 33
    274  053b		       01 26		      .byte.b	WHITE|WP, 38
    275  053d		       01 20		      .byte.b	WHITE|WP, 32
    276  053f		       01 27		      .byte.b	WHITE|WP, 39
    277  0541
    278  0541		       07 1a		      .byte.b	WHITE|K, 26
    279  0543
    280  0543		       86 5f		      .byte.b	BLACK|Q, 95
    281  0545		       84 5e		      .byte.b	BLACK|B, 94
    282  0547		       84 61		      .byte.b	BLACK|B, 97
    283  0549		       85 5c		      .byte.b	BLACK|R, 92
    284  054b		       85 63		      .byte.b	BLACK|R, 99
    285  054d		       83 5d		      .byte.b	BLACK|N, 93
    286  054f		       83 62		      .byte.b	BLACK|N, 98
    287  0551
    288  0551		       82 55		      .byte.b	BLACK|BP, 85
    289  0553		       82 56		      .byte.b	BLACK|BP, 86
    290  0555		       82 54		      .byte.b	BLACK|BP, 84
    291  0557		       82 57		      .byte.b	BLACK|BP, 87
    292  0559		       82 53		      .byte.b	BLACK|BP, 83
    293  055b		       82 58		      .byte.b	BLACK|BP, 88
    294  055d		       82 52		      .byte.b	BLACK|BP, 82
    295  055f		       82 59		      .byte.b	BLACK|BP, 89
    296  0561
    297  0561		       87 60		      .byte.b	BLACK|K, 96
    298  0563
    299  0563		       00		      .byte.b	0	;end
    300  0564
    301  0564				  -	      ELSE		; test position...
    302  0564				  -
    303  0564				  -
    304  0564				  -	      IF	0
    305  0564				  -
    306  0564				  -	      .byte	WHITE|K, 28
    307  0564				  -	      .byte	WHITE|WP, 37
    308  0564				  -	      .byte	WHITE|WP, 38
    309  0564				  -	      .byte	WHITE|WP, 53
    310  0564				  -	      .byte	WHITE|WP, 49
    311  0564				  -	      .byte	WHITE|WP, 32
    312  0564				  -	      .byte	WHITE|R, 27
    313  0564				  -	      .byte	WHITE|B, 46
    314  0564				  -	      .byte	WHITE|R, 54
    315  0564				  -
    316  0564				  -	      .byte	BLACK|BP, 56
    317  0564				  -	      .byte	BLACK|BP, 87
    318  0564				  -	      .byte	BLACK|BP, 88
    319  0564				  -	      .byte	BLACK|BP, 89
    320  0564				  -	      .byte	BLACK|BP, 84
    321  0564				  -	      .byte	BLACK|B, 66
    322  0564				  -	      .byte	BLACK|R, 69
    323  0564				  -	      .byte	BLACK|K, 98
    324  0564				  -
    325  0564				  -	      .byte	BLACK|R, 92
    326  0564				  -
    327  0564				  -
    328  0564				  -
    329  0564				  -	      ENDIF
    330  0564				  -
    331  0564				  -
    332  0564				  -	      IF	0
    333  0564				  -			; En passant test
    334  0564				  -
    335  0564				  -	      .byte	BLACK|BP, 88
    336  0564				  -	      .byte	BLACK|BP, 86
    337  0564				  -
    338  0564				  -	      .byte	WHITE|WP, 67
    339  0564				  -	      .byte	WHITE|K, 52
    340  0564				  -
    341  0564				  -
    342  0564				  -	      ENDIF
    343  0564				  -
    344  0564				  -
    345  0564				  -
    346  0564				  -
    347  0564				  -	      IF	1
    348  0564				  -
    349  0564				  -
    350  0564				  -			;.byte BLACK|R, 97
    351  0564				  -	      .byte	BLACK|K, 98
    352  0564				  -	      .byte	BLACK|BP, 87
    353  0564				  -	      .byte	BLACK|BP, 88
    354  0564				  -	      .byte	BLACK|BP, 89
    355  0564				  -			;    .byte BLACK|B, 76
    356  0564				  -
    357  0564				  -
    358  0564				  -	      .byte	WHITE|R,28
    359  0564				  -	      .byte	WHITE|Q,58
    360  0564				  -			;   .byte WHITE|N,65
    361  0564				  -	      ENDIF
    362  0564				  -
    363  0564				  -	      IF	0
    364  0564				  -			;.byte WHITE|WP, 56
    365  0564				  -
    366  0564				  -
    367  0564				  -	      .byte	BLACK|K, 98
    368  0564				  -
    369  0564				  -
    370  0564				  -	      .byte	WHITE|R,29
    371  0564				  -	      .byte	WHITE|Q,49
    372  0564				  -	      .byte	WHITE|N,65
    373  0564				  -	      ENDIF
    374  0564				  -	      .byte	0	;end
    375  0564				  -
    376  0564					      ENDIF
    377  0564
    378  0564
    379  0564
    380  0564
    381  0564							;---------------------------------------------------------------------------------------------------
    382  0564
      0  0564					      DEF	AdjustMaterialPositionalValue
      1  0564				   SLOT_AdjustMaterialPositionalValue SET	_BANK_SLOT
      2  0564				   BANK_AdjustMaterialPositionalValue SET	SLOT_AdjustMaterialPositionalValue + _CURRENT_BANK
      3  0564				   AdjustMaterialPositionalValue
      4  0564				   TEMPORARY_VAR SET	Overlay
      5  0564				   TEMPORARY_OFFSET SET	0
      6  0564				   VAR_BOUNDARY_AdjustMaterialPositionalValue SET	TEMPORARY_OFFSET
      7  0564				   FUNCTION_NAME SET	AdjustMaterialPositionalValue
    384  0564					      SUBROUTINE
    385  0564
    386  0564							; A move is about to be made, so  adjust material and positional values based on from/to and
    387  0564							; capture.
    388  0564
    389  0564							; First, nominate referencing subroutines so that local variables can be adjusted properly
    390  0564
    391  0564							;TODO REFER negaMax
    392  0564							;TODO REFER MakeMove
    393  0564							;TODO REFER aiMoveIsSelected
      0  0564					      VAR	__originalPiece, 1
      1  0564		       00 a2	   __originalPiece =	TEMPORARY_VAR
      2  0564				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0564
      4  0564				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0564				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0564				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0564					      ENDIF
      8  0564				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0564				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  0564				  -	      ERR
     11  0564					      ENDIF
     12  0564					      LIST	ON
      0  0564					      VAR	__capturedPiece, 1
      1  0564		       00 a3	   __capturedPiece =	TEMPORARY_VAR
      2  0564				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0564
      4  0564				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0564				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0564				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0564					      ENDIF
      8  0564				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0564				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  0564				  -	      ERR
     11  0564					      ENDIF
     12  0564					      LIST	ON
      0  0564					      VEND	AdjustMaterialPositionalValue
      1  0564				  -	      IFNCONST	AdjustMaterialPositionalValue
      2  0564				  -	      ECHO	"Incorrect VEND label", AdjustMaterialPositionalValue
      3  0564				  -	      ERR
      4  0564					      ENDIF
      5  0564		       00 a4	   VAREND_AdjustMaterialPositionalValue =	TEMPORARY_VAR
    397  0564
    398  0564							; fromPiece	 piece doing the move (promoted type)
    399  0564							; fromX12	 current square
    400  0564							; originX12	 starting square
    401  0564							; toX12	 ending square
    402  0564
    403  0564
    404  0564							; get the piece types from the board
    405  0564
    406  0564		       a9 cf		      lda	#RAMBANK_BOARD
    407  0566		       85 3e		      sta	SET_BANK_RAM
    408  0568		       a4 87		      ldy	originX12
    409  056a		       b9 79 fc 	      lda	Board,y
    410  056d		       85 a2		      sta	__originalPiece
    411  056f		       a4 86		      ldy	toX12
    412  0571		       b9 79 fc 	      lda	Board,y
    413  0574		       85 a3		      sta	__capturedPiece
    414  0576
    415  0576							; {
    416  0576							;   adjust the positional value  (originX12 --> fromX12)
    417  0576
    418  0576		       a9 90		      lda	#RAMBANK_BANK_EVAL	;BANK_AddPiecePositionValue
    419  0578		       85 3e		      sta	SET_BANK_RAM
    420  057a
    421  057a
    422  057a							;ldy toX12
    423  057a		       a5 97		      lda	fromPiece
    424  057c		       20 c8 f5 	      jsr	AddPiecePositionValue	; add pos value for new position
    425  057f
    426  057f
    427  057f		       a5 a2		      lda	__originalPiece
    428  0581		       45 97		      eor	fromPiece	; the new piece
    429  0583		       29 0f		      and	#PIECE_MASK
    430  0585		       f0 05		      beq	.same1	; unchanged, so skip
    431  0587
    432  0587		       a5 97		      lda	fromPiece	; new piece
    433  0589							;and #PIECE_MASK
    434  0589							;tay
    435  0589		       20 0b f6 	      jsr	AddPieceMaterialValue
    436  058c
    437  058c				   .same1
    438  058c
    439  058c							; and now the 'subtracts'
    440  058c
      0  058c					      NEGEVAL
      1  058c
      2  058c		       38		      sec
      3  058d		       a9 00		      lda	#0
      4  058f		       e5 90		      sbc	Evaluation
      5  0591		       85 90		      sta	Evaluation
      6  0593		       a9 00		      lda	#0
      7  0595		       e5 91		      sbc	Evaluation+1
      8  0597		       85 91		      sta	Evaluation+1
    442  0599
    443  0599		       a4 87		      ldy	originX12
    444  059b		       a5 a2		      lda	__originalPiece
    445  059d		       20 c8 f5 	      jsr	AddPiecePositionValue	; remove pos value for original position
    446  05a0
    447  05a0
    448  05a0		       a5 a2		      lda	__originalPiece
    449  05a2		       45 97		      eor	fromPiece	; the new piece
    450  05a4		       29 0f		      and	#PIECE_MASK
    451  05a6		       f0 05		      beq	.same2	; unchanged, so skip
    452  05a8
    453  05a8		       a5 a2		      lda	__originalPiece
    454  05aa							;and #PIECE_MASK
    455  05aa							;tay
    456  05aa		       20 0b f6 	      jsr	AddPieceMaterialValue	; remove material for original type
    457  05ad				   .same2
    458  05ad
      0  05ad					      NEGEVAL
      1  05ad
      2  05ad		       38		      sec
      3  05ae		       a9 00		      lda	#0
      4  05b0		       e5 90		      sbc	Evaluation
      5  05b2		       85 90		      sta	Evaluation
      6  05b4		       a9 00		      lda	#0
      7  05b6		       e5 91		      sbc	Evaluation+1
      8  05b8		       85 91		      sta	Evaluation+1
    460  05ba
    461  05ba							; If there's a capture, we adjust the material value
    462  05ba
    463  05ba							;		      lda __capturedPiece
    464  05ba							;		      eor __originalPiece
    465  05ba							;		      bpl .noCapture		      ; special-case capture rook castling onto king
    466  05ba
    467  05ba
    468  05ba		       a5 a3		      lda	__capturedPiece
    469  05bc		       29 0f		      and	#PIECE_MASK
    470  05be		       f0 03		      beq	.noCapture
    471  05c0							;tay
    472  05c0		       20 0b f6 	      jsr	AddPieceMaterialValue	; -other colour = + my colour!
    473  05c3				   .noCapture
    474  05c3
    475  05c3							; }
    476  05c3		       a5 8b		      lda	savedBank
    477  05c5		       85 3f		      sta	SET_BANK
    478  05c7		       60		      rts
    479  05c8
    480  05c8
    481  05c8							;---------------------------------------------------------------------------------------------------
    482  05c8
      0  05c8					      DEF	AddPiecePositionValue
      1  05c8				   SLOT_AddPiecePositionValue SET	_BANK_SLOT
      2  05c8				   BANK_AddPiecePositionValue SET	SLOT_AddPiecePositionValue + _CURRENT_BANK
      3  05c8				   AddPiecePositionValue
      4  05c8				   TEMPORARY_VAR SET	Overlay
      5  05c8				   TEMPORARY_OFFSET SET	0
      6  05c8				   VAR_BOUNDARY_AddPiecePositionValue SET	TEMPORARY_OFFSET
      7  05c8				   FUNCTION_NAME SET	AddPiecePositionValue
    484  05c8					      SUBROUTINE
    485  05c8
      0  05c8					      REFER	AdjustMaterialPositionalValue
      1  05c8					      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  05c8				   TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  05c8					      ENDIF
      0  05c8					      REFER	EnPassantRemovePiece
      1  05c8					      IF	VAREND_EnPassantRemovePiece > TEMPORARY_VAR
      2  05c8				   TEMPORARY_VAR SET	VAREND_EnPassantRemovePiece
      3  05c8					      ENDIF
      0  05c8					      REFER	InitPieceLists
      1  05c8				  -	      IF	VAREND_InitPieceLists > TEMPORARY_VAR
      2  05c8				  -TEMPORARY_VAR SET	VAREND_InitPieceLists
      3  05c8					      ENDIF
      0  05c8					      REFER	negaMax
      1  05c8				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  05c8				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  05c8					      ENDIF
      0  05c8					      REFER	quiesce
      1  05c8				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  05c8				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  05c8					      ENDIF
    491  05c8
      0  05c8					      VAR	__valPtr, 2
      1  05c8		       00 b2	   __valPtr   =	TEMPORARY_VAR
      2  05c8				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  05c8
      4  05c8				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05c8				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05c8				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05c8					      ENDIF
      8  05c8				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  05c8				  -	      ECHO	"Temporary Variable", __valPtr, "overflow!"
     10  05c8				  -	      ERR
     11  05c8					      ENDIF
     12  05c8					      LIST	ON
      0  05c8					      VAR	__valHi, 1
      1  05c8		       00 b4	   __valHi    =	TEMPORARY_VAR
      2  05c8				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  05c8
      4  05c8				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05c8				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05c8				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05c8					      ENDIF
      8  05c8				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  05c8				  -	      ECHO	"Temporary Variable", __valHi, "overflow!"
     10  05c8				  -	      ERR
     11  05c8					      ENDIF
     12  05c8					      LIST	ON
      0  05c8					      VEND	AddPiecePositionValue
      1  05c8				  -	      IFNCONST	AddPiecePositionValue
      2  05c8				  -	      ECHO	"Incorrect VEND label", AddPiecePositionValue
      3  05c8				  -	      ERR
      4  05c8					      ENDIF
      5  05c8		       00 b5	   VAREND_AddPiecePositionValue =	TEMPORARY_VAR
    495  05c8
    496  05c8
    497  05c8							; adds value of square piece is on to the evaluation
    498  05c8							; note to do the subtraction as -( -x + val) == x - val
    499  05c8
    500  05c8							; y = square
    501  05c8							; a = piece type (+flags)
    502  05c8
    503  05c8
    504  05c8
    505  05c8		       c9 80		      cmp	#128	; black = CS
    506  05ca		       29 0f		      and	#PIECE_MASK
    507  05cc		       aa		      tax
    508  05cd
    509  05cd							; black pieces flip rows so we can use the same eval tables
    510  05cd
    511  05cd		       98		      tya
    512  05ce		       90 03		      bcc	.white
    513  05d0		       b9 1e f6 	      lda	FlipSquareIndex,y
    514  05d3							;clc
    515  05d3				   .white
    516  05d3		       7d 10 f8 	      adc	PosValVecLO,x
    517  05d6		       85 b2		      sta	__valPtr
    518  05d8		       bd 18 f8 	      lda	PosValVecHI,x
    519  05db		       69 00		      adc	#0
    520  05dd		       85 b3		      sta	__valPtr+1
    521  05df
    522  05df		       a0 00		      ldy	#0
    523  05e1		       84 b4		      sty	__valHi
    524  05e3		       b1 b2		      lda	(__valPtr),y
    525  05e5		       10 02		      bpl	.sum
    526  05e7		       c6 b4		      dec	__valHi
    527  05e9
    528  05e9		       18	   .sum       clc
    529  05ea		       65 90		      adc	Evaluation
    530  05ec		       85 90		      sta	Evaluation
    531  05ee		       a5 91		      lda	Evaluation+1
    532  05f0		       65 b4		      adc	__valHi
    533  05f2		       85 91		      sta	Evaluation+1
    534  05f4		       60		      rts
    535  05f5
    536  05f5
    537  05f5
    538  05f5							;---------------------------------------------------------------------------------------------------
    539  05f5
      0  05f5					      DEF	EnPassantRemovePiece
      1  05f5				   SLOT_EnPassantRemovePiece SET	_BANK_SLOT
      2  05f5				   BANK_EnPassantRemovePiece SET	SLOT_EnPassantRemovePiece + _CURRENT_BANK
      3  05f5				   EnPassantRemovePiece
      4  05f5				   TEMPORARY_VAR SET	Overlay
      5  05f5				   TEMPORARY_OFFSET SET	0
      6  05f5				   VAR_BOUNDARY_EnPassantRemovePiece SET	TEMPORARY_OFFSET
      7  05f5				   FUNCTION_NAME SET	EnPassantRemovePiece
    541  05f5					      SUBROUTINE
    542  05f5
    543  05f5							;TODO REFER MakeMove
    544  05f5					      IF	ENPASSANT_ENABLED
      0  05f5					      REFER	EnPassantCheck
      1  05f5					      IF	VAREND_EnPassantCheck > TEMPORARY_VAR
      2  05f5				   TEMPORARY_VAR SET	VAREND_EnPassantCheck
      3  05f5					      ENDIF
    546  05f5					      ENDIF
      0  05f5					      VAR	__y, 1
      1  05f5		       00 b0	   __y	      =	TEMPORARY_VAR
      2  05f5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  05f5
      4  05f5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05f5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05f5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05f5					      ENDIF
      8  05f5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  05f5				  -	      ECHO	"Temporary Variable", __y, "overflow!"
     10  05f5				  -	      ERR
     11  05f5					      ENDIF
     12  05f5					      LIST	ON
      0  05f5					      VAR	__col, 1
      1  05f5		       00 b1	   __col      =	TEMPORARY_VAR
      2  05f5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  05f5
      4  05f5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05f5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05f5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05f5					      ENDIF
      8  05f5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  05f5				  -	      ECHO	"Temporary Variable", __col, "overflow!"
     10  05f5				  -	      ERR
     11  05f5					      ENDIF
     12  05f5					      LIST	ON
      0  05f5					      VEND	EnPassantRemovePiece
      1  05f5				  -	      IFNCONST	EnPassantRemovePiece
      2  05f5				  -	      ECHO	"Incorrect VEND label", EnPassantRemovePiece
      3  05f5				  -	      ERR
      4  05f5					      ENDIF
      5  05f5		       00 b2	   VAREND_EnPassantRemovePiece =	TEMPORARY_VAR
    550  05f5
    551  05f5
    552  05f5							; Based on piece square, adjust material and position value with piece deleted
    553  05f5							; y = piece square
    554  05f5
    555  05f5		       84 b0		      sty	__y
    556  05f7
    557  05f7		       a9 cf		      lda	#RAMBANK_BOARD
    558  05f9		       85 3e		      sta	SET_BANK_RAM
    559  05fb		       b9 79 fc 	      lda	Board,y
    560  05fe		       85 b1		      sta	__col
    561  0600		       20 0b f6 	      jsr	AddPieceMaterialValue	; adding for opponent = taking
    562  0603
    563  0603		       a5 b1		      lda	__col
    564  0605		       a4 b0		      ldy	__y
    565  0607		       20 c8 f5 	      jsr	AddPiecePositionValue	; adding for opponent = taking
    566  060a
    567  060a		       60		      rts
    568  060b
    569  060b
    570  060b							;---------------------------------------------------------------------------------------------------
    571  060b
      0  060b					      DEF	AddPieceMaterialValue
      1  060b				   SLOT_AddPieceMaterialValue SET	_BANK_SLOT
      2  060b				   BANK_AddPieceMaterialValue SET	SLOT_AddPieceMaterialValue + _CURRENT_BANK
      3  060b				   AddPieceMaterialValue
      4  060b				   TEMPORARY_VAR SET	Overlay
      5  060b				   TEMPORARY_OFFSET SET	0
      6  060b				   VAR_BOUNDARY_AddPieceMaterialValue SET	TEMPORARY_OFFSET
      7  060b				   FUNCTION_NAME SET	AddPieceMaterialValue
    573  060b					      SUBROUTINE
    574  060b
      0  060b					      REFER	AdjustMaterialPositionalValue
      1  060b					      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  060b				   TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  060b					      ENDIF
      0  060b					      REFER	InitialisePieceSquares
      1  060b					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  060b				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  060b					      ENDIF
      0  060b					      REFER	EnPassantRemovePiece
      1  060b					      IF	VAREND_EnPassantRemovePiece > TEMPORARY_VAR
      2  060b				   TEMPORARY_VAR SET	VAREND_EnPassantRemovePiece
      3  060b					      ENDIF
      0  060b					      REFER	InitPieceLists
      1  060b				  -	      IF	VAREND_InitPieceLists > TEMPORARY_VAR
      2  060b				  -TEMPORARY_VAR SET	VAREND_InitPieceLists
      3  060b					      ENDIF
      0  060b					      VEND	AddPieceMaterialValue
      1  060b				  -	      IFNCONST	AddPieceMaterialValue
      2  060b				  -	      ECHO	"Incorrect VEND label", AddPieceMaterialValue
      3  060b				  -	      ERR
      4  060b					      ENDIF
      5  060b		       00 b2	   VAREND_AddPieceMaterialValue =	TEMPORARY_VAR
    580  060b
    581  060b							; Adjust the material score based on the piece
    582  060b							; a = piece type + flags
    583  060b
    584  060b		       29 0f		      and	#PIECE_MASK
    585  060d		       a8		      tay
    586  060e
    587  060e		       18		      clc
    588  060f		       b9 00 f8 	      lda	PieceValueLO,y
    589  0612		       65 90		      adc	Evaluation
    590  0614		       85 90		      sta	Evaluation
    591  0616		       b9 08 f8 	      lda	PieceValueHI,y
    592  0619		       65 91		      adc	Evaluation+1
    593  061b		       85 91		      sta	Evaluation+1
    594  061d		       60		      rts
    595  061e
    596  061e
    597  061e
    598  061e
    599  061e				  -	      IF	0
    600  061e				  -	      DEF	IncVal
    601  061e				  -	      SUBROUTINE
    602  061e				  -
    603  061e				  -	      ldx	#99
    604  061e				  -.higher    clc
    605  061e				  -	      lda@RAM	PositionalValue_PAWN_BLACK,x
    606  061e				  -	      adc	#10
    607  061e				  -	      cmp	#$7F
    608  061e				  -	      bcc	.norm
    609  061e				  -	      lda	#$7f
    610  061e				  -.norm      sta@RAM	PositionalValue_PAWN_BLACK,x
    611  061e				  -	      dex
    612  061e				  -	      bpl	.higher
    613  061e				  -	      rts
    614  061e					      ENDIF
    615  061e							;---------------------------------------------------------------------------------------------------
    616  061e
      0  061e					      ALLOCATE	FlipSquareIndex, 100
      0  061e					      OPTIONAL_PAGEBREAK	"Table", 100
     12  061e					      LIST	ON
      0  061e					      DEF	FlipSquareIndex
      1  061e				   SLOT_FlipSquareIndex SET	_BANK_SLOT
      2  061e				   BANK_FlipSquareIndex SET	SLOT_FlipSquareIndex + _CURRENT_BANK
      3  061e				   FlipSquareIndex
      4  061e				   TEMPORARY_VAR SET	Overlay
      5  061e				   TEMPORARY_OFFSET SET	0
      6  061e				   VAR_BOUNDARY_FlipSquareIndex SET	TEMPORARY_OFFSET
      7  061e				   FUNCTION_NAME SET	FlipSquareIndex
    618  061e
    619  061e		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    620  0628		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    621  0632
    622  0632				   .SQBASE    SET	90-1
    623  0632					      REPEAT	8
    624  0632		       00 00		      .byte.b	0,0
    625  0632				   .SQX       SET	2
    626  0634					      REPEAT	8
    627  0634		       5b		      .byte.b	(.SQBASE+.SQX)
    628  0634				   .SQX       SET	.SQX + 1
    626  0634					      REPEND
    627  0635		       5c		      .byte.b	(.SQBASE+.SQX)
    628  0635				   .SQX       SET	.SQX + 1
    626  0635					      REPEND
    627  0636		       5d		      .byte.b	(.SQBASE+.SQX)
    628  0636				   .SQX       SET	.SQX + 1
    626  0636					      REPEND
    627  0637		       5e		      .byte.b	(.SQBASE+.SQX)
    628  0637				   .SQX       SET	.SQX + 1
    626  0637					      REPEND
    627  0638		       5f		      .byte.b	(.SQBASE+.SQX)
    628  0638				   .SQX       SET	.SQX + 1
    626  0638					      REPEND
    627  0639		       60		      .byte.b	(.SQBASE+.SQX)
    628  0639				   .SQX       SET	.SQX + 1
    626  0639					      REPEND
    627  063a		       61		      .byte.b	(.SQBASE+.SQX)
    628  063a				   .SQX       SET	.SQX + 1
    626  063a					      REPEND
    627  063b		       62		      .byte.b	(.SQBASE+.SQX)
    628  063b				   .SQX       SET	.SQX + 1
    629  063c					      REPEND
    630  063c				   .SQBASE    SET	.SQBASE - 10
    623  063c					      REPEND
    624  063c		       00 00		      .byte.b	0,0
    625  063c				   .SQX       SET	2
    626  063e					      REPEAT	8
    627  063e		       51		      .byte.b	(.SQBASE+.SQX)
    628  063e				   .SQX       SET	.SQX + 1
    626  063e					      REPEND
    627  063f		       52		      .byte.b	(.SQBASE+.SQX)
    628  063f				   .SQX       SET	.SQX + 1
    626  063f					      REPEND
    627  0640		       53		      .byte.b	(.SQBASE+.SQX)
    628  0640				   .SQX       SET	.SQX + 1
    626  0640					      REPEND
    627  0641		       54		      .byte.b	(.SQBASE+.SQX)
    628  0641				   .SQX       SET	.SQX + 1
    626  0641					      REPEND
    627  0642		       55		      .byte.b	(.SQBASE+.SQX)
    628  0642				   .SQX       SET	.SQX + 1
    626  0642					      REPEND
    627  0643		       56		      .byte.b	(.SQBASE+.SQX)
    628  0643				   .SQX       SET	.SQX + 1
    626  0643					      REPEND
    627  0644		       57		      .byte.b	(.SQBASE+.SQX)
    628  0644				   .SQX       SET	.SQX + 1
    626  0644					      REPEND
    627  0645		       58		      .byte.b	(.SQBASE+.SQX)
    628  0645				   .SQX       SET	.SQX + 1
    629  0646					      REPEND
    630  0646				   .SQBASE    SET	.SQBASE - 10
    623  0646					      REPEND
    624  0646		       00 00		      .byte.b	0,0
    625  0646				   .SQX       SET	2
    626  0648					      REPEAT	8
    627  0648		       47		      .byte.b	(.SQBASE+.SQX)
    628  0648				   .SQX       SET	.SQX + 1
    626  0648					      REPEND
    627  0649		       48		      .byte.b	(.SQBASE+.SQX)
    628  0649				   .SQX       SET	.SQX + 1
    626  0649					      REPEND
    627  064a		       49		      .byte.b	(.SQBASE+.SQX)
    628  064a				   .SQX       SET	.SQX + 1
    626  064a					      REPEND
    627  064b		       4a		      .byte.b	(.SQBASE+.SQX)
    628  064b				   .SQX       SET	.SQX + 1
    626  064b					      REPEND
    627  064c		       4b		      .byte.b	(.SQBASE+.SQX)
    628  064c				   .SQX       SET	.SQX + 1
    626  064c					      REPEND
    627  064d		       4c		      .byte.b	(.SQBASE+.SQX)
    628  064d				   .SQX       SET	.SQX + 1
    626  064d					      REPEND
    627  064e		       4d		      .byte.b	(.SQBASE+.SQX)
    628  064e				   .SQX       SET	.SQX + 1
    626  064e					      REPEND
    627  064f		       4e		      .byte.b	(.SQBASE+.SQX)
    628  064f				   .SQX       SET	.SQX + 1
    629  0650					      REPEND
    630  0650				   .SQBASE    SET	.SQBASE - 10
    623  0650					      REPEND
    624  0650		       00 00		      .byte.b	0,0
    625  0650				   .SQX       SET	2
    626  0652					      REPEAT	8
    627  0652		       3d		      .byte.b	(.SQBASE+.SQX)
    628  0652				   .SQX       SET	.SQX + 1
    626  0652					      REPEND
    627  0653		       3e		      .byte.b	(.SQBASE+.SQX)
    628  0653				   .SQX       SET	.SQX + 1
    626  0653					      REPEND
    627  0654		       3f		      .byte.b	(.SQBASE+.SQX)
    628  0654				   .SQX       SET	.SQX + 1
    626  0654					      REPEND
    627  0655		       40		      .byte.b	(.SQBASE+.SQX)
    628  0655				   .SQX       SET	.SQX + 1
    626  0655					      REPEND
    627  0656		       41		      .byte.b	(.SQBASE+.SQX)
    628  0656				   .SQX       SET	.SQX + 1
    626  0656					      REPEND
    627  0657		       42		      .byte.b	(.SQBASE+.SQX)
    628  0657				   .SQX       SET	.SQX + 1
    626  0657					      REPEND
    627  0658		       43		      .byte.b	(.SQBASE+.SQX)
    628  0658				   .SQX       SET	.SQX + 1
    626  0658					      REPEND
    627  0659		       44		      .byte.b	(.SQBASE+.SQX)
    628  0659				   .SQX       SET	.SQX + 1
    629  065a					      REPEND
    630  065a				   .SQBASE    SET	.SQBASE - 10
    623  065a					      REPEND
    624  065a		       00 00		      .byte.b	0,0
    625  065a				   .SQX       SET	2
    626  065c					      REPEAT	8
    627  065c		       33		      .byte.b	(.SQBASE+.SQX)
    628  065c				   .SQX       SET	.SQX + 1
    626  065c					      REPEND
    627  065d		       34		      .byte.b	(.SQBASE+.SQX)
    628  065d				   .SQX       SET	.SQX + 1
    626  065d					      REPEND
    627  065e		       35		      .byte.b	(.SQBASE+.SQX)
    628  065e				   .SQX       SET	.SQX + 1
    626  065e					      REPEND
    627  065f		       36		      .byte.b	(.SQBASE+.SQX)
    628  065f				   .SQX       SET	.SQX + 1
    626  065f					      REPEND
    627  0660		       37		      .byte.b	(.SQBASE+.SQX)
    628  0660				   .SQX       SET	.SQX + 1
    626  0660					      REPEND
    627  0661		       38		      .byte.b	(.SQBASE+.SQX)
    628  0661				   .SQX       SET	.SQX + 1
    626  0661					      REPEND
    627  0662		       39		      .byte.b	(.SQBASE+.SQX)
    628  0662				   .SQX       SET	.SQX + 1
    626  0662					      REPEND
    627  0663		       3a		      .byte.b	(.SQBASE+.SQX)
    628  0663				   .SQX       SET	.SQX + 1
    629  0664					      REPEND
    630  0664				   .SQBASE    SET	.SQBASE - 10
    623  0664					      REPEND
    624  0664		       00 00		      .byte.b	0,0
    625  0664				   .SQX       SET	2
    626  0666					      REPEAT	8
    627  0666		       29		      .byte.b	(.SQBASE+.SQX)
    628  0666				   .SQX       SET	.SQX + 1
    626  0666					      REPEND
    627  0667		       2a		      .byte.b	(.SQBASE+.SQX)
    628  0667				   .SQX       SET	.SQX + 1
    626  0667					      REPEND
    627  0668		       2b		      .byte.b	(.SQBASE+.SQX)
    628  0668				   .SQX       SET	.SQX + 1
    626  0668					      REPEND
    627  0669		       2c		      .byte.b	(.SQBASE+.SQX)
    628  0669				   .SQX       SET	.SQX + 1
    626  0669					      REPEND
    627  066a		       2d		      .byte.b	(.SQBASE+.SQX)
    628  066a				   .SQX       SET	.SQX + 1
    626  066a					      REPEND
    627  066b		       2e		      .byte.b	(.SQBASE+.SQX)
    628  066b				   .SQX       SET	.SQX + 1
    626  066b					      REPEND
    627  066c		       2f		      .byte.b	(.SQBASE+.SQX)
    628  066c				   .SQX       SET	.SQX + 1
    626  066c					      REPEND
    627  066d		       30		      .byte.b	(.SQBASE+.SQX)
    628  066d				   .SQX       SET	.SQX + 1
    629  066e					      REPEND
    630  066e				   .SQBASE    SET	.SQBASE - 10
    623  066e					      REPEND
    624  066e		       00 00		      .byte.b	0,0
    625  066e				   .SQX       SET	2
    626  0670					      REPEAT	8
    627  0670		       1f		      .byte.b	(.SQBASE+.SQX)
    628  0670				   .SQX       SET	.SQX + 1
    626  0670					      REPEND
    627  0671		       20		      .byte.b	(.SQBASE+.SQX)
    628  0671				   .SQX       SET	.SQX + 1
    626  0671					      REPEND
    627  0672		       21		      .byte.b	(.SQBASE+.SQX)
    628  0672				   .SQX       SET	.SQX + 1
    626  0672					      REPEND
    627  0673		       22		      .byte.b	(.SQBASE+.SQX)
    628  0673				   .SQX       SET	.SQX + 1
    626  0673					      REPEND
    627  0674		       23		      .byte.b	(.SQBASE+.SQX)
    628  0674				   .SQX       SET	.SQX + 1
    626  0674					      REPEND
    627  0675		       24		      .byte.b	(.SQBASE+.SQX)
    628  0675				   .SQX       SET	.SQX + 1
    626  0675					      REPEND
    627  0676		       25		      .byte.b	(.SQBASE+.SQX)
    628  0676				   .SQX       SET	.SQX + 1
    626  0676					      REPEND
    627  0677		       26		      .byte.b	(.SQBASE+.SQX)
    628  0677				   .SQX       SET	.SQX + 1
    629  0678					      REPEND
    630  0678				   .SQBASE    SET	.SQBASE - 10
    623  0678					      REPEND
    624  0678		       00 00		      .byte.b	0,0
    625  0678				   .SQX       SET	2
    626  067a					      REPEAT	8
    627  067a		       15		      .byte.b	(.SQBASE+.SQX)
    628  067a				   .SQX       SET	.SQX + 1
    626  067a					      REPEND
    627  067b		       16		      .byte.b	(.SQBASE+.SQX)
    628  067b				   .SQX       SET	.SQX + 1
    626  067b					      REPEND
    627  067c		       17		      .byte.b	(.SQBASE+.SQX)
    628  067c				   .SQX       SET	.SQX + 1
    626  067c					      REPEND
    627  067d		       18		      .byte.b	(.SQBASE+.SQX)
    628  067d				   .SQX       SET	.SQX + 1
    626  067d					      REPEND
    627  067e		       19		      .byte.b	(.SQBASE+.SQX)
    628  067e				   .SQX       SET	.SQX + 1
    626  067e					      REPEND
    627  067f		       1a		      .byte.b	(.SQBASE+.SQX)
    628  067f				   .SQX       SET	.SQX + 1
    626  067f					      REPEND
    627  0680		       1b		      .byte.b	(.SQBASE+.SQX)
    628  0680				   .SQX       SET	.SQX + 1
    626  0680					      REPEND
    627  0681		       1c		      .byte.b	(.SQBASE+.SQX)
    628  0681				   .SQX       SET	.SQX + 1
    629  0682					      REPEND
    630  0682				   .SQBASE    SET	.SQBASE - 10
    631  0682					      REPEND
    632  0682
    633  0682
    634  0682							;---------------------------------------------------------------------------------------------------
    635  0682
      0  0682					      CHECK_BANK_SIZE	"BANK_1"
      1  0682		       02 82	   .TEMP      =	* - _BANK_START
 BANK_1 (1K) SIZE =  $282 , FREE= $17e
      2  0682					      ECHO	"BANK_1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  0682				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  0682				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_1", " size=", * - ORIGIN
      5  0682				  -	      ERR
      6  0682					      ENDIF
    637  0682
    638  0682							;---------------------------------------------------------------------------------------------------
    639  0682							; EOF
------- FILE ./chess.asm
------- FILE BANK_ROM_SHADOW_SCREEN.asm LEVEL 2 PASS 4
      0  0682					      include	"BANK_ROM_SHADOW_SCREEN.asm"
      1  0682
      0  0682					      SLOT	2
      1  0682				  -	      IF	(2 < 0) || (2 > 3)
      2  0682				  -	      ECHO	"Illegal bank address/segment location", 2
      3  0682				  -	      ERR
      4  0682					      ENDIF
      5  0682				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  0682				   _BANK_SLOT SET	2 * 64
      0  0682					      NEWBANK	BITMAP
      1  09a6 ????				      SEG	BITMAP
      2  0800					      ORG	_ORIGIN
      3  0800					      RORG	_BANK_ADDRESS_ORIGIN
      4  0800				   _BANK_START SET	*
      5  0800				   BITMAP_START SET	*
      6  0800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0800				   BITMAP     SET	_BANK_SLOT + _CURRENT_BANK
      8  0800				   _ORIGIN    SET	_ORIGIN + 1024
      4  0800
      5  0800							; These equates allow revectoring (address offset) if the RAM slot is not the same as the SHADOW slot
      6  0800
      7  0800		       f8 00	   ChessBitmap =	SHADOW_ChessBitmap
      8  0800
      9  0800		       f8 00	   ChessBitmap0 =	SHADOW_ChessBitmap0
     10  0800		       f8 18	   ChessBitmap1 =	SHADOW_ChessBitmap1
     11  0800		       f8 30	   ChessBitmap2 =	SHADOW_ChessBitmap2
     12  0800		       f8 48	   ChessBitmap3 =	SHADOW_ChessBitmap3
     13  0800		       f8 60	   ChessBitmap4 =	SHADOW_ChessBitmap4
     14  0800		       f8 78	   ChessBitmap5 =	SHADOW_ChessBitmap5
     15  0800
     16  0800							; Template bank for a SINGLE ROW of the chessboard display.
     17  0800							; There are 8x of these.
     18  0800							; The bank contains the definition of the bitmap, and also the code to draw the bitmap
     19  0800							; The bank is copied from ROM into RAM at startup.
     20  0800							; The draw switches between consecutive row banks, with the last returning
     21  0800							; we effectively have 1K
     22  0800							;---------------------------------------------------------------------------------------------------
     23  0800
     24  0800		       00 72	   COLOUR_LINE_1 =	$72
     25  0800		       00 24	   COLOUR_LINE_2 =	$24
     26  0800		       00 d4	   COLOUR_LINE_3 =	$D4
     27  0800		       00 00	   BACKGCOL   =	$00
     28  0800
     29  0800
     30  0800		       00 90	   ROW_BITMAP_SIZE =	6 * 24	; PF0/PF1/PF2/(PF0)/(PF1)/(PF2) x 8 ICC pixels
     31  0800
     32  0800
      0  0800					      ALLOCATE	SHADOW_ChessBitmap, ROW_BITMAP_SIZE
      0  0800					      OPTIONAL_PAGEBREAK	"Table", ROW_BITMAP_SIZE
     12  0800					      LIST	ON
      0  0800					      DEF	SHADOW_ChessBitmap
      1  0800				   SLOT_SHADOW_ChessBitmap SET	_BANK_SLOT
      2  0800				   BANK_SHADOW_ChessBitmap SET	SLOT_SHADOW_ChessBitmap + _CURRENT_BANK
      3  0800				   SHADOW_ChessBitmap
      4  0800				   TEMPORARY_VAR SET	Overlay
      5  0800				   TEMPORARY_OFFSET SET	0
      6  0800				   VAR_BOUNDARY_SHADOW_ChessBitmap SET	TEMPORARY_OFFSET
      7  0800				   FUNCTION_NAME SET	SHADOW_ChessBitmap
     34  0800		       00 00 00 00*SHADOW_ChessBitmap0 ds	24
     35  0818		       00 00 00 00*SHADOW_ChessBitmap1 ds	24
     36  0830		       00 00 00 00*SHADOW_ChessBitmap2 ds	24
     37  0848		       00 00 00 00*SHADOW_ChessBitmap3 ds	24
     38  0860		       00 00 00 00*SHADOW_ChessBitmap4 ds	24
     39  0878		       00 00 00 00*SHADOW_ChessBitmap5 ds	24
     40  0890
      0  0890					      ALLOCATE	BlankSprite, 8
      0  0890					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0890					      LIST	ON
      0  0890					      DEF	BlankSprite
      1  0890				   SLOT_BlankSprite SET	_BANK_SLOT
      2  0890				   BANK_BlankSprite SET	SLOT_BlankSprite + _CURRENT_BANK
      3  0890				   BlankSprite
      4  0890				   TEMPORARY_VAR SET	Overlay
      5  0890				   TEMPORARY_OFFSET SET	0
      6  0890				   VAR_BOUNDARY_BlankSprite SET	TEMPORARY_OFFSET
      7  0890				   FUNCTION_NAME SET	BlankSprite
     42  0890		       00 00 00 00*	      ds	8, 0
     43  0898
      0  0898					      ALLOCATE	SpriteBuffer, 8
      0  0898					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0898					      LIST	ON
      0  0898					      DEF	SpriteBuffer
      1  0898				   SLOT_SpriteBuffer SET	_BANK_SLOT
      2  0898				   BANK_SpriteBuffer SET	SLOT_SpriteBuffer + _CURRENT_BANK
      3  0898				   SpriteBuffer
      4  0898				   TEMPORARY_VAR SET	Overlay
      5  0898				   TEMPORARY_OFFSET SET	0
      6  0898				   VAR_BOUNDARY_SpriteBuffer SET	TEMPORARY_OFFSET
      7  0898				   FUNCTION_NAME SET	SpriteBuffer
     45  0898				   SpriteBuffer2
     46  0898		       f8		      .byte.b	%11111000
     47  0899		       f8		      .byte.b	%11111000
     48  089a		       f8		      .byte.b	%11111000
     49  089b		       f8		      .byte.b	%11111000
     50  089c		       f8		      .byte.b	%11111000
     51  089d		       f8		      .byte.b	%11111000
     52  089e		       f8		      .byte.b	%11111000
     53  089f		       f8		      .byte.b	%11111000
     54  08a0
     55  08a0				  -	      IF	0
     56  08a0				  -	      ALLOCATE	BackupBitmap, ROW_BITMAP_SIZE
     57  08a0				  -	      ds	ROW_BITMAP_SIZE, 0
     58  08a0					      ENDIF
     59  08a0
     60  08a0							;---------------------------------------------------------------------------------------------------
     61  08a0
     62  0900		       00 00 00 00*	      ALIGN	256
     63  0900					      SUBROUTINE
     64  0900
      0  0900					      REFER	StartupBankReset
      1  0900				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0900				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0900					      ENDIF
     66  0900				   __dummy
      0  0900					      VEND	__dummy
      1  0900				  -	      IFNCONST	__dummy
      2  0900				  -	      ECHO	"Incorrect VEND label", __dummy
      3  0900				  -	      ERR
      4  0900					      ENDIF
      5  0900		       00 a2	   VAREND___dummy =	TEMPORARY_VAR
     68  0900
     69  0900							; x = row # (and bank#)
     70  0900
     71  0900				   .endline
     72  0900
     73  0900							;@59
     74  0900
     75  0900							; The following 'inx' is replaced in the LAST row bank with a 'RTS', thus ending the draw loop
     76  0900							; Note that the other 7 row banks are unmodified (keeping the 'inx')
     77  0900				   SELFMOD_RTS_ON_LAST_ROW
     78  0900
     79  0900		       e8		      inx		; 2
     80  0901		       86 3e		      stx	SET_BANK_RAM	; 3 @64     BANK switch to next row
     81  0903
      0  0903					      DEF	DrawRow
      1  0903				   SLOT_DrawRow SET	_BANK_SLOT
      2  0903				   BANK_DrawRow SET	SLOT_DrawRow + _CURRENT_BANK
      3  0903				   DrawRow
      4  0903				   TEMPORARY_VAR SET	Overlay
      5  0903				   TEMPORARY_OFFSET SET	0
      6  0903				   VAR_BOUNDARY_DrawRow SET	TEMPORARY_OFFSET
      7  0903				   FUNCTION_NAME SET	DrawRow
     83  0903
     84  0903							;@64
     85  0903		       a0 07		      ldy	#7	; 2
     86  0905		       10 3b		      bpl	.dl2	; 3   (must be 69 here)
     87  0907
     88  0907							;@58...
     89  0907
     90  0907				   .l3
     91  0907
     92  0907		       b9 a8 f8    SMSPRITE16_0 lda	SpriteBuffer+16,y	; 4
     93  090a		       85 5b		      sta	GRP0	; 3
     94  090c		       b9 a8 f8    SMSPRITE16_1 lda	SpriteBuffer2+16,y	; 4
     95  090f		       85 5c		      sta	GRP1	; 3
     96  0911
     97  0911							;@-4
     98  0911
     99  0911		       a9 72		      lda	#COLOUR_LINE_1	;#$94			  ; 2
    100  0913		       85 48		      sta	COLUPF	; 3 @1
    101  0915
    102  0915		       b9 10 f8 	      lda	ChessBitmap0+16,y	; 4
    103  0918		       85 4d		      sta	PF0	; 3
    104  091a		       b9 28 f8 	      lda	ChessBitmap1+16,y	; 4
    105  091d		       85 4e		      sta	PF1	; 3
    106  091f		       b9 40 f8 	      lda	ChessBitmap2+16,y	; 4
    107  0922		       85 4f		      sta	PF2	; 3 @22
    108  0924
      0  0924					      SLEEP	6	; 6 @28
      1  0924				   .CYCLES    SET	6
      2  0924
      3  0924				  -	      IF	.CYCLES < 2
      4  0924				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0924				  -	      ERR
      6  0924					      ENDIF
      7  0924
      8  0924				  -	      IF	.CYCLES & 1
      9  0924				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0924				  -	      nop	0
     11  0924				  -	      ELSE
     12  0924				  -	      bit	VSYNC
     13  0924				  -	      ENDIF
     14  0924				  -.CYCLES    SET	.CYCLES - 3
     15  0924					      ENDIF
     16  0924
     17  0924					      REPEAT	.CYCLES / 2
     18  0924		       ea		      nop
     17  0924					      REPEND
     18  0925		       ea		      nop
     17  0925					      REPEND
     18  0926		       ea		      nop
     19  0927					      REPEND
    110  0927
    111  0927		       b9 58 f8 	      lda	ChessBitmap3+16,y	; 4
    112  092a		       85 4d		      sta	PF0	; 3
    113  092c		       b9 70 f8 	      lda	ChessBitmap4+16,y	; 4
    114  092f		       85 4e		      sta	PF1	; 3
    115  0931		       b9 88 f8 	      lda	ChessBitmap5+16,y	; 4
    116  0934		       8d 4f 00 	      sta.w	PF2	; 4 @50
    117  0937
      0  0937					      SLEEP	4	; 4
      1  0937				   .CYCLES    SET	4
      2  0937
      3  0937				  -	      IF	.CYCLES < 2
      4  0937				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0937				  -	      ERR
      6  0937					      ENDIF
      7  0937
      8  0937				  -	      IF	.CYCLES & 1
      9  0937				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0937				  -	      nop	0
     11  0937				  -	      ELSE
     12  0937				  -	      bit	VSYNC
     13  0937				  -	      ENDIF
     14  0937				  -.CYCLES    SET	.CYCLES - 3
     15  0937					      ENDIF
     16  0937
     17  0937					      REPEAT	.CYCLES / 2
     18  0937		       ea		      nop
     17  0937					      REPEND
     18  0938		       ea		      nop
     19  0939					      REPEND
    119  0939
    120  0939		       88		      dey		; 2
    121  093a		       30 c4		      bmi	.endline	; 2 (3)
    122  093c
    123  093c							;@57
    124  093c				   .drawLine
    125  093c
      0  093c					      SLEEP	11
      1  093c				   .CYCLES    SET	11
      2  093c
      3  093c				  -	      IF	.CYCLES < 2
      4  093c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  093c				  -	      ERR
      6  093c					      ENDIF
      7  093c
      8  093c					      IF	.CYCLES & 1
      9  093c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  093c		       04 00		      nop	0
     11  093e				  -	      ELSE
     12  093e				  -	      bit	VSYNC
     13  093e					      ENDIF
     14  093e				   .CYCLES    SET	.CYCLES - 3
     15  093e					      ENDIF
     16  093e
     17  093e					      REPEAT	.CYCLES / 2
     18  093e		       ea		      nop
     17  093e					      REPEND
     18  093f		       ea		      nop
     17  093f					      REPEND
     18  0940		       ea		      nop
     17  0940					      REPEND
     18  0941		       ea		      nop
     19  0942					      REPEND
    127  0942
    128  0942				   .dl2
    129  0942		       b9 98 f8    SMSPRITE0_0 lda	SpriteBuffer,y	; 4
    130  0945		       85 5b		      sta	GRP0	; 3
    131  0947		       b9 98 f8    SMSPRITE0_1 lda	SpriteBuffer2,y	; 4
    132  094a		       85 5c		      sta	GRP1	; 3
    133  094c
    134  094c							;@7
    135  094c
    136  094c		       a9 24		      lda	#COLOUR_LINE_2	;#$4A			  ; 2
    137  094e		       85 48		      sta	COLUPF	; 3 @12
    138  0950
    139  0950		       b9 00 f8 	      lda	ChessBitmap0,y	; 4
    140  0953		       85 4d		      sta	PF0	; 3
    141  0955		       b9 18 f8 	      lda	ChessBitmap1,y	; 4
    142  0958		       85 4e		      sta	PF1	; 3
    143  095a		       b9 30 f8 	      lda	ChessBitmap2,y	; 4
    144  095d		       85 4f		      sta	PF2	; 3 @33
    145  095f
      0  095f					      SLEEP	3	; 3 @36
      1  095f				   .CYCLES    SET	3
      2  095f
      3  095f				  -	      IF	.CYCLES < 2
      4  095f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  095f				  -	      ERR
      6  095f					      ENDIF
      7  095f
      8  095f					      IF	.CYCLES & 1
      9  095f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  095f		       04 00		      nop	0
     11  0961				  -	      ELSE
     12  0961				  -	      bit	VSYNC
     13  0961					      ENDIF
     14  0961				   .CYCLES    SET	.CYCLES - 3
     15  0961					      ENDIF
     16  0961
     17  0961				  -	      REPEAT	.CYCLES / 2
     18  0961				  -	      nop
     19  0961					      REPEND
    147  0961
    148  0961		       b9 48 f8 	      lda	ChessBitmap3,y	; 4
    149  0964		       85 4d		      sta	PF0	; 3
    150  0966		       b9 60 f8 	      lda	ChessBitmap4,y	; 4
    151  0969		       85 4e		      sta	PF1	; 3
    152  096b		       b9 78 f8 	      lda	ChessBitmap5,y	; 4
    153  096e		       85 4f		      sta	PF2	; 3 @57
    154  0970
      0  0970					      SLEEP	5
      1  0970				   .CYCLES    SET	5
      2  0970
      3  0970				  -	      IF	.CYCLES < 2
      4  0970				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0970				  -	      ERR
      6  0970					      ENDIF
      7  0970
      8  0970					      IF	.CYCLES & 1
      9  0970					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0970		       04 00		      nop	0
     11  0972				  -	      ELSE
     12  0972				  -	      bit	VSYNC
     13  0972					      ENDIF
     14  0972				   .CYCLES    SET	.CYCLES - 3
     15  0972					      ENDIF
     16  0972
     17  0972					      REPEAT	.CYCLES / 2
     18  0972		       ea		      nop
     19  0973					      REPEND
    156  0973
    157  0973		       b9 a0 f8    SMSPRITE8_0 lda	SpriteBuffer+8,y	; 4
    158  0976		       85 5b		      sta	GRP0	; 3
    159  0978		       b9 a0 f8    SMSPRITE8_1 lda	SpriteBuffer2+8,y	; 4
    160  097b		       85 5c		      sta	GRP1	; 3
    161  097d
    162  097d							;@0
    163  097d		       a9 d4		      lda	#COLOUR_LINE_3	;#$28			  ; 2
    164  097f		       85 48		      sta	COLUPF	; 3 @5
    165  0981
    166  0981		       b9 08 f8 	      lda	ChessBitmap0+8,y	; 4
    167  0984		       85 4d		      sta	PF0	; 3
    168  0986		       b9 20 f8 	      lda	ChessBitmap1+8,y	; 4
    169  0989		       85 4e		      sta	PF1	; 3
    170  098b		       b9 38 f8 	      lda	ChessBitmap2+8,y	; 4
    171  098e		       85 4f		      sta	PF2	; 3 @26
    172  0990
      0  0990					      SLEEP	8	; 6 @34
      1  0990				   .CYCLES    SET	8
      2  0990
      3  0990				  -	      IF	.CYCLES < 2
      4  0990				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0990				  -	      ERR
      6  0990					      ENDIF
      7  0990
      8  0990				  -	      IF	.CYCLES & 1
      9  0990				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0990				  -	      nop	0
     11  0990				  -	      ELSE
     12  0990				  -	      bit	VSYNC
     13  0990				  -	      ENDIF
     14  0990				  -.CYCLES    SET	.CYCLES - 3
     15  0990					      ENDIF
     16  0990
     17  0990					      REPEAT	.CYCLES / 2
     18  0990		       ea		      nop
     17  0990					      REPEND
     18  0991		       ea		      nop
     17  0991					      REPEND
     18  0992		       ea		      nop
     17  0992					      REPEND
     18  0993		       ea		      nop
     19  0994					      REPEND
    174  0994
    175  0994		       b9 50 f8 	      lda	ChessBitmap3+8,y	; 4
    176  0997		       85 4d		      sta	PF0	; 3
    177  0999		       b9 68 f8 	      lda	ChessBitmap4+8,y	; 4
    178  099c		       85 4e		      sta	PF1	; 3
    179  099e		       b9 80 f8 	      lda	ChessBitmap5+8,y	; 4
    180  09a1		       85 4f		      sta	PF2	; 3 @55
    181  09a3
    182  09a3		       4c 07 f9 	      jmp	.l3	; 3 @58
    183  09a6
    184  09a6
    185  09a6
    186  09a6							;---------------------------------------------------------------------------------------------------
    187  09a6
      0  09a6					      CHECK_RAM_BANK_SIZE	"ROM_SHADOW_SCREEN"
      1  09a6		       01 a6	   .TEMP      =	* - _BANK_START
 ROM_SHADOW_SCREEN (512 byte) SIZE =  $1a6 , FREE= $5a
      2  09a6					      ECHO	"ROM_SHADOW_SCREEN", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3  09a6				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  09a6				  -	      ECHO	"BANK OVERFLOW @ ", "ROM_SHADOW_SCREEN", " size=", * - ORIGIN
      5  09a6				  -	      ERR
      6  09a6					      ENDIF
    189  09a6
    190  09a6							;---------------------------------------------------------------------------------------------------
    191  09a6							;EOF
------- FILE ./chess.asm
------- FILE ROM_SCREEN@3.asm LEVEL 2 PASS 4
      0  09a6					      include	"ROM_SCREEN@3.asm"
      1  09a6
      0  09a6					      SLOT	3
      1  09a6				  -	      IF	(3 < 0) || (3 > 3)
      2  09a6				  -	      ECHO	"Illegal bank address/segment location", 3
      3  09a6				  -	      ERR
      4  09a6					      ENDIF
      5  09a6				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  09a6				   _BANK_SLOT SET	3 * 64
      0  09a6					      NEWBANK	BITMAP2
      1  0cbd ????				      SEG	BITMAP2
      2  0c00					      ORG	_ORIGIN
      3  0c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  0c00				   _BANK_START SET	*
      5  0c00				   BITMAP2_START SET	*
      6  0c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0c00				   BITMAP2    SET	_BANK_SLOT + _CURRENT_BANK
      8  0c00				   _ORIGIN    SET	_ORIGIN + 1024
      4  0c00
      5  0c00							;---------------------------------------------------------------------------------------------------
      6  0c00
      0  0c00					      DEF	ClearRowBitmap
      1  0c00				   SLOT_ClearRowBitmap SET	_BANK_SLOT
      2  0c00				   BANK_ClearRowBitmap SET	SLOT_ClearRowBitmap + _CURRENT_BANK
      3  0c00				   ClearRowBitmap
      4  0c00				   TEMPORARY_VAR SET	Overlay
      5  0c00				   TEMPORARY_OFFSET SET	0
      6  0c00				   VAR_BOUNDARY_ClearRowBitmap SET	TEMPORARY_OFFSET
      7  0c00				   FUNCTION_NAME SET	ClearRowBitmap
      8  0c00					      SUBROUTINE
      9  0c00
      0  0c00					      REFER	CallClear
      1  0c00				  -	      IF	VAREND_CallClear > TEMPORARY_VAR
      2  0c00				  -TEMPORARY_VAR SET	VAREND_CallClear
      3  0c00					      ENDIF
      0  0c00					      VEND	ClearRowBitmap
      1  0c00				  -	      IFNCONST	ClearRowBitmap
      2  0c00				  -	      ECHO	"Incorrect VEND label", ClearRowBitmap
      3  0c00				  -	      ERR
      4  0c00					      ENDIF
      5  0c00		       00 a2	   VAREND_ClearRowBitmap =	TEMPORARY_VAR
     12  0c00
     13  0c00							; No transient variable dependencies/calls
     14  0c00
     15  0c00		       a9 00		      lda	#0
     16  0c02		       a0 90		      ldy	#ROW_BITMAP_SIZE
      0  0c04				   .clearRow  sta@RAM	ChessBitmap-1,y
      1  0c04		       99 ff f9 	      sta	[RAM]+ChessBitmap-1,y
     18  0c07		       88		      dey
     19  0c08		       d0 fa		      bne	.clearRow
     20  0c0a		       60		      rts
     21  0c0b
     22  0c0b
     23  0c0b							;---------------------------------------------------------------------------------------------------
     24  0c0b
      0  0c0b					      DEF	CopyPieceToRowBitmap	;@3
      1  0c0b				   SLOT_CopyPieceToRowBitmap SET	_BANK_SLOT
      2  0c0b				   BANK_CopyPieceToRowBitmap SET	SLOT_CopyPieceToRowBitmap + _CURRENT_BANK
      3  0c0b				   CopyPieceToRowBitmap
      4  0c0b				   TEMPORARY_VAR SET	Overlay
      5  0c0b				   TEMPORARY_OFFSET SET	0
      6  0c0b				   VAR_BOUNDARY_CopyPieceToRowBitmap SET	TEMPORARY_OFFSET
      7  0c0b				   FUNCTION_NAME SET	CopyPieceToRowBitmap
     26  0c0b					      SUBROUTINE
     27  0c0b
     28  0c0b							;REFER CopySinglePiece 	  ; special-case due to 'intercept'
      0  0c0b					      VEND	CopyPieceToRowBitmap
      1  0c0b				  -	      IFNCONST	CopyPieceToRowBitmap
      2  0c0b				  -	      ECHO	"Incorrect VEND label", CopyPieceToRowBitmap
      3  0c0b				  -	      ERR
      4  0c0b					      ENDIF
      5  0c0b		       00 a2	   VAREND_CopyPieceToRowBitmap =	TEMPORARY_VAR
     30  0c0b
     31  0c0b		       a0 11		      ldy	#17
     32  0c0d		       b0 30		      bcs	.rightSide
     33  0c0f
     34  0c0f		       b9 a2 00    .copyPiece lda	__pieceShapeBuffer,y
     35  0c12		       f0 06		      beq	.blank1
     36  0c14		       59 00 f8 	      eor	ChessBitmap,y
      0  0c17					      sta@RAM	ChessBitmap,y
      1  0c17		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
     38  0c1a
     39  0c1a		       b9 b4 00    .blank1    lda	__pieceShapeBuffer+18,y
     40  0c1d		       f0 06		      beq	.blank2
     41  0c1f		       59 12 f8 	      eor	ChessBitmap+18,y
      0  0c22					      sta@RAM	ChessBitmap+18,y
      1  0c22		       99 12 fa 	      sta	[RAM]+ChessBitmap+18,y
     43  0c25
     44  0c25		       b9 c6 00    .blank2    lda	__pieceShapeBuffer+36,y
     45  0c28		       f0 06		      beq	.blank3
     46  0c2a		       59 24 f8 	      eor	ChessBitmap+36,y
      0  0c2d					      sta@RAM	ChessBitmap+36,y
      1  0c2d		       99 24 fa 	      sta	[RAM]+ChessBitmap+36,y
     48  0c30
     49  0c30		       b9 d8 00    .blank3    lda	__pieceShapeBuffer+54,y
     50  0c33		       f0 06		      beq	.blank4
     51  0c35		       59 36 f8 	      eor	ChessBitmap+54,y
      0  0c38					      sta@RAM	ChessBitmap+54,y
      1  0c38		       99 36 fa 	      sta	[RAM]+ChessBitmap+54,y
     53  0c3b
     54  0c3b		       88	   .blank4    dey
     55  0c3c		       10 d1		      bpl	.copyPiece
     56  0c3e		       60		      rts
     57  0c3f
     58  0c3f				   .rightSide
     59  0c3f
     60  0c3f					      SUBROUTINE
     61  0c3f
     62  0c3f		       b9 a2 00    .copyPieceR lda	__pieceShapeBuffer,y
     63  0c42		       f0 06		      beq	.blank1
     64  0c44		       59 48 f8 	      eor	ChessBitmap+72,y
      0  0c47					      sta@RAM	ChessBitmap+72,y
      1  0c47		       99 48 fa 	      sta	[RAM]+ChessBitmap+72,y
     66  0c4a
     67  0c4a		       b9 b4 00    .blank1    lda	__pieceShapeBuffer+18,y
     68  0c4d		       f0 06		      beq	.blank2
     69  0c4f		       59 5a f8 	      eor	ChessBitmap+72+18,y
      0  0c52					      sta@RAM	ChessBitmap+72+18,y
      1  0c52		       99 5a fa 	      sta	[RAM]+ChessBitmap+72+18,y
     71  0c55
     72  0c55		       b9 c6 00    .blank2    lda	__pieceShapeBuffer+36,y
     73  0c58		       f0 06		      beq	.blank3
     74  0c5a		       59 6c f8 	      eor	ChessBitmap+72+36,y
      0  0c5d					      sta@RAM	ChessBitmap+72+36,y
      1  0c5d		       99 6c fa 	      sta	[RAM]+ChessBitmap+72+36,y
     76  0c60
     77  0c60		       b9 d8 00    .blank3    lda	__pieceShapeBuffer+54,y
     78  0c63		       f0 06		      beq	.blank4
     79  0c65		       59 7e f8 	      eor	ChessBitmap+72+54,y
      0  0c68					      sta@RAM	ChessBitmap+72+54,y
      1  0c68		       99 7e fa 	      sta	[RAM]+ChessBitmap+72+54,y
     81  0c6b
     82  0c6b		       88	   .blank4    dey
     83  0c6c		       10 d1		      bpl	.copyPieceR
     84  0c6e		       60		      rts
     85  0c6f
     86  0c6f
     87  0c6f							;---------------------------------------------------------------------------------------------------
     88  0c6f
     89  0c6f					      IF	1
      0  0c6f					      DEF	WriteBlank
      1  0c6f				   SLOT_WriteBlank SET	_BANK_SLOT
      2  0c6f				   BANK_WriteBlank SET	SLOT_WriteBlank + _CURRENT_BANK
      3  0c6f				   WriteBlank
      4  0c6f				   TEMPORARY_VAR SET	Overlay
      5  0c6f				   TEMPORARY_OFFSET SET	0
      6  0c6f				   VAR_BOUNDARY_WriteBlank SET	TEMPORARY_OFFSET
      7  0c6f				   FUNCTION_NAME SET	WriteBlank
     91  0c6f					      SUBROUTINE
     92  0c6f
      0  0c6f					      REFER	StartupBankReset
      1  0c6f				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0c6f				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0c6f					      ENDIF
      0  0c6f					      VEND	WriteBlank
      1  0c6f				  -	      IFNCONST	WriteBlank
      2  0c6f				  -	      ECHO	"Incorrect VEND label", WriteBlank
      3  0c6f				  -	      ERR
      4  0c6f					      ENDIF
      5  0c6f		       00 a2	   VAREND_WriteBlank =	TEMPORARY_VAR
     95  0c6f
     96  0c6f		       a9 90		      lda	#<BlankSprite
      0  0c71					      sta@RAM	SMSPRITE0_0+1
      1  0c71		       8d 43 fb 	      sta	[RAM]+SMSPRITE0_0+1
      0  0c74					      sta@RAM	SMSPRITE8_0+1
      1  0c74		       8d 74 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  0c77					      sta@RAM	SMSPRITE16_0+1
      1  0c77		       8d 08 fb 	      sta	[RAM]+SMSPRITE16_0+1
      0  0c7a					      sta@RAM	SMSPRITE0_1+1
      1  0c7a		       8d 48 fb 	      sta	[RAM]+SMSPRITE0_1+1
      0  0c7d					      sta@RAM	SMSPRITE8_1+1
      1  0c7d		       8d 79 fb 	      sta	[RAM]+SMSPRITE8_1+1
      0  0c80					      sta@RAM	SMSPRITE16_1+1
      1  0c80		       8d 0d fb 	      sta	[RAM]+SMSPRITE16_1+1
    103  0c83
    104  0c83		       a9 f8		      lda	#>BlankSprite
      0  0c85					      sta@RAM	SMSPRITE0_0+2
      1  0c85		       8d 44 fb 	      sta	[RAM]+SMSPRITE0_0+2
      0  0c88					      sta@RAM	SMSPRITE8_0+2
      1  0c88		       8d 75 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  0c8b					      sta@RAM	SMSPRITE16_0+2
      1  0c8b		       8d 09 fb 	      sta	[RAM]+SMSPRITE16_0+2
      0  0c8e					      sta@RAM	SMSPRITE0_1+2
      1  0c8e		       8d 49 fb 	      sta	[RAM]+SMSPRITE0_1+2
      0  0c91					      sta@RAM	SMSPRITE8_1+2
      1  0c91		       8d 7a fb 	      sta	[RAM]+SMSPRITE8_1+2
      0  0c94					      sta@RAM	SMSPRITE16_1+2
      1  0c94		       8d 0e fb 	      sta	[RAM]+SMSPRITE16_1+2
    111  0c97
    112  0c97		       60		      rts
    113  0c98					      ENDIF
    114  0c98
    115  0c98							;---------------------------------------------------------------------------------------------------
    116  0c98
    117  0c98					      IF	1
      0  0c98					      DEF	WriteCursor
      1  0c98				   SLOT_WriteCursor SET	_BANK_SLOT
      2  0c98				   BANK_WriteCursor SET	SLOT_WriteCursor + _CURRENT_BANK
      3  0c98				   WriteCursor
      4  0c98				   TEMPORARY_VAR SET	Overlay
      5  0c98				   TEMPORARY_OFFSET SET	0
      6  0c98				   VAR_BOUNDARY_WriteCursor SET	TEMPORARY_OFFSET
      7  0c98				   FUNCTION_NAME SET	WriteCursor
    119  0c98					      SUBROUTINE
    120  0c98
      0  0c98					      REFER	StartupBankReset
      1  0c98				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0c98				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0c98					      ENDIF
      0  0c98					      VEND	WriteCursor
      1  0c98				  -	      IFNCONST	WriteCursor
      2  0c98				  -	      ECHO	"Incorrect VEND label", WriteCursor
      3  0c98				  -	      ERR
      4  0c98					      ENDIF
      5  0c98		       00 a2	   VAREND_WriteCursor =	TEMPORARY_VAR
    123  0c98
    124  0c98		       38		      sec
    125  0c99		       a5 88		      lda	cursorX12
    126  0c9b		       30 1f		      bmi	.exit
    127  0c9d		       a2 0a		      ldx	#10
    128  0c9f		       e9 0a	   .sub10     sbc	#10
    129  0ca1		       ca		      dex
    130  0ca2		       b0 fb		      bcs	.sub10
    131  0ca4
    132  0ca4		       86 3e		      stx	SET_BANK_RAM
    133  0ca6		       a9 98		      lda	#<SpriteBuffer
      0  0ca8					      sta@RAM	SMSPRITE0_0+1
      1  0ca8		       8d 43 fb 	      sta	[RAM]+SMSPRITE0_0+1
      0  0cab					      sta@RAM	SMSPRITE8_0+1
      1  0cab		       8d 74 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  0cae					      sta@RAM	SMSPRITE16_0+1
      1  0cae		       8d 08 fb 	      sta	[RAM]+SMSPRITE16_0+1
    137  0cb1		       a9 f8		      lda	#>SpriteBuffer
      0  0cb3					      sta@RAM	SMSPRITE0_0+2
      1  0cb3		       8d 44 fb 	      sta	[RAM]+SMSPRITE0_0+2
      0  0cb6					      sta@RAM	SMSPRITE8_0+2
      1  0cb6		       8d 75 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  0cb9					      sta@RAM	SMSPRITE16_0+2
      1  0cb9		       8d 09 fb 	      sta	[RAM]+SMSPRITE16_0+2
    141  0cbc
    142  0cbc		       60	   .exit      rts
    143  0cbd					      ENDIF
    144  0cbd
    145  0cbd
    146  0cbd							;---------------------------------------------------------------------------------------------------
    147  0cbd
    148  0cbd				  -	      IF	0
    149  0cbd				  -	      DEF	SaveBitmap
    150  0cbd				  -	      SUBROUTINE
    151  0cbd				  -
    152  0cbd				  -	      REFER	SAFE_BackupBitmaps
    153  0cbd				  -	      VEND	SaveBitmap
    154  0cbd				  -
    155  0cbd				  -	      ldy	#71
    156  0cbd				  -.fromTo    lda	ChessBitmap,y
    157  0cbd				  -	      sta@RAM	BackupBitmap,y
    158  0cbd				  -	      lda	ChessBitmap+72,y
    159  0cbd				  -	      sta@RAM	BackupBitmap+72,y
    160  0cbd				  -	      dey
    161  0cbd				  -	      bpl	.fromTo
    162  0cbd				  -	      rts
    163  0cbd					      ENDIF
    164  0cbd
    165  0cbd							;---------------------------------------------------------------------------------------------------
    166  0cbd
    167  0cbd				  -	      IF	0
    168  0cbd				  -
    169  0cbd				  -	      DEF	RestoreBitmap
    170  0cbd				  -	      SUBROUTINE
    171  0cbd				  -
    172  0cbd				  -	      VEND	RestoreBitmap
    173  0cbd				  -
    174  0cbd				  -	      ldy	#71
    175  0cbd				  -.fromTo    lda	BackupBitmap,y
    176  0cbd				  -	      sta@RAM	ChessBitmap,y
    177  0cbd				  -	      lda	BackupBitmap+72,y
    178  0cbd				  -	      sta@RAM	ChessBitmap+72,y
    179  0cbd				  -	      dey
    180  0cbd				  -	      bpl	.fromTo
    181  0cbd				  -	      rts
    182  0cbd					      ENDIF
    183  0cbd
    184  0cbd							;---------------------------------------------------------------------------------------------------
    185  0cbd
    186  0cbd				  -	      IF	0
    187  0cbd				  -
    188  0cbd				  -	      DEF	CopyTextToRowBitmap
    189  0cbd				  -	      SUBROUTINE
    190  0cbd				  -
    191  0cbd				  -	      VEND	CopyTextToRowBitmap
    192  0cbd				  -
    193  0cbd				  -			; An OR-draw, used for placing matricies/text onscreen
    194  0cbd				  -			; Similar to the EOR - first copy data into __pieceShapeBuffer, then call this function
    195  0cbd				  -			; The draw can be bracketed by "SaveBitmap" and "RestoreBitmap" to leave screen
    196  0cbd				  -			; in original state once text disappears
    197  0cbd				  -
    198  0cbd				  -	      ldy	#71
    199  0cbd				  -	      bcs	.rightSide
    200  0cbd				  -
    201  0cbd				  -.copy      lda	__pieceShapeBuffer,y
    202  0cbd				  -	      ora	ChessBitmap,y
    203  0cbd				  -	      sta@RAM	ChessBitmap,y
    204  0cbd				  -	      dey
    205  0cbd				  -	      bpl	.copy
    206  0cbd				  -
    207  0cbd				  -	      rts
    208  0cbd				  -
    209  0cbd				  -.rightSide
    210  0cbd				  -
    211  0cbd				  -	      SUBROUTINE
    212  0cbd				  -
    213  0cbd				  -.copy      lda	__pieceShapeBuffer,y
    214  0cbd				  -	      ora	ChessBitmap+72,y
    215  0cbd				  -	      sta@RAM	ChessBitmap+72,y
    216  0cbd				  -	      dey
    217  0cbd				  -	      bpl	.copy
    218  0cbd				  -
    219  0cbd				  -	      rts
    220  0cbd				  -
    221  0cbd					      ENDIF
    222  0cbd
    223  0cbd							;---------------------------------------------------------------------------------------------------
    224  0cbd
      0  0cbd					      CHECK_RAM_BANK_SIZE	"ROM_SHADOW_SCREEN"
      1  0cbd		       00 bd	   .TEMP      =	* - _BANK_START
 ROM_SHADOW_SCREEN (512 byte) SIZE =  $bd , FREE= $143
      2  0cbd					      ECHO	"ROM_SHADOW_SCREEN", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3  0cbd				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  0cbd				  -	      ECHO	"BANK OVERFLOW @ ", "ROM_SHADOW_SCREEN", " size=", * - ORIGIN
      5  0cbd				  -	      ERR
      6  0cbd					      ENDIF
    226  0cbd
    227  0cbd							;---------------------------------------------------------------------------------------------------
    228  0cbd							;EOF
------- FILE ./chess.asm
------- FILE BANK_PLY.asm LEVEL 2 PASS 4
      0  0cbd					      include	"BANK_PLY.asm"
      1  0cbd							; Copyright (C)2020 Andrew Davie
      2  0cbd							; andrew@taswegian.com
      3  0cbd
      0  0cbd					      SLOT	1	;TODO
      1  0cbd				  -	      IF	(1 < 0) || (1 > 3)
      2  0cbd				  -	      ECHO	"Illegal bank address/segment location", 1
      3  0cbd				  -	      ERR
      4  0cbd					      ENDIF
      5  0cbd				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  0cbd				   _BANK_SLOT SET	1 * 64
      0  0cbd					      NEWBANK	BANK_PLY	; ROM SHADOW
      1  127b ????				      SEG	BANK_PLY
      2  1000					      ORG	_ORIGIN
      3  1000					      RORG	_BANK_ADDRESS_ORIGIN
      4  1000				   _BANK_START SET	*
      5  1000				   BANK_PLY_START SET	*
      6  1000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1000				   BANK_PLY   SET	_BANK_SLOT + _CURRENT_BANK
      8  1000				   _ORIGIN    SET	_ORIGIN + 1024
      6  1000
      7  1000
      8  1000							;---------------------------------------------------------------------------------------------------
      9  1000
      0  1000					      DEF	NewPlyInitialise
      1  1000				   SLOT_NewPlyInitialise SET	_BANK_SLOT
      2  1000				   BANK_NewPlyInitialise SET	SLOT_NewPlyInitialise + _CURRENT_BANK
      3  1000				   NewPlyInitialise
      4  1000				   TEMPORARY_VAR SET	Overlay
      5  1000				   TEMPORARY_OFFSET SET	0
      6  1000				   VAR_BOUNDARY_NewPlyInitialise SET	TEMPORARY_OFFSET
      7  1000				   FUNCTION_NAME SET	NewPlyInitialise
     11  1000					      SUBROUTINE
     12  1000
      0  1000					      REFER	GenerateAllMoves
      1  1000					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1000				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1000					      ENDIF
      0  1000					      REFER	negaMax
      1  1000				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  1000				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  1000					      ENDIF
      0  1000					      VEND	NewPlyInitialise
      1  1000				  -	      IFNCONST	NewPlyInitialise
      2  1000				  -	      ECHO	"Incorrect VEND label", NewPlyInitialise
      3  1000				  -	      ERR
      4  1000					      ENDIF
      5  1000		       00 b3	   VAREND_NewPlyInitialise =	TEMPORARY_VAR
     16  1000
     17  1000							; This MUST be called at the start of a new ply
     18  1000							; It initialises the movelist to empty
     19  1000							; x must be preserved
     20  1000
     21  1000							; note that 'alpha' and 'beta' are set externally!!
     22  1000
     23  1000		       a9 ff		      lda	#-1
      0  1002					      sta@PLY	moveIndex	; no valid moves
      1  1002		       8d 9e 01 	      sta	[RAM]+moveIndex
      0  1005					      sta@PLY	bestMove
      1  1005		       8d a0 01 	      sta	[RAM]+bestMove
     26  1008
     27  1008		       a5 94		      lda	enPassantPawn	; flag/square from last actual move made
      0  100a					      sta@PLY	enPassantSquare	; used for backtracking, to reset the flag
      1  100a		       8d 98 01 	      sta	[RAM]+enPassantSquare
     29  100d
     30  100d
     31  100d							; The value of the material (signed, 16-bit) is restored to the saved value at the reversion
     32  100d							; of a move. It's quicker to restore than to re-sum. So we save the current evaluation at the
     33  100d							; start of each new ply.
     34  100d
     35  100d		       a5 90		      lda	Evaluation
      0  100f					      sta@PLY	savedEvaluation
      1  100f		       8d 96 01 	      sta	[RAM]+savedEvaluation
     37  1012		       a5 91		      lda	Evaluation+1
      0  1014					      sta@PLY	savedEvaluation+1
      1  1014		       8d 97 01 	      sta	[RAM]+savedEvaluation+1
     39  1017
     40  1017		       60		      rts
     41  1018
     42  1018
     43  1018							;---------------------------------------------------------------------------------------------------
     44  1018
      0  1018					      DEF	CheckMoveListFromSquare
      1  1018				   SLOT_CheckMoveListFromSquare SET	_BANK_SLOT
      2  1018				   BANK_CheckMoveListFromSquare SET	SLOT_CheckMoveListFromSquare + _CURRENT_BANK
      3  1018				   CheckMoveListFromSquare
      4  1018				   TEMPORARY_VAR SET	Overlay
      5  1018				   TEMPORARY_OFFSET SET	0
      6  1018				   VAR_BOUNDARY_CheckMoveListFromSquare SET	TEMPORARY_OFFSET
      7  1018				   FUNCTION_NAME SET	CheckMoveListFromSquare
     46  1018					      SUBROUTINE
     47  1018
      0  1018					      REFER	IsValidMoveFromSquare
      1  1018				  -	      IF	VAREND_IsValidMoveFromSquare > TEMPORARY_VAR
      2  1018				  -TEMPORARY_VAR SET	VAREND_IsValidMoveFromSquare
      3  1018					      ENDIF
      0  1018					      VEND	CheckMoveListFromSquare
      1  1018				  -	      IFNCONST	CheckMoveListFromSquare
      2  1018				  -	      ECHO	"Incorrect VEND label", CheckMoveListFromSquare
      3  1018				  -	      ERR
      4  1018					      ENDIF
      5  1018		       00 a2	   VAREND_CheckMoveListFromSquare =	TEMPORARY_VAR
     50  1018
     51  1018							; X12 in A
     52  1018							; y = -1 on return if NOT FOUND
     53  1018
      0  1018					      ldy@RAM	moveIndex
      1  1018		       ac 9e ff 	      ldy	moveIndex
     55  101b		       30 08		      bmi	.exit
     56  101d
     57  101d		       d9 00 fc    .scan      cmp	MoveFrom,y
     58  1020		       f0 04		      beq	.scanned
     59  1022		       88		      dey
     60  1023		       10 f8		      bpl	.scan
     61  1025		       60	   .exit      rts
     62  1026
      0  1026				   .scanned   lda@PLY	MovePiece,y
      1  1026		       b9 00 fe 	      lda	MovePiece,y
     64  1029		       85 97		      sta	fromPiece
     65  102b		       60		      rts
     66  102c
     67  102c
     68  102c							;---------------------------------------------------------------------------------------------------
     69  102c
      0  102c					      DEF	GetPieceGivenFromToSquares
      1  102c				   SLOT_GetPieceGivenFromToSquares SET	_BANK_SLOT
      2  102c				   BANK_GetPieceGivenFromToSquares SET	SLOT_GetPieceGivenFromToSquares + _CURRENT_BANK
      3  102c				   GetPieceGivenFromToSquares
      4  102c				   TEMPORARY_VAR SET	Overlay
      5  102c				   TEMPORARY_OFFSET SET	0
      6  102c				   VAR_BOUNDARY_GetPieceGivenFromToSquares SET	TEMPORARY_OFFSET
      7  102c				   FUNCTION_NAME SET	GetPieceGivenFromToSquares
     71  102c					      SUBROUTINE
     72  102c
      0  102c					      REFER	GetPiece
      1  102c				  -	      IF	VAREND_GetPiece > TEMPORARY_VAR
      2  102c				  -TEMPORARY_VAR SET	VAREND_GetPiece
      3  102c					      ENDIF
      0  102c					      VEND	GetPieceGivenFromToSquares
      1  102c				  -	      IFNCONST	GetPieceGivenFromToSquares
      2  102c				  -	      ECHO	"Incorrect VEND label", GetPieceGivenFromToSquares
      3  102c				  -	      ERR
      4  102c					      ENDIF
      5  102c		       00 a2	   VAREND_GetPieceGivenFromToSquares =	TEMPORARY_VAR
     75  102c
     76  102c							; returns piece in A+fromPiece
     77  102c							; or Y=-1 if not found
     78  102c
     79  102c							; We need to get the piece from the movelist because it contains flags (e.g., castling) about
     80  102c							; the move. We need to do from/to checks because moves can have multiple origin/desinations.
     81  102c							; This fixes the move with/without castle flag
     82  102c
     83  102c
      0  102c					      ldy@PLY	moveIndex
      1  102c		       ac 9e ff 	      ldy	moveIndex
     85  102f							;bmi .fail		  ; shouldn't happen
     86  102f		       a5 85	   .scan      lda	fromX12
      0  1031					      cmp@PLY	MoveFrom,y
      1  1031		       d9 00 fc 	      cmp	MoveFrom,y
     88  1034		       d0 07		      bne	.next
     89  1036		       a5 86		      lda	toX12
      0  1038					      cmp@PLY	MoveTo,y
      1  1038		       d9 00 fd 	      cmp	MoveTo,y
     91  103b		       f0 04		      beq	.found
     92  103d		       88	   .next      dey
     93  103e		       10 ef		      bpl	.scan
     94  1040		       60	   .fail      rts
     95  1041
      0  1041				   .found     lda@PLY	MovePiece,y
      1  1041		       b9 00 fe 	      lda	MovePiece,y
     97  1044		       85 97		      sta	fromPiece
     98  1046		       60		      rts
     99  1047
    100  1047
    101  1047
    102  1047							;---------------------------------------------------------------------------------------------------
    103  1047
      0  1047					      DEF	selectmove
      1  1047				   SLOT_selectmove SET	_BANK_SLOT
      2  1047				   BANK_selectmove SET	SLOT_selectmove + _CURRENT_BANK
      3  1047				   selectmove
      4  1047				   TEMPORARY_VAR SET	Overlay
      5  1047				   TEMPORARY_OFFSET SET	0
      6  1047				   VAR_BOUNDARY_selectmove SET	TEMPORARY_OFFSET
      7  1047				   FUNCTION_NAME SET	selectmove
    105  1047					      SUBROUTINE
    106  1047
      0  1047					      COMMON_VARS_ALPHABETA
      1  1047
      0  1047					      VAR	__thinkbar, 1
      1  1047		       00 a2	   __thinkbar =	TEMPORARY_VAR
      2  1047				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1047
      4  1047				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1047				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1047				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1047					      ENDIF
      8  1047				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1047				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  1047				  -	      ERR
     11  1047					      ENDIF
     12  1047					      LIST	ON
      0  1047					      VAR	__toggle, 1
      1  1047		       00 a3	   __toggle   =	TEMPORARY_VAR
      2  1047				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1047
      4  1047				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1047				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1047				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1047					      ENDIF
      8  1047				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1047				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  1047				  -	      ERR
     11  1047					      ENDIF
     12  1047					      LIST	ON
      4  1047
      0  1047					      VAR	__bestMove, 1
      1  1047		       00 a4	   __bestMove =	TEMPORARY_VAR
      2  1047				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1047
      4  1047				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1047				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1047				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1047					      ENDIF
      8  1047				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1047				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  1047				  -	      ERR
     11  1047					      ENDIF
     12  1047					      LIST	ON
      0  1047					      VAR	__alpha, 2
      1  1047		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  1047				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1047
      4  1047				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1047				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1047				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1047					      ENDIF
      8  1047				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1047				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  1047				  -	      ERR
     11  1047					      ENDIF
     12  1047					      LIST	ON
      0  1047					      VAR	__beta, 2
      1  1047		       00 a7	   __beta     =	TEMPORARY_VAR
      2  1047				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1047
      4  1047				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1047				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1047				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1047					      ENDIF
      8  1047				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1047				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  1047				  -	      ERR
     11  1047					      ENDIF
     12  1047					      LIST	ON
      0  1047					      VAR	__negaMax, 2
      1  1047		       00 a9	   __negaMax  =	TEMPORARY_VAR
      2  1047				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1047
      4  1047				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1047				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1047				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1047					      ENDIF
      8  1047				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1047				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  1047				  -	      ERR
     11  1047					      ENDIF
     12  1047					      LIST	ON
      0  1047					      VAR	__value, 2
      1  1047		       00 ab	   __value    =	TEMPORARY_VAR
      2  1047				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1047
      4  1047				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1047				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1047				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1047					      ENDIF
      8  1047				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1047				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  1047				  -	      ERR
     11  1047					      ENDIF
     12  1047					      LIST	ON
     10  1047
      0  1047					      VAR	__quiesceCapOnly, 1
      1  1047		       00 ad	   __quiesceCapOnly =	TEMPORARY_VAR
      2  1047				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1047
      4  1047				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1047				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1047				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1047					      ENDIF
      8  1047				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1047				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  1047				  -	      ERR
     11  1047					      ENDIF
     12  1047					      LIST	ON
     12  1047
      0  1047					      REFER	aiComputerMove
      1  1047				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  1047				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  1047					      ENDIF
      0  1047					      VEND	selectmove
      1  1047				  -	      IFNCONST	selectmove
      2  1047				  -	      ECHO	"Incorrect VEND label", selectmove
      3  1047				  -	      ERR
      4  1047					      ENDIF
      5  1047		       00 ae	   VAREND_selectmove =	TEMPORARY_VAR
    110  1047
    111  1047
    112  1047
    113  1047							; RAM bank already switched in!!!
    114  1047							; returns with RAM bank switched
    115  1047
    116  1047
    117  1047				  -	      IF	DIAGNOSTICS
    118  1047				  -
    119  1047				  -	      lda	#0
    120  1047				  -	      sta	positionCount
    121  1047				  -	      sta	positionCount+1
    122  1047				  -	      sta	positionCount+2
    123  1047				  -			;sta maxPly
    124  1047					      ENDIF
    125  1047
    126  1047
    127  1047		       a9 00		      lda	#<INFINITY
    128  1049		       85 a7		      sta	__beta
    129  104b		       a9 70		      lda	#>INFINITY
    130  104d		       85 a8		      sta	__beta+1
    131  104f
    132  104f		       a9 00		      lda	#<-INFINITY
    133  1051		       85 a5		      sta	__alpha
    134  1053		       a9 90		      lda	#>-INFINITY
    135  1055		       85 a6		      sta	__alpha+1	; player tries to maximise
    136  1057
    137  1057		       a2 03		      ldx	#SEARCH_DEPTH
    138  1059		       a9 00		      lda	#0	; no captured piece
    139  105b		       85 ad		      sta	__quiesceCapOnly	; ALL moves to be generated
    140  105d
    141  105d		       20 22 f4 	      jsr	negaMax
    142  1060
      0  1060					      ldx@PLY	bestMove
      1  1060		       ae a0 ff 	      ldx	bestMove
    144  1063		       30 28		      bmi	.nomove
    145  1065
    146  1065							; Generate player's moves in reply
    147  1065							; Make the computer move, list player moves (PLY+1), unmake computer move
    148  1065
    149  1065
      0  1065					      stx@PLY	movePtr
      1  1065		       8e 9f 01 	      stx	[RAM]+movePtr
    151  1068		       20 00 f4 	      jsr	MakeMove
    152  106b
    153  106b		       20 73 f5 	      jsr	ListPlayerMoves
    154  106e
    155  106e		       a9 c8		      lda	#RAMBANK_PLY
    156  1070		       85 3e		      sta	SET_BANK_RAM
    157  1072
    158  1072		       20 6f f4 	      jsr	unmakeMove
    159  1075
    160  1075							; Grab the computer move details for the UI animation
    161  1075
    162  1075		       a9 c8		      lda	#RAMBANK_PLY
    163  1077		       85 3e		      sta	SET_BANK_RAM
    164  1079
      0  1079					      ldx@PLY	bestMove
      1  1079		       ae a0 ff 	      ldx	bestMove
      0  107c					      lda@PLY	MoveTo,x
      1  107c		       bd 00 fd 	      lda	MoveTo,x
    167  107f		       85 86		      sta	toX12
      0  1081					      lda@PLY	MoveFrom,x
      1  1081		       bd 00 fc 	      lda	MoveFrom,x
    169  1084		       85 87		      sta	originX12
    170  1086		       85 85		      sta	fromX12
      0  1088					      lda@PLY	MovePiece,x
      1  1088		       bd 00 fe 	      lda	MovePiece,x
    172  108b		       85 97		      sta	fromPiece
    173  108d
    174  108d				   .nomove
    175  108d		       60		      rts
    176  108e
    177  108e
    178  108e							;---------------------------------------------------------------------------------------------------
    179  108e
      0  108e					      DEF	GenCastleMoveForRook
      1  108e				   SLOT_GenCastleMoveForRook SET	_BANK_SLOT
      2  108e				   BANK_GenCastleMoveForRook SET	SLOT_GenCastleMoveForRook + _CURRENT_BANK
      3  108e				   GenCastleMoveForRook
      4  108e				   TEMPORARY_VAR SET	Overlay
      5  108e				   TEMPORARY_OFFSET SET	0
      6  108e				   VAR_BOUNDARY_GenCastleMoveForRook SET	TEMPORARY_OFFSET
      7  108e				   FUNCTION_NAME SET	GenCastleMoveForRook
    181  108e					      SUBROUTINE
    182  108e
      0  108e					      REFER	MakeMove
      1  108e					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  108e				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  108e					      ENDIF
      0  108e					      REFER	CastleFixupDraw
      1  108e				  -	      IF	VAREND_CastleFixupDraw > TEMPORARY_VAR
      2  108e				  -TEMPORARY_VAR SET	VAREND_CastleFixupDraw
      3  108e					      ENDIF
      0  108e					      VEND	GenCastleMoveForRook
      1  108e				  -	      IFNCONST	GenCastleMoveForRook
      2  108e				  -	      ECHO	"Incorrect VEND label", GenCastleMoveForRook
      3  108e				  -	      ERR
      4  108e					      ENDIF
      5  108e		       00 b0	   VAREND_GenCastleMoveForRook =	TEMPORARY_VAR
    186  108e
    187  108e		       18		      clc
    188  108f
    189  108f		       a5 97		      lda	fromPiece
    190  1091		       29 10		      and	#FLAG_CASTLE
    191  1093		       f0 2b		      beq	.exit	; NOT involved in castle!
    192  1095
    193  1095		       a2 04		      ldx	#4
    194  1097		       a5 85		      lda	fromX12	; *destination*
    195  1099		       18	   .findCast  clc
    196  109a		       ca		      dex
    197  109b		       30 23		      bmi	.exit
    198  109d		       dd d2 f4 	      cmp	KSquare,x
    199  10a0		       d0 f7		      bne	.findCast
    200  10a2
    201  10a2		       bd da f4 	      lda	RSquareEnd,x
    202  10a5		       85 86		      sta	toX12
      0  10a7					      sta@PLY	secondaryBlank
      1  10a7		       8d 9d 01 	      sta	[RAM]+secondaryBlank
    204  10aa		       bc d6 f4 	      ldy	RSquareStart,x
    205  10ad		       84 85		      sty	fromX12
    206  10af		       84 87		      sty	originX12
      0  10b1					      sty@PLY	secondarySquare
      1  10b1		       8c 9c 01 	      sty	[RAM]+secondarySquare
    208  10b4
    209  10b4		       a5 97		      lda	fromPiece
    210  10b6		       29 80		      and	#128	; colour bit
    211  10b8		       09 05		      ora	#ROOK	; preserve colour
    212  10ba		       85 97		      sta	fromPiece
      0  10bc					      sta@PLY	secondaryPiece
      1  10bc		       8d 9b 01 	      sta	[RAM]+secondaryPiece
    214  10bf
    215  10bf		       38		      sec
    216  10c0		       60	   .exit      rts
    217  10c1
    218  10c1
    219  10c1							;---------------------------------------------------------------------------------------------------
    220  10c1
      0  10c1					      DEF	CastleFixupDraw
      1  10c1				   SLOT_CastleFixupDraw SET	_BANK_SLOT
      2  10c1				   BANK_CastleFixupDraw SET	SLOT_CastleFixupDraw + _CURRENT_BANK
      3  10c1				   CastleFixupDraw
      4  10c1				   TEMPORARY_VAR SET	Overlay
      5  10c1				   TEMPORARY_OFFSET SET	0
      6  10c1				   VAR_BOUNDARY_CastleFixupDraw SET	TEMPORARY_OFFSET
      7  10c1				   FUNCTION_NAME SET	CastleFixupDraw
    222  10c1					      SUBROUTINE
    223  10c1
      0  10c1					      REFER	aiSpecialMoveFixup
      1  10c1					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  10c1				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  10c1					      ENDIF
      0  10c1					      VEND	CastleFixupDraw
      1  10c1				  -	      IFNCONST	CastleFixupDraw
      2  10c1				  -	      ECHO	"Incorrect VEND label", CastleFixupDraw
      3  10c1				  -	      ERR
      4  10c1					      ENDIF
      5  10c1		       00 ae	   VAREND_CastleFixupDraw =	TEMPORARY_VAR
    226  10c1
    227  10c1							; fixup any castling issues
    228  10c1							; at this point the king has finished his two-square march
    229  10c1							; based on the finish square, we determine which rook we're interacting with
    230  10c1							; and generate a 'move' for the rook to position on the other side of the king
    231  10c1
    232  10c1
    233  10c1					      IF	CASTLING_ENABLED
    234  10c1		       20 8e f4 	      jsr	GenCastleMoveForRook
    235  10c4		       b0 07		      bcs	.phase
    236  10c6					      ENDIF
    237  10c6
      0  10c6					      SWAP
      1  10c6		       a5 96		      lda	sideToMove
      2  10c8		       49 80		      eor	#SWAP_SIDE
      3  10ca		       85 96		      sta	sideToMove
    239  10cc		       60		      rts
    240  10cd
    241  10cd				   .phase
    242  10cd
    243  10cd							; in this siutation (castle, rook moving) we do not change sides yet!
    244  10cd
      0  10cd					      PHASE	AI_MoveIsSelected
      1  10cd		       a9 14		      lda	#AI_MoveIsSelected
      2  10cf		       85 8c		      sta	aiState
    246  10d1		       60		      rts
    247  10d2
    248  10d2
    249  10d2
    250  10d2		       18 1c 5e 62 KSquare    .byte.b	24,28,94,98
    251  10d6		       16 1d 5c 63 RSquareStart .byte.b	22,29,92,99
    252  10da		       19 1b 5f 61 RSquareEnd .byte.b	25,27,95,97
    253  10de
    254  10de
    255  10de							;---------------------------------------------------------------------------------------------------
    256  10de
    257  10de					      MAC	xchg
    258  10de					      lda@PLY	{1},x
    259  10de					      sta	__xchg
    260  10de					      lda@PLY	{1},y
    261  10de					      sta@PLY	{1},x
    262  10de					      lda	__xchg
    263  10de					      sta@PLY	{1},y
    264  10de					      ENDM		;{name}
    265  10de
    266  10de
      0  10de					      DEF	Sort
      1  10de				   SLOT_Sort  SET	_BANK_SLOT
      2  10de				   BANK_Sort  SET	SLOT_Sort + _CURRENT_BANK
      3  10de				   Sort
      4  10de				   TEMPORARY_VAR SET	Overlay
      5  10de				   TEMPORARY_OFFSET SET	0
      6  10de				   VAR_BOUNDARY_Sort SET	TEMPORARY_OFFSET
      7  10de				   FUNCTION_NAME SET	Sort
    268  10de					      SUBROUTINE
    269  10de
      0  10de					      REFER	GenerateAllMoves
      1  10de					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  10de				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  10de					      ENDIF
      0  10de					      VAR	__xchg, 1
      1  10de		       00 b3	   __xchg     =	TEMPORARY_VAR
      2  10de				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  10de
      4  10de				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  10de				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  10de				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  10de					      ENDIF
      8  10de				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  10de				  -	      ECHO	"Temporary Variable", __xchg, "overflow!"
     10  10de				  -	      ERR
     11  10de					      ENDIF
     12  10de					      LIST	ON
      0  10de					      VEND	Sort
      1  10de				  -	      IFNCONST	Sort
      2  10de				  -	      ECHO	"Incorrect VEND label", Sort
      3  10de				  -	      ERR
      4  10de					      ENDIF
      5  10de		       00 b4	   VAREND_Sort =	TEMPORARY_VAR
    273  10de
    274  10de							;lda currentPly
    275  10de							;sta savedBank 	  ; ??
    276  10de
    277  10de		       a5 ad		      lda	__quiesceCapOnly
    278  10e0		       30 51		      bmi	.exit	; only caps present so already sorted!
    279  10e2
      0  10e2					      ldx@PLY	moveIndex
      1  10e2		       ae 9e ff 	      ldx	moveIndex
      0  10e5					      ldy@PLY	moveIndex
      1  10e5		       ac 9e ff 	      ldy	moveIndex
    282  10e8		       88	   .next      dey
    283  10e9		       30 48		      bmi	.exit
    284  10eb
      0  10eb					      lda@PLY	MoveCapture,y
      1  10eb		       b9 00 ff 	      lda	MoveCapture,y
    286  10ee		       f0 f8		      beq	.next
    287  10f0
      0  10f0					      XCHG	MoveFrom
      0  10f0					      lda@PLY	MoveFrom,x
      1  10f0		       bd 00 fc 	      lda	MoveFrom,x
      2  10f3		       85 b3		      sta	__xchg
      0  10f5					      lda@PLY	MoveFrom,y
      1  10f5		       b9 00 fc 	      lda	MoveFrom,y
      0  10f8					      sta@PLY	MoveFrom,x
      1  10f8		       9d 00 fe 	      sta	[RAM]+MoveFrom,x
      5  10fb		       a5 b3		      lda	__xchg
      0  10fd					      sta@PLY	MoveFrom,y
      1  10fd		       99 00 fe 	      sta	[RAM]+MoveFrom,y
      0  1100					      XCHG	MoveTo
      0  1100					      lda@PLY	MoveTo,x
      1  1100		       bd 00 fd 	      lda	MoveTo,x
      2  1103		       85 b3		      sta	__xchg
      0  1105					      lda@PLY	MoveTo,y
      1  1105		       b9 00 fd 	      lda	MoveTo,y
      0  1108					      sta@PLY	MoveTo,x
      1  1108		       9d 00 ff 	      sta	[RAM]+MoveTo,x
      5  110b		       a5 b3		      lda	__xchg
      0  110d					      sta@PLY	MoveTo,y
      1  110d		       99 00 ff 	      sta	[RAM]+MoveTo,y
      0  1110					      XCHG	MovePiece
      0  1110					      lda@PLY	MovePiece,x
      1  1110		       bd 00 fe 	      lda	MovePiece,x
      2  1113		       85 b3		      sta	__xchg
      0  1115					      lda@PLY	MovePiece,y
      1  1115		       b9 00 fe 	      lda	MovePiece,y
      0  1118					      sta@PLY	MovePiece,x
      1  1118		       9d 00 00 	      sta	[RAM]+MovePiece,x
      5  111b		       a5 b3		      lda	__xchg
      0  111d					      sta@PLY	MovePiece,y
      1  111d		       99 00 00 	      sta	[RAM]+MovePiece,y
      0  1120					      XCHG	MoveCapture
      0  1120					      lda@PLY	MoveCapture,x
      1  1120		       bd 00 ff 	      lda	MoveCapture,x
      2  1123		       85 b3		      sta	__xchg
      0  1125					      lda@PLY	MoveCapture,y
      1  1125		       b9 00 ff 	      lda	MoveCapture,y
      0  1128					      sta@PLY	MoveCapture,x
      1  1128		       9d 00 01 	      sta	[RAM]+MoveCapture,x
      5  112b		       a5 b3		      lda	__xchg
      0  112d					      sta@PLY	MoveCapture,y
      1  112d		       99 00 01 	      sta	[RAM]+MoveCapture,y
    292  1130
    293  1130		       ca		      dex
    294  1131		       10 b5		      bpl	.next
    295  1133
    296  1133				   .exit
    297  1133
    298  1133
    299  1133
    300  1133
    301  1133							; Scan for capture of king
    302  1133
      0  1133					      ldx@PLY	moveIndex
      1  1133		       ae 9e ff 	      ldx	moveIndex
    304  1136
      0  1136				   .scanCheck lda@PLY	MoveCapture,x
      1  1136		       bd 00 ff 	      lda	MoveCapture,x
    306  1139		       f0 0b		      beq	.check	; since they're sorted with captures "first" we can exit
    307  113b		       29 0f		      and	#PIECE_MASK
    308  113d		       c9 07		      cmp	#KING
    309  113f		       f0 05		      beq	.check
    310  1141		       ca		      dex
    311  1142		       10 f2		      bpl	.scanCheck
    312  1144
    313  1144		       a9 00		      lda	#0
    314  1146		       85 9f	   .check     sta	flagCheck
    315  1148		       60		      rts
    316  1149
    317  1149
    318  1149							;---------------------------------------------------------------------------------------------------
    319  1149							; QUIESCE!
    320  1149
    321  1149							;int Quiesce( int alpha, int beta ) {
    322  1149							;    int stand_pat = Evaluate();
    323  1149							;    if( stand_pat >= beta )
    324  1149							;	  return beta;
    325  1149							;    if( alpha < stand_pat )
    326  1149							;	  alpha = stand_pat;
    327  1149
    328  1149							;    until( every_capture_has_been_examined )	{
    329  1149							;	  MakeCapture();
    330  1149							;	  score = -Quiesce( -beta, -alpha );
    331  1149							;	  TakeBackMove();
    332  1149
    333  1149							;	  if( score >= beta )
    334  1149							;	      return beta;
    335  1149							;	  if( score > alpha )
    336  1149							;	     alpha = score;
    337  1149							;    }
    338  1149							;    return alpha;
    339  1149							;}
    340  1149
    341  1149
      0  1149					      DEF	quiesce
      1  1149				   SLOT_quiesce SET	_BANK_SLOT
      2  1149				   BANK_quiesce SET	SLOT_quiesce + _CURRENT_BANK
      3  1149				   quiesce
      4  1149				   TEMPORARY_VAR SET	Overlay
      5  1149				   TEMPORARY_OFFSET SET	0
      6  1149				   VAR_BOUNDARY_quiesce SET	TEMPORARY_OFFSET
      7  1149				   FUNCTION_NAME SET	quiesce
    343  1149					      SUBROUTINE
    344  1149
    345  1149							; pass...
    346  1149							; x = depthleft
    347  1149							; SET_BANK_RAM      --> current ply
    348  1149							; __alpha[2] = param alpha
    349  1149							; __beta[2] = param beta
    350  1149
    351  1149
      0  1149					      COMMON_VARS_ALPHABETA
      1  1149
      0  1149					      VAR	__thinkbar, 1
      1  1149		       00 a2	   __thinkbar =	TEMPORARY_VAR
      2  1149				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1149
      4  1149				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1149				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1149				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1149					      ENDIF
      8  1149				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1149				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  1149				  -	      ERR
     11  1149					      ENDIF
     12  1149					      LIST	ON
      0  1149					      VAR	__toggle, 1
      1  1149		       00 a3	   __toggle   =	TEMPORARY_VAR
      2  1149				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1149
      4  1149				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1149				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1149				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1149					      ENDIF
      8  1149				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1149				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  1149				  -	      ERR
     11  1149					      ENDIF
     12  1149					      LIST	ON
      4  1149
      0  1149					      VAR	__bestMove, 1
      1  1149		       00 a4	   __bestMove =	TEMPORARY_VAR
      2  1149				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1149
      4  1149				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1149				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1149				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1149					      ENDIF
      8  1149				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1149				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  1149				  -	      ERR
     11  1149					      ENDIF
     12  1149					      LIST	ON
      0  1149					      VAR	__alpha, 2
      1  1149		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  1149				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1149
      4  1149				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1149				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1149				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1149					      ENDIF
      8  1149				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1149				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  1149				  -	      ERR
     11  1149					      ENDIF
     12  1149					      LIST	ON
      0  1149					      VAR	__beta, 2
      1  1149		       00 a7	   __beta     =	TEMPORARY_VAR
      2  1149				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1149
      4  1149				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1149				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1149				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1149					      ENDIF
      8  1149				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1149				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  1149				  -	      ERR
     11  1149					      ENDIF
     12  1149					      LIST	ON
      0  1149					      VAR	__negaMax, 2
      1  1149		       00 a9	   __negaMax  =	TEMPORARY_VAR
      2  1149				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1149
      4  1149				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1149				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1149				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1149					      ENDIF
      8  1149				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1149				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  1149				  -	      ERR
     11  1149					      ENDIF
     12  1149					      LIST	ON
      0  1149					      VAR	__value, 2
      1  1149		       00 ab	   __value    =	TEMPORARY_VAR
      2  1149				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1149
      4  1149				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1149				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1149				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1149					      ENDIF
      8  1149				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1149				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  1149				  -	      ERR
     11  1149					      ENDIF
     12  1149					      LIST	ON
     10  1149
      0  1149					      VAR	__quiesceCapOnly, 1
      1  1149		       00 ad	   __quiesceCapOnly =	TEMPORARY_VAR
      2  1149				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1149
      4  1149				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1149				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1149				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1149					      ENDIF
      8  1149				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1149				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  1149				  -	      ERR
     11  1149					      ENDIF
     12  1149					      LIST	ON
     12  1149
      0  1149					      REFER	selectmove
      1  1149				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  1149				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  1149					      ENDIF
      0  1149					      REFER	negaMax
      1  1149				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  1149				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  1149					      ENDIF
      0  1149					      VEND	quiesce
      1  1149				  -	      IFNCONST	quiesce
      2  1149				  -	      ECHO	"Incorrect VEND label", quiesce
      3  1149				  -	      ERR
      4  1149					      ENDIF
      5  1149		       00 ae	   VAREND_quiesce =	TEMPORARY_VAR
    356  1149
    357  1149		       a5 95		      lda	currentPly
    358  114b		       c9 ce		      cmp	#RAMBANK_PLY + MAX_PLY_DEPTH_BANK -1
    359  114d		       b0 43		      bcs	.retBeta
    360  114f
    361  114f							; The 'thinkbar' pattern...
    362  114f
    363  114f		       a9 00		      lda	#0
    364  1151		       a4 4c		      ldy	INPT4
    365  1153		       30 14		      bmi	.doThink
    366  1155
    367  1155		       a5 a2		      lda	__thinkbar
    368  1157		       0a		      asl
    369  1158		       0a		      asl
    370  1159		       0a		      asl
    371  115a		       0a		      asl
    372  115b		       09 02		      ora	#2
    373  115d		       85 48		      sta	COLUPF
    374  115f
    375  115f		       e6 a2		      inc	__thinkbar
    376  1161		       a5 a2		      lda	__thinkbar
    377  1163		       29 0f		      and	#15
    378  1165		       a8		      tay
    379  1166		       b9 4f f6 	      lda	SynapsePattern2,y
    380  1169
    381  1169		       85 4e	   .doThink   sta	PF1
    382  116b		       85 4f		      sta	PF2
    383  116d
    384  116d							; ^
    385  116d
    386  116d		       a5 a7		      lda	__beta
      0  116f					      sta@PLY	beta
      1  116f		       8d a3 01 	      sta	[RAM]+beta
    388  1172		       a5 a8		      lda	__beta+1
      0  1174					      sta@PLY	beta+1
      1  1174		       8d a4 01 	      sta	[RAM]+beta+1
    390  1177
    391  1177		       a5 a5		      lda	__alpha
      0  1179					      sta@PLY	alpha
      1  1179		       8d a1 01 	      sta	[RAM]+alpha
    393  117c		       a5 a6		      lda	__alpha+1
      0  117e					      sta@PLY	alpha+1
      1  117e		       8d a2 01 	      sta	[RAM]+alpha+1
    395  1181
    396  1181
    397  1181							;    int stand_pat = Evaluate();
    398  1181							;    if( stand_pat >= beta )
    399  1181							;	  return beta;
    400  1181
    401  1181		       38		      sec
    402  1182		       a5 90		      lda	Evaluation
      0  1184					      sbc@PLY	beta
      1  1184		       ed a3 ff 	      sbc	beta
    404  1187		       a5 91		      lda	Evaluation+1
      0  1189					      sbc@PLY	beta+1
      1  1189		       ed a4 ff 	      sbc	beta+1
    406  118c		       50 02		      bvc	.spat0
    407  118e		       49 80		      eor	#$80
    408  1190		       30 0b	   .spat0     bmi	.norb	;pl .retBeta			 ; branch if stand_pat >= beta
    409  1192
    410  1192		       ad a3 ff    .retBeta   lda	beta
    411  1195		       85 a9		      sta	__negaMax
    412  1197		       ad a4 ff 	      lda	beta+1
    413  119a		       85 aa		      sta	__negaMax+1
    414  119c
    415  119c		       60	   .abort     rts
    416  119d
    417  119d				   .norb
    418  119d
    419  119d
    420  119d							;    if( alpha < stand_pat )
    421  119d							;	  alpha = stand_pat;
    422  119d
    423  119d		       38		      sec
    424  119e		       ad a1 ff 	      lda	alpha
    425  11a1		       e5 90		      sbc	Evaluation
    426  11a3		       ad a2 ff 	      lda	alpha+1
    427  11a6		       e5 91		      sbc	Evaluation+1
    428  11a8		       50 02		      bvc	.spat1
    429  11aa		       49 80		      eor	#$80
    430  11ac		       10 0a	   .spat1     bpl	.alpha	; branch if alpha >= stand_pat
    431  11ae
    432  11ae							; alpha < stand_pat
    433  11ae
    434  11ae		       a5 90		      lda	Evaluation
      0  11b0					      sta@PLY	alpha
      1  11b0		       8d a1 01 	      sta	[RAM]+alpha
    436  11b3		       a5 91		      lda	Evaluation+1
      0  11b5					      sta@PLY	alpha+1
      1  11b5		       8d a2 01 	      sta	[RAM]+alpha+1
    438  11b8
    439  11b8				   .alpha
    440  11b8		       20 1c f5 	      jsr	GenerateAllMoves
    441  11bb		       a5 9f		      lda	flagCheck
    442  11bd		       d0 dd		      bne	.abort	; pure abort
    443  11bf
      0  11bf					      ldx@PLY	moveIndex
      1  11bf		       ae 9e ff 	      ldx	moveIndex
    445  11c2		       30 7a		      bmi	.exit
    446  11c4
      0  11c4				   .forChild  stx@PLY	movePtr
      1  11c4		       8e 9f 01 	      stx	[RAM]+movePtr
    448  11c7
    449  11c7							; The movelist has captures ONLY (ref: __quiesceCapOnly != 0)
    450  11c7
    451  11c7		       20 00 f4 	      jsr	MakeMove
    452  11ca
    453  11ca		       38		      sec
    454  11cb		       a9 00		      lda	#0
      0  11cd					      sbc@PLY	beta
      1  11cd		       ed a3 ff 	      sbc	beta
    456  11d0		       85 a5		      sta	__alpha
    457  11d2		       a9 00		      lda	#0
      0  11d4					      sbc@PLY	beta+1
      1  11d4		       ed a4 ff 	      sbc	beta+1
    459  11d7		       85 a6		      sta	__alpha+1
    460  11d9
    461  11d9		       38		      sec
    462  11da		       a9 00		      lda	#0
      0  11dc					      sbc@PLY	alpha
      1  11dc		       ed a1 ff 	      sbc	alpha
    464  11df		       85 a7		      sta	__beta
    465  11e1		       a9 00		      lda	#0
      0  11e3					      sbc@PLY	alpha+1
      1  11e3		       ed a2 ff 	      sbc	alpha+1
    467  11e6		       85 a8		      sta	__beta+1
    468  11e8
    469  11e8		       e6 95		      inc	currentPly
    470  11ea		       a5 95		      lda	currentPly
    471  11ec		       85 3e		      sta	SET_BANK_RAM	; self-switch
    472  11ee
    473  11ee		       20 49 f5 	      jsr	quiesce
    474  11f1
    475  11f1		       c6 95		      dec	currentPly
    476  11f3		       a5 95		      lda	currentPly
    477  11f5		       85 3e		      sta	SET_BANK_RAM
    478  11f7
    479  11f7		       20 6f f4 	      jsr	unmakeMove
    480  11fa
    481  11fa		       a5 9f		      lda	flagCheck	; don't consider moves which leave us in check
    482  11fc		       d0 4b		      bne	.inCheck
    483  11fe
    484  11fe		       38		      sec
    485  11ff							;lda #0			 ; already 0
    486  11ff		       e5 a9		      sbc	__negaMax
    487  1201		       85 a9		      sta	__negaMax
    488  1203		       a9 00		      lda	#0
    489  1205		       e5 aa		      sbc	__negaMax+1
    490  1207		       85 aa		      sta	__negaMax+1	; -negaMax(...)
    491  1209
    492  1209
    493  1209
    494  1209							;	  if( score >= beta )
    495  1209							;	      return beta;
    496  1209
    497  1209
    498  1209		       38		      sec
    499  120a		       a5 a9		      lda	__negaMax
      0  120c					      sbc@PLY	beta
      1  120c		       ed a3 ff 	      sbc	beta
    501  120f		       a5 aa		      lda	__negaMax+1
      0  1211					      sbc@PLY	beta+1
      1  1211		       ed a4 ff 	      sbc	beta+1
    503  1214		       50 02		      bvc	.lab0
    504  1216		       49 80		      eor	#$80
    505  1218		       30 03	   .lab0      bmi	.nrb2	; .retBeta		       ; branch if score >= beta
    506  121a		       4c 92 f5 	      jmp	.retBeta
    507  121d				   .nrb2
    508  121d
    509  121d							;	  if( score > alpha )
    510  121d							;	     alpha = score;
    511  121d							;    }
    512  121d
    513  121d		       38		      sec
      0  121e					      lda@PLY	alpha
      1  121e		       ad a1 ff 	      lda	alpha
    515  1221		       e5 a9		      sbc	__negaMax
      0  1223					      lda@PLY	alpha+1
      1  1223		       ad a2 ff 	      lda	alpha+1
    517  1226		       e5 aa		      sbc	__negaMax+1
    518  1228		       50 02		      bvc	.lab2
    519  122a		       49 80		      eor	#$80
    520  122c		       10 0a	   .lab2      bpl	.nextMove	; alpha >= score
    521  122e
    522  122e							; score > alpha
    523  122e
    524  122e		       a5 a9		      lda	__negaMax
      0  1230					      sta@PLY	alpha
      1  1230		       8d a1 01 	      sta	[RAM]+alpha
    526  1233		       a5 aa		      lda	__negaMax+1
      0  1235					      sta@PLY	alpha+1
      1  1235		       8d a2 01 	      sta	[RAM]+alpha+1
    528  1238
      0  1238				   .nextMove  ldx@PLY	movePtr
      1  1238		       ae 9f ff 	      ldx	movePtr
    530  123b		       ca		      dex
    531  123c		       10 86		      bpl	.forChild
    532  123e
    533  123e							;    return alpha;
    534  123e
    535  123e				   .exit
      0  123e					      lda@PLY	alpha
      1  123e		       ad a1 ff 	      lda	alpha
    537  1241		       85 a9		      sta	__negaMax
      0  1243					      lda@PLY	alpha+1
      1  1243		       ad a2 ff 	      lda	alpha+1
    539  1246		       85 aa		      sta	__negaMax+1
    540  1248		       60		      rts
    541  1249
    542  1249		       a9 00	   .inCheck   lda	#0
    543  124b		       85 9f		      sta	flagCheck
    544  124d		       f0 e9		      beq	.nextMove
    545  124f
    546  124f
    547  124f
    548  124f				   SynapsePattern2
    549  124f
    550  124f		       c1		      .byte.b	%11000001
    551  1250		       60		      .byte.b	%01100000
    552  1251		       30		      .byte.b	%00110000
    553  1252		       18		      .byte.b	%00011000
    554  1253		       0c		      .byte.b	%00001100
    555  1254		       06		      .byte.b	%00000110
    556  1255		       83		      .byte.b	%10000011
    557  1256		       c1		      .byte.b	%11000001
    558  1257
    559  1257		       83		      .byte.b	%10000011
    560  1258		       06		      .byte.b	%00000110
    561  1259		       0c		      .byte.b	%00001100
    562  125a		       18		      .byte.b	%00011000
    563  125b		       30		      .byte.b	%00110000
    564  125c		       60		      .byte.b	%01100000
    565  125d		       c1		      .byte.b	%11000001
    566  125e		       83		      .byte.b	%10000011
    567  125f
    568  125f
    569  125f							;---------------------------------------------------------------------------------------------------
    570  125f
      0  125f					      DEF	AddMovePly
      1  125f				   SLOT_AddMovePly SET	_BANK_SLOT
      2  125f				   BANK_AddMovePly SET	SLOT_AddMovePly + _CURRENT_BANK
      3  125f				   AddMovePly
      4  125f				   TEMPORARY_VAR SET	Overlay
      5  125f				   TEMPORARY_OFFSET SET	0
      6  125f				   VAR_BOUNDARY_AddMovePly SET	TEMPORARY_OFFSET
      7  125f				   FUNCTION_NAME SET	AddMovePly
    572  125f					      SUBROUTINE
    573  125f
      0  125f					      REFER	AddMove
      1  125f				  -	      IF	VAREND_AddMove > TEMPORARY_VAR
      2  125f				  -TEMPORARY_VAR SET	VAREND_AddMove
      3  125f					      ENDIF
      0  125f					      VEND	AddMovePly
      1  125f				  -	      IFNCONST	AddMovePly
      2  125f				  -	      ECHO	"Incorrect VEND label", AddMovePly
      3  125f				  -	      ERR
      4  125f					      ENDIF
      5  125f		       00 a2	   VAREND_AddMovePly =	TEMPORARY_VAR
    576  125f
    577  125f		       98		      tya
    578  1260
      0  1260					      ldy@PLY	moveIndex
      1  1260		       ac 9e ff 	      ldy	moveIndex
    580  1263		       c8		      iny
      0  1264					      sty@PLY	moveIndex
      1  1264		       8c 9e 01 	      sty	[RAM]+moveIndex
    582  1267
      0  1267					      sta@PLY	MoveTo,y
      1  1267		       99 00 ff 	      sta	[RAM]+MoveTo,y
    584  126a		       aa		      tax		; used for continuation of sliding moves
    585  126b		       a5 93		      lda	currentSquare
      0  126d					      sta@PLY	MoveFrom,y
      1  126d		       99 00 fe 	      sta	[RAM]+MoveFrom,y
    587  1270		       a5 92		      lda	currentPiece
      0  1272					      sta@PLY	MovePiece,y
      1  1272		       99 00 00 	      sta	[RAM]+MovePiece,y
    589  1275		       a5 9e		      lda	capture
      0  1277					      sta@PLY	MoveCapture,y
      1  1277		       99 00 01 	      sta	[RAM]+MoveCapture,y
    591  127a
    592  127a		       60		      rts
    593  127b
    594  127b
    595  127b							;---------------------------------------------------------------------------------------------------
    596  127b
      0  127b					      CHECK_BANK_SIZE	"BANK_PLY"
      1  127b		       02 7b	   .TEMP      =	* - _BANK_START
 BANK_PLY (1K) SIZE =  $27b , FREE= $185
      2  127b					      ECHO	"BANK_PLY", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  127b				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  127b				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_PLY", " size=", * - ORIGIN
      5  127b				  -	      ERR
      6  127b					      ENDIF
    598  127b
    599  127b							;---------------------------------------------------------------------------------------------------
    600  127b							; EOF
------- FILE ./chess.asm
------- FILE SHADOW_PLY.asm LEVEL 2 PASS 4
      0  127b					      include	"SHADOW_PLY.asm"
      1  127b							; Chess
      2  127b							; Copyright (c) 2019-2020 Andrew Davie
      3  127b							; andrew@taswegian.com
      4  127b
      5  127b
      6  127b							;---------------------------------------------------------------------------------------------------
      7  127b							; Define the RAM banks
      8  127b							; A "PLY" bank represents all the data required on any single ply of the search tree.
      9  127b							; The banks are organised sequentially, PLY_BANKS of them starting at RAMBANK_PLY
     10  127b							; The startup code copies the ROM shadow into each of these PLY banks, and from then on
     11  127b							; they act as independant switchable banks usable for data on each ply during the search.
     12  127b							; A ply will hold the move list for that position
     13  127b
     14  127b
      0  127b					      SLOT	3
      1  127b				  -	      IF	(3 < 0) || (3 > 3)
      2  127b				  -	      ECHO	"Illegal bank address/segment location", 3
      3  127b				  -	      ERR
      4  127b					      ENDIF
      5  127b				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  127b				   _BANK_SLOT SET	3 * 64
      0  127b					      NEWRAMBANK	PLY	; RAM bank for holding the following ROM shadow
      1  127b
      2  127b
      3  127b
      4 U1000 ????				      SEG.U	PLY
      5 U1000					      ORG	ORIGIN_RAM
      6 U1000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1000				   _BANK_START SET	*
      8 U1000				   RAMBANK_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1000				   _CURRENT_RAMBANK SET	RAMBANK_PLY
     10 U1000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U1000					      REPEAT	PLY_BANKS-1
      0 U1000					      NEWRAMBANK	.DUMMY_PLY
      1 U1000
      2 U1000
      3 U1000
      4 U1c00 ????				      SEG.U	.DUMMY_PLY
      5 U1200					      ORG	ORIGIN_RAM
      6 U1200					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1200				   _BANK_START SET	*
      8 U1200				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1200				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U1200				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U1200					      REPEND
      0 U1200					      NEWRAMBANK	.DUMMY_PLY
      1 U1200
      2 U1200
      3 U1200
      4 U1200					      SEG.U	.DUMMY_PLY
      5 U1400					      ORG	ORIGIN_RAM
      6 U1400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1400				   _BANK_START SET	*
      8 U1400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U1400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY_PLY
      1 U1400
      2 U1400
      3 U1400
      4 U1400					      SEG.U	.DUMMY_PLY
      5 U1600					      ORG	ORIGIN_RAM
      6 U1600					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1600				   _BANK_START SET	*
      8 U1600				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1600				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U1600				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U1600					      REPEND
      0 U1600					      NEWRAMBANK	.DUMMY_PLY
      1 U1600
      2 U1600
      3 U1600
      4 U1600					      SEG.U	.DUMMY_PLY
      5 U1800					      ORG	ORIGIN_RAM
      6 U1800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1800				   _BANK_START SET	*
      8 U1800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U1800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY_PLY
      1 U1800
      2 U1800
      3 U1800
      4 U1800					      SEG.U	.DUMMY_PLY
      5 U1a00					      ORG	ORIGIN_RAM
      6 U1a00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1a00				   _BANK_START SET	*
      8 U1a00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1a00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U1a00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U1a00					      REPEND
      0 U1a00					      NEWRAMBANK	.DUMMY_PLY
      1 U1a00
      2 U1a00
      3 U1a00
      4 U1a00					      SEG.U	.DUMMY_PLY
      5 U1c00					      ORG	ORIGIN_RAM
      6 U1c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1c00				   _BANK_START SET	*
      8 U1c00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     19 U1c00					      REPEND
     20 U1c00
     21 U1c00
     22 U1c00							; and now the ROM shadow - this is copied to ALL of the RAM ply banks
     23 U1c00
      0 U1c00					      SLOT	3
      1 U1c00				  -	      IF	(3 < 0) || (3 > 3)
      2 U1c00				  -	      ECHO	"Illegal bank address/segment location", 3
      3 U1c00				  -	      ERR
      4 U1c00					      ENDIF
      5 U1c00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6 U1c00				   _BANK_SLOT SET	3 * 64
      0 U1c00					      NEWBANK	SHADOW_PLY
      1  17ac ????				      SEG	SHADOW_PLY
      2  1400					      ORG	_ORIGIN
      3  1400					      RORG	_BANK_ADDRESS_ORIGIN
      4  1400				   _BANK_START SET	*
      5  1400				   SHADOW_PLY_START SET	*
      6  1400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1400				   SHADOW_PLY SET	_BANK_SLOT + _CURRENT_BANK
      8  1400				   _ORIGIN    SET	_ORIGIN + 1024
     26  1400
     27  1400							;---------------------------------------------------------------------------------------------------
     28  1400
     29  1400		       00 96	   MAX_MOVES  =	150	; big is good
     30  1400
      0  1400					      VARIABLE	MoveFrom, MAX_MOVES
      0  1400					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  1400					      LIST	ON
      2  1400		       00 00 00 00*MoveFrom   ds	MAX_MOVES
      0  1496					      VARIABLE	MoveTo, MAX_MOVES
      0  1496					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  1500					      LIST	ON
      2  1500		       00 00 00 00*MoveTo     ds	MAX_MOVES
      0  1596					      VARIABLE	MovePiece, MAX_MOVES
      0  1596					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  1600					      LIST	ON
      2  1600		       00 00 00 00*MovePiece  ds	MAX_MOVES
      0  1696					      VARIABLE	MoveCapture, MAX_MOVES
      0  1696					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  1700					      LIST	ON
      2  1700		       00 00 00 00*MoveCapture ds	MAX_MOVES
     35  1796
     36  1796
     37  1796							;---------------------------------------------------------------------------------------------------
     38  1796
     39  1796							; The X12 square at which a pawn CAN be taken en-passant. Normally 0.
     40  1796							; This is set/cleared whenever a move is made. The flag is indicated in the move description.
     41  1796
      0  1796					      VARIABLE	savedEvaluation, 2	; THIS node's evaluation - used for reverting moves!
      0  1796					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  1796					      LIST	ON
      2  1796		       00 00	   savedEvaluation ds	2
      0  1798					      VARIABLE	enPassantSquare, 1
      0  1798					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  1798					      LIST	ON
      2  1798		       00	   enPassantSquare ds	1
      0  1799					      VARIABLE	capturedPiece, 1
      0  1799					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  1799					      LIST	ON
      2  1799		       00	   capturedPiece ds	1
      0  179a					      VARIABLE	originalPiece, 1
      0  179a					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  179a					      LIST	ON
      2  179a		       00	   originalPiece ds	1
      0  179b					      VARIABLE	secondaryPiece, 1	; original piece on secondary (castle, enpassant)
      0  179b					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  179b					      LIST	ON
      2  179b		       00	   secondaryPiece ds	1
      0  179c					      VARIABLE	secondarySquare, 1	; original square of secondary piece
      0  179c					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  179c					      LIST	ON
      2  179c		       00	   secondarySquare ds	1
      0  179d					      VARIABLE	secondaryBlank, 1	; square to blank on secondary
      0  179d					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  179d					      LIST	ON
      2  179d		       00	   secondaryBlank ds	1
      0  179e					      VARIABLE	moveIndex, 1	; points to first available 'slot' for move storage
      0  179e					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  179e					      LIST	ON
      2  179e		       00	   moveIndex  ds	1
      0  179f					      VARIABLE	movePtr, 1
      0  179f					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  179f					      LIST	ON
      2  179f		       00	   movePtr    ds	1
      0  17a0					      VARIABLE	bestMove, 1
      0  17a0					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  17a0					      LIST	ON
      2  17a0		       00	   bestMove   ds	1
      0  17a1					      VARIABLE	alpha, 2
      0  17a1					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  17a1					      LIST	ON
      2  17a1		       00 00	   alpha      ds	2
      0  17a3					      VARIABLE	beta, 2
      0  17a3					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  17a3					      LIST	ON
      2  17a3		       00 00	   beta       ds	2
      0  17a5					      VARIABLE	value, 2
      0  17a5					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  17a5					      LIST	ON
      2  17a5		       00 00	   value      ds	2
      0  17a7					      VARIABLE	depthLeft, 1
      0  17a7					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  17a7					      LIST	ON
      2  17a7		       00	   depthLeft  ds	1
      0  17a8					      VARIABLE	restorePiece, 1
      0  17a8					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  17a8					      LIST	ON
      2  17a8		       00	   restorePiece ds	1
      0  17a9					      VARIABLE	kingSquare, 3	; traversing squares for castle/check
      0  17a9					      OPTIONAL_PAGEBREAK	"Variable", 3
     12  17a9					      LIST	ON
      2  17a9		       00 00 00    kingSquare ds	3
     58  17ac
     59  17ac
     60  17ac							;---------------------------------------------------------------------------------------------------
     61  17ac							; EOF
------- FILE ./chess.asm
------- FILE SHADOW_BOARD.asm LEVEL 2 PASS 4
      0  17ac					      include	"SHADOW_BOARD.asm"
      1  17ac							; Copyright (C)2020 Andrew Davie
      2  17ac
      3  17ac
      4  17ac							;---------------------------------------------------------------------------------------------------
      0  17ac					      SLOT	3
      1  17ac				  -	      IF	(3 < 0) || (3 > 3)
      2  17ac				  -	      ECHO	"Illegal bank address/segment location", 3
      3  17ac				  -	      ERR
      4  17ac					      ENDIF
      5  17ac				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  17ac				   _BANK_SLOT SET	3 * 64
      0  17ac					      NEWRAMBANK	BOARD	; RAM bank for holding the following ROM shadow
      1  17ac
      2  17ac
      3  17ac
      4 U1e00 ????				      SEG.U	BOARD
      5 U1e00					      ORG	ORIGIN_RAM
      6 U1e00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1e00				   _BANK_START SET	*
      8 U1e00				   RAMBANK_BOARD SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1e00				   _CURRENT_RAMBANK SET	RAMBANK_BOARD
     10 U1e00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      7 U1e00
      8 U1e00		       fc 15	   ValidSquare =	ShadowValidSquare + $400
      9 U1e00		       fc 79	   Board      =	ShadowBoard + $400
     10 U1e00
      0 U1e00					      SLOT	2
      1 U1e00				  -	      IF	(2 < 0) || (2 > 3)
      2 U1e00				  -	      ECHO	"Illegal bank address/segment location", 2
      3 U1e00				  -	      ERR
      4 U1e00					      ENDIF
      5 U1e00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6 U1e00				   _BANK_SLOT SET	2 * 64
      0 U1e00					      NEWBANK	SHADOW_BOARD	; copy the following bank to RAMBANK_BOARD
      1  18dd ????				      SEG	SHADOW_BOARD
      2  1800					      ORG	_ORIGIN
      3  1800					      RORG	_BANK_ADDRESS_ORIGIN
      4  1800				   _BANK_START SET	*
      5  1800				   SHADOW_BOARD_START SET	*
      6  1800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1800				   SHADOW_BOARD SET	_BANK_SLOT + _CURRENT_BANK
      8  1800				   _ORIGIN    SET	_ORIGIN + 1024
     13  1800
     14  1800							; Board is a 10 x 12 object which simplifies the generation of moves
     15  1800							; The squares marked '░░░' are illegal. The ("X12") index of each square is the left
     16  1800							; number + the bottom number. Bottom left legal square (AS VISIBLE ON SCREEN) is #22
     17  1800
     18  1800							;     X12 numbering
     19  1800							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     20  1800							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     21  1800							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     22  1800							; 90 ┃░░░┊░░░┊ 92┊ 93┊ 94┊ 95┊ 96┊ 97┊ 98┊ 99┃ 8 BLACK
     23  1800							; 80 ┃░░░┊░░░┊ 82┊ 83┊ 84┊ 85┊ 86┊ 87┊ 88┊ 89┃ 7 BLACK
     24  1800							; 70 ┃░░░┊░░░┊ 72┊ 73┊ 74┊ 75┊ 76┊ 77┊ 78┊ 79┃ 6
     25  1800							; 60 ┃░░░┊░░░┊ 62┊ 63┊ 64┊ 65┊ 66┊ 67┊ 68┊ 69┃ 5
     26  1800							; 50 ┃░░░┊░░░┊ 52┊ 53┊ 54┊ 55┊ 56┊ 57┊ 58┊ 59┃ 4
     27  1800							; 40 ┃░░░┊░░░┊ 42┊ 43┊ 44┊ 45┊ 46┊ 47┊ 48┊ 49┃ 3
     28  1800							; 30 ┃░░░┊░░░┊ 32┊ 33┊ 34┊ 35┊ 36┊ 37┊ 38┊ 39┃ 2 WHITE
     29  1800							; 20 ┃░░░┊░░░┊ 22┊ 23┊ 24┊ 25┊ 26┊ 27┊ 28┊ 29┃ 1 WHITE
     30  1800							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     31  1800							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     32  1800							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     33  1800							;	0   1	2   3	4   5	6   7	8   9
     34  1800							;		A   B	C   D	E   F	G   H
     35  1800
     36  1800							;     HEX X12
     37  1800							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     38  1800							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     39  1800							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     40  1800							; 90 ┃░░░┊░░░┊$5C┊$5D┊$5E┊$5F┊$60┊$61┊$62┊$63┃ 8
     41  1800							; 80 ┃░░░┊░░░┊$52┊$53┊$54┊$55┊$56┊$57┊$58┊$59┃ 7
     42  1800							; 70 ┃░░░┊░░░┊$48┊$49┊$4A┊$4B┊$4C┊$4D┊$4E┊$4F┃ 6
     43  1800							; 60 ┃░░░┊░░░┊$3E┊$3F┊$40┊$41┊$42┊$43┊$44┊$45┃ 5
     44  1800							; 50 ┃░░░┊░░░┊$34┊$35┊$36┊$37┊$38┊$39┊$3A┊$3B┃ 4
     45  1800							; 40 ┃░░░┊░░░┊$2A┊$2B┊$2C┊$2D┊$2E┊$2F┊$30┊$31┃ 3
     46  1800							; 30 ┃░░░┊░░░┊$20┊$21┊$22┊$23┊$24┊$25┊$26|$27┃ 2
     47  1800							; 20 ┃░░░┊░░░┊$16┊$17┊$18┊$19┊$1A┊$1B┊$1C┊$1D┃ 1
     48  1800							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     49  1800							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     50  1800							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     51  1800							;	0   1	2   3	4   5	6   7	8   9
     52  1800							;		A   B	C   D	E   F	G   H
     53  1800
     54  1800
     55  1800							; We put a short buffer before 'ValidSquare' when it is at the start of the bank, so that
     56  1800							; the move indexing (ie., "ValidSquare+{1},x" won't drop off the beginning of the bank
     57  1800							; and sause "segfaults". 21 is the max offset (a knight move). These spare bytes can
     58  1800							; be re-used for something else - we just need to guarantee there are 21 of them there
     59  1800
      0  1800					      ALLOCATE	Valid, 120 + 80 + 21
      0  1800					      OPTIONAL_PAGEBREAK	"Table", 120 + 80 + 21
     12  1800					      LIST	ON
      0  1800					      DEF	Valid
      1  1800				   SLOT_Valid SET	_BANK_SLOT
      2  1800				   BANK_Valid SET	SLOT_Valid + _CURRENT_BANK
      3  1800				   Valid
      4  1800				   TEMPORARY_VAR SET	Overlay
      5  1800				   TEMPORARY_OFFSET SET	0
      6  1800				   VAR_BOUNDARY_Valid SET	TEMPORARY_OFFSET
      7  1800				   FUNCTION_NAME SET	Valid
     61  1800		       00 00 00 00*	      ds	21	; so indexing of "ValidSquare-21,x" won't fail
     62  1815							; Note, we will never index INTO the above bytes - x will always be >= 21
     63  1815							; We just need to make sure that the actual indexing will not have an address before
     64  1815							; the index of outside the page.
     65  1815
      0  1815					      DEF	ShadowValidSquare
      1  1815				   SLOT_ShadowValidSquare SET	_BANK_SLOT
      2  1815				   BANK_ShadowValidSquare SET	SLOT_ShadowValidSquare + _CURRENT_BANK
      3  1815				   ShadowValidSquare
      4  1815				   TEMPORARY_VAR SET	Overlay
      5  1815				   TEMPORARY_OFFSET SET	0
      6  1815				   VAR_BOUNDARY_ShadowValidSquare SET	TEMPORARY_OFFSET
      7  1815				   FUNCTION_NAME SET	ShadowValidSquare
     67  1815
     68  1815
     69  1815							; Use this table to
     70  1815							;   a) Determine if a square is valid (-1 = NO)
     71  1815							;   b) Move pieces without addition.  e.g., "lda ValidSquareTable+10,x" will let you know
     72  1815							;	if a white pawn on square "x" can move "up" the board.
     73  1815
     74  1815		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     75  181f		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     76  1829		       ff ff 16 17*	      .byte.b	-1, -1, 22, 23, 24, 25, 26, 27, 28, 29
     77  1833		       ff ff 20 21*	      .byte.b	-1, -1, 32, 33, 34, 35, 36, 37, 38, 39
     78  183d		       ff ff 2a 2b*	      .byte.b	-1, -1, 42, 43, 44, 45, 46, 47, 48, 49
     79  1847		       ff ff 34 35*	      .byte.b	-1, -1, 52, 53, 54, 55, 56, 57, 58, 59
     80  1851		       ff ff 3e 3f*	      .byte.b	-1, -1, 62, 63, 64, 65, 66, 67, 68, 69
     81  185b		       ff ff 48 49*	      .byte.b	-1, -1, 72, 73, 74, 75, 76, 77, 78, 79
     82  1865		       ff ff 52 53*	      .byte.b	-1, -1, 82, 83, 84, 85, 86, 87, 88, 89
     83  186f		       ff ff 5c 5d*	      .byte.b	-1, -1, 92, 93, 94, 95, 96, 97, 98, 99	; CONTINUES...
     84  1879
      0  1879					      DEF	ShadowBoard
      1  1879				   SLOT_ShadowBoard SET	_BANK_SLOT
      2  1879				   BANK_ShadowBoard SET	SLOT_ShadowBoard + _CURRENT_BANK
      3  1879				   ShadowBoard
      4  1879				   TEMPORARY_VAR SET	Overlay
      5  1879				   TEMPORARY_OFFSET SET	0
      6  1879				   VAR_BOUNDARY_ShadowBoard SET	TEMPORARY_OFFSET
      7  1879				   FUNCTION_NAME SET	ShadowBoard
     86  1879
     87  1879							; A 10X10... we should never write using invalid square
     88  1879							; ON COPY TO RAM BANK, 'BOARD' SELF-INITIALISES TO THE FOLLOWING VALUES
     89  1879							; FROM THEN ON IT'S WRITEABLE (REMEMBER TO +RAM_WRITE) FOR MODIFICATIONS
     90  1879
     91  1879		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     92  1883		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     93  188d
     94  188d					      REPEAT	8
     95  188d		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  188d					      REPEND
     95  1897		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  1897					      REPEND
     95  18a1		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  18a1					      REPEND
     95  18ab		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  18ab					      REPEND
     95  18b5		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  18b5					      REPEND
     95  18bf		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  18bf					      REPEND
     95  18c9		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  18c9					      REPEND
     95  18d3		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     96  18dd					      REPEND
     97  18dd
     98  18dd							; DON'T OVERSTEP BOUNDS WHEN WRITING BOARD - MAXIMUM INDEX = 99
     99  18dd
    100  18dd
    101  18dd							;---------------------------------------------------------------------------------------------------
    102  18dd							; EOF
------- FILE ./chess.asm
------- FILE BANK_EVAL.asm LEVEL 2 PASS 4
      0  18dd					      include	"BANK_EVAL.asm"
      1  18dd
      0  18dd					      SLOT	2
      1  18dd				  -	      IF	(2 < 0) || (2 > 3)
      2  18dd				  -	      ECHO	"Illegal bank address/segment location", 2
      3  18dd				  -	      ERR
      4  18dd					      ENDIF
      5  18dd				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  18dd				   _BANK_SLOT SET	2 * 64
      3  18dd
      4  18dd
      0  18dd					      NEWRAMBANK	BANK_EVAL
      1  18dd
      2  18dd
      3  18dd
      4 U2000 ????				      SEG.U	BANK_EVAL
      5 U2000					      ORG	ORIGIN_RAM
      6 U2000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2000				   _BANK_START SET	*
      8 U2000				   RAMBANK_BANK_EVAL SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2000				   _CURRENT_RAMBANK SET	RAMBANK_BANK_EVAL
     10 U2000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U2000					      NEWBANK	EVAL
      1  1e50 ????				      SEG	EVAL
      2  1c00					      ORG	_ORIGIN
      3  1c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  1c00				   _BANK_START SET	*
      5  1c00				   EVAL_START SET	*
      6  1c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1c00				   EVAL       SET	_BANK_SLOT + _CURRENT_BANK
      8  1c00				   _ORIGIN    SET	_ORIGIN + 1024
      7  1c00
      8  1c00
      9  1c00							; see https://www.chessprogramming.org/Simplified_Evaluation_Function
     10  1c00
     11  1c00
     12  1c00
     13  1c00					      MAC	vequ
     14  1c00				   VALUE_{1}  =	{2}
     15  1c00					      ENDM
     16  1c00
     17  1c00					      MAC	lobyte
     18  1c00					      .byte	<{2}
     19  1c00					      ENDM
     20  1c00
     21  1c00					      MAC	hibyte
     22  1c00					      .byte	>{2}
     23  1c00					      ENDM
     24  1c00
     25  1c00
     26  1c00					      MAC	valuetable
     27  1c00					      {1}	BLANK, 0
     28  1c00					      {1}	PAWN, 100	; white
     29  1c00					      {1}	PAWN, 100	; black
     30  1c00					      {1}	KNIGHT, 320
     31  1c00					      {1}	BISHOP, 375
     32  1c00					      {1}	ROOK, 575
     33  1c00					      {1}	QUEEN, 900
     34  1c00					      {1}	KING, 10000
     35  1c00					      ENDM
     36  1c00
     37  1c00
      0  1c00					      VALUETABLE	VEQU
      0  1c00					      VEQU	BLANK, 0
      1  1c00		       00 00	   VALUE_BLANK =	0
      0  1c00					      VEQU	PAWN, 100
      1  1c00		       00 64	   VALUE_PAWN =	100
      0  1c00					      VEQU	PAWN, 100
      1  1c00		       00 64	   VALUE_PAWN =	100
      0  1c00					      VEQU	KNIGHT, 320
      1  1c00		       01 40	   VALUE_KNIGHT =	320
      0  1c00					      VEQU	BISHOP, 375
      1  1c00		       01 77	   VALUE_BISHOP =	375
      0  1c00					      VEQU	ROOK, 575
      1  1c00		       02 3f	   VALUE_ROOK =	575
      0  1c00					      VEQU	QUEEN, 900
      1  1c00		       03 84	   VALUE_QUEEN =	900
      0  1c00					      VEQU	KING, 10000
      1  1c00		       27 10	   VALUE_KING =	10000
     39  1c00
      0  1c00					      DEF	PieceValueLO
      1  1c00				   SLOT_PieceValueLO SET	_BANK_SLOT
      2  1c00				   BANK_PieceValueLO SET	SLOT_PieceValueLO + _CURRENT_BANK
      3  1c00				   PieceValueLO
      4  1c00				   TEMPORARY_VAR SET	Overlay
      5  1c00				   TEMPORARY_OFFSET SET	0
      6  1c00				   VAR_BOUNDARY_PieceValueLO SET	TEMPORARY_OFFSET
      7  1c00				   FUNCTION_NAME SET	PieceValueLO
      0  1c00					      VALUETABLE	LOBYTE
      0  1c00					      LOBYTE	BLANK, 0
      1  1c00		       00		      .byte.b	<0
      0  1c01					      LOBYTE	PAWN, 100
      1  1c01		       64		      .byte.b	<100
      0  1c02					      LOBYTE	PAWN, 100
      1  1c02		       64		      .byte.b	<100
      0  1c03					      LOBYTE	KNIGHT, 320
      1  1c03		       40		      .byte.b	<320
      0  1c04					      LOBYTE	BISHOP, 375
      1  1c04		       77		      .byte.b	<375
      0  1c05					      LOBYTE	ROOK, 575
      1  1c05		       3f		      .byte.b	<575
      0  1c06					      LOBYTE	QUEEN, 900
      1  1c06		       84		      .byte.b	<900
      0  1c07					      LOBYTE	KING, 10000
      1  1c07		       10		      .byte.b	<10000
     42  1c08
      0  1c08					      DEF	PieceValueHI
      1  1c08				   SLOT_PieceValueHI SET	_BANK_SLOT
      2  1c08				   BANK_PieceValueHI SET	SLOT_PieceValueHI + _CURRENT_BANK
      3  1c08				   PieceValueHI
      4  1c08				   TEMPORARY_VAR SET	Overlay
      5  1c08				   TEMPORARY_OFFSET SET	0
      6  1c08				   VAR_BOUNDARY_PieceValueHI SET	TEMPORARY_OFFSET
      7  1c08				   FUNCTION_NAME SET	PieceValueHI
      0  1c08					      VALUETABLE	HIBYTE
      0  1c08					      HIBYTE	BLANK, 0
      1  1c08		       00		      .byte.b	>0
      0  1c09					      HIBYTE	PAWN, 100
      1  1c09		       00		      .byte.b	>100
      0  1c0a					      HIBYTE	PAWN, 100
      1  1c0a		       00		      .byte.b	>100
      0  1c0b					      HIBYTE	KNIGHT, 320
      1  1c0b		       01		      .byte.b	>320
      0  1c0c					      HIBYTE	BISHOP, 375
      1  1c0c		       01		      .byte.b	>375
      0  1c0d					      HIBYTE	ROOK, 575
      1  1c0d		       02		      .byte.b	>575
      0  1c0e					      HIBYTE	QUEEN, 900
      1  1c0e		       03		      .byte.b	>900
      0  1c0f					      HIBYTE	KING, 10000
      1  1c0f		       27		      .byte.b	>10000
     45  1c10
     46  1c10
     47  1c10							;---------------------------------------------------------------------------------------------------
     48  1c10							; Vectors to the position value tables for each piece
     49  1c10
     50  1c10					      MAC	posval
     51  1c10					      .byte	0
     52  1c10					      .byte	{1}(PositionalValue_PAWN - 22)
     53  1c10					      .byte	{1}(PositionalValue_PAWN - 22)
     54  1c10					      .byte	{1}(PositionalValue_KNIGHT - 22)
     55  1c10					      .byte	{1}(PositionalValue_BISHOP - 22)
     56  1c10					      .byte	{1}(PositionalValue_ROOK - 22)
     57  1c10					      .byte	{1}(PositionalValue_QUEEN - 22)
     58  1c10					      .byte	{1}(PositionalValue_KING_MIDGAME - 22)
     59  1c10					      ENDM
     60  1c10
      0  1c10					      ALLOCATE	PosValVecLO, 8
      0  1c10					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1c10					      LIST	ON
      0  1c10					      DEF	PosValVecLO
      1  1c10				   SLOT_PosValVecLO SET	_BANK_SLOT
      2  1c10				   BANK_PosValVecLO SET	SLOT_PosValVecLO + _CURRENT_BANK
      3  1c10				   PosValVecLO
      4  1c10				   TEMPORARY_VAR SET	Overlay
      5  1c10				   TEMPORARY_OFFSET SET	0
      6  1c10				   VAR_BOUNDARY_PosValVecLO SET	TEMPORARY_OFFSET
      7  1c10				   FUNCTION_NAME SET	PosValVecLO
      0  1c10					      POSVAL	<
      1  1c10		       00		      .byte.b	0
      2  1c11		       0a		      .byte.b	<(PositionalValue_PAWN - 22)
      3  1c12		       0a		      .byte.b	<(PositionalValue_PAWN - 22)
      4  1c13		       5a		      .byte.b	<(PositionalValue_KNIGHT - 22)
      5  1c14		       aa		      .byte.b	<(PositionalValue_BISHOP - 22)
      6  1c15		       fa		      .byte.b	<(PositionalValue_ROOK - 22)
      7  1c16		       4a		      .byte.b	<(PositionalValue_QUEEN - 22)
      8  1c17		       9a		      .byte.b	<(PositionalValue_KING_MIDGAME - 22)
      0  1c18					      ALLOCATE	PosValVecHI, 8
      0  1c18					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1c18					      LIST	ON
      0  1c18					      DEF	PosValVecHI
      1  1c18				   SLOT_PosValVecHI SET	_BANK_SLOT
      2  1c18				   BANK_PosValVecHI SET	SLOT_PosValVecHI + _CURRENT_BANK
      3  1c18				   PosValVecHI
      4  1c18				   TEMPORARY_VAR SET	Overlay
      5  1c18				   TEMPORARY_OFFSET SET	0
      6  1c18				   VAR_BOUNDARY_PosValVecHI SET	TEMPORARY_OFFSET
      7  1c18				   FUNCTION_NAME SET	PosValVecHI
      0  1c18					      POSVAL	>
      1  1c18		       00		      .byte.b	0
      2  1c19		       f8		      .byte.b	>(PositionalValue_PAWN - 22)
      3  1c1a		       f8		      .byte.b	>(PositionalValue_PAWN - 22)
      4  1c1b		       f8		      .byte.b	>(PositionalValue_KNIGHT - 22)
      5  1c1c		       f8		      .byte.b	>(PositionalValue_BISHOP - 22)
      6  1c1d		       f8		      .byte.b	>(PositionalValue_ROOK - 22)
      7  1c1e		       f9		      .byte.b	>(PositionalValue_QUEEN - 22)
      8  1c1f		       f9		      .byte.b	>(PositionalValue_KING_MIDGAME - 22)
     65  1c20
     66  1c20		       00 32	   BZ	      =	50
     67  1c20
     68  1c20					      MAC	pval
     69  1c20					      .byte	BZ + {1}
     70  1c20					      .byte	BZ + {2}
     71  1c20					      .byte	BZ + {3}
     72  1c20					      .byte	BZ + {4}
     73  1c20					      .byte	BZ + {5}
     74  1c20					      .byte	BZ + {6}
     75  1c20					      .byte	BZ + {7}
     76  1c20					      .byte	BZ + {8}
     77  1c20					      .byte	BZ
     78  1c20					      .byte	BZ
     79  1c20					      ENDM		;{ 10 entries }
     80  1c20
     81  1c20							;---------------------------------------------------------------------------------------------------
     82  1c20
     83  1c20				   PositionalValue_PAWN
     84  1c20
      0  1c20					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  1c20		       32		      .byte.b	BZ + 0
      2  1c21		       32		      .byte.b	BZ + 0
      3  1c22		       32		      .byte.b	BZ + 0
      4  1c23		       32		      .byte.b	BZ + 0
      5  1c24		       32		      .byte.b	BZ + 0
      6  1c25		       32		      .byte.b	BZ + 0
      7  1c26		       32		      .byte.b	BZ + 0
      8  1c27		       32		      .byte.b	BZ + 0
      9  1c28		       32		      .byte.b	BZ
     10  1c29		       32		      .byte.b	BZ
      0  1c2a					      PVAL	15, 10, 0, -20, -20, 0, 10, 15
      1  1c2a		       41		      .byte.b	BZ + 15
      2  1c2b		       3c		      .byte.b	BZ + 10
      3  1c2c		       32		      .byte.b	BZ + 0
      4  1c2d		       1e		      .byte.b	BZ + -20
      5  1c2e		       1e		      .byte.b	BZ + -20
      6  1c2f		       32		      .byte.b	BZ + 0
      7  1c30		       3c		      .byte.b	BZ + 10
      8  1c31		       41		      .byte.b	BZ + 15
      9  1c32		       32		      .byte.b	BZ
     10  1c33		       32		      .byte.b	BZ
      0  1c34					      PVAL	5, -5, -10, 0, 0, -10, -5, 5
      1  1c34		       37		      .byte.b	BZ + 5
      2  1c35		       2d		      .byte.b	BZ + -5
      3  1c36		       28		      .byte.b	BZ + -10
      4  1c37		       32		      .byte.b	BZ + 0
      5  1c38		       32		      .byte.b	BZ + 0
      6  1c39		       28		      .byte.b	BZ + -10
      7  1c3a		       2d		      .byte.b	BZ + -5
      8  1c3b		       37		      .byte.b	BZ + 5
      9  1c3c		       32		      .byte.b	BZ
     10  1c3d		       32		      .byte.b	BZ
      0  1c3e					      PVAL	0, 0, 0, 10, 40, 0, 0, 0
      1  1c3e		       32		      .byte.b	BZ + 0
      2  1c3f		       32		      .byte.b	BZ + 0
      3  1c40		       32		      .byte.b	BZ + 0
      4  1c41		       3c		      .byte.b	BZ + 10
      5  1c42		       5a		      .byte.b	BZ + 40
      6  1c43		       32		      .byte.b	BZ + 0
      7  1c44		       32		      .byte.b	BZ + 0
      8  1c45		       32		      .byte.b	BZ + 0
      9  1c46		       32		      .byte.b	BZ
     10  1c47		       32		      .byte.b	BZ
      0  1c48					      PVAL	15, 15, 20, 20, 50, 20, 15, 15
      1  1c48		       41		      .byte.b	BZ + 15
      2  1c49		       41		      .byte.b	BZ + 15
      3  1c4a		       46		      .byte.b	BZ + 20
      4  1c4b		       46		      .byte.b	BZ + 20
      5  1c4c		       64		      .byte.b	BZ + 50
      6  1c4d		       46		      .byte.b	BZ + 20
      7  1c4e		       41		      .byte.b	BZ + 15
      8  1c4f		       41		      .byte.b	BZ + 15
      9  1c50		       32		      .byte.b	BZ
     10  1c51		       32		      .byte.b	BZ
      0  1c52					      PVAL	30, 30, 40, 50, 50, 40, 30, 30
      1  1c52		       50		      .byte.b	BZ + 30
      2  1c53		       50		      .byte.b	BZ + 30
      3  1c54		       5a		      .byte.b	BZ + 40
      4  1c55		       64		      .byte.b	BZ + 50
      5  1c56		       64		      .byte.b	BZ + 50
      6  1c57		       5a		      .byte.b	BZ + 40
      7  1c58		       50		      .byte.b	BZ + 30
      8  1c59		       50		      .byte.b	BZ + 30
      9  1c5a		       32		      .byte.b	BZ
     10  1c5b		       32		      .byte.b	BZ
      0  1c5c					      PVAL	40, 50, 60, 70, 70, 60, 50, 40
      1  1c5c		       5a		      .byte.b	BZ + 40
      2  1c5d		       64		      .byte.b	BZ + 50
      3  1c5e		       6e		      .byte.b	BZ + 60
      4  1c5f		       78		      .byte.b	BZ + 70
      5  1c60		       78		      .byte.b	BZ + 70
      6  1c61		       6e		      .byte.b	BZ + 60
      7  1c62		       64		      .byte.b	BZ + 50
      8  1c63		       5a		      .byte.b	BZ + 40
      9  1c64		       32		      .byte.b	BZ
     10  1c65		       32		      .byte.b	BZ
      0  1c66					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  1c66		       32		      .byte.b	BZ + 0
      2  1c67		       32		      .byte.b	BZ + 0
      3  1c68		       32		      .byte.b	BZ + 0
      4  1c69		       32		      .byte.b	BZ + 0
      5  1c6a		       32		      .byte.b	BZ + 0
      6  1c6b		       32		      .byte.b	BZ + 0
      7  1c6c		       32		      .byte.b	BZ + 0
      8  1c6d		       32		      .byte.b	BZ + 0
      9  1c6e		       32		      .byte.b	BZ
     10  1c6f		       32		      .byte.b	BZ
     93  1c70
     94  1c70							;---------------------------------------------------------------------------------------------------
     95  1c70
     96  1c70				   PositionalValue_KNIGHT
     97  1c70
      0  1c70					      PVAL	-50, -40, -30, -30, -30, -30, -40, -50
      1  1c70		       00		      .byte.b	BZ + -50
      2  1c71		       0a		      .byte.b	BZ + -40
      3  1c72		       14		      .byte.b	BZ + -30
      4  1c73		       14		      .byte.b	BZ + -30
      5  1c74		       14		      .byte.b	BZ + -30
      6  1c75		       14		      .byte.b	BZ + -30
      7  1c76		       0a		      .byte.b	BZ + -40
      8  1c77		       00		      .byte.b	BZ + -50
      9  1c78		       32		      .byte.b	BZ
     10  1c79		       32		      .byte.b	BZ
      0  1c7a					      PVAL	-40, -20, 0, 5, 5, 0, -20, -40
      1  1c7a		       0a		      .byte.b	BZ + -40
      2  1c7b		       1e		      .byte.b	BZ + -20
      3  1c7c		       32		      .byte.b	BZ + 0
      4  1c7d		       37		      .byte.b	BZ + 5
      5  1c7e		       37		      .byte.b	BZ + 5
      6  1c7f		       32		      .byte.b	BZ + 0
      7  1c80		       1e		      .byte.b	BZ + -20
      8  1c81		       0a		      .byte.b	BZ + -40
      9  1c82		       32		      .byte.b	BZ
     10  1c83		       32		      .byte.b	BZ
      0  1c84					      PVAL	-30, 0, 20, 15, 15, 20, 0, -30
      1  1c84		       14		      .byte.b	BZ + -30
      2  1c85		       32		      .byte.b	BZ + 0
      3  1c86		       46		      .byte.b	BZ + 20
      4  1c87		       41		      .byte.b	BZ + 15
      5  1c88		       41		      .byte.b	BZ + 15
      6  1c89		       46		      .byte.b	BZ + 20
      7  1c8a		       32		      .byte.b	BZ + 0
      8  1c8b		       14		      .byte.b	BZ + -30
      9  1c8c		       32		      .byte.b	BZ
     10  1c8d		       32		      .byte.b	BZ
      0  1c8e					      PVAL	-30, 0, 15, 30, 30, 15, 0, -30
      1  1c8e		       14		      .byte.b	BZ + -30
      2  1c8f		       32		      .byte.b	BZ + 0
      3  1c90		       41		      .byte.b	BZ + 15
      4  1c91		       50		      .byte.b	BZ + 30
      5  1c92		       50		      .byte.b	BZ + 30
      6  1c93		       41		      .byte.b	BZ + 15
      7  1c94		       32		      .byte.b	BZ + 0
      8  1c95		       14		      .byte.b	BZ + -30
      9  1c96		       32		      .byte.b	BZ
     10  1c97		       32		      .byte.b	BZ
      0  1c98					      PVAL	-30, 5, 15, 30, 30, 15, 5, -30
      1  1c98		       14		      .byte.b	BZ + -30
      2  1c99		       37		      .byte.b	BZ + 5
      3  1c9a		       41		      .byte.b	BZ + 15
      4  1c9b		       50		      .byte.b	BZ + 30
      5  1c9c		       50		      .byte.b	BZ + 30
      6  1c9d		       41		      .byte.b	BZ + 15
      7  1c9e		       37		      .byte.b	BZ + 5
      8  1c9f		       14		      .byte.b	BZ + -30
      9  1ca0		       32		      .byte.b	BZ
     10  1ca1		       32		      .byte.b	BZ
      0  1ca2					      PVAL	-30, 0, 10, 15, 15, 10, 0, -30
      1  1ca2		       14		      .byte.b	BZ + -30
      2  1ca3		       32		      .byte.b	BZ + 0
      3  1ca4		       3c		      .byte.b	BZ + 10
      4  1ca5		       41		      .byte.b	BZ + 15
      5  1ca6		       41		      .byte.b	BZ + 15
      6  1ca7		       3c		      .byte.b	BZ + 10
      7  1ca8		       32		      .byte.b	BZ + 0
      8  1ca9		       14		      .byte.b	BZ + -30
      9  1caa		       32		      .byte.b	BZ
     10  1cab		       32		      .byte.b	BZ
      0  1cac					      PVAL	-40, -20, 30, 0, 0, 30, -20, -40
      1  1cac		       0a		      .byte.b	BZ + -40
      2  1cad		       1e		      .byte.b	BZ + -20
      3  1cae		       50		      .byte.b	BZ + 30
      4  1caf		       32		      .byte.b	BZ + 0
      5  1cb0		       32		      .byte.b	BZ + 0
      6  1cb1		       50		      .byte.b	BZ + 30
      7  1cb2		       1e		      .byte.b	BZ + -20
      8  1cb3		       0a		      .byte.b	BZ + -40
      9  1cb4		       32		      .byte.b	BZ
     10  1cb5		       32		      .byte.b	BZ
      0  1cb6					      PVAL	-50, -20, -30, -30, -30, -30, -20, -50
      1  1cb6		       00		      .byte.b	BZ + -50
      2  1cb7		       1e		      .byte.b	BZ + -20
      3  1cb8		       14		      .byte.b	BZ + -30
      4  1cb9		       14		      .byte.b	BZ + -30
      5  1cba		       14		      .byte.b	BZ + -30
      6  1cbb		       14		      .byte.b	BZ + -30
      7  1cbc		       1e		      .byte.b	BZ + -20
      8  1cbd		       00		      .byte.b	BZ + -50
      9  1cbe		       32		      .byte.b	BZ
     10  1cbf		       32		      .byte.b	BZ
    106  1cc0
    107  1cc0
    108  1cc0							;---------------------------------------------------------------------------------------------------
    109  1cc0
    110  1cc0				   PositionalValue_BISHOP
    111  1cc0
      0  1cc0					      PVAL	-20, -10, -50, -10, -10, -50, -10, -20
      1  1cc0		       1e		      .byte.b	BZ + -20
      2  1cc1		       28		      .byte.b	BZ + -10
      3  1cc2		       00		      .byte.b	BZ + -50
      4  1cc3		       28		      .byte.b	BZ + -10
      5  1cc4		       28		      .byte.b	BZ + -10
      6  1cc5		       00		      .byte.b	BZ + -50
      7  1cc6		       28		      .byte.b	BZ + -10
      8  1cc7		       1e		      .byte.b	BZ + -20
      9  1cc8		       32		      .byte.b	BZ
     10  1cc9		       32		      .byte.b	BZ
      0  1cca					      PVAL	-10, 5, 0, 0, 0, 0, 5, -10
      1  1cca		       28		      .byte.b	BZ + -10
      2  1ccb		       37		      .byte.b	BZ + 5
      3  1ccc		       32		      .byte.b	BZ + 0
      4  1ccd		       32		      .byte.b	BZ + 0
      5  1cce		       32		      .byte.b	BZ + 0
      6  1ccf		       32		      .byte.b	BZ + 0
      7  1cd0		       37		      .byte.b	BZ + 5
      8  1cd1		       28		      .byte.b	BZ + -10
      9  1cd2		       32		      .byte.b	BZ
     10  1cd3		       32		      .byte.b	BZ
      0  1cd4					      PVAL	-10, 10, 10, 10, 10, 10, 10, -10
      1  1cd4		       28		      .byte.b	BZ + -10
      2  1cd5		       3c		      .byte.b	BZ + 10
      3  1cd6		       3c		      .byte.b	BZ + 10
      4  1cd7		       3c		      .byte.b	BZ + 10
      5  1cd8		       3c		      .byte.b	BZ + 10
      6  1cd9		       3c		      .byte.b	BZ + 10
      7  1cda		       3c		      .byte.b	BZ + 10
      8  1cdb		       28		      .byte.b	BZ + -10
      9  1cdc		       32		      .byte.b	BZ
     10  1cdd		       32		      .byte.b	BZ
      0  1cde					      PVAL	-10, 0, 10, 20, 20, 10, 0, -10
      1  1cde		       28		      .byte.b	BZ + -10
      2  1cdf		       32		      .byte.b	BZ + 0
      3  1ce0		       3c		      .byte.b	BZ + 10
      4  1ce1		       46		      .byte.b	BZ + 20
      5  1ce2		       46		      .byte.b	BZ + 20
      6  1ce3		       3c		      .byte.b	BZ + 10
      7  1ce4		       32		      .byte.b	BZ + 0
      8  1ce5		       28		      .byte.b	BZ + -10
      9  1ce6		       32		      .byte.b	BZ
     10  1ce7		       32		      .byte.b	BZ
      0  1ce8					      PVAL	-10, 5, 5, 20, 20, 5, 5, -10
      1  1ce8		       28		      .byte.b	BZ + -10
      2  1ce9		       37		      .byte.b	BZ + 5
      3  1cea		       37		      .byte.b	BZ + 5
      4  1ceb		       46		      .byte.b	BZ + 20
      5  1cec		       46		      .byte.b	BZ + 20
      6  1ced		       37		      .byte.b	BZ + 5
      7  1cee		       37		      .byte.b	BZ + 5
      8  1cef		       28		      .byte.b	BZ + -10
      9  1cf0		       32		      .byte.b	BZ
     10  1cf1		       32		      .byte.b	BZ
      0  1cf2					      PVAL	-10, 0, 5, 10, 10, 5, 0, -10
      1  1cf2		       28		      .byte.b	BZ + -10
      2  1cf3		       32		      .byte.b	BZ + 0
      3  1cf4		       37		      .byte.b	BZ + 5
      4  1cf5		       3c		      .byte.b	BZ + 10
      5  1cf6		       3c		      .byte.b	BZ + 10
      6  1cf7		       37		      .byte.b	BZ + 5
      7  1cf8		       32		      .byte.b	BZ + 0
      8  1cf9		       28		      .byte.b	BZ + -10
      9  1cfa		       32		      .byte.b	BZ
     10  1cfb		       32		      .byte.b	BZ
      0  1cfc					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      1  1cfc		       28		      .byte.b	BZ + -10
      2  1cfd		       32		      .byte.b	BZ + 0
      3  1cfe		       32		      .byte.b	BZ + 0
      4  1cff		       32		      .byte.b	BZ + 0
      5  1d00		       32		      .byte.b	BZ + 0
      6  1d01		       32		      .byte.b	BZ + 0
      7  1d02		       32		      .byte.b	BZ + 0
      8  1d03		       28		      .byte.b	BZ + -10
      9  1d04		       32		      .byte.b	BZ
     10  1d05		       32		      .byte.b	BZ
      0  1d06					      PVAL	-20, -10, -10, -10, -10, -10, -10, -20
      1  1d06		       1e		      .byte.b	BZ + -20
      2  1d07		       28		      .byte.b	BZ + -10
      3  1d08		       28		      .byte.b	BZ + -10
      4  1d09		       28		      .byte.b	BZ + -10
      5  1d0a		       28		      .byte.b	BZ + -10
      6  1d0b		       28		      .byte.b	BZ + -10
      7  1d0c		       28		      .byte.b	BZ + -10
      8  1d0d		       1e		      .byte.b	BZ + -20
      9  1d0e		       32		      .byte.b	BZ
     10  1d0f		       32		      .byte.b	BZ
    120  1d10
    121  1d10
    122  1d10							;---------------------------------------------------------------------------------------------------
    123  1d10
    124  1d10				   PositionalValue_ROOK
    125  1d10
      0  1d10					      PVAL	-120, -10, 10, 25, 25, 10, -10, -200
      1  1d10		       ba		      .byte.b	BZ + -120
      2  1d11		       28		      .byte.b	BZ + -10
      3  1d12		       3c		      .byte.b	BZ + 10
      4  1d13		       4b		      .byte.b	BZ + 25
      5  1d14		       4b		      .byte.b	BZ + 25
      6  1d15		       3c		      .byte.b	BZ + 10
      7  1d16		       28		      .byte.b	BZ + -10
      8  1d17		       6a		      .byte.b	BZ + -200
      9  1d18		       32		      .byte.b	BZ
     10  1d19		       32		      .byte.b	BZ
      0  1d1a					      PVAL	-75, 0, 0, 0, 0, 0, 0, -200
      1  1d1a		       e7		      .byte.b	BZ + -75
      2  1d1b		       32		      .byte.b	BZ + 0
      3  1d1c		       32		      .byte.b	BZ + 0
      4  1d1d		       32		      .byte.b	BZ + 0
      5  1d1e		       32		      .byte.b	BZ + 0
      6  1d1f		       32		      .byte.b	BZ + 0
      7  1d20		       32		      .byte.b	BZ + 0
      8  1d21		       6a		      .byte.b	BZ + -200
      9  1d22		       32		      .byte.b	BZ
     10  1d23		       32		      .byte.b	BZ
      0  1d24					      PVAL	-75, 0, 0, 0, 0, 0, 0, -150
      1  1d24		       e7		      .byte.b	BZ + -75
      2  1d25		       32		      .byte.b	BZ + 0
      3  1d26		       32		      .byte.b	BZ + 0
      4  1d27		       32		      .byte.b	BZ + 0
      5  1d28		       32		      .byte.b	BZ + 0
      6  1d29		       32		      .byte.b	BZ + 0
      7  1d2a		       32		      .byte.b	BZ + 0
      8  1d2b		       9c		      .byte.b	BZ + -150
      9  1d2c		       32		      .byte.b	BZ
     10  1d2d		       32		      .byte.b	BZ
      0  1d2e					      PVAL	-50, 0, 0, 0, 0, 0, 0, -100
      1  1d2e		       00		      .byte.b	BZ + -50
      2  1d2f		       32		      .byte.b	BZ + 0
      3  1d30		       32		      .byte.b	BZ + 0
      4  1d31		       32		      .byte.b	BZ + 0
      5  1d32		       32		      .byte.b	BZ + 0
      6  1d33		       32		      .byte.b	BZ + 0
      7  1d34		       32		      .byte.b	BZ + 0
      8  1d35		       ce		      .byte.b	BZ + -100
      9  1d36		       32		      .byte.b	BZ
     10  1d37		       32		      .byte.b	BZ
      0  1d38					      PVAL	-5, 0, 0, 0, 0, 0, 0, -50
      1  1d38		       2d		      .byte.b	BZ + -5
      2  1d39		       32		      .byte.b	BZ + 0
      3  1d3a		       32		      .byte.b	BZ + 0
      4  1d3b		       32		      .byte.b	BZ + 0
      5  1d3c		       32		      .byte.b	BZ + 0
      6  1d3d		       32		      .byte.b	BZ + 0
      7  1d3e		       32		      .byte.b	BZ + 0
      8  1d3f		       00		      .byte.b	BZ + -50
      9  1d40		       32		      .byte.b	BZ
     10  1d41		       32		      .byte.b	BZ
      0  1d42					      PVAL	-5, 0, 30, 30, 30, 30, 0, -5
      1  1d42		       2d		      .byte.b	BZ + -5
      2  1d43		       32		      .byte.b	BZ + 0
      3  1d44		       50		      .byte.b	BZ + 30
      4  1d45		       50		      .byte.b	BZ + 30
      5  1d46		       50		      .byte.b	BZ + 30
      6  1d47		       50		      .byte.b	BZ + 30
      7  1d48		       32		      .byte.b	BZ + 0
      8  1d49		       2d		      .byte.b	BZ + -5
      9  1d4a		       32		      .byte.b	BZ
     10  1d4b		       32		      .byte.b	BZ
      0  1d4c					      PVAL	5, 10, 50, 50, 50, 50, 10, 5
      1  1d4c		       37		      .byte.b	BZ + 5
      2  1d4d		       3c		      .byte.b	BZ + 10
      3  1d4e		       64		      .byte.b	BZ + 50
      4  1d4f		       64		      .byte.b	BZ + 50
      5  1d50		       64		      .byte.b	BZ + 50
      6  1d51		       64		      .byte.b	BZ + 50
      7  1d52		       3c		      .byte.b	BZ + 10
      8  1d53		       37		      .byte.b	BZ + 5
      9  1d54		       32		      .byte.b	BZ
     10  1d55		       32		      .byte.b	BZ
      0  1d56					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  1d56		       32		      .byte.b	BZ + 0
      2  1d57		       32		      .byte.b	BZ + 0
      3  1d58		       32		      .byte.b	BZ + 0
      4  1d59		       32		      .byte.b	BZ + 0
      5  1d5a		       32		      .byte.b	BZ + 0
      6  1d5b		       32		      .byte.b	BZ + 0
      7  1d5c		       32		      .byte.b	BZ + 0
      8  1d5d		       32		      .byte.b	BZ + 0
      9  1d5e		       32		      .byte.b	BZ
     10  1d5f		       32		      .byte.b	BZ
    134  1d60
    135  1d60
    136  1d60							;---------------------------------------------------------------------------------------------------
    137  1d60
    138  1d60				   PositionalValue_QUEEN
    139  1d60
      0  1d60					      PVAL	-20, -10, -5, -5, -5, -10, -10, -20
      1  1d60		       1e		      .byte.b	BZ + -20
      2  1d61		       28		      .byte.b	BZ + -10
      3  1d62		       2d		      .byte.b	BZ + -5
      4  1d63		       2d		      .byte.b	BZ + -5
      5  1d64		       2d		      .byte.b	BZ + -5
      6  1d65		       28		      .byte.b	BZ + -10
      7  1d66		       28		      .byte.b	BZ + -10
      8  1d67		       1e		      .byte.b	BZ + -20
      9  1d68		       32		      .byte.b	BZ
     10  1d69		       32		      .byte.b	BZ
      0  1d6a					      PVAL	-10, 0, 5, 0, 0, 0, 0, -10
      1  1d6a		       28		      .byte.b	BZ + -10
      2  1d6b		       32		      .byte.b	BZ + 0
      3  1d6c		       37		      .byte.b	BZ + 5
      4  1d6d		       32		      .byte.b	BZ + 0
      5  1d6e		       32		      .byte.b	BZ + 0
      6  1d6f		       32		      .byte.b	BZ + 0
      7  1d70		       32		      .byte.b	BZ + 0
      8  1d71		       28		      .byte.b	BZ + -10
      9  1d72		       32		      .byte.b	BZ
     10  1d73		       32		      .byte.b	BZ
      0  1d74					      PVAL	-10, 5, 5, 5, 5, 25, 0, -10
      1  1d74		       28		      .byte.b	BZ + -10
      2  1d75		       37		      .byte.b	BZ + 5
      3  1d76		       37		      .byte.b	BZ + 5
      4  1d77		       37		      .byte.b	BZ + 5
      5  1d78		       37		      .byte.b	BZ + 5
      6  1d79		       4b		      .byte.b	BZ + 25
      7  1d7a		       32		      .byte.b	BZ + 0
      8  1d7b		       28		      .byte.b	BZ + -10
      9  1d7c		       32		      .byte.b	BZ
     10  1d7d		       32		      .byte.b	BZ
      0  1d7e					      PVAL	-10, 0, 5, 25, 25, 25, 0, -10
      1  1d7e		       28		      .byte.b	BZ + -10
      2  1d7f		       32		      .byte.b	BZ + 0
      3  1d80		       37		      .byte.b	BZ + 5
      4  1d81		       4b		      .byte.b	BZ + 25
      5  1d82		       4b		      .byte.b	BZ + 25
      6  1d83		       4b		      .byte.b	BZ + 25
      7  1d84		       32		      .byte.b	BZ + 0
      8  1d85		       28		      .byte.b	BZ + -10
      9  1d86		       32		      .byte.b	BZ
     10  1d87		       32		      .byte.b	BZ
      0  1d88					      PVAL	-5, 0, 15, 55, 55, 55, 0, -5
      1  1d88		       2d		      .byte.b	BZ + -5
      2  1d89		       32		      .byte.b	BZ + 0
      3  1d8a		       41		      .byte.b	BZ + 15
      4  1d8b		       69		      .byte.b	BZ + 55
      5  1d8c		       69		      .byte.b	BZ + 55
      6  1d8d		       69		      .byte.b	BZ + 55
      7  1d8e		       32		      .byte.b	BZ + 0
      8  1d8f		       2d		      .byte.b	BZ + -5
      9  1d90		       32		      .byte.b	BZ
     10  1d91		       32		      .byte.b	BZ
      0  1d92					      PVAL	-10, 0, 25, 75, 75, 75, 0, -10
      1  1d92		       28		      .byte.b	BZ + -10
      2  1d93		       32		      .byte.b	BZ + 0
      3  1d94		       4b		      .byte.b	BZ + 25
      4  1d95		       7d		      .byte.b	BZ + 75
      5  1d96		       7d		      .byte.b	BZ + 75
      6  1d97		       7d		      .byte.b	BZ + 75
      7  1d98		       32		      .byte.b	BZ + 0
      8  1d99		       28		      .byte.b	BZ + -10
      9  1d9a		       32		      .byte.b	BZ
     10  1d9b		       32		      .byte.b	BZ
      0  1d9c					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      1  1d9c		       28		      .byte.b	BZ + -10
      2  1d9d		       32		      .byte.b	BZ + 0
      3  1d9e		       32		      .byte.b	BZ + 0
      4  1d9f		       32		      .byte.b	BZ + 0
      5  1da0		       32		      .byte.b	BZ + 0
      6  1da1		       32		      .byte.b	BZ + 0
      7  1da2		       32		      .byte.b	BZ + 0
      8  1da3		       28		      .byte.b	BZ + -10
      9  1da4		       32		      .byte.b	BZ
     10  1da5		       32		      .byte.b	BZ
      0  1da6					      PVAL	-20, -10, -10, -5, -5, -10, -10, -20
      1  1da6		       1e		      .byte.b	BZ + -20
      2  1da7		       28		      .byte.b	BZ + -10
      3  1da8		       28		      .byte.b	BZ + -10
      4  1da9		       2d		      .byte.b	BZ + -5
      5  1daa		       2d		      .byte.b	BZ + -5
      6  1dab		       28		      .byte.b	BZ + -10
      7  1dac		       28		      .byte.b	BZ + -10
      8  1dad		       1e		      .byte.b	BZ + -20
      9  1dae		       32		      .byte.b	BZ
     10  1daf		       32		      .byte.b	BZ
    148  1db0
    149  1db0
    150  1db0							;---------------------------------------------------------------------------------------------------
    151  1db0
    152  1db0				   PositionalValue_KING_MIDGAME
    153  1db0
      0  1db0					      PVAL	0, 0, 30, -20, 0, 10, 40, 10
      1  1db0		       32		      .byte.b	BZ + 0
      2  1db1		       32		      .byte.b	BZ + 0
      3  1db2		       50		      .byte.b	BZ + 30
      4  1db3		       1e		      .byte.b	BZ + -20
      5  1db4		       32		      .byte.b	BZ + 0
      6  1db5		       3c		      .byte.b	BZ + 10
      7  1db6		       5a		      .byte.b	BZ + 40
      8  1db7		       3c		      .byte.b	BZ + 10
      9  1db8		       32		      .byte.b	BZ
     10  1db9		       32		      .byte.b	BZ
      0  1dba					      PVAL	20, 20, 0, -10, -10, 0, 20, 20
      1  1dba		       46		      .byte.b	BZ + 20
      2  1dbb		       46		      .byte.b	BZ + 20
      3  1dbc		       32		      .byte.b	BZ + 0
      4  1dbd		       28		      .byte.b	BZ + -10
      5  1dbe		       28		      .byte.b	BZ + -10
      6  1dbf		       32		      .byte.b	BZ + 0
      7  1dc0		       46		      .byte.b	BZ + 20
      8  1dc1		       46		      .byte.b	BZ + 20
      9  1dc2		       32		      .byte.b	BZ
     10  1dc3		       32		      .byte.b	BZ
      0  1dc4					      PVAL	-10, -20, -20, -20, -20, -20, -20, -10
      1  1dc4		       28		      .byte.b	BZ + -10
      2  1dc5		       1e		      .byte.b	BZ + -20
      3  1dc6		       1e		      .byte.b	BZ + -20
      4  1dc7		       1e		      .byte.b	BZ + -20
      5  1dc8		       1e		      .byte.b	BZ + -20
      6  1dc9		       1e		      .byte.b	BZ + -20
      7  1dca		       1e		      .byte.b	BZ + -20
      8  1dcb		       28		      .byte.b	BZ + -10
      9  1dcc		       32		      .byte.b	BZ
     10  1dcd		       32		      .byte.b	BZ
      0  1dce					      PVAL	-20, -30, -30, -40, -40, -30, -30, -20
      1  1dce		       1e		      .byte.b	BZ + -20
      2  1dcf		       14		      .byte.b	BZ + -30
      3  1dd0		       14		      .byte.b	BZ + -30
      4  1dd1		       0a		      .byte.b	BZ + -40
      5  1dd2		       0a		      .byte.b	BZ + -40
      6  1dd3		       14		      .byte.b	BZ + -30
      7  1dd4		       14		      .byte.b	BZ + -30
      8  1dd5		       1e		      .byte.b	BZ + -20
      9  1dd6		       32		      .byte.b	BZ
     10  1dd7		       32		      .byte.b	BZ
      0  1dd8					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  1dd8		       14		      .byte.b	BZ + -30
      2  1dd9		       0a		      .byte.b	BZ + -40
      3  1dda		       0a		      .byte.b	BZ + -40
      4  1ddb		       00		      .byte.b	BZ + -50
      5  1ddc		       00		      .byte.b	BZ + -50
      6  1ddd		       0a		      .byte.b	BZ + -40
      7  1dde		       0a		      .byte.b	BZ + -40
      8  1ddf		       14		      .byte.b	BZ + -30
      9  1de0		       32		      .byte.b	BZ
     10  1de1		       32		      .byte.b	BZ
      0  1de2					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  1de2		       14		      .byte.b	BZ + -30
      2  1de3		       0a		      .byte.b	BZ + -40
      3  1de4		       0a		      .byte.b	BZ + -40
      4  1de5		       00		      .byte.b	BZ + -50
      5  1de6		       00		      .byte.b	BZ + -50
      6  1de7		       0a		      .byte.b	BZ + -40
      7  1de8		       0a		      .byte.b	BZ + -40
      8  1de9		       14		      .byte.b	BZ + -30
      9  1dea		       32		      .byte.b	BZ
     10  1deb		       32		      .byte.b	BZ
      0  1dec					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  1dec		       14		      .byte.b	BZ + -30
      2  1ded		       0a		      .byte.b	BZ + -40
      3  1dee		       0a		      .byte.b	BZ + -40
      4  1def		       00		      .byte.b	BZ + -50
      5  1df0		       00		      .byte.b	BZ + -50
      6  1df1		       0a		      .byte.b	BZ + -40
      7  1df2		       0a		      .byte.b	BZ + -40
      8  1df3		       14		      .byte.b	BZ + -30
      9  1df4		       32		      .byte.b	BZ
     10  1df5		       32		      .byte.b	BZ
      0  1df6					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  1df6		       14		      .byte.b	BZ + -30
      2  1df7		       0a		      .byte.b	BZ + -40
      3  1df8		       0a		      .byte.b	BZ + -40
      4  1df9		       00		      .byte.b	BZ + -50
      5  1dfa		       00		      .byte.b	BZ + -50
      6  1dfb		       0a		      .byte.b	BZ + -40
      7  1dfc		       0a		      .byte.b	BZ + -40
      8  1dfd		       14		      .byte.b	BZ + -30
      9  1dfe		       32		      .byte.b	BZ
     10  1dff		       32		      .byte.b	BZ
    162  1e00
    163  1e00
    164  1e00							;---------------------------------------------------------------------------------------------------
    165  1e00
    166  1e00				   PositionalValue_KING_ENDGAME
    167  1e00
      0  1e00					      PVAL	-50, -30, -30, -30, -30, -30, -30, -50
      1  1e00		       00		      .byte.b	BZ + -50
      2  1e01		       14		      .byte.b	BZ + -30
      3  1e02		       14		      .byte.b	BZ + -30
      4  1e03		       14		      .byte.b	BZ + -30
      5  1e04		       14		      .byte.b	BZ + -30
      6  1e05		       14		      .byte.b	BZ + -30
      7  1e06		       14		      .byte.b	BZ + -30
      8  1e07		       00		      .byte.b	BZ + -50
      9  1e08		       32		      .byte.b	BZ
     10  1e09		       32		      .byte.b	BZ
      0  1e0a					      PVAL	-30, -30, 0, 0, 0, 0, -30, -30
      1  1e0a		       14		      .byte.b	BZ + -30
      2  1e0b		       14		      .byte.b	BZ + -30
      3  1e0c		       32		      .byte.b	BZ + 0
      4  1e0d		       32		      .byte.b	BZ + 0
      5  1e0e		       32		      .byte.b	BZ + 0
      6  1e0f		       32		      .byte.b	BZ + 0
      7  1e10		       14		      .byte.b	BZ + -30
      8  1e11		       14		      .byte.b	BZ + -30
      9  1e12		       32		      .byte.b	BZ
     10  1e13		       32		      .byte.b	BZ
      0  1e14					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      1  1e14		       14		      .byte.b	BZ + -30
      2  1e15		       28		      .byte.b	BZ + -10
      3  1e16		       46		      .byte.b	BZ + 20
      4  1e17		       50		      .byte.b	BZ + 30
      5  1e18		       50		      .byte.b	BZ + 30
      6  1e19		       46		      .byte.b	BZ + 20
      7  1e1a		       28		      .byte.b	BZ + -10
      8  1e1b		       14		      .byte.b	BZ + -30
      9  1e1c		       32		      .byte.b	BZ
     10  1e1d		       32		      .byte.b	BZ
      0  1e1e					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      1  1e1e		       14		      .byte.b	BZ + -30
      2  1e1f		       28		      .byte.b	BZ + -10
      3  1e20		       50		      .byte.b	BZ + 30
      4  1e21		       5a		      .byte.b	BZ + 40
      5  1e22		       5a		      .byte.b	BZ + 40
      6  1e23		       50		      .byte.b	BZ + 30
      7  1e24		       28		      .byte.b	BZ + -10
      8  1e25		       14		      .byte.b	BZ + -30
      9  1e26		       32		      .byte.b	BZ
     10  1e27		       32		      .byte.b	BZ
      0  1e28					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      1  1e28		       14		      .byte.b	BZ + -30
      2  1e29		       28		      .byte.b	BZ + -10
      3  1e2a		       50		      .byte.b	BZ + 30
      4  1e2b		       5a		      .byte.b	BZ + 40
      5  1e2c		       5a		      .byte.b	BZ + 40
      6  1e2d		       50		      .byte.b	BZ + 30
      7  1e2e		       28		      .byte.b	BZ + -10
      8  1e2f		       14		      .byte.b	BZ + -30
      9  1e30		       32		      .byte.b	BZ
     10  1e31		       32		      .byte.b	BZ
      0  1e32					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      1  1e32		       14		      .byte.b	BZ + -30
      2  1e33		       28		      .byte.b	BZ + -10
      3  1e34		       46		      .byte.b	BZ + 20
      4  1e35		       50		      .byte.b	BZ + 30
      5  1e36		       50		      .byte.b	BZ + 30
      6  1e37		       46		      .byte.b	BZ + 20
      7  1e38		       28		      .byte.b	BZ + -10
      8  1e39		       14		      .byte.b	BZ + -30
      9  1e3a		       32		      .byte.b	BZ
     10  1e3b		       32		      .byte.b	BZ
      0  1e3c					      PVAL	-30, -20, -10, 0, 0, -10, -20, -30
      1  1e3c		       14		      .byte.b	BZ + -30
      2  1e3d		       1e		      .byte.b	BZ + -20
      3  1e3e		       28		      .byte.b	BZ + -10
      4  1e3f		       32		      .byte.b	BZ + 0
      5  1e40		       32		      .byte.b	BZ + 0
      6  1e41		       28		      .byte.b	BZ + -10
      7  1e42		       1e		      .byte.b	BZ + -20
      8  1e43		       14		      .byte.b	BZ + -30
      9  1e44		       32		      .byte.b	BZ
     10  1e45		       32		      .byte.b	BZ
      0  1e46					      PVAL	-50, -40, -30, -20,- 20, -30, -40, -50
      1  1e46		       00		      .byte.b	BZ + -50
      2  1e47		       0a		      .byte.b	BZ + -40
      3  1e48		       14		      .byte.b	BZ + -30
      4  1e49		       1e		      .byte.b	BZ + -20
      5  1e4a		       1e		      .byte.b	BZ + - 20
      6  1e4b		       14		      .byte.b	BZ + -30
      7  1e4c		       0a		      .byte.b	BZ + -40
      8  1e4d		       00		      .byte.b	BZ + -50
      9  1e4e		       32		      .byte.b	BZ
     10  1e4f		       32		      .byte.b	BZ
    176  1e50
    177  1e50
      0  1e50					      CHECK_BANK_SIZE	"BANK_EVAL"
      1  1e50		       02 50	   .TEMP      =	* - _BANK_START
 BANK_EVAL (1K) SIZE =  $250 , FREE= $1b0
      2  1e50					      ECHO	"BANK_EVAL", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1e50				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1e50				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_EVAL", " size=", * - ORIGIN
      5  1e50				  -	      ERR
      6  1e50					      ENDIF
    179  1e50
    180  1e50							;---------------------------------------------------------------------------------------------------
    181  1e50							; EOF
------- FILE ./chess.asm
------- FILE BANK_StateMachine@1#1.asm LEVEL 2 PASS 4
      0  1e50					      include	"BANK_StateMachine@1#1.asm"
      0  1e50					      SLOT	1
      1  1e50				  -	      IF	(1 < 0) || (1 > 3)
      2  1e50				  -	      ECHO	"Illegal bank address/segment location", 1
      3  1e50				  -	      ERR
      4  1e50					      ENDIF
      5  1e50				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  1e50				   _BANK_SLOT SET	1 * 64
      0  1e50					      NEWBANK	STATEMACHINE
      1  235d ????				      SEG	STATEMACHINE
      2  2000					      ORG	_ORIGIN
      3  2000					      RORG	_BANK_ADDRESS_ORIGIN
      4  2000				   _BANK_START SET	*
      5  2000				   STATEMACHINE_START SET	*
      6  2000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2000				   STATEMACHINE SET	_BANK_SLOT + _CURRENT_BANK
      8  2000				   _ORIGIN    SET	_ORIGIN + 1024
      3  2000
      4  2000
      5  2000							; Banks holding data (ply 0 doubles as WHITE, and ply 1 as BLACK)
      6  2000
      7  2000
      8  2000		       00 10	   CURSOR_MOVE_SPEED =	16
      9  2000		       00 14	   CAP_SPEED  =	20
     10  2000		       00 28	   HOLD_DELAY =	40
     11  2000
     12  2000
     13  2000							;---------------------------------------------------------------------------------------------------
     14  2000
     15  2000
     16  2000							;---------------------------------------------------------------------------------------------------
     17  2000
      0  2000					      DEF	aiStartMoveGen
      1  2000				   SLOT_aiStartMoveGen SET	_BANK_SLOT
      2  2000				   BANK_aiStartMoveGen SET	SLOT_aiStartMoveGen + _CURRENT_BANK
      3  2000				   aiStartMoveGen
      4  2000				   TEMPORARY_VAR SET	Overlay
      5  2000				   TEMPORARY_OFFSET SET	0
      6  2000				   VAR_BOUNDARY_aiStartMoveGen SET	TEMPORARY_OFFSET
      7  2000				   FUNCTION_NAME SET	aiStartMoveGen
     19  2000					      SUBROUTINE
     20  2000
      0  2000					      REFER	AiStateMachine
      1  2000				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2000				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2000					      ENDIF
      0  2000					      VEND	aiStartMoveGen
      1  2000				  -	      IFNCONST	aiStartMoveGen
      2  2000				  -	      ECHO	"Incorrect VEND label", aiStartMoveGen
      3  2000				  -	      ERR
      4  2000					      ENDIF
      5  2000		       00 a2	   VAREND_aiStartMoveGen =	TEMPORARY_VAR
     23  2000
     24  2000							; To assist with castling, generate the moves for the opponent, giving us effectively
     25  2000							; a list of squares that are being attacked. The castling can't happen if the king is
     26  2000							; in check or if the squares it would have to move over are in check
     27  2000
     28  2000							; we don't need to worry about this if K has moved, or relevant R has moved or if
     29  2000							; the squares between are occupied. We can tell THAT by examining the movelist to see
     30  2000							; if there are K-moves marked "FLAG_CASTLE" - and the relevant squares
     31  2000
     32  2000							;inc currentPly
     33  2000							;jsr InitialiseMoveGeneration
     34  2000
      0  2000					      PHASE	AI_StepMoveGen
      1  2000		       a9 0c		      lda	#AI_StepMoveGen
      2  2002		       85 8c		      sta	aiState
     36  2004		       60		      rts
     37  2005
     38  2005
     39  2005							;---------------------------------------------------------------------------------------------------
     40  2005
      0  2005					      DEF	aiInCheckBackup
      1  2005				   SLOT_aiInCheckBackup SET	_BANK_SLOT
      2  2005				   BANK_aiInCheckBackup SET	SLOT_aiInCheckBackup + _CURRENT_BANK
      3  2005				   aiInCheckBackup
      4  2005				   TEMPORARY_VAR SET	Overlay
      5  2005				   TEMPORARY_OFFSET SET	0
      6  2005				   VAR_BOUNDARY_aiInCheckBackup SET	TEMPORARY_OFFSET
      7  2005				   FUNCTION_NAME SET	aiInCheckBackup
     42  2005					      SUBROUTINE
     43  2005
      0  2005					      REFER	AiStateMachine
      1  2005				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2005				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2005					      ENDIF
      0  2005					      VEND	aiInCheckBackup
      1  2005				  -	      IFNCONST	aiInCheckBackup
      2  2005				  -	      ECHO	"Incorrect VEND label", aiInCheckBackup
      3  2005				  -	      ERR
      4  2005					      ENDIF
      5  2005		       00 a2	   VAREND_aiInCheckBackup =	TEMPORARY_VAR
     46  2005
     47  2005							; We're about to draw some large text on the screen
     48  2005							; Make a backup copy of all of the row bitmaps, so that we can restore once text is done
     49  2005
     50  2005		       c6 84		      dec	drawCount
     51  2007		       30 02		      bmi	.exit	; done all rows
     52  2009		       a4 84		      ldy	drawCount
     53  200b				  -	      IF	0
     54  200b				  -	      jmp	SAFE_BackupBitmaps
     55  200b					      ENDIF
     56  200b
      0  200b				   .exit      PHASE	AI_InCheckDelay
      1  200b		       a9 1e		      lda	#AI_InCheckDelay
      2  200d		       85 8c		      sta	aiState
     58  200f		       60		      rts
     59  2010
     60  2010
     61  2010							;---------------------------------------------------------------------------------------------------
     62  2010
      0  2010					      DEF	aiInCheckDelay
      1  2010				   SLOT_aiInCheckDelay SET	_BANK_SLOT
      2  2010				   BANK_aiInCheckDelay SET	SLOT_aiInCheckDelay + _CURRENT_BANK
      3  2010				   aiInCheckDelay
      4  2010				   TEMPORARY_VAR SET	Overlay
      5  2010				   TEMPORARY_OFFSET SET	0
      6  2010				   VAR_BOUNDARY_aiInCheckDelay SET	TEMPORARY_OFFSET
      7  2010				   FUNCTION_NAME SET	aiInCheckDelay
     64  2010					      SUBROUTINE
     65  2010
      0  2010					      REFER	AiStateMachine
      1  2010				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2010				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2010					      ENDIF
      0  2010					      VEND	aiInCheckDelay
      1  2010				  -	      IFNCONST	aiInCheckDelay
      2  2010				  -	      ECHO	"Incorrect VEND label", aiInCheckDelay
      3  2010				  -	      ERR
      4  2010					      ENDIF
      5  2010		       00 a2	   VAREND_aiInCheckDelay =	TEMPORARY_VAR
     68  2010
     69  2010		       c6 89		      dec	mdelay
     70  2012		       d0 08		      bne	.exit
     71  2014
     72  2014		       a9 00		      lda	#0
     73  2016		       85 49		      sta	COLUBK
     74  2018
      0  2018					      PHASE	AI_BeginSelectMovePhase
      1  2018		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  201a		       85 8c		      sta	aiState
     76  201c		       60	   .exit      rts
     77  201d
     78  201d
     79  201d							;---------------------------------------------------------------------------------------------------
     80  201d
      0  201d					      DEF	aiBeginSelectMovePhase
      1  201d				   SLOT_aiBeginSelectMovePhase SET	_BANK_SLOT
      2  201d				   BANK_aiBeginSelectMovePhase SET	SLOT_aiBeginSelectMovePhase + _CURRENT_BANK
      3  201d				   aiBeginSelectMovePhase
      4  201d				   TEMPORARY_VAR SET	Overlay
      5  201d				   TEMPORARY_OFFSET SET	0
      6  201d				   VAR_BOUNDARY_aiBeginSelectMovePhase SET	TEMPORARY_OFFSET
      7  201d				   FUNCTION_NAME SET	aiBeginSelectMovePhase
     82  201d					      SUBROUTINE
     83  201d
      0  201d					      REFER	AiStateMachine
      1  201d				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  201d				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  201d					      ENDIF
      0  201d					      VEND	aiBeginSelectMovePhase
      1  201d				  -	      IFNCONST	aiBeginSelectMovePhase
      2  201d				  -	      ECHO	"Incorrect VEND label", aiBeginSelectMovePhase
      3  201d				  -	      ERR
      4  201d					      ENDIF
      5  201d		       00 a2	   VAREND_aiBeginSelectMovePhase =	TEMPORARY_VAR
     86  201d
     87  201d		       a9 02		      lda	#$2
     88  201f		       85 46		      sta	COLUP0
     89  2021		       a2 04		      ldx	#%100
     90  2023		       86 4a		      stx	CTRLPF	; under
     91  2025
     92  2025		       a9 00		      lda	#0
     93  2027		       85 89		      sta	mdelay	;?
     94  2029		       85 8f		      sta	aiFlashPhase	; odd/even for flashing pieces
     95  202b
     96  202b		       a9 28		      lda	#CAP_SPEED*2
     97  202d		       85 8d		      sta	aiFlashDelay
     98  202f
     99  202f		       a9 ff		      lda	#-1
    100  2031		       85 85		      sta	fromX12
    101  2033		       85 86		      sta	toX12
    102  2035
    103  2035							;lsr randomness
    104  2035
      0  2035					      PHASE	AI_FlashComputerMove
      1  2035		       a9 00		      lda	#AI_FlashComputerMove
      2  2037		       85 8c		      sta	aiState
    106  2039		       60		      rts
    107  203a
    108  203a
    109  203a							;---------------------------------------------------------------------------------------------------
    110  203a
      0  203a					      DEF	aiFlashComputerMove
      1  203a				   SLOT_aiFlashComputerMove SET	_BANK_SLOT
      2  203a				   BANK_aiFlashComputerMove SET	SLOT_aiFlashComputerMove + _CURRENT_BANK
      3  203a				   aiFlashComputerMove
      4  203a				   TEMPORARY_VAR SET	Overlay
      5  203a				   TEMPORARY_OFFSET SET	0
      6  203a				   VAR_BOUNDARY_aiFlashComputerMove SET	TEMPORARY_OFFSET
      7  203a				   FUNCTION_NAME SET	aiFlashComputerMove
    112  203a					      SUBROUTINE
    113  203a
    114  203a
    115  203a		       a5 80		      lda	squareToDraw
    116  203c		       30 1f		      bmi	.initial	; startup - no computer move to show
    117  203e
    118  203e							; "squareToDraw" is the piece that should flash while human waits
    119  203e
    120  203e		       ad 80 02 	      lda	SWCHA
    121  2041		       29 f0		      and	#$F0
    122  2043		       c9 f0		      cmp	#$F0
    123  2045		       f0 08		      beq	.nodir
    124  2047
    125  2047		       a9 01		      lda	#1
    126  2049		       85 8d		      sta	aiFlashDelay
    127  204b		       25 8f		      and	aiFlashPhase
    128  204d		       f0 0e		      beq	.initial
    129  204f
    130  204f		       c6 8d	   .nodir     dec	aiFlashDelay
    131  2051		       d0 0e		      bne	.exit	; don't flash
    132  2053		       a9 28		      lda	#CAP_SPEED*2
    133  2055		       85 8d		      sta	aiFlashDelay
    134  2057
    135  2057		       e6 8f		      inc	aiFlashPhase
    136  2059
    137  2059		       20 83 f0 	      jsr	CopySinglePiece	;@0
    138  205c		       60		      rts
    139  205d
      0  205d				   .initial   PHASE	AI_SelectStartSquare
      1  205d		       a9 02		      lda	#AI_SelectStartSquare
      2  205f		       85 8c		      sta	aiState
    141  2061
    142  2061		       60	   .exit      rts
    143  2062
    144  2062
    145  2062							;---------------------------------------------------------------------------------------------------
    146  2062
      0  2062					      DEF	aiSelectStartSquare
      1  2062				   SLOT_aiSelectStartSquare SET	_BANK_SLOT
      2  2062				   BANK_aiSelectStartSquare SET	SLOT_aiSelectStartSquare + _CURRENT_BANK
      3  2062				   aiSelectStartSquare
      4  2062				   TEMPORARY_VAR SET	Overlay
      5  2062				   TEMPORARY_OFFSET SET	0
      6  2062				   VAR_BOUNDARY_aiSelectStartSquare SET	TEMPORARY_OFFSET
      7  2062				   FUNCTION_NAME SET	aiSelectStartSquare
    148  2062					      SUBROUTINE
    149  2062
      0  2062					      REFER	AiStateMachine
      1  2062				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2062				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2062					      ENDIF
      0  2062					      VEND	aiSelectStartSquare
      1  2062				  -	      IFNCONST	aiSelectStartSquare
      2  2062				  -	      ECHO	"Incorrect VEND label", aiSelectStartSquare
      3  2062				  -	      ERR
      4  2062					      ENDIF
      5  2062		       00 a2	   VAREND_aiSelectStartSquare =	TEMPORARY_VAR
    152  2062
      0  2062					      NEXT_RANDOM
      1  2062		       a5 81		      lda	rnd
      2  2064		       4a		      lsr
      3  2065		       90 02		      bcc	.skipEOR
      4  2067		       49 fe		      eor	#RND_EOR_VAL
      5  2069		       85 81	   .skipEOR   sta	rnd
    154  206b
    155  206b		       20 cb f5 	      jsr	moveCursor
    156  206e		       20 82 f6 	      jsr	IsValidMoveFromSquare
    157  2071
    158  2071		       c6 8a		      dec	ccur	; pulse colour for valid squares
    159  2073		       20 96 f4 	      jsr	setCursorColours
    160  2076
    161  2076		       98		      tya
    162  2077		       05 4c		      ora	INPT4
    163  2079		       30 04		      bmi	.exit	; illegal square or no button press
    164  207b
      0  207b					      PHASE	AI_StartSquareSelected
      1  207b		       a9 03		      lda	#AI_StartSquareSelected
      2  207d		       85 8c		      sta	aiState
    166  207f
    167  207f		       60	   .exit      rts
    168  2080
    169  2080							;---------------------------------------------------------------------------------------------------
    170  2080
      0  2080					      DEF	setCursorPriority
      1  2080				   SLOT_setCursorPriority SET	_BANK_SLOT
      2  2080				   BANK_setCursorPriority SET	SLOT_setCursorPriority + _CURRENT_BANK
      3  2080				   setCursorPriority
      4  2080				   TEMPORARY_VAR SET	Overlay
      5  2080				   TEMPORARY_OFFSET SET	0
      6  2080				   VAR_BOUNDARY_setCursorPriority SET	TEMPORARY_OFFSET
      7  2080				   FUNCTION_NAME SET	setCursorPriority
    172  2080					      SUBROUTINE
    173  2080
      0  2080					      REFER	moveCursor
      1  2080					      IF	VAREND_moveCursor > TEMPORARY_VAR
      2  2080				   TEMPORARY_VAR SET	VAREND_moveCursor
      3  2080					      ENDIF
      0  2080					      VEND	setCursorPriority
      1  2080				  -	      IFNCONST	setCursorPriority
      2  2080				  -	      ECHO	"Incorrect VEND label", setCursorPriority
      3  2080				  -	      ERR
      4  2080					      ENDIF
      5  2080		       00 a3	   VAREND_setCursorPriority =	TEMPORARY_VAR
    176  2080
    177  2080		       98		      tya
    178  2081		       48		      pha
    179  2082
    180  2082		       a2 04		      ldx	#%100
    181  2084
    182  2084		       a4 88		      ldy	cursorX12
    183  2086		       30 09		      bmi	.under
    184  2088		       20 76 f6 	      jsr	GetBoard
    185  208b		       c9 00		      cmp	#0
    186  208d		       d0 02		      bne	.under
    187  208f		       a2 00		      ldx	#0
    188  2091		       86 4a	   .under     stx	CTRLPF	; UNDER
    189  2093
    190  2093		       68		      pla
    191  2094		       a8		      tay
    192  2095		       60		      rts
    193  2096
    194  2096							;---------------------------------------------------------------------------------------------------
    195  2096
      0  2096					      DEF	setCursorColours
      1  2096				   SLOT_setCursorColours SET	_BANK_SLOT
      2  2096				   BANK_setCursorColours SET	SLOT_setCursorColours + _CURRENT_BANK
      3  2096				   setCursorColours
      4  2096				   TEMPORARY_VAR SET	Overlay
      5  2096				   TEMPORARY_OFFSET SET	0
      6  2096				   VAR_BOUNDARY_setCursorColours SET	TEMPORARY_OFFSET
      7  2096				   FUNCTION_NAME SET	setCursorColours
    197  2096					      SUBROUTINE
    198  2096
      0  2096					      REFER	aiSelectStartSquare
      1  2096				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  2096				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  2096					      ENDIF
      0  2096					      REFER	aiDrawMoves
      1  2096				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  2096				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  2096					      ENDIF
      0  2096					      REFER	aiUnDrawTargetSquares
      1  2096				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  2096				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  2096					      ENDIF
      0  2096					      REFER	aiShowMoveCaptures
      1  2096				  -	      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  2096				  -TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  2096					      ENDIF
      0  2096					      REFER	aiSlowFlash
      1  2096				  -	      IF	VAREND_aiSlowFlash > TEMPORARY_VAR
      2  2096				  -TEMPORARY_VAR SET	VAREND_aiSlowFlash
      3  2096					      ENDIF
      0  2096					      REFER	aiSelectDestinationSquare
      1  2096				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  2096				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  2096					      ENDIF
      0  2096					      VEND	setCursorColours
      1  2096				  -	      IFNCONST	setCursorColours
      2  2096				  -	      ECHO	"Incorrect VEND label", setCursorColours
      3  2096				  -	      ERR
      4  2096					      ENDIF
      5  2096		       00 a2	   VAREND_setCursorColours =	TEMPORARY_VAR
    206  2096
    207  2096							; pass y=-1 if move is NOT in the movelist
    208  2096							; preserve y
    209  2096
    210  2096		       a9 40		      lda	#$40
    211  2098
    212  2098		       c0 ff		      cpy	#-1
    213  209a		       f0 0a		      beq	.writeCursorCol	; NOT in the movelist
    214  209c
    215  209c		       a5 8a		      lda	ccur
    216  209e		       4a		      lsr
    217  209f		       4a		      lsr
    218  20a0		       4a		      lsr
    219  20a1		       29 03		      and	#3
    220  20a3		       18		      clc
    221  20a4		       69 d0		      adc	#$D0	;COLOUR_LINE_1
    222  20a6
    223  20a6		       85 46	   .writeCursorCol sta	COLUP0
    224  20a8		       60		      rts
    225  20a9
    226  20a9
    227  20a9							;---------------------------------------------------------------------------------------------------
    228  20a9
    229  20a9							;	    RLDU RLD  RL U RL	R DU R D  R  U R     LDU  LD   L U  L	  DU   D     U
    230  20a9							;	    0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    231  20a9
      0  20a9					      ALLOCATE	JoyCombined, 16
      0  20a9					      OPTIONAL_PAGEBREAK	"Table", 16
     12  20a9					      LIST	ON
      0  20a9					      DEF	JoyCombined
      1  20a9				   SLOT_JoyCombined SET	_BANK_SLOT
      2  20a9				   BANK_JoyCombined SET	SLOT_JoyCombined + _CURRENT_BANK
      3  20a9				   JoyCombined
      4  20a9				   TEMPORARY_VAR SET	Overlay
      5  20a9				   TEMPORARY_OFFSET SET	0
      6  20a9				   VAR_BOUNDARY_JoyCombined SET	TEMPORARY_OFFSET
      7  20a9				   FUNCTION_NAME SET	JoyCombined
    233  20a9		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, -1, 0
    234  20b9
      0  20b9					      ALLOCATE	JoyMoveCursor, 16
      0  20b9					      OPTIONAL_PAGEBREAK	"Table", 16
     12  20b9					      LIST	ON
      0  20b9					      DEF	JoyMoveCursor
      1  20b9				   SLOT_JoyMoveCursor SET	_BANK_SLOT
      2  20b9				   BANK_JoyMoveCursor SET	SLOT_JoyMoveCursor + _CURRENT_BANK
      3  20b9				   JoyMoveCursor
      4  20b9				   TEMPORARY_VAR SET	Overlay
      5  20b9				   TEMPORARY_OFFSET SET	0
      6  20b9				   VAR_BOUNDARY_JoyMoveCursor SET	TEMPORARY_OFFSET
      7  20b9				   FUNCTION_NAME SET	JoyMoveCursor
    236  20b9		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, -9, 11, 1, 0, -11, 9, -1, 0, -10, 10, 0
    237  20c9
    238  20c9
    239  20c9							;---------------------------------------------------------------------------------------------------
    240  20c9
      0  20c9					      DEF	aiStartSquareSelected
      1  20c9				   SLOT_aiStartSquareSelected SET	_BANK_SLOT
      2  20c9				   BANK_aiStartSquareSelected SET	SLOT_aiStartSquareSelected + _CURRENT_BANK
      3  20c9				   aiStartSquareSelected
      4  20c9				   TEMPORARY_VAR SET	Overlay
      5  20c9				   TEMPORARY_OFFSET SET	0
      6  20c9				   VAR_BOUNDARY_aiStartSquareSelected SET	TEMPORARY_OFFSET
      7  20c9				   FUNCTION_NAME SET	aiStartSquareSelected
    242  20c9					      SUBROUTINE
    243  20c9
      0  20c9					      REFER	AiStateMachine
      1  20c9				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  20c9				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  20c9					      ENDIF
      0  20c9					      VEND	aiStartSquareSelected
      1  20c9				  -	      IFNCONST	aiStartSquareSelected
      2  20c9				  -	      ECHO	"Incorrect VEND label", aiStartSquareSelected
      3  20c9				  -	      ERR
      4  20c9					      ENDIF
      5  20c9		       00 a2	   VAREND_aiStartSquareSelected =	TEMPORARY_VAR
    246  20c9
    247  20c9
    248  20c9							; Mark all the valid moves for the selected piece on the board
    249  20c9							; and then start pulsing the piece
    250  20c9							; AND start choosing for selection of TO square
    251  20c9
    252  20c9							; Iterate the movelist and for all from squares which = drawPieceNumber
    253  20c9							; then draw a BLANK at that square
    254  20c9							; do 1 by one, when none found then increment state
    255  20c9
    256  20c9		       a5 88		      lda	cursorX12
    257  20cb		       85 80		      sta	squareToDraw
    258  20cd
    259  20cd		       a9 0a		      lda	#10
    260  20cf		       85 8d		      sta	aiFlashDelay
    261  20d1
    262  20d1		       a9 00		      lda	#0
    263  20d3		       85 86		      sta	toX12	;aiToSquareX12
    264  20d5		       85 8f		      sta	aiFlashPhase	; for debounce exit timing
    265  20d7
    266  20d7		       a9 ff		      lda	#-1
    267  20d9		       85 8e		      sta	aiMoveIndex
    268  20db
    269  20db		       a9 28		      lda	#HOLD_DELAY
    270  20dd		       85 89		      sta	mdelay	; hold-down delay before moves are shown
    271  20df
      0  20df					      PHASE	AI_DrawMoves
      1  20df		       a9 04		      lda	#AI_DrawMoves
      2  20e1		       85 8c		      sta	aiState
    273  20e3		       60		      rts
    274  20e4
    275  20e4
    276  20e4							;---------------------------------------------------------------------------------------------------
    277  20e4
      0  20e4					      DEF	aiDrawMoves
      1  20e4				   SLOT_aiDrawMoves SET	_BANK_SLOT
      2  20e4				   BANK_aiDrawMoves SET	SLOT_aiDrawMoves + _CURRENT_BANK
      3  20e4				   aiDrawMoves
      4  20e4				   TEMPORARY_VAR SET	Overlay
      5  20e4				   TEMPORARY_OFFSET SET	0
      6  20e4				   VAR_BOUNDARY_aiDrawMoves SET	TEMPORARY_OFFSET
      7  20e4				   FUNCTION_NAME SET	aiDrawMoves
    279  20e4					      SUBROUTINE
    280  20e4
      0  20e4					      REFER	AiStateMachine
      1  20e4				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  20e4				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  20e4					      ENDIF
      0  20e4					      VEND	aiDrawMoves
      1  20e4				  -	      IFNCONST	aiDrawMoves
      2  20e4				  -	      ECHO	"Incorrect VEND label", aiDrawMoves
      3  20e4				  -	      ERR
      4  20e4					      ENDIF
      5  20e4		       00 a2	   VAREND_aiDrawMoves =	TEMPORARY_VAR
    283  20e4
    284  20e4		       c6 8a		      dec	ccur
    285  20e6		       20 96 f4 	      jsr	setCursorColours
    286  20e9
    287  20e9		       c6 89		      dec	mdelay
    288  20eb		       d0 21		      bne	.exit
    289  20ed		       a9 01		      lda	#1	; larger number will slow the draw of available moves
    290  20ef		       85 89		      sta	mdelay	; once triggered, runs always
    291  20f1
    292  20f1		       a5 8e		      lda	aiMoveIndex
    293  20f3		       10 05		      bpl	.valid
    294  20f5		       20 c2 f4 	      jsr	SAFE_getMoveIndex
    295  20f8		       85 8e		      sta	aiMoveIndex
    296  20fa				   .valid
    297  20fa
    298  20fa		       20 1b f5 	      jsr	SAFE_showMoveOptions	; draw potential moves one at a time
    299  20fd		       a5 8e		      lda	aiMoveIndex
    300  20ff		       10 19		      bpl	.unsure	; still drawing in this phase
    301  2101
    302  2101		       a9 14		      lda	#CAP_SPEED
    303  2103		       85 89		      sta	mdelay
    304  2105
    305  2105		       a9 00		      lda	#0
    306  2107		       85 8f		      sta	aiFlashPhase	; controls odd/even exit of flashing
    307  2109
      0  2109					      PHASE	AI_ShowMoveCaptures
      1  2109		       a9 05		      lda	#AI_ShowMoveCaptures
      2  210b		       85 8c		      sta	aiState
    309  210d		       60		      rts
    310  210e
    311  210e				   .exit
    312  210e
    313  210e							; Initial piece selection has happened, but the button hasn't been released yet
    314  210e							; AND we're still in the waiting phase to see if the button was held long enough for move show
    315  210e
    316  210e		       a5 4c		      lda	INPT4
    317  2110		       10 08		      bpl	.unsure	; button still pressed, so still unsure what to do
    318  2112
    319  2112							; Aha! Button released, so we know the selected piece and can start flashing it
    320  2112							; and allowing movement of the selector to a destination square...
    321  2112
    322  2112		       a9 18		      lda	#6*4
    323  2114		       85 8a		      sta	ccur	; bright green square for selection
    324  2116
      0  2116					      PHASE	AI_SelectDestinationSquare
      1  2116		       a9 08		      lda	#AI_SelectDestinationSquare
      2  2118		       85 8c		      sta	aiState
    326  211a
    327  211a		       60	   .unsure    rts
    328  211b
    329  211b
    330  211b							;---------------------------------------------------------------------------------------------------
    331  211b
      0  211b					      DEF	SAFE_showMoveOptions
      1  211b				   SLOT_SAFE_showMoveOptions SET	_BANK_SLOT
      2  211b				   BANK_SAFE_showMoveOptions SET	SLOT_SAFE_showMoveOptions + _CURRENT_BANK
      3  211b				   SAFE_showMoveOptions
      4  211b				   TEMPORARY_VAR SET	Overlay
      5  211b				   TEMPORARY_OFFSET SET	0
      6  211b				   VAR_BOUNDARY_SAFE_showMoveOptions SET	TEMPORARY_OFFSET
      7  211b				   FUNCTION_NAME SET	SAFE_showMoveOptions
    333  211b					      SUBROUTINE
    334  211b
      0  211b					      REFER	aiDrawMoves
      1  211b				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  211b				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  211b					      ENDIF
      0  211b					      REFER	aiUnDrawTargetSquares
      1  211b				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  211b				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  211b					      ENDIF
      0  211b					      VAR	__saveIdx, 1
      1  211b		       00 a2	   __saveIdx  =	TEMPORARY_VAR
      2  211b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  211b
      4  211b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  211b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  211b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  211b					      ENDIF
      8  211b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  211b				  -	      ECHO	"Temporary Variable", __saveIdx, "overflow!"
     10  211b				  -	      ERR
     11  211b					      ENDIF
     12  211b					      LIST	ON
      0  211b					      VAR	__piece, 1
      1  211b		       00 a3	   __piece    =	TEMPORARY_VAR
      2  211b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  211b
      4  211b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  211b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  211b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  211b					      ENDIF
      8  211b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  211b				  -	      ECHO	"Temporary Variable", __piece, "overflow!"
     10  211b				  -	      ERR
     11  211b					      ENDIF
     12  211b					      LIST	ON
      0  211b					      VEND	SAFE_showMoveOptions
      1  211b				  -	      IFNCONST	SAFE_showMoveOptions
      2  211b				  -	      ECHO	"Incorrect VEND label", SAFE_showMoveOptions
      3  211b				  -	      ERR
      4  211b					      ENDIF
      5  211b		       00 a4	   VAREND_SAFE_showMoveOptions =	TEMPORARY_VAR
    340  211b
    341  211b							; place a marker on the board for any square matching the piece
    342  211b							; EXCEPT for squares which are occupied (we'll flash those later)
    343  211b
    344  211b		       a6 8e	   .next      ldx	aiMoveIndex
    345  211d		       86 a2		      stx	__saveIdx
    346  211f		       30 40		      bmi	.skip
    347  2121
    348  2121		       ad 84 02 	      lda	INTIM
    349  2124		       c9 2b		      cmp	#2+SPEEDOF_COPYSINGLEPIECE
    350  2126		       90 39		      bcc	.skip
    351  2128
    352  2128		       c6 8e		      dec	aiMoveIndex
    353  212a
    354  212a		       20 b0 f5 	      jsr	GetP_MoveFrom
    355  212d		       c5 85		      cmp	fromX12
    356  212f		       d0 ea		      bne	.next
    357  2131
    358  2131		       20 bc f5 	      jsr	GetP_MoveTo
    359  2134		       85 80		      sta	squareToDraw
    360  2136
    361  2136		       20 d4 f5 	      jsr	GetP_MovePiece
    362  2139		       85 a3		      sta	__piece
    363  213b
    364  213b							; If it's a pawn promote (duplicate "to" AND piece different (TODO) then skip others)
    365  213b							; TODO this could/will fail on sorted lists. MMh.
    366  213b
    367  213b		       ca	   .sk	      dex
    368  213c		       30 16		      bmi	.prom
    369  213e		       20 bc f5 	      jsr	GetP_MoveTo
    370  2141		       c5 80		      cmp	squareToDraw
    371  2143		       d0 0f		      bne	.prom
    372  2145		       20 d4 f5 	      jsr	GetP_MovePiece
    373  2148		       45 a3		      eor	__piece
    374  214a		       29 0f		      and	#PIECE_MASK
    375  214c		       f0 06		      beq	.prom	; same piece type so not a promote
    376  214e
    377  214e		       c6 8e		      dec	aiMoveIndex
    378  2150		       c6 8e		      dec	aiMoveIndex
    379  2152		       c6 8e		      dec	aiMoveIndex
    380  2154				   .prom
    381  2154
    382  2154		       a4 80		      ldy	squareToDraw
    383  2156		       20 76 f6 	      jsr	GetBoard
    384  2159		       29 0f		      and	#PIECE_MASK
    385  215b		       d0 be		      bne	.next	; don't draw dots on captures - they are flashed later
    386  215d
    387  215d
    388  215d							;lda INTIM
    389  215d							;cmp #SPEEDOF_COPYSINGLEPIECE
    390  215d							;bcc .skip
    391  215d
    392  215d							;lda aiMoveIndex
    393  215d							;sta __saveIdx
    394  215d
    395  215d		       20 a8 f5 	      jsr	markerDraw
    396  2160		       60		      rts
    397  2161
    398  2161		       a5 a2	   .skip      lda	__saveIdx
    399  2163		       85 8e		      sta	aiMoveIndex
    400  2165		       60		      rts
    401  2166
    402  2166
    403  2166							;---------------------------------------------------------------------------------------------------
    404  2166
      0  2166					      DEF	aiUnDrawTargetSquares
      1  2166				   SLOT_aiUnDrawTargetSquares SET	_BANK_SLOT
      2  2166				   BANK_aiUnDrawTargetSquares SET	SLOT_aiUnDrawTargetSquares + _CURRENT_BANK
      3  2166				   aiUnDrawTargetSquares
      4  2166				   TEMPORARY_VAR SET	Overlay
      5  2166				   TEMPORARY_OFFSET SET	0
      6  2166				   VAR_BOUNDARY_aiUnDrawTargetSquares SET	TEMPORARY_OFFSET
      7  2166				   FUNCTION_NAME SET	aiUnDrawTargetSquares
    406  2166					      SUBROUTINE
    407  2166
      0  2166					      REFER	AiStateMachine
      1  2166				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2166				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2166					      ENDIF
      0  2166					      VEND	aiUnDrawTargetSquares
      1  2166				  -	      IFNCONST	aiUnDrawTargetSquares
      2  2166				  -	      ECHO	"Incorrect VEND label", aiUnDrawTargetSquares
      3  2166				  -	      ERR
      4  2166					      ENDIF
      5  2166		       00 a2	   VAREND_aiUnDrawTargetSquares =	TEMPORARY_VAR
    410  2166
    411  2166
    412  2166		       c6 8a		      dec	ccur
    413  2168		       20 96 f4 	      jsr	setCursorColours
    414  216b
    415  216b		       c6 89		      dec	mdelay
    416  216d		       d0 18		      bne	.exit
    417  216f		       a9 01		      lda	#1
    418  2171		       85 89		      sta	mdelay	; once triggered, runs always
    419  2173
    420  2173		       a5 8e		      lda	aiMoveIndex
    421  2175		       10 05		      bpl	.valid
    422  2177		       20 c2 f4 	      jsr	SAFE_getMoveIndex
    423  217a		       85 8e		      sta	aiMoveIndex
    424  217c				   .valid
    425  217c
    426  217c		       20 1b f5 	      jsr	SAFE_showMoveOptions	; draw potential moves one at a time
    427  217f		       a5 8e		      lda	aiMoveIndex
    428  2181		       10 04		      bpl	.exit	; still drawing in this phase
    429  2183
      0  2183					      PHASE	AI_SelectStartSquare
      1  2183		       a9 02		      lda	#AI_SelectStartSquare
      2  2185		       85 8c		      sta	aiState
    431  2187
    432  2187		       60	   .exit      rts
    433  2188
    434  2188
    435  2188							;---------------------------------------------------------------------------------------------------
    436  2188
    437  2188
      0  2188					      DEF	aiShowMoveCaptures
      1  2188				   SLOT_aiShowMoveCaptures SET	_BANK_SLOT
      2  2188				   BANK_aiShowMoveCaptures SET	SLOT_aiShowMoveCaptures + _CURRENT_BANK
      3  2188				   aiShowMoveCaptures
      4  2188				   TEMPORARY_VAR SET	Overlay
      5  2188				   TEMPORARY_OFFSET SET	0
      6  2188				   VAR_BOUNDARY_aiShowMoveCaptures SET	TEMPORARY_OFFSET
      7  2188				   FUNCTION_NAME SET	aiShowMoveCaptures
    439  2188					      SUBROUTINE
    440  2188
      0  2188					      REFER	AiStateMachine
      1  2188				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2188				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2188					      ENDIF
      0  2188					      VEND	aiShowMoveCaptures
      1  2188				  -	      IFNCONST	aiShowMoveCaptures
      2  2188				  -	      ECHO	"Incorrect VEND label", aiShowMoveCaptures
      3  2188				  -	      ERR
      4  2188					      ENDIF
      5  2188		       00 a2	   VAREND_aiShowMoveCaptures =	TEMPORARY_VAR
    443  2188
    444  2188							; draw/undraw ALL captured pieces
    445  2188							; we should do this an even number of times so that pieces don't disappEOR
    446  2188
    447  2188		       c6 8a		      dec	ccur
    448  218a		       20 96 f4 	      jsr	setCursorColours
    449  218d
    450  218d		       c6 89		      dec	mdelay	; flash speed UNVARYING despite draw happening
    451  218f
    452  218f		       a5 8e		      lda	aiMoveIndex
    453  2191		       10 05		      bpl	.valid	; guaranteed -1 on 1st call
    454  2193		       20 c2 f4 	      jsr	SAFE_getMoveIndex
    455  2196		       85 8e		      sta	aiMoveIndex
    456  2198				   .valid
    457  2198
    458  2198		       20 00 f4 	      jsr	SAFE_showMoveCaptures
    459  219b		       a5 8e		      lda	aiMoveIndex
    460  219d		       10 06		      bpl	.exit
    461  219f
    462  219f		       e6 8f		      inc	aiFlashPhase
    463  21a1
      0  21a1					      PHASE	AI_SlowFlash
      1  21a1		       a9 06		      lda	#AI_SlowFlash
      2  21a3		       85 8c		      sta	aiState
    465  21a5
    466  21a5		       60	   .exit      rts
    467  21a6
    468  21a6
    469  21a6							;---------------------------------------------------------------------------------------------------
    470  21a6
      0  21a6					      DEF	aiSlowFlash
      1  21a6				   SLOT_aiSlowFlash SET	_BANK_SLOT
      2  21a6				   BANK_aiSlowFlash SET	SLOT_aiSlowFlash + _CURRENT_BANK
      3  21a6				   aiSlowFlash
      4  21a6				   TEMPORARY_VAR SET	Overlay
      5  21a6				   TEMPORARY_OFFSET SET	0
      6  21a6				   VAR_BOUNDARY_aiSlowFlash SET	TEMPORARY_OFFSET
      7  21a6				   FUNCTION_NAME SET	aiSlowFlash
    472  21a6					      SUBROUTINE
    473  21a6
      0  21a6					      REFER	AiStateMachine
      1  21a6				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  21a6				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  21a6					      ENDIF
      0  21a6					      VEND	aiSlowFlash
      1  21a6				  -	      IFNCONST	aiSlowFlash
      2  21a6				  -	      ECHO	"Incorrect VEND label", aiSlowFlash
      3  21a6				  -	      ERR
      4  21a6					      ENDIF
      5  21a6		       00 a2	   VAREND_aiSlowFlash =	TEMPORARY_VAR
    476  21a6
    477  21a6							; Joystick button is held down, so we're displaying the available moves
    478  21a6							; They have all been drawn, so now we "slow" flash any pieces that can be captures
    479  21a6
    480  21a6		       c6 8a		      dec	ccur
    481  21a8		       20 96 f4 	      jsr	setCursorColours
    482  21ab
    483  21ab		       a5 8f		      lda	aiFlashPhase
    484  21ad		       29 01		      and	#1
    485  21af		       d0 04		      bne	.notEven	; only exit after even # EOR-draws
    486  21b1
    487  21b1		       a5 4c		      lda	INPT4
    488  21b3		       30 0d		      bmi	.butpress	; exit on button release
    489  21b5
    490  21b5				   .notEven
    491  21b5
    492  21b5							; Wait for delay to expire then back and flash 'em again
    493  21b5
    494  21b5		       c6 89		      dec	mdelay
    495  21b7		       10 08		      bpl	.slowWait
    496  21b9
    497  21b9		       a9 14		      lda	#CAP_SPEED
    498  21bb		       85 89		      sta	mdelay
    499  21bd
      0  21bd					      PHASE	AI_ShowMoveCaptures	; go back and rEORdraw all captures again
      1  21bd		       a9 05		      lda	#AI_ShowMoveCaptures
      2  21bf		       85 8c		      sta	aiState
    501  21c1
    502  21c1		       60	   .slowWait  rts
    503  21c2
    504  21c2
    505  21c2		       a9 01	   .butpress  lda	#1
    506  21c4		       85 89		      sta	mdelay
    507  21c6
      0  21c6					      PHASE	AI_UnDrawTargetSquares
      1  21c6		       a9 07		      lda	#AI_UnDrawTargetSquares
      2  21c8		       85 8c		      sta	aiState
    509  21ca		       60		      rts
    510  21cb
    511  21cb
    512  21cb							;---------------------------------------------------------------------------------------------------
    513  21cb
      0  21cb					      DEF	moveCursor
      1  21cb				   SLOT_moveCursor SET	_BANK_SLOT
      2  21cb				   BANK_moveCursor SET	SLOT_moveCursor + _CURRENT_BANK
      3  21cb				   moveCursor
      4  21cb				   TEMPORARY_VAR SET	Overlay
      5  21cb				   TEMPORARY_OFFSET SET	0
      6  21cb				   VAR_BOUNDARY_moveCursor SET	TEMPORARY_OFFSET
      7  21cb				   FUNCTION_NAME SET	moveCursor
    515  21cb					      SUBROUTINE
    516  21cb
      0  21cb					      REFER	aiSelectStartSquare
      1  21cb				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  21cb				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  21cb					      ENDIF
      0  21cb					      REFER	aiSelectDestinationSquare
      1  21cb				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  21cb				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  21cb					      ENDIF
      0  21cb					      VAR	__newCursor, 1
      1  21cb		       00 a2	   __newCursor =	TEMPORARY_VAR
      2  21cb				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  21cb
      4  21cb				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  21cb				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  21cb				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  21cb					      ENDIF
      8  21cb				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  21cb				  -	      ECHO	"Temporary Variable", __newCursor, "overflow!"
     10  21cb				  -	      ERR
     11  21cb					      ENDIF
     12  21cb					      LIST	ON
      0  21cb					      VEND	moveCursor
      1  21cb				  -	      IFNCONST	moveCursor
      2  21cb				  -	      ECHO	"Incorrect VEND label", moveCursor
      3  21cb				  -	      ERR
      4  21cb					      ENDIF
      5  21cb		       00 a3	   VAREND_moveCursor =	TEMPORARY_VAR
    521  21cb
    522  21cb							; Part (a) move cursor around the board waiting for joystick press
    523  21cb
    524  21cb		       a2 00		      ldx	#0	; delay
    525  21cd
    526  21cd		       ad 80 02 	      lda	SWCHA
    527  21d0		       4a		      lsr
    528  21d1		       4a		      lsr
    529  21d2		       4a		      lsr
    530  21d3		       4a		      lsr
    531  21d4		       a8		      tay
    532  21d5
    533  21d5		       c9 0f		      cmp	#15
    534  21d7		       f0 1a		      beq	.cursor	; nothing pressed - skip delays
    535  21d9
    536  21d9		       c6 89		      dec	mdelay
    537  21db		       10 1b		      bpl	.delaym
    538  21dd
    539  21dd		       18		      clc
    540  21de		       a5 88		      lda	cursorX12
    541  21e0		       79 b9 f4 	      adc	JoyMoveCursor,y
    542  21e3		       85 a2		      sta	__newCursor
    543  21e5		       a8		      tay
    544  21e6		       20 ce f4 	      jsr	GetValid
    545  21e9		       c9 ff		      cmp	#-1
    546  21eb		       f0 04		      beq	.invalid
    547  21ed		       a5 a2		      lda	__newCursor
    548  21ef		       85 88		      sta	cursorX12
    549  21f1				   .invalid
    550  21f1
    551  21f1		       a2 10		      ldx	#CURSOR_MOVE_SPEED
    552  21f3		       86 89	   .cursor    stx	mdelay
    553  21f5		       20 80 f4 	      jsr	setCursorPriority
    554  21f8		       60	   .delaym    rts
    555  21f9
    556  21f9
    557  21f9							;---------------------------------------------------------------------------------------------------
    558  21f9
      0  21f9					      DEF	aiSelectDestinationSquare
      1  21f9				   SLOT_aiSelectDestinationSquare SET	_BANK_SLOT
      2  21f9				   BANK_aiSelectDestinationSquare SET	SLOT_aiSelectDestinationSquare + _CURRENT_BANK
      3  21f9				   aiSelectDestinationSquare
      4  21f9				   TEMPORARY_VAR SET	Overlay
      5  21f9				   TEMPORARY_OFFSET SET	0
      6  21f9				   VAR_BOUNDARY_aiSelectDestinationSquare SET	TEMPORARY_OFFSET
      7  21f9				   FUNCTION_NAME SET	aiSelectDestinationSquare
    560  21f9					      SUBROUTINE
    561  21f9
      0  21f9					      REFER	AiStateMachine
      1  21f9				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  21f9				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  21f9					      ENDIF
      0  21f9					      VEND	aiSelectDestinationSquare
      1  21f9				  -	      IFNCONST	aiSelectDestinationSquare
      2  21f9				  -	      ECHO	"Incorrect VEND label", aiSelectDestinationSquare
      3  21f9				  -	      ERR
      4  21f9					      ENDIF
      5  21f9		       00 a2	   VAREND_aiSelectDestinationSquare =	TEMPORARY_VAR
    564  21f9
    565  21f9							; Piece is selected and now we're looking for a button press on a destination square
    566  21f9							; we flash the piece on-and-off while we're doing that
    567  21f9							; Flash the selected piece
    568  21f9
    569  21f9		       ad 84 02 	      lda	INTIM
    570  21fc		       c9 28		      cmp	#ONCEPERFRAME
    571  21fe		       90 0e		      bcc	.exit
    572  2200
    573  2200
    574  2200		       c6 8d		      dec	aiFlashDelay
    575  2202		       d0 0a		      bne	.exit	; don't flash
    576  2204		       a9 14		      lda	#CAP_SPEED
    577  2206		       85 8d		      sta	aiFlashDelay
    578  2208
    579  2208		       e6 8f		      inc	aiFlashPhase
    580  220a
    581  220a		       20 83 f0 	      jsr	CopySinglePiece	;@0
    582  220d		       60		      rts
    583  220e
    584  220e				   .exit
    585  220e		       20 cb f5 	      jsr	moveCursor
    586  2211
    587  2211		       ad 84 02 	      lda	INTIM
    588  2214		       c9 14		      cmp	#20
    589  2216		       90 35		      bcc	.noButton
    590  2218
    591  2218
    592  2218		       a4 88		      ldy	cursorX12
    593  221a		       84 86		      sty	toX12
    594  221c
    595  221c		       20 c8 f5 	      jsr	GetPiece
    596  221f		       20 96 f4 	      jsr	setCursorColours
    597  2222
    598  2222
    599  2222							; y = valid square
    600  2222
    601  2222		       a5 4c		      lda	INPT4
    602  2224		       30 27		      bmi	.noButton
    603  2226
    604  2226		       a5 86		      lda	toX12
    605  2228		       c5 85		      cmp	fromX12
    606  222a		       f0 0d		      beq	.cancel
    607  222c
    608  222c		       c0 ff		      cpy	#-1
    609  222e		       f0 1d		      beq	.noButton	; not a valid square
    610  2230
    611  2230		       a5 8f		      lda	aiFlashPhase
    612  2232		       29 01		      and	#1
    613  2234		       f0 13		      beq	.done
    614  2236		       85 8d		      sta	aiFlashDelay	; EOR-phase incorrect - force quick fix to allow next-frame button detect
    615  2238		       60		      rts
    616  2239
    617  2239				   .cancel
    618  2239
    619  2239		       a5 8f		      lda	aiFlashPhase
    620  223b		       29 01		      and	#1
    621  223d		       f0 05		      beq	.doCancel
    622  223f
    623  223f							; EOR-phase incorrect - force quick fix to allow next-frame button detect
    624  223f
    625  223f		       a9 01		      lda	#1
    626  2241		       85 8d		      sta	aiFlashDelay
    627  2243		       60		      rts
    628  2244
    629  2244
      0  2244				   .doCancel  PHASE	AI_ReselectDebounce
      1  2244		       a9 0a		      lda	#AI_ReselectDebounce
      2  2246		       85 8c		      sta	aiState
    631  2248		       60		      rts
    632  2249
      0  2249				   .done      PHASE	AI_Quiescent	; destination selected!
      1  2249		       a9 09		      lda	#AI_Quiescent
      2  224b		       85 8c		      sta	aiState
    634  224d		       60	   .noButton  rts
    635  224e
    636  224e
    637  224e
    638  224e
    639  224e							;---------------------------------------------------------------------------------------------------
    640  224e
      0  224e					      DEF	aiReselectDebounce
      1  224e				   SLOT_aiReselectDebounce SET	_BANK_SLOT
      2  224e				   BANK_aiReselectDebounce SET	SLOT_aiReselectDebounce + _CURRENT_BANK
      3  224e				   aiReselectDebounce
      4  224e				   TEMPORARY_VAR SET	Overlay
      5  224e				   TEMPORARY_OFFSET SET	0
      6  224e				   VAR_BOUNDARY_aiReselectDebounce SET	TEMPORARY_OFFSET
      7  224e				   FUNCTION_NAME SET	aiReselectDebounce
    642  224e					      SUBROUTINE
    643  224e
      0  224e					      REFER	AiStateMachine
      1  224e				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  224e				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  224e					      ENDIF
      0  224e					      VEND	aiReselectDebounce
      1  224e				  -	      IFNCONST	aiReselectDebounce
      2  224e				  -	      ECHO	"Incorrect VEND label", aiReselectDebounce
      3  224e				  -	      ERR
      4  224e					      ENDIF
      5  224e		       00 a2	   VAREND_aiReselectDebounce =	TEMPORARY_VAR
    646  224e
    647  224e							; We've just cancelled the move. Wait for the button to be released
    648  224e							; and then go back to selecting a piece to move
    649  224e
    650  224e		       a5 4c		      lda	INPT4
    651  2250		       10 04		      bpl	.exit	; button still pressed, so wait
    652  2252
      0  2252					      PHASE	AI_SelectStartSquare
      1  2252		       a9 02		      lda	#AI_SelectStartSquare
      2  2254		       85 8c		      sta	aiState
    654  2256		       60	   .exit      rts
    655  2257
    656  2257
    657  2257							;---------------------------------------------------------------------------------------------------
    658  2257
      0  2257					      DEF	aiQuiescent
      1  2257				   SLOT_aiQuiescent SET	_BANK_SLOT
      2  2257				   BANK_aiQuiescent SET	SLOT_aiQuiescent + _CURRENT_BANK
      3  2257				   aiQuiescent
      4  2257				   TEMPORARY_VAR SET	Overlay
      5  2257				   TEMPORARY_OFFSET SET	0
      6  2257				   VAR_BOUNDARY_aiQuiescent SET	TEMPORARY_OFFSET
      7  2257				   FUNCTION_NAME SET	aiQuiescent
    660  2257					      SUBROUTINE
    661  2257
      0  2257					      REFER	AiStateMachine
      1  2257				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2257				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2257					      ENDIF
      0  2257					      VEND	aiQuiescent
      1  2257				  -	      IFNCONST	aiQuiescent
      2  2257				  -	      ECHO	"Incorrect VEND label", aiQuiescent
      3  2257				  -	      ERR
      4  2257					      ENDIF
      5  2257		       00 a2	   VAREND_aiQuiescent =	TEMPORARY_VAR
    664  2257
    665  2257							; Move has been selected
    666  2257
    667  2257		       a9 ff		      lda	#-1
    668  2259		       85 88		      sta	cursorX12
    669  225b
    670  225b		       a5 85		      lda	fromX12
    671  225d		       85 87		      sta	originX12
    672  225f		       20 c8 f5 	      jsr	GetPiece	; from the movelist
    673  2262
    674  2262		       a4 85		      ldy	fromX12
    675  2264		       20 76 f6 	      jsr	GetBoard	; get the piece from the board itself
    676  2267
    677  2267		       45 97		      eor	fromPiece
    678  2269		       29 0f		      and	#PIECE_MASK	; if not the same piece board/movelist...
    679  226b		       d0 05		      bne	.promote	; promote a pawn
    680  226d
      0  226d					      PHASE	AI_MoveIsSelected
      1  226d		       a9 14		      lda	#AI_MoveIsSelected
      2  226f		       85 8c		      sta	aiState
    682  2271		       60		      rts
    683  2272
      0  2272				   .promote   PHASE	AI_PromotePawnStart
      1  2272		       a9 1f		      lda	#AI_PromotePawnStart
      2  2274		       85 8c		      sta	aiState
    685  2276		       60		      rts
    686  2277
    687  2277
    688  2277							;---------------------------------------------------------------------------------------------------
    689  2277
      0  2277					      DEF	aiRollPromotionPiece
      1  2277				   SLOT_aiRollPromotionPiece SET	_BANK_SLOT
      2  2277				   BANK_aiRollPromotionPiece SET	SLOT_aiRollPromotionPiece + _CURRENT_BANK
      3  2277				   aiRollPromotionPiece
      4  2277				   TEMPORARY_VAR SET	Overlay
      5  2277				   TEMPORARY_OFFSET SET	0
      6  2277				   VAR_BOUNDARY_aiRollPromotionPiece SET	TEMPORARY_OFFSET
      7  2277				   FUNCTION_NAME SET	aiRollPromotionPiece
    691  2277					      SUBROUTINE
    692  2277
      0  2277					      REFER	AiStateMachine
      1  2277				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2277				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2277					      ENDIF
      0  2277					      VEND	aiRollPromotionPiece
      1  2277				  -	      IFNCONST	aiRollPromotionPiece
      2  2277				  -	      ECHO	"Incorrect VEND label", aiRollPromotionPiece
      3  2277				  -	      ERR
      4  2277					      ENDIF
      5  2277		       00 a2	   VAREND_aiRollPromotionPiece =	TEMPORARY_VAR
    695  2277
    696  2277							; Flash the '?' and wait for an UDLR move
    697  2277
    698  2277		       ad 84 02 	      lda	INTIM
    699  227a		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    700  227c		       90 28		      bcc	.exit
    701  227e
    702  227e		       ad 80 02 	      lda	SWCHA
    703  2281		       29 f0		      and	#$F0
    704  2283		       c9 f0		      cmp	#$F0
    705  2285		       f0 0a		      beq	.nojoy
    706  2287
    707  2287		       a9 00		      lda	#0
    708  2289		       85 8d		      sta	aiFlashDelay
    709  228b
    710  228b		       a5 8f		      lda	aiFlashPhase
    711  228d		       29 01		      and	#1
    712  228f		       f0 16		      beq	.even
    713  2291
    714  2291		       c6 8d	   .nojoy     dec	aiFlashDelay
    715  2293		       10 11		      bpl	.exit
    716  2295
    717  2295		       a9 0a		      lda	#10
    718  2297		       85 8d		      sta	aiFlashDelay
    719  2299
    720  2299		       a2 20		      ldx	#INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0
    721  229b		       a5 96		      lda	sideToMove
    722  229d		       10 02		      bpl	.wtm
    723  229f		       a2 68		      ldx	#INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0
    724  22a1				   .wtm
    725  22a1		       20 53 f4 	      jsr	showPromoteOptions
    726  22a4
    727  22a4		       e6 8f		      inc	aiFlashPhase
    728  22a6
    729  22a6		       60	   .exit      rts
    730  22a7
    731  22a7
    732  22a7		       a9 03	   .even      lda	#3	; QUEEN
    733  22a9		       85 97		      sta	fromPiece	; cycles as index to NBRQ
    734  22ab
    735  22ab		       e6 8f		      inc	aiFlashPhase
    736  22ad
    737  22ad
    738  22ad		       a2 14		      ldx	#INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0	;TODO: fix for colour
    739  22af		       a5 96		      lda	sideToMove
    740  22b1		       10 02		      bpl	.whiteToMove
    741  22b3		       a2 5c		      ldx	#INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    742  22b5				   .whiteToMove
    743  22b5
    744  22b5		       20 53 f4 	      jsr	showPromoteOptions
    745  22b8
      0  22b8					      PHASE	AI_ChooseDebounce
      1  22b8		       a9 22		      lda	#AI_ChooseDebounce
      2  22ba		       85 8c		      sta	aiState
    747  22bc		       60		      rts
    748  22bd
    749  22bd
    750  22bd							;---------------------------------------------------------------------------------------------------
    751  22bd
      0  22bd					      DEF	aiMarchToTargetA
      1  22bd				   SLOT_aiMarchToTargetA SET	_BANK_SLOT
      2  22bd				   BANK_aiMarchToTargetA SET	SLOT_aiMarchToTargetA + _CURRENT_BANK
      3  22bd				   aiMarchToTargetA
      4  22bd				   TEMPORARY_VAR SET	Overlay
      5  22bd				   TEMPORARY_OFFSET SET	0
      6  22bd				   VAR_BOUNDARY_aiMarchToTargetA SET	TEMPORARY_OFFSET
      7  22bd				   FUNCTION_NAME SET	aiMarchToTargetA
    753  22bd					      SUBROUTINE
    754  22bd
      0  22bd					      REFER	AiStateMachine
      1  22bd				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  22bd				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  22bd					      ENDIF
      0  22bd					      VAR	__fromRow, 1
      1  22bd		       00 a2	   __fromRow  =	TEMPORARY_VAR
      2  22bd				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  22bd
      4  22bd				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  22bd				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  22bd				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  22bd					      ENDIF
      8  22bd				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  22bd				  -	      ECHO	"Temporary Variable", __fromRow, "overflow!"
     10  22bd				  -	      ERR
     11  22bd					      ENDIF
     12  22bd					      LIST	ON
      0  22bd					      VAR	__boardIndex, 1
      1  22bd		       00 a3	   __boardIndex =	TEMPORARY_VAR
      2  22bd				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  22bd
      4  22bd				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  22bd				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  22bd				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  22bd					      ENDIF
      8  22bd				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  22bd				  -	      ECHO	"Temporary Variable", __boardIndex, "overflow!"
     10  22bd				  -	      ERR
     11  22bd					      ENDIF
     12  22bd					      LIST	ON
      0  22bd					      VAR	__fromCol, 1
      1  22bd		       00 a4	   __fromCol  =	TEMPORARY_VAR
      2  22bd				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  22bd
      4  22bd				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  22bd				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  22bd				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  22bd					      ENDIF
      8  22bd				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  22bd				  -	      ECHO	"Temporary Variable", __fromCol, "overflow!"
     10  22bd				  -	      ERR
     11  22bd					      ENDIF
     12  22bd					      LIST	ON
      0  22bd					      VAR	__toCol, 1
      1  22bd		       00 a5	   __toCol    =	TEMPORARY_VAR
      2  22bd				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  22bd
      4  22bd				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  22bd				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  22bd				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  22bd					      ENDIF
      8  22bd				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  22bd				  -	      ECHO	"Temporary Variable", __toCol, "overflow!"
     10  22bd				  -	      ERR
     11  22bd					      ENDIF
     12  22bd					      LIST	ON
      0  22bd					      VEND	aiMarchToTargetA
      1  22bd				  -	      IFNCONST	aiMarchToTargetA
      2  22bd				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetA
      3  22bd				  -	      ERR
      4  22bd					      ENDIF
      5  22bd		       00 a6	   VAREND_aiMarchToTargetA =	TEMPORARY_VAR
    761  22bd
    762  22bd
    763  22bd							; Now we calculate move to new square
    764  22bd
    765  22bd		       a5 85		      lda	fromX12
    766  22bf		       c5 86		      cmp	toX12
    767  22c1		       f0 44		      beq	.unmovedx
    768  22c3		       85 83		      sta	lastSquareX12
    769  22c5
    770  22c5		       38		      sec
    771  22c6		       a2 fd		      ldx	#-3
    772  22c8		       e9 0a	   .sub10     sbc	#10
    773  22ca		       e8		      inx
    774  22cb		       b0 fb		      bcs	.sub10
    775  22cd		       69 08		      adc	#8
    776  22cf		       85 a4		      sta	__fromCol
    777  22d1		       86 a2		      stx	__fromRow
    778  22d3
    779  22d3		       a5 86		      lda	toX12
    780  22d5		       38		      sec
    781  22d6		       a2 fd		      ldx	#-3
    782  22d8		       e9 0a	   .sub10b    sbc	#10
    783  22da		       e8		      inx
    784  22db		       b0 fb		      bcs	.sub10b
    785  22dd		       69 08		      adc	#8
    786  22df		       85 a5		      sta	__toCol
    787  22e1
    788  22e1
    789  22e1		       e4 a2		      cpx	__fromRow
    790  22e3		       f0 13		      beq	.rowDone
    791  22e5
    792  22e5		       b0 0a		      bcs	.incRow
    793  22e7
    794  22e7		       38		      sec
    795  22e8		       a5 85		      lda	fromX12
    796  22ea		       e9 0a		      sbc	#10
    797  22ec		       85 85		      sta	fromX12
    798  22ee		       4c f8 f6 	      jmp	.rowDone
    799  22f1
    800  22f1		       18	   .incRow    clc
    801  22f2		       a5 85		      lda	fromX12
    802  22f4		       69 0a		      adc	#10
    803  22f6		       85 85		      sta	fromX12
    804  22f8
    805  22f8				   .rowDone
    806  22f8
    807  22f8		       a5 a5		      lda	__toCol
    808  22fa		       c5 a4		      cmp	__fromCol
    809  22fc		       f0 09		      beq	.colDone
    810  22fe
    811  22fe		       b0 05		      bcs	.incCol
    812  2300
    813  2300		       c6 85		      dec	fromX12
    814  2302		       4c 07 f7 	      jmp	.colDone
    815  2305
    816  2305		       e6 85	   .incCol    inc	fromX12
    817  2307				   .colDone
    818  2307				   .unmovedx
    819  2307
      0  2307					      PHASE	AI_MarchA2
      1  2307		       a9 17		      lda	#AI_MarchA2
      2  2309		       85 8c		      sta	aiState
    821  230b		       60		      rts
    822  230c
    823  230c
    824  230c							;---------------------------------------------------------------------------------------------------
    825  230c
      0  230c					      DEF	aiMarchA2
      1  230c				   SLOT_aiMarchA2 SET	_BANK_SLOT
      2  230c				   BANK_aiMarchA2 SET	SLOT_aiMarchA2 + _CURRENT_BANK
      3  230c				   aiMarchA2
      4  230c				   TEMPORARY_VAR SET	Overlay
      5  230c				   TEMPORARY_OFFSET SET	0
      6  230c				   VAR_BOUNDARY_aiMarchA2 SET	TEMPORARY_OFFSET
      7  230c				   FUNCTION_NAME SET	aiMarchA2
    827  230c					      SUBROUTINE
    828  230c
    829  230c
    830  230c							; erase object in new sqare --> blank
    831  230c
    832  230c		       a4 85		      ldy	fromX12
    833  230e		       84 80		      sty	squareToDraw
    834  2310
    835  2310		       20 76 f6 	      jsr	GetBoard
    836  2313		       c9 00		      cmp	#0
    837  2315		       f0 03		      beq	.skipbl
    838  2317		       20 83 f0 	      jsr	CopySinglePiece	;@0	      ; erase next square along --> blank
    839  231a
    840  231a				   .skipbl
    841  231a		       a4 85		      ldy	fromX12
    842  231c		       84 a3		      sty	__boardIndex
    843  231e
    844  231e		       20 76 f6 	      jsr	GetBoard
    845  2321		       85 98		      sta	lastPiece	; what we are overwriting
    846  2323		       a5 97		      lda	fromPiece
    847  2325		       09 40		      ora	#FLAG_MOVED	; prevents usage in castling for K/R
    848  2327		       29 df		      and	#~FLAG_ENPASSANT
    849  2329		       a4 a3		      ldy	__boardIndex
    850  232b		       20 6a f6 	      jsr	PutBoard
    851  232e
      0  232e					      PHASE	AI_MarchB
      1  232e		       a9 18		      lda	#AI_MarchB
      2  2330		       85 8c		      sta	aiState
    853  2332		       60		      rts
    854  2333
    855  2333
    856  2333							;---------------------------------------------------------------------------------------------------
    857  2333
      0  2333					      DEF	aiMarchB2
      1  2333				   SLOT_aiMarchB2 SET	_BANK_SLOT
      2  2333				   BANK_aiMarchB2 SET	SLOT_aiMarchB2 + _CURRENT_BANK
      3  2333				   aiMarchB2
      4  2333				   TEMPORARY_VAR SET	Overlay
      5  2333				   TEMPORARY_OFFSET SET	0
      6  2333				   VAR_BOUNDARY_aiMarchB2 SET	TEMPORARY_OFFSET
      7  2333				   FUNCTION_NAME SET	aiMarchB2
    859  2333					      SUBROUTINE
    860  2333
      0  2333					      REFER	AiStateMachine
      1  2333				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2333				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2333					      ENDIF
      0  2333					      VEND	aiMarchB2
      1  2333				  -	      IFNCONST	aiMarchB2
      2  2333				  -	      ECHO	"Incorrect VEND label", aiMarchB2
      3  2333				  -	      ERR
      4  2333					      ENDIF
      5  2333		       00 a2	   VAREND_aiMarchB2 =	TEMPORARY_VAR
    863  2333
    864  2333		       a4 83		      ldy	lastSquareX12
    865  2335		       84 80		      sty	squareToDraw
    866  2337
    867  2337		       20 76 f6 	      jsr	GetBoard
    868  233a		       c9 00		      cmp	#0
    869  233c		       f0 03		      beq	.skipbl2
    870  233e
    871  233e		       20 83 f0 	      jsr	CopySinglePiece	;@0	      ; draw previous piece back in old position
    872  2341				   .skipbl2
    873  2341
    874  2341		       a5 85		      lda	fromX12
    875  2343		       c5 86		      cmp	toX12
    876  2345		       f0 09		      beq	xhalt
    877  2347
    878  2347		       a9 00		      lda	#0	; inter-move segment speed (can be 0)
    879  2349		       85 82		      sta	drawDelay
      0  234b					      PHASE	AI_MarchToTargetA
      1  234b		       a9 16		      lda	#AI_MarchToTargetA
      2  234d		       85 8c		      sta	aiState
    881  234f
    882  234f		       60		      rts
    883  2350
    884  2350				   xhalt
    885  2350
    886  2350							;??? jsr FinaliseMove
    887  2350
    888  2350		       a9 04		      lda	#4	; on/off count
    889  2352		       85 84		      sta	drawCount	; flashing for piece about to move
    890  2354		       a9 00		      lda	#0
    891  2356		       85 82		      sta	drawDelay
    892  2358
      0  2358					      PHASE	AI_FinalFlash
      1  2358		       a9 1b		      lda	#AI_FinalFlash
      2  235a		       85 8c		      sta	aiState
    894  235c		       60		      rts
    895  235d
    896  235d							;---------------------------------------------------------------------------------------------------
    897  235d
      0  235d					      CHECK_BANK_SIZE	"BANK_StateMachine"
      1  235d		       03 5d	   .TEMP      =	* - _BANK_START
 BANK_StateMachine (1K) SIZE =  $35d , FREE= $a3
      2  235d					      ECHO	"BANK_StateMachine", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  235d				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  235d				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_StateMachine", " size=", * - ORIGIN
      5  235d				  -	      ERR
      6  235d					      ENDIF
    899  235d
    900  235d
    901  235d							;---------------------------------------------------------------------------------------------------
    902  235d
    903  235d							; EOF
------- FILE ./chess.asm
------- FILE BANK_StateMachine@1#2.asm LEVEL 2 PASS 4
      0  235d					      include	"BANK_StateMachine@1#2.asm"
      0  235d					      SLOT	1
      1  235d				  -	      IF	(1 < 0) || (1 > 3)
      2  235d				  -	      ECHO	"Illegal bank address/segment location", 1
      3  235d				  -	      ERR
      4  235d					      ENDIF
      5  235d				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  235d				   _BANK_SLOT SET	1 * 64
      0  235d					      NEWBANK	STATEMACHINE2
      1  2538 ????				      SEG	STATEMACHINE2
      2  2400					      ORG	_ORIGIN
      3  2400					      RORG	_BANK_ADDRESS_ORIGIN
      4  2400				   _BANK_START SET	*
      5  2400				   STATEMACHINE2_START SET	*
      6  2400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2400				   STATEMACHINE2 SET	_BANK_SLOT + _CURRENT_BANK
      8  2400				   _ORIGIN    SET	_ORIGIN + 1024
      3  2400
      4  2400							;---------------------------------------------------------------------------------------------------
      5  2400
      0  2400					      DEF	aiChoosePromotePiece
      1  2400				   SLOT_aiChoosePromotePiece SET	_BANK_SLOT
      2  2400				   BANK_aiChoosePromotePiece SET	SLOT_aiChoosePromotePiece + _CURRENT_BANK
      3  2400				   aiChoosePromotePiece
      4  2400				   TEMPORARY_VAR SET	Overlay
      5  2400				   TEMPORARY_OFFSET SET	0
      6  2400				   VAR_BOUNDARY_aiChoosePromotePiece SET	TEMPORARY_OFFSET
      7  2400				   FUNCTION_NAME SET	aiChoosePromotePiece
      7  2400					      SUBROUTINE
      8  2400
      0  2400					      REFER	AiStateMachine
      1  2400				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2400				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2400					      ENDIF
      0  2400					      VEND	aiChoosePromotePiece
      1  2400				  -	      IFNCONST	aiChoosePromotePiece
      2  2400				  -	      ECHO	"Incorrect VEND label", aiChoosePromotePiece
      3  2400				  -	      ERR
      4  2400					      ENDIF
      5  2400		       00 a2	   VAREND_aiChoosePromotePiece =	TEMPORARY_VAR
     11  2400
     12  2400							; Question-mark phase has exited via joystick direction
     13  2400							; Now we cycle through the selectable pieces
     14  2400
     15  2400		       ad 84 02 	      lda	INTIM
     16  2403		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
     17  2405		       90 40		      bcc	.exit
     18  2407
     19  2407		       a5 4c		      lda	INPT4
     20  2409		       30 0a		      bmi	.nobut	; no press
     21  240b
     22  240b							; button pressed but make sure phase is correct for exit
     23  240b
     24  240b		       a9 00		      lda	#0
     25  240d		       85 8d		      sta	aiFlashDelay
     26  240f
     27  240f		       a5 8f		      lda	aiFlashPhase
     28  2411		       29 01		      and	#1
     29  2413		       f0 33		      beq	.chosen	; button pressed --> selection made
     30  2415
     31  2415				   .nobut
     32  2415		       ad 80 02 	      lda	SWCHA
     33  2418		       29 f0		      and	#$F0
     34  241a		       c9 f0		      cmp	#$F0
     35  241c		       f0 17		      beq	.odd	; no direction pressed
     36  241e
     37  241e		       4a		      lsr
     38  241f		       4a		      lsr
     39  2420		       4a		      lsr
     40  2421		       4a		      lsr
     41  2422		       a8		      tay
     42  2423
     43  2423							; joystick but make sure phase is correct
     44  2423
     45  2423		       a5 8f		      lda	aiFlashPhase
     46  2425		       4a		      lsr
     47  2426		       b0 0d		      bcs	.odd	; must wait until piece undrawn
     48  2428
     49  2428							; cycle to the next promotable piece (N/B/R/Q)
     50  2428							; TODO; use joy table for mod instead of just incrementing all the time
     51  2428
     52  2428							;clc
     53  2428		       a5 97		      lda	fromPiece
     54  242a		       79 a9 f4 	      adc	JoyCombined,y
     55  242d		       29 03		      and	#3
     56  242f		       85 97		      sta	fromPiece
     57  2431
      0  2431					      PHASE	AI_ChooseDebounce	; wait for release
      1  2431		       a9 22		      lda	#AI_ChooseDebounce
      2  2433		       85 8c		      sta	aiState
     59  2435
     60  2435		       c6 8d	   .odd       dec	aiFlashDelay
     61  2437		       10 0e		      bpl	.exit
     62  2439
     63  2439		       a9 0a	   .force     lda	#10
     64  243b		       85 8d		      sta	aiFlashDelay
     65  243d
     66  243d		       e6 8f		      inc	aiFlashPhase
     67  243f
     68  243f		       a4 97		      ldy	fromPiece
     69  2441		       be 63 f4 	      ldx	promotePiece,y
     70  2444		       20 53 f4 	      jsr	showPromoteOptions
     71  2447
     72  2447		       60	   .exit      rts
     73  2448
     74  2448
     75  2448				   .chosen
     76  2448		       a5 97		      lda	fromPiece
     77  244a		       29 0f		      and	#PIECE_MASK
     78  244c		       aa		      tax
     79  244d
     80  244d		       bd 67 f4 	      lda	promoteType,x
     81  2450		       85 97		      sta	fromPiece
     82  2452
     83  2452		       a4 86		      ldy	toX12
     84  2454		       20 76 f6 	      jsr	GetBoard
     85  2457		       29 0f		      and	#PIECE_MASK
     86  2459		       f0 03		      beq	.nothing
     87  245b
     88  245b		       20 83 f0 	      jsr	CopySinglePiece	;@0	      ; put back whatever was there to start
     89  245e
      0  245e				   .nothing   PHASE	AI_MoveIsSelected
      1  245e		       a9 14		      lda	#AI_MoveIsSelected
      2  2460		       85 8c		      sta	aiState
     91  2462		       60		      rts
     92  2463
      0  2463					      ALLOCATE	promotePiece, 4
      0  2463					      OPTIONAL_PAGEBREAK	"Table", 4
     12  2463					      LIST	ON
      0  2463					      DEF	promotePiece
      1  2463				   SLOT_promotePiece SET	_BANK_SLOT
      2  2463				   BANK_promotePiece SET	SLOT_promotePiece + _CURRENT_BANK
      3  2463				   promotePiece
      4  2463				   TEMPORARY_VAR SET	Overlay
      5  2463				   TEMPORARY_OFFSET SET	0
      6  2463				   VAR_BOUNDARY_promotePiece SET	TEMPORARY_OFFSET
      7  2463				   FUNCTION_NAME SET	promotePiece
     94  2463		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
     95  2464		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
     96  2465		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
     97  2466		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
     98  2467
      0  2467					      ALLOCATE	promoteType,4
      0  2467					      OPTIONAL_PAGEBREAK	"Table", 4
     12  2467					      LIST	ON
      0  2467					      DEF	promoteType
      1  2467				   SLOT_promoteType SET	_BANK_SLOT
      2  2467				   BANK_promoteType SET	SLOT_promoteType + _CURRENT_BANK
      3  2467				   promoteType
      4  2467				   TEMPORARY_VAR SET	Overlay
      5  2467				   TEMPORARY_OFFSET SET	0
      6  2467				   VAR_BOUNDARY_promoteType SET	TEMPORARY_OFFSET
      7  2467				   FUNCTION_NAME SET	promoteType
    100  2467		       03 04 05 06	      .byte.b	KNIGHT, BISHOP, ROOK, QUEEN
    101  246b
    102  246b
    103  246b							;---------------------------------------------------------------------------------------------------
    104  246b
      0  246b					      DEF	aiChooseDebounce
      1  246b				   SLOT_aiChooseDebounce SET	_BANK_SLOT
      2  246b				   BANK_aiChooseDebounce SET	SLOT_aiChooseDebounce + _CURRENT_BANK
      3  246b				   aiChooseDebounce
      4  246b				   TEMPORARY_VAR SET	Overlay
      5  246b				   TEMPORARY_OFFSET SET	0
      6  246b				   VAR_BOUNDARY_aiChooseDebounce SET	TEMPORARY_OFFSET
      7  246b				   FUNCTION_NAME SET	aiChooseDebounce
    106  246b					      SUBROUTINE
    107  246b
      0  246b					      REFER	AiStateMachine
      1  246b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  246b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  246b					      ENDIF
      0  246b					      VEND	aiChooseDebounce
      1  246b				  -	      IFNCONST	aiChooseDebounce
      2  246b				  -	      ECHO	"Incorrect VEND label", aiChooseDebounce
      3  246b				  -	      ERR
      4  246b					      ENDIF
      5  246b		       00 a2	   VAREND_aiChooseDebounce =	TEMPORARY_VAR
    110  246b
    111  246b							; We've changed promotion piece, but wait for joystick to be released
    112  246b
    113  246b		       ad 80 02 	      lda	SWCHA
    114  246e		       29 f0		      and	#$F0
    115  2470		       c9 f0		      cmp	#$F0
    116  2472		       d0 08		      bne	.exit	; wait while joystick still pressed
    117  2474
    118  2474		       a9 01		      lda	#1
    119  2476		       85 8d		      sta	aiFlashDelay
    120  2478
      0  2478					      PHASE	AI_ChoosePromotePiece
      1  2478		       a9 21		      lda	#AI_ChoosePromotePiece
      2  247a		       85 8c		      sta	aiState
    122  247c		       60	   .exit      rts
    123  247d
    124  247d
    125  247d							;---------------------------------------------------------------------------------------------------
    126  247d
      0  247d					      DEF	aiDelayAfterMove
      1  247d				   SLOT_aiDelayAfterMove SET	_BANK_SLOT
      2  247d				   BANK_aiDelayAfterMove SET	SLOT_aiDelayAfterMove + _CURRENT_BANK
      3  247d				   aiDelayAfterMove
      4  247d				   TEMPORARY_VAR SET	Overlay
      5  247d				   TEMPORARY_OFFSET SET	0
      6  247d				   VAR_BOUNDARY_aiDelayAfterMove SET	TEMPORARY_OFFSET
      7  247d				   FUNCTION_NAME SET	aiDelayAfterMove
    128  247d					      SUBROUTINE
    129  247d
      0  247d					      VEND	aiDelayAfterMove
      1  247d				  -	      IFNCONST	aiDelayAfterMove
      2  247d				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  247d				  -	      ERR
      4  247d					      ENDIF
      5  247d		       00 a2	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
    131  247d
    132  247d		       a9 32		      lda	#50
    133  247f		       85 8d		      sta	aiFlashDelay
      0  2481					      PHASE	AI_DelayAfterMove2
      1  2481		       a9 26		      lda	#AI_DelayAfterMove2
      2  2483		       85 8c		      sta	aiState
    135  2485		       60	   .exit      rts
    136  2486
    137  2486
    138  2486							;---------------------------------------------------------------------------------------------------
    139  2486
      0  2486					      DEF	aiDelayAfterMove2
      1  2486				   SLOT_aiDelayAfterMove2 SET	_BANK_SLOT
      2  2486				   BANK_aiDelayAfterMove2 SET	SLOT_aiDelayAfterMove2 + _CURRENT_BANK
      3  2486				   aiDelayAfterMove2
      4  2486				   TEMPORARY_VAR SET	Overlay
      5  2486				   TEMPORARY_OFFSET SET	0
      6  2486				   VAR_BOUNDARY_aiDelayAfterMove2 SET	TEMPORARY_OFFSET
      7  2486				   FUNCTION_NAME SET	aiDelayAfterMove2
    141  2486					      SUBROUTINE
    142  2486
      0  2486					      VEND	aiDelayAfterMove
      1  2486				  -	      IFNCONST	aiDelayAfterMove
      2  2486				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  2486				  -	      ERR
      4  2486					      ENDIF
      5  2486		       00 a2	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
    144  2486
    145  2486		       c6 8d		      dec	aiFlashDelay
    146  2488		       d0 04		      bne	.exit
      0  248a					      PHASE	AI_MoveIsSelected
      1  248a		       a9 14		      lda	#AI_MoveIsSelected
      2  248c		       85 8c		      sta	aiState
    148  248e		       60	   .exit      rts
    149  248f
    150  248f
    151  248f							;---------------------------------------------------------------------------------------------------
    152  248f
      0  248f					      DEF	aiDelayAfterPlaced
      1  248f				   SLOT_aiDelayAfterPlaced SET	_BANK_SLOT
      2  248f				   BANK_aiDelayAfterPlaced SET	SLOT_aiDelayAfterPlaced + _CURRENT_BANK
      3  248f				   aiDelayAfterPlaced
      4  248f				   TEMPORARY_VAR SET	Overlay
      5  248f				   TEMPORARY_OFFSET SET	0
      6  248f				   VAR_BOUNDARY_aiDelayAfterPlaced SET	TEMPORARY_OFFSET
      7  248f				   FUNCTION_NAME SET	aiDelayAfterPlaced
    154  248f					      SUBROUTINE
    155  248f
      0  248f					      VEND	aiDelayAfterPlaced
      1  248f				  -	      IFNCONST	aiDelayAfterPlaced
      2  248f				  -	      ECHO	"Incorrect VEND label", aiDelayAfterPlaced
      3  248f				  -	      ERR
      4  248f					      ENDIF
      5  248f		       00 a2	   VAREND_aiDelayAfterPlaced =	TEMPORARY_VAR
    157  248f
    158  248f		       a2 4b		      ldx	#75	; delay after human move
    159  2491		       a5 96		      lda	sideToMove
    160  2493		       30 02		      bmi	.computer
    161  2495		       a2 01		      ldx	#1	; delay after computer move
    162  2497		       86 8d	   .computer  stx	aiFlashDelay
    163  2499
      0  2499					      PHASE	AI_DelayAfterPlaced2
      1  2499		       a9 28		      lda	#AI_DelayAfterPlaced2
      2  249b		       85 8c		      sta	aiState
    165  249d		       60		      rts
    166  249e
    167  249e
    168  249e							;---------------------------------------------------------------------------------------------------
    169  249e
      0  249e					      DEF	aiDelayAfterPlaced2
      1  249e				   SLOT_aiDelayAfterPlaced2 SET	_BANK_SLOT
      2  249e				   BANK_aiDelayAfterPlaced2 SET	SLOT_aiDelayAfterPlaced2 + _CURRENT_BANK
      3  249e				   aiDelayAfterPlaced2
      4  249e				   TEMPORARY_VAR SET	Overlay
      5  249e				   TEMPORARY_OFFSET SET	0
      6  249e				   VAR_BOUNDARY_aiDelayAfterPlaced2 SET	TEMPORARY_OFFSET
      7  249e				   FUNCTION_NAME SET	aiDelayAfterPlaced2
    171  249e					      SUBROUTINE
    172  249e
    173  249e							;jsr debug
    174  249e
    175  249e		       c6 8d		      dec	aiFlashDelay
    176  24a0		       d0 04		      bne	.exit
      0  24a2					      PHASE	AI_GenerateMoves
      1  24a2		       a9 12		      lda	#AI_GenerateMoves
      2  24a4		       85 8c		      sta	aiState
    178  24a6		       60	   .exit      rts
    179  24a7
    180  24a7
    181  24a7							;---------------------------------------------------------------------------------------------------
    182  24a7
      0  24a7					      DEF	aiMarchToTargetB
      1  24a7				   SLOT_aiMarchToTargetB SET	_BANK_SLOT
      2  24a7				   BANK_aiMarchToTargetB SET	SLOT_aiMarchToTargetB + _CURRENT_BANK
      3  24a7				   aiMarchToTargetB
      4  24a7				   TEMPORARY_VAR SET	Overlay
      5  24a7				   TEMPORARY_OFFSET SET	0
      6  24a7				   VAR_BOUNDARY_aiMarchToTargetB SET	TEMPORARY_OFFSET
      7  24a7				   FUNCTION_NAME SET	aiMarchToTargetB
    184  24a7					      SUBROUTINE
    185  24a7
      0  24a7					      REFER	AiStateMachine
      1  24a7				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  24a7				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  24a7					      ENDIF
      0  24a7					      VEND	aiMarchToTargetB
      1  24a7				  -	      IFNCONST	aiMarchToTargetB
      2  24a7				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetB
      3  24a7				  -	      ERR
      4  24a7					      ENDIF
      5  24a7		       00 a2	   VAREND_aiMarchToTargetB =	TEMPORARY_VAR
    188  24a7
    189  24a7							; now we want to undraw the piece in the old square
    190  24a7
    191  24a7		       a5 83		      lda	lastSquareX12
    192  24a9		       85 80		      sta	squareToDraw
    193  24ab
    194  24ab		       20 83 f0 	      jsr	CopySinglePiece	;@0	      ; erase whatever was on the previous square (completely blank)
    195  24ae
    196  24ae		       a4 83		      ldy	lastSquareX12
    197  24b0		       a5 99		      lda	previousPiece
    198  24b2		       20 6a f6 	      jsr	PutBoard
    199  24b5
    200  24b5		       a5 98		      lda	lastPiece
    201  24b7		       85 99		      sta	previousPiece
    202  24b9
      0  24b9					      PHASE	AI_MarchB2
      1  24b9		       a9 1a		      lda	#AI_MarchB2
      2  24bb		       85 8c		      sta	aiState
    204  24bd		       60		      rts
    205  24be
    206  24be
    207  24be							;---------------------------------------------------------------------------------------------------
    208  24be
      0  24be					      DEF	aiPromotePawnStart
      1  24be				   SLOT_aiPromotePawnStart SET	_BANK_SLOT
      2  24be				   BANK_aiPromotePawnStart SET	SLOT_aiPromotePawnStart + _CURRENT_BANK
      3  24be				   aiPromotePawnStart
      4  24be				   TEMPORARY_VAR SET	Overlay
      5  24be				   TEMPORARY_OFFSET SET	0
      6  24be				   VAR_BOUNDARY_aiPromotePawnStart SET	TEMPORARY_OFFSET
      7  24be				   FUNCTION_NAME SET	aiPromotePawnStart
    210  24be					      SUBROUTINE
    211  24be
      0  24be					      REFER	AiStateMachine
      1  24be				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  24be				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  24be					      ENDIF
      0  24be					      VEND	aiPromotePawnStart
      1  24be				  -	      IFNCONST	aiPromotePawnStart
      2  24be				  -	      ECHO	"Incorrect VEND label", aiPromotePawnStart
      3  24be				  -	      ERR
      4  24be					      ENDIF
      5  24be		       00 a2	   VAREND_aiPromotePawnStart =	TEMPORARY_VAR
    214  24be
    215  24be
    216  24be		       ad 84 02 	      lda	INTIM
    217  24c1		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    218  24c3		       90 18		      bcc	.exit
    219  24c5
    220  24c5		       a9 00		      lda	#0
    221  24c7		       85 8f		      sta	aiFlashPhase
    222  24c9		       85 8d		      sta	aiFlashDelay
    223  24cb
    224  24cb		       a4 86		      ldy	toX12
    225  24cd		       84 80		      sty	squareToDraw
    226  24cf
    227  24cf		       20 76 f6 	      jsr	GetBoard
    228  24d2		       29 0f		      and	#PIECE_MASK
    229  24d4		       f0 03		      beq	.empty
    230  24d6
    231  24d6		       20 83 f0 	      jsr	CopySinglePiece	;@0	      ; remove any capturable piece for display purposes
    232  24d9
      0  24d9				   .empty     PHASE	AI_RollPromotionPiece
      1  24d9		       a9 20		      lda	#AI_RollPromotionPiece
      2  24db		       85 8c		      sta	aiState
    234  24dd		       60	   .exit      rts
    235  24de
    236  24de
    237  24de							;---------------------------------------------------------------------------------------------------
    238  24de
      0  24de					      DEF	aiGenerateMoves
      1  24de				   SLOT_aiGenerateMoves SET	_BANK_SLOT
      2  24de				   BANK_aiGenerateMoves SET	SLOT_aiGenerateMoves + _CURRENT_BANK
      3  24de				   aiGenerateMoves
      4  24de				   TEMPORARY_VAR SET	Overlay
      5  24de				   TEMPORARY_OFFSET SET	0
      6  24de				   VAR_BOUNDARY_aiGenerateMoves SET	TEMPORARY_OFFSET
      7  24de				   FUNCTION_NAME SET	aiGenerateMoves
    240  24de					      SUBROUTINE
    241  24de
      0  24de					      REFER	AiStateMachine
      1  24de				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  24de				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  24de					      ENDIF
      0  24de					      VEND	aiGenerateMoves
      1  24de				  -	      IFNCONST	aiGenerateMoves
      2  24de				  -	      ECHO	"Incorrect VEND label", aiGenerateMoves
      3  24de				  -	      ERR
      4  24de					      ENDIF
      5  24de		       00 a2	   VAREND_aiGenerateMoves =	TEMPORARY_VAR
    244  24de
    245  24de							; Player comes here at the start of making a move
    246  24de							; This generates a valid movelist by calling 'negaMax' (removing illegal moves)
    247  24de		       60		      rts		;tmp
    248  24df		       a5 86		      lda	toX12
    249  24e1		       85 80		      sta	squareToDraw	; for showing move (display square)
    250  24e3
    251  24e3		       a6 96		      ldx	sideToMove
    252  24e5		       10 05		      bpl	.player
    253  24e7
    254  24e7
      0  24e7				   .computer  PHASE	AI_ComputerMove	; computer select move
      1  24e7		       a9 13		      lda	#AI_ComputerMove
      2  24e9		       85 8c		      sta	aiState
    256  24eb		       60		      rts
    257  24ec
    258  24ec
      0  24ec				   .player    PHASE	AI_StartMoveGen
      1  24ec		       a9 0b		      lda	#AI_StartMoveGen
      2  24ee		       85 8c		      sta	aiState
    260  24f0		       60		      rts
    261  24f1
    262  24f1
    263  24f1							;---------------------------------------------------------------------------------------------------
    264  24f1
      0  24f1					      DEF	aiStepMoveGen
      1  24f1				   SLOT_aiStepMoveGen SET	_BANK_SLOT
      2  24f1				   BANK_aiStepMoveGen SET	SLOT_aiStepMoveGen + _CURRENT_BANK
      3  24f1				   aiStepMoveGen
      4  24f1				   TEMPORARY_VAR SET	Overlay
      5  24f1				   TEMPORARY_OFFSET SET	0
      6  24f1				   VAR_BOUNDARY_aiStepMoveGen SET	TEMPORARY_OFFSET
      7  24f1				   FUNCTION_NAME SET	aiStepMoveGen
    266  24f1					      SUBROUTINE
    267  24f1
      0  24f1					      REFER	AiStateMachine
      1  24f1				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  24f1				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  24f1					      ENDIF
      0  24f1					      VEND	aiStepMoveGen
      1  24f1				  -	      IFNCONST	aiStepMoveGen
      2  24f1				  -	      ECHO	"Incorrect VEND label", aiStepMoveGen
      3  24f1				  -	      ERR
      4  24f1					      ENDIF
      5  24f1		       00 a2	   VAREND_aiStepMoveGen =	TEMPORARY_VAR
    270  24f1
    271  24f1		       a5 87		      lda	originX12	; location of cursor (show move)
    272  24f3		       85 88		      sta	cursorX12
      0  24f5					      PHASE	AI_BeginSelectMovePhase
      1  24f5		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  24f7		       85 8c		      sta	aiState
    274  24f9		       60		      rts
    275  24fa
    276  24fa
    277  24fa							;---------------------------------------------------------------------------------------------------
    278  24fa
    279  2500		       00 00 00 00*	      align	256
      0  2500					      DEF	PositionSprites
      1  2500				   SLOT_PositionSprites SET	_BANK_SLOT
      2  2500				   BANK_PositionSprites SET	SLOT_PositionSprites + _CURRENT_BANK
      3  2500				   PositionSprites
      4  2500				   TEMPORARY_VAR SET	Overlay
      5  2500				   TEMPORARY_OFFSET SET	0
      6  2500				   VAR_BOUNDARY_PositionSprites SET	TEMPORARY_OFFSET
      7  2500				   FUNCTION_NAME SET	PositionSprites
    281  2500					      SUBROUTINE
    282  2500
      0  2500					      REFER	StartupBankReset
      1  2500				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  2500				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  2500					      ENDIF
      0  2500					      VEND	PositionSprites
      1  2500				  -	      IFNCONST	PositionSprites
      2  2500				  -	      ECHO	"Incorrect VEND label", PositionSprites
      3  2500				  -	      ERR
      4  2500					      ENDIF
      5  2500		       00 a2	   VAREND_PositionSprites =	TEMPORARY_VAR
    285  2500
    286  2500
    287  2500		       a5 88		      lda	cursorX12
    288  2502		       38		      sec
    289  2503		       e9 0a	   .sub10     sbc	#10
    290  2505		       b0 fc		      bcs	.sub10
    291  2507		       69 08		      adc	#8
    292  2509		       a8		      tay
    293  250a
    294  250a		       85 42		      sta	WSYNC	; 00	  Sync to start of scanline.
    295  250c
    296  250c		       b9 30 f5 	      lda	colToPixel,y
    297  250f
    298  250f		       38		      sec		; 02	  Set the carry flag so no borrow will be applied during the division.
    299  2510		       e9 0f	   .divideby15 sbc	#15	; 04	  Waste the necessary amount of time dividing X-pos by 15!
    300  2512		       b0 fc		      bcs	.divideby15	; 06/07  11/16/21/26/31/36/41/46/51/56/61/66
    301  2514
    302  2514		       a8		      tay
    303  2515		       b9 30 f4 	      lda	fineAdjustTable,y	; 13 -> Consume 5 cycles by guaranteeing we cross a page boundary
    304  2518		       85 60		      sta	HMP0
    305  251a		       85 50		      sta	RESP0	; 21/ 26/31/36/41/46/51/56/61/66/71 - Set the rough position.
    306  251c
    307  251c		       85 42		      sta	WSYNC
    308  251e		       85 6a		      sta	HMOVE
    309  2520
    310  2520		       60		      rts
    311  2521
    312  2521							; This table converts the "remainder" of the division by 15 (-1 to -15) to the correct
    313  2521							; fine adjustment value. This table is on a page boundary to guarantee the processor
    314  2521							; will cross a page boundary and waste a cycle in order to be at the precise position
    315  2521							; for a RESP0,x write
    316  2521
    317  2521				   fineAdjustBegin
    318  2521
    319  2521		       70		      DC.B	%01110000	; Left 7
    320  2522		       60		      DC.B	%01100000	; Left 6
    321  2523		       50		      DC.B	%01010000	; Left 5
    322  2524		       40		      DC.B	%01000000	; Left 4
    323  2525		       30		      DC.B	%00110000	; Left 3
    324  2526		       20		      DC.B	%00100000	; Left 2
    325  2527		       10		      DC.B	%00010000	; Left 1
    326  2528		       00		      DC.B	%00000000	; No movement.
    327  2529		       f0		      DC.B	%11110000	; Right 1
    328  252a		       e0		      DC.B	%11100000	; Right 2
    329  252b		       d0		      DC.B	%11010000	; Right 3
    330  252c		       c0		      DC.B	%11000000	; Right 4
    331  252d		       b0		      DC.B	%10110000	; Right 5
    332  252e		       a0		      DC.B	%10100000	; Right 6
    333  252f		       90		      DC.B	%10010000	; Right 7
    334  2530
    335  2530		       f4 30	   fineAdjustTable EQU	fineAdjustBegin - %11110001	; NOTE: %11110001 = -15
    336  2530
    337  2530
      0  2530					      ALLOCATE	colToPixel, 8
      0  2530					      OPTIONAL_PAGEBREAK	"Table", 8
     12  2530					      LIST	ON
      0  2530					      DEF	colToPixel
      1  2530				   SLOT_colToPixel SET	_BANK_SLOT
      2  2530				   BANK_colToPixel SET	SLOT_colToPixel + _CURRENT_BANK
      3  2530				   colToPixel
      4  2530				   TEMPORARY_VAR SET	Overlay
      5  2530				   TEMPORARY_OFFSET SET	0
      6  2530				   VAR_BOUNDARY_colToPixel SET	TEMPORARY_OFFSET
      7  2530				   FUNCTION_NAME SET	colToPixel
    339  2530		       00 14 28 3c*	      .byte.b	0,20,40,60,80,100,120,140
    340  2538
    341  2538							;---------------------------------------------------------------------------------------------------
    342  2538
    343  2538
      0  2538					      CHECK_BANK_SIZE	"BANK_StateMachine2"
      1  2538		       01 38	   .TEMP      =	* - _BANK_START
 BANK_StateMachine2 (1K) SIZE =  $138 , FREE= $2c8
      2  2538					      ECHO	"BANK_StateMachine2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2538				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2538				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_StateMachine2", " size=", * - ORIGIN
      5  2538				  -	      ERR
      6  2538					      ENDIF
    345  2538
    346  2538
    347  2538							;---------------------------------------------------------------------------------------------------
    348  2538
    349  2538							; EOF
------- FILE ./chess.asm
------- FILE BANK_RECON.asm LEVEL 2 PASS 4
      0  2538					      include	"BANK_RECON.asm"
      0  2538					      SLOT	1
      1  2538				  -	      IF	(1 < 0) || (1 > 3)
      2  2538				  -	      ECHO	"Illegal bank address/segment location", 1
      3  2538				  -	      ERR
      4  2538					      ENDIF
      5  2538				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  2538				   _BANK_SLOT SET	1 * 64
      0  2538					      NEWBANK	RECON
      1  285d ????				      SEG	RECON
      2  2800					      ORG	_ORIGIN
      3  2800					      RORG	_BANK_ADDRESS_ORIGIN
      4  2800				   _BANK_START SET	*
      5  2800				   RECON_START SET	*
      6  2800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2800				   RECON      SET	_BANK_SLOT + _CURRENT_BANK
      8  2800				   _ORIGIN    SET	_ORIGIN + 1024
      3  2800
      4  2800							;---------------------------------------------------------------------------------------------------
      5  2800
      0  2800					      DEF	SAFE_showMoveCaptures
      1  2800				   SLOT_SAFE_showMoveCaptures SET	_BANK_SLOT
      2  2800				   BANK_SAFE_showMoveCaptures SET	SLOT_SAFE_showMoveCaptures + _CURRENT_BANK
      3  2800				   SAFE_showMoveCaptures
      4  2800				   TEMPORARY_VAR SET	Overlay
      5  2800				   TEMPORARY_OFFSET SET	0
      6  2800				   VAR_BOUNDARY_SAFE_showMoveCaptures SET	TEMPORARY_OFFSET
      7  2800				   FUNCTION_NAME SET	SAFE_showMoveCaptures
      7  2800					      SUBROUTINE
      8  2800
      0  2800					      VEND	SAFE_showMoveCaptures
      1  2800				  -	      IFNCONST	SAFE_showMoveCaptures
      2  2800				  -	      ECHO	"Incorrect VEND label", SAFE_showMoveCaptures
      3  2800				  -	      ERR
      4  2800					      ENDIF
      5  2800		       00 a2	   VAREND_SAFE_showMoveCaptures =	TEMPORARY_VAR
     10  2800
     11  2800		       20 08 f4 	      jsr	UNSAFE_showMoveCaptures
     12  2803		       a5 8b		      lda	savedBank
     13  2805		       85 3f		      sta	SET_BANK
     14  2807		       60		      rts
     15  2808
     16  2808
     17  2808							;---------------------------------------------------------------------------------------------------
     18  2808
      0  2808					      DEF	UNSAFE_showMoveCaptures
      1  2808				   SLOT_UNSAFE_showMoveCaptures SET	_BANK_SLOT
      2  2808				   BANK_UNSAFE_showMoveCaptures SET	SLOT_UNSAFE_showMoveCaptures + _CURRENT_BANK
      3  2808				   UNSAFE_showMoveCaptures
      4  2808				   TEMPORARY_VAR SET	Overlay
      5  2808				   TEMPORARY_OFFSET SET	0
      6  2808				   VAR_BOUNDARY_UNSAFE_showMoveCaptures SET	TEMPORARY_OFFSET
      7  2808				   FUNCTION_NAME SET	UNSAFE_showMoveCaptures
     20  2808					      SUBROUTINE
     21  2808
      0  2808					      REFER	SAFE_showMoveCaptures
      1  2808				  -	      IF	VAREND_SAFE_showMoveCaptures > TEMPORARY_VAR
      2  2808				  -TEMPORARY_VAR SET	VAREND_SAFE_showMoveCaptures
      3  2808					      ENDIF
      0  2808					      VAR	__toSquareX12, 1
      1  2808		       00 a2	   __toSquareX12 =	TEMPORARY_VAR
      2  2808				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  2808
      4  2808				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  2808				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  2808				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  2808					      ENDIF
      8  2808				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  2808				  -	      ECHO	"Temporary Variable", __toSquareX12, "overflow!"
     10  2808				  -	      ERR
     11  2808					      ENDIF
     12  2808					      LIST	ON
      0  2808					      VAR	__fromPiece, 1
      1  2808		       00 a3	   __fromPiece =	TEMPORARY_VAR
      2  2808				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  2808
      4  2808				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  2808				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  2808				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  2808					      ENDIF
      8  2808				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  2808				  -	      ECHO	"Temporary Variable", __fromPiece, "overflow!"
     10  2808				  -	      ERR
     11  2808					      ENDIF
     12  2808					      LIST	ON
      0  2808					      VAR	__aiMoveIndex, 1
      1  2808		       00 a4	   __aiMoveIndex =	TEMPORARY_VAR
      2  2808				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  2808
      4  2808				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  2808				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  2808				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  2808					      ENDIF
      8  2808				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  2808				  -	      ECHO	"Temporary Variable", __aiMoveIndex, "overflow!"
     10  2808				  -	      ERR
     11  2808					      ENDIF
     12  2808					      LIST	ON
      0  2808					      VEND	UNSAFE_showMoveCaptures
      1  2808				  -	      IFNCONST	UNSAFE_showMoveCaptures
      2  2808				  -	      ECHO	"Incorrect VEND label", UNSAFE_showMoveCaptures
      3  2808				  -	      ERR
      4  2808					      ENDIF
      5  2808		       00 a5	   VAREND_UNSAFE_showMoveCaptures =	TEMPORARY_VAR
     27  2808
     28  2808							; place a marker on the board for any square matching the piece
     29  2808							; EXCEPT for squares which are occupied (we'll flash those later)
     30  2808							; x = movelist item # being checked
     31  2808
     32  2808		       a5 8b		      lda	savedBank
     33  280a		       48		      pha
     34  280b
     35  280b		       a9 4a		      lda	#BANK_UNSAFE_showMoveCaptures
     36  280d		       85 8b		      sta	savedBank
     37  280f
     38  280f
     39  280f		       a6 8e	   .next      ldx	aiMoveIndex
     40  2811		       86 a4		      stx	__aiMoveIndex
     41  2813		       30 3a		      bmi	.skip	; no moves in list
     42  2815
     43  2815		       ad 84 02 	      lda	INTIM
     44  2818		       c9 14		      cmp	#20
     45  281a		       90 33		      bcc	.skip
     46  281c
     47  281c		       c6 8e		      dec	aiMoveIndex
     48  281e
     49  281e		       20 b0 f5 	      jsr	GetP_MoveFrom
     50  2821		       c5 85		      cmp	fromX12
     51  2823		       d0 ea		      bne	.next
     52  2825
     53  2825
     54  2825		       20 bc f5 	      jsr	GetP_MoveTo
     55  2828		       85 a2		      sta	__toSquareX12
     56  282a		       a8		      tay
     57  282b		       20 76 f6 	      jsr	GetBoard
     58  282e		       29 0f		      and	#PIECE_MASK
     59  2830		       f0 dd		      beq	.next
     60  2832
     61  2832							; There's something on the board at destination, so it's a capture
     62  2832							; Let's see if we are doing a pawn promote...
     63  2832
     64  2832		       a4 85		      ldy	fromX12
     65  2834		       20 76 f6 	      jsr	GetBoard
     66  2837		       85 a3		      sta	__fromPiece
     67  2839
     68  2839		       20 d4 f5 	      jsr	GetP_MovePiece
     69  283c		       45 a3		      eor	__fromPiece
     70  283e		       29 0f		      and	#PIECE_MASK
     71  2840		       f0 06		      beq	.legit	; from == to, so not a promote
     72  2842
     73  2842							; Have detected a promotion duplicate - skip all 3 of them
     74  2842
     75  2842		       c6 8e		      dec	aiMoveIndex	; skip "KBRQ" promotes
     76  2844		       c6 8e		      dec	aiMoveIndex
     77  2846		       c6 8e		      dec	aiMoveIndex
     78  2848
     79  2848				   .legit
     80  2848
     81  2848							;TIMECHECK COPYSINGLEPIECE, restoreIndex     ; not enough time to draw
     82  2848
     83  2848		       a5 a2		      lda	__toSquareX12
     84  284a		       85 80		      sta	squareToDraw
     85  284c
     86  284c		       20 83 f0 	      jsr	CopySinglePiece	;@0
     87  284f
     88  284f		       68	   .skip      pla
     89  2850		       85 8b		      sta	savedBank
     90  2852		       60		      rts
     91  2853
     92  2853
     93  2853							;---------------------------------------------------------------------------------------------------
     94  2853
      0  2853					      DEF	showPromoteOptions
      1  2853				   SLOT_showPromoteOptions SET	_BANK_SLOT
      2  2853				   BANK_showPromoteOptions SET	SLOT_showPromoteOptions + _CURRENT_BANK
      3  2853				   showPromoteOptions
      4  2853				   TEMPORARY_VAR SET	Overlay
      5  2853				   TEMPORARY_OFFSET SET	0
      6  2853				   VAR_BOUNDARY_showPromoteOptions SET	TEMPORARY_OFFSET
      7  2853				   FUNCTION_NAME SET	showPromoteOptions
     96  2853					      SUBROUTINE
     97  2853
      0  2853					      REFER	aiRollPromotionPiece
      1  2853				  -	      IF	VAREND_aiRollPromotionPiece > TEMPORARY_VAR
      2  2853				  -TEMPORARY_VAR SET	VAREND_aiRollPromotionPiece
      3  2853					      ENDIF
      0  2853					      REFER	aiChoosePromotePiece
      1  2853				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  2853				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  2853					      ENDIF
      0  2853					      VEND	showPromoteOptions
      1  2853				  -	      IFNCONST	showPromoteOptions
      2  2853				  -	      ECHO	"Incorrect VEND label", showPromoteOptions
      3  2853				  -	      ERR
      4  2853					      ENDIF
      5  2853		       00 a2	   VAREND_showPromoteOptions =	TEMPORARY_VAR
    101  2853
    102  2853							; X = character shape # (?/N/B/R/Q)
    103  2853
    104  2853		       a4 86		      ldy	toX12
    105  2855		       84 80		      sty	squareToDraw
    106  2857
    107  2857		       20 da f4 	      jsr	CopySetupForMarker
    108  285a		       4c 8a f0 	      jmp	InterceptMarkerCopy
    109  285d
    110  285d
    111  285d
    112  285d							;---------------------------------------------------------------------------------------------------
    113  285d
    114  285d
      0  285d					      CHECK_BANK_SIZE	"BANK_RECON"
      1  285d		       00 5d	   .TEMP      =	* - _BANK_START
 BANK_RECON (1K) SIZE =  $5d , FREE= $3a3
      2  285d					      ECHO	"BANK_RECON", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  285d				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  285d				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_RECON", " size=", * - ORIGIN
      5  285d				  -	      ERR
      6  285d					      ENDIF
    116  285d
    117  285d							; EOF
------- FILE ./chess.asm
------- FILE piece_graphics.asm LEVEL 2 PASS 4
      0  285d					      include	"piece_graphics.asm"
      1  285d							; Import the graphics definitions generated by ConvertChessPieces.py
      2  285d
      0  285d					      SLOT	2
      1  285d				  -	      IF	(2 < 0) || (2 > 3)
      2  285d				  -	      ECHO	"Illegal bank address/segment location", 2
      3  285d				  -	      ERR
      4  285d					      ENDIF
      5  285d				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  285d				   _BANK_SLOT SET	2 * 64
      0  285d					      NEWBANK	PIECES_0
      1  2fd8 ????				      SEG	PIECES_0
      2  2c00					      ORG	_ORIGIN
      3  2c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  2c00				   _BANK_START SET	*
      5  2c00				   PIECES_0_START SET	*
      6  2c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2c00				   PIECES_0   SET	_BANK_SLOT + _CURRENT_BANK
      8  2c00				   _ORIGIN    SET	_ORIGIN + 1024
      5  2c00
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2c00					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm"
      0  2c00					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_0", 72
     12  2c00					      LIST	ON
      0  2c00					      DEF	WHITE_BLANK_on_WHITE_SQUARE_0
      1  2c00				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2c00				   BANK_WHITE_BLANK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2c00				   WHITE_BLANK_on_WHITE_SQUARE_0
      4  2c00				   TEMPORARY_VAR SET	Overlay
      5  2c00				   TEMPORARY_OFFSET SET	0
      6  2c00				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2c00				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_0
      3  2c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  2c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  2c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2c48					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm"
      0  2c48					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_1", 72
     12  2c48					      LIST	ON
      0  2c48					      DEF	WHITE_BLANK_on_WHITE_SQUARE_1
      1  2c48				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2c48				   BANK_WHITE_BLANK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2c48				   WHITE_BLANK_on_WHITE_SQUARE_1
      4  2c48				   TEMPORARY_VAR SET	Overlay
      5  2c48				   TEMPORARY_OFFSET SET	0
      6  2c48				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2c48				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_1
      3  2c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  2c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2c90					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm"
      0  2c90					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_2", 72
     12  2c90					      LIST	ON
      0  2c90					      DEF	WHITE_BLANK_on_WHITE_SQUARE_2
      1  2c90				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2c90				   BANK_WHITE_BLANK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2c90				   WHITE_BLANK_on_WHITE_SQUARE_2
      4  2c90				   TEMPORARY_VAR SET	Overlay
      5  2c90				   TEMPORARY_OFFSET SET	0
      6  2c90				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2c90				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_2
      3  2c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  2cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2cd8					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm"
      0  2cd8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_3", 72
     12  2d00					      LIST	ON
      0  2d00					      DEF	WHITE_BLANK_on_WHITE_SQUARE_3
      1  2d00				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2d00				   BANK_WHITE_BLANK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2d00				   WHITE_BLANK_on_WHITE_SQUARE_3
      4  2d00				   TEMPORARY_VAR SET	Overlay
      5  2d00				   TEMPORARY_OFFSET SET	0
      6  2d00				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2d00				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_3
      3  2d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2d48					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm"
      0  2d48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_0", 72
     12  2d48					      LIST	ON
      0  2d48					      DEF	WHITE_PAWN_on_WHITE_SQUARE_0
      1  2d48				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2d48				   BANK_WHITE_PAWN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2d48				   WHITE_PAWN_on_WHITE_SQUARE_0
      4  2d48				   TEMPORARY_VAR SET	Overlay
      5  2d48				   TEMPORARY_OFFSET SET	0
      6  2d48				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2d48				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_0
      3  2d48		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  2d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  2d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2d90					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm"
      0  2d90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_1", 72
     12  2d90					      LIST	ON
      0  2d90					      DEF	WHITE_PAWN_on_WHITE_SQUARE_1
      1  2d90				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2d90				   BANK_WHITE_PAWN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2d90				   WHITE_PAWN_on_WHITE_SQUARE_1
      4  2d90				   TEMPORARY_VAR SET	Overlay
      5  2d90				   TEMPORARY_OFFSET SET	0
      6  2d90				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2d90				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_1
      3  2d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2da8		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  2dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2dd8					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm"
      0  2dd8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_2", 72
     12  2e00					      LIST	ON
      0  2e00					      DEF	WHITE_PAWN_on_WHITE_SQUARE_2
      1  2e00				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2e00				   BANK_WHITE_PAWN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2e00				   WHITE_PAWN_on_WHITE_SQUARE_2
      4  2e00				   TEMPORARY_VAR SET	Overlay
      5  2e00				   TEMPORARY_OFFSET SET	0
      6  2e00				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2e00				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_2
      3  2e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e18		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  2e30		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2e48					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm"
      0  2e48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_3", 72
     12  2e48					      LIST	ON
      0  2e48					      DEF	WHITE_PAWN_on_WHITE_SQUARE_3
      1  2e48				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2e48				   BANK_WHITE_PAWN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2e48				   WHITE_PAWN_on_WHITE_SQUARE_3
      4  2e48				   TEMPORARY_VAR SET	Overlay
      5  2e48				   TEMPORARY_OFFSET SET	0
      6  2e48				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2e48				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_3
      3  2e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e78		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2e90					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  2e90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_0", 72
     12  2e90					      LIST	ON
      0  2e90					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_0
      1  2e90				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2e90				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2e90				   WHITE_KNIGHT_on_WHITE_SQUARE_0
      4  2e90				   TEMPORARY_VAR SET	Overlay
      5  2e90				   TEMPORARY_OFFSET SET	0
      6  2e90				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2e90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_0
      3  2e90		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  2ea8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  2ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2ed8					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  2ed8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_1", 72
     12  2f00					      LIST	ON
      0  2f00					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_1
      1  2f00				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2f00				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2f00				   WHITE_KNIGHT_on_WHITE_SQUARE_1
      4  2f00				   TEMPORARY_VAR SET	Overlay
      5  2f00				   TEMPORARY_OFFSET SET	0
      6  2f00				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2f00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_1
      3  2f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f18		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  2f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2f48					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  2f48					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_2", 72
     12  2f48					      LIST	ON
      0  2f48					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_2
      1  2f48				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2f48				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2f48				   WHITE_KNIGHT_on_WHITE_SQUARE_2
      4  2f48				   TEMPORARY_VAR SET	Overlay
      5  2f48				   TEMPORARY_OFFSET SET	0
      6  2f48				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2f48				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_2
      3  2f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f60		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  2f78		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2f90					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  2f90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_3", 72
     12  2f90					      LIST	ON
      0  2f90					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_3
      1  2f90				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2f90				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2f90				   WHITE_KNIGHT_on_WHITE_SQUARE_3
      4  2f90				   TEMPORARY_VAR SET	Overlay
      5  2f90				   TEMPORARY_OFFSET SET	0
      6  2f90				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2f90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_3
      3  2f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2fc0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
      0  2fd8					      CHECK_BANK_SIZE	"PIECE_0 (1K)"
      1  2fd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_0 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  2fd8					      ECHO	"PIECE_0 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2fd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_0 (1K)", " size=", * - ORIGIN
      5  2fd8				  -	      ERR
      6  2fd8					      ENDIF
     19  2fd8
      0  2fd8					      SLOT	2
      1  2fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  2fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  2fd8				  -	      ERR
      4  2fd8					      ENDIF
      5  2fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  2fd8				   _BANK_SLOT SET	2 * 64
      0  2fd8					      NEWBANK	PIECES_1
      1  33d8 ????				      SEG	PIECES_1
      2  3000					      ORG	_ORIGIN
      3  3000					      RORG	_BANK_ADDRESS_ORIGIN
      4  3000				   _BANK_START SET	*
      5  3000				   PIECES_1_START SET	*
      6  3000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3000				   PIECES_1   SET	_BANK_SLOT + _CURRENT_BANK
      8  3000				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3000					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm"
      0  3000					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_0", 72
     12  3000					      LIST	ON
      0  3000					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_0
      1  3000				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3000				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3000				   WHITE_BISHOP_on_WHITE_SQUARE_0
      4  3000				   TEMPORARY_VAR SET	Overlay
      5  3000				   TEMPORARY_OFFSET SET	0
      6  3000				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3000				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_0
      3  3000		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  3018		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  3030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3048					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm"
      0  3048					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_1", 72
     12  3048					      LIST	ON
      0  3048					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_1
      1  3048				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3048				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3048				   WHITE_BISHOP_on_WHITE_SQUARE_1
      4  3048				   TEMPORARY_VAR SET	Overlay
      5  3048				   TEMPORARY_OFFSET SET	0
      6  3048				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3048				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_1
      3  3048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3060		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  3078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3090					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm"
      0  3090					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_2", 72
     12  3090					      LIST	ON
      0  3090					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_2
      1  3090				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3090				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3090				   WHITE_BISHOP_on_WHITE_SQUARE_2
      4  3090				   TEMPORARY_VAR SET	Overlay
      5  3090				   TEMPORARY_OFFSET SET	0
      6  3090				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3090				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_2
      3  3090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  30a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  30c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  30d8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm"
      0  30d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_3", 72
     12  3100					      LIST	ON
      0  3100					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_3
      1  3100				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3100				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3100				   WHITE_BISHOP_on_WHITE_SQUARE_3
      4  3100				   TEMPORARY_VAR SET	Overlay
      5  3100				   TEMPORARY_OFFSET SET	0
      6  3100				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3100				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_3
      3  3100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3130		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3148					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm"
      0  3148					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_0", 72
     12  3148					      LIST	ON
      0  3148					      DEF	WHITE_ROOK_on_WHITE_SQUARE_0
      1  3148				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3148				   BANK_WHITE_ROOK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3148				   WHITE_ROOK_on_WHITE_SQUARE_0
      4  3148				   TEMPORARY_VAR SET	Overlay
      5  3148				   TEMPORARY_OFFSET SET	0
      6  3148				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3148				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_0
      3  3148		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  3160		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  3178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3190					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm"
      0  3190					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_1", 72
     12  3190					      LIST	ON
      0  3190					      DEF	WHITE_ROOK_on_WHITE_SQUARE_1
      1  3190				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3190				   BANK_WHITE_ROOK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3190				   WHITE_ROOK_on_WHITE_SQUARE_1
      4  3190				   TEMPORARY_VAR SET	Overlay
      5  3190				   TEMPORARY_OFFSET SET	0
      6  3190				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3190				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_1
      3  3190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  31a8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  31c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  31d8					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm"
      0  31d8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_2", 72
     12  3200					      LIST	ON
      0  3200					      DEF	WHITE_ROOK_on_WHITE_SQUARE_2
      1  3200				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3200				   BANK_WHITE_ROOK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3200				   WHITE_ROOK_on_WHITE_SQUARE_2
      4  3200				   TEMPORARY_VAR SET	Overlay
      5  3200				   TEMPORARY_OFFSET SET	0
      6  3200				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3200				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_2
      3  3200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3218		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  3230		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3248					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm"
      0  3248					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_3", 72
     12  3248					      LIST	ON
      0  3248					      DEF	WHITE_ROOK_on_WHITE_SQUARE_3
      1  3248				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3248				   BANK_WHITE_ROOK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3248				   WHITE_ROOK_on_WHITE_SQUARE_3
      4  3248				   TEMPORARY_VAR SET	Overlay
      5  3248				   TEMPORARY_OFFSET SET	0
      6  3248				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3248				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_3
      3  3248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3278		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3290					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm"
      0  3290					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_0", 72
     12  3290					      LIST	ON
      0  3290					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_0
      1  3290				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3290				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3290				   WHITE_QUEEN_on_WHITE_SQUARE_0
      4  3290				   TEMPORARY_VAR SET	Overlay
      5  3290				   TEMPORARY_OFFSET SET	0
      6  3290				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3290				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_0
      3  3290		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  32a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  32c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  32d8					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm"
      0  32d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_1", 72
     12  3300					      LIST	ON
      0  3300					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_1
      1  3300				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3300				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3300				   WHITE_QUEEN_on_WHITE_SQUARE_1
      4  3300				   TEMPORARY_VAR SET	Overlay
      5  3300				   TEMPORARY_OFFSET SET	0
      6  3300				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3300				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_1
      3  3300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3318		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  3330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3348					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm"
      0  3348					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_2", 72
     12  3348					      LIST	ON
      0  3348					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_2
      1  3348				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3348				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3348				   WHITE_QUEEN_on_WHITE_SQUARE_2
      4  3348				   TEMPORARY_VAR SET	Overlay
      5  3348				   TEMPORARY_OFFSET SET	0
      6  3348				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3348				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_2
      3  3348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3360		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  3378		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3390					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm"
      0  3390					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_3", 72
     12  3390					      LIST	ON
      0  3390					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_3
      1  3390				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3390				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3390				   WHITE_QUEEN_on_WHITE_SQUARE_3
      4  3390				   TEMPORARY_VAR SET	Overlay
      5  3390				   TEMPORARY_OFFSET SET	0
      6  3390				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3390				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_3
      3  3390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  33a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  33c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
      0  33d8					      CHECK_BANK_SIZE	"PIECE_1 (1K)"
      1  33d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_1 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  33d8					      ECHO	"PIECE_1 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  33d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  33d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_1 (1K)", " size=", * - ORIGIN
      5  33d8				  -	      ERR
      6  33d8					      ENDIF
      0  33d8					      SLOT	2
      1  33d8				  -	      IF	(2 < 0) || (2 > 3)
      2  33d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  33d8				  -	      ERR
      4  33d8					      ENDIF
      5  33d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  33d8				   _BANK_SLOT SET	2 * 64
      0  33d8					      NEWBANK	PIECES_2
      1  37d8 ????				      SEG	PIECES_2
      2  3400					      ORG	_ORIGIN
      3  3400					      RORG	_BANK_ADDRESS_ORIGIN
      4  3400				   _BANK_START SET	*
      5  3400				   PIECES_2_START SET	*
      6  3400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3400				   PIECES_2   SET	_BANK_SLOT + _CURRENT_BANK
      8  3400				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3400					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_0.asm"
      0  3400					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_0", 72
     12  3400					      LIST	ON
      0  3400					      DEF	WHITE_KING_on_WHITE_SQUARE_0
      1  3400				   SLOT_WHITE_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3400				   BANK_WHITE_KING_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3400				   WHITE_KING_on_WHITE_SQUARE_0
      4  3400				   TEMPORARY_VAR SET	Overlay
      5  3400				   TEMPORARY_OFFSET SET	0
      6  3400				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3400				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_0
      3  3400		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$f0,$f0,$f0,$f0,$f0,$b0,$f0,$f0	;PF0
      4  3418		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  3430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3448					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_1.asm"
      0  3448					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_1", 72
     12  3448					      LIST	ON
      0  3448					      DEF	WHITE_KING_on_WHITE_SQUARE_1
      1  3448				   SLOT_WHITE_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3448				   BANK_WHITE_KING_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3448				   WHITE_KING_on_WHITE_SQUARE_1
      4  3448				   TEMPORARY_VAR SET	Overlay
      5  3448				   TEMPORARY_OFFSET SET	0
      6  3448				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3448				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_1
      3  3448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3460		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$7c,$7c,$7c,$7c,$7c,$6c,$7c,$7c	;PF1
      5  3478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3490					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_2.asm"
      0  3490					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_2", 72
     12  3490					      LIST	ON
      0  3490					      DEF	WHITE_KING_on_WHITE_SQUARE_2
      1  3490				   SLOT_WHITE_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3490				   BANK_WHITE_KING_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3490				   WHITE_KING_on_WHITE_SQUARE_2
      4  3490				   TEMPORARY_VAR SET	Overlay
      5  3490				   TEMPORARY_OFFSET SET	0
      6  3490				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3490				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_2
      3  3490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  34a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  34c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$07,$07,$07,$07,$07,$06,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  34d8					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_3.asm"
      0  34d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_3", 72
     12  3500					      LIST	ON
      0  3500					      DEF	WHITE_KING_on_WHITE_SQUARE_3
      1  3500				   SLOT_WHITE_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3500				   BANK_WHITE_KING_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3500				   WHITE_KING_on_WHITE_SQUARE_3
      4  3500				   TEMPORARY_VAR SET	Overlay
      5  3500				   TEMPORARY_OFFSET SET	0
      6  3500				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3500				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_3
      3  3500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3530		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$f8,$f8,$f8,$f8,$f8,$d8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3548					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm"
      0  3548					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_0", 72
     12  3548					      LIST	ON
      0  3548					      DEF	WHITE_BLANK_on_BLACK_SQUARE_0
      1  3548				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3548				   BANK_WHITE_BLANK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3548				   WHITE_BLANK_on_BLACK_SQUARE_0
      4  3548				   TEMPORARY_VAR SET	Overlay
      5  3548				   TEMPORARY_OFFSET SET	0
      6  3548				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3548				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_0
      3  3548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3590					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm"
      0  3590					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_1", 72
     12  3590					      LIST	ON
      0  3590					      DEF	WHITE_BLANK_on_BLACK_SQUARE_1
      1  3590				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3590				   BANK_WHITE_BLANK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3590				   WHITE_BLANK_on_BLACK_SQUARE_1
      4  3590				   TEMPORARY_VAR SET	Overlay
      5  3590				   TEMPORARY_OFFSET SET	0
      6  3590				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3590				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_1
      3  3590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  35a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  35c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  35d8					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm"
      0  35d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_2", 72
     12  3600					      LIST	ON
      0  3600					      DEF	WHITE_BLANK_on_BLACK_SQUARE_2
      1  3600				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3600				   BANK_WHITE_BLANK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3600				   WHITE_BLANK_on_BLACK_SQUARE_2
      4  3600				   TEMPORARY_VAR SET	Overlay
      5  3600				   TEMPORARY_OFFSET SET	0
      6  3600				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3600				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_2
      3  3600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3630		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3648					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm"
      0  3648					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_3", 72
     12  3648					      LIST	ON
      0  3648					      DEF	WHITE_BLANK_on_BLACK_SQUARE_3
      1  3648				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3648				   BANK_WHITE_BLANK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3648				   WHITE_BLANK_on_BLACK_SQUARE_3
      4  3648				   TEMPORARY_VAR SET	Overlay
      5  3648				   TEMPORARY_OFFSET SET	0
      6  3648				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3648				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_3
      3  3648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3678		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3690					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm"
      0  3690					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_0", 72
     12  3690					      LIST	ON
      0  3690					      DEF	WHITE_PAWN_on_BLACK_SQUARE_0
      1  3690				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3690				   BANK_WHITE_PAWN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3690				   WHITE_PAWN_on_BLACK_SQUARE_0
      4  3690				   TEMPORARY_VAR SET	Overlay
      5  3690				   TEMPORARY_OFFSET SET	0
      6  3690				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3690				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_0
      3  3690		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  36a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  36c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  36d8					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm"
      0  36d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_1", 72
     12  3700					      LIST	ON
      0  3700					      DEF	WHITE_PAWN_on_BLACK_SQUARE_1
      1  3700				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3700				   BANK_WHITE_PAWN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3700				   WHITE_PAWN_on_BLACK_SQUARE_1
      4  3700				   TEMPORARY_VAR SET	Overlay
      5  3700				   TEMPORARY_OFFSET SET	0
      6  3700				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3700				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_1
      3  3700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3718		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  3730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3748					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm"
      0  3748					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_2", 72
     12  3748					      LIST	ON
      0  3748					      DEF	WHITE_PAWN_on_BLACK_SQUARE_2
      1  3748				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3748				   BANK_WHITE_PAWN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3748				   WHITE_PAWN_on_BLACK_SQUARE_2
      4  3748				   TEMPORARY_VAR SET	Overlay
      5  3748				   TEMPORARY_OFFSET SET	0
      6  3748				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3748				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_2
      3  3748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3760		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  3778		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3790					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm"
      0  3790					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_3", 72
     12  3790					      LIST	ON
      0  3790					      DEF	WHITE_PAWN_on_BLACK_SQUARE_3
      1  3790				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3790				   BANK_WHITE_PAWN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3790				   WHITE_PAWN_on_BLACK_SQUARE_3
      4  3790				   TEMPORARY_VAR SET	Overlay
      5  3790				   TEMPORARY_OFFSET SET	0
      6  3790				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3790				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_3
      3  3790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  37a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  37c0		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
      0  37d8					      CHECK_BANK_SIZE	"PIECE_2 (1K)"
      1  37d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_2 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  37d8					      ECHO	"PIECE_2 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  37d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  37d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_2 (1K)", " size=", * - ORIGIN
      5  37d8				  -	      ERR
      6  37d8					      ENDIF
      0  37d8					      SLOT	2
      1  37d8				  -	      IF	(2 < 0) || (2 > 3)
      2  37d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  37d8				  -	      ERR
      4  37d8					      ENDIF
      5  37d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  37d8				   _BANK_SLOT SET	2 * 64
      0  37d8					      NEWBANK	PIECES_3
      1  3bd8 ????				      SEG	PIECES_3
      2  3800					      ORG	_ORIGIN
      3  3800					      RORG	_BANK_ADDRESS_ORIGIN
      4  3800				   _BANK_START SET	*
      5  3800				   PIECES_3_START SET	*
      6  3800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3800				   PIECES_3   SET	_BANK_SLOT + _CURRENT_BANK
      8  3800				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3800					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  3800					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_0", 72
     12  3800					      LIST	ON
      0  3800					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_0
      1  3800				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3800				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3800				   WHITE_KNIGHT_on_BLACK_SQUARE_0
      4  3800				   TEMPORARY_VAR SET	Overlay
      5  3800				   TEMPORARY_OFFSET SET	0
      6  3800				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3800				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_0
      3  3800		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$f0,$e0,$e0,$f0,$f0,$40,$00	;PF0
      4  3818		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  3830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3848					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  3848					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_1", 72
     12  3848					      LIST	ON
      0  3848					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_1
      1  3848				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3848				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3848				   WHITE_KNIGHT_on_BLACK_SQUARE_1
      4  3848				   TEMPORARY_VAR SET	Overlay
      5  3848				   TEMPORARY_OFFSET SET	0
      6  3848				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3848				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_1
      3  3848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3860		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$78,$38,$3c,$7c,$7c,$14,$00	;PF1
      5  3878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3890					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  3890					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_2", 72
     12  3890					      LIST	ON
      0  3890					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_2
      1  3890				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3890				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3890				   WHITE_KNIGHT_on_BLACK_SQUARE_2
      4  3890				   TEMPORARY_VAR SET	Overlay
      5  3890				   TEMPORARY_OFFSET SET	0
      6  3890				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3890				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_2
      3  3890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  38a8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$01,$03,$03,$00,$00	;PF1
      5  38c0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$03,$03,$07,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  38d8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  38d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_3", 72
     12  3900					      LIST	ON
      0  3900					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_3
      1  3900				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3900				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3900				   WHITE_KNIGHT_on_BLACK_SQUARE_3
      4  3900				   TEMPORARY_VAR SET	Overlay
      5  3900				   TEMPORARY_OFFSET SET	0
      6  3900				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3900				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_3
      3  3900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3930		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$78,$70,$f0,$f8,$f8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3948					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm"
      0  3948					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_0", 72
     12  3948					      LIST	ON
      0  3948					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_0
      1  3948				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3948				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3948				   WHITE_BISHOP_on_BLACK_SQUARE_0
      4  3948				   TEMPORARY_VAR SET	Overlay
      5  3948				   TEMPORARY_OFFSET SET	0
      6  3948				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3948				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_0
      3  3948		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$b0,$d0,$e0,$40,$40	;PF0
      4  3960		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  3978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3990					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm"
      0  3990					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_1", 72
     12  3990					      LIST	ON
      0  3990					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_1
      1  3990				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3990				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3990				   WHITE_BISHOP_on_BLACK_SQUARE_1
      4  3990				   TEMPORARY_VAR SET	Overlay
      5  3990				   TEMPORARY_OFFSET SET	0
      6  3990				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3990				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_1
      3  3990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  39a8		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$6c,$5c,$38,$10,$10	;PF1
      5  39c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  39d8					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm"
      0  39d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_2", 72
     12  3a00					      LIST	ON
      0  3a00					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_2
      1  3a00				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3a00				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3a00				   WHITE_BISHOP_on_BLACK_SQUARE_2
      4  3a00				   TEMPORARY_VAR SET	Overlay
      5  3a00				   TEMPORARY_OFFSET SET	0
      6  3a00				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3a00				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_2
      3  3a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a18		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  3a30		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$06,$07,$03,$01,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3a48					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm"
      0  3a48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_3", 72
     12  3a48					      LIST	ON
      0  3a48					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_3
      1  3a48				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3a48				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3a48				   WHITE_BISHOP_on_BLACK_SQUARE_3
      4  3a48				   TEMPORARY_VAR SET	Overlay
      5  3a48				   TEMPORARY_OFFSET SET	0
      6  3a48				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3a48				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_3
      3  3a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3a78		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$d8,$e8,$70,$20,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3a90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm"
      0  3a90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_0", 72
     12  3a90					      LIST	ON
      0  3a90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_0
      1  3a90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3a90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3a90				   WHITE_ROOK_on_BLACK_SQUARE_0
      4  3a90				   TEMPORARY_VAR SET	Overlay
      5  3a90				   TEMPORARY_OFFSET SET	0
      6  3a90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3a90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_0
      3  3a90		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$f0,$50,$00	;PF0
      4  3aa8		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  3ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ad8					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm"
      0  3ad8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_1", 72
     12  3b00					      LIST	ON
      0  3b00					      DEF	WHITE_ROOK_on_BLACK_SQUARE_1
      1  3b00				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3b00				   BANK_WHITE_ROOK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3b00				   WHITE_ROOK_on_BLACK_SQUARE_1
      4  3b00				   TEMPORARY_VAR SET	Overlay
      5  3b00				   TEMPORARY_OFFSET SET	0
      6  3b00				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3b00				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_1
      3  3b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b18		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$7c,$54,$00	;PF1
      5  3b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3b48					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm"
      0  3b48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_2", 72
     12  3b48					      LIST	ON
      0  3b48					      DEF	WHITE_ROOK_on_BLACK_SQUARE_2
      1  3b48				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3b48				   BANK_WHITE_ROOK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3b48				   WHITE_ROOK_on_BLACK_SQUARE_2
      4  3b48				   TEMPORARY_VAR SET	Overlay
      5  3b48				   TEMPORARY_OFFSET SET	0
      6  3b48				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3b48				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_2
      3  3b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b60		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$03,$02,$00	;PF1
      5  3b78		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3b90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm"
      0  3b90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_3", 72
     12  3b90					      LIST	ON
      0  3b90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_3
      1  3b90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3b90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3b90				   WHITE_ROOK_on_BLACK_SQUARE_3
      4  3b90				   TEMPORARY_VAR SET	Overlay
      5  3b90				   TEMPORARY_OFFSET SET	0
      6  3b90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3b90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_3
      3  3b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3bc0		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$f8,$a8,$00	;PF2
------- FILE piece_graphics.asm
      0  3bd8					      CHECK_BANK_SIZE	"PIECE_3 (1K)"
      1  3bd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_3 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  3bd8					      ECHO	"PIECE_3 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  3bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3bd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_3 (1K)", " size=", * - ORIGIN
      5  3bd8				  -	      ERR
      6  3bd8					      ENDIF
      0  3bd8					      SLOT	2
      1  3bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  3bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  3bd8				  -	      ERR
      4  3bd8					      ENDIF
      5  3bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  3bd8				   _BANK_SLOT SET	2 * 64
      0  3bd8					      NEWBANK	PIECE_4
      1  3fd8 ????				      SEG	PIECE_4
      2  3c00					      ORG	_ORIGIN
      3  3c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  3c00				   _BANK_START SET	*
      5  3c00				   PIECE_4_START SET	*
      6  3c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3c00				   PIECE_4    SET	_BANK_SLOT + _CURRENT_BANK
      8  3c00				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3c00					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm"
      0  3c00					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_0", 72
     12  3c00					      LIST	ON
      0  3c00					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_0
      1  3c00				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3c00				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3c00				   WHITE_QUEEN_on_BLACK_SQUARE_0
      4  3c00				   TEMPORARY_VAR SET	Overlay
      5  3c00				   TEMPORARY_OFFSET SET	0
      6  3c00				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3c00				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_0
      3  3c00		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  3c18		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00,$80,$00	;PF1
      5  3c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3c48					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm"
      0  3c48					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_1", 72
     12  3c48					      LIST	ON
      0  3c48					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_1
      1  3c48				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3c48				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3c48				   WHITE_QUEEN_on_BLACK_SQUARE_1
      4  3c48				   TEMPORARY_VAR SET	Overlay
      5  3c48				   TEMPORARY_OFFSET SET	0
      6  3c48				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3c48				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_1
      3  3c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3c60		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$7c,$7c,$54,$00,$54,$00	;PF1
      5  3c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3c90					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm"
      0  3c90					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_2", 72
     12  3c90					      LIST	ON
      0  3c90					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_2
      1  3c90				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3c90				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3c90				   WHITE_QUEEN_on_BLACK_SQUARE_2
      4  3c90				   TEMPORARY_VAR SET	Overlay
      5  3c90				   TEMPORARY_OFFSET SET	0
      6  3c90				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3c90				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_2
      3  3c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ca8		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  3cc0		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$07,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3cd8					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm"
      0  3cd8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_3", 72
     12  3d00					      LIST	ON
      0  3d00					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_3
      1  3d00				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3d00				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3d00				   WHITE_QUEEN_on_BLACK_SQUARE_3
      4  3d00				   TEMPORARY_VAR SET	Overlay
      5  3d00				   TEMPORARY_OFFSET SET	0
      6  3d00				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3d00				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_3
      3  3d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d30		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$f8,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3d48					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_0.asm"
      0  3d48					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_0", 72
     12  3d48					      LIST	ON
      0  3d48					      DEF	WHITE_KING_on_BLACK_SQUARE_0
      1  3d48				   SLOT_WHITE_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3d48				   BANK_WHITE_KING_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3d48				   WHITE_KING_on_BLACK_SQUARE_0
      4  3d48				   TEMPORARY_VAR SET	Overlay
      5  3d48				   TEMPORARY_OFFSET SET	0
      6  3d48				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3d48				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_0
      3  3d48		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$f0,$00,$e0,$40	;PF0
      4  3d60		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  3d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3d90					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_1.asm"
      0  3d90					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_1", 72
     12  3d90					      LIST	ON
      0  3d90					      DEF	WHITE_KING_on_BLACK_SQUARE_1
      1  3d90				   SLOT_WHITE_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3d90				   BANK_WHITE_KING_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3d90				   WHITE_KING_on_BLACK_SQUARE_1
      4  3d90				   TEMPORARY_VAR SET	Overlay
      5  3d90				   TEMPORARY_OFFSET SET	0
      6  3d90				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3d90				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_1
      3  3d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3da8		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$7c,$00,$38,$10	;PF1
      5  3dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3dd8					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_2.asm"
      0  3dd8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_2", 72
     12  3e00					      LIST	ON
      0  3e00					      DEF	WHITE_KING_on_BLACK_SQUARE_2
      1  3e00				   SLOT_WHITE_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3e00				   BANK_WHITE_KING_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3e00				   WHITE_KING_on_BLACK_SQUARE_2
      4  3e00				   TEMPORARY_VAR SET	Overlay
      5  3e00				   TEMPORARY_OFFSET SET	0
      6  3e00				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3e00				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_2
      3  3e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e18		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  3e30		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$07,$00,$03,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3e48					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_3.asm"
      0  3e48					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_3", 72
     12  3e48					      LIST	ON
      0  3e48					      DEF	WHITE_KING_on_BLACK_SQUARE_3
      1  3e48				   SLOT_WHITE_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3e48				   BANK_WHITE_KING_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3e48				   WHITE_KING_on_BLACK_SQUARE_3
      4  3e48				   TEMPORARY_VAR SET	Overlay
      5  3e48				   TEMPORARY_OFFSET SET	0
      6  3e48				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3e48				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_3
      3  3e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e78		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$f8,$00,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3e90					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm"
      0  3e90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_0", 72
     12  3e90					      LIST	ON
      0  3e90					      DEF	BLACK_BLANK_on_WHITE_SQUARE_0
      1  3e90				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3e90				   BANK_BLACK_BLANK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3e90				   BLACK_BLANK_on_WHITE_SQUARE_0
      4  3e90				   TEMPORARY_VAR SET	Overlay
      5  3e90				   TEMPORARY_OFFSET SET	0
      6  3e90				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3e90				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_0
      3  3e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  3ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  3ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ed8					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm"
      0  3ed8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_1", 72
     12  3f00					      LIST	ON
      0  3f00					      DEF	BLACK_BLANK_on_WHITE_SQUARE_1
      1  3f00				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3f00				   BANK_BLACK_BLANK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3f00				   BLACK_BLANK_on_WHITE_SQUARE_1
      4  3f00				   TEMPORARY_VAR SET	Overlay
      5  3f00				   TEMPORARY_OFFSET SET	0
      6  3f00				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3f00				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_1
      3  3f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  3f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3f48					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm"
      0  3f48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_2", 72
     12  3f48					      LIST	ON
      0  3f48					      DEF	BLACK_BLANK_on_WHITE_SQUARE_2
      1  3f48				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3f48				   BANK_BLACK_BLANK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3f48				   BLACK_BLANK_on_WHITE_SQUARE_2
      4  3f48				   TEMPORARY_VAR SET	Overlay
      5  3f48				   TEMPORARY_OFFSET SET	0
      6  3f48				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3f48				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_2
      3  3f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  3f78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3f90					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm"
      0  3f90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_3", 72
     12  3f90					      LIST	ON
      0  3f90					      DEF	BLACK_BLANK_on_WHITE_SQUARE_3
      1  3f90				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3f90				   BANK_BLACK_BLANK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3f90				   BLACK_BLANK_on_WHITE_SQUARE_3
      4  3f90				   TEMPORARY_VAR SET	Overlay
      5  3f90				   TEMPORARY_OFFSET SET	0
      6  3f90				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3f90				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_3
      3  3f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3fc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
      0  3fd8					      CHECK_BANK_SIZE	"PIECE_4 (1K)"
      1  3fd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_4 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  3fd8					      ECHO	"PIECE_4 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  3fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3fd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_4 (1K)", " size=", * - ORIGIN
      5  3fd8				  -	      ERR
      6  3fd8					      ENDIF
      0  3fd8					      SLOT	2
      1  3fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  3fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  3fd8				  -	      ERR
      4  3fd8					      ENDIF
      5  3fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  3fd8				   _BANK_SLOT SET	2 * 64
      0  3fd8					      NEWBANK	PIECE_5
      1  43d8 ????				      SEG	PIECE_5
      2  4000					      ORG	_ORIGIN
      3  4000					      RORG	_BANK_ADDRESS_ORIGIN
      4  4000				   _BANK_START SET	*
      5  4000				   PIECE_5_START SET	*
      6  4000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4000				   PIECE_5    SET	_BANK_SLOT + _CURRENT_BANK
      8  4000				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4000					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm"
      0  4000					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_0", 72
     12  4000					      LIST	ON
      0  4000					      DEF	BLACK_PAWN_on_WHITE_SQUARE_0
      1  4000				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4000				   BANK_BLACK_PAWN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4000				   BLACK_PAWN_on_WHITE_SQUARE_0
      4  4000				   TEMPORARY_VAR SET	Overlay
      5  4000				   TEMPORARY_OFFSET SET	0
      6  4000				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4000				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_0
      3  4000		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$00,$00,$f0,$10,$b0,$b0,$10,$b0,$b0,$f0	;PF0
      4  4018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  4030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4048					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm"
      0  4048					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_1", 72
     12  4048					      LIST	ON
      0  4048					      DEF	BLACK_PAWN_on_WHITE_SQUARE_1
      1  4048				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4048				   BANK_BLACK_PAWN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4048				   BLACK_PAWN_on_WHITE_SQUARE_1
      4  4048				   TEMPORARY_VAR SET	Overlay
      5  4048				   TEMPORARY_OFFSET SET	0
      6  4048				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4048				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_1
      3  4048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4060		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$00,$00,$7c,$44,$6c,$6c,$44,$6c,$6c,$7c	;PF1
      5  4078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4090					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm"
      0  4090					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_2", 72
     12  4090					      LIST	ON
      0  4090					      DEF	BLACK_PAWN_on_WHITE_SQUARE_2
      1  4090				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4090				   BANK_BLACK_PAWN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4090				   BLACK_PAWN_on_WHITE_SQUARE_2
      4  4090				   TEMPORARY_VAR SET	Overlay
      5  4090				   TEMPORARY_OFFSET SET	0
      6  4090				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4090				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_2
      3  4090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  40a8		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$03,$02,$03,$03,$02,$03,$03,$03	;PF1
      5  40c0		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$00,$00,$07,$04,$06,$06,$04,$06,$06,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  40d8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm"
      0  40d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_3", 72
     12  4100					      LIST	ON
      0  4100					      DEF	BLACK_PAWN_on_WHITE_SQUARE_3
      1  4100				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4100				   BANK_BLACK_PAWN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4100				   BLACK_PAWN_on_WHITE_SQUARE_3
      4  4100				   TEMPORARY_VAR SET	Overlay
      5  4100				   TEMPORARY_OFFSET SET	0
      6  4100				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4100				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_3
      3  4100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4130		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$00,$00,$f8,$88,$d8,$d8,$88,$d8,$d8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4148					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  4148					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_0", 72
     12  4148					      LIST	ON
      0  4148					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_0
      1  4148				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4148				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4148				   BLACK_KNIGHT_on_WHITE_SQUARE_0
      4  4148				   TEMPORARY_VAR SET	Overlay
      5  4148				   TEMPORARY_OFFSET SET	0
      6  4148				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4148				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_0
      3  4148		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$80,$10,$30,$00,$40,$b0,$f0	;PF0
      4  4160		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00,$00,$80	;PF1
      5  4178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4190					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  4190					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_1", 72
     12  4190					      LIST	ON
      0  4190					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_1
      1  4190				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4190				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4190				   BLACK_KNIGHT_on_WHITE_SQUARE_1
      4  4190				   TEMPORARY_VAR SET	Overlay
      5  4190				   TEMPORARY_OFFSET SET	0
      6  4190				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4190				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_1
      3  4190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  41a8		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$0c,$44,$60,$00,$10,$68,$7c	;PF1
      5  41c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  41d8					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  41d8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_2", 72
     12  4200					      LIST	ON
      0  4200					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_2
      1  4200				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4200				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4200				   BLACK_KNIGHT_on_WHITE_SQUARE_2
      4  4200				   TEMPORARY_VAR SET	Overlay
      5  4200				   TEMPORARY_OFFSET SET	0
      6  4200				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4200				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_2
      3  4200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4218		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$02,$03,$00,$00,$03,$03	;PF1
      5  4230		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$06,$04,$00,$00,$01,$02,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4248					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  4248					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_3", 72
     12  4248					      LIST	ON
      0  4248					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_3
      1  4248				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4248				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4248				   BLACK_KNIGHT_on_WHITE_SQUARE_3
      4  4248				   TEMPORARY_VAR SET	Overlay
      5  4248				   TEMPORARY_OFFSET SET	0
      6  4248				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4248				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_3
      3  4248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4278		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$c0,$88,$18,$00,$20,$58,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4290					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm"
      0  4290					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_0", 72
     12  4290					      LIST	ON
      0  4290					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_0
      1  4290				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4290				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4290				   BLACK_BISHOP_on_WHITE_SQUARE_0
      4  4290				   TEMPORARY_VAR SET	Overlay
      5  4290				   TEMPORARY_OFFSET SET	0
      6  4290				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4290				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_0
      3  4290		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$10,$00,$40,$20,$10,$f0,$b0	;PF0
      4  42a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$00,$00,$80,$80,$80	;PF1
      5  42c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  42d8					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm"
      0  42d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_1", 72
     12  4300					      LIST	ON
      0  4300					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_1
      1  4300				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4300				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4300				   BLACK_BISHOP_on_WHITE_SQUARE_1
      4  4300				   TEMPORARY_VAR SET	Overlay
      5  4300				   TEMPORARY_OFFSET SET	0
      6  4300				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4300				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_1
      3  4300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4318		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$44,$04,$10,$20,$44,$7c,$6c	;PF1
      5  4330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4348					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm"
      0  4348					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_2", 72
     12  4348					      LIST	ON
      0  4348					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_2
      1  4348				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4348				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4348				   BLACK_BISHOP_on_WHITE_SQUARE_2
      4  4348				   TEMPORARY_VAR SET	Overlay
      5  4348				   TEMPORARY_OFFSET SET	0
      6  4348				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4348				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_2
      3  4348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4360		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$02,$00,$00,$01,$02,$03,$03	;PF1
      5  4378		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$04,$04,$01,$00,$04,$07,$06	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4390					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm"
      0  4390					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_3", 72
     12  4390					      LIST	ON
      0  4390					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_3
      1  4390				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4390				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4390				   BLACK_BISHOP_on_WHITE_SQUARE_3
      4  4390				   TEMPORARY_VAR SET	Overlay
      5  4390				   TEMPORARY_OFFSET SET	0
      6  4390				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4390				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_3
      3  4390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  43a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  43c0		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$88,$80,$20,$10,$88,$f8,$d8	;PF2
------- FILE piece_graphics.asm
      0  43d8					      CHECK_BANK_SIZE	"PIECE_5 (1K)"
      1  43d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_5 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  43d8					      ECHO	"PIECE_5 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  43d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  43d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_5 (1K)", " size=", * - ORIGIN
      5  43d8				  -	      ERR
      6  43d8					      ENDIF
      0  43d8					      SLOT	2
      1  43d8				  -	      IF	(2 < 0) || (2 > 3)
      2  43d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  43d8				  -	      ERR
      4  43d8					      ENDIF
      5  43d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  43d8				   _BANK_SLOT SET	2 * 64
      0  43d8					      NEWBANK	PIECE_6
      1  4790 ????				      SEG	PIECE_6
      2  4400					      ORG	_ORIGIN
      3  4400					      RORG	_BANK_ADDRESS_ORIGIN
      4  4400				   _BANK_START SET	*
      5  4400				   PIECE_6_START SET	*
      6  4400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4400				   PIECE_6    SET	_BANK_SLOT + _CURRENT_BANK
      8  4400				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4400					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm"
      0  4400					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_0", 72
     12  4400					      LIST	ON
      0  4400					      DEF	BLACK_ROOK_on_WHITE_SQUARE_0
      1  4400				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4400				   BANK_BLACK_ROOK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4400				   BLACK_ROOK_on_WHITE_SQUARE_0
      4  4400				   TEMPORARY_VAR SET	Overlay
      5  4400				   TEMPORARY_OFFSET SET	0
      6  4400				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4400				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_0
      3  4400		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$10,$10,$10,$00,$a0,$a0,$f0	;PF0
      4  4418		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00,$80	;PF1
      5  4430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4448					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm"
      0  4448					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_1", 72
     12  4448					      LIST	ON
      0  4448					      DEF	BLACK_ROOK_on_WHITE_SQUARE_1
      1  4448				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4448				   BANK_BLACK_ROOK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4448				   BLACK_ROOK_on_WHITE_SQUARE_1
      4  4448				   TEMPORARY_VAR SET	Overlay
      5  4448				   TEMPORARY_OFFSET SET	0
      6  4448				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4448				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_1
      3  4448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4460		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$44,$44,$44,$00,$28,$28,$7c	;PF1
      5  4478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4490					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm"
      0  4490					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_2", 72
     12  4490					      LIST	ON
      0  4490					      DEF	BLACK_ROOK_on_WHITE_SQUARE_2
      1  4490				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4490				   BANK_BLACK_ROOK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4490				   BLACK_ROOK_on_WHITE_SQUARE_2
      4  4490				   TEMPORARY_VAR SET	Overlay
      5  4490				   TEMPORARY_OFFSET SET	0
      6  4490				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4490				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_2
      3  4490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  44a8		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$02,$02,$02,$00,$01,$01,$03	;PF1
      5  44c0		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$04,$04,$04,$00,$02,$02,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  44d8					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm"
      0  44d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_3", 72
     12  4500					      LIST	ON
      0  4500					      DEF	BLACK_ROOK_on_WHITE_SQUARE_3
      1  4500				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4500				   BANK_BLACK_ROOK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4500				   BLACK_ROOK_on_WHITE_SQUARE_3
      4  4500				   TEMPORARY_VAR SET	Overlay
      5  4500				   TEMPORARY_OFFSET SET	0
      6  4500				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4500				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_3
      3  4500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4530		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$88,$88,$88,$00,$50,$50,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4548					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm"
      0  4548					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_0", 72
     12  4548					      LIST	ON
      0  4548					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_0
      1  4548				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4548				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4548				   BLACK_QUEEN_on_WHITE_SQUARE_0
      4  4548				   TEMPORARY_VAR SET	Overlay
      5  4548				   TEMPORARY_OFFSET SET	0
      6  4548				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4548				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_0
      3  4548		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$10,$10,$00,$00,$a0,$f0,$a0,$f0	;PF0
      4  4560		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$80,$80,$80,$00,$00,$80,$00,$80	;PF1
      5  4578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4590					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm"
      0  4590					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_1", 72
     12  4590					      LIST	ON
      0  4590					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_1
      1  4590				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4590				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4590				   BLACK_QUEEN_on_WHITE_SQUARE_1
      4  4590				   TEMPORARY_VAR SET	Overlay
      5  4590				   TEMPORARY_OFFSET SET	0
      6  4590				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4590				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_1
      3  4590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  45a8		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$44,$44,$04,$00,$28,$7c,$28,$7c	;PF1
      5  45c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  45d8					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm"
      0  45d8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_2", 72
     12  4600					      LIST	ON
      0  4600					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_2
      1  4600				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4600				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4600				   BLACK_QUEEN_on_WHITE_SQUARE_2
      4  4600				   TEMPORARY_VAR SET	Overlay
      5  4600				   TEMPORARY_OFFSET SET	0
      6  4600				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4600				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_2
      3  4600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4618		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$02,$02,$00,$00,$01,$03,$01,$03	;PF1
      5  4630		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$04,$04,$04,$00,$02,$07,$02,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4648					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm"
      0  4648					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_3", 72
     12  4648					      LIST	ON
      0  4648					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_3
      1  4648				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4648				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4648				   BLACK_QUEEN_on_WHITE_SQUARE_3
      4  4648				   TEMPORARY_VAR SET	Overlay
      5  4648				   TEMPORARY_OFFSET SET	0
      6  4648				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4648				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_3
      3  4648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4678		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$88,$88,$80,$00,$50,$f8,$50,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4690					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_0.asm"
      0  4690					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_0", 72
     12  4690					      LIST	ON
      0  4690					      DEF	BLACK_KING_on_WHITE_SQUARE_0
      1  4690				   SLOT_BLACK_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4690				   BANK_BLACK_KING_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4690				   BLACK_KING_on_WHITE_SQUARE_0
      4  4690				   TEMPORARY_VAR SET	Overlay
      5  4690				   TEMPORARY_OFFSET SET	0
      6  4690				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4690				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_0
      3  4690		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$10,$10,$a0,$a0,$00,$b0,$10,$b0	;PF0
      4  46a8		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$00,$00,$00,$80,$80,$80	;PF1
      5  46c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  46d8					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_1.asm"
      0  46d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_1", 72
     12  4700					      LIST	ON
      0  4700					      DEF	BLACK_KING_on_WHITE_SQUARE_1
      1  4700				   SLOT_BLACK_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4700				   BANK_BLACK_KING_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4700				   BLACK_KING_on_WHITE_SQUARE_1
      4  4700				   TEMPORARY_VAR SET	Overlay
      5  4700				   TEMPORARY_OFFSET SET	0
      6  4700				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4700				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_1
      3  4700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4718		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$44,$44,$28,$28,$00,$6c,$44,$6c	;PF1
      5  4730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4748					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_2.asm"
      0  4748					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_2", 72
     12  4748					      LIST	ON
      0  4748					      DEF	BLACK_KING_on_WHITE_SQUARE_2
      1  4748				   SLOT_BLACK_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4748				   BANK_BLACK_KING_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4748				   BLACK_KING_on_WHITE_SQUARE_2
      4  4748				   TEMPORARY_VAR SET	Overlay
      5  4748				   TEMPORARY_OFFSET SET	0
      6  4748				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4748				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_2
      3  4748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4760		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$02,$02,$01,$01,$00,$03,$02,$03	;PF1
      5  4778		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$04,$04,$02,$02,$00,$06,$04,$06	;PF2
------- FILE piece_graphics.asm
      0  4790					      CHECK_BANK_SIZE	"PIECE_6 (1K)"
      1  4790		       03 90	   .TEMP      =	* - _BANK_START
 PIECE_6 (1K) (1K) SIZE =  $390 , FREE= $70
      2  4790					      ECHO	"PIECE_6 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4790				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4790				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_6 (1K)", " size=", * - ORIGIN
      5  4790				  -	      ERR
      6  4790					      ENDIF
      0  4790					      SLOT	2
      1  4790				  -	      IF	(2 < 0) || (2 > 3)
      2  4790				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4790				  -	      ERR
      4  4790					      ENDIF
      5  4790				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4790				   _BANK_SLOT SET	2 * 64
      0  4790					      NEWBANK	PIECE_7
      1  4c48 ????				      SEG	PIECE_7
      2  4800					      ORG	_ORIGIN
      3  4800					      RORG	_BANK_ADDRESS_ORIGIN
      4  4800				   _BANK_START SET	*
      5  4800				   PIECE_7_START SET	*
      6  4800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4800				   PIECE_7    SET	_BANK_SLOT + _CURRENT_BANK
      8  4800				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4800					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_3.asm"
      0  4800					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_3", 72
     12  4800					      LIST	ON
      0  4800					      DEF	BLACK_KING_on_WHITE_SQUARE_3
      1  4800				   SLOT_BLACK_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4800				   BANK_BLACK_KING_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4800				   BLACK_KING_on_WHITE_SQUARE_3
      4  4800				   TEMPORARY_VAR SET	Overlay
      5  4800				   TEMPORARY_OFFSET SET	0
      6  4800				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4800				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_3
      3  4800		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4830		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$88,$88,$50,$50,$00,$d8,$88,$d8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4848					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm"
      0  4848					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_0", 72
     12  4848					      LIST	ON
      0  4848					      DEF	BLACK_BLANK_on_BLACK_SQUARE_0
      1  4848				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4848				   BANK_BLACK_BLANK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4848				   BLACK_BLANK_on_BLACK_SQUARE_0
      4  4848				   TEMPORARY_VAR SET	Overlay
      5  4848				   TEMPORARY_OFFSET SET	0
      6  4848				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4848				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_0
      3  4848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4860		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4890					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm"
      0  4890					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_1", 72
     12  4890					      LIST	ON
      0  4890					      DEF	BLACK_BLANK_on_BLACK_SQUARE_1
      1  4890				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4890				   BANK_BLACK_BLANK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4890				   BLACK_BLANK_on_BLACK_SQUARE_1
      4  4890				   TEMPORARY_VAR SET	Overlay
      5  4890				   TEMPORARY_OFFSET SET	0
      6  4890				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4890				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_1
      3  4890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  48a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  48c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  48d8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm"
      0  48d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_2", 72
     12  4900					      LIST	ON
      0  4900					      DEF	BLACK_BLANK_on_BLACK_SQUARE_2
      1  4900				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4900				   BANK_BLACK_BLANK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4900				   BLACK_BLANK_on_BLACK_SQUARE_2
      4  4900				   TEMPORARY_VAR SET	Overlay
      5  4900				   TEMPORARY_OFFSET SET	0
      6  4900				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4900				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_2
      3  4900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4930		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4948					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm"
      0  4948					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_3", 72
     12  4948					      LIST	ON
      0  4948					      DEF	BLACK_BLANK_on_BLACK_SQUARE_3
      1  4948				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4948				   BANK_BLACK_BLANK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4948				   BLACK_BLANK_on_BLACK_SQUARE_3
      4  4948				   TEMPORARY_VAR SET	Overlay
      5  4948				   TEMPORARY_OFFSET SET	0
      6  4948				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4948				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_3
      3  4948		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4990					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm"
      0  4990					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_0", 72
     12  4990					      LIST	ON
      0  4990					      DEF	BLACK_PAWN_on_BLACK_SQUARE_0
      1  4990				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4990				   BANK_BLACK_PAWN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4990				   BLACK_PAWN_on_BLACK_SQUARE_0
      4  4990				   TEMPORARY_VAR SET	Overlay
      5  4990				   TEMPORARY_OFFSET SET	0
      6  4990				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4990				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_0
      3  4990		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  49a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  49c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  49d8					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm"
      0  49d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_1", 72
     12  4a00					      LIST	ON
      0  4a00					      DEF	BLACK_PAWN_on_BLACK_SQUARE_1
      1  4a00				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4a00				   BANK_BLACK_PAWN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4a00				   BLACK_PAWN_on_BLACK_SQUARE_1
      4  4a00				   TEMPORARY_VAR SET	Overlay
      5  4a00				   TEMPORARY_OFFSET SET	0
      6  4a00				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4a00				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_1
      3  4a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a18		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4a30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4a48					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm"
      0  4a48					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_2", 72
     12  4a48					      LIST	ON
      0  4a48					      DEF	BLACK_PAWN_on_BLACK_SQUARE_2
      1  4a48				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4a48				   BANK_BLACK_PAWN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4a48				   BLACK_PAWN_on_BLACK_SQUARE_2
      4  4a48				   TEMPORARY_VAR SET	Overlay
      5  4a48				   TEMPORARY_OFFSET SET	0
      6  4a48				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4a48				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_2
      3  4a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a60		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4a78		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4a90					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm"
      0  4a90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_3", 72
     12  4a90					      LIST	ON
      0  4a90					      DEF	BLACK_PAWN_on_BLACK_SQUARE_3
      1  4a90				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4a90				   BANK_BLACK_PAWN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4a90				   BLACK_PAWN_on_BLACK_SQUARE_3
      4  4a90				   TEMPORARY_VAR SET	Overlay
      5  4a90				   TEMPORARY_OFFSET SET	0
      6  4a90				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4a90				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_3
      3  4a90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4ac0		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4ad8					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  4ad8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_0", 72
     12  4b00					      LIST	ON
      0  4b00					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_0
      1  4b00				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4b00				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4b00				   BLACK_KNIGHT_on_BLACK_SQUARE_0
      4  4b00				   TEMPORARY_VAR SET	Overlay
      5  4b00				   TEMPORARY_OFFSET SET	0
      6  4b00				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4b00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_0
      3  4b00		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$40,$00,$00	;PF0
      4  4b18		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4b48					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  4b48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_1", 72
     12  4b48					      LIST	ON
      0  4b48					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_1
      1  4b48				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4b48				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4b48				   BLACK_KNIGHT_on_BLACK_SQUARE_1
      4  4b48				   TEMPORARY_VAR SET	Overlay
      5  4b48				   TEMPORARY_OFFSET SET	0
      6  4b48				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4b48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_1
      3  4b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4b60		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$10,$00,$00	;PF1
      5  4b78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4b90					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  4b90					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_2", 72
     12  4b90					      LIST	ON
      0  4b90					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_2
      1  4b90				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4b90				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4b90				   BLACK_KNIGHT_on_BLACK_SQUARE_2
      4  4b90				   TEMPORARY_VAR SET	Overlay
      5  4b90				   TEMPORARY_OFFSET SET	0
      6  4b90				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4b90				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_2
      3  4b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ba8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4bc0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  4bd8					      CHECK_BANK_SIZE	"PIECE_7 (1K)"
      1  4bd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_7 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  4bd8					      ECHO	"PIECE_7 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4bd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_7 (1K)", " size=", * - ORIGIN
      5  4bd8				  -	      ERR
      6  4bd8					      ENDIF
      0  4bd8					      SLOT	2
      1  4bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  4bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4bd8				  -	      ERR
      4  4bd8					      ENDIF
      5  4bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4bd8				   _BANK_SLOT SET	2 * 64
      0  4bd8					      NEWBANK	PIECE_7
      1  4bd8					      SEG	PIECE_7
      2  4c00					      ORG	_ORIGIN
      3  4c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  4c00				   _BANK_START SET	*
      5  4c00				   PIECE_7_START SET	*
      6  4c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4c00				   PIECE_7    SET	_BANK_SLOT + _CURRENT_BANK
      8  4c00				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4c00					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  4c00					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_3", 72
     12  4c00					      LIST	ON
      0  4c00					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_3
      1  4c00				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4c00				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4c00				   BLACK_KNIGHT_on_BLACK_SQUARE_3
      4  4c00				   TEMPORARY_VAR SET	Overlay
      5  4c00				   TEMPORARY_OFFSET SET	0
      6  4c00				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4c00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_3
      3  4c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4c30		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
    127  4c48
    128  4c48							;    CHECK_BANK_SIZE "PIECES_4 (2K)"
    129  4c48
    130  4c48							;    NEWBANK PIECES_5
    131  4c48
    132  4c48							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
    133  4c48							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
    134  4c48							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
    135  4c48							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
    136  4c48							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
    137  4c48							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
    138  4c48							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
    139  4c48							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
    140  4c48
    141  4c48
    142  4c48				  -	      IF	0
    143  4c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    144  4c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    145  4c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    146  4c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    147  4c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    148  4c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    149  4c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    150  4c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    151  4c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    152  4c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    153  4c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    154  4c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    155  4c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    156  4c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    157  4c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    158  4c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    159  4c48					      ENDIF
    160  4c48
    161  4c48							;    CHECK_BANK_SIZE "PIECES_5 (2K)"
    162  4c48
    163  4c48				  -	      IF	0
    164  4c48				  -	      NEWBANK	PIECES_6
    165  4c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    166  4c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    167  4c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    168  4c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    169  4c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    170  4c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    171  4c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    172  4c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    173  4c48				  -
    174  4c48				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_0.asm"
    175  4c48				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_1.asm"
    176  4c48				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_2.asm"
    177  4c48				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_3.asm"
    178  4c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    179  4c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    180  4c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    181  4c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    182  4c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    183  4c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    184  4c48				  -
    185  4c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    186  4c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    187  4c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    188  4c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    189  4c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    190  4c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    191  4c48				  -	      CHECK_BANK_SIZE	"PIECES_6 (2K)"
    192  4c48				  -
    193  4c48				  -
    194  4c48				  -	      NEWBANK	PIECES_7
    195  4c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    196  4c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    197  4c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    198  4c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    199  4c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    200  4c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    201  4c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    202  4c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    203  4c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    204  4c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    205  4c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    206  4c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    207  4c48				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_0.asm"
    208  4c48				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_1.asm"
    209  4c48				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_2.asm"
    210  4c48				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_3.asm"
    211  4c48				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    212  4c48				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    213  4c48				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    214  4c48				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    215  4c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    216  4c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    217  4c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    218  4c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    219  4c48				  -	      CHECK_BANK_SIZE	"PIECES_7 (2K)"
    220  4c48				  -
    221  4c48				  -
    222  4c48				  -	      NEWBANK	PIECES_8
    223  4c48				  -
    224  4c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    225  4c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    226  4c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    227  4c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    228  4c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    229  4c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    230  4c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    231  4c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    232  4c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    233  4c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    234  4c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    235  4c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    236  4c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    237  4c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    238  4c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    239  4c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    240  4c48				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_0.asm"
    241  4c48				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_1.asm"
    242  4c48				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_2.asm"
    243  4c48				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_3.asm"
    244  4c48				  -
    245  4c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    246  4c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    247  4c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    248  4c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    249  4c48				  -	      CHECK_BANK_SIZE	"PIECES_8 (2K)"
    250  4c48				  -
    251  4c48					      ENDIF
    252  4c48
    253  4c48							;    NEWBANK PIECES_9
    254  4c48
    255  4c48							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    256  4c48							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    257  4c48							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    258  4c48							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    259  4c48							; include "gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    260  4c48
    261  4c48				  -	      IF	0
    262  4c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    263  4c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    264  4c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    265  4c48					      ENDIF
    266  4c48
    267  4c48							;    CHECK_BANK_SIZE "PIECES_9 (2K)"
    268  4c48
    269  4c48				  -	      IF	0
    270  4c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    271  4c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    272  4c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    273  4c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    274  4c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    275  4c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    276  4c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    277  4c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    278  4c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    279  4c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    280  4c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    281  4c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    282  4c48				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_0.asm"
    283  4c48				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_1.asm"
    284  4c48				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_2.asm"
    285  4c48				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_3.asm"
    286  4c48					      ENDIF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@2.asm LEVEL 2 PASS 4
      0  4c48					      include	"BANK_GENERIC@2.asm"
      1  4c48
      0  4c48					      SLOT	2
      1  4c48				  -	      IF	(2 < 0) || (2 > 3)
      2  4c48				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4c48				  -	      ERR
      4  4c48					      ENDIF
      5  4c48				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4c48				   _BANK_SLOT SET	2 * 64
      0  4c48					      NEWBANK	GENERIC_BANK@2
      1  524f ????				      SEG	GENERIC_BANK@2
      2  5000					      ORG	_ORIGIN
      3  5000					      RORG	_BANK_ADDRESS_ORIGIN
      4  5000				   _BANK_START SET	*
      5  5000				   GENERIC_BANK@2_START SET	*
      6  5000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5000				   GENERIC_BANK@2 SET	_BANK_SLOT + _CURRENT_BANK
      8  5000				   _ORIGIN    SET	_ORIGIN + 1024
      4  5000
      5  5000							;    DEFINE_1K_SEGMENT DECODE_LEVEL_SHADOW
      6  5000
      7  5000				  -	      IF	0
      8  5000				  -	      IF	PLUSCART = YES
      9  5000				  -	      .byte	"ChessAPI.php", #0 //TODO: change!
     10  5000				  -	      .byte	"pluscart.firmaplus.de", #0
     11  5000				  -	      ENDIF
     12  5000					      ENDIF
     13  5000
     14  5000							;STELLA_AUTODETECT .byte $85,$3e,$a9,$00 ; 3E
     15  5000
     16  5000
     17  5000
     18  5000							;---------------------------------------------------------------------------------------------------
     19  5000
      0  5000					      DEF	tidySc
      1  5000				   SLOT_tidySc SET	_BANK_SLOT
      2  5000				   BANK_tidySc SET	SLOT_tidySc + _CURRENT_BANK
      3  5000				   tidySc
      4  5000				   TEMPORARY_VAR SET	Overlay
      5  5000				   TEMPORARY_OFFSET SET	0
      6  5000				   VAR_BOUNDARY_tidySc SET	TEMPORARY_OFFSET
      7  5000				   FUNCTION_NAME SET	tidySc
     21  5000					      SUBROUTINE
     22  5000
     23  5000		       a9 00		      lda	#0
     24  5002		       85 4d		      sta	PF0
     25  5004		       85 4e		      sta	PF1
     26  5006		       85 4f		      sta	PF2
     27  5008		       85 5b		      sta	GRP0
     28  500a		       85 5c		      sta	GRP1
     29  500c
     30  500c		       a9 42		      lda	#%01000010	; bit6 is not required
     31  500e							;sta VBLANK			  ; end of screen - enter blanking
     32  500e
     33  500e
     34  500e							; END OF VISIBLE SCREEN
     35  500e							; HERE'S SOME TIME TO DO STUFF
     36  500e
     37  500e		       a9 2e		      lda	#TIME_PART_2
     38  5010		       8d 96 02 	      sta	TIM64T
     39  5013		       60		      rts
     40  5014
     41  5014
     42  5014							;---------------------------------------------------------------------------------------------------
     43  5014
      0  5014					      DEF	longD
      1  5014				   SLOT_longD SET	_BANK_SLOT
      2  5014				   BANK_longD SET	SLOT_longD + _CURRENT_BANK
      3  5014				   longD
      4  5014				   TEMPORARY_VAR SET	Overlay
      5  5014				   TEMPORARY_OFFSET SET	0
      6  5014				   VAR_BOUNDARY_longD SET	TEMPORARY_OFFSET
      7  5014				   FUNCTION_NAME SET	longD
     45  5014					      SUBROUTINE
     46  5014
     47  5014		       85 42		      sta	WSYNC
     48  5016
     49  5016		       20 27 f8 	      jsr	_rts
     50  5019		       20 27 f8 	      jsr	_rts
     51  501c		       20 27 f8 	      jsr	_rts
      0  501f					      SLEEP	7
      1  501f				   .CYCLES    SET	7
      2  501f
      3  501f				  -	      IF	.CYCLES < 2
      4  501f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  501f				  -	      ERR
      6  501f					      ENDIF
      7  501f
      8  501f					      IF	.CYCLES & 1
      9  501f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  501f		       04 00		      nop	0
     11  5021				  -	      ELSE
     12  5021				  -	      bit	VSYNC
     13  5021					      ENDIF
     14  5021				   .CYCLES    SET	.CYCLES - 3
     15  5021					      ENDIF
     16  5021
     17  5021					      REPEAT	.CYCLES / 2
     18  5021		       ea		      nop
     17  5021					      REPEND
     18  5022		       ea		      nop
     19  5023					      REPEND
     53  5023
     54  5023		       a2 00		      ldx	#0
     55  5025		       86 41		      stx	VBLANK
     56  5027		       60	   _rts       rts
     57  5028
     58  5028				  -	      IF	0
     59  5028				  -	      DEF	Resync
     60  5028				  -	      SUBROUTINE
     61  5028				  -
     62  5028				  -	      RESYNC
     63  5028				  -	      rts
     64  5028					      ENDIF
     65  5028
     66  5028
     67  5028							;---------------------------------------------------------------------------------------------------
     68  5028
      0  5028					      DEF	aiStartClearBoard
      1  5028				   SLOT_aiStartClearBoard SET	_BANK_SLOT
      2  5028				   BANK_aiStartClearBoard SET	SLOT_aiStartClearBoard + _CURRENT_BANK
      3  5028				   aiStartClearBoard
      4  5028				   TEMPORARY_VAR SET	Overlay
      5  5028				   TEMPORARY_OFFSET SET	0
      6  5028				   VAR_BOUNDARY_aiStartClearBoard SET	TEMPORARY_OFFSET
      7  5028				   FUNCTION_NAME SET	aiStartClearBoard
     70  5028					      SUBROUTINE
     71  5028
      0  5028					      REFER	AiStateMachine
      1  5028				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5028				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5028					      ENDIF
      0  5028					      VEND	aiStartClearBoard
      1  5028				  -	      IFNCONST	aiStartClearBoard
      2  5028				  -	      ECHO	"Incorrect VEND label", aiStartClearBoard
      3  5028				  -	      ERR
      4  5028					      ENDIF
      5  5028		       00 a2	   VAREND_aiStartClearBoard =	TEMPORARY_VAR
     74  5028
     75  5028		       a2 08		      ldx	#8
     76  502a		       86 84		      stx	drawCount	; = bank
     77  502c
     78  502c		       a9 ff		      lda	#-1
     79  502e		       85 88		      sta	cursorX12
     80  5030
      0  5030					      PHASE	AI_ClearEachRow
      1  5030		       a9 0e		      lda	#AI_ClearEachRow
      2  5032		       85 8c		      sta	aiState
     82  5034		       60		      rts
     83  5035
     84  5035							;---------------------------------------------------------------------------------------------------
     85  5035
      0  5035					      DEF	aiClearEachRow
      1  5035				   SLOT_aiClearEachRow SET	_BANK_SLOT
      2  5035				   BANK_aiClearEachRow SET	SLOT_aiClearEachRow + _CURRENT_BANK
      3  5035				   aiClearEachRow
      4  5035				   TEMPORARY_VAR SET	Overlay
      5  5035				   TEMPORARY_OFFSET SET	0
      6  5035				   VAR_BOUNDARY_aiClearEachRow SET	TEMPORARY_OFFSET
      7  5035				   FUNCTION_NAME SET	aiClearEachRow
     87  5035					      SUBROUTINE
     88  5035
      0  5035					      REFER	AiStateMachine
      1  5035				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5035				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5035					      ENDIF
      0  5035					      VEND	aiClearEachRow
      1  5035				  -	      IFNCONST	aiClearEachRow
      2  5035				  -	      ECHO	"Incorrect VEND label", aiClearEachRow
      3  5035				  -	      ERR
      4  5035					      ENDIF
      5  5035		       00 a2	   VAREND_aiClearEachRow =	TEMPORARY_VAR
     91  5035
     92  5035		       c6 84		      dec	drawCount
     93  5037		       30 00		      bmi	.bitmapCleared
     94  5039							;TODOldy drawCount
     95  5039							;TODO jmp CallClear
     96  5039
     97  5039				   .bitmapCleared
     98  5039
     99  5039		       a9 63		      lda	#99
    100  503b		       85 80		      sta	squareToDraw
    101  503d
      0  503d					      PHASE	AI_DrawEntireBoard
      1  503d		       a9 0f		      lda	#AI_DrawEntireBoard
      2  503f		       85 8c		      sta	aiState
    103  5041		       60		      rts
    104  5042
    105  5042
    106  5042
    107  5042							;---------------------------------------------------------------------------------------------------
    108  5042
      0  5042					      DEF	aiMoveIsSelected
      1  5042				   SLOT_aiMoveIsSelected SET	_BANK_SLOT
      2  5042				   BANK_aiMoveIsSelected SET	SLOT_aiMoveIsSelected + _CURRENT_BANK
      3  5042				   aiMoveIsSelected
      4  5042				   TEMPORARY_VAR SET	Overlay
      5  5042				   TEMPORARY_OFFSET SET	0
      6  5042				   VAR_BOUNDARY_aiMoveIsSelected SET	TEMPORARY_OFFSET
      7  5042				   FUNCTION_NAME SET	aiMoveIsSelected
    110  5042					      SUBROUTINE
    111  5042
      0  5042					      REFER	AiStateMachine
      1  5042				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5042				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5042					      ENDIF
      0  5042					      VEND	aiMoveIsSelected
      1  5042				  -	      IFNCONST	aiMoveIsSelected
      2  5042				  -	      ECHO	"Incorrect VEND label", aiMoveIsSelected
      3  5042				  -	      ERR
      4  5042					      ENDIF
      5  5042		       00 a2	   VAREND_aiMoveIsSelected =	TEMPORARY_VAR
    114  5042
    115  5042
    116  5042							; Both computer and human have now seleted a move, and converge here
    117  5042
    118  5042
    119  5042							; fromPiece	 piece doing the move
    120  5042							; fromX12	 current square X12
    121  5042							; originX12	 starting square X12
    122  5042							; toX12	 ending square X12
    123  5042
    124  5042
    125  5042
    126  5042		       20 64 f5 	      jsr	AdjustMaterialPositionalValue
    127  5045
    128  5045		       a9 00		      lda	#0
    129  5047		       85 99		      sta	previousPiece
    130  5049		       85 82		      sta	drawDelay
    131  504b
    132  504b		       a9 0a		      lda	#10	; on/off count
    133  504d		       85 84		      sta	drawCount	; flashing for piece about to move
    134  504f
      0  504f					      PHASE	AI_WriteStartPieceBlank
      1  504f		       a9 15		      lda	#AI_WriteStartPieceBlank
      2  5051		       85 8c		      sta	aiState
    136  5053		       60	   .idleErase rts
    137  5054
    138  5054
    139  5054							;---------------------------------------------------------------------------------------------------
    140  5054
      0  5054					      DEF	CopySetup	;@2 - uses @3
      1  5054				   SLOT_CopySetup SET	_BANK_SLOT
      2  5054				   BANK_CopySetup SET	SLOT_CopySetup + _CURRENT_BANK
      3  5054				   CopySetup
      4  5054				   TEMPORARY_VAR SET	Overlay
      5  5054				   TEMPORARY_OFFSET SET	0
      6  5054				   VAR_BOUNDARY_CopySetup SET	TEMPORARY_OFFSET
      7  5054				   FUNCTION_NAME SET	CopySetup
    142  5054					      SUBROUTINE
    143  5054
      0  5054					      REFER	CopySinglePiece
      1  5054					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  5054				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  5054					      ENDIF
      0  5054					      VAR	__tmp, 1
      1  5054		       00 ae	   __tmp      =	TEMPORARY_VAR
      2  5054				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5054
      4  5054				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5054				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5054				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5054					      ENDIF
      8  5054				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5054				  -	      ECHO	"Temporary Variable", __tmp, "overflow!"
     10  5054				  -	      ERR
     11  5054					      ENDIF
     12  5054					      LIST	ON
      0  5054					      VAR	__shiftx, 1
      1  5054		       00 af	   __shiftx   =	TEMPORARY_VAR
      2  5054				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5054
      4  5054				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5054				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5054				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5054					      ENDIF
      8  5054				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5054				  -	      ECHO	"Temporary Variable", __shiftx, "overflow!"
     10  5054				  -	      ERR
     11  5054					      ENDIF
     12  5054					      LIST	ON
      0  5054					      VAR	__pieceColour2, 1
      1  5054		       00 b0	   __pieceColour2 =	TEMPORARY_VAR
      2  5054				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5054
      4  5054				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5054				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5054				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5054					      ENDIF
      8  5054				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5054				  -	      ECHO	"Temporary Variable", __pieceColour2, "overflow!"
     10  5054				  -	      ERR
     11  5054					      ENDIF
     12  5054					      LIST	ON
      0  5054					      VEND	CopySetup
      1  5054				  -	      IFNCONST	CopySetup
      2  5054				  -	      ECHO	"Incorrect VEND label", CopySetup
      3  5054				  -	      ERR
      4  5054					      ENDIF
      5  5054		       00 b1	   VAREND_CopySetup =	TEMPORARY_VAR
    149  5054
    150  5054							; figure colouration of square
    151  5054
    152  5054		       a5 80		      lda	squareToDraw
    153  5056
    154  5056				  -	      IF	DIAGNOSTICS
    155  5056				  -			; Catch out-of-range piece square
    156  5056				  -			; will not catch off left/right edge
    157  5056				  -
    158  5056				  -.fail      cmp	#100
    159  5056				  -	      bcs	.fail
    160  5056				  -	      cmp	#22
    161  5056				  -	      bcc	.fail
    162  5056					      ENDIF
    163  5056
    164  5056
    165  5056		       a2 0a		      ldx	#10
    166  5058		       38		      sec
    167  5059		       e9 0a	   .sub10     sbc	#10
    168  505b		       ca		      dex
    169  505c		       b0 fb		      bcs	.sub10
    170  505e		       69 08		      adc	#8
    171  5060		       85 af		      sta	__shiftx
    172  5062				  -	      IF	DIAGNOSTICS
    173  5062				  -.fail2     cmp	#8
    174  5062				  -	      bcs	.fail2
    175  5062				  -	      cpx	#8
    176  5062				  -	      bcs	.fail2
    177  5062					      ENDIF
    178  5062		       86 ae		      stx	__tmp
    179  5064		       65 ae		      adc	__tmp
    180  5066
    181  5066
    182  5066		       29 01		      and	#1
    183  5068		       49 01		      eor	#1
    184  506a		       f0 02		      beq	.white
    185  506c		       a9 24		      lda	#36
    186  506e				   .white
    187  506e		       85 b0		      sta	__pieceColour2	; actually SQUARE black/white
    188  5070
    189  5070							; PieceColour = 0 for white square, 36 for black square
    190  5070
    191  5070		       a9 cf		      lda	#RAMBANK_BOARD
    192  5072		       85 3e		      sta	SET_BANK_RAM	;@3
    193  5074
    194  5074		       a4 80		      ldy	squareToDraw
    195  5076		       b9 79 fc 	      lda	Board,y
    196  5079							;and #$87
    197  5079		       0a		      asl
    198  507a		       90 02		      bcc	.blackAdjust
    199  507c		       09 10		      ora	#16	; switch white pieces
    200  507e		       4a	   .blackAdjust lsr
    201  507f		       29 0f		      and	#%1111
    202  5081		       aa		      tax
    203  5082
    204  5082		       a5 af		      lda	__shiftx
    205  5084		       29 03		      and	#3	; shift position in P
    206  5086
    207  5086		       18		      clc
    208  5087		       7d 8f f8 	      adc	PieceToShape,x
    209  508a		       18		      clc
    210  508b		       65 b0		      adc	__pieceColour2
    211  508d		       a8		      tay
    212  508e		       60		      rts
    213  508f
    214  508f				   PieceToShape
    215  508f
    216  508f		       00		      .byte.b	INDEX_WHITE_BLANK_on_WHITE_SQUARE_0
    217  5090		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    218  5091		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (black P)
    219  5092		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    220  5093		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    221  5094		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    222  5095		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    223  5096		       18		      .byte.b	INDEX_WHITE_KING_on_WHITE_SQUARE_0
    224  5097
    225  5097		       48		      .byte.b	INDEX_BLACK_BLANK_on_WHITE_SQUARE_0
    226  5098		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (white P)
    227  5099		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    228  509a		       50		      .byte.b	INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0
    229  509b		       54		      .byte.b	INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0
    230  509c		       58		      .byte.b	INDEX_BLACK_ROOK_on_WHITE_SQUARE_0
    231  509d		       5c		      .byte.b	INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    232  509e		       60		      .byte.b	INDEX_BLACK_KING_on_WHITE_SQUARE_0
    233  509f
    234  509f
    235  509f							;---------------------------------------------------------------------------------------------------
    236  509f
------- FILE piece_vectors.asm LEVEL 3 PASS 4
      0  509f					      include	"piece_vectors.asm"
      1  509f							; Created by ConvertChessPieces.py
      0  509f					      DEF	PIECE_VECTOR_LO
      1  509f				   SLOT_PIECE_VECTOR_LO SET	_BANK_SLOT
      2  509f				   BANK_PIECE_VECTOR_LO SET	SLOT_PIECE_VECTOR_LO + _CURRENT_BANK
      3  509f				   PIECE_VECTOR_LO
      4  509f				   TEMPORARY_VAR SET	Overlay
      5  509f				   TEMPORARY_OFFSET SET	0
      6  509f				   VAR_BOUNDARY_PIECE_VECTOR_LO SET	TEMPORARY_OFFSET
      7  509f				   FUNCTION_NAME SET	PIECE_VECTOR_LO
      3  509f		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_0
      4  50a0		       48		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_1
      5  50a1		       90		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_2
      6  50a2		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_3
      7  50a3		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_0
      8  50a4		       90		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_1
      9  50a5		       00		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_2
     10  50a6		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_3
     11  50a7		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_0
     12  50a8		       00		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_1
     13  50a9		       48		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_2
     14  50aa		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_3
     15  50ab		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_0
     16  50ac		       48		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_1
     17  50ad		       90		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_2
     18  50ae		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_3
     19  50af		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_0
     20  50b0		       90		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_1
     21  50b1		       00		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_2
     22  50b2		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_3
     23  50b3		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_0
     24  50b4		       00		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_1
     25  50b5		       48		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_2
     26  50b6		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_3
     27  50b7		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_0
     28  50b8		       48		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_1
     29  50b9		       90		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_2
     30  50ba		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_3
     31  50bb		       00		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_0
     32  50bc		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_1
     33  50bd		       90		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_2
     34  50be		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_3
     35  50bf		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_0
     36  50c0		       00		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_1
     37  50c1		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_2
     38  50c2		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_3
     39  50c3		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_0
     40  50c4		       90		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_1
     41  50c5		       00		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_2
     42  50c6		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_3
     43  50c7		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_0
     44  50c8		       00		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_1
     45  50c9		       48		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_2
     46  50ca		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_3
     47  50cb		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_0
     48  50cc		       48		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_1
     49  50cd		       90		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_2
     50  50ce		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_3
     51  50cf		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_0
     52  50d0		       90		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_1
     53  50d1		       00		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_2
     54  50d2		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_3
     55  50d3		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_0
     56  50d4		       00		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_1
     57  50d5		       48		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_2
     58  50d6		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_3
     59  50d7		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_0
     60  50d8		       48		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_1
     61  50d9		       90		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_2
     62  50da		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_3
     63  50db		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_0
     64  50dc		       90		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_1
     65  50dd		       00		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_2
     66  50de		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_3
     67  50df		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_0
     68  50e0		       00		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_1
     69  50e1		       48		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_2
     70  50e2		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_3
     71  50e3		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_0
     72  50e4		       90		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_1
     73  50e5		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_2
     74  50e6		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_3
     75  50e7		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_0
     76  50e8		       00		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_1
     77  50e9		       48		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_2
     78  50ea		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_3
     79  50eb		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_0
     80  50ec		       48		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_1
     81  50ed		       90		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_2
     82  50ee		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_3
     83  50ef		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_0
     84  50f0		       90		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_1
     85  50f1		       00		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_2
     86  50f2		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_3
     87  50f3		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_0
     88  50f4		       00		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_1
     89  50f5		       48		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_2
     90  50f6		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_3
     91  50f7		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_0
     92  50f8		       48		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_1
     93  50f9		       90		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_2
     94  50fa		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_3
     95  50fb		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_0
     96  50fc		       90		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_1
     97  50fd		       00		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_2
     98  50fe		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_3
     99  50ff		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_0
    100  5100		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_1
    101  5101		       48		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_2
    102  5102		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_3
    103  5103		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_0
    104  5104		       48		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_1
    105  5105		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_2
    106  5106		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_3
    107  5107		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_0
    108  5108		       90		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_1
    109  5109		       00		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_2
    110  510a		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_3
    111  510b		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_0
    112  510c		       90		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_1
    113  510d		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_2
    114  510e		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_3
    115  510f		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_0
    116  5110		       00		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_1
    117  5111		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_2
    118  5112		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_3
    119  5113		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_0
    120  5114		       48		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_1
    121  5115		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_2
    122  5116		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_3
    123  5117		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_0
    124  5118		       48		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_1
    125  5119		       90		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_2
    126  511a		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_3
    127  511b		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_0
    128  511c		       90		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_1
    129  511d		       00		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_2
    130  511e		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_3
    131  511f		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_0
    132  5120		       00		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_1
    133  5121		       48		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_2
    134  5122		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_3
    135  5123		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_0
    136  5124		       48		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_1
    137  5125		       90		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_2
    138  5126		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_3
    139  5127		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_0
    140  5128		       00		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_1
    141  5129		       48		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_2
    142  512a		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_3
    143  512b		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_0
    144  512c		       48		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_1
    145  512d		       90		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_2
    146  512e		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  512f					      DEF	PIECE_VECTOR_HI
      1  512f				   SLOT_PIECE_VECTOR_HI SET	_BANK_SLOT
      2  512f				   BANK_PIECE_VECTOR_HI SET	SLOT_PIECE_VECTOR_HI + _CURRENT_BANK
      3  512f				   PIECE_VECTOR_HI
      4  512f				   TEMPORARY_VAR SET	Overlay
      5  512f				   TEMPORARY_OFFSET SET	0
      6  512f				   VAR_BOUNDARY_PIECE_VECTOR_HI SET	TEMPORARY_OFFSET
      7  512f				   FUNCTION_NAME SET	PIECE_VECTOR_HI
    148  512f		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_0
    149  5130		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_1
    150  5131		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_2
    151  5132		       f9		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_3
    152  5133		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_0
    153  5134		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_1
    154  5135		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_2
    155  5136		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_3
    156  5137		       fa		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_0
    157  5138		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_1
    158  5139		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_2
    159  513a		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_3
    160  513b		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_0
    161  513c		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_1
    162  513d		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_2
    163  513e		       f9		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_3
    164  513f		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_0
    165  5140		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_1
    166  5141		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_2
    167  5142		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_3
    168  5143		       fa		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_0
    169  5144		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_1
    170  5145		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_2
    171  5146		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_3
    172  5147		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_0
    173  5148		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_1
    174  5149		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_2
    175  514a		       f9		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_3
    176  514b		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_0
    177  514c		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_1
    178  514d		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_2
    179  514e		       fa		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_3
    180  514f		       fa		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_0
    181  5150		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_1
    182  5151		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_2
    183  5152		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_3
    184  5153		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_0
    185  5154		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_1
    186  5155		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_2
    187  5156		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_3
    188  5157		       fa		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_0
    189  5158		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_1
    190  5159		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_2
    191  515a		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_3
    192  515b		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_0
    193  515c		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_1
    194  515d		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_2
    195  515e		       f9		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_3
    196  515f		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_0
    197  5160		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_1
    198  5161		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_2
    199  5162		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_3
    200  5163		       fa		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_0
    201  5164		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_1
    202  5165		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_2
    203  5166		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_3
    204  5167		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_0
    205  5168		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_1
    206  5169		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_2
    207  516a		       f9		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_3
    208  516b		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_0
    209  516c		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_1
    210  516d		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_2
    211  516e		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_3
    212  516f		       fa		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_0
    213  5170		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_1
    214  5171		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_2
    215  5172		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_3
    216  5173		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_0
    217  5174		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_1
    218  5175		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_2
    219  5176		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_3
    220  5177		       fa		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_0
    221  5178		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_1
    222  5179		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_2
    223  517a		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_3
    224  517b		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_0
    225  517c		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_1
    226  517d		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_2
    227  517e		       f9		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_3
    228  517f		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_0
    229  5180		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_1
    230  5181		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_2
    231  5182		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_3
    232  5183		       fa		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_0
    233  5184		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_1
    234  5185		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_2
    235  5186		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_3
    236  5187		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_0
    237  5188		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_1
    238  5189		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_2
    239  518a		       f9		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_3
    240  518b		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_0
    241  518c		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_1
    242  518d		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_2
    243  518e		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_3
    244  518f		       fa		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_0
    245  5190		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_1
    246  5191		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_2
    247  5192		       f8		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_3
    248  5193		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_0
    249  5194		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_1
    250  5195		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_2
    251  5196		       f9		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_3
    252  5197		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_0
    253  5198		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_1
    254  5199		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_2
    255  519a		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_3
    256  519b		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_0
    257  519c		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_1
    258  519d		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_2
    259  519e		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_3
    260  519f		       f9		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_0
    261  51a0		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_1
    262  51a1		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_2
    263  51a2		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_3
    264  51a3		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_0
    265  51a4		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_1
    266  51a5		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_2
    267  51a6		       f8		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_3
    268  51a7		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_0
    269  51a8		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_1
    270  51a9		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_2
    271  51aa		       fa		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_3
    272  51ab		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_0
    273  51ac		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_1
    274  51ad		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_2
    275  51ae		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_3
    276  51af		       fb		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_0
    277  51b0		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_1
    278  51b1		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_2
    279  51b2		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_3
    280  51b3		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_0
    281  51b4		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_1
    282  51b5		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_2
    283  51b6		       fa		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_3
    284  51b7		       fa		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_0
    285  51b8		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_1
    286  51b9		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_2
    287  51ba		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_3
    288  51bb		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_0
    289  51bc		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_1
    290  51bd		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_2
    291  51be		       f9		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  51bf					      DEF	PIECE_VECTOR_BANK
      1  51bf				   SLOT_PIECE_VECTOR_BANK SET	_BANK_SLOT
      2  51bf				   BANK_PIECE_VECTOR_BANK SET	SLOT_PIECE_VECTOR_BANK + _CURRENT_BANK
      3  51bf				   PIECE_VECTOR_BANK
      4  51bf				   TEMPORARY_VAR SET	Overlay
      5  51bf				   TEMPORARY_OFFSET SET	0
      6  51bf				   VAR_BOUNDARY_PIECE_VECTOR_BANK SET	TEMPORARY_OFFSET
      7  51bf				   FUNCTION_NAME SET	PIECE_VECTOR_BANK
    293  51bf		       8b		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_0
    294  51c0		       8b		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_1
    295  51c1		       8b		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_2
    296  51c2		       8b		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_3
    297  51c3		       8b		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_0
    298  51c4		       8b		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_1
    299  51c5		       8b		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_2
    300  51c6		       8b		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_3
    301  51c7		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0
    302  51c8		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1
    303  51c9		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2
    304  51ca		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3
    305  51cb		       8c		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_0
    306  51cc		       8c		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_1
    307  51cd		       8c		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_2
    308  51ce		       8c		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_3
    309  51cf		       8c		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_0
    310  51d0		       8c		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_1
    311  51d1		       8c		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_2
    312  51d2		       8c		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_3
    313  51d3		       8c		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_0
    314  51d4		       8c		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_1
    315  51d5		       8c		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_2
    316  51d6		       8c		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_3
    317  51d7		       8d		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_0
    318  51d8		       8d		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_1
    319  51d9		       8d		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_2
    320  51da		       8d		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_3
    321  51db		       97		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_0
    322  51dc		       97		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_1
    323  51dd		       97		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_2
    324  51de		       98		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_3
    325  51df		       99		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0
    326  51e0		       99		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1
    327  51e1		       99		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2
    328  51e2		       99		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3
    329  51e3		       8d		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_0
    330  51e4		       8d		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_1
    331  51e5		       8d		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_2
    332  51e6		       8d		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_3
    333  51e7		       8d		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_0
    334  51e8		       8d		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_1
    335  51e9		       8d		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_2
    336  51ea		       8d		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_3
    337  51eb		       8e		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0
    338  51ec		       8e		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1
    339  51ed		       8e		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2
    340  51ee		       8e		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3
    341  51ef		       8e		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_0
    342  51f0		       8e		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_1
    343  51f1		       8e		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_2
    344  51f2		       8e		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_3
    345  51f3		       8e		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_0
    346  51f4		       8e		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_1
    347  51f5		       8e		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_2
    348  51f6		       8e		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_3
    349  51f7		       8f		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_0
    350  51f8		       8f		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_1
    351  51f9		       8f		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_2
    352  51fa		       8f		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_3
    353  51fb		       8f		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_0
    354  51fc		       8f		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_1
    355  51fd		       8f		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_2
    356  51fe		       8f		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_3
    357  51ff		       96		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_0
    358  5200		       96		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_1
    359  5201		       96		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_2
    360  5202		       96		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_3
    361  5203		       99		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0
    362  5204		       99		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1
    363  5205		       99		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2
    364  5206		       99		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3
    365  5207		       8f		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_0
    366  5208		       8f		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_1
    367  5209		       8f		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_2
    368  520a		       8f		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_3
    369  520b		       90		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_0
    370  520c		       90		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_1
    371  520d		       90		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_2
    372  520e		       90		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_3
    373  520f		       90		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0
    374  5210		       90		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1
    375  5211		       90		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2
    376  5212		       90		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3
    377  5213		       90		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_0
    378  5214		       90		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_1
    379  5215		       90		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_2
    380  5216		       90		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_3
    381  5217		       91		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_0
    382  5218		       91		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_1
    383  5219		       91		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_2
    384  521a		       91		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_3
    385  521b		       91		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_0
    386  521c		       91		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_1
    387  521d		       91		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_2
    388  521e		       91		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_3
    389  521f		       91		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_0
    390  5220		       91		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_1
    391  5221		       91		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_2
    392  5222		       92		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_3
    393  5223		       99		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_0
    394  5224		       99		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_1
    395  5225		       99		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_2
    396  5226		       99		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_3
    397  5227		       96		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0
    398  5228		       96		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1
    399  5229		       96		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2
    400  522a		       96		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3
    401  522b		       92		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_0
    402  522c		       92		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_1
    403  522d		       92		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_2
    404  522e		       92		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_3
    405  522f		       92		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_0
    406  5230		       92		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_1
    407  5231		       92		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_2
    408  5232		       92		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_3
    409  5233		       92		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0
    410  5234		       92		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1
    411  5235		       92		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2
    412  5236		       93		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3
    413  5237		       97		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_0
    414  5238		       97		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_1
    415  5239		       97		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_2
    416  523a		       97		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_3
    417  523b		       97		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_0
    418  523c		       97		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_1
    419  523d		       97		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_2
    420  523e		       97		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_3
    421  523f		       97		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_0
    422  5240		       98		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_1
    423  5241		       98		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_2
    424  5242		       98		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_3
    425  5243		       98		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_0
    426  5244		       98		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_1
    427  5245		       98		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_2
    428  5246		       98		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_3
    429  5247		       98		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_0
    430  5248		       98		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_1
    431  5249		       98		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_2
    432  524a		       98		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_3
    433  524b		       96		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0
    434  524c		       96		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1
    435  524d		       96		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2
    436  524e		       96		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3
    437  524f
    438  524f							; piece index equates...
    439  524f		       00 00	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_0 =	0
    440  524f		       00 01	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_1 =	1
    441  524f		       00 02	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_2 =	2
    442  524f		       00 03	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_3 =	3
    443  524f		       00 04	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_0 =	4
    444  524f		       00 05	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_1 =	5
    445  524f		       00 06	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_2 =	6
    446  524f		       00 07	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_3 =	7
    447  524f		       00 08	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0 =	8
    448  524f		       00 09	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_1 =	9
    449  524f		       00 0a	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_2 =	10
    450  524f		       00 0b	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_3 =	11
    451  524f		       00 0c	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0 =	12
    452  524f		       00 0d	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_1 =	13
    453  524f		       00 0e	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_2 =	14
    454  524f		       00 0f	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_3 =	15
    455  524f		       00 10	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_0 =	16
    456  524f		       00 11	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_1 =	17
    457  524f		       00 12	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_2 =	18
    458  524f		       00 13	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_3 =	19
    459  524f		       00 14	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0 =	20
    460  524f		       00 15	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_1 =	21
    461  524f		       00 16	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_2 =	22
    462  524f		       00 17	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_3 =	23
    463  524f		       00 18	   INDEX_WHITE_KING_on_WHITE_SQUARE_0 =	24
    464  524f		       00 19	   INDEX_WHITE_KING_on_WHITE_SQUARE_1 =	25
    465  524f		       00 1a	   INDEX_WHITE_KING_on_WHITE_SQUARE_2 =	26
    466  524f		       00 1b	   INDEX_WHITE_KING_on_WHITE_SQUARE_3 =	27
    467  524f		       00 1c	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_0 =	28
    468  524f		       00 1d	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_1 =	29
    469  524f		       00 1e	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_2 =	30
    470  524f		       00 1f	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_3 =	31
    471  524f		       00 20	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0 =	32
    472  524f		       00 21	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_1 =	33
    473  524f		       00 22	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_2 =	34
    474  524f		       00 23	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_3 =	35
    475  524f		       00 24	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_0 =	36
    476  524f		       00 25	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_1 =	37
    477  524f		       00 26	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_2 =	38
    478  524f		       00 27	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_3 =	39
    479  524f		       00 28	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_0 =	40
    480  524f		       00 29	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_1 =	41
    481  524f		       00 2a	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_2 =	42
    482  524f		       00 2b	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_3 =	43
    483  524f		       00 2c	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_0 =	44
    484  524f		       00 2d	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_1 =	45
    485  524f		       00 2e	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_2 =	46
    486  524f		       00 2f	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_3 =	47
    487  524f		       00 30	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_0 =	48
    488  524f		       00 31	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_1 =	49
    489  524f		       00 32	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_2 =	50
    490  524f		       00 33	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_3 =	51
    491  524f		       00 34	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_0 =	52
    492  524f		       00 35	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_1 =	53
    493  524f		       00 36	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_2 =	54
    494  524f		       00 37	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_3 =	55
    495  524f		       00 38	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_0 =	56
    496  524f		       00 39	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_1 =	57
    497  524f		       00 3a	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_2 =	58
    498  524f		       00 3b	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_3 =	59
    499  524f		       00 3c	   INDEX_WHITE_KING_on_BLACK_SQUARE_0 =	60
    500  524f		       00 3d	   INDEX_WHITE_KING_on_BLACK_SQUARE_1 =	61
    501  524f		       00 3e	   INDEX_WHITE_KING_on_BLACK_SQUARE_2 =	62
    502  524f		       00 3f	   INDEX_WHITE_KING_on_BLACK_SQUARE_3 =	63
    503  524f		       00 40	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_0 =	64
    504  524f		       00 41	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_1 =	65
    505  524f		       00 42	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_2 =	66
    506  524f		       00 43	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_3 =	67
    507  524f		       00 44	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_0 =	68
    508  524f		       00 45	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_1 =	69
    509  524f		       00 46	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_2 =	70
    510  524f		       00 47	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_3 =	71
    511  524f		       00 48	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_0 =	72
    512  524f		       00 49	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_1 =	73
    513  524f		       00 4a	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_2 =	74
    514  524f		       00 4b	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_3 =	75
    515  524f		       00 4c	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_0 =	76
    516  524f		       00 4d	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_1 =	77
    517  524f		       00 4e	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_2 =	78
    518  524f		       00 4f	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_3 =	79
    519  524f		       00 50	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0 =	80
    520  524f		       00 51	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_1 =	81
    521  524f		       00 52	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_2 =	82
    522  524f		       00 53	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_3 =	83
    523  524f		       00 54	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0 =	84
    524  524f		       00 55	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_1 =	85
    525  524f		       00 56	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_2 =	86
    526  524f		       00 57	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_3 =	87
    527  524f		       00 58	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_0 =	88
    528  524f		       00 59	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_1 =	89
    529  524f		       00 5a	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_2 =	90
    530  524f		       00 5b	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_3 =	91
    531  524f		       00 5c	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0 =	92
    532  524f		       00 5d	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_1 =	93
    533  524f		       00 5e	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_2 =	94
    534  524f		       00 5f	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_3 =	95
    535  524f		       00 60	   INDEX_BLACK_KING_on_WHITE_SQUARE_0 =	96
    536  524f		       00 61	   INDEX_BLACK_KING_on_WHITE_SQUARE_1 =	97
    537  524f		       00 62	   INDEX_BLACK_KING_on_WHITE_SQUARE_2 =	98
    538  524f		       00 63	   INDEX_BLACK_KING_on_WHITE_SQUARE_3 =	99
    539  524f		       00 64	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_0 =	100
    540  524f		       00 65	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_1 =	101
    541  524f		       00 66	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_2 =	102
    542  524f		       00 67	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_3 =	103
    543  524f		       00 68	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0 =	104
    544  524f		       00 69	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_1 =	105
    545  524f		       00 6a	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_2 =	106
    546  524f		       00 6b	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_3 =	107
    547  524f		       00 6c	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_0 =	108
    548  524f		       00 6d	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_1 =	109
    549  524f		       00 6e	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_2 =	110
    550  524f		       00 6f	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_3 =	111
    551  524f		       00 70	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_0 =	112
    552  524f		       00 71	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_1 =	113
    553  524f		       00 72	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_2 =	114
    554  524f		       00 73	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_3 =	115
    555  524f		       00 74	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_0 =	116
    556  524f		       00 75	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_1 =	117
    557  524f		       00 76	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_2 =	118
    558  524f		       00 77	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_3 =	119
    559  524f		       00 78	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_0 =	120
    560  524f		       00 79	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_1 =	121
    561  524f		       00 7a	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_2 =	122
    562  524f		       00 7b	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_3 =	123
    563  524f		       00 7c	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_0 =	124
    564  524f		       00 7d	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_1 =	125
    565  524f		       00 7e	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_2 =	126
    566  524f		       00 7f	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_3 =	127
    567  524f		       00 80	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_0 =	128
    568  524f		       00 81	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_1 =	129
    569  524f		       00 82	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_2 =	130
    570  524f		       00 83	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_3 =	131
    571  524f		       00 84	   INDEX_BLACK_KING_on_BLACK_SQUARE_0 =	132
    572  524f		       00 85	   INDEX_BLACK_KING_on_BLACK_SQUARE_1 =	133
    573  524f		       00 86	   INDEX_BLACK_KING_on_BLACK_SQUARE_2 =	134
    574  524f		       00 87	   INDEX_BLACK_KING_on_BLACK_SQUARE_3 =	135
    575  524f		       00 88	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_0 =	136
    576  524f		       00 89	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_1 =	137
    577  524f		       00 8a	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_2 =	138
    578  524f		       00 8b	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_3 =	139
    579  524f		       00 8c	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_0 =	140
    580  524f		       00 8d	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_1 =	141
    581  524f		       00 8e	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_2 =	142
    582  524f		       00 8f	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_3 =	143
------- FILE BANK_GENERIC@2.asm
    238  524f
    239  524f							;---------------------------------------------------------------------------------------------------
    240  524f
      0  524f					      CHECK_BANK_SIZE	"BANK_GENERIC@2"
      1  524f		       02 4f	   .TEMP      =	* - _BANK_START
 BANK_GENERIC@2 (1K) SIZE =  $24f , FREE= $1b1
      2  524f					      ECHO	"BANK_GENERIC@2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  524f				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  524f				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC@2", " size=", * - ORIGIN
      5  524f				  -	      ERR
      6  524f					      ENDIF
    242  524f
    243  524f							;---------------------------------------------------------------------------------------------------
    244  524f							;EOF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@1#3.asm LEVEL 2 PASS 4
      0  524f					      include	"BANK_GENERIC@1#3.asm"
      0  524f					      SLOT	1
      1  524f				  -	      IF	(1 < 0) || (1 > 3)
      2  524f				  -	      ECHO	"Illegal bank address/segment location", 1
      3  524f				  -	      ERR
      4  524f					      ENDIF
      5  524f				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  524f				   _BANK_SLOT SET	1 * 64
      0  524f					      NEWBANK	GENERIC_BANK_2
      1  5483 ????				      SEG	GENERIC_BANK_2
      2  5400					      ORG	_ORIGIN
      3  5400					      RORG	_BANK_ADDRESS_ORIGIN
      4  5400				   _BANK_START SET	*
      5  5400				   GENERIC_BANK_2_START SET	*
      6  5400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5400				   GENERIC_BANK_2 SET	_BANK_SLOT + _CURRENT_BANK
      8  5400				   _ORIGIN    SET	_ORIGIN + 1024
      3  5400
      4  5400							;---------------------------------------------------------------------------------------------------
      5  5400
      0  5400					      DEF	aiWriteStartPieceBlank
      1  5400				   SLOT_aiWriteStartPieceBlank SET	_BANK_SLOT
      2  5400				   BANK_aiWriteStartPieceBlank SET	SLOT_aiWriteStartPieceBlank + _CURRENT_BANK
      3  5400				   aiWriteStartPieceBlank
      4  5400				   TEMPORARY_VAR SET	Overlay
      5  5400				   TEMPORARY_OFFSET SET	0
      6  5400				   VAR_BOUNDARY_aiWriteStartPieceBlank SET	TEMPORARY_OFFSET
      7  5400				   FUNCTION_NAME SET	aiWriteStartPieceBlank
      7  5400					      SUBROUTINE
      8  5400
      0  5400					      REFER	AiStateMachine
      1  5400				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5400				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5400					      ENDIF
      0  5400					      VEND	aiWriteStartPieceBlank
      1  5400				  -	      IFNCONST	aiWriteStartPieceBlank
      2  5400				  -	      ECHO	"Incorrect VEND label", aiWriteStartPieceBlank
      3  5400				  -	      ERR
      4  5400					      ENDIF
      5  5400		       00 a2	   VAREND_aiWriteStartPieceBlank =	TEMPORARY_VAR
     11  5400
     12  5400							; Flash the piece in-place preparatory to moving it.
     13  5400							; drawDelay = flash speed
     14  5400							; drawCount = # of flashes
     15  5400
     16  5400		       a5 87		      lda	originX12
     17  5402		       85 88		      sta	cursorX12
     18  5404
     19  5404		       a9 04		      lda	#%100
     20  5406		       85 4a		      sta	CTRLPF
     21  5408		       a9 02		      lda	#2
     22  540a		       85 46		      sta	COLUP0
     23  540c
     24  540c
     25  540c		       a5 82		      lda	drawDelay
     26  540e		       f0 03		      beq	deCount
     27  5410		       c6 82		      dec	drawDelay
     28  5412		       60		      rts
     29  5413				   deCount
     30  5413
     31  5413		       a5 84		      lda	drawCount
     32  5415		       f0 0e		      beq	flashDone
     33  5417		       c6 84		      dec	drawCount
     34  5419
     35  5419		       a9 0a		      lda	#READY_TO_MOVE_FLASH
     36  541b		       85 82		      sta	drawDelay	; "getting ready to move" flash
     37  541d
     38  541d		       a5 85		      lda	fromX12
     39  541f		       85 80		      sta	squareToDraw
     40  5421
     41  5421		       20 83 f0 	      jsr	CopySinglePiece	;@0	      ; EOR-draw = flash
     42  5424		       60		      rts
     43  5425
     44  5425				   flashDone
     45  5425
      0  5425					      PHASE	AI_MarchToTargetA
      1  5425		       a9 16		      lda	#AI_MarchToTargetA
      2  5427		       85 8c		      sta	aiState
     47  5429		       60		      rts
     48  542a
     49  542a
     50  542a							;---------------------------------------------------------------------------------------------------
     51  542a
      0  542a					      DEF	aiDrawPart2
      1  542a				   SLOT_aiDrawPart2 SET	_BANK_SLOT
      2  542a				   BANK_aiDrawPart2 SET	SLOT_aiDrawPart2 + _CURRENT_BANK
      3  542a				   aiDrawPart2
      4  542a				   TEMPORARY_VAR SET	Overlay
      5  542a				   TEMPORARY_OFFSET SET	0
      6  542a				   VAR_BOUNDARY_aiDrawPart2 SET	TEMPORARY_OFFSET
      7  542a				   FUNCTION_NAME SET	aiDrawPart2
     53  542a					      SUBROUTINE
     54  542a
      0  542a					      REFER	AiStateMachine
      1  542a				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  542a				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  542a					      ENDIF
      0  542a					      VEND	aiDrawPart2
      1  542a				  -	      IFNCONST	aiDrawPart2
      2  542a				  -	      ECHO	"Incorrect VEND label", aiDrawPart2
      3  542a				  -	      ERR
      4  542a					      ENDIF
      5  542a		       00 a2	   VAREND_aiDrawPart2 =	TEMPORARY_VAR
     57  542a
     58  542a		       20 83 f0 	      jsr	CopySinglePiece	;@0
     59  542d
      0  542d					      DEF	aiDrawPart3
      1  542d				   SLOT_aiDrawPart3 SET	_BANK_SLOT
      2  542d				   BANK_aiDrawPart3 SET	SLOT_aiDrawPart3 + _CURRENT_BANK
      3  542d				   aiDrawPart3
      4  542d				   TEMPORARY_VAR SET	Overlay
      5  542d				   TEMPORARY_OFFSET SET	0
      6  542d				   VAR_BOUNDARY_aiDrawPart3 SET	TEMPORARY_OFFSET
      7  542d				   FUNCTION_NAME SET	aiDrawPart3
     61  542d					      SUBROUTINE
     62  542d
     63  542d		       c6 80		      dec	squareToDraw
     64  542f		       a5 80		      lda	squareToDraw
     65  5431		       c9 16		      cmp	#22
     66  5433		       90 05		      bcc	.comp
     67  5435
      0  5435					      PHASE	AI_DrawEntireBoard
      1  5435		       a9 0f		      lda	#AI_DrawEntireBoard
      2  5437		       85 8c		      sta	aiState
     69  5439		       60		      rts
     70  543a
     71  543a				   .comp
     72  543a
     73  543a		       a9 ff		      lda	#-1
     74  543c		       85 86		      sta	toX12	; becomes startup flash square
     75  543e		       a9 24		      lda	#36	; becomes cursor position
     76  5440		       85 87		      sta	originX12
     77  5442
     78  5442
      0  5442					      PHASE	AI_GenerateMoves
      1  5442		       a9 12		      lda	#AI_GenerateMoves
      2  5444		       85 8c		      sta	aiState
     80  5446		       60		      rts
     81  5447
     82  5447
     83  5447
     84  5447
     85  5447							;---------------------------------------------------------------------------------------------------
     86  5447
      0  5447					      DEF	aiMarchB
      1  5447				   SLOT_aiMarchB SET	_BANK_SLOT
      2  5447				   BANK_aiMarchB SET	SLOT_aiMarchB + _CURRENT_BANK
      3  5447				   aiMarchB
      4  5447				   TEMPORARY_VAR SET	Overlay
      5  5447				   TEMPORARY_OFFSET SET	0
      6  5447				   VAR_BOUNDARY_aiMarchB SET	TEMPORARY_OFFSET
      7  5447				   FUNCTION_NAME SET	aiMarchB
     88  5447					      SUBROUTINE
     89  5447
      0  5447					      REFER	AiStateMachine
      1  5447				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5447				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5447					      ENDIF
      0  5447					      VEND	aiMarchB
      1  5447				  -	      IFNCONST	aiMarchB
      2  5447				  -	      ECHO	"Incorrect VEND label", aiMarchB
      3  5447				  -	      ERR
      4  5447					      ENDIF
      5  5447		       00 a2	   VAREND_aiMarchB =	TEMPORARY_VAR
     92  5447
     93  5447							; Draw the piece in the new square
     94  5447
     95  5447		       a5 85		      lda	fromX12
     96  5449		       85 80		      sta	squareToDraw
     97  544b
     98  544b		       20 83 f0 	      jsr	CopySinglePiece	;@0	      ; draw the moving piece into the new square
     99  544e
    100  544e		       a9 06		      lda	#6	; snail trail delay
    101  5450		       85 82		      sta	drawDelay
    102  5452
      0  5452					      PHASE	AI_MarchToTargetB
      1  5452		       a9 19		      lda	#AI_MarchToTargetB
      2  5454		       85 8c		      sta	aiState
    104  5456		       60		      rts
    105  5457
    106  5457
    107  5457							;---------------------------------------------------------------------------------------------------
    108  5457
      0  5457					      DEF	aiFinalFlash
      1  5457				   SLOT_aiFinalFlash SET	_BANK_SLOT
      2  5457				   BANK_aiFinalFlash SET	SLOT_aiFinalFlash + _CURRENT_BANK
      3  5457				   aiFinalFlash
      4  5457				   TEMPORARY_VAR SET	Overlay
      5  5457				   TEMPORARY_OFFSET SET	0
      6  5457				   VAR_BOUNDARY_aiFinalFlash SET	TEMPORARY_OFFSET
      7  5457				   FUNCTION_NAME SET	aiFinalFlash
    110  5457					      SUBROUTINE
    111  5457
      0  5457					      REFER	AiStateMachine
      1  5457				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5457				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5457					      ENDIF
      0  5457					      VEND	aiFinalFlash
      1  5457				  -	      IFNCONST	aiFinalFlash
      2  5457				  -	      ECHO	"Incorrect VEND label", aiFinalFlash
      3  5457				  -	      ERR
      4  5457					      ENDIF
      5  5457		       00 a2	   VAREND_aiFinalFlash =	TEMPORARY_VAR
    114  5457
    115  5457
    116  5457		       a5 82		      lda	drawDelay
    117  5459		       f0 03		      beq	.deCount
    118  545b		       c6 82		      dec	drawDelay
    119  545d		       60		      rts
    120  545e
    121  545e		       a5 84	   .deCount   lda	drawCount
    122  5460		       f0 0e		      beq	.flashDone2
    123  5462		       c6 84		      dec	drawCount
    124  5464
    125  5464		       a9 0a		      lda	#10
    126  5466		       85 82		      sta	drawDelay	; "getting ready to move" flash
    127  5468
    128  5468		       a5 85		      lda	fromX12
    129  546a		       85 80		      sta	squareToDraw
    130  546c
    131  546c		       20 83 f0 	      jsr	CopySinglePiece	;@0
    132  546f		       60		      rts
    133  5470
    134  5470				   .flashDone2
    135  5470
    136  5470		       a9 64		      lda	#100
    137  5472		       85 8d		      sta	aiFlashDelay
    138  5474
      0  5474					      PHASE	AI_SpecialMoveFixup
      1  5474		       a9 1c		      lda	#AI_SpecialMoveFixup
      2  5476		       85 8c		      sta	aiState
    140  5478		       60		      rts
    141  5479
    142  5479
    143  5479							;---------------------------------------------------------------------------------------------------
    144  5479
      0  5479					      DEF	aiDraw
      1  5479				   SLOT_aiDraw SET	_BANK_SLOT
      2  5479				   BANK_aiDraw SET	SLOT_aiDraw + _CURRENT_BANK
      3  5479				   aiDraw
      4  5479				   TEMPORARY_VAR SET	Overlay
      5  5479				   TEMPORARY_OFFSET SET	0
      6  5479				   VAR_BOUNDARY_aiDraw SET	TEMPORARY_OFFSET
      7  5479				   FUNCTION_NAME SET	aiDraw
    146  5479					      SUBROUTINE
    147  5479		       a9 c0		      lda	#$C0
    148  547b		       85 49		      sta	COLUBK
    149  547d		       60		      rts
    150  547e
    151  547e
    152  547e							;---------------------------------------------------------------------------------------------------
    153  547e
      0  547e					      DEF	aiCheckMate
      1  547e				   SLOT_aiCheckMate SET	_BANK_SLOT
      2  547e				   BANK_aiCheckMate SET	SLOT_aiCheckMate + _CURRENT_BANK
      3  547e				   aiCheckMate
      4  547e				   TEMPORARY_VAR SET	Overlay
      5  547e				   TEMPORARY_OFFSET SET	0
      6  547e				   VAR_BOUNDARY_aiCheckMate SET	TEMPORARY_OFFSET
      7  547e				   FUNCTION_NAME SET	aiCheckMate
    155  547e					      SUBROUTINE
    156  547e		       a9 44		      lda	#$44
    157  5480		       85 49		      sta	COLUBK
    158  5482		       60		      rts
    159  5483
    160  5483							;---------------------------------------------------------------------------------------------------
    161  5483
      0  5483					      CHECK_BANK_SIZE	"BANK_GENERIC2"
      1  5483		       00 83	   .TEMP      =	* - _BANK_START
 BANK_GENERIC2 (1K) SIZE =  $83 , FREE= $37d
      2  5483					      ECHO	"BANK_GENERIC2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5483				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5483				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC2", " size=", * - ORIGIN
      5  5483				  -	      ERR
      6  5483					      ENDIF
    163  5483
    164  5483							;---------------------------------------------------------------------------------------------------
    165  5483							;EOF
------- FILE ./chess.asm
------- FILE GFX1.asm LEVEL 2 PASS 4
      0  5483					      include	"GFX1.asm"
      0  5483					      SLOT	2
      1  5483				  -	      IF	(2 < 0) || (2 > 3)
      2  5483				  -	      ECHO	"Illegal bank address/segment location", 2
      3  5483				  -	      ERR
      4  5483					      ENDIF
      5  5483				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  5483				   _BANK_SLOT SET	2 * 64
      0  5483					      NEWBANK	GFX1
      1  5bd8 ????				      SEG	GFX1
      2  5800					      ORG	_ORIGIN
      3  5800					      RORG	_BANK_ADDRESS_ORIGIN
      4  5800				   _BANK_START SET	*
      5  5800				   GFX1_START SET	*
      6  5800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5800				   GFX1       SET	_BANK_SLOT + _CURRENT_BANK
      8  5800				   _ORIGIN    SET	_ORIGIN + 1024
      3  5800
      4  5800
      5  5800							;---------------------------------------------------------------------------------------------------
      6  5800
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5800					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  5800					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_0", 72
     12  5800					      LIST	ON
      0  5800					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_0
      1  5800				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5800				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5800				   BLACK_PROMOTE_on_BLACK_SQUARE_0
      4  5800				   TEMPORARY_VAR SET	Overlay
      5  5800				   TEMPORARY_OFFSET SET	0
      6  5800				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5800				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_0
      3  5800		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5848					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  5848					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_1", 72
     12  5848					      LIST	ON
      0  5848					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_1
      1  5848				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5848				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5848				   BLACK_PROMOTE_on_BLACK_SQUARE_1
      4  5848				   TEMPORARY_VAR SET	Overlay
      5  5848				   TEMPORARY_OFFSET SET	0
      6  5848				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5848				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_1
      3  5848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5860		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5890					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  5890					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_2", 72
     12  5890					      LIST	ON
      0  5890					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_2
      1  5890				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5890				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5890				   BLACK_PROMOTE_on_BLACK_SQUARE_2
      4  5890				   TEMPORARY_VAR SET	Overlay
      5  5890				   TEMPORARY_OFFSET SET	0
      6  5890				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5890				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_2
      3  5890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  58a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  58c0		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  58d8					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  58d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_3", 72
     12  5900					      LIST	ON
      0  5900					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_3
      1  5900				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5900				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5900				   BLACK_PROMOTE_on_BLACK_SQUARE_3
      4  5900				   TEMPORARY_VAR SET	Overlay
      5  5900				   TEMPORARY_OFFSET SET	0
      6  5900				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5900				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_3
      3  5900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5930		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5948					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  5948					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_0", 72
     12  5948					      LIST	ON
      0  5948					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_0
      1  5948				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5948				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5948				   BLACK_PROMOTE_on_WHITE_SQUARE_0
      4  5948				   TEMPORARY_VAR SET	Overlay
      5  5948				   TEMPORARY_OFFSET SET	0
      6  5948				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5948				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_0
      3  5948		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$b0,$f0,$b0,$30,$70,$50,$10,$b0	;PF0
      4  5960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  5978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5990					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  5990					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_1", 72
     12  5990					      LIST	ON
      0  5990					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_1
      1  5990				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5990				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5990				   BLACK_PROMOTE_on_WHITE_SQUARE_1
      4  5990				   TEMPORARY_VAR SET	Overlay
      5  5990				   TEMPORARY_OFFSET SET	0
      6  5990				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5990				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_1
      3  5990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  59a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$6c,$7c,$6c,$64,$74,$54,$44,$6c	;PF1
      5  59c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  59d8					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  59d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_2", 72
     12  5a00					      LIST	ON
      0  5a00					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_2
      1  5a00				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5a00				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5a00				   BLACK_PROMOTE_on_WHITE_SQUARE_2
      4  5a00				   TEMPORARY_VAR SET	Overlay
      5  5a00				   TEMPORARY_OFFSET SET	0
      6  5a00				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5a00				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_2
      3  5a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$03,$03,$03,$03,$03,$02,$02,$03	;PF1
      5  5a30		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$06,$07,$06,$04,$05,$05,$04,$06	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5a48					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  5a48					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_3", 72
     12  5a48					      LIST	ON
      0  5a48					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_3
      1  5a48				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5a48				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5a48				   BLACK_PROMOTE_on_WHITE_SQUARE_3
      4  5a48				   TEMPORARY_VAR SET	Overlay
      5  5a48				   TEMPORARY_OFFSET SET	0
      6  5a48				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5a48				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_3
      3  5a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5a78		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$d8,$f8,$d8,$98,$b8,$a8,$88,$d8	;PF2
------- FILE GFX1.asm
     15  5a90
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5a90					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm"
      0  5a90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_0", 72
     12  5a90					      LIST	ON
      0  5a90					      DEF	WHITE_MARKER_on_BLACK_SQUARE_0
      1  5a90				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5a90				   BANK_WHITE_MARKER_on_BLACK_SQUARE_0 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5a90				   WHITE_MARKER_on_BLACK_SQUARE_0
      4  5a90				   TEMPORARY_VAR SET	Overlay
      5  5a90				   TEMPORARY_OFFSET SET	0
      6  5a90				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5a90				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_0
      3  5a90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$e0,$e0,$e0,$e0,$e0,$00,$00,$00,$e0,$e0,$e0,$e0,$e0,$00,$00	;PF0
      4  5aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5ad8					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm"
      0  5ad8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_1", 72
     12  5b00					      LIST	ON
      0  5b00					      DEF	WHITE_MARKER_on_BLACK_SQUARE_1
      1  5b00				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5b00				   BANK_WHITE_MARKER_on_BLACK_SQUARE_1 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5b00				   WHITE_MARKER_on_BLACK_SQUARE_1
      4  5b00				   TEMPORARY_VAR SET	Overlay
      5  5b00				   TEMPORARY_OFFSET SET	0
      6  5b00				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5b00				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_1
      3  5b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5b18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$38,$38,$38,$38,$38,$00,$00,$00,$38,$38,$38,$38,$38,$00,$00	;PF1
      5  5b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5b48					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm"
      0  5b48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_2", 72
     12  5b48					      LIST	ON
      0  5b48					      DEF	WHITE_MARKER_on_BLACK_SQUARE_2
      1  5b48				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5b48				   BANK_WHITE_MARKER_on_BLACK_SQUARE_2 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5b48				   WHITE_MARKER_on_BLACK_SQUARE_2
      4  5b48				   TEMPORARY_VAR SET	Overlay
      5  5b48				   TEMPORARY_OFFSET SET	0
      6  5b48				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5b48				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_2
      3  5b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5b60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$00,$00,$00,$01,$01,$01,$01,$01,$00,$00	;PF1
      5  5b78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$00,$00,$00,$03,$03,$03,$03,$03,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5b90					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm"
      0  5b90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_3", 72
     12  5b90					      LIST	ON
      0  5b90					      DEF	WHITE_MARKER_on_BLACK_SQUARE_3
      1  5b90				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5b90				   BANK_WHITE_MARKER_on_BLACK_SQUARE_3 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5b90				   WHITE_MARKER_on_BLACK_SQUARE_3
      4  5b90				   TEMPORARY_VAR SET	Overlay
      5  5b90				   TEMPORARY_OFFSET SET	0
      6  5b90				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5b90				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_3
      3  5b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5bc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$70,$70,$70,$70,$70,$00,$00,$00,$70,$70,$70,$70,$70,$00,$00	;PF2
------- FILE GFX1.asm
     20  5bd8
     21  5bd8
     22  5bd8							;---------------------------------------------------------------------------------------------------
     23  5bd8
      0  5bd8					      CHECK_BANK_SIZE	"BANK_GFX1"
      1  5bd8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX1 (1K) SIZE =  $3d8 , FREE= $28
      2  5bd8					      ECHO	"BANK_GFX1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5bd8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX1", " size=", * - ORIGIN
      5  5bd8				  -	      ERR
      6  5bd8					      ENDIF
     25  5bd8
     26  5bd8							;---------------------------------------------------------------------------------------------------
     27  5bd8							;EOF
------- FILE ./chess.asm
------- FILE GFX2.asm LEVEL 2 PASS 4
      0  5bd8					      include	"GFX2.asm"
      0  5bd8					      SLOT	2
      1  5bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  5bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  5bd8				  -	      ERR
      4  5bd8					      ENDIF
      5  5bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  5bd8				   _BANK_SLOT SET	2 * 64
      0  5bd8					      NEWBANK	GFX2
      1  5fd8 ????				      SEG	GFX2
      2  5c00					      ORG	_ORIGIN
      3  5c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  5c00				   _BANK_START SET	*
      5  5c00				   GFX2_START SET	*
      6  5c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5c00				   GFX2       SET	_BANK_SLOT + _CURRENT_BANK
      8  5c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  5c00
      4  5c00							;---------------------------------------------------------------------------------------------------
      5  5c00
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5c00					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm"
      0  5c00					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_0", 72
     12  5c00					      LIST	ON
      0  5c00					      DEF	WHITE_MARKER_on_WHITE_SQUARE_0
      1  5c00				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5c00				   BANK_WHITE_MARKER_on_WHITE_SQUARE_0 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5c00				   WHITE_MARKER_on_WHITE_SQUARE_0
      4  5c00				   TEMPORARY_VAR SET	Overlay
      5  5c00				   TEMPORARY_OFFSET SET	0
      6  5c00				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5c00				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_0
      3  5c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$e0,$e0,$e0,$e0,$e0,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  5c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  5c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5c48					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm"
      0  5c48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_1", 72
     12  5c48					      LIST	ON
      0  5c48					      DEF	WHITE_MARKER_on_WHITE_SQUARE_1
      1  5c48				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5c48				   BANK_WHITE_MARKER_on_WHITE_SQUARE_1 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5c48				   WHITE_MARKER_on_WHITE_SQUARE_1
      4  5c48				   TEMPORARY_VAR SET	Overlay
      5  5c48				   TEMPORARY_OFFSET SET	0
      6  5c48				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5c48				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_1
      3  5c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5c60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$38,$38,$38,$38,$38,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  5c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5c90					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm"
      0  5c90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_2", 72
     12  5c90					      LIST	ON
      0  5c90					      DEF	WHITE_MARKER_on_WHITE_SQUARE_2
      1  5c90				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5c90				   BANK_WHITE_MARKER_on_WHITE_SQUARE_2 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5c90				   WHITE_MARKER_on_WHITE_SQUARE_2
      4  5c90				   TEMPORARY_VAR SET	Overlay
      5  5c90				   TEMPORARY_OFFSET SET	0
      6  5c90				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5c90				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_2
      3  5c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  5cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE GFX2.asm
      9  5cd8
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5cd8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm"
      0  5cd8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_0", 72
     12  5d00					      LIST	ON
      0  5d00					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_0
      1  5d00				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5d00				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5d00				   BLACK_BISHOP_on_BLACK_SQUARE_0
      4  5d00				   TEMPORARY_VAR SET	Overlay
      5  5d00				   TEMPORARY_OFFSET SET	0
      6  5d00				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5d00				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_0
      3  5d00		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$40,$00	;PF0
      4  5d18		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5d48					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm"
      0  5d48					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_1", 72
     12  5d48					      LIST	ON
      0  5d48					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_1
      1  5d48				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5d48				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5d48				   BLACK_BISHOP_on_BLACK_SQUARE_1
      4  5d48				   TEMPORARY_VAR SET	Overlay
      5  5d48				   TEMPORARY_OFFSET SET	0
      6  5d48				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5d48				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_1
      3  5d48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5d60		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$00,$00,$00,$10,$00	;PF1
      5  5d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5d90					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm"
      0  5d90					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_2", 72
     12  5d90					      LIST	ON
      0  5d90					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_2
      1  5d90				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5d90				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5d90				   BLACK_BISHOP_on_BLACK_SQUARE_2
      4  5d90				   TEMPORARY_VAR SET	Overlay
      5  5d90				   TEMPORARY_OFFSET SET	0
      6  5d90				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5d90				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_2
      3  5d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5da8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5dc0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$00,$00,$00,$01,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5dd8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm"
      0  5dd8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_3", 72
     12  5e00					      LIST	ON
      0  5e00					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_3
      1  5e00				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5e00				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5e00				   BLACK_BISHOP_on_BLACK_SQUARE_3
      4  5e00				   TEMPORARY_VAR SET	Overlay
      5  5e00				   TEMPORARY_OFFSET SET	0
      6  5e00				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5e00				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_3
      3  5e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5e18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5e30		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$00,$00,$00,$20,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5e48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm"
      0  5e48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_0", 72
     12  5e48					      LIST	ON
      0  5e48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_0
      1  5e48				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5e48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5e48				   BLACK_ROOK_on_BLACK_SQUARE_0
      4  5e48				   TEMPORARY_VAR SET	Overlay
      5  5e48				   TEMPORARY_OFFSET SET	0
      6  5e48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5e48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_0
      3  5e48		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$a0,$00,$00	;PF0
      4  5e60		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5e78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5e90					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm"
      0  5e90					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_1", 72
     12  5e90					      LIST	ON
      0  5e90					      DEF	BLACK_ROOK_on_BLACK_SQUARE_1
      1  5e90				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5e90				   BANK_BLACK_ROOK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5e90				   BLACK_ROOK_on_BLACK_SQUARE_1
      4  5e90				   TEMPORARY_VAR SET	Overlay
      5  5e90				   TEMPORARY_OFFSET SET	0
      6  5e90				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5e90				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_1
      3  5e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ea8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$28,$00,$00	;PF1
      5  5ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5ed8					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm"
      0  5ed8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_2", 72
     12  5f00					      LIST	ON
      0  5f00					      DEF	BLACK_ROOK_on_BLACK_SQUARE_2
      1  5f00				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5f00				   BANK_BLACK_ROOK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5f00				   BLACK_ROOK_on_BLACK_SQUARE_2
      4  5f00				   TEMPORARY_VAR SET	Overlay
      5  5f00				   TEMPORARY_OFFSET SET	0
      6  5f00				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5f00				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_2
      3  5f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5f18		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF1
      5  5f30		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$02,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5f48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm"
      0  5f48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_3", 72
     12  5f48					      LIST	ON
      0  5f48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_3
      1  5f48				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5f48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5f48				   BLACK_ROOK_on_BLACK_SQUARE_3
      4  5f48				   TEMPORARY_VAR SET	Overlay
      5  5f48				   TEMPORARY_OFFSET SET	0
      6  5f48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5f48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_3
      3  5f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5f78		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00	;PF2
------- FILE GFX2.asm
     18  5f90
     19  5f90
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5f90					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm"
      0  5f90					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_0", 72
     12  5f90					      LIST	ON
      0  5f90					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_0
      1  5f90				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5f90				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5f90				   BLACK_QUEEN_on_BLACK_SQUARE_0
      4  5f90				   TEMPORARY_VAR SET	Overlay
      5  5f90				   TEMPORARY_OFFSET SET	0
      6  5f90				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5f90				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_0
      3  5f90		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5fa8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5fc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
     21  5fd8
     22  5fd8
     23  5fd8							;---------------------------------------------------------------------------------------------------
     24  5fd8
      0  5fd8					      CHECK_BANK_SIZE	"BANK_GFX2"
      1  5fd8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX2 (1K) SIZE =  $3d8 , FREE= $28
      2  5fd8					      ECHO	"BANK_GFX2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5fd8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX2", " size=", * - ORIGIN
      5  5fd8				  -	      ERR
      6  5fd8					      ENDIF
     26  5fd8
     27  5fd8							;---------------------------------------------------------------------------------------------------
     28  5fd8							;EOF
------- FILE ./chess.asm
------- FILE GFX3.asm LEVEL 2 PASS 4
      0  5fd8					      include	"GFX3.asm"
      0  5fd8					      SLOT	2
      1  5fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  5fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  5fd8				  -	      ERR
      4  5fd8					      ENDIF
      5  5fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  5fd8				   _BANK_SLOT SET	2 * 64
      0  5fd8					      NEWBANK	GFX3
      1  63d8 ????				      SEG	GFX3
      2  6000					      ORG	_ORIGIN
      3  6000					      RORG	_BANK_ADDRESS_ORIGIN
      4  6000				   _BANK_START SET	*
      5  6000				   GFX3_START SET	*
      6  6000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6000				   GFX3       SET	_BANK_SLOT + _CURRENT_BANK
      8  6000				   _ORIGIN    SET	_ORIGIN + 1024
      3  6000
      4  6000							;---------------------------------------------------------------------------------------------------
      5  6000
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  6000					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm"
      0  6000					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_1", 72
     12  6000					      LIST	ON
      0  6000					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_1
      1  6000				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  6000				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  6000				   BLACK_QUEEN_on_BLACK_SQUARE_1
      4  6000				   TEMPORARY_VAR SET	Overlay
      5  6000				   TEMPORARY_OFFSET SET	0
      6  6000				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  6000				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_1
      3  6000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6018		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
      7  6048
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  6048					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm"
      0  6048					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_2", 72
     12  6048					      LIST	ON
      0  6048					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_2
      1  6048				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  6048				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  6048				   BLACK_QUEEN_on_BLACK_SQUARE_2
      4  6048				   TEMPORARY_VAR SET	Overlay
      5  6048				   TEMPORARY_OFFSET SET	0
      6  6048				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  6048				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_2
      3  6048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6060		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6078		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  6090					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm"
      0  6090					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_3", 72
     12  6090					      LIST	ON
      0  6090					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_3
      1  6090				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  6090				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  6090				   BLACK_QUEEN_on_BLACK_SQUARE_3
      4  6090				   TEMPORARY_VAR SET	Overlay
      5  6090				   TEMPORARY_OFFSET SET	0
      6  6090				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  6090				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_3
      3  6090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  60a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  60c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     10  60d8
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  60d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_0.asm"
      0  60d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_0", 72
     12  6100					      LIST	ON
      0  6100					      DEF	BLACK_KING_on_BLACK_SQUARE_0
      1  6100				   SLOT_BLACK_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  6100				   BANK_BLACK_KING_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  6100				   BLACK_KING_on_BLACK_SQUARE_0
      4  6100				   TEMPORARY_VAR SET	Overlay
      5  6100				   TEMPORARY_OFFSET SET	0
      6  6100				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  6100				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_0
      3  6100		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6118		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6130		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  6148					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_1.asm"
      0  6148					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_1", 72
     12  6148					      LIST	ON
      0  6148					      DEF	BLACK_KING_on_BLACK_SQUARE_1
      1  6148				   SLOT_BLACK_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  6148				   BANK_BLACK_KING_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  6148				   BLACK_KING_on_BLACK_SQUARE_1
      4  6148				   TEMPORARY_VAR SET	Overlay
      5  6148				   TEMPORARY_OFFSET SET	0
      6  6148				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  6148				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_1
      3  6148		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6160		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  6190					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_2.asm"
      0  6190					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_2", 72
     12  6190					      LIST	ON
      0  6190					      DEF	BLACK_KING_on_BLACK_SQUARE_2
      1  6190				   SLOT_BLACK_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  6190				   BANK_BLACK_KING_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  6190				   BLACK_KING_on_BLACK_SQUARE_2
      4  6190				   TEMPORARY_VAR SET	Overlay
      5  6190				   TEMPORARY_OFFSET SET	0
      6  6190				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  6190				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_2
      3  6190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  61a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  61c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  61d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_3.asm"
      0  61d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_3", 72
     12  6200					      LIST	ON
      0  6200					      DEF	BLACK_KING_on_BLACK_SQUARE_3
      1  6200				   SLOT_BLACK_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  6200				   BANK_BLACK_KING_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  6200				   BLACK_KING_on_BLACK_SQUARE_3
      4  6200				   TEMPORARY_VAR SET	Overlay
      5  6200				   TEMPORARY_OFFSET SET	0
      6  6200				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  6200				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_3
      3  6200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6218		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6230		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     15  6248
     16  6248
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  6248					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm"
      0  6248					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_3", 72
     12  6248					      LIST	ON
      0  6248					      DEF	WHITE_MARKER_on_WHITE_SQUARE_3
      1  6248				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  6248				   BANK_WHITE_MARKER_on_WHITE_SQUARE_3 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  6248				   WHITE_MARKER_on_WHITE_SQUARE_3
      4  6248				   TEMPORARY_VAR SET	Overlay
      5  6248				   TEMPORARY_OFFSET SET	0
      6  6248				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  6248				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_3
      3  6248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6278		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$70,$70,$70,$70,$70,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE GFX3.asm
     18  6290
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  6290					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
      0  6290					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_0", 72
     12  6290					      LIST	ON
      0  6290					      DEF	BLACK_MARKER_on_BLACK_SQUARE_0
      1  6290				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  6290				   BANK_BLACK_MARKER_on_BLACK_SQUARE_0 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  6290				   BLACK_MARKER_on_BLACK_SQUARE_0
      4  6290				   TEMPORARY_VAR SET	Overlay
      5  6290				   TEMPORARY_OFFSET SET	0
      6  6290				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  6290				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_0
      3  6290		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  62a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  62c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  62d8					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
      0  62d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_1", 72
     12  6300					      LIST	ON
      0  6300					      DEF	BLACK_MARKER_on_BLACK_SQUARE_1
      1  6300				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  6300				   BANK_BLACK_MARKER_on_BLACK_SQUARE_1 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  6300				   BLACK_MARKER_on_BLACK_SQUARE_1
      4  6300				   TEMPORARY_VAR SET	Overlay
      5  6300				   TEMPORARY_OFFSET SET	0
      6  6300				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  6300				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_1
      3  6300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6318		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  6348					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
      0  6348					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_2", 72
     12  6348					      LIST	ON
      0  6348					      DEF	BLACK_MARKER_on_BLACK_SQUARE_2
      1  6348				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  6348				   BANK_BLACK_MARKER_on_BLACK_SQUARE_2 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  6348				   BLACK_MARKER_on_BLACK_SQUARE_2
      4  6348				   TEMPORARY_VAR SET	Overlay
      5  6348				   TEMPORARY_OFFSET SET	0
      6  6348				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  6348				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_2
      3  6348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6378		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  6390					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
      0  6390					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_3", 72
     12  6390					      LIST	ON
      0  6390					      DEF	BLACK_MARKER_on_BLACK_SQUARE_3
      1  6390				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  6390				   BANK_BLACK_MARKER_on_BLACK_SQUARE_3 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  6390				   BLACK_MARKER_on_BLACK_SQUARE_3
      4  6390				   TEMPORARY_VAR SET	Overlay
      5  6390				   TEMPORARY_OFFSET SET	0
      6  6390				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  6390				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_3
      3  6390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  63a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  63c0		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     23  63d8
     24  63d8							;---------------------------------------------------------------------------------------------------
     25  63d8
      0  63d8					      CHECK_BANK_SIZE	"BANK_GFX3"
      1  63d8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX3 (1K) SIZE =  $3d8 , FREE= $28
      2  63d8					      ECHO	"BANK_GFX3", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  63d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  63d8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX3", " size=", * - ORIGIN
      5  63d8				  -	      ERR
      6  63d8					      ENDIF
     27  63d8
     28  63d8							;---------------------------------------------------------------------------------------------------
     29  63d8							;EOF
------- FILE ./chess.asm
------- FILE GFX4.asm LEVEL 2 PASS 4
      0  63d8					      include	"GFX4.asm"
      0  63d8					      SLOT	2
      1  63d8				  -	      IF	(2 < 0) || (2 > 3)
      2  63d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  63d8				  -	      ERR
      4  63d8					      ENDIF
      5  63d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  63d8				   _BANK_SLOT SET	2 * 64
      0  63d8					      NEWBANK	GFX4
      1  67d8 ????				      SEG	GFX4
      2  6400					      ORG	_ORIGIN
      3  6400					      RORG	_BANK_ADDRESS_ORIGIN
      4  6400				   _BANK_START SET	*
      5  6400				   GFX4_START SET	*
      6  6400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6400				   GFX4       SET	_BANK_SLOT + _CURRENT_BANK
      8  6400				   _ORIGIN    SET	_ORIGIN + 1024
      3  6400
      4  6400							;---------------------------------------------------------------------------------------------------
      5  6400
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  6400					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
      0  6400					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_0", 72
     12  6400					      LIST	ON
      0  6400					      DEF	BLACK_MARKER_on_WHITE_SQUARE_0
      1  6400				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  6400				   BANK_BLACK_MARKER_on_WHITE_SQUARE_0 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  6400				   BLACK_MARKER_on_WHITE_SQUARE_0
      4  6400				   TEMPORARY_VAR SET	Overlay
      5  6400				   TEMPORARY_OFFSET SET	0
      6  6400				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  6400				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_0
      3  6400		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$f0,$f0,$f0,$b0,$b0,$f0,$f0,$f0	;PF0
      4  6418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  6430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  6448					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
      0  6448					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_1", 72
     12  6448					      LIST	ON
      0  6448					      DEF	BLACK_MARKER_on_WHITE_SQUARE_1
      1  6448				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  6448				   BANK_BLACK_MARKER_on_WHITE_SQUARE_1 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  6448				   BLACK_MARKER_on_WHITE_SQUARE_1
      4  6448				   TEMPORARY_VAR SET	Overlay
      5  6448				   TEMPORARY_OFFSET SET	0
      6  6448				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  6448				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_1
      3  6448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6460		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$7c,$7c,$7c,$6c,$6c,$7c,$7c,$7c	;PF1
      5  6478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  6490					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
      0  6490					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_2", 72
     12  6490					      LIST	ON
      0  6490					      DEF	BLACK_MARKER_on_WHITE_SQUARE_2
      1  6490				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  6490				   BANK_BLACK_MARKER_on_WHITE_SQUARE_2 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  6490				   BLACK_MARKER_on_WHITE_SQUARE_2
      4  6490				   TEMPORARY_VAR SET	Overlay
      5  6490				   TEMPORARY_OFFSET SET	0
      6  6490				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  6490				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_2
      3  6490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  64a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  64c0		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$07,$07,$07,$06,$06,$07,$07,$07	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  64d8					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
      0  64d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_3", 72
     12  6500					      LIST	ON
      0  6500					      DEF	BLACK_MARKER_on_WHITE_SQUARE_3
      1  6500				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  6500				   BANK_BLACK_MARKER_on_WHITE_SQUARE_3 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  6500				   BLACK_MARKER_on_WHITE_SQUARE_3
      4  6500				   TEMPORARY_VAR SET	Overlay
      5  6500				   TEMPORARY_OFFSET SET	0
      6  6500				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  6500				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_3
      3  6500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6530		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$f8,$f8,$f8,$d8,$d8,$f8,$f8,$f8	;PF2
------- FILE GFX4.asm
     10  6548
     11  6548
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  6548					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  6548					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_0", 72
     12  6548					      LIST	ON
      0  6548					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_0
      1  6548				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  6548				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  6548				   WHITE_PROMOTE_on_BLACK_SQUARE_0
      4  6548				   TEMPORARY_VAR SET	Overlay
      5  6548				   TEMPORARY_OFFSET SET	0
      6  6548				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  6548				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_0
      3  6548		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  6560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  6590					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  6590					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_1", 72
     12  6590					      LIST	ON
      0  6590					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_1
      1  6590				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  6590				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  6590				   WHITE_PROMOTE_on_BLACK_SQUARE_1
      4  6590				   TEMPORARY_VAR SET	Overlay
      5  6590				   TEMPORARY_OFFSET SET	0
      6  6590				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  6590				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_1
      3  6590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  65a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  65c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  65d8					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  65d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_2", 72
     12  6600					      LIST	ON
      0  6600					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_2
      1  6600				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  6600				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  6600				   WHITE_PROMOTE_on_BLACK_SQUARE_2
      4  6600				   TEMPORARY_VAR SET	Overlay
      5  6600				   TEMPORARY_OFFSET SET	0
      6  6600				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  6600				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_2
      3  6600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  6630		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  6648					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  6648					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_3", 72
     12  6648					      LIST	ON
      0  6648					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_3
      1  6648				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  6648				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  6648				   WHITE_PROMOTE_on_BLACK_SQUARE_3
      4  6648				   TEMPORARY_VAR SET	Overlay
      5  6648				   TEMPORARY_OFFSET SET	0
      6  6648				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  6648				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_3
      3  6648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6678		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  6690					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  6690					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_0", 72
     12  6690					      LIST	ON
      0  6690					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_0
      1  6690				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  6690				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  6690				   WHITE_PROMOTE_on_WHITE_SQUARE_0
      4  6690				   TEMPORARY_VAR SET	Overlay
      5  6690				   TEMPORARY_OFFSET SET	0
      6  6690				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  6690				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_0
      3  6690		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  66a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  66c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  66d8					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  66d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_1", 72
     12  6700					      LIST	ON
      0  6700					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_1
      1  6700				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  6700				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  6700				   WHITE_PROMOTE_on_WHITE_SQUARE_1
      4  6700				   TEMPORARY_VAR SET	Overlay
      5  6700				   TEMPORARY_OFFSET SET	0
      6  6700				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  6700				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_1
      3  6700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6718		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  6730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  6748					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  6748					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_2", 72
     12  6748					      LIST	ON
      0  6748					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_2
      1  6748				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  6748				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  6748				   WHITE_PROMOTE_on_WHITE_SQUARE_2
      4  6748				   TEMPORARY_VAR SET	Overlay
      5  6748				   TEMPORARY_OFFSET SET	0
      6  6748				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  6748				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_2
      3  6748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6760		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  6778		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  6790					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  6790					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_3", 72
     12  6790					      LIST	ON
      0  6790					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_3
      1  6790				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  6790				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  6790				   WHITE_PROMOTE_on_WHITE_SQUARE_3
      4  6790				   TEMPORARY_VAR SET	Overlay
      5  6790				   TEMPORARY_OFFSET SET	0
      6  6790				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  6790				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_3
      3  6790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  67a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  67c0		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE GFX4.asm
     20  67d8
     21  67d8
     22  67d8							;---------------------------------------------------------------------------------------------------
     23  67d8
      0  67d8					      CHECK_BANK_SIZE	"BANK_GFX4"
      1  67d8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX4 (1K) SIZE =  $3d8 , FREE= $28
      2  67d8					      ECHO	"BANK_GFX4", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  67d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  67d8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX4", " size=", * - ORIGIN
      5  67d8				  -	      ERR
      6  67d8					      ENDIF
     25  67d8
     26  67d8							;---------------------------------------------------------------------------------------------------
     27  67d8							;EOF
------- FILE ./chess.asm
------- FILE NEGAMAX.asm LEVEL 2 PASS 4
      0  67d8					      include	"NEGAMAX.asm"
      1  67d8							; Chess
      2  67d8							; Copyright (c) 2019-2020 Andrew Davie
      3  67d8							; andrew@taswegian.com
      4  67d8
      0  67d8					      SLOT	1	; this code assembles for bank #1
      1  67d8				  -	      IF	(1 < 0) || (1 > 3)
      2  67d8				  -	      ECHO	"Illegal bank address/segment location", 1
      3  67d8				  -	      ERR
      4  67d8					      ENDIF
      5  67d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  67d8				   _BANK_SLOT SET	1 * 64
      0  67d8					      NEWBANK	NEGAMAX
      1  693b ????				      SEG	NEGAMAX
      2  6800					      ORG	_ORIGIN
      3  6800					      RORG	_BANK_ADDRESS_ORIGIN
      4  6800				   _BANK_START SET	*
      5  6800				   NEGAMAX_START SET	*
      6  6800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6800				   NEGAMAX    SET	_BANK_SLOT + _CURRENT_BANK
      8  6800				   _ORIGIN    SET	_ORIGIN + 1024
      7  6800
      8  6800							;---------------------------------------------------------------------------------------------------
      9  6800
     10  6800							;function negaMax(node, depth, α, β, color) is
     11  6800							;    if depth = 0 or node is a terminal node then
     12  6800							;	  return color × the heuristic value of node
     13  6800
     14  6800							;    childNodes := generateMoves(node)
     15  6800							;    childNodes := orderMoves(childNodes)
     16  6800							;    value := −∞
     17  6800							;    foreach child in childNodes do
     18  6800							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
     19  6800							;	  α := max(α, value)
     20  6800							;	  if α ≥ β then
     21  6800							;	      break (* cut-off *)
     22  6800							;    return value
     23  6800							;(* Initial call for Player A's root node *)
     24  6800							;negaMax(rootNode, depth, −∞, +∞, 1)
     25  6800
     26  6800
     27  6800					      SUBROUTINE
     28  6800
     29  6800		       a9 ff	   .doQ       lda	#-1
     30  6802		       85 ad		      sta	__quiesceCapOnly
     31  6804		       20 49 f5 	      jsr	quiesce
     32  6807		       e6 ad		      inc	__quiesceCapOnly
     33  6809		       60		      rts
     34  680a
     35  680a
      0  680a				   .exit      lda@PLY	value
      1  680a		       ad a5 ff 	      lda	value
     37  680d		       85 a9		      sta	__negaMax
      0  680f					      lda@PLY	value+1
      1  680f		       ad a6 ff 	      lda	value+1
     39  6812		       85 aa		      sta	__negaMax+1
     40  6814		       60		      rts
     41  6815
     42  6815
     43  6815		       c9 00	   .terminal  cmp	#0	; captured piece
     44  6817		       d0 e7		      bne	.doQ	; last move was capture, so quiesce
     45  6819
     46  6819
     47  6819				  -	      IF	0
     48  6819				  -			; king moves will also quiesce
     49  6819				  -			; theory is - we need to see if it was an illegal move
     50  6819				  -
     51  6819				  -	      lda	fromPiece
     52  6819				  -	      and	#PIECE_MASK
     53  6819				  -	      cmp	#KING
     54  6819				  -	      beq	.doQ
     55  6819					      ENDIF
     56  6819
     57  6819		       a5 90		      lda	Evaluation
     58  681b		       85 a9		      sta	__negaMax
     59  681d		       a5 91		      lda	Evaluation+1
     60  681f		       85 aa		      sta	__negaMax+1
     61  6821
     62  6821		       60	   .inCheck2  rts
     63  6822
     64  6822
     65  6822
      0  6822					      DEF	negaMax
      1  6822				   SLOT_negaMax SET	_BANK_SLOT
      2  6822				   BANK_negaMax SET	SLOT_negaMax + _CURRENT_BANK
      3  6822				   negaMax
      4  6822				   TEMPORARY_VAR SET	Overlay
      5  6822				   TEMPORARY_OFFSET SET	0
      6  6822				   VAR_BOUNDARY_negaMax SET	TEMPORARY_OFFSET
      7  6822				   FUNCTION_NAME SET	negaMax
     67  6822
     68  6822							; PARAMS depth-1, -beta, -alpha
     69  6822							; pased through temporary variables (__alpha, __beta) and X reg
     70  6822
     71  6822							; pass...
     72  6822							; x = depthleft
     73  6822							; a = captured piece
     74  6822							; SET_BANK_RAM      --> current ply
     75  6822							; __alpha[2] = param alpha
     76  6822							; __beta[2] = param beta
     77  6822
     78  6822
      0  6822					      COMMON_VARS_ALPHABETA
      1  6822
      0  6822					      VAR	__thinkbar, 1
      1  6822		       00 a2	   __thinkbar =	TEMPORARY_VAR
      2  6822				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6822
      4  6822				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6822				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6822				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6822					      ENDIF
      8  6822				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6822				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  6822				  -	      ERR
     11  6822					      ENDIF
     12  6822					      LIST	ON
      0  6822					      VAR	__toggle, 1
      1  6822		       00 a3	   __toggle   =	TEMPORARY_VAR
      2  6822				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6822
      4  6822				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6822				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6822				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6822					      ENDIF
      8  6822				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6822				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  6822				  -	      ERR
     11  6822					      ENDIF
     12  6822					      LIST	ON
      4  6822
      0  6822					      VAR	__bestMove, 1
      1  6822		       00 a4	   __bestMove =	TEMPORARY_VAR
      2  6822				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6822
      4  6822				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6822				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6822				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6822					      ENDIF
      8  6822				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6822				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  6822				  -	      ERR
     11  6822					      ENDIF
     12  6822					      LIST	ON
      0  6822					      VAR	__alpha, 2
      1  6822		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  6822				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6822
      4  6822				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6822				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6822				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6822					      ENDIF
      8  6822				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6822				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  6822				  -	      ERR
     11  6822					      ENDIF
     12  6822					      LIST	ON
      0  6822					      VAR	__beta, 2
      1  6822		       00 a7	   __beta     =	TEMPORARY_VAR
      2  6822				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6822
      4  6822				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6822				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6822				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6822					      ENDIF
      8  6822				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6822				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  6822				  -	      ERR
     11  6822					      ENDIF
     12  6822					      LIST	ON
      0  6822					      VAR	__negaMax, 2
      1  6822		       00 a9	   __negaMax  =	TEMPORARY_VAR
      2  6822				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6822
      4  6822				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6822				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6822				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6822					      ENDIF
      8  6822				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6822				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  6822				  -	      ERR
     11  6822					      ENDIF
     12  6822					      LIST	ON
      0  6822					      VAR	__value, 2
      1  6822		       00 ab	   __value    =	TEMPORARY_VAR
      2  6822				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6822
      4  6822				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6822				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6822				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6822					      ENDIF
      8  6822				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6822				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  6822				  -	      ERR
     11  6822					      ENDIF
     12  6822					      LIST	ON
     10  6822
      0  6822					      VAR	__quiesceCapOnly, 1
      1  6822		       00 ad	   __quiesceCapOnly =	TEMPORARY_VAR
      2  6822				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6822
      4  6822				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6822				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6822				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6822					      ENDIF
      8  6822				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6822				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  6822				  -	      ERR
     11  6822					      ENDIF
     12  6822					      LIST	ON
     12  6822
      0  6822					      REFER	selectmove
      1  6822				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  6822				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  6822					      ENDIF
      0  6822					      VEND	negaMax
      1  6822				  -	      IFNCONST	negaMax
      2  6822				  -	      ECHO	"Incorrect VEND label", negaMax
      3  6822				  -	      ERR
      4  6822					      ENDIF
      5  6822		       00 ae	   VAREND_negaMax =	TEMPORARY_VAR
     82  6822
     83  6822		       48		      pha
     84  6823
      0  6823					      CALL	ThinkBar
      1  6823				  -	      IF	SLOT_ThinkBar == _BANK_SLOT
      2  6823				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  6823				  -	      ECHO	"Cannot switch bank in use for", ThinkBar
      4  6823				  -	      ERR
      5  6823					      ENDIF
      6  6823		       a9 00		      lda	#BANK_ThinkBar
      7  6825		       85 3f		      sta	SET_BANK
      8  6827		       20 5e f0 	      jsr	ThinkBar
     86  682a		       a5 95		      lda	currentPly
     87  682c		       85 3e		      sta	SET_BANK_RAM
     88  682e
     89  682e		       68		      pla
     90  682f		       ca		      dex
     91  6830		       30 e3		      bmi	.terminal
      0  6832					      stx@PLY	depthLeft
      1  6832		       8e a7 01 	      stx	[RAM]+depthLeft
     93  6835
     94  6835
     95  6835							; Allow the player to force computer to select a move. Press the SELECT switch
     96  6835							; This may have issues if no move has been selected yet. Still... if you wanna cheat....
     97  6835
     98  6835		       ad 82 02 	      lda	SWCHB
     99  6838		       29 02		      and	#2
    100  683a		       f0 ce		      beq	.exit	; SELECT abort
    101  683c		       85 48		      sta	COLUPF	; grey thinkbars
    102  683e
    103  683e		       a5 a5		      lda	__alpha
      0  6840					      sta@PLY	alpha
      1  6840		       8d a1 01 	      sta	[RAM]+alpha
    105  6843		       a5 a6		      lda	__alpha+1
      0  6845					      sta@PLY	alpha+1
      1  6845		       8d a2 01 	      sta	[RAM]+alpha+1
    107  6848
    108  6848		       a5 a7		      lda	__beta
      0  684a					      sta@PLY	beta
      1  684a		       8d a3 01 	      sta	[RAM]+beta
    110  684d		       a5 a8		      lda	__beta+1
      0  684f					      sta@PLY	beta+1
      1  684f		       8d a4 01 	      sta	[RAM]+beta+1
    112  6852
    113  6852
    114  6852					      IF	1
    115  6852		       a5 90		      lda	Evaluation
    116  6854		       65 a1		      adc	randomness
    117  6856		       85 90		      sta	Evaluation
    118  6858		       90 02		      bcc	.evh
    119  685a		       e6 91		      inc	Evaluation+1
    120  685c				   .evh
    121  685c					      ENDIF
    122  685c
    123  685c		       20 1c f5 	      jsr	GenerateAllMoves
    124  685f		       a5 9f		      lda	flagCheck
    125  6861		       d0 be		      bne	.inCheck2	; OTHER guy in check
    126  6863
    127  6863					      IF	1
      0  6863					      lda@PLY	moveIndex
      1  6863		       ad 9e ff 	      lda	moveIndex
    129  6866		       30 0f		      bmi	.none
    130  6868		       4a		      lsr
    131  6869		       4a		      lsr
    132  686a		       4a		      lsr
    133  686b		       4a		      lsr
    134  686c		       4a		      lsr
    135  686d		       65 90		      adc	Evaluation
    136  686f		       85 90		      sta	Evaluation
    137  6871		       a5 91		      lda	Evaluation+1
    138  6873		       69 00		      adc	#0
    139  6875		       85 91		      sta	Evaluation+1
    140  6877				   .none
    141  6877					      ENDIF
    142  6877
    143  6877
    144  6877		       a9 00		      lda	#<-INFINITY
      0  6879					      sta@PLY	value
      1  6879		       8d a5 01 	      sta	[RAM]+value
    146  687c		       a9 90		      lda	#>-INFINITY
      0  687e					      sta@PLY	value+1
      1  687e		       8d a6 01 	      sta	[RAM]+value+1
    148  6881
      0  6881					      ldx@PLY	moveIndex
      1  6881		       ae 9e ff 	      ldx	moveIndex
    150  6884		       10 03		      bpl	.forChild
    151  6886		       4c 0a f4 	      jmp	.exit
    152  6889
      0  6889				   .forChild  stx@PLY	movePtr
      1  6889		       8e 9f 01 	      stx	[RAM]+movePtr
    154  688c
    155  688c		       20 00 f4 	      jsr	MakeMove
    156  688f
    157  688f
    158  688f
    159  688f							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    160  688f
    161  688f							; PARAMS depth-1, -beta, -alpha
    162  688f							; pased through temporary variables (__alpha, __beta) and X reg
    163  688f
    164  688f		       38		      sec
    165  6890		       a9 00		      lda	#0
      0  6892					      sbc@PLY	beta
      1  6892		       ed a3 ff 	      sbc	beta
    167  6895		       85 a5		      sta	__alpha
    168  6897		       a9 00		      lda	#0
      0  6899					      sbc@PLY	beta+1
      1  6899		       ed a4 ff 	      sbc	beta+1
    170  689c		       85 a6		      sta	__alpha+1
    171  689e
    172  689e		       38		      sec
    173  689f		       a9 00		      lda	#0
      0  68a1					      sbc@PLY	alpha
      1  68a1		       ed a1 ff 	      sbc	alpha
    175  68a4		       85 a7		      sta	__beta
    176  68a6		       a9 00		      lda	#0
      0  68a8					      sbc@PLY	alpha+1
      1  68a8		       ed a2 ff 	      sbc	alpha+1
    178  68ab		       85 a8		      sta	__beta+1
    179  68ad
    180  68ad
      0  68ad					      ldx@PLY	depthLeft
      1  68ad		       ae a7 ff 	      ldx	depthLeft
      0  68b0					      lda@PLY	capturedPiece
      1  68b0		       ad 99 ff 	      lda	capturedPiece
    183  68b3
    184  68b3		       e6 95		      inc	currentPly
    185  68b5		       a4 95		      ldy	currentPly
    186  68b7		       84 3e		      sty	SET_BANK_RAM	; self-switch
    187  68b9
    188  68b9		       20 22 f4 	      jsr	negaMax
    189  68bc
    190  68bc		       c6 95		      dec	currentPly
    191  68be		       a5 95		      lda	currentPly
    192  68c0		       85 3e		      sta	SET_BANK_RAM
    193  68c2
    194  68c2		       20 6f f4 	      jsr	unmakeMove
    195  68c5
    196  68c5		       38		      sec
    197  68c6		       a9 00		      lda	#0
    198  68c8		       e5 a9		      sbc	__negaMax
    199  68ca		       85 a9		      sta	__negaMax
    200  68cc		       a9 00		      lda	#0
    201  68ce		       e5 aa		      sbc	__negaMax+1
    202  68d0		       85 aa		      sta	__negaMax+1	; -negaMax(...)
    203  68d2
    204  68d2		       a5 9f		      lda	flagCheck
    205  68d4		       f0 06		      beq	.notCheck
    206  68d6
    207  68d6							; at this point we've determined that the move was illegal, because the next ply detected
    208  68d6							; a king capture. So, the move should be totally discounted
    209  68d6
    210  68d6		       a9 00		      lda	#0
    211  68d8		       85 9f		      sta	flagCheck	; so we don't retrigger in future - it's been handled!
    212  68da		       f0 53		      beq	.nextMove	; unconditional - move is not considered!
    213  68dc
    214  68dc		       38	   .notCheck  sec
      0  68dd					      lda@PLY	value
      1  68dd		       ad a5 ff 	      lda	value
    216  68e0		       e5 a9		      sbc	__negaMax
      0  68e2					      lda@PLY	value+1
      1  68e2		       ad a6 ff 	      lda	value+1
    218  68e5		       e5 aa		      sbc	__negaMax+1
    219  68e7		       50 02		      bvc	.lab0
    220  68e9		       49 80		      eor	#$80
    221  68eb		       10 10	   .lab0      bpl	.lt0	; branch if value >= negaMax
    222  68ed
    223  68ed							; so, negaMax > value!
    224  68ed
    225  68ed		       a5 a9		      lda	__negaMax
      0  68ef					      sta@PLY	value
      1  68ef		       8d a5 01 	      sta	[RAM]+value
    227  68f2		       a5 aa		      lda	__negaMax+1
      0  68f4					      sta@PLY	value+1	; max(value, -negaMax)
      1  68f4		       8d a6 01 	      sta	[RAM]+value+1
    229  68f7
      0  68f7					      lda@PLY	movePtr
      1  68f7		       ad 9f ff 	      lda	movePtr
      0  68fa					      sta@PLY	bestMove
      1  68fa		       8d a0 01 	      sta	[RAM]+bestMove
    232  68fd				   .lt0
    233  68fd
    234  68fd							;	  α := max(α, value)
    235  68fd
    236  68fd		       38		      sec
      0  68fe					      lda@PLY	value
      1  68fe		       ad a5 ff 	      lda	value
      0  6901					      sbc@PLY	alpha
      1  6901		       ed a1 ff 	      sbc	alpha
      0  6904					      lda@PLY	value+1
      1  6904		       ad a6 ff 	      lda	value+1
      0  6907					      sbc@PLY	alpha+1
      1  6907		       ed a2 ff 	      sbc	alpha+1
    241  690a		       50 02		      bvc	.lab1
    242  690c		       49 80		      eor	#$80
    243  690e		       30 0c	   .lab1      bmi	.lt1	; value < alpha
    244  6910
      0  6910					      lda@PLY	value
      1  6910		       ad a5 ff 	      lda	value
      0  6913					      sta@PLY	alpha
      1  6913		       8d a1 01 	      sta	[RAM]+alpha
      0  6916					      lda@PLY	value+1
      1  6916		       ad a6 ff 	      lda	value+1
      0  6919					      sta@PLY	alpha+1	; alpha = max(alpha, value)
      1  6919		       8d a2 01 	      sta	[RAM]+alpha+1
    249  691c
    250  691c				   .lt1
    251  691c
    252  691c							;	  if α ≥ β then
    253  691c							;	      break (* cut-off *)
    254  691c
    255  691c		       38		      sec
      0  691d					      lda@PLY	alpha
      1  691d		       ad a1 ff 	      lda	alpha
      0  6920					      sbc@PLY	beta
      1  6920		       ed a3 ff 	      sbc	beta
      0  6923					      lda@PLY	alpha+1
      1  6923		       ad a2 ff 	      lda	alpha+1
      0  6926					      sbc@PLY	beta+1
      1  6926		       ed a4 ff 	      sbc	beta+1
    260  6929		       50 02		      bvc	.lab2
    261  692b		       49 80		      eor	#$80
    262  692d		       10 09	   .lab2      bpl	.retrn	; alpha >= beta
    263  692f
    264  692f
      0  692f				   .nextMove  ldx@PLY	movePtr
      1  692f		       ae 9f ff 	      ldx	movePtr
    266  6932		       ca	   .nextX     dex
    267  6933		       30 03		      bmi	.retrn
    268  6935		       4c 89 f4 	      jmp	.forChild
    269  6938
    270  6938		       4c 0a f4    .retrn     jmp	.exit
    271  693b
    272  693b
    273  693b							;---------------------------------------------------------------------------------------------------
    274  693b
      0  693b					      CHECK_BANK_SIZE	"NEGAMAX"
      1  693b		       01 3b	   .TEMP      =	* - _BANK_START
 NEGAMAX (1K) SIZE =  $13b , FREE= $2c5
      2  693b					      ECHO	"NEGAMAX", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  693b				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  693b				  -	      ECHO	"BANK OVERFLOW @ ", "NEGAMAX", " size=", * - ORIGIN
      5  693b				  -	      ERR
      6  693b					      ENDIF
    276  693b
    277  693b							;---------------------------------------------------------------------------------------------------
    278  693b							; EOF
------- FILE ./chess.asm
    628  693b
------- FILE Handler_MACROS.asm LEVEL 2 PASS 4
      0  693b					      include	"Handler_MACROS.asm"
      1  693b							; Copyright (C)2020 Andrew Davie
      2  693b							; Common macros for piece move handlers
      3  693b
      4  693b							;---------------------------------------------------------------------------------------------------
      5  693b							; Looks at a square offset {1} to see if piece can move to it
      6  693b							; Adds the square to the movelist if it can
      7  693b							; Keeps moving in the same direction until it's blocked/off=board
      8  693b
      9  693b					      MAC	move_towards
     10  693b					      SUBROUTINE
     11  693b
     12  693b							; = 76 for single square (empty/take)
     13  693b
     14  693b					      lda	#0
     15  693b					      sta	capture
     16  693b
     17  693b					      ldx	currentSquare	; 3
     18  693b					      bne	.project	; 3   unconditional
     19  693b
     20  693b				   .empty     jsr	AddMove	; 57
     21  693b				   .project   ldy	ValidSquare+{1},x	; 4
     22  693b					      bmi	.invalid	; 2/3 off board!
     23  693b					      lda	Board,y	; 4   piece @ destination
     24  693b					      beq	.empty	; 2/3
     25  693b					      sta	capture
     26  693b					      eor	currentPiece	; 3
     27  693b					      bpl	.invalid	; 2/3 same colour
     28  693b					      jsr	AddMove	; 57  and exit
     29  693b
     30  693b				   .invalid
     31  693b					      ENDM
     32  693b
     33  693b
     34  693b							;---------------------------------------------------------------------------------------------------
     35  693b
     36  693b					      MAC	move_to
     37  693b					      SUBROUTINE
     38  693b					      ldy	ValidSquare+{1},x
     39  693b					      bmi	.invalid	; off board!
     40  693b					      lda	Board,y	; piece @ destination
     41  693b					      sta	capture
     42  693b					      beq	.squareEmpty
     43  693b					      eor	currentPiece
     44  693b					      bpl	.invalid	; same colour
     45  693b				   .squareEmpty jsr	AddMove
     46  693b				   .invalid
     47  693b					      ENDM
     48  693b
     49  693b
     50  693b							;---------------------------------------------------------------------------------------------------
     51  693b
     52  693b					      MAC	move_to_x
     53  693b					      ldx	currentSquare
     54  693b					      MOVE_TO	{1}
     55  693b					      ENDM
     56  693b
     57  693b
     58  693b							;---------------------------------------------------------------------------------------------------
     59  693b							; EOF
------- FILE ./chess.asm
------- FILE GENMOVE.asm LEVEL 2 PASS 4
      0  693b					      include	"GENMOVE.asm"
      1  693b							; Chess
      2  693b							; Copyright (c) 2019-2020 Andrew Davie
      3  693b							; andrew@taswegian.com
      4  693b
      0  693b					      SLOT	1	; this code assembles for bank #1
      1  693b				  -	      IF	(1 < 0) || (1 > 3)
      2  693b				  -	      ECHO	"Illegal bank address/segment location", 1
      3  693b				  -	      ERR
      4  693b					      ENDIF
      5  693b				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  693b				   _BANK_SLOT SET	1 * 64
      0  693b					      NEWBANK	GENMOVE
      1  6e8c ????				      SEG	GENMOVE
      2  6c00					      ORG	_ORIGIN
      3  6c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  6c00				   _BANK_START SET	*
      5  6c00				   GENMOVE_START SET	*
      6  6c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6c00				   GENMOVE    SET	_BANK_SLOT + _CURRENT_BANK
      8  6c00				   _ORIGIN    SET	_ORIGIN + 1024
      7  6c00
      8  6c00					      MAC	handlevec
      9  6c00					      .byte	{1}MoveReturn
     10  6c00					      .byte	{1}MoveReturn	;byte {1}Handle_WHITE_PAWN	   ; 1
     11  6c00					      .byte	{1}MoveReturn	;.byte {1}Handle_BLACK_PAWN	    ; 2
     12  6c00					      .byte	{1}Handle_KNIGHT	; 3
     13  6c00					      .byte	{1}Handle_BISHOP	; 4
     14  6c00					      .byte	{1}Handle_ROOK	; 5
     15  6c00					      .byte	{1}Handle_QUEEN	; 6
     16  6c00					      .byte	{1}Handle_KING	; 7
     17  6c00
     18  6c00					      .byte	{1}MoveReturn
     19  6c00					      .byte	{1}Handle_WHITE_PAWN	; 1
     20  6c00					      .byte	{1}Handle_BLACK_PAWN	; 2
     21  6c00					      .byte	{1}MoveReturn	;.byte {1}Handle_KNIGHT	    ; 3
     22  6c00					      .byte	{1}MoveReturn	;.byte {1}Handle_BISHOP	    ; 4
     23  6c00					      .byte	{1}MoveReturn	;.byte {1}Handle_ROOK		    ; 5
     24  6c00					      .byte	{1}MoveReturn	;.byte {1}Handle_QUEEN 	    ; 6
     25  6c00					      .byte	{1}MoveReturn	;.byte {1}Handle_KING		    ; 7
     26  6c00					      ENDM
     27  6c00
     28  6c00
     29  6c00							;    .byte 0	  ; dummy to prevent page cross access on index 0
     30  6c00
      0  6c00				   HandlerVectorLO HANDLEVEC	<
      1  6c00		       40		      .byte.b	<MoveReturn
      2  6c01		       40		      .byte.b	<MoveReturn
      3  6c02		       40		      .byte.b	<MoveReturn
      4  6c03		       7b		      .byte.b	<Handle_KNIGHT
      5  6c04		       30		      .byte.b	<Handle_BISHOP
      6  6c05		       00		      .byte.b	<Handle_ROOK
      7  6c06		       99		      .byte.b	<Handle_QUEEN
      8  6c07		       ab		      .byte.b	<Handle_KING
      9  6c08
     10  6c08		       40		      .byte.b	<MoveReturn
     11  6c09		       4d		      .byte.b	<Handle_WHITE_PAWN
     12  6c0a		       21		      .byte.b	<Handle_BLACK_PAWN
     13  6c0b		       40		      .byte.b	<MoveReturn
     14  6c0c		       40		      .byte.b	<MoveReturn
     15  6c0d		       40		      .byte.b	<MoveReturn
     16  6c0e		       40		      .byte.b	<MoveReturn
     17  6c0f		       40		      .byte.b	<MoveReturn
      0  6c10				   HandlerVectorHI HANDLEVEC	>
      1  6c10		       f5		      .byte.b	>MoveReturn
      2  6c11		       f5		      .byte.b	>MoveReturn
      3  6c12		       f5		      .byte.b	>MoveReturn
      4  6c13		       f4		      .byte.b	>Handle_KNIGHT
      5  6c14		       f4		      .byte.b	>Handle_BISHOP
      6  6c15		       f4		      .byte.b	>Handle_ROOK
      7  6c16		       f5		      .byte.b	>Handle_QUEEN
      8  6c17		       f4		      .byte.b	>Handle_KING
      9  6c18
     10  6c18		       f5		      .byte.b	>MoveReturn
     11  6c19		       f5		      .byte.b	>Handle_WHITE_PAWN
     12  6c1a		       f6		      .byte.b	>Handle_BLACK_PAWN
     13  6c1b		       f5		      .byte.b	>MoveReturn
     14  6c1c		       f5		      .byte.b	>MoveReturn
     15  6c1d		       f5		      .byte.b	>MoveReturn
     16  6c1e		       f5		      .byte.b	>MoveReturn
     17  6c1f		       f5		      .byte.b	>MoveReturn
      0  6c20				   HandlerVectorBANK HANDLEVEC	BANK_
      1  6c20		       5d		      .byte.b	BANK_MoveReturn
      2  6c21		       5d		      .byte.b	BANK_MoveReturn
      3  6c22		       5d		      .byte.b	BANK_MoveReturn
      4  6c23		       5c		      .byte.b	BANK_Handle_KNIGHT
      5  6c24		       5b		      .byte.b	BANK_Handle_BISHOP
      6  6c25		       5c		      .byte.b	BANK_Handle_ROOK
      7  6c26		       5b		      .byte.b	BANK_Handle_QUEEN
      8  6c27		       5b		      .byte.b	BANK_Handle_KING
      9  6c28
     10  6c28		       5d		      .byte.b	BANK_MoveReturn
     11  6c29		       5c		      .byte.b	BANK_Handle_WHITE_PAWN
     12  6c2a		       5c		      .byte.b	BANK_Handle_BLACK_PAWN
     13  6c2b		       5d		      .byte.b	BANK_MoveReturn
     14  6c2c		       5d		      .byte.b	BANK_MoveReturn
     15  6c2d		       5d		      .byte.b	BANK_MoveReturn
     16  6c2e		       5d		      .byte.b	BANK_MoveReturn
     17  6c2f		       5d		      .byte.b	BANK_MoveReturn
     34  6c30
     35  6c30
------- FILE Handler_BISHOP.asm LEVEL 3 PASS 4
      0  6c30					      include	"Handler_BISHOP.asm"
      1  6c30							; Copyright (C)2020 Andrew Davie
      2  6c30
      3  6c30							;---------------------------------------------------------------------------------------------------
      4  6c30							; BISHOP
      5  6c30							;---------------------------------------------------------------------------------------------------
      6  6c30
      0  6c30					      DEF	Handle_BISHOP
      1  6c30				   SLOT_Handle_BISHOP SET	_BANK_SLOT
      2  6c30				   BANK_Handle_BISHOP SET	SLOT_Handle_BISHOP + _CURRENT_BANK
      3  6c30				   Handle_BISHOP
      4  6c30				   TEMPORARY_VAR SET	Overlay
      5  6c30				   TEMPORARY_OFFSET SET	0
      6  6c30				   VAR_BOUNDARY_Handle_BISHOP SET	TEMPORARY_OFFSET
      7  6c30				   FUNCTION_NAME SET	Handle_BISHOP
      8  6c30					      SUBROUTINE
      9  6c30
      0  6c30					      REFER	GenerateAllMoves
      1  6c30					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6c30				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6c30					      ENDIF
      0  6c30					      VEND	Handle_BISHOP
      1  6c30				  -	      IFNCONST	Handle_BISHOP
      2  6c30				  -	      ECHO	"Incorrect VEND label", Handle_BISHOP
      3  6c30				  -	      ERR
      4  6c30					      ENDIF
      5  6c30		       00 b3	   VAREND_Handle_BISHOP =	TEMPORARY_VAR
     12  6c30
     13  6c30							; x = currentSquare (square the piece is on)
     14  6c30							; currentPiece (with flags/colour attached)
     15  6c30
      0  6c30					      MOVE_TOWARDS	_DOWN+_LEFT
      1  6c30					      SUBROUTINE
      2  6c30
      3  6c30
      4  6c30
      5  6c30		       a9 00		      lda	#0
      6  6c32		       85 9e		      sta	capture
      7  6c34
      8  6c34		       a6 93		      ldx	currentSquare
      9  6c36		       d0 03		      bne	.project
     10  6c38
     11  6c38		       20 05 f5    .empty     jsr	AddMove
     12  6c3b		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  6c3e		       30 0e		      bmi	.invalid
     14  6c40		       b9 79 fc 	      lda	Board,y
     15  6c43		       f0 f3		      beq	.empty
     16  6c45		       85 9e		      sta	capture
     17  6c47		       45 92		      eor	currentPiece
     18  6c49		       10 03		      bpl	.invalid
     19  6c4b		       20 05 f5 	      jsr	AddMove
     20  6c4e
     21  6c4e				   .invalid
      0  6c4e					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  6c4e					      SUBROUTINE
      2  6c4e
      3  6c4e
      4  6c4e
      5  6c4e		       a9 00		      lda	#0
      6  6c50		       85 9e		      sta	capture
      7  6c52
      8  6c52		       a6 93		      ldx	currentSquare
      9  6c54		       d0 03		      bne	.project
     10  6c56
     11  6c56		       20 05 f5    .empty     jsr	AddMove
     12  6c59		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  6c5c		       30 0e		      bmi	.invalid
     14  6c5e		       b9 79 fc 	      lda	Board,y
     15  6c61		       f0 f3		      beq	.empty
     16  6c63		       85 9e		      sta	capture
     17  6c65		       45 92		      eor	currentPiece
     18  6c67		       10 03		      bpl	.invalid
     19  6c69		       20 05 f5 	      jsr	AddMove
     20  6c6c
     21  6c6c				   .invalid
      0  6c6c					      MOVE_TOWARDS	_UP+_LEFT
      1  6c6c					      SUBROUTINE
      2  6c6c
      3  6c6c
      4  6c6c
      5  6c6c		       a9 00		      lda	#0
      6  6c6e		       85 9e		      sta	capture
      7  6c70
      8  6c70		       a6 93		      ldx	currentSquare
      9  6c72		       d0 03		      bne	.project
     10  6c74
     11  6c74		       20 05 f5    .empty     jsr	AddMove
     12  6c77		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  6c7a		       30 0e		      bmi	.invalid
     14  6c7c		       b9 79 fc 	      lda	Board,y
     15  6c7f		       f0 f3		      beq	.empty
     16  6c81		       85 9e		      sta	capture
     17  6c83		       45 92		      eor	currentPiece
     18  6c85		       10 03		      bpl	.invalid
     19  6c87		       20 05 f5 	      jsr	AddMove
     20  6c8a
     21  6c8a				   .invalid
      0  6c8a					      MOVE_TOWARDS	_UP+_RIGHT
      1  6c8a					      SUBROUTINE
      2  6c8a
      3  6c8a
      4  6c8a
      5  6c8a		       a9 00		      lda	#0
      6  6c8c		       85 9e		      sta	capture
      7  6c8e
      8  6c8e		       a6 93		      ldx	currentSquare
      9  6c90		       d0 03		      bne	.project
     10  6c92
     11  6c92		       20 05 f5    .empty     jsr	AddMove
     12  6c95		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  6c98		       30 0e		      bmi	.invalid
     14  6c9a		       b9 79 fc 	      lda	Board,y
     15  6c9d		       f0 f3		      beq	.empty
     16  6c9f		       85 9e		      sta	capture
     17  6ca1		       45 92		      eor	currentPiece
     18  6ca3		       10 03		      bpl	.invalid
     19  6ca5		       20 05 f5 	      jsr	AddMove
     20  6ca8
     21  6ca8				   .invalid
     20  6ca8
     21  6ca8		       4c 40 f5 	      jmp	MoveReturn
     22  6cab
     23  6cab							;---------------------------------------------------------------------------------------------------
     24  6cab							; EOF
------- FILE GENMOVE.asm
------- FILE Handler_KING.asm LEVEL 3 PASS 4
      0  6cab					      include	"Handler_KING.asm"
      1  6cab							; Copyright (C)2020 Andrew Davie
      2  6cab
      3  6cab							;---------------------------------------------------------------------------------------------------
      4  6cab							; KING
      5  6cab							; This is the move handler for a KING
      6  6cab							; "Check" is detected in the next ply of the search.
      7  6cab
      8  6cab
      9  6cab							;---------------------------------------------------------------------------------------------------
     10  6cab
     11  6cab							; MACRO - Castling
     12  6cab
     13  6cab		       00 03	   KINGSIDE   =	3
     14  6cab		       ff ff ff fc QUEENSIDE  =	-4
     15  6cab
     16  6cab					      MAC	castle
     17  6cab							; {1} = "KINGSIDE" or "QUEENSIDE"
     18  6cab
     19  6cab					      ldx	currentSquare
     20  6cab					      lda	Board+{1},x	; kingside/queenside R position
     21  6cab					      and	#PIECE_MASK|FLAG_MOVED
     22  6cab					      cmp	#ROOK
     23  6cab					      bne	.noCastle	; not a R that hasn't moved
     24  6cab
     25  6cab							; It's a R and it *HAS* to be correct colour because it hasn't moved!
     26  6cab							; AND the K hasn't moved (earlier check), so check for vacant squares between K and R
     27  6cab
     28  6cab					      IF	{1} = QUEENSIDE
     29  6cab					      lda	Board-3,x	; N pos
     30  6cab					      ora	Board-2,x	; B pos
     31  6cab					      ora	Board-1,x	; Q pos
     32  6cab					      bne	.noCastle	; not vacant?
     33  6cab
     34  6cab					      ENDIF
     35  6cab
     36  6cab					      IF	{1} = KINGSIDE
     37  6cab					      lda	Board+2,x	; N pos
     38  6cab					      ora	Board+1,x	; B pos
     39  6cab					      bne	.noCastle	; not vacant?
     40  6cab					      ENDIF
     41  6cab
     42  6cab							; appropriate N/B/(Q) squares are vacant so we proceed...
     43  6cab
     44  6cab							; FINALLY -- king can castle
     45  6cab							; note: when we actually DO the move we MUST insert "Phantom" kings onto the board over the
     46  6cab							; squares the king traverses so that "check" (and thus illegal moves) can be detected on the
     47  6cab							; next move. Castling will be detected by K moving > 1 square. (TODO: FIX?? not CASTLE flag??)
     48  6cab
     49  6cab					      lda	currentPiece
     50  6cab					      ora	#FLAG_CASTLE	; flag it's a castling move
     51  6cab					      sta	currentPiece
     52  6cab
     53  6cab					      IF	{1} = KINGSIDE
     54  6cab					      ldy	ValidSquare+2,x
     55  6cab					      ENDIF
     56  6cab
     57  6cab					      IF	{1} = QUEENSIDE
     58  6cab					      ldy	ValidSquare-2,x
     59  6cab					      ENDIF
     60  6cab
     61  6cab					      jsr	AddMove	; 57
     62  6cab
     63  6cab				   .noCastle
     64  6cab					      ENDM
     65  6cab
     66  6cab
     67  6cab							;---------------------------------------------------------------------------------------------------
     68  6cab
      0  6cab					      DEF	Handle_KING
      1  6cab				   SLOT_Handle_KING SET	_BANK_SLOT
      2  6cab				   BANK_Handle_KING SET	SLOT_Handle_KING + _CURRENT_BANK
      3  6cab				   Handle_KING
      4  6cab				   TEMPORARY_VAR SET	Overlay
      5  6cab				   TEMPORARY_OFFSET SET	0
      6  6cab				   VAR_BOUNDARY_Handle_KING SET	TEMPORARY_OFFSET
      7  6cab				   FUNCTION_NAME SET	Handle_KING
     70  6cab					      SUBROUTINE
     71  6cab
      0  6cab					      REFER	GenerateAllMoves
      1  6cab					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6cab				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6cab					      ENDIF
      0  6cab					      VEND	Handle_KING
      1  6cab				  -	      IFNCONST	Handle_KING
      2  6cab				  -	      ECHO	"Incorrect VEND label", Handle_KING
      3  6cab				  -	      ERR
      4  6cab					      ENDIF
      5  6cab		       00 b3	   VAREND_Handle_KING =	TEMPORARY_VAR
     74  6cab
     75  6cab							; x = currentSquare (square the KING is on)
     76  6cab							; currentPiece (KING of course, but with flags/colour attached)
     77  6cab
      0  6cab					      MOVE_TO	_DOWN+_LEFT
      1  6cab					      SUBROUTINE
      2  6cab		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      3  6cae		       30 0e		      bmi	.invalid
      4  6cb0		       b9 79 fc 	      lda	Board,y
      5  6cb3		       85 9e		      sta	capture
      6  6cb5		       f0 04		      beq	.squareEmpty
      7  6cb7		       45 92		      eor	currentPiece
      8  6cb9		       10 03		      bpl	.invalid
      9  6cbb		       20 05 f5    .squareEmpty jsr	AddMove
     10  6cbe				   .invalid
      0  6cbe					      MOVE_TO_X	_DOWN
      1  6cbe		       a6 93		      ldx	currentSquare
      0  6cc0					      MOVE_TO	_DOWN
      1  6cc0					      SUBROUTINE
      2  6cc0		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x
      3  6cc3		       30 0e		      bmi	.invalid
      4  6cc5		       b9 79 fc 	      lda	Board,y
      5  6cc8		       85 9e		      sta	capture
      6  6cca		       f0 04		      beq	.squareEmpty
      7  6ccc		       45 92		      eor	currentPiece
      8  6cce		       10 03		      bpl	.invalid
      9  6cd0		       20 05 f5    .squareEmpty jsr	AddMove
     10  6cd3				   .invalid
      0  6cd3					      MOVE_TO_X	_DOWN+_RIGHT
      1  6cd3		       a6 93		      ldx	currentSquare
      0  6cd5					      MOVE_TO	_DOWN+_RIGHT
      1  6cd5					      SUBROUTINE
      2  6cd5		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      3  6cd8		       30 0e		      bmi	.invalid
      4  6cda		       b9 79 fc 	      lda	Board,y
      5  6cdd		       85 9e		      sta	capture
      6  6cdf		       f0 04		      beq	.squareEmpty
      7  6ce1		       45 92		      eor	currentPiece
      8  6ce3		       10 03		      bpl	.invalid
      9  6ce5		       20 05 f5    .squareEmpty jsr	AddMove
     10  6ce8				   .invalid
      0  6ce8					      MOVE_TO_X	_RIGHT
      1  6ce8		       a6 93		      ldx	currentSquare
      0  6cea					      MOVE_TO	_RIGHT
      1  6cea					      SUBROUTINE
      2  6cea		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      3  6ced		       30 0e		      bmi	.invalid
      4  6cef		       b9 79 fc 	      lda	Board,y
      5  6cf2		       85 9e		      sta	capture
      6  6cf4		       f0 04		      beq	.squareEmpty
      7  6cf6		       45 92		      eor	currentPiece
      8  6cf8		       10 03		      bpl	.invalid
      9  6cfa		       20 05 f5    .squareEmpty jsr	AddMove
     10  6cfd				   .invalid
      0  6cfd					      MOVE_TO_X	_UP+_RIGHT
      1  6cfd		       a6 93		      ldx	currentSquare
      0  6cff					      MOVE_TO	_UP+_RIGHT
      1  6cff					      SUBROUTINE
      2  6cff		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      3  6d02		       30 0e		      bmi	.invalid
      4  6d04		       b9 79 fc 	      lda	Board,y
      5  6d07		       85 9e		      sta	capture
      6  6d09		       f0 04		      beq	.squareEmpty
      7  6d0b		       45 92		      eor	currentPiece
      8  6d0d		       10 03		      bpl	.invalid
      9  6d0f		       20 05 f5    .squareEmpty jsr	AddMove
     10  6d12				   .invalid
      0  6d12					      MOVE_TO_X	_UP
      1  6d12		       a6 93		      ldx	currentSquare
      0  6d14					      MOVE_TO	_UP
      1  6d14					      SUBROUTINE
      2  6d14		       bc 1f fc 	      ldy	ValidSquare+_UP,x
      3  6d17		       30 0e		      bmi	.invalid
      4  6d19		       b9 79 fc 	      lda	Board,y
      5  6d1c		       85 9e		      sta	capture
      6  6d1e		       f0 04		      beq	.squareEmpty
      7  6d20		       45 92		      eor	currentPiece
      8  6d22		       10 03		      bpl	.invalid
      9  6d24		       20 05 f5    .squareEmpty jsr	AddMove
     10  6d27				   .invalid
      0  6d27					      MOVE_TO_X	_UP+_LEFT
      1  6d27		       a6 93		      ldx	currentSquare
      0  6d29					      MOVE_TO	_UP+_LEFT
      1  6d29					      SUBROUTINE
      2  6d29		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      3  6d2c		       30 0e		      bmi	.invalid
      4  6d2e		       b9 79 fc 	      lda	Board,y
      5  6d31		       85 9e		      sta	capture
      6  6d33		       f0 04		      beq	.squareEmpty
      7  6d35		       45 92		      eor	currentPiece
      8  6d37		       10 03		      bpl	.invalid
      9  6d39		       20 05 f5    .squareEmpty jsr	AddMove
     10  6d3c				   .invalid
      0  6d3c					      MOVE_TO_X	_LEFT
      1  6d3c		       a6 93		      ldx	currentSquare
      0  6d3e					      MOVE_TO	_LEFT
      1  6d3e					      SUBROUTINE
      2  6d3e		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      3  6d41		       30 0e		      bmi	.invalid
      4  6d43		       b9 79 fc 	      lda	Board,y
      5  6d46		       85 9e		      sta	capture
      6  6d48		       f0 04		      beq	.squareEmpty
      7  6d4a		       45 92		      eor	currentPiece
      8  6d4c		       10 03		      bpl	.invalid
      9  6d4e		       20 05 f5    .squareEmpty jsr	AddMove
     10  6d51				   .invalid
     86  6d51
     87  6d51							;IF CASTLING_ENABLED
     88  6d51
     89  6d51		       24 92		      bit	currentPiece
     90  6d53		       70 41		      bvs	.exit	; king has moved, so no castling
     91  6d55
      0  6d55					      CASTLE	KINGSIDE
      1  6d55
      2  6d55
      3  6d55		       a6 93		      ldx	currentSquare
      4  6d57		       bd 7c fc 	      lda	Board+KINGSIDE,x
      5  6d5a		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  6d5c		       c9 05		      cmp	#ROOK
      7  6d5e		       d0 14		      bne	.noCastle
      8  6d60
      9  6d60
     10  6d60
     11  6d60
     12  6d60				  -	      IF	KINGSIDE = QUEENSIDE
     13  6d60				  -	      lda	Board-3,x
     14  6d60				  -	      ora	Board-2,x
     15  6d60				  -	      ora	Board-1,x
     16  6d60				  -	      bne	.noCastle
     17  6d60				  -
     18  6d60					      ENDIF
     19  6d60
     20  6d60					      IF	KINGSIDE = KINGSIDE
     21  6d60		       bd 7b fc 	      lda	Board+2,x
     22  6d63		       1d 7a fc 	      ora	Board+1,x
     23  6d66		       d0 0c		      bne	.noCastle
     24  6d68					      ENDIF
     25  6d68
     26  6d68
     27  6d68
     28  6d68
     29  6d68
     30  6d68
     31  6d68
     32  6d68
     33  6d68		       a5 92		      lda	currentPiece
     34  6d6a		       09 10		      ora	#FLAG_CASTLE
     35  6d6c		       85 92		      sta	currentPiece
     36  6d6e
     37  6d6e					      IF	KINGSIDE = KINGSIDE
     38  6d6e		       bc 17 fc 	      ldy	ValidSquare+2,x
     39  6d71					      ENDIF
     40  6d71
     41  6d71				  -	      IF	KINGSIDE = QUEENSIDE
     42  6d71				  -	      ldy	ValidSquare-2,x
     43  6d71					      ENDIF
     44  6d71
     45  6d71		       20 05 f5 	      jsr	AddMove
     46  6d74
     47  6d74				   .noCastle
      0  6d74					      CASTLE	QUEENSIDE
      1  6d74
      2  6d74
      3  6d74		       a6 93		      ldx	currentSquare
      4  6d76		       bd 75 fc 	      lda	Board+QUEENSIDE,x
      5  6d79		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  6d7b		       c9 05		      cmp	#ROOK
      7  6d7d		       d0 17		      bne	.noCastle
      8  6d7f
      9  6d7f
     10  6d7f
     11  6d7f
     12  6d7f					      IF	QUEENSIDE = QUEENSIDE
     13  6d7f		       bd 76 fc 	      lda	Board-3,x
     14  6d82		       1d 77 fc 	      ora	Board-2,x
     15  6d85		       1d 78 fc 	      ora	Board-1,x
     16  6d88		       d0 0c		      bne	.noCastle
     17  6d8a
     18  6d8a					      ENDIF
     19  6d8a
     20  6d8a				  -	      IF	QUEENSIDE = KINGSIDE
     21  6d8a				  -	      lda	Board+2,x
     22  6d8a				  -	      ora	Board+1,x
     23  6d8a				  -	      bne	.noCastle
     24  6d8a					      ENDIF
     25  6d8a
     26  6d8a
     27  6d8a
     28  6d8a
     29  6d8a
     30  6d8a
     31  6d8a
     32  6d8a
     33  6d8a		       a5 92		      lda	currentPiece
     34  6d8c		       09 10		      ora	#FLAG_CASTLE
     35  6d8e		       85 92		      sta	currentPiece
     36  6d90
     37  6d90				  -	      IF	QUEENSIDE = KINGSIDE
     38  6d90				  -	      ldy	ValidSquare+2,x
     39  6d90					      ENDIF
     40  6d90
     41  6d90					      IF	QUEENSIDE = QUEENSIDE
     42  6d90		       bc 13 fc 	      ldy	ValidSquare-2,x
     43  6d93					      ENDIF
     44  6d93
     45  6d93		       20 05 f5 	      jsr	AddMove
     46  6d96
     47  6d96				   .noCastle
     94  6d96
     95  6d96							;ENDIF
     96  6d96
     97  6d96		       4c 40 f5    .exit      jmp	MoveReturn
     98  6d99
     99  6d99							;---------------------------------------------------------------------------------------------------
    100  6d99							; EOF
------- FILE GENMOVE.asm
------- FILE Handler_QUEEN.asm LEVEL 3 PASS 4
      0  6d99					      include	"Handler_QUEEN.asm"
      1  6d99							; Copyright (C)2020 Andrew Davie
      2  6d99
      3  6d99							;---------------------------------------------------------------------------------------------------
      4  6d99							; QUEEN
      5  6d99							;---------------------------------------------------------------------------------------------------
      6  6d99
      0  6d99					      DEF	Handle_QUEEN
      1  6d99				   SLOT_Handle_QUEEN SET	_BANK_SLOT
      2  6d99				   BANK_Handle_QUEEN SET	SLOT_Handle_QUEEN + _CURRENT_BANK
      3  6d99				   Handle_QUEEN
      4  6d99				   TEMPORARY_VAR SET	Overlay
      5  6d99				   TEMPORARY_OFFSET SET	0
      6  6d99				   VAR_BOUNDARY_Handle_QUEEN SET	TEMPORARY_OFFSET
      7  6d99				   FUNCTION_NAME SET	Handle_QUEEN
      8  6d99					      SUBROUTINE
      9  6d99
      0  6d99					      REFER	GenerateAllMoves
      1  6d99					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6d99				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6d99					      ENDIF
      0  6d99					      VEND	Handle_QUEEN
      1  6d99				  -	      IFNCONST	Handle_QUEEN
      2  6d99				  -	      ECHO	"Incorrect VEND label", Handle_QUEEN
      3  6d99				  -	      ERR
      4  6d99					      ENDIF
      5  6d99		       00 b3	   VAREND_Handle_QUEEN =	TEMPORARY_VAR
     12  6d99
     13  6d99							; Pass...
     14  6d99							; x = currentSquare (square the piece is on)
     15  6d99							; currentPiece (with flags/colour attached)
     16  6d99
      0  6d99					      MOVE_TOWARDS	_DOWN+_LEFT
      1  6d99					      SUBROUTINE
      2  6d99
      3  6d99
      4  6d99
      5  6d99		       a9 00		      lda	#0
      6  6d9b		       85 9e		      sta	capture
      7  6d9d
      8  6d9d		       a6 93		      ldx	currentSquare
      9  6d9f		       d0 03		      bne	.project
     10  6da1
     11  6da1		       20 05 f5    .empty     jsr	AddMove
     12  6da4		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  6da7		       30 0e		      bmi	.invalid
     14  6da9		       b9 79 fc 	      lda	Board,y
     15  6dac		       f0 f3		      beq	.empty
     16  6dae		       85 9e		      sta	capture
     17  6db0		       45 92		      eor	currentPiece
     18  6db2		       10 03		      bpl	.invalid
     19  6db4		       20 05 f5 	      jsr	AddMove
     20  6db7
     21  6db7				   .invalid
      0  6db7					      MOVE_TOWARDS	_DOWN
      1  6db7					      SUBROUTINE
      2  6db7
      3  6db7
      4  6db7
      5  6db7		       a9 00		      lda	#0
      6  6db9		       85 9e		      sta	capture
      7  6dbb
      8  6dbb		       a6 93		      ldx	currentSquare
      9  6dbd		       d0 03		      bne	.project
     10  6dbf
     11  6dbf		       20 05 f5    .empty     jsr	AddMove
     12  6dc2		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  6dc5		       30 0e		      bmi	.invalid
     14  6dc7		       b9 79 fc 	      lda	Board,y
     15  6dca		       f0 f3		      beq	.empty
     16  6dcc		       85 9e		      sta	capture
     17  6dce		       45 92		      eor	currentPiece
     18  6dd0		       10 03		      bpl	.invalid
     19  6dd2		       20 05 f5 	      jsr	AddMove
     20  6dd5
     21  6dd5				   .invalid
      0  6dd5					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  6dd5					      SUBROUTINE
      2  6dd5
      3  6dd5
      4  6dd5
      5  6dd5		       a9 00		      lda	#0
      6  6dd7		       85 9e		      sta	capture
      7  6dd9
      8  6dd9		       a6 93		      ldx	currentSquare
      9  6ddb		       d0 03		      bne	.project
     10  6ddd
     11  6ddd		       20 05 f5    .empty     jsr	AddMove
     12  6de0		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  6de3		       30 0e		      bmi	.invalid
     14  6de5		       b9 79 fc 	      lda	Board,y
     15  6de8		       f0 f3		      beq	.empty
     16  6dea		       85 9e		      sta	capture
     17  6dec		       45 92		      eor	currentPiece
     18  6dee		       10 03		      bpl	.invalid
     19  6df0		       20 05 f5 	      jsr	AddMove
     20  6df3
     21  6df3				   .invalid
      0  6df3					      MOVE_TOWARDS	_RIGHT
      1  6df3					      SUBROUTINE
      2  6df3
      3  6df3
      4  6df3
      5  6df3		       a9 00		      lda	#0
      6  6df5		       85 9e		      sta	capture
      7  6df7
      8  6df7		       a6 93		      ldx	currentSquare
      9  6df9		       d0 03		      bne	.project
     10  6dfb
     11  6dfb		       20 05 f5    .empty     jsr	AddMove
     12  6dfe		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  6e01		       30 0e		      bmi	.invalid
     14  6e03		       b9 79 fc 	      lda	Board,y
     15  6e06		       f0 f3		      beq	.empty
     16  6e08		       85 9e		      sta	capture
     17  6e0a		       45 92		      eor	currentPiece
     18  6e0c		       10 03		      bpl	.invalid
     19  6e0e		       20 05 f5 	      jsr	AddMove
     20  6e11
     21  6e11				   .invalid
      0  6e11					      MOVE_TOWARDS	_UP+_RIGHT
      1  6e11					      SUBROUTINE
      2  6e11
      3  6e11
      4  6e11
      5  6e11		       a9 00		      lda	#0
      6  6e13		       85 9e		      sta	capture
      7  6e15
      8  6e15		       a6 93		      ldx	currentSquare
      9  6e17		       d0 03		      bne	.project
     10  6e19
     11  6e19		       20 05 f5    .empty     jsr	AddMove
     12  6e1c		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  6e1f		       30 0e		      bmi	.invalid
     14  6e21		       b9 79 fc 	      lda	Board,y
     15  6e24		       f0 f3		      beq	.empty
     16  6e26		       85 9e		      sta	capture
     17  6e28		       45 92		      eor	currentPiece
     18  6e2a		       10 03		      bpl	.invalid
     19  6e2c		       20 05 f5 	      jsr	AddMove
     20  6e2f
     21  6e2f				   .invalid
      0  6e2f					      MOVE_TOWARDS	_UP
      1  6e2f					      SUBROUTINE
      2  6e2f
      3  6e2f
      4  6e2f
      5  6e2f		       a9 00		      lda	#0
      6  6e31		       85 9e		      sta	capture
      7  6e33
      8  6e33		       a6 93		      ldx	currentSquare
      9  6e35		       d0 03		      bne	.project
     10  6e37
     11  6e37		       20 05 f5    .empty     jsr	AddMove
     12  6e3a		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  6e3d		       30 0e		      bmi	.invalid
     14  6e3f		       b9 79 fc 	      lda	Board,y
     15  6e42		       f0 f3		      beq	.empty
     16  6e44		       85 9e		      sta	capture
     17  6e46		       45 92		      eor	currentPiece
     18  6e48		       10 03		      bpl	.invalid
     19  6e4a		       20 05 f5 	      jsr	AddMove
     20  6e4d
     21  6e4d				   .invalid
      0  6e4d					      MOVE_TOWARDS	_UP+_LEFT
      1  6e4d					      SUBROUTINE
      2  6e4d
      3  6e4d
      4  6e4d
      5  6e4d		       a9 00		      lda	#0
      6  6e4f		       85 9e		      sta	capture
      7  6e51
      8  6e51		       a6 93		      ldx	currentSquare
      9  6e53		       d0 03		      bne	.project
     10  6e55
     11  6e55		       20 05 f5    .empty     jsr	AddMove
     12  6e58		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  6e5b		       30 0e		      bmi	.invalid
     14  6e5d		       b9 79 fc 	      lda	Board,y
     15  6e60		       f0 f3		      beq	.empty
     16  6e62		       85 9e		      sta	capture
     17  6e64		       45 92		      eor	currentPiece
     18  6e66		       10 03		      bpl	.invalid
     19  6e68		       20 05 f5 	      jsr	AddMove
     20  6e6b
     21  6e6b				   .invalid
      0  6e6b					      MOVE_TOWARDS	_LEFT
      1  6e6b					      SUBROUTINE
      2  6e6b
      3  6e6b
      4  6e6b
      5  6e6b		       a9 00		      lda	#0
      6  6e6d		       85 9e		      sta	capture
      7  6e6f
      8  6e6f		       a6 93		      ldx	currentSquare
      9  6e71		       d0 03		      bne	.project
     10  6e73
     11  6e73		       20 05 f5    .empty     jsr	AddMove
     12  6e76		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  6e79		       30 0e		      bmi	.invalid
     14  6e7b		       b9 79 fc 	      lda	Board,y
     15  6e7e		       f0 f3		      beq	.empty
     16  6e80		       85 9e		      sta	capture
     17  6e82		       45 92		      eor	currentPiece
     18  6e84		       10 03		      bpl	.invalid
     19  6e86		       20 05 f5 	      jsr	AddMove
     20  6e89
     21  6e89				   .invalid
     25  6e89
     26  6e89		       4c 40 f5 	      jmp	MoveReturn
     27  6e8c
     28  6e8c							; EOF
------- FILE GENMOVE.asm
     39  6e8c
     40  6e8c							;---------------------------------------------------------------------------------------------------
     41  6e8c
      0  6e8c					      CHECK_BANK_SIZE	"GENMOVE"
      1  6e8c		       02 8c	   .TEMP      =	* - _BANK_START
 GENMOVE (1K) SIZE =  $28c , FREE= $174
      2  6e8c					      ECHO	"GENMOVE", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  6e8c				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6e8c				  -	      ECHO	"BANK OVERFLOW @ ", "GENMOVE", " size=", * - ORIGIN
      5  6e8c				  -	      ERR
      6  6e8c					      ENDIF
     43  6e8c
     44  6e8c							;---------------------------------------------------------------------------------------------------
     45  6e8c							; EOF
------- FILE ./chess.asm
------- FILE GENMOVE2.asm LEVEL 2 PASS 4
      0  6e8c					      include	"GENMOVE2.asm"
      1  6e8c							; Chess
      2  6e8c							; Copyright (c) 2019-2020 Andrew Davie
      3  6e8c							; andrew@taswegian.com
      4  6e8c
      0  6e8c					      SLOT	1	; this code assembles for bank #1
      1  6e8c				  -	      IF	(1 < 0) || (1 > 3)
      2  6e8c				  -	      ECHO	"Illegal bank address/segment location", 1
      3  6e8c				  -	      ERR
      4  6e8c					      ENDIF
      5  6e8c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  6e8c				   _BANK_SLOT SET	1 * 64
      0  6e8c					      NEWBANK	GENMOVE2
      1  72cc ????				      SEG	GENMOVE2
      2  7000					      ORG	_ORIGIN
      3  7000					      RORG	_BANK_ADDRESS_ORIGIN
      4  7000				   _BANK_START SET	*
      5  7000				   GENMOVE2_START SET	*
      6  7000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7000				   GENMOVE2   SET	_BANK_SLOT + _CURRENT_BANK
      8  7000				   _ORIGIN    SET	_ORIGIN + 1024
      7  7000
------- FILE Handler_ROOK.asm LEVEL 3 PASS 4
      0  7000					      include	"Handler_ROOK.asm"
      1  7000							; Copyright (C)2020 Andrew Davie
      2  7000							; Rook move handler
      3  7000
      4  7000							;---------------------------------------------------------------------------------------------------
      5  7000							; ROOK
      6  7000							;---------------------------------------------------------------------------------------------------
      7  7000
      0  7000					      DEF	Handle_ROOK
      1  7000				   SLOT_Handle_ROOK SET	_BANK_SLOT
      2  7000				   BANK_Handle_ROOK SET	SLOT_Handle_ROOK + _CURRENT_BANK
      3  7000				   Handle_ROOK
      4  7000				   TEMPORARY_VAR SET	Overlay
      5  7000				   TEMPORARY_OFFSET SET	0
      6  7000				   VAR_BOUNDARY_Handle_ROOK SET	TEMPORARY_OFFSET
      7  7000				   FUNCTION_NAME SET	Handle_ROOK
      9  7000					      SUBROUTINE
     10  7000
      0  7000					      REFER	GenerateAllMoves
      1  7000					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  7000				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  7000					      ENDIF
      0  7000					      VEND	Handle_ROOK
      1  7000				  -	      IFNCONST	Handle_ROOK
      2  7000				  -	      ECHO	"Incorrect VEND label", Handle_ROOK
      3  7000				  -	      ERR
      4  7000					      ENDIF
      5  7000		       00 b3	   VAREND_Handle_ROOK =	TEMPORARY_VAR
     13  7000
     14  7000							; Pass...
     15  7000							; x = currentSquare (square the piece is on)
     16  7000							; currentPiece (with flags/colour attached)
     17  7000
      0  7000					      MOVE_TOWARDS	_DOWN
      1  7000					      SUBROUTINE
      2  7000
      3  7000
      4  7000
      5  7000		       a9 00		      lda	#0
      6  7002		       85 9e		      sta	capture
      7  7004
      8  7004		       a6 93		      ldx	currentSquare
      9  7006		       d0 03		      bne	.project
     10  7008
     11  7008		       20 05 f5    .empty     jsr	AddMove
     12  700b		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  700e		       30 0e		      bmi	.invalid
     14  7010		       b9 79 fc 	      lda	Board,y
     15  7013		       f0 f3		      beq	.empty
     16  7015		       85 9e		      sta	capture
     17  7017		       45 92		      eor	currentPiece
     18  7019		       10 03		      bpl	.invalid
     19  701b		       20 05 f5 	      jsr	AddMove
     20  701e
     21  701e				   .invalid
      0  701e					      MOVE_TOWARDS	_RIGHT
      1  701e					      SUBROUTINE
      2  701e
      3  701e
      4  701e
      5  701e		       a9 00		      lda	#0
      6  7020		       85 9e		      sta	capture
      7  7022
      8  7022		       a6 93		      ldx	currentSquare
      9  7024		       d0 03		      bne	.project
     10  7026
     11  7026		       20 05 f5    .empty     jsr	AddMove
     12  7029		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  702c		       30 0e		      bmi	.invalid
     14  702e		       b9 79 fc 	      lda	Board,y
     15  7031		       f0 f3		      beq	.empty
     16  7033		       85 9e		      sta	capture
     17  7035		       45 92		      eor	currentPiece
     18  7037		       10 03		      bpl	.invalid
     19  7039		       20 05 f5 	      jsr	AddMove
     20  703c
     21  703c				   .invalid
      0  703c					      MOVE_TOWARDS	_UP
      1  703c					      SUBROUTINE
      2  703c
      3  703c
      4  703c
      5  703c		       a9 00		      lda	#0
      6  703e		       85 9e		      sta	capture
      7  7040
      8  7040		       a6 93		      ldx	currentSquare
      9  7042		       d0 03		      bne	.project
     10  7044
     11  7044		       20 05 f5    .empty     jsr	AddMove
     12  7047		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  704a		       30 0e		      bmi	.invalid
     14  704c		       b9 79 fc 	      lda	Board,y
     15  704f		       f0 f3		      beq	.empty
     16  7051		       85 9e		      sta	capture
     17  7053		       45 92		      eor	currentPiece
     18  7055		       10 03		      bpl	.invalid
     19  7057		       20 05 f5 	      jsr	AddMove
     20  705a
     21  705a				   .invalid
      0  705a					      MOVE_TOWARDS	_LEFT
      1  705a					      SUBROUTINE
      2  705a
      3  705a
      4  705a
      5  705a		       a9 00		      lda	#0
      6  705c		       85 9e		      sta	capture
      7  705e
      8  705e		       a6 93		      ldx	currentSquare
      9  7060		       d0 03		      bne	.project
     10  7062
     11  7062		       20 05 f5    .empty     jsr	AddMove
     12  7065		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  7068		       30 0e		      bmi	.invalid
     14  706a		       b9 79 fc 	      lda	Board,y
     15  706d		       f0 f3		      beq	.empty
     16  706f		       85 9e		      sta	capture
     17  7071		       45 92		      eor	currentPiece
     18  7073		       10 03		      bpl	.invalid
     19  7075		       20 05 f5 	      jsr	AddMove
     20  7078
     21  7078				   .invalid
     22  7078
     23  7078		       4c 40 f5 	      jmp	MoveReturn
     24  707b
     25  707b							;---------------------------------------------------------------------------------------------------
     26  707b							; EOF
------- FILE GENMOVE2.asm
------- FILE Handler_KNIGHT.asm LEVEL 3 PASS 4
      0  707b					      include	"Handler_KNIGHT.asm"
      1  707b							; Copyright (C)2020 Andrew Davie
      2  707b							; Knight move handler
      3  707b
      4  707b							;---------------------------------------------------------------------------------------------------
      5  707b							; KNIGHT
      6  707b							;---------------------------------------------------------------------------------------------------
      7  707b
      0  707b					      DEF	Handle_KNIGHT
      1  707b				   SLOT_Handle_KNIGHT SET	_BANK_SLOT
      2  707b				   BANK_Handle_KNIGHT SET	SLOT_Handle_KNIGHT + _CURRENT_BANK
      3  707b				   Handle_KNIGHT
      4  707b				   TEMPORARY_VAR SET	Overlay
      5  707b				   TEMPORARY_OFFSET SET	0
      6  707b				   VAR_BOUNDARY_Handle_KNIGHT SET	TEMPORARY_OFFSET
      7  707b				   FUNCTION_NAME SET	Handle_KNIGHT
      9  707b					      SUBROUTINE
     10  707b
      0  707b					      REFER	GenerateAllMoves
      1  707b					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  707b				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  707b					      ENDIF
      0  707b					      VEND	Handle_KNIGHT
      1  707b				  -	      IFNCONST	Handle_KNIGHT
      2  707b				  -	      ECHO	"Incorrect VEND label", Handle_KNIGHT
      3  707b				  -	      ERR
      4  707b					      ENDIF
      5  707b		       00 b3	   VAREND_Handle_KNIGHT =	TEMPORARY_VAR
     13  707b
     14  707b							; x = currentSquare (square the piece is on)
     15  707b							; currentPiece (with flags/colour attached)
     16  707b
      0  707b					      MOVE_TO	_DOWN+_DOWN+_LEFT
      1  707b					      SUBROUTINE
      2  707b		       bc 00 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_LEFT,x
      3  707e		       30 0e		      bmi	.invalid
      4  7080		       b9 79 fc 	      lda	Board,y
      5  7083		       85 9e		      sta	capture
      6  7085		       f0 04		      beq	.squareEmpty
      7  7087		       45 92		      eor	currentPiece
      8  7089		       10 03		      bpl	.invalid
      9  708b		       20 05 f5    .squareEmpty jsr	AddMove
     10  708e				   .invalid
      0  708e					      MOVE_TO_X	_DOWN+_DOWN+_RIGHT
      1  708e		       a6 93		      ldx	currentSquare
      0  7090					      MOVE_TO	_DOWN+_DOWN+_RIGHT
      1  7090					      SUBROUTINE
      2  7090		       bc 02 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_RIGHT,x
      3  7093		       30 0e		      bmi	.invalid
      4  7095		       b9 79 fc 	      lda	Board,y
      5  7098		       85 9e		      sta	capture
      6  709a		       f0 04		      beq	.squareEmpty
      7  709c		       45 92		      eor	currentPiece
      8  709e		       10 03		      bpl	.invalid
      9  70a0		       20 05 f5    .squareEmpty jsr	AddMove
     10  70a3				   .invalid
      0  70a3					      MOVE_TO_X	_UP+_UP+_LEFT
      1  70a3		       a6 93		      ldx	currentSquare
      0  70a5					      MOVE_TO	_UP+_UP+_LEFT
      1  70a5					      SUBROUTINE
      2  70a5		       bc 28 fc 	      ldy	ValidSquare+_UP+_UP+_LEFT,x
      3  70a8		       30 0e		      bmi	.invalid
      4  70aa		       b9 79 fc 	      lda	Board,y
      5  70ad		       85 9e		      sta	capture
      6  70af		       f0 04		      beq	.squareEmpty
      7  70b1		       45 92		      eor	currentPiece
      8  70b3		       10 03		      bpl	.invalid
      9  70b5		       20 05 f5    .squareEmpty jsr	AddMove
     10  70b8				   .invalid
      0  70b8					      MOVE_TO_X	_UP+_UP+_RIGHT
      1  70b8		       a6 93		      ldx	currentSquare
      0  70ba					      MOVE_TO	_UP+_UP+_RIGHT
      1  70ba					      SUBROUTINE
      2  70ba		       bc 2a fc 	      ldy	ValidSquare+_UP+_UP+_RIGHT,x
      3  70bd		       30 0e		      bmi	.invalid
      4  70bf		       b9 79 fc 	      lda	Board,y
      5  70c2		       85 9e		      sta	capture
      6  70c4		       f0 04		      beq	.squareEmpty
      7  70c6		       45 92		      eor	currentPiece
      8  70c8		       10 03		      bpl	.invalid
      9  70ca		       20 05 f5    .squareEmpty jsr	AddMove
     10  70cd				   .invalid
     21  70cd
      0  70cd					      MOVE_TO_X	_DOWN+_LEFT+_LEFT
      1  70cd		       a6 93		      ldx	currentSquare
      0  70cf					      MOVE_TO	_DOWN+_LEFT+_LEFT
      1  70cf					      SUBROUTINE
      2  70cf		       bc 09 fc 	      ldy	ValidSquare+_DOWN+_LEFT+_LEFT,x
      3  70d2		       30 0e		      bmi	.invalid
      4  70d4		       b9 79 fc 	      lda	Board,y
      5  70d7		       85 9e		      sta	capture
      6  70d9		       f0 04		      beq	.squareEmpty
      7  70db		       45 92		      eor	currentPiece
      8  70dd		       10 03		      bpl	.invalid
      9  70df		       20 05 f5    .squareEmpty jsr	AddMove
     10  70e2				   .invalid
      0  70e2					      MOVE_TO_X	_DOWN+_RIGHT+_RIGHT
      1  70e2		       a6 93		      ldx	currentSquare
      0  70e4					      MOVE_TO	_DOWN+_RIGHT+_RIGHT
      1  70e4					      SUBROUTINE
      2  70e4		       bc 0d fc 	      ldy	ValidSquare+_DOWN+_RIGHT+_RIGHT,x
      3  70e7		       30 0e		      bmi	.invalid
      4  70e9		       b9 79 fc 	      lda	Board,y
      5  70ec		       85 9e		      sta	capture
      6  70ee		       f0 04		      beq	.squareEmpty
      7  70f0		       45 92		      eor	currentPiece
      8  70f2		       10 03		      bpl	.invalid
      9  70f4		       20 05 f5    .squareEmpty jsr	AddMove
     10  70f7				   .invalid
      0  70f7					      MOVE_TO_X	_UP+_LEFT+_LEFT
      1  70f7		       a6 93		      ldx	currentSquare
      0  70f9					      MOVE_TO	_UP+_LEFT+_LEFT
      1  70f9					      SUBROUTINE
      2  70f9		       bc 1d fc 	      ldy	ValidSquare+_UP+_LEFT+_LEFT,x
      3  70fc		       30 0e		      bmi	.invalid
      4  70fe		       b9 79 fc 	      lda	Board,y
      5  7101		       85 9e		      sta	capture
      6  7103		       f0 04		      beq	.squareEmpty
      7  7105		       45 92		      eor	currentPiece
      8  7107		       10 03		      bpl	.invalid
      9  7109		       20 05 f5    .squareEmpty jsr	AddMove
     10  710c				   .invalid
      0  710c					      MOVE_TO_X	_UP+_RIGHT+_RIGHT
      1  710c		       a6 93		      ldx	currentSquare
      0  710e					      MOVE_TO	_UP+_RIGHT+_RIGHT
      1  710e					      SUBROUTINE
      2  710e		       bc 21 fc 	      ldy	ValidSquare+_UP+_RIGHT+_RIGHT,x
      3  7111		       30 0e		      bmi	.invalid
      4  7113		       b9 79 fc 	      lda	Board,y
      5  7116		       85 9e		      sta	capture
      6  7118		       f0 04		      beq	.squareEmpty
      7  711a		       45 92		      eor	currentPiece
      8  711c		       10 03		      bpl	.invalid
      9  711e		       20 05 f5    .squareEmpty jsr	AddMove
     10  7121				   .invalid
     26  7121
     27  7121		       4c 40 f5 	      jmp	MoveReturn
     28  7124
     29  7124							; EOF
------- FILE GENMOVE2.asm
------- FILE Handler_PAWN.asm LEVEL 3 PASS 4
      0  7124					      include	"Handler_PAWN.asm"
      1  7124							; Copyright (C)2020 Andrew Davie
      2  7124							; Pawn move handlers
      3  7124
      4  7124							;---------------------------------------------------------------------------------------------------
      5  7124							; WHITE PAWN
      6  7124							;---------------------------------------------------------------------------------------------------
      7  7124
      8  7124		       00 28	   WHITE_HOME_ROW =	40	; < this, on home row
      9  7124		       00 52	   BLACK_HOME_ROW =	82	; >= this, on home row
     10  7124
     11  7124							;---------------------------------------------------------------------------------------------------
     12  7124
     13  7124					      MAC	en_passant
     14  7124					      SUBROUTINE
     15  7124							; {1} = _LEFT or _RIGHT
     16  7124
     17  7124					      ldx	currentSquare
     18  7124					      ldy	ValidSquare+{1},x
     19  7124					      cpy	enPassantPawn
     20  7124					      bne	.invalid
     21  7124					      ldy	ValidSquare+{1}+{2},x	; en-passant endpoint must be blank
     22  7124					      lda	Board,y
     23  7124					      bne	.invalid
     24  7124					      jsr	AddMove	; the MOVE will need to deal with the details of en-passant??
     25  7124				   .invalid
     26  7124					      ENDM
     27  7124
     28  7124							;---------------------------------------------------------------------------------------------------
     29  7124
     30  7124					      MAC	promote_pawn
     31  7124							;SUBROUTINE
     32  7124
     33  7124							;{1} = BLACK or WHITE
     34  7124
     35  7124
     36  7124					      sty	__temp
     37  7124					      lda	#{1}|QUEEN
     38  7124					      sta	currentPiece
     39  7124					      jsr	AddMove
     40  7124
     41  7124					      lda	#{1}|ROOK
     42  7124					      sta	currentPiece
     43  7124					      ldy	__temp
     44  7124					      jsr	AddMove
     45  7124
     46  7124					      lda	#{1}|BISHOP
     47  7124					      sta	currentPiece
     48  7124					      ldy	__temp
     49  7124					      jsr	AddMove
     50  7124
     51  7124					      lda	#{1}|KNIGHT
     52  7124					      sta	currentPiece
     53  7124					      ldy	__temp
     54  7124					      jsr	AddMove
     55  7124
     56  7124					      IF	{1} = WHITE
     57  7124					      lda	#WHITE|WP
     58  7124					      ENDIF
     59  7124					      IF	{1} = BLACK
     60  7124					      lda	#BLACK|BP
     61  7124					      ENDIF
     62  7124					      sta	currentPiece
     63  7124					      ENDM
     64  7124
     65  7124							;---------------------------------------------------------------------------------------------------
     66  7124
     67  7124					      MAC	move_or_promote_pawn
     68  7124							;SUBROUTINE
     69  7124							; {1} = BLACK or WHITE
     70  7124
     71  7124					      IF	{1} = WHITE
     72  7124					      cpy	#90	; last rank?
     73  7124					      bcc	.standard
     74  7124					      jsr	PromoteWhitePawn
     75  7124					      jmp	.pMoved
     76  7124					      ENDIF
     77  7124
     78  7124					      IF	{1} = BLACK
     79  7124					      cpy	#30	; last rank?
     80  7124					      bcs	.standard
     81  7124					      jsr	PromoteBlackPawn
     82  7124					      jmp	.pMoved
     83  7124					      ENDIF
     84  7124
     85  7124				   .standard  jsr	AddMove	; add +1UP move
     86  7124				   .pMoved
     87  7124
     88  7124					      ENDM
     89  7124
     90  7124							;---------------------------------------------------------------------------------------------------
     91  7124
     92  7124					      MAC	take
     93  7124							;SUBROUTINE
     94  7124							; {1} = capture square offset
     95  7124
     96  7124					      ldx	currentSquare
     97  7124					      ldy	ValidSquare+{1},x
     98  7124					      bmi	.invalid2
     99  7124					      lda	Board,y
    100  7124					      beq	.invalid2	; square empty
    101  7124					      sta	capture
    102  7124					      eor	currentPiece
    103  7124					      bpl	.invalid	; same colour
    104  7124
    105  7124					      MOVE_OR_PROMOTE_PAWN	{2}
    106  7124
    107  7124					      jmp	.invalid2
    108  7124				   .invalid   inc	protecting
    109  7124				   .invalid2
    110  7124					      ENDM
    111  7124
    112  7124							;---------------------------------------------------------------------------------------------------
    113  7124
      0  7124					      DEF	PromoteWhitePawn
      1  7124				   SLOT_PromoteWhitePawn SET	_BANK_SLOT
      2  7124				   BANK_PromoteWhitePawn SET	SLOT_PromoteWhitePawn + _CURRENT_BANK
      3  7124				   PromoteWhitePawn
      4  7124				   TEMPORARY_VAR SET	Overlay
      5  7124				   TEMPORARY_OFFSET SET	0
      6  7124				   VAR_BOUNDARY_PromoteWhitePawn SET	TEMPORARY_OFFSET
      7  7124				   FUNCTION_NAME SET	PromoteWhitePawn
    115  7124					      SUBROUTINE
    116  7124
      0  7124					      REFER	Handle_WHITE_PAWN
      1  7124					      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  7124				   TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  7124					      ENDIF
      0  7124					      VAR	__temp, 1
      1  7124		       00 b3	   __temp     =	TEMPORARY_VAR
      2  7124				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7124
      4  7124				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7124				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7124				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7124					      ENDIF
      8  7124				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7124				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  7124				  -	      ERR
     11  7124					      ENDIF
     12  7124					      LIST	ON
      0  7124					      VEND	PromoteWhitePawn
      1  7124				  -	      IFNCONST	PromoteWhitePawn
      2  7124				  -	      ECHO	"Incorrect VEND label", PromoteWhitePawn
      3  7124				  -	      ERR
      4  7124					      ENDIF
      5  7124		       00 b4	   VAREND_PromoteWhitePawn =	TEMPORARY_VAR
    120  7124
      0  7124					      PROMOTE_PAWN	WHITE
      1  7124
      2  7124
      3  7124
      4  7124
      5  7124
      6  7124		       84 b3		      sty	__temp
      7  7126		       a9 06		      lda	#WHITE|QUEEN
      8  7128		       85 92		      sta	currentPiece
      9  712a		       20 05 f5 	      jsr	AddMove
     10  712d
     11  712d		       a9 05		      lda	#WHITE|ROOK
     12  712f		       85 92		      sta	currentPiece
     13  7131		       a4 b3		      ldy	__temp
     14  7133		       20 05 f5 	      jsr	AddMove
     15  7136
     16  7136		       a9 04		      lda	#WHITE|BISHOP
     17  7138		       85 92		      sta	currentPiece
     18  713a		       a4 b3		      ldy	__temp
     19  713c		       20 05 f5 	      jsr	AddMove
     20  713f
     21  713f		       a9 03		      lda	#WHITE|KNIGHT
     22  7141		       85 92		      sta	currentPiece
     23  7143		       a4 b3		      ldy	__temp
     24  7145		       20 05 f5 	      jsr	AddMove
     25  7148
     26  7148					      IF	WHITE = WHITE
     27  7148		       a9 01		      lda	#WHITE|WP
     28  714a					      ENDIF
     29  714a				  -	      IF	WHITE = BLACK
     30  714a				  -	      lda	#BLACK|BP
     31  714a					      ENDIF
     32  714a		       85 92		      sta	currentPiece
    122  714c		       60		      rts
    123  714d
    124  714d							;---------------------------------------------------------------------------------------------------
    125  714d
      0  714d					      DEF	Handle_WHITE_PAWN
      1  714d				   SLOT_Handle_WHITE_PAWN SET	_BANK_SLOT
      2  714d				   BANK_Handle_WHITE_PAWN SET	SLOT_Handle_WHITE_PAWN + _CURRENT_BANK
      3  714d				   Handle_WHITE_PAWN
      4  714d				   TEMPORARY_VAR SET	Overlay
      5  714d				   TEMPORARY_OFFSET SET	0
      6  714d				   VAR_BOUNDARY_Handle_WHITE_PAWN SET	TEMPORARY_OFFSET
      7  714d				   FUNCTION_NAME SET	Handle_WHITE_PAWN
    127  714d					      SUBROUTINE
    128  714d
      0  714d					      REFER	GenerateAllMoves
      1  714d					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  714d				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  714d					      ENDIF
      0  714d					      VEND	Handle_WHITE_PAWN
      1  714d				  -	      IFNCONST	Handle_WHITE_PAWN
      2  714d				  -	      ECHO	"Incorrect VEND label", Handle_WHITE_PAWN
      3  714d				  -	      ERR
      4  714d					      ENDIF
      5  714d		       00 b3	   VAREND_Handle_WHITE_PAWN =	TEMPORARY_VAR
    131  714d
    132  714d		       bc 1f fc 	      ldy	ValidSquare+_UP,x	; square above must be blank (WILL NOT EVER be off-board!)
    133  7150		       b9 79 fc 	      lda	Board,y
    134  7153		       d0 26		      bne	.pMoved	; occupied
    135  7155		       85 9e		      sta	capture
    136  7157
    137  7157							; we may need to promote the pawn
    138  7157							; All possibilites (Q/R/B/N) are added as individual moves
    139  7157
      0  7157					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  7157
      2  7157
      3  7157
      4  7157					      IF	WHITE = WHITE
      5  7157		       c0 5a		      cpy	#90
      6  7159		       90 06		      bcc	.standard
      7  715b		       20 24 f5 	      jsr	PromoteWhitePawn
      8  715e		       4c 64 f5 	      jmp	.pMoved
      9  7161					      ENDIF
     10  7161
     11  7161				  -	      IF	WHITE = BLACK
     12  7161				  -	      cpy	#30
     13  7161				  -	      bcs	.standard
     14  7161				  -	      jsr	PromoteBlackPawn
     15  7161				  -	      jmp	.pMoved
     16  7161					      ENDIF
     17  7161
     18  7161		       20 05 f5    .standard  jsr	AddMove
     19  7164				   .pMoved
     20  7164
    141  7164
    142  7164							; the +2 move off the home rank...
    143  7164
    144  7164		       a6 93		      ldx	currentSquare
    145  7166		       e0 28		      cpx	#WHITE_HOME_ROW
    146  7168		       b0 11		      bcs	.pMoved	; pawn has moved so can't do +2
    147  716a		       bc 29 fc 	      ldy	ValidSquare+_UP+_UP,x	; WILL be a valid square
    148  716d		       b9 79 fc 	      lda	Board,y
    149  7170		       d0 09		      bne	.pMoved	; destination square occupied
    150  7172
    151  7172		       a5 92		      lda	currentPiece
    152  7174		       09 20		      ora	#FLAG_ENPASSANT
    153  7176		       85 92		      sta	currentPiece	; GENERATE en-passant opportunity
    154  7178
    155  7178		       20 05 f5 	      jsr	AddMove	; add the +2UP move off home row
    156  717b
    157  717b				   .pMoved
    158  717b
    159  717b							; regular captures...
    160  717b
      0  717b					      TAKE	_UP+_LEFT, WHITE
      1  717b
      2  717b
      3  717b
      4  717b		       a6 93		      ldx	currentSquare
      5  717d		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      6  7180		       30 1d		      bmi	.invalid2
      7  7182		       b9 79 fc 	      lda	Board,y
      8  7185		       f0 18		      beq	.invalid2
      9  7187		       85 9e		      sta	capture
     10  7189		       45 92		      eor	currentPiece
     11  718b		       10 10		      bpl	.invalid
     12  718d
      0  718d					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  718d
      2  718d
      3  718d
      4  718d					      IF	WHITE = WHITE
      5  718d		       c0 5a		      cpy	#90
      6  718f		       90 06		      bcc	.standard
      7  7191		       20 24 f5 	      jsr	PromoteWhitePawn
      8  7194		       4c 9a f5 	      jmp	.pMoved
      9  7197					      ENDIF
     10  7197
     11  7197				  -	      IF	WHITE = BLACK
     12  7197				  -	      cpy	#30
     13  7197				  -	      bcs	.standard
     14  7197				  -	      jsr	PromoteBlackPawn
     15  7197				  -	      jmp	.pMoved
     16  7197					      ENDIF
     17  7197
     18  7197		       20 05 f5    .standard  jsr	AddMove
     19  719a				   .pMoved
     20  719a
     14  719a
     15  719a		       4c 9f f5 	      jmp	.invalid2
     16  719d		       e6 a0	   .invalid   inc	protecting
     17  719f				   .invalid2
      0  719f					      TAKE	_UP+_RIGHT, WHITE
      1  719f
      2  719f
      3  719f
      4  719f		       a6 93		      ldx	currentSquare
      5  71a1		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      6  71a4		       30 1d		      bmi	.invalid2
      7  71a6		       b9 79 fc 	      lda	Board,y
      8  71a9		       f0 18		      beq	.invalid2
      9  71ab		       85 9e		      sta	capture
     10  71ad		       45 92		      eor	currentPiece
     11  71af		       10 10		      bpl	.invalid
     12  71b1
      0  71b1					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  71b1
      2  71b1
      3  71b1
      4  71b1					      IF	WHITE = WHITE
      5  71b1		       c0 5a		      cpy	#90
      6  71b3		       90 06		      bcc	.standard
      7  71b5		       20 24 f5 	      jsr	PromoteWhitePawn
      8  71b8		       4c be f5 	      jmp	.pMoved
      9  71bb					      ENDIF
     10  71bb
     11  71bb				  -	      IF	WHITE = BLACK
     12  71bb				  -	      cpy	#30
     13  71bb				  -	      bcs	.standard
     14  71bb				  -	      jsr	PromoteBlackPawn
     15  71bb				  -	      jmp	.pMoved
     16  71bb					      ENDIF
     17  71bb
     18  71bb		       20 05 f5    .standard  jsr	AddMove
     19  71be				   .pMoved
     20  71be
     14  71be
     15  71be		       4c c3 f5 	      jmp	.invalid2
     16  71c1		       e6 a0	   .invalid   inc	protecting
     17  71c3				   .invalid2
    163  71c3
    164  71c3
    165  71c3					      IF	ENPASSANT_ENABLED
    166  71c3							; en-passant captures...
    167  71c3
    168  71c3		       a5 94		      lda	enPassantPawn
    169  71c5		       f0 2e		      beq	.noEnPassant	; previous move (opponent) enpassant square?
    170  71c7
    171  71c7		       a5 92		      lda	currentPiece
    172  71c9		       09 20		      ora	#FLAG_ENPASSANT
    173  71cb		       85 92		      sta	currentPiece	; CONSUME en-passant opportunity
    174  71cd
      0  71cd					      EN_PASSANT	_LEFT, _UP
      1  71cd					      SUBROUTINE
      2  71cd
      3  71cd
      4  71cd		       a6 93		      ldx	currentSquare
      5  71cf		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      6  71d2		       c4 94		      cpy	enPassantPawn
      7  71d4		       d0 0b		      bne	.invalid
      8  71d6		       bc 1e fc 	      ldy	ValidSquare+_LEFT+_UP,x
      9  71d9		       b9 79 fc 	      lda	Board,y
     10  71dc		       d0 03		      bne	.invalid
     11  71de		       20 05 f5 	      jsr	AddMove
     12  71e1				   .invalid
      0  71e1					      EN_PASSANT	_RIGHT, _UP
      1  71e1					      SUBROUTINE
      2  71e1
      3  71e1
      4  71e1		       a6 93		      ldx	currentSquare
      5  71e3		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      6  71e6		       c4 94		      cpy	enPassantPawn
      7  71e8		       d0 0b		      bne	.invalid
      8  71ea		       bc 20 fc 	      ldy	ValidSquare+_RIGHT+_UP,x
      9  71ed		       b9 79 fc 	      lda	Board,y
     10  71f0		       d0 03		      bne	.invalid
     11  71f2		       20 05 f5 	      jsr	AddMove
     12  71f5				   .invalid
    177  71f5
    178  71f5				   .noEnPassant
    179  71f5					      ENDIF
    180  71f5
    181  71f5		       4c 40 f5 	      jmp	MoveReturn
    182  71f8
    183  71f8
    184  71f8							;---------------------------------------------------------------------------------------------------
    185  71f8							; BLACK PAWN
    186  71f8							;---------------------------------------------------------------------------------------------------
    187  71f8
      0  71f8					      DEF	PromoteBlackPawn
      1  71f8				   SLOT_PromoteBlackPawn SET	_BANK_SLOT
      2  71f8				   BANK_PromoteBlackPawn SET	SLOT_PromoteBlackPawn + _CURRENT_BANK
      3  71f8				   PromoteBlackPawn
      4  71f8				   TEMPORARY_VAR SET	Overlay
      5  71f8				   TEMPORARY_OFFSET SET	0
      6  71f8				   VAR_BOUNDARY_PromoteBlackPawn SET	TEMPORARY_OFFSET
      7  71f8				   FUNCTION_NAME SET	PromoteBlackPawn
    189  71f8					      SUBROUTINE
    190  71f8
      0  71f8					      REFER	Handle_BLACK_PAWN
      1  71f8					      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  71f8				   TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  71f8					      ENDIF
      0  71f8					      VAR	__temp, 1
      1  71f8		       00 b3	   __temp     =	TEMPORARY_VAR
      2  71f8				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  71f8
      4  71f8				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  71f8				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  71f8				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  71f8					      ENDIF
      8  71f8				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  71f8				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  71f8				  -	      ERR
     11  71f8					      ENDIF
     12  71f8					      LIST	ON
      0  71f8					      VEND	PromoteBlackPawn
      1  71f8				  -	      IFNCONST	PromoteBlackPawn
      2  71f8				  -	      ECHO	"Incorrect VEND label", PromoteBlackPawn
      3  71f8				  -	      ERR
      4  71f8					      ENDIF
      5  71f8		       00 b4	   VAREND_PromoteBlackPawn =	TEMPORARY_VAR
    194  71f8
      0  71f8					      PROMOTE_PAWN	BLACK
      1  71f8
      2  71f8
      3  71f8
      4  71f8
      5  71f8
      6  71f8		       84 b3		      sty	__temp
      7  71fa		       a9 86		      lda	#BLACK|QUEEN
      8  71fc		       85 92		      sta	currentPiece
      9  71fe		       20 05 f5 	      jsr	AddMove
     10  7201
     11  7201		       a9 85		      lda	#BLACK|ROOK
     12  7203		       85 92		      sta	currentPiece
     13  7205		       a4 b3		      ldy	__temp
     14  7207		       20 05 f5 	      jsr	AddMove
     15  720a
     16  720a		       a9 84		      lda	#BLACK|BISHOP
     17  720c		       85 92		      sta	currentPiece
     18  720e		       a4 b3		      ldy	__temp
     19  7210		       20 05 f5 	      jsr	AddMove
     20  7213
     21  7213		       a9 83		      lda	#BLACK|KNIGHT
     22  7215		       85 92		      sta	currentPiece
     23  7217		       a4 b3		      ldy	__temp
     24  7219		       20 05 f5 	      jsr	AddMove
     25  721c
     26  721c				  -	      IF	BLACK = WHITE
     27  721c				  -	      lda	#WHITE|WP
     28  721c					      ENDIF
     29  721c					      IF	BLACK = BLACK
     30  721c		       a9 82		      lda	#BLACK|BP
     31  721e					      ENDIF
     32  721e		       85 92		      sta	currentPiece
    196  7220		       60		      rts
    197  7221
      0  7221					      DEF	Handle_BLACK_PAWN
      1  7221				   SLOT_Handle_BLACK_PAWN SET	_BANK_SLOT
      2  7221				   BANK_Handle_BLACK_PAWN SET	SLOT_Handle_BLACK_PAWN + _CURRENT_BANK
      3  7221				   Handle_BLACK_PAWN
      4  7221				   TEMPORARY_VAR SET	Overlay
      5  7221				   TEMPORARY_OFFSET SET	0
      6  7221				   VAR_BOUNDARY_Handle_BLACK_PAWN SET	TEMPORARY_OFFSET
      7  7221				   FUNCTION_NAME SET	Handle_BLACK_PAWN
    199  7221					      SUBROUTINE
    200  7221
      0  7221					      REFER	GenerateAllMoves
      1  7221					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  7221				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  7221					      ENDIF
      0  7221					      VEND	Handle_BLACK_PAWN
      1  7221				  -	      IFNCONST	Handle_BLACK_PAWN
      2  7221				  -	      ECHO	"Incorrect VEND label", Handle_BLACK_PAWN
      3  7221				  -	      ERR
      4  7221					      ENDIF
      5  7221		       00 b3	   VAREND_Handle_BLACK_PAWN =	TEMPORARY_VAR
    203  7221
    204  7221		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x	; square below must be blank (WILL NOT EVER be off-board!)
    205  7224		       b9 79 fc 	      lda	Board,y
    206  7227		       d0 26		      bne	.pMoved	; occupied
    207  7229		       85 9e		      sta	capture
    208  722b
    209  722b							; we may need to promote the pawn
    210  722b							; All possibilites (Q/R/B/N) are added as individual moves
    211  722b
      0  722b					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  722b
      2  722b
      3  722b
      4  722b				  -	      IF	BLACK = WHITE
      5  722b				  -	      cpy	#90
      6  722b				  -	      bcc	.standard
      7  722b				  -	      jsr	PromoteWhitePawn
      8  722b				  -	      jmp	.pMoved
      9  722b					      ENDIF
     10  722b
     11  722b					      IF	BLACK = BLACK
     12  722b		       c0 1e		      cpy	#30
     13  722d		       b0 06		      bcs	.standard
     14  722f		       20 f8 f5 	      jsr	PromoteBlackPawn
     15  7232		       4c 38 f6 	      jmp	.pMoved
     16  7235					      ENDIF
     17  7235
     18  7235		       20 05 f5    .standard  jsr	AddMove
     19  7238				   .pMoved
     20  7238
    213  7238
    214  7238							; the +2 move off the home rank...
    215  7238
    216  7238		       a6 93		      ldx	currentSquare
    217  723a		       e0 52		      cpx	#BLACK_HOME_ROW
    218  723c		       90 11		      bcc	.pMoved	; pawn has moved so can't do +2
    219  723e
    220  723e
    221  723e		       bc 01 fc 	      ldy	ValidSquare+_DOWN+_DOWN,x	; WILL be a valid square
    222  7241		       b9 79 fc 	      lda	Board,y
    223  7244		       d0 09		      bne	.pMoved	; destination square occupied
    224  7246
    225  7246		       a5 92		      lda	currentPiece
    226  7248		       09 20		      ora	#FLAG_ENPASSANT
    227  724a		       85 92		      sta	currentPiece	; CAN en-passant
    228  724c
    229  724c		       20 05 f5 	      jsr	AddMove	; add the +2DOWN move off home row
    230  724f
    231  724f				   .pMoved
    232  724f
    233  724f							; regular captures... (with promotion)
    234  724f
      0  724f					      TAKE	_DOWN+_LEFT, BLACK
      1  724f
      2  724f
      3  724f
      4  724f		       a6 93		      ldx	currentSquare
      5  7251		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      6  7254		       30 1d		      bmi	.invalid2
      7  7256		       b9 79 fc 	      lda	Board,y
      8  7259		       f0 18		      beq	.invalid2
      9  725b		       85 9e		      sta	capture
     10  725d		       45 92		      eor	currentPiece
     11  725f		       10 10		      bpl	.invalid
     12  7261
      0  7261					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  7261
      2  7261
      3  7261
      4  7261				  -	      IF	BLACK = WHITE
      5  7261				  -	      cpy	#90
      6  7261				  -	      bcc	.standard
      7  7261				  -	      jsr	PromoteWhitePawn
      8  7261				  -	      jmp	.pMoved
      9  7261					      ENDIF
     10  7261
     11  7261					      IF	BLACK = BLACK
     12  7261		       c0 1e		      cpy	#30
     13  7263		       b0 06		      bcs	.standard
     14  7265		       20 f8 f5 	      jsr	PromoteBlackPawn
     15  7268		       4c 6e f6 	      jmp	.pMoved
     16  726b					      ENDIF
     17  726b
     18  726b		       20 05 f5    .standard  jsr	AddMove
     19  726e				   .pMoved
     20  726e
     14  726e
     15  726e		       4c 73 f6 	      jmp	.invalid2
     16  7271		       e6 a0	   .invalid   inc	protecting
     17  7273				   .invalid2
      0  7273					      TAKE	_DOWN+_RIGHT, BLACK
      1  7273
      2  7273
      3  7273
      4  7273		       a6 93		      ldx	currentSquare
      5  7275		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      6  7278		       30 1d		      bmi	.invalid2
      7  727a		       b9 79 fc 	      lda	Board,y
      8  727d		       f0 18		      beq	.invalid2
      9  727f		       85 9e		      sta	capture
     10  7281		       45 92		      eor	currentPiece
     11  7283		       10 10		      bpl	.invalid
     12  7285
      0  7285					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  7285
      2  7285
      3  7285
      4  7285				  -	      IF	BLACK = WHITE
      5  7285				  -	      cpy	#90
      6  7285				  -	      bcc	.standard
      7  7285				  -	      jsr	PromoteWhitePawn
      8  7285				  -	      jmp	.pMoved
      9  7285					      ENDIF
     10  7285
     11  7285					      IF	BLACK = BLACK
     12  7285		       c0 1e		      cpy	#30
     13  7287		       b0 06		      bcs	.standard
     14  7289		       20 f8 f5 	      jsr	PromoteBlackPawn
     15  728c		       4c 92 f6 	      jmp	.pMoved
     16  728f					      ENDIF
     17  728f
     18  728f		       20 05 f5    .standard  jsr	AddMove
     19  7292				   .pMoved
     20  7292
     14  7292
     15  7292		       4c 97 f6 	      jmp	.invalid2
     16  7295		       e6 a0	   .invalid   inc	protecting
     17  7297				   .invalid2
    237  7297
    238  7297
    239  7297					      IF	ENPASSANT_ENABLED
    240  7297							; en-passant captures...
    241  7297
    242  7297		       a5 94		      lda	enPassantPawn
    243  7299		       f0 2e		      beq	.noEnPassant	; was last move en-passantable?
    244  729b
    245  729b		       a5 92		      lda	currentPiece
    246  729d		       09 20		      ora	#FLAG_ENPASSANT
    247  729f		       85 92		      sta	currentPiece	; any en-passant move added will have flag set
    248  72a1
      0  72a1					      EN_PASSANT	_LEFT, _DOWN
      1  72a1					      SUBROUTINE
      2  72a1
      3  72a1
      4  72a1		       a6 93		      ldx	currentSquare
      5  72a3		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      6  72a6		       c4 94		      cpy	enPassantPawn
      7  72a8		       d0 0b		      bne	.invalid
      8  72aa		       bc 0a fc 	      ldy	ValidSquare+_LEFT+_DOWN,x
      9  72ad		       b9 79 fc 	      lda	Board,y
     10  72b0		       d0 03		      bne	.invalid
     11  72b2		       20 05 f5 	      jsr	AddMove
     12  72b5				   .invalid
      0  72b5					      EN_PASSANT	_RIGHT, _DOWN
      1  72b5					      SUBROUTINE
      2  72b5
      3  72b5
      4  72b5		       a6 93		      ldx	currentSquare
      5  72b7		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      6  72ba		       c4 94		      cpy	enPassantPawn
      7  72bc		       d0 0b		      bne	.invalid
      8  72be		       bc 0c fc 	      ldy	ValidSquare+_RIGHT+_DOWN,x
      9  72c1		       b9 79 fc 	      lda	Board,y
     10  72c4		       d0 03		      bne	.invalid
     11  72c6		       20 05 f5 	      jsr	AddMove
     12  72c9				   .invalid
    251  72c9
    252  72c9				   .noEnPassant
    253  72c9					      ENDIF
    254  72c9
    255  72c9		       4c 40 f5 	      jmp	MoveReturn
    256  72cc
    257  72cc							; EOF
------- FILE GENMOVE2.asm
     11  72cc
     12  72cc							;---------------------------------------------------------------------------------------------------
     13  72cc
      0  72cc					      CHECK_BANK_SIZE	"GENMOVE2"
      1  72cc		       02 cc	   .TEMP      =	* - _BANK_START
 GENMOVE2 (1K) SIZE =  $2cc , FREE= $134
      2  72cc					      ECHO	"GENMOVE2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  72cc				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  72cc				  -	      ECHO	"BANK OVERFLOW @ ", "GENMOVE2", " size=", * - ORIGIN
      5  72cc				  -	      ERR
      6  72cc					      ENDIF
     15  72cc
     16  72cc							;---------------------------------------------------------------------------------------------------
     17  72cc							; EOF
------- FILE ./chess.asm
    632  72cc
------- FILE BANK_GENERIC@1#2.asm LEVEL 2 PASS 4
      0  72cc					      include	"BANK_GENERIC@1#2.asm"
      1  72cc							; Chess
      2  72cc							; Copyright (c) 2019-2020 Andrew Davie
      3  72cc							; andrew@taswegian.com
      4  72cc
      0  72cc					      SLOT	1
      1  72cc				  -	      IF	(1 < 0) || (1 > 3)
      2  72cc				  -	      ECHO	"Illegal bank address/segment location", 1
      3  72cc				  -	      ERR
      4  72cc					      ENDIF
      5  72cc				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  72cc				   _BANK_SLOT SET	1 * 64
      0  72cc					      NEWBANK	TWO
      1  76bd ????				      SEG	TWO
      2  7400					      ORG	_ORIGIN
      3  7400					      RORG	_BANK_ADDRESS_ORIGIN
      4  7400				   _BANK_START SET	*
      5  7400				   TWO_START  SET	*
      6  7400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7400				   TWO	      SET	_BANK_SLOT + _CURRENT_BANK
      8  7400				   _ORIGIN    SET	_ORIGIN + 1024
      7  7400
      8  7400
      9  7400							;---------------------------------------------------------------------------------------------------
     10  7400
     11  7400				  -	      IF	0
     12  7400				  -	      DEF	SAFE_BackupBitmaps
     13  7400				  -	      SUBROUTINE
     14  7400				  -
     15  7400				  -	      VEND	SAFE_BackupBitmaps
     16  7400				  -
     17  7400				  -	      sty	SET_BANK_RAM
     18  7400				  -	      jsr	SaveBitmap
     19  7400				  -	      lda	savedBank
     20  7400				  -	      sta	SET_BANK
     21  7400				  -	      rts
     22  7400					      ENDIF
     23  7400
     24  7400							;---------------------------------------------------------------------------------------------------
     25  7400
      0  7400					      DEF	MakeMove
      1  7400				   SLOT_MakeMove SET	_BANK_SLOT
      2  7400				   BANK_MakeMove SET	SLOT_MakeMove + _CURRENT_BANK
      3  7400				   MakeMove
      4  7400				   TEMPORARY_VAR SET	Overlay
      5  7400				   TEMPORARY_OFFSET SET	0
      6  7400				   VAR_BOUNDARY_MakeMove SET	TEMPORARY_OFFSET
      7  7400				   FUNCTION_NAME SET	MakeMove
     27  7400					      SUBROUTINE
     28  7400
      0  7400					      REFER	negaMax
      1  7400					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  7400				   TEMPORARY_VAR SET	VAREND_negaMax
      3  7400					      ENDIF
      0  7400					      VAR	__capture, 1
      1  7400		       00 ae	   __capture  =	TEMPORARY_VAR
      2  7400				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7400
      4  7400				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7400				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7400				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7400					      ENDIF
      8  7400				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7400				  -	      ECHO	"Temporary Variable", __capture, "overflow!"
     10  7400				  -	      ERR
     11  7400					      ENDIF
     12  7400					      LIST	ON
      0  7400					      VAR	__restore, 1
      1  7400		       00 af	   __restore  =	TEMPORARY_VAR
      2  7400				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7400
      4  7400				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7400				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7400				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7400					      ENDIF
      8  7400				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7400				  -	      ECHO	"Temporary Variable", __restore, "overflow!"
     10  7400				  -	      ERR
     11  7400					      ENDIF
     12  7400					      LIST	ON
      0  7400					      VEND	MakeMove
      1  7400				  -	      IFNCONST	MakeMove
      2  7400				  -	      ECHO	"Incorrect VEND label", MakeMove
      3  7400				  -	      ERR
      4  7400					      ENDIF
      5  7400		       00 b0	   VAREND_MakeMove =	TEMPORARY_VAR
     33  7400
     34  7400							; Do a move without any GUI stuff
     35  7400							; This function is ALWAYS paired with "unmakeMove" - a call to both will leave board
     36  7400							; and all relevant flags in original state. This is NOT used for the visible move on the
     37  7400							; screen.
     38  7400
     39  7400
     40  7400							; fromPiece	 piece doing the move
     41  7400							; fromX12	 current square X12
     42  7400							; originX12	 starting square X12
     43  7400							; toX12	 ending square X12
     44  7400
     45  7400
     46  7400							; There are potentially "two" moves, with the following
     47  7400							; a) Castling, moving both rook and king
     48  7400							; b) en-Passant, capturing pawn on "odd" square
     49  7400							; These both set "secondary" movers which are used for restoring during unmakeMove
     50  7400
     51  7400		       a9 00		      lda	#0
      0  7402					      sta@PLY	secondaryPiece
      1  7402		       8d 9b 01 	      sta	[RAM]+secondaryPiece
     53  7405
      0  7405					      ldx@PLY	movePtr
      1  7405		       ae 9f ff 	      ldx	movePtr
      0  7408					      lda@PLY	MoveFrom,x
      1  7408		       bd 00 fc 	      lda	MoveFrom,x
     56  740b		       85 85		      sta	fromX12
     57  740d		       85 87		      sta	originX12
      0  740f					      lda@PLY	MoveTo,x
      1  740f		       bd 00 fd 	      lda	MoveTo,x
     59  7412		       85 86		      sta	toX12
      0  7414					      lda@PLY	MovePiece,x
      1  7414		       bd 00 fe 	      lda	MovePiece,x
     61  7417		       85 97		      sta	fromPiece
     62  7419
     63  7419		       20 64 f5    .move      jsr	AdjustMaterialPositionalValue
     64  741c
     65  741c							; Modify the board
     66  741c
     67  741c		       a0 cf		      ldy	#RAMBANK_BOARD
     68  741e		       84 3e		      sty	SET_BANK_RAM
     69  7420		       a4 87		      ldy	originX12
      0  7422					      lda@RAM	Board,y
      1  7422		       b9 79 fc 	      lda	Board,y
     71  7425		       85 af		      sta	__restore
     72  7427		       a9 00		      lda	#0
      0  7429					      sta@RAM	Board,y
      1  7429		       99 79 fe 	      sta	[RAM]+Board,y
     74  742c		       a4 86		      ldy	toX12
      0  742e					      lda@RAM	Board,y
      1  742e		       b9 79 fc 	      lda	Board,y
     76  7431		       85 ae		      sta	__capture
     77  7433		       a5 97		      lda	fromPiece
     78  7435		       29 8f		      and	#PIECE_MASK|FLAG_COLOUR
     79  7437		       09 40		      ora	#FLAG_MOVED
      0  7439					      sta@RAM	Board,y
      1  7439		       99 79 fe 	      sta	[RAM]+Board,y
     81  743c
     82  743c		       a5 95		      lda	currentPly
     83  743e		       85 3e		      sta	SET_BANK_RAM
     84  7440		       a5 ae		      lda	__capture
      0  7442					      sta@PLY	capturedPiece
      1  7442		       8d 99 01 	      sta	[RAM]+capturedPiece
     86  7445		       a5 af		      lda	__restore
      0  7447					      sta@PLY	restorePiece
      1  7447		       8d a8 01 	      sta	[RAM]+restorePiece
     88  744a
     89  744a					      IF	CASTLING_ENABLED
     90  744a
     91  744a							; If the FROM piece has the castle bit set (i.e., it's a king that's just moved 2 squares)
     92  744a							; then we find the appropriate ROOK, set the secondary piece "undo" information, and then
     93  744a							; redo the moving code (for the rook, this time).
     94  744a
     95  744a		       20 8e f4 	      jsr	GenCastleMoveForRook
     96  744d		       b0 ca		      bcs	.move	; move the rook!
     97  744f					      ENDIF
     98  744f
     99  744f
    100  744f					      IF	ENPASSANT_ENABLED
    101  744f		       20 92 f6 	      jsr	EnPassantCheck
    102  7452		       f0 03		      beq	.notEnPassant
    103  7454		       20 f5 f5 	      jsr	EnPassantRemovePiece	; y = origin X12
    104  7457				   .notEnPassant
    105  7457					      ENDIF
    106  7457
    107  7457							; Swap over sides
    108  7457
      0  7457					      NEGEVAL
      1  7457
      2  7457		       38		      sec
      3  7458		       a9 00		      lda	#0
      4  745a		       e5 90		      sbc	Evaluation
      5  745c		       85 90		      sta	Evaluation
      6  745e		       a9 00		      lda	#0
      7  7460		       e5 91		      sbc	Evaluation+1
      8  7462		       85 91		      sta	Evaluation+1
      0  7464					      SWAP
      1  7464		       a5 96		      lda	sideToMove
      2  7466		       49 80		      eor	#SWAP_SIDE
      3  7468		       85 96		      sta	sideToMove
    111  746a
    112  746a		       a5 95		      lda	currentPly
    113  746c		       85 3e		      sta	SET_BANK_RAM
    114  746e		       60		      rts
    115  746f
    116  746f
    117  746f							;---------------------------------------------------------------------------------------------------
    118  746f
      0  746f					      DEF	unmakeMove
      1  746f				   SLOT_unmakeMove SET	_BANK_SLOT
      2  746f				   BANK_unmakeMove SET	SLOT_unmakeMove + _CURRENT_BANK
      3  746f				   unmakeMove
      4  746f				   TEMPORARY_VAR SET	Overlay
      5  746f				   TEMPORARY_OFFSET SET	0
      6  746f				   VAR_BOUNDARY_unmakeMove SET	TEMPORARY_OFFSET
      7  746f				   FUNCTION_NAME SET	unmakeMove
    120  746f					      SUBROUTINE
    121  746f
      0  746f					      REFER	negaMax
      1  746f					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  746f				   TEMPORARY_VAR SET	VAREND_negaMax
      3  746f					      ENDIF
      0  746f					      VAR	__unmake_capture, 1
      1  746f		       00 ae	   __unmake_capture =	TEMPORARY_VAR
      2  746f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  746f
      4  746f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  746f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  746f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  746f					      ENDIF
      8  746f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  746f				  -	      ECHO	"Temporary Variable", __unmake_capture, "overflow!"
     10  746f				  -	      ERR
     11  746f					      ENDIF
     12  746f					      LIST	ON
      0  746f					      VAR	__secondaryBlank, 1
      1  746f		       00 af	   __secondaryBlank =	TEMPORARY_VAR
      2  746f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  746f
      4  746f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  746f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  746f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  746f					      ENDIF
      8  746f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  746f				  -	      ECHO	"Temporary Variable", __secondaryBlank, "overflow!"
     10  746f				  -	      ERR
     11  746f					      ENDIF
     12  746f					      LIST	ON
      0  746f					      VEND	unmakeMove
      1  746f				  -	      IFNCONST	unmakeMove
      2  746f				  -	      ECHO	"Incorrect VEND label", unmakeMove
      3  746f				  -	      ERR
      4  746f					      ENDIF
      5  746f		       00 b0	   VAREND_unmakeMove =	TEMPORARY_VAR
    126  746f
    127  746f							; restore the board evaluation to what it was at the start of this ply
    128  746f							; TODO: note: moved flag seems wrong on restoration
    129  746f
      0  746f					      lda@PLY	savedEvaluation
      1  746f		       ad 96 ff 	      lda	savedEvaluation
    131  7472		       85 90		      sta	Evaluation
      0  7474					      lda@PLY	savedEvaluation+1
      1  7474		       ad 97 ff 	      lda	savedEvaluation+1
    133  7477		       85 91		      sta	Evaluation+1
    134  7479
    135  7479		       ae 9f ff 	      ldx	movePtr
      0  747c					      lda@PLY	MoveFrom,x
      1  747c		       bd 00 fc 	      lda	MoveFrom,x
    137  747f		       85 85		      sta	fromX12
      0  7481					      ldy@PLY	MoveTo,x
      1  7481		       bc 00 fd 	      ldy	MoveTo,x
    139  7484
      0  7484					      lda@PLY	restorePiece
      1  7484		       ad a8 ff 	      lda	restorePiece
    141  7487		       48		      pha
      0  7488					      lda@PLY	capturedPiece
      1  7488		       ad 99 ff 	      lda	capturedPiece
    143  748b
    144  748b		       a2 cf		      ldx	#RAMBANK_BOARD
    145  748d		       86 3e		      stx	SET_BANK_RAM
      0  748f					      sta@RAM	Board,y
      1  748f		       99 79 fe 	      sta	[RAM]+Board,y
    147  7492		       a4 85		      ldy	fromX12
    148  7494		       68		      pla
      0  7495					      sta@RAM	Board,y
      1  7495		       99 79 fe 	      sta	[RAM]+Board,y
    150  7498
    151  7498
    152  7498		       a5 95		      lda	currentPly
    153  749a		       85 3e		      sta	SET_BANK_RAM
    154  749c
    155  749c							; See if there are any 'secondary' pieces that moved
    156  749c							; here we're dealing with reverting a castling or enPassant move
    157  749c
      0  749c					      lda@PLY	secondaryPiece
      1  749c		       ad 9b ff 	      lda	secondaryPiece
    159  749f		       f0 1a		      beq	.noSecondary
      0  74a1					      ldy@PLY	secondaryBlank
      1  74a1		       ac 9d ff 	      ldy	secondaryBlank
    161  74a4		       84 af		      sty	__secondaryBlank
      0  74a6					      ldy@PLY	secondarySquare
      1  74a6		       ac 9c ff 	      ldy	secondarySquare
    163  74a9
    164  74a9
    165  74a9		       a2 cf		      ldx	#RAMBANK_BOARD
    166  74ab		       86 3e		      stx	SET_BANK_RAM
      0  74ad					      sta@RAM	Board,y	; put piece back
      1  74ad		       99 79 fe 	      sta	[RAM]+Board,y
    168  74b0
    169  74b0		       a4 af		      ldy	__secondaryBlank
    170  74b2		       a9 00		      lda	#0
      0  74b4					      sta@RAM	Board,y	; blank piece origin
      1  74b4		       99 79 fe 	      sta	[RAM]+Board,y
    172  74b7
    173  74b7		       a5 95		      lda	currentPly
    174  74b9		       85 3e		      sta	SET_BANK_RAM
    175  74bb
    176  74bb
    177  74bb				   .noSecondary
      0  74bb					      SWAP
      1  74bb		       a5 96		      lda	sideToMove
      2  74bd		       49 80		      eor	#SWAP_SIDE
      3  74bf		       85 96		      sta	sideToMove
    179  74c1		       60		      rts
    180  74c2
    181  74c2
    182  74c2							;---------------------------------------------------------------------------------------------------
    183  74c2
      0  74c2					      DEF	SAFE_getMoveIndex
      1  74c2				   SLOT_SAFE_getMoveIndex SET	_BANK_SLOT
      2  74c2				   BANK_SAFE_getMoveIndex SET	SLOT_SAFE_getMoveIndex + _CURRENT_BANK
      3  74c2				   SAFE_getMoveIndex
      4  74c2				   TEMPORARY_VAR SET	Overlay
      5  74c2				   TEMPORARY_OFFSET SET	0
      6  74c2				   VAR_BOUNDARY_SAFE_getMoveIndex SET	TEMPORARY_OFFSET
      7  74c2				   FUNCTION_NAME SET	SAFE_getMoveIndex
    185  74c2					      SUBROUTINE
    186  74c2
    187  74c2		       a9 c9		      lda	#RAMBANK_PLY+1
    188  74c4		       85 3e		      sta	SET_BANK_RAM
      0  74c6					      lda@PLY	moveIndex
      1  74c6		       ad 9e ff 	      lda	moveIndex
    190  74c9		       a6 8b		      ldx	savedBank
    191  74cb		       86 3f		      stx	SET_BANK
    192  74cd		       60		      rts
    193  74ce
    194  74ce
    195  74ce							;---------------------------------------------------------------------------------------------------
    196  74ce
      0  74ce					      DEF	GetValid
      1  74ce				   SLOT_GetValid SET	_BANK_SLOT
      2  74ce				   BANK_GetValid SET	SLOT_GetValid + _CURRENT_BANK
      3  74ce				   GetValid
      4  74ce				   TEMPORARY_VAR SET	Overlay
      5  74ce				   TEMPORARY_OFFSET SET	0
      6  74ce				   VAR_BOUNDARY_GetValid SET	TEMPORARY_OFFSET
      7  74ce				   FUNCTION_NAME SET	GetValid
    198  74ce					      SUBROUTINE
    199  74ce
    200  74ce		       a9 cf		      lda	#RAMBANK_BOARD
    201  74d0		       85 3e		      sta	SET_BANK_RAM
    202  74d2		       b9 15 fc 	      lda	ValidSquare,y
    203  74d5		       a4 8b		      ldy	savedBank
    204  74d7		       84 3f		      sty	SET_BANK
    205  74d9		       60		      rts
    206  74da
    207  74da
    208  74da
    209  74da							;---------------------------------------------------------------------------------------------------
    210  74da
    211  74da
    212  74da							;---------------------------------------------------------------------------------------------------
    213  74da
      0  74da					      DEF	CopySetupForMarker
      1  74da				   SLOT_CopySetupForMarker SET	_BANK_SLOT
      2  74da				   BANK_CopySetupForMarker SET	SLOT_CopySetupForMarker + _CURRENT_BANK
      3  74da				   CopySetupForMarker
      4  74da				   TEMPORARY_VAR SET	Overlay
      5  74da				   TEMPORARY_OFFSET SET	0
      6  74da				   VAR_BOUNDARY_CopySetupForMarker SET	TEMPORARY_OFFSET
      7  74da				   FUNCTION_NAME SET	CopySetupForMarker
    215  74da					      SUBROUTINE
    216  74da
      0  74da					      REFER	markerDraw
      1  74da					      IF	VAREND_markerDraw > TEMPORARY_VAR
      2  74da				   TEMPORARY_VAR SET	VAREND_markerDraw
      3  74da					      ENDIF
      0  74da					      REFER	showPromoteOptions
      1  74da				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  74da				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  74da					      ENDIF
      0  74da					      VAR	__pieceColour, 1
      1  74da		       00 a4	   __pieceColour =	TEMPORARY_VAR
      2  74da				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  74da
      4  74da				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  74da				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  74da				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  74da					      ENDIF
      8  74da				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  74da				  -	      ECHO	"Temporary Variable", __pieceColour, "overflow!"
     10  74da				  -	      ERR
     11  74da					      ENDIF
     12  74da					      LIST	ON
      0  74da					      VAR	__oddeven, 1
      1  74da		       00 a5	   __oddeven  =	TEMPORARY_VAR
      2  74da				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  74da
      4  74da				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  74da				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  74da				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  74da					      ENDIF
      8  74da				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  74da				  -	      ECHO	"Temporary Variable", __oddeven, "overflow!"
     10  74da				  -	      ERR
     11  74da					      ENDIF
     12  74da					      LIST	ON
      0  74da					      VAR	__pmcol, 1
      1  74da		       00 a6	   __pmcol    =	TEMPORARY_VAR
      2  74da				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  74da
      4  74da				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  74da				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  74da				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  74da					      ENDIF
      8  74da				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  74da				  -	      ECHO	"Temporary Variable", __pmcol, "overflow!"
     10  74da				  -	      ERR
     11  74da					      ENDIF
     12  74da					      LIST	ON
      0  74da					      VEND	CopySetupForMarker
      1  74da				  -	      IFNCONST	CopySetupForMarker
      2  74da				  -	      ECHO	"Incorrect VEND label", CopySetupForMarker
      3  74da				  -	      ERR
      4  74da					      ENDIF
      5  74da		       00 a7	   VAREND_CopySetupForMarker =	TEMPORARY_VAR
    223  74da
    224  74da		       a5 80		      lda	squareToDraw
    225  74dc		       38		      sec
    226  74dd		       a0 0a		      ldy	#10
    227  74df		       e9 0a	   .sub10     sbc	#10
    228  74e1		       88		      dey
    229  74e2		       b0 fb		      bcs	.sub10
    230  74e4		       84 a5		      sty	__oddeven
    231  74e6		       69 08		      adc	#8
    232  74e8		       85 a6		      sta	__pmcol
    233  74ea		       65 a5		      adc	__oddeven
    234  74ec
    235  74ec		       29 01		      and	#1
    236  74ee		       49 01		      eor	#1
    237  74f0		       f0 02		      beq	.white
    238  74f2		       a9 24		      lda	#36
    239  74f4				   .white
    240  74f4		       85 a4		      sta	__pieceColour	; actually SQUARE black/white
    241  74f6
    242  74f6		       8a		      txa
    243  74f7		       18		      clc
    244  74f8		       65 a4		      adc	__pieceColour
    245  74fa		       85 a4		      sta	__pieceColour
    246  74fc
    247  74fc		       a5 a6		      lda	__pmcol
    248  74fe		       29 03		      and	#3
    249  7500
    250  7500		       18		      clc
    251  7501		       65 a4		      adc	__pieceColour
    252  7503		       a8		      tay
    253  7504		       60		      rts
    254  7505
    255  7505							;---------------------------------------------------------------------------------------------------
    256  7505
    257  7505
    258  7505
    259  7505							;---------------------------------------------------------------------------------------------------
    260  7505
      0  7505					      DEF	AddMove
      1  7505				   SLOT_AddMove SET	_BANK_SLOT
      2  7505				   BANK_AddMove SET	SLOT_AddMove + _CURRENT_BANK
      3  7505				   AddMove
      4  7505				   TEMPORARY_VAR SET	Overlay
      5  7505				   TEMPORARY_OFFSET SET	0
      6  7505				   VAR_BOUNDARY_AddMove SET	TEMPORARY_OFFSET
      7  7505				   FUNCTION_NAME SET	AddMove
    262  7505					      SUBROUTINE
    263  7505
      0  7505					      VEND	AddMove
      1  7505				  -	      IFNCONST	AddMove
      2  7505				  -	      ECHO	"Incorrect VEND label", AddMove
      3  7505				  -	      ERR
      4  7505					      ENDIF
      5  7505		       00 a2	   VAREND_AddMove =	TEMPORARY_VAR
    265  7505
    266  7505							; add square in y register to movelist as destination (X12 format)
    267  7505							; [y]		     to square (X12)
    268  7505							; currentSquare     from square (X12)
    269  7505							; currentPiece      piece.
    270  7505							;   ENPASSANT flag set if pawn double-moving off opening rank
    271  7505							; capture	     captured piece
    272  7505
    273  7505		       a5 9e		      lda	capture
    274  7507		       d0 04		      bne	.always
    275  7509		       a5 ad		      lda	__quiesceCapOnly
    276  750b		       d0 0c		      bne	.abort
    277  750d
    278  750d		       a5 95	   .always    lda	currentPly
    279  750f		       85 3e		      sta	SET_BANK_RAM
    280  7511		       20 5f f6 	      jsr	AddMovePly
    281  7514		       a9 cf		      lda	#RAMBANK_BOARD
    282  7516		       85 3e		      sta	SET_BANK_RAM
    283  7518		       60		      rts
    284  7519
    285  7519		       98	   .abort     tya
    286  751a		       aa		      tax
    287  751b		       60		      rts
    288  751c
    289  751c							;---------------------------------------------------------------------------------------------------
    290  751c
      0  751c					      DEF	GenerateAllMoves
      1  751c				   SLOT_GenerateAllMoves SET	_BANK_SLOT
      2  751c				   BANK_GenerateAllMoves SET	SLOT_GenerateAllMoves + _CURRENT_BANK
      3  751c				   GenerateAllMoves
      4  751c				   TEMPORARY_VAR SET	Overlay
      5  751c				   TEMPORARY_OFFSET SET	0
      6  751c				   VAR_BOUNDARY_GenerateAllMoves SET	TEMPORARY_OFFSET
      7  751c				   FUNCTION_NAME SET	GenerateAllMoves
    292  751c					      SUBROUTINE
    293  751c
      0  751c					      REFER	negaMax
      1  751c					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  751c				   TEMPORARY_VAR SET	VAREND_negaMax
      3  751c					      ENDIF
      0  751c					      REFER	quiesce
      1  751c				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  751c				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  751c					      ENDIF
      0  751c					      REFER	aiStepMoveGen
      1  751c				  -	      IF	VAREND_aiStepMoveGen > TEMPORARY_VAR
      2  751c				  -TEMPORARY_VAR SET	VAREND_aiStepMoveGen
      3  751c					      ENDIF
      0  751c					      REFER	aiGenerateMoves
      1  751c				  -	      IF	VAREND_aiGenerateMoves > TEMPORARY_VAR
      2  751c				  -TEMPORARY_VAR SET	VAREND_aiGenerateMoves
      3  751c					      ENDIF
      0  751c					      REFER	selectmove
      1  751c				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  751c				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  751c					      ENDIF
      0  751c					      VAR	__vector, 2
      1  751c		       00 ae	   __vector   =	TEMPORARY_VAR
      2  751c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  751c
      4  751c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  751c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  751c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  751c					      ENDIF
      8  751c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  751c				  -	      ECHO	"Temporary Variable", __vector, "overflow!"
     10  751c				  -	      ERR
     11  751c					      ENDIF
     12  751c					      LIST	ON
      0  751c					      VAR	__masker, 2
      1  751c		       00 b0	   __masker   =	TEMPORARY_VAR
      2  751c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  751c
      4  751c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  751c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  751c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  751c					      ENDIF
      8  751c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  751c				  -	      ECHO	"Temporary Variable", __masker, "overflow!"
     10  751c				  -	      ERR
     11  751c					      ENDIF
     12  751c					      LIST	ON
      0  751c					      VAR	__pieceFilter, 1
      1  751c		       00 b2	   __pieceFilter =	TEMPORARY_VAR
      2  751c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  751c
      4  751c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  751c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  751c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  751c					      ENDIF
      8  751c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  751c				  -	      ECHO	"Temporary Variable", __pieceFilter, "overflow!"
     10  751c				  -	      ERR
     11  751c					      ENDIF
     12  751c					      LIST	ON
      0  751c					      VEND	GenerateAllMoves
      1  751c				  -	      IFNCONST	GenerateAllMoves
      2  751c				  -	      ECHO	"Incorrect VEND label", GenerateAllMoves
      3  751c				  -	      ERR
      4  751c					      ENDIF
      5  751c		       00 b3	   VAREND_GenerateAllMoves =	TEMPORARY_VAR
    303  751c
    304  751c							; Do the move generation in two passes - pawns then pieces
    305  751c							; This is an effort to get the alphabeta pruning happening with major pieces handled first in list
    306  751c
    307  751c		       a5 95		      lda	currentPly
    308  751e		       85 3e		      sta	SET_BANK_RAM
    309  7520		       20 00 f4 	      jsr	NewPlyInitialise
    310  7523
    311  7523		       a9 08		      lda	#8	; pawns
    312  7525		       85 b2		      sta	__pieceFilter
    313  7527		       20 3c f5 	      jsr	MoveGenX
    314  752a		       a9 63		      lda	#99
    315  752c		       85 93		      sta	currentSquare
    316  752e		       a9 00		      lda	#0
    317  7530		       85 b2		      sta	__pieceFilter
    318  7532		       20 3c f5 	      jsr	MoveGenX
    319  7535
    320  7535		       a5 95		      lda	currentPly
    321  7537		       85 3e		      sta	SET_BANK_RAM
    322  7539		       4c de f4 	      jmp	Sort
    323  753c
    324  753c
    325  753c
      0  753c					      DEF	MoveGenX
      1  753c				   SLOT_MoveGenX SET	_BANK_SLOT
      2  753c				   BANK_MoveGenX SET	SLOT_MoveGenX + _CURRENT_BANK
      3  753c				   MoveGenX
      4  753c				   TEMPORARY_VAR SET	Overlay
      5  753c				   TEMPORARY_OFFSET SET	0
      6  753c				   VAR_BOUNDARY_MoveGenX SET	TEMPORARY_OFFSET
      7  753c				   FUNCTION_NAME SET	MoveGenX
    327  753c					      SUBROUTINE
    328  753c
    329  753c		       a2 64		      ldx	#100
    330  753e		       d0 02		      bne	.next2
    331  7540
      0  7540					      DEF	MoveReturn
      1  7540				   SLOT_MoveReturn SET	_BANK_SLOT
      2  7540				   BANK_MoveReturn SET	SLOT_MoveReturn + _CURRENT_BANK
      3  7540				   MoveReturn
      4  7540				   TEMPORARY_VAR SET	Overlay
      5  7540				   TEMPORARY_OFFSET SET	0
      6  7540				   VAR_BOUNDARY_MoveReturn SET	TEMPORARY_OFFSET
      7  7540				   FUNCTION_NAME SET	MoveReturn
    333  7540
    334  7540
    335  7540		       a6 93		      ldx	currentSquare
    336  7542
    337  7542		       a9 cf	   .next2     lda	#RAMBANK_BOARD
    338  7544		       85 3e		      sta	SET_BANK_RAM
    339  7546
    340  7546		       ca	   .next      dex
    341  7547		       e0 16		      cpx	#22
    342  7549		       90 27		      bcc	.exit
    343  754b
    344  754b		       bd 79 fc 	      lda	Board,x
    345  754e		       f0 f6		      beq	.next
    346  7550		       c9 ff		      cmp	#-1
    347  7552		       f0 f2		      beq	.next
    348  7554		       45 96		      eor	sideToMove
    349  7556		       30 ee		      bmi	.next
    350  7558
    351  7558							;    DEF handleIt
    352  7558							;    SUBROUTINE
    353  7558
    354  7558
    355  7558		       86 93		      stx	currentSquare
    356  755a
    357  755a		       45 96		      eor	sideToMove
    358  755c		       29 ef		      and	#~FLAG_CASTLE	; todo: better part of the move, mmh?
    359  755e		       85 92		      sta	currentPiece
    360  7560		       29 0f		      and	#PIECE_MASK
    361  7562		       05 b2		      ora	__pieceFilter
    362  7564		       a8		      tay
    363  7565
    364  7565		       b9 10 f4 	      lda	HandlerVectorHI,y
    365  7568		       85 af		      sta	__vector+1
    366  756a		       b9 00 f4 	      lda	HandlerVectorLO,y
    367  756d		       85 ae		      sta	__vector
    368  756f		       6c ae 00 	      jmp	(__vector)
    369  7572
    370  7572
    371  7572
    372  7572				   .exit
    373  7572		       60		      rts
    374  7573
    375  7573
    376  7573							;---------------------------------------------------------------------------------------------------
    377  7573
      0  7573					      DEF	ListPlayerMoves
      1  7573				   SLOT_ListPlayerMoves SET	_BANK_SLOT
      2  7573				   BANK_ListPlayerMoves SET	SLOT_ListPlayerMoves + _CURRENT_BANK
      3  7573				   ListPlayerMoves
      4  7573				   TEMPORARY_VAR SET	Overlay
      5  7573				   TEMPORARY_OFFSET SET	0
      6  7573				   VAR_BOUNDARY_ListPlayerMoves SET	TEMPORARY_OFFSET
      7  7573				   FUNCTION_NAME SET	ListPlayerMoves
    379  7573					      SUBROUTINE
    380  7573
    381  7573
    382  7573		       a9 00		      lda	#0
    383  7575		       85 ad		      sta	__quiesceCapOnly	; gen ALL moves
    384  7577
    385  7577		       a9 c9		      lda	#RAMBANK_PLY+1
    386  7579		       85 95		      sta	currentPly
    387  757b		       20 1c f5 	      jsr	GenerateAllMoves
    388  757e
      0  757e					      ldx@PLY	moveIndex
      1  757e		       ae 9e ff 	      ldx	moveIndex
      0  7581				   .scan      stx@PLY	movePtr
      1  7581		       8e 9f 01 	      stx	[RAM]+movePtr
    391  7584
    392  7584		       20 00 f4 	      jsr	MakeMove
    393  7587
    394  7587		       e6 95		      inc	currentPly
    395  7589		       20 1c f5 	      jsr	GenerateAllMoves
    396  758c
    397  758c		       c6 95		      dec	currentPly
    398  758e		       a5 95		      lda	currentPly
    399  7590		       85 3e		      sta	SET_BANK_RAM
    400  7592
    401  7592		       20 6f f4 	      jsr	unmakeMove
    402  7595
    403  7595		       a5 9f		      lda	flagCheck
    404  7597		       f0 08		      beq	.next
    405  7599
      0  7599					      ldx@PLY	movePtr
      1  7599		       ae 9f ff 	      ldx	movePtr
    407  759c		       a9 00		      lda	#0
      0  759e					      sta@PLY	MoveFrom,x	; invalidate move (still in check!)
      1  759e		       9d 00 fe 	      sta	[RAM]+MoveFrom,x
    409  75a1
      0  75a1				   .next      ldx@PLY	movePtr
      1  75a1		       ae 9f ff 	      ldx	movePtr
    411  75a4		       ca		      dex
    412  75a5		       10 da		      bpl	.scan
    413  75a7
    414  75a7		       60		      rts
    415  75a8
    416  75a8
    417  75a8							;---------------------------------------------------------------------------------------------------
    418  75a8							; TODO - is this valid?
    419  75a8
      0  75a8					      DEF	markerDraw
      1  75a8				   SLOT_markerDraw SET	_BANK_SLOT
      2  75a8				   BANK_markerDraw SET	SLOT_markerDraw + _CURRENT_BANK
      3  75a8				   markerDraw
      4  75a8				   TEMPORARY_VAR SET	Overlay
      5  75a8				   TEMPORARY_OFFSET SET	0
      6  75a8				   VAR_BOUNDARY_markerDraw SET	TEMPORARY_OFFSET
      7  75a8				   FUNCTION_NAME SET	markerDraw
    421  75a8					      SUBROUTINE
    422  75a8
      0  75a8					      REFER	SAFE_showMoveOptions
      1  75a8					      IF	VAREND_SAFE_showMoveOptions > TEMPORARY_VAR
      2  75a8				   TEMPORARY_VAR SET	VAREND_SAFE_showMoveOptions
      3  75a8					      ENDIF
      0  75a8					      VEND	markerDraw
      1  75a8				  -	      IFNCONST	markerDraw
      2  75a8				  -	      ECHO	"Incorrect VEND label", markerDraw
      3  75a8				  -	      ERR
      4  75a8					      ENDIF
      5  75a8		       00 a4	   VAREND_markerDraw =	TEMPORARY_VAR
    425  75a8		       a2 1c		      ldx	#INDEX_WHITE_MARKER_on_WHITE_SQUARE_0
    426  75aa		       20 da f4 	      jsr	CopySetupForMarker
    427  75ad		       4c 8a f0 	      jmp	InterceptMarkerCopy
    428  75b0
    429  75b0
    430  75b0							;---------------------------------------------------------------------------------------------------
    431  75b0
      0  75b0					      DEF	GetP_MoveFrom
      1  75b0				   SLOT_GetP_MoveFrom SET	_BANK_SLOT
      2  75b0				   BANK_GetP_MoveFrom SET	SLOT_GetP_MoveFrom + _CURRENT_BANK
      3  75b0				   GetP_MoveFrom
      4  75b0				   TEMPORARY_VAR SET	Overlay
      5  75b0				   TEMPORARY_OFFSET SET	0
      6  75b0				   VAR_BOUNDARY_GetP_MoveFrom SET	TEMPORARY_OFFSET
      7  75b0				   FUNCTION_NAME SET	GetP_MoveFrom
    433  75b0		       a9 c9		      lda	#RAMBANK_PLY+1
    434  75b2		       85 3e		      sta	SET_BANK_RAM
    435  75b4		       a4 8b		      ldy	savedBank
      0  75b6					      lda@PLY	MoveFrom,x
      1  75b6		       bd 00 fc 	      lda	MoveFrom,x
    437  75b9		       84 3f		      sty	SET_BANK
    438  75bb		       60		      rts
    439  75bc
    440  75bc
    441  75bc							;---------------------------------------------------------------------------------------------------
    442  75bc
      0  75bc					      DEF	GetP_MoveTo
      1  75bc				   SLOT_GetP_MoveTo SET	_BANK_SLOT
      2  75bc				   BANK_GetP_MoveTo SET	SLOT_GetP_MoveTo + _CURRENT_BANK
      3  75bc				   GetP_MoveTo
      4  75bc				   TEMPORARY_VAR SET	Overlay
      5  75bc				   TEMPORARY_OFFSET SET	0
      6  75bc				   VAR_BOUNDARY_GetP_MoveTo SET	TEMPORARY_OFFSET
      7  75bc				   FUNCTION_NAME SET	GetP_MoveTo
    444  75bc					      SUBROUTINE
    445  75bc
    446  75bc		       a9 c9		      lda	#RAMBANK_PLY+1
    447  75be		       85 3e		      sta	SET_BANK_RAM
    448  75c0		       a4 8b		      ldy	savedBank
      0  75c2					      lda@PLY	MoveTo,x
      1  75c2		       bd 00 fd 	      lda	MoveTo,x
    450  75c5		       84 3f		      sty	SET_BANK
    451  75c7		       60		      rts
    452  75c8
    453  75c8
    454  75c8							;---------------------------------------------------------------------------------------------------
    455  75c8
      0  75c8					      DEF	GetPiece
      1  75c8				   SLOT_GetPiece SET	_BANK_SLOT
      2  75c8				   BANK_GetPiece SET	SLOT_GetPiece + _CURRENT_BANK
      3  75c8				   GetPiece
      4  75c8				   TEMPORARY_VAR SET	Overlay
      5  75c8				   TEMPORARY_OFFSET SET	0
      6  75c8				   VAR_BOUNDARY_GetPiece SET	TEMPORARY_OFFSET
      7  75c8				   FUNCTION_NAME SET	GetPiece
    457  75c8					      SUBROUTINE
    458  75c8
      0  75c8					      REFER	aiSelectDestinationSquare
      1  75c8				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  75c8				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  75c8					      ENDIF
      0  75c8					      REFER	aiQuiescent
      1  75c8				  -	      IF	VAREND_aiQuiescent > TEMPORARY_VAR
      2  75c8				  -TEMPORARY_VAR SET	VAREND_aiQuiescent
      3  75c8					      ENDIF
      0  75c8					      VEND	GetPiece
      1  75c8				  -	      IFNCONST	GetPiece
      2  75c8				  -	      ECHO	"Incorrect VEND label", GetPiece
      3  75c8				  -	      ERR
      4  75c8					      ENDIF
      5  75c8		       00 a2	   VAREND_GetPiece =	TEMPORARY_VAR
    462  75c8
    463  75c8							; Retrieve the piece+flags from the movelist, given from/to squares
    464  75c8							; Required as moves have different flags but same origin squares (e.g., castling)
    465  75c8
    466  75c8		       a5 95		      lda	currentPly
    467  75ca		       85 3e		      sta	SET_BANK_RAM
    468  75cc
    469  75cc		       20 2c f4 	      jsr	GetPieceGivenFromToSquares
    470  75cf
    471  75cf		       a5 8b		      lda	savedBank
    472  75d1		       85 3f		      sta	SET_BANK
    473  75d3		       60		      rts
    474  75d4
    475  75d4
    476  75d4							;---------------------------------------------------------------------------------------------------
    477  75d4
      0  75d4					      DEF	GetP_MovePiece
      1  75d4				   SLOT_GetP_MovePiece SET	_BANK_SLOT
      2  75d4				   BANK_GetP_MovePiece SET	SLOT_GetP_MovePiece + _CURRENT_BANK
      3  75d4				   GetP_MovePiece
      4  75d4				   TEMPORARY_VAR SET	Overlay
      5  75d4				   TEMPORARY_OFFSET SET	0
      6  75d4				   VAR_BOUNDARY_GetP_MovePiece SET	TEMPORARY_OFFSET
      7  75d4				   FUNCTION_NAME SET	GetP_MovePiece
    479  75d4					      SUBROUTINE
    480  75d4
    481  75d4		       a9 c9		      lda	#RAMBANK_PLY+1
    482  75d6		       85 3e		      sta	SET_BANK_RAM
    483  75d8		       a4 8b		      ldy	savedBank
      0  75da					      lda@PLY	MovePiece,x
      1  75da		       bd 00 fe 	      lda	MovePiece,x
    485  75dd		       84 3f		      sty	SET_BANK
    486  75df		       60		      rts
    487  75e0
    488  75e0
    489  75e0							;---------------------------------------------------------------------------------------------------
    490  75e0
      0  75e0					      DEF	aiComputerMove
      1  75e0				   SLOT_aiComputerMove SET	_BANK_SLOT
      2  75e0				   BANK_aiComputerMove SET	SLOT_aiComputerMove + _CURRENT_BANK
      3  75e0				   aiComputerMove
      4  75e0				   TEMPORARY_VAR SET	Overlay
      5  75e0				   TEMPORARY_OFFSET SET	0
      6  75e0				   VAR_BOUNDARY_aiComputerMove SET	TEMPORARY_OFFSET
      7  75e0				   FUNCTION_NAME SET	aiComputerMove
    492  75e0					      SUBROUTINE
    493  75e0
      0  75e0					      REFER	AiStateMachine
      1  75e0				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  75e0				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  75e0					      ENDIF
      0  75e0					      VEND	aiComputerMove
      1  75e0				  -	      IFNCONST	aiComputerMove
      2  75e0				  -	      ECHO	"Incorrect VEND label", aiComputerMove
      3  75e0				  -	      ERR
      4  75e0					      ENDIF
      5  75e0		       00 a2	   VAREND_aiComputerMove =	TEMPORARY_VAR
    496  75e0
    497  75e0
    498  75e0		       a9 c8		      lda	#RAMBANK_PLY
    499  75e2		       85 95		      sta	currentPly
    500  75e4		       85 3e		      sta	SET_BANK_RAM	; switch in movelist
    501  75e6
    502  75e6		       a9 01		      lda	#1
    503  75e8		       85 4a		      sta	CTRLPF	; mirroring for thinkbars
    504  75ea
    505  75ea		       20 47 f4 	      jsr	selectmove
    506  75ed
    507  75ed		       a9 00		      lda	#0
    508  75ef		       85 4a		      sta	CTRLPF	; clear mirroring
    509  75f1		       85 4e		      sta	PF1
    510  75f3		       85 4f		      sta	PF2
    511  75f5
      0  75f5					      lda@PLY	bestMove
      1  75f5		       ad a0 ff 	      lda	bestMove
    513  75f8		       10 17		      bpl	.notComputer
    514  75fa
    515  75fa							; Computer could not find a valid move. It's checkmate or stalemate. Find which...
    516  75fa
      0  75fa					      SWAP
      1  75fa		       a5 96		      lda	sideToMove
      2  75fc		       49 80		      eor	#SWAP_SIDE
      3  75fe		       85 96		      sta	sideToMove
    518  7600		       20 1c f5 	      jsr	GenerateAllMoves
    519  7603		       a5 9f		      lda	flagCheck
    520  7605		       f0 05		      beq	.gameDrawn
    521  7607
      0  7607					      PHASE	AI_CheckMate
      1  7607		       a9 23		      lda	#AI_CheckMate
      2  7609		       85 8c		      sta	aiState
    523  760b		       60		      rts
    524  760c
    525  760c
      0  760c				   .gameDrawn PHASE	AI_Draw
      1  760c		       a9 24		      lda	#AI_Draw
      2  760e		       85 8c		      sta	aiState
    527  7610		       60		      rts
    528  7611
    529  7611				   .notComputer
    530  7611
    531  7611
    532  7611		       a9 ff		      lda	#-1
    533  7613		       85 88		      sta	cursorX12
    534  7615
      0  7615					      PHASE	AI_DelayAfterMove
      1  7615		       a9 25		      lda	#AI_DelayAfterMove
      2  7617		       85 8c		      sta	aiState
    536  7619		       60	   .halted    rts
    537  761a
    538  761a
    539  761a
    540  761a							;---------------------------------------------------------------------------------------------------
    541  761a
      0  761a					      DEF	aiSpecialMoveFixup
      1  761a				   SLOT_aiSpecialMoveFixup SET	_BANK_SLOT
      2  761a				   BANK_aiSpecialMoveFixup SET	SLOT_aiSpecialMoveFixup + _CURRENT_BANK
      3  761a				   aiSpecialMoveFixup
      4  761a				   TEMPORARY_VAR SET	Overlay
      5  761a				   TEMPORARY_OFFSET SET	0
      6  761a				   VAR_BOUNDARY_aiSpecialMoveFixup SET	TEMPORARY_OFFSET
      7  761a				   FUNCTION_NAME SET	aiSpecialMoveFixup
    543  761a					      SUBROUTINE
    544  761a
      0  761a					      COMMON_VARS_ALPHABETA
      1  761a
      0  761a					      VAR	__thinkbar, 1
      1  761a		       00 a2	   __thinkbar =	TEMPORARY_VAR
      2  761a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  761a
      4  761a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  761a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  761a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  761a					      ENDIF
      8  761a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  761a				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  761a				  -	      ERR
     11  761a					      ENDIF
     12  761a					      LIST	ON
      0  761a					      VAR	__toggle, 1
      1  761a		       00 a3	   __toggle   =	TEMPORARY_VAR
      2  761a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  761a
      4  761a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  761a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  761a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  761a					      ENDIF
      8  761a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  761a				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  761a				  -	      ERR
     11  761a					      ENDIF
     12  761a					      LIST	ON
      4  761a
      0  761a					      VAR	__bestMove, 1
      1  761a		       00 a4	   __bestMove =	TEMPORARY_VAR
      2  761a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  761a
      4  761a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  761a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  761a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  761a					      ENDIF
      8  761a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  761a				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  761a				  -	      ERR
     11  761a					      ENDIF
     12  761a					      LIST	ON
      0  761a					      VAR	__alpha, 2
      1  761a		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  761a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  761a
      4  761a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  761a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  761a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  761a					      ENDIF
      8  761a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  761a				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  761a				  -	      ERR
     11  761a					      ENDIF
     12  761a					      LIST	ON
      0  761a					      VAR	__beta, 2
      1  761a		       00 a7	   __beta     =	TEMPORARY_VAR
      2  761a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  761a
      4  761a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  761a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  761a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  761a					      ENDIF
      8  761a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  761a				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  761a				  -	      ERR
     11  761a					      ENDIF
     12  761a					      LIST	ON
      0  761a					      VAR	__negaMax, 2
      1  761a		       00 a9	   __negaMax  =	TEMPORARY_VAR
      2  761a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  761a
      4  761a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  761a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  761a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  761a					      ENDIF
      8  761a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  761a				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  761a				  -	      ERR
     11  761a					      ENDIF
     12  761a					      LIST	ON
      0  761a					      VAR	__value, 2
      1  761a		       00 ab	   __value    =	TEMPORARY_VAR
      2  761a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  761a
      4  761a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  761a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  761a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  761a					      ENDIF
      8  761a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  761a				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  761a				  -	      ERR
     11  761a					      ENDIF
     12  761a					      LIST	ON
     10  761a
      0  761a					      VAR	__quiesceCapOnly, 1
      1  761a		       00 ad	   __quiesceCapOnly =	TEMPORARY_VAR
      2  761a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  761a
      4  761a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  761a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  761a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  761a					      ENDIF
      8  761a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  761a				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  761a				  -	      ERR
     11  761a					      ENDIF
     12  761a					      LIST	ON
     12  761a
      0  761a					      REFER	AiStateMachine
      1  761a				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  761a				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  761a					      ENDIF
      0  761a					      VEND	aiSpecialMoveFixup
      1  761a				  -	      IFNCONST	aiSpecialMoveFixup
      2  761a				  -	      ECHO	"Incorrect VEND label", aiSpecialMoveFixup
      3  761a				  -	      ERR
      4  761a					      ENDIF
      5  761a		       00 ae	   VAREND_aiSpecialMoveFixup =	TEMPORARY_VAR
    548  761a
    549  761a		       ad 84 02 	      lda	INTIM
    550  761d		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    551  761f		       b0 01		      bcs	.cont
    552  7621		       60		      rts
    553  7622
    554  7622
    555  7622				   .cont
    556  7622
    557  7622
      0  7622					      PHASE	AI_DelayAfterPlaced
      1  7622		       a9 27		      lda	#AI_DelayAfterPlaced
      2  7624		       85 8c		      sta	aiState
    559  7626
    560  7626
    561  7626							; Special move fixup
    562  7626
    563  7626					      IF	ENPASSANT_ENABLED
    564  7626
    565  7626							; Handle en-passant captures
    566  7626							; The (dual-use) FLAG_ENPASSANT will have been cleared if it was set for a home-rank move
    567  7626							; but if we're here and the flag is still set, then it's an actual en-passant CAPTURE and we
    568  7626							; need to do the appropriate things...
    569  7626
    570  7626		       a9 5d		      lda	#BANK_EnPassantCheck
    571  7628		       85 3f		      sta	SET_BANK
    572  762a		       20 92 f6 	      jsr	EnPassantCheck
    573  762d
    574  762d					      ENDIF
    575  762d
    576  762d
    577  762d		       a5 95		      lda	currentPly
    578  762f		       85 3e		      sta	SET_BANK_RAM
    579  7631		       20 c1 f4 	      jsr	CastleFixupDraw
    580  7634
    581  7634		       a5 85		      lda	fromX12
    582  7636		       85 80		      sta	squareToDraw
    583  7638
    584  7638		       60		      rts
    585  7639
    586  7639
    587  7639							;---------------------------------------------------------------------------------------------------
    588  7639
      0  7639					      DEF	aiDrawEntireBoard
      1  7639				   SLOT_aiDrawEntireBoard SET	_BANK_SLOT
      2  7639				   BANK_aiDrawEntireBoard SET	SLOT_aiDrawEntireBoard + _CURRENT_BANK
      3  7639				   aiDrawEntireBoard
      4  7639				   TEMPORARY_VAR SET	Overlay
      5  7639				   TEMPORARY_OFFSET SET	0
      6  7639				   VAR_BOUNDARY_aiDrawEntireBoard SET	TEMPORARY_OFFSET
      7  7639				   FUNCTION_NAME SET	aiDrawEntireBoard
    590  7639					      SUBROUTINE
    591  7639
      0  7639					      REFER	AiStateMachine
      1  7639				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  7639				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  7639					      ENDIF
      0  7639					      VEND	aiDrawEntireBoard
      1  7639				  -	      IFNCONST	aiDrawEntireBoard
      2  7639				  -	      ECHO	"Incorrect VEND label", aiDrawEntireBoard
      3  7639				  -	      ERR
      4  7639					      ENDIF
      5  7639		       00 a2	   VAREND_aiDrawEntireBoard =	TEMPORARY_VAR
    594  7639
    595  7639
    596  7639		       ad 84 02 	      lda	INTIM
    597  763c		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    598  763e		       90 29		      bcc	.exit
    599  7640
    600  7640							; We use [SLOT3] for accessing board
    601  7640
    602  7640		       a9 cf		      lda	#RAMBANK_BOARD
    603  7642		       85 3e		      sta	SET_BANK_RAM
    604  7644		       a4 80		      ldy	squareToDraw
    605  7646		       b9 15 fc 	      lda	ValidSquare,y
    606  7649		       30 1a		      bmi	.isablank2
    607  764b
    608  764b		       b9 79 fc 	      lda	Board,y
    609  764e		       f0 10		      beq	.isablank
    610  7650		       48		      pha
    611  7651		       a9 00		      lda	#BLANK
      0  7653					      sta@RAM	Board,y
      1  7653		       99 79 fe 	      sta	[RAM]+Board,y
    613  7656
    614  7656							;jsr CopySinglePiece
    615  7656
    616  7656		       a9 cf		      lda	#RAMBANK_BOARD
    617  7658		       85 3e		      sta	SET_BANK_RAM
    618  765a
    619  765a		       a4 80		      ldy	squareToDraw
    620  765c		       68		      pla
      0  765d					      sta@RAM	Board,y
      1  765d		       99 79 fe 	      sta	[RAM]+Board,y
    622  7660
      0  7660				   .isablank  PHASE	AI_DrawPart2
      1  7660		       a9 10		      lda	#AI_DrawPart2
      2  7662		       85 8c		      sta	aiState
    624  7664		       60		      rts
    625  7665
      0  7665				   .isablank2 PHASE	AI_DrawPart3
      1  7665		       a9 11		      lda	#AI_DrawPart3
      2  7667		       85 8c		      sta	aiState
    627  7669		       60	   .exit      rts
    628  766a
    629  766a
    630  766a							;---------------------------------------------------------------------------------------------------
    631  766a
      0  766a					      DEF	PutBoard
      1  766a				   SLOT_PutBoard SET	_BANK_SLOT
      2  766a				   BANK_PutBoard SET	SLOT_PutBoard + _CURRENT_BANK
      3  766a				   PutBoard
      4  766a				   TEMPORARY_VAR SET	Overlay
      5  766a				   TEMPORARY_OFFSET SET	0
      6  766a				   VAR_BOUNDARY_PutBoard SET	TEMPORARY_OFFSET
      7  766a				   FUNCTION_NAME SET	PutBoard
    633  766a		       a2 cf		      ldx	#RAMBANK_BOARD
    634  766c		       86 3e		      stx	SET_BANK_RAM
      0  766e					      sta@RAM	Board,y	; and what's actually moving there
      1  766e		       99 79 fe 	      sta	[RAM]+Board,y
    636  7671		       a6 8b		      ldx	savedBank
    637  7673		       86 3f		      stx	SET_BANK
    638  7675		       60		      rts
    639  7676
    640  7676
    641  7676							;---------------------------------------------------------------------------------------------------
    642  7676
      0  7676					      DEF	GetBoard
      1  7676				   SLOT_GetBoard SET	_BANK_SLOT
      2  7676				   BANK_GetBoard SET	SLOT_GetBoard + _CURRENT_BANK
      3  7676				   GetBoard
      4  7676				   TEMPORARY_VAR SET	Overlay
      5  7676				   TEMPORARY_OFFSET SET	0
      6  7676				   VAR_BOUNDARY_GetBoard SET	TEMPORARY_OFFSET
      7  7676				   FUNCTION_NAME SET	GetBoard
    644  7676		       a9 cf		      lda	#RAMBANK_BOARD
    645  7678		       85 3e		      sta	SET_BANK_RAM
    646  767a		       b9 79 fc 	      lda	Board,y
    647  767d		       a4 8b		      ldy	savedBank
    648  767f		       84 3f		      sty	SET_BANK
    649  7681		       60		      rts
    650  7682
    651  7682							;---------------------------------------------------------------------------------------------------
    652  7682
    653  7682
      0  7682					      DEF	IsValidMoveFromSquare
      1  7682				   SLOT_IsValidMoveFromSquare SET	_BANK_SLOT
      2  7682				   BANK_IsValidMoveFromSquare SET	SLOT_IsValidMoveFromSquare + _CURRENT_BANK
      3  7682				   IsValidMoveFromSquare
      4  7682				   TEMPORARY_VAR SET	Overlay
      5  7682				   TEMPORARY_OFFSET SET	0
      6  7682				   VAR_BOUNDARY_IsValidMoveFromSquare SET	TEMPORARY_OFFSET
      7  7682				   FUNCTION_NAME SET	IsValidMoveFromSquare
    655  7682					      SUBROUTINE
    656  7682
      0  7682					      REFER	aiSelectStartSquare
      1  7682				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  7682				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  7682					      ENDIF
      0  7682					      VEND	IsValidMoveFromSquare
      1  7682				  -	      IFNCONST	IsValidMoveFromSquare
      2  7682				  -	      ECHO	"Incorrect VEND label", IsValidMoveFromSquare
      3  7682				  -	      ERR
      4  7682					      ENDIF
      5  7682		       00 a2	   VAREND_IsValidMoveFromSquare =	TEMPORARY_VAR
    659  7682
    660  7682							; Does the square exist in the movelist?
    661  7682							; Return: y = -1 if NOT FOUND
    662  7682
    663  7682		       a5 88		      lda	cursorX12
    664  7684		       85 85		      sta	fromX12
    665  7686
    666  7686		       a4 95		      ldy	currentPly
    667  7688		       84 3e		      sty	SET_BANK_RAM
    668  768a		       20 18 f4 	      jsr	CheckMoveListFromSquare
    669  768d
    670  768d		       a5 8b		      lda	savedBank
    671  768f		       85 3f		      sta	SET_BANK
    672  7691		       60		      rts
    673  7692
    674  7692
    675  7692							;---------------------------------------------------------------------------------------------------
    676  7692
    677  7692					      IF	ENPASSANT_ENABLED
    678  7692
      0  7692					      DEF	EnPassantCheck
      1  7692				   SLOT_EnPassantCheck SET	_BANK_SLOT
      2  7692				   BANK_EnPassantCheck SET	SLOT_EnPassantCheck + _CURRENT_BANK
      3  7692				   EnPassantCheck
      4  7692				   TEMPORARY_VAR SET	Overlay
      5  7692				   TEMPORARY_OFFSET SET	0
      6  7692				   VAR_BOUNDARY_EnPassantCheck SET	TEMPORARY_OFFSET
      7  7692				   FUNCTION_NAME SET	EnPassantCheck
    680  7692					      SUBROUTINE
    681  7692
      0  7692					      REFER	MakeMove
      1  7692					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  7692				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  7692					      ENDIF
      0  7692					      REFER	aiSpecialMoveFixup
      1  7692				  -	      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  7692				  -TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  7692					      ENDIF
      0  7692					      VEND	EnPassantCheck
      1  7692				  -	      IFNCONST	EnPassantCheck
      2  7692				  -	      ECHO	"Incorrect VEND label", EnPassantCheck
      3  7692				  -	      ERR
      4  7692					      ENDIF
      5  7692		       00 b0	   VAREND_EnPassantCheck =	TEMPORARY_VAR
    685  7692
    686  7692							; {
    687  7692							; With en-passant flag, it is essentially dual-use.
    688  7692							; First, it marks if the move is *involved* somehow in an en-passant
    689  7692							; if the piece has MOVED already, then it's an en-passant capture
    690  7692							; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
    691  7692
    692  7692		       a4 94		      ldy	enPassantPawn	; save from previous side move
    693  7694
    694  7694		       a2 00		      ldx	#0	; (probably) NO en-passant this time
    695  7696		       a5 97		      lda	fromPiece
    696  7698		       29 60		      and	#FLAG_ENPASSANT|FLAG_MOVED
    697  769a		       c9 20		      cmp	#FLAG_ENPASSANT
    698  769c		       d0 06		      bne	.noep	; HAS moved, or not en-passant
    699  769e
    700  769e		       45 97		      eor	fromPiece	; clear FLAG_ENPASSANT
    701  76a0		       85 97		      sta	fromPiece
    702  76a2
    703  76a2		       a6 85		      ldx	fromX12	; this IS an en-passantable opening, so record the square
    704  76a4		       86 94	   .noep      stx	enPassantPawn	; capturable square for en-passant move (or none)
    705  76a6
    706  76a6							; }
    707  76a6
    708  76a6
    709  76a6							; Check to see if we are doing an actual en-passant capture...
    710  76a6
    711  76a6							; NOTE: If using test boards for debugging, the FLAG_MOVED flag is IMPORTANT
    712  76a6							;  as the en-passant will fail if the taking piece does not have this flag set correctly
    713  76a6
    714  76a6		       a5 97		      lda	fromPiece
    715  76a8		       29 20		      and	#FLAG_ENPASSANT
    716  76aa		       f0 10		      beq	.notEnPassant	; not an en-passant, or it's enpassant by a MOVED piece
    717  76ac
    718  76ac
    719  76ac							; {
    720  76ac
    721  76ac							; Here we are the aggressor and we need to take the pawn 'en passant' fashion
    722  76ac							; y = the square containing the pawn to capture (i.e., previous value of 'enPassantPawn')
    723  76ac
    724  76ac							; Remove the pawn from the board and piecelist, and undraw
    725  76ac
    726  76ac		       84 80		      sty	squareToDraw
    727  76ae		       20 83 f0 	      jsr	CopySinglePiece	;@0	      ; undraw captured pawn
    728  76b1
    729  76b1		       a9 90		      lda	#RAMBANK_BANK_EVAL
    730  76b3		       85 3e		      sta	SET_BANK_RAM
    731  76b5		       85 8b		      sta	savedBank
    732  76b7
    733  76b7		       a4 87		      ldy	originX12	; taken pawn's square
    734  76b9		       20 f5 f5 	      jsr	EnPassantRemovePiece
    735  76bc
    736  76bc				   .notEnPassant
    737  76bc							; }
    738  76bc
    739  76bc		       60		      rts
    740  76bd
    741  76bd					      ENDIF
    742  76bd
    743  76bd
    744  76bd							;---------------------------------------------------------------------------------------------------
    745  76bd
      0  76bd					      CHECK_BANK_SIZE	"TWO"
      1  76bd		       02 bd	   .TEMP      =	* - _BANK_START
 TWO (1K) SIZE =  $2bd , FREE= $143
      2  76bd					      ECHO	"TWO", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  76bd				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  76bd				  -	      ECHO	"BANK OVERFLOW @ ", "TWO", " size=", * - ORIGIN
      5  76bd				  -	      ERR
      6  76bd					      ENDIF
    747  76bd
    748  76bd							;---------------------------------------------------------------------------------------------------
    749  76bd							;EOF
------- FILE ./chess.asm
------- FILE BANK_3.asm LEVEL 2 PASS 4
      0  76bd					      include	"BANK_3.asm"
      1  76bd							; Chess
      2  76bd							; Copyright (c) 2019-2020 Andrew Davie
      3  76bd							; andrew@taswegian.com
      4  76bd
      0  76bd					      SLOT	1	; this code assembles for bank #1
      1  76bd				  -	      IF	(1 < 0) || (1 > 3)
      2  76bd				  -	      ECHO	"Illegal bank address/segment location", 1
      3  76bd				  -	      ERR
      4  76bd					      ENDIF
      5  76bd				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  76bd				   _BANK_SLOT SET	1 * 64
      0  76bd					      NEWBANK	THREE
      1  7c00 ????				      SEG	THREE
      2  7800					      ORG	_ORIGIN
      3  7800					      RORG	_BANK_ADDRESS_ORIGIN
      4  7800				   _BANK_START SET	*
      5  7800				   THREE_START SET	*
      6  7800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7800				   THREE      SET	_BANK_SLOT + _CURRENT_BANK
      8  7800				   _ORIGIN    SET	_ORIGIN + 1024
      7  7800
      8  7800		       00 00 00 00*	      ds	1024
      9  7c00
     10  7c00
     11  7c00							; EOF
------- FILE ./chess.asm
    635  7c00
    636  7c00							;include "Handler_MACROS.asm"
    637  7c00
    638  7c00							;include "BANK_GENERIC.asm"
    639  7c00							;include "BANK_GENERIC2.asm"
    640  7c00							;include "BANK_ROM_SHADOW_SCREEN.asm"
    641  7c00							;include "BANK_CHESS_INCLUDES.asm"
    642  7c00							;include "BANK_StateMachine.asm"
    643  7c00							;include "BANK_TEXT_OVERLAYS.asm"
    644  7c00							;include "BANK_PLIST.asm"
    645  7c00
    646  7c00							;include "titleScreen.asm"
    647  7c00							;include "BANK_RECON.asm"
    648  7c00
    649  7c00							; The handlers for piece move generation
    650  7c00							;include "Handler_BANK1.asm"
    651  7c00							;include "BANK_PLY.asm"
    652  7c00							;include "BANK_EVAL.asm"
    653  7c00							;include "BANK_SPEAK.asm"
    654  7c00
    655  7c00							; MUST BE LAST...
    656  7c00							;include "BANK_FIXED.asm"
    657  7c00
    658  7c00							;END
