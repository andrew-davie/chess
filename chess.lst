------- FILE ./chess.asm LEVEL 1 PASS 5
      1  8000 ????						; Chess
      2  8000 ????						; Atari 2600 Chess display system
      3  8000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  8000 ????						; andrew@taswegian.com
      5  8000 ????
      6  8000 ????
      7  8000 ????	       00 40	   TIA_BASE_ADDRESS =	$40
      8  8000 ????
      9  8000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 5
      0  8000 ????				      include	"vcs.h"
      1  8000 ????						; VCS.H
      2  8000 ????						; Version 1.05, 13/November/2003
      3  8000 ????
      4  8000 ????	       00 69	   VERSION_VCS =	105
      5  8000 ????
      6  8000 ????						; This file defines hardware registers and memory mapping for the
      7  8000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  8000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  8000 ????						; available at at http://www.atari2600.org/dasm
     10  8000 ????						;
     11  8000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  8000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  8000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  8000 ????						; with your views.  Please contribute, if you think you can improve this
     15  8000 ????						; file!
     16  8000 ????						;
     17  8000 ????						; Latest Revisions...
     18  8000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  8000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  8000 ????						;			    This will allow conditional code to verify VCS.H being
     21  8000 ????						;			    used for code assembly.
     22  8000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  8000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  8000 ????						;			 mirrored reading/writing differences.	This is more a
     25  8000 ????						;			 readability issue, and binary compatibility with disassembled
     26  8000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  8000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  8000 ????						;			 which was broken by the use of segments in this file, as
     29  8000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  8000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  8000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  8000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  8000 ????						;						   it is safe to leave it undefined, and the base address will
     34  8000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  8000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  8000 ????						;			  - register definitions are now generated through assignment
     37  8000 ????						;			    in uninitialised segments.	This allows a changeable base
     38  8000 ????						;			    address architecture.
     39  8000 ????						; 1.0	22/MAR/2003		Initial release
     40  8000 ????
     41  8000 ????
     42  8000 ????						;-------------------------------------------------------------------------------
     43  8000 ????
     44  8000 ????						; TIA_BASE_ADDRESS
     45  8000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  8000 ????						; Normally 0, the base address should (externally, before including this file)
     47  8000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  8000 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  8000 ????						; < $40 as a bankswitch.
     50  8000 ????
     51  8000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  8000 ????			  -TIA_BASE_ADDRESS =	0
     53  8000 ????				      ENDIF
     54  8000 ????
     55  8000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  8000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  8000 ????						; *OR* by declaring the label before including this file, eg:
     58  8000 ????						; TIA_BASE_ADDRESS = $40
     59  8000 ????						;   include "vcs.h"
     60  8000 ????
     61  8000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  8000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  8000 ????						; for the mirrored ROM hardware registers.
     64  8000 ????
     65  8000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  8000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  8000 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  8000 ????
     69  8000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  8000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  8000 ????				      ENDIF
     72  8000 ????
     73  8000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  8000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  8000 ????				      ENDIF
     76  8000 ????
     77  8000 ????						;-------------------------------------------------------------------------------
     78  8000 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE macro.h LEVEL 2 PASS 5
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE piece_defines.h LEVEL 2 PASS 5
      0  0000 ????				      include	"piece_defines.h"
      1  0000 ????						; Copyright (C)2020 Andrew Davie
      2  0000 ????
      3  0000 ????	       00 80	   BLACK      =	128
      4  0000 ????	       00 00	   WHITE      =	0
      5  0000 ????
      6  0000 ????	       00 80	   FLAG_COLOUR =	128	; mask
      7  0000 ????	       00 40	   FLAG_MOVED =	64	; mark ALL pieces when moved. Used for castling
      8  0000 ????						; but maybe useful for evaluation of development
      9  0000 ????	       00 20	   FLAG_ENPASSANT =	32
     10  0000 ????	       00 10	   FLAG_CASTLE =	16
     11  0000 ????
     12  0000 ????						;---------------------------------------------------------------------------------------------------
     13  0000 ????						; DEFINE THE PIECES
     14  0000 ????						; ID lives in bits 0-2
     15  0000 ????
     16  0000 ????	       00 00	   BLANK      =	0
     17  0000 ????	       00 00	   ███  =	BLANK
     18  0000 ????
     19  0000 ????	       00 01	   WPAWN      =	1
     20  0000 ????	       00 01	   WP	      =	WPAWN
     21  0000 ????	       00 02	   BPAWN      =	2
     22  0000 ????	       00 02	   BP	      =	BPAWN
     23  0000 ????	       00 03	   KNIGHT     =	3
     24  0000 ????	       00 03	   N	      =	KNIGHT
     25  0000 ????	       00 04	   BISHOP     =	4
     26  0000 ????	       00 04	   B	      =	BISHOP
     27  0000 ????	       00 05	   ROOK       =	5
     28  0000 ????	       00 05	   R	      =	ROOK
     29  0000 ????	       00 06	   QUEEN      =	6
     30  0000 ????	       00 06	   Q	      =	QUEEN
     31  0000 ????	       00 07	   KING       =	7
     32  0000 ????	       00 07	   K	      =	KING
     33  0000 ????	       00 08	   MARKER     =	8
     34  0000 ????
     35  0000 ????	       00 0f	   PIECE_MASK =	15	; trim off the flags leaving just piece ID
     36  0000 ????
     37  0000 ????						;---------------------------------------------------------------------------------------------------
     38  0000 ????
     39  0000 ????						; Movements
     40  0000 ????
     41  0000 ????	       00 0a	   _UP	      =	10	; up
     42  0000 ????	       ff ff ff ff _LEFT      =	-1	; left
     43  0000 ????	       ff ff ff f6 _DOWN      =	-10	; down
     44  0000 ????	       00 01	   _RIGHT     =	1	; right
     45  0000 ????
     46  0000 ????						; EOF
------- FILE ./chess.asm
     13  0000 ????
     14  0000 ????	       00 00	   VERBOSE    =	0	; set to 1 for compile messages
     15  0000 ????
     16  0000 ????			   ORIGIN     SET	0
     17  0000 ????			   ORIGIN_RAM SET	0
     18  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 5
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	segtime_c
     89  0000 ????			   {1}	      SET	({2}+32)/64 + 2
     90  0000 ????			   TEST_{1}   =	0
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????						; Pathways
     94  0000 ????						; StealPart3, not enough time for SCD_SLOW --> 79✅
     95  0000 ????						; if QuickDraw does immediate exit, 58✅
     96  0000 ????
     97  0000 ????						;---------------------------------------------------------------------------------------------------
     98  0000 ????
      0  0000 ????				      SEGTIME_C	MINIMUM_SEGTIME, 95	;✅ processing slice minimum requirement
      1  0000 ????			   MINIMUM_SEGTIME SET	(95+32)/64 + 2
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIME =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_MINIMUM_TIMESLICE, 54	;✅ abort time maximum requirement for timeslice
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	(54+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    101  0000 ????
    102  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    103  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    104  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    105  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    106  0000 ????						; uses ...
    107  0000 ????
    108  0000 ????
    109  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    110  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    111  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    112  0000 ????
    113  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    114  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    115  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,22	;18 ;12	  ;NFI
      1  0000 ????			   SEGTIME_MAN SET	22
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
------- FILE ./chess.asm
     20  0000 ????
     21  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     22  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     23  0000 ????	       78 00	   FIXED_BANK =	15 * 2048	; ->> 32K
     24  0000 ????						;FIXED_BANK		 = 31 * 2048	       ; ->> 64K
     25  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     26  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     27  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     28  0000 ????
     29  0000 ????	       00 01	   YES	      =	1
     30  0000 ????	       00 00	   NO	      =	0
     31  0000 ????
     32  0000 ????	       7f ff	   INFINITY   =	32767
     33  0000 ????
     34  0000 ????
     35  0000 ????						; assemble diagnostics. Remove for release.
     36  0000 ????	       00 00	   ASSERTS    =	0
     37  0000 ????	       00 00	   TEST_POSITION =	0	; 0=normal, 1 = setup test position
     38  0000 ????	       00 00	   PVSP       =	0	; player versus player =1
     39  0000 ????	       00 00	   ENPASSANT_ENABLED =	0
     40  0000 ????	       00 01	   CASTLING_ENABLED =	1
     41  0000 ????						;PIECELIST_ENABLED	  = 0
     42  0000 ????
     43  0000 ????	       00 00	   WHITE_PLAYER =	0	; human
     44  0000 ????	       00 00	   BLACK_PLAYER =	0	; human
     45  0000 ????
     46  0000 ????						; DELAYS
     47  0000 ????
     48  0000 ????	       00 0a	   READY_TO_MOVE_FLASH =	10
     49  0000 ????
     50  0000 ????						;===================================
     51  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     52  0000 ????						;===================================
     53  0000 ????
     54  0000 ????						;-------------------------------------------------------------------------------
     55  0000 ????						; The following are optional YES/NO depending on phase of the moon
     56  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     57  0000 ????						;-------------------------------------------------------------------------------
     58  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     59  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     60  0000 ????			  -	      IF	FINAL_VERSION = YES
     61  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????						;-------------------------------------------------------------------------------
     65  0000 ????
     66  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     67  0000 ????
     68  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
     69  0000 ????
     70  0000 ????						;------------------------------------------------------------------------------
     71  0000 ????
     72  0000 ????	       00 01	   PLUSCART   =	YES
     73  0000 ????
     74  0000 ????						;------------------------------------------------------------------------------
     75  0000 ????
     76  0000 ????
     77  0000 ????	       00 08	   CHESSBOARD_ROWS =	8	; number of ROWS of chessboard
     78  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
     79  0000 ????	       00 48	   PIECE_SHAPE_SIZE =	72	; 3 PF bytes x 24 scanlines
     80  0000 ????
     81  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
     82  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
     83  0000 ????
     84  0000 ????
     85  0000 ????	       10 00	   RAM_3E     =	$1000
     86  0000 ????	       04 00	   RAM_SIZE   =	$400
     87  0000 ????	       04 00	   RAM_WRITE  =	$400	; add this to RAM address when doing writes
     88  0000 ????	       04 00	   RAM	      =	RAM_WRITE
     89  0000 ????
     90  0000 ????
     91  0000 ????
     92  0000 ????						; Platform constants:
     93  0000 ????	       00 02	   PAL	      =	%10
     94  0000 ????	       00 02	   PAL_50     =	PAL|0
     95  0000 ????	       00 03	   PAL_60     =	PAL|1
     96  0000 ????
     97  0000 ????
     98  0000 ????				      IF	L276
     99  0000 ????	       00 30	   VBLANK_TIM_NTSC =	48	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    100  0000 ????			  -	      ELSE
    101  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    102  0000 ????				      ENDIF
    103  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    104  0000 ????
    105  0000 ????				      IF	L276
    106  0000 ????	       00 23	   OVERSCAN_TIM_NTSC =	35	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    107  0000 ????			  -	      ELSE
    108  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    109  0000 ????				      ENDIF
    110  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    111  0000 ????
    112  0000 ????				      IF	L276
    113  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    114  0000 ????			  -	      ELSE
    115  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    116  0000 ????				      ENDIF
    117  0000 ????	       01 38	   SCANLINES_PAL =	312
    118  0000 ????
    119  0000 ????
    120  0000 ????	       00 2e	   TIME_PART_2 =	46
    121  0000 ????	       00 2f	   TIME_PART_1 =	47
    122  0000 ????
    123  0000 ????
    124  0000 ????						;------------------------------------------------------------------------------
    125  0000 ????						; MACRO definitions
    126  0000 ????
    127  0000 ????
    128  0000 ????	       08 00	   ROM_BANK_SIZE =	$800
    129  0000 ????
    130  0000 ????				      MAC	newbank
    131  0000 ????				      SEG	{1}
    132  0000 ????				      ORG	ORIGIN
    133  0000 ????				      RORG	$F000
    134  0000 ????			   BANK_START SET	*
    135  0000 ????			   {1}	      SET	ORIGIN / 2048
    136  0000 ????			   ORIGIN     SET	ORIGIN + 2048
    137  0000 ????			   _CURRENT_BANK SET	{1}
    138  0000 ????				      ENDM		; bank name
    139  0000 ????
    140  0000 ????				      MAC	define_1k_segment
    141  0000 ????				      ALIGN	$400
    142  0000 ????			   SEGMENT_{1} SET	*
    143  0000 ????			   BANK_{1}   SET	_CURRENT_BANK
    144  0000 ????				      ENDM		; {seg name}
    145  0000 ????
    146  0000 ????				      MAC	check_bank_size
    147  0000 ????			   .TEMP      =	* - BANK_START
    148  0000 ????				      ECHO	{1}, "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
    149  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE
    150  0000 ????				      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
    151  0000 ????				      ERR
    152  0000 ????				      endif
    153  0000 ????				      ENDM		; name
    154  0000 ????
    155  0000 ????
    156  0000 ????				      MAC	check_half_bank_size
    157  0000 ????						; This macro is for checking the first 1K of ROM bank data that is to be copied to RAM.
    158  0000 ????						; Note that these ROM banks can contain 2K, so this macro will generally go 'halfway'
    159  0000 ????			   .TEMP      =	* - BANK_START
    160  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
    161  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE/2
    162  0000 ????				      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
    163  0000 ????				      ERR
    164  0000 ????				      endif
    165  0000 ????				      ENDM		; name
    166  0000 ????
    167  0000 ????
    168  0000 ????						;---------------------------------------------------------------------------------------------------
    169  0000 ????
    170  0000 ????						; Macro inserts a page break if the object would overlap a page
    171  0000 ????
    172  0000 ????				      MAC	optional_pagebreak
    173  0000 ????				      LIST	OFF
    174  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    175  0000 ????			   EARLY_LOCATION SET	*
    176  0000 ????				      ALIGN	256
    177  0000 ????				      IF	VERBOSE=1
    178  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR", {1}
    179  0000 ????				      ECHO	"REQUESTED SIZE =", {2}
    180  0000 ????				      ECHO	"WASTED SPACE =", *-EARLY_LOCATION
    181  0000 ????				      ECHO	"PAGEBREAK LOCATION =", *
    182  0000 ????				      ENDIF
    183  0000 ????				      ENDIF
    184  0000 ????				      LIST	ON
    185  0000 ????				      ENDM		; { string, size }
    186  0000 ????
    187  0000 ????
    188  0000 ????				      MAC	check_page_crossing
    189  0000 ????				      LIST	OFF
    190  0000 ????				      if	( >BLOCK_END != >BLOCK_START )
    191  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    192  0000 ????				      endif
    193  0000 ????				      LIST	ON
    194  0000 ????				      ENDM
    195  0000 ????
    196  0000 ????				      MAC	checkpage
    197  0000 ????				      LIST	OFF
    198  0000 ????				      IF	>. != >{1}
    199  0000 ????				      ECHO	""
    200  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    201  0000 ????				      ECHO	""
    202  0000 ????				      ERR
    203  0000 ????				      ENDIF
    204  0000 ????				      LIST	ON
    205  0000 ????				      ENDM
    206  0000 ????
    207  0000 ????				      MAC	checkpagex
    208  0000 ????				      LIST	OFF
    209  0000 ????				      IF	>. != >{1}
    210  0000 ????				      ECHO	""
    211  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    212  0000 ????				      ECHO	{2}
    213  0000 ????				      ECHO	""
    214  0000 ????				      ERR
    215  0000 ????				      ENDIF
    216  0000 ????				      LIST	ON
    217  0000 ????				      ENDM
    218  0000 ????
    219  0000 ????						;---------------------------------------------------------------------------------------------------
    220  0000 ????
    221  0000 ????						; Defines a variable of the given size, making sure it doesn't cross a page
    222  0000 ????				      MAC	variable
    223  0000 ????				      OPTIONAL_PAGEBREAK	"Variable", {2}
    224  0000 ????			   {1}	      ds	{2}
    225  0000 ????				      ENDM		; {name, size}
    226  0000 ????
    227  0000 ????
    228  0000 ????						;---------------------------------------------------------------------------------------------------
    229  0000 ????
    230  0000 ????				      MAC	def
    231  0000 ????			   BANK_{1}   SET	_CURRENT_BANK	; bank in which this subroutine resides
    232  0000 ????			   {1}			; entry point
    233  0000 ????			   TEMPORARY_VAR SET	Overlay
    234  0000 ????			   TEMPORARY_OFFSET SET	0
    235  0000 ????			   VAR_BOUNDARY_{1} SET	TEMPORARY_OFFSET
    236  0000 ????			   FUNCTION_NAME SET	{1}
    237  0000 ????				      SUBROUTINE
    238  0000 ????				      ENDM		; name of subroutine
    239  0000 ????
    240  0000 ????
    241  0000 ????						;---------------------------------------------------------------------------------------------------
    242  0000 ????
    243  0000 ????				      MAC	allocate
    244  0000 ????				      OPTIONAL_PAGEBREAK	"Table", {2}
    245  0000 ????				      DEF	{1}
    246  0000 ????				      ENDM
    247  0000 ????
    248  0000 ????
    249  0000 ????						;---------------------------------------------------------------------------------------------------
    250  0000 ????
    251  0000 ????				      MAC	negeval
    252  0000 ????
    253  0000 ????				      sec
    254  0000 ????				      lda	#0
    255  0000 ????				      sbc	Evaluation
    256  0000 ????				      sta	Evaluation
    257  0000 ????				      lda	#0
    258  0000 ????				      sbc	Evaluation+1
    259  0000 ????				      sta	Evaluation+1
    260  0000 ????
    261  0000 ????						;		      clc
    262  0000 ????						;		      lda Evaluation
    263  0000 ????						;		      eor #$FF
    264  0000 ????						;		      adc #1
    265  0000 ????						;		      sta Evaluation
    266  0000 ????						;		      lda Evaluation+1
    267  0000 ????						;		      eor #$FF
    268  0000 ????						;		      adc #0
    269  0000 ????						;		      sta Evaluation+1
    270  0000 ????
    271  0000 ????				      ENDM
    272  0000 ????
    273  0000 ????
    274  0000 ????						;---------------------------------------------------------------------------------------------------
    275  0000 ????
    276  0000 ????			   TEMPORARY_OFFSET SET	0
    277  0000 ????
    278  0000 ????
    279  0000 ????				      MAC	vend
    280  0000 ????				      IFNCONST	{1}
    281  0000 ????				      ECHO	"Incorrect VEND label", {1}
    282  0000 ????				      ERR
    283  0000 ????				      ENDIF
    284  0000 ????			   VAREND_{1} =	TEMPORARY_VAR
    285  0000 ????				      ENDM		; {1}
    286  0000 ????
    287  0000 ????
    288  0000 ????				      MAC	refer
    289  0000 ????				      IF	VAREND_{1} > TEMPORARY_VAR
    290  0000 ????			   TEMPORARY_VAR SET	VAREND_{1}
    291  0000 ????				      ENDIF
    292  0000 ????				      ENDM		; {1}
    293  0000 ????
    294  0000 ????
    295  0000 ????
    296  0000 ????						; Define a temporary variable for use in a subroutine
    297  0000 ????						; Will allocate appropriate bytes, and also check for overflow of the available overlay buffer
    298  0000 ????
    299  0000 ????				      MAC	var
    300  0000 ????			   {1}	      =	TEMPORARY_VAR
    301  0000 ????			   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + {2}
    302  0000 ????
    303  0000 ????			   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
    304  0000 ????				      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
    305  0000 ????			   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
    306  0000 ????				      ENDIF
    307  0000 ????				      IF	OVERLAY_DELTA > OVERLAY_SIZE
    308  0000 ????				      ECHO	"Temporary Variable", {1}, "overflow!"
    309  0000 ????				      ERR
    310  0000 ????				      ENDIF
    311  0000 ????				      LIST	ON
    312  0000 ????				      ENDM		; { name, size }
    313  0000 ????
    314  0000 ????
    315  0000 ????
    316  0000 ????
    317  0000 ????						;---------------------------------------------------------------------------------------------------
    318  0000 ????
    319  0000 ????				      MAC	tag
    320  0000 ????						; {0}
    321  0000 ????				      ENDM		; {ident/tag}
    322  0000 ????
    323  0000 ????						;---------------------------------------------------------------------------------------------------
    324  0000 ????
    325  0000 ????				      MAC	sta@ram
    326  0000 ????				      sta	[RAM]+{0}
    327  0000 ????				      ENDM		;{}
    328  0000 ????
    329  0000 ????				      MAC	stx@ram
    330  0000 ????				      stx	[RAM]+{0}
    331  0000 ????				      ENDM
    332  0000 ????
    333  0000 ????				      MAC	sty@ram
    334  0000 ????				      sty	[RAM]+{0}
    335  0000 ????				      ENDM
    336  0000 ????
    337  0000 ????
    338  0000 ????						;---------------------------------------------------------------------------------------------------
    339  0000 ????
    340  0000 ????				      MAC	newrambank
    341  0000 ????						; {1}	     bank name
    342  0000 ????						; {2}	     RAM bank number
    343  0000 ????
    344  0000 ????				      SEG.U	{1}
    345  0000 ????				      ORG	ORIGIN_RAM
    346  0000 ????				      RORG	RAM_3E
    347  0000 ????			   BANK_START SET	*
    348  0000 ????			   RAMBANK_{1} SET	ORIGIN_RAM / RAM_SIZE
    349  0000 ????			   _CURRENT_RAMBANK SET	RAMBANK_{1}
    350  0000 ????			   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    351  0000 ????				      ENDM		; bank name
    352  0000 ????
    353  0000 ????						; TODO - fix - this is faulty....
    354  0000 ????				      MAC	validate_ram_size
    355  0000 ????			   .RAM_BANK_SIZE SET	* - RAM_3E
    356  0000 ????				      IF	.RAM_BANK_SIZE > RAM_SIZE
    357  0000 ????				      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
    358  0000 ????				      ERR
    359  0000 ????				      ENDIF
    360  0000 ????				      ENDM
    361  0000 ????
    362  0000 ????						;---------------------------------------------------------------------------------------------------
    363  0000 ????
    364  0000 ????				      MAC	resync
    365  0000 ????						; resync screen, X and Y == 0 afterwards
    366  0000 ????				      lda	#%10	; make sure VBLANK is ON
    367  0000 ????				      sta	VBLANK
    368  0000 ????
    369  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    370  0000 ????			   .loopResync
    371  0000 ????				      VERTICAL_SYNC
    372  0000 ????
    373  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    374  0000 ????				      lda	Platform
    375  0000 ????				      eor	#PAL_50	; PAL-50?
    376  0000 ????				      bne	.ntsc
    377  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    378  0000 ????			   .ntsc
    379  0000 ????			   .loopWait
    380  0000 ????				      sta	WSYNC
    381  0000 ????				      sta	WSYNC
    382  0000 ????				      dey
    383  0000 ????				      bne	.loopWait
    384  0000 ????				      dex
    385  0000 ????				      bne	.loopResync
    386  0000 ????				      ENDM
    387  0000 ????
    388  0000 ????				      MAC	set_platform
    389  0000 ????						; 00 = NTSC
    390  0000 ????						; 01 = NTSC
    391  0000 ????						; 10 = PAL-50
    392  0000 ????						; 11 = PAL-60
    393  0000 ????				      lda	SWCHB
    394  0000 ????				      rol
    395  0000 ????				      rol
    396  0000 ????				      rol
    397  0000 ????				      and	#%11
    398  0000 ????				      eor	#PAL
    399  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    400  0000 ????				      ENDM
    401  0000 ????
    402  0000 ????
    403  0000 ????						;---------------------------------------------------------------------------------------------------
    404  0000 ????
    405  0000 ????				      MAC	jsrom_safe
    406  0000 ????						; Saves bank of routine to variable for later restore.
    407  0000 ????						; Switches to the bank and does a JSR to the routine.
    408  0000 ????
    409  0000 ????				      lda	#BANK_{1}
    410  0000 ????				      sta	savedBank
    411  0000 ????				      sta	SET_BANK
    412  0000 ????				      jsr	{1}
    413  0000 ????				      ENDM		; {routine}
    414  0000 ????
    415  0000 ????
    416  0000 ????				      MAC	jsrom
    417  0000 ????
    418  0000 ????				      lda	#BANK_{1}
    419  0000 ????				      sta	SET_BANK
    420  0000 ????				      jsr	{1}
    421  0000 ????				      ENDM		; {routine}
    422  0000 ????
    423  0000 ????
    424  0000 ????				      MAC	jsram
    425  0000 ????				      lda	#BANK_{1}
    426  0000 ????				      sta	SET_BANK_RAM
    427  0000 ????				      jsr	{1}
    428  0000 ????				      ENDM
    429  0000 ????
    430  0000 ????
    431  0000 ????
    432  0000 ????				      MAC	timecheck
    433  0000 ????				      lda	INTIM
    434  0000 ????				      cmp	#SPEEDOF_{1}
    435  0000 ????				      bcc	{2}
    436  0000 ????				      ENDM		; {ident}, {branch if out of time}
    437  0000 ????
    438  0000 ????
    439  0000 ????				      MAC	timing
    440  0000 ????			   SPEEDOF_{1} =	({2}/64) + 1
    441  0000 ????				      ENDM		; {label}, {cycles}
    442  0000 ????
    443  0000 ????
    444  0000 ????						;---------------------------------------------------------------------------------------------------
    445  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 5
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						; Chess
      2  0000 ????						; Atari 2600 Chess display system
      3  0000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  0000 ????						; andrew@taswegian.com
      5  0000 ????
      6 U00fa ????				      SEG.U	variables
      7 U0080					      ORG	$80
      8 U0080
      9 U0080		       00	   squareToDraw ds	1
     10 U0081		       00	   rnd	      ds	1	; random
     11 U0082		       00	   drawDelay  ds	1
     12 U0083		       00	   lastSquareX12 ds	1
     13 U0084
     14 U0084		       00	   drawCount  ds	1
     15 U0085		       00	   fromX12    ds	1
     16 U0086		       00	   toX12      ds	1
     17 U0087		       00	   originX12  ds	1
     18 U0088
     19 U0088		       00	   cursorX12  ds	1
     20 U0089
     21 U0089		       00	   mdelay     ds	1
     22 U008a		       00	   ccur       ds	1
     23 U008b		       00	   savedBank  ds	1	; switched-in bank for FIXED returns
     24 U008c		       00	   aiState    ds	1	; state
     25 U008d		       00	   aiFlashDelay ds	1
     26 U008e
     27 U008e		       00	   aiMoveIndex ds	1
     28 U008f
     29 U008f		       00	   aiFlashPhase ds	1
     30 U0090
     31 U0090		       00 00	   Evaluation ds	2	; tracks value of the board position
     32 U0092
     33 U0092		       00	   currentPiece ds	1
     34 U0093		       00	   currentSquare ds	1
     35 U0094		       00	   enPassantPawn ds	1	; TODO - this belongs in PLY bank
     36 U0095		       00	   currentPly ds	1
     37 U0096
     38 U0096							;    IFCONST PIECELIST_ENABLED
     39 U0096							;piecelistIndex		  ds 1
     40 U0096							;    ELSE
     41 U0096		       00	   squareIndex ds	1
     42 U0097							;    ENDIF
     43 U0097
     44 U0097
     45 U0097		       00	   sideToMove ds	1	; d7 == side, 0=white, 128 = black
     46 U0098		       00	   fromPiece  ds	1
     47 U0099		       00	   lastPiece  ds	1
     48 U009a		       00	   previousPiece ds	1
     49 U009b
     50 U009b		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     51 U009c		       00 00	   speech_addr ds	2
     52 U009e		       00	   bg	      ds	1
     53 U009f
     54 U009f		       00	   _2nd_square ds	1
     55 U00a0		       00	   _2nd_blank ds	1
     56 U00a1		       00	   _2nd_piece ds	1
------- FILE ./chess.asm
------- FILE overlays.asm LEVEL 2 PASS 5
      0 U00a2					      include	"overlays.asm"
      1 U00a2							; Chess
      2 U00a2							; Atari 2600 Chess display system
      3 U00a2							; Copyright (c) 2019-2020 Andrew Davie
      4 U00a2							; andrew@taswegian.com
      5 U00a2
      6 U00a2							;---------------------------------------------------------------------------------------------------
      7 U00a2							; OVERLAYS!
      8 U00a2							; These variables are overlays, and should be managed with care
      9 U00a2							; They co-exist (each "OVERLAY" starts at the zero-page variable "Overlay"
     10 U00a2							; and thus, overlays cannot be used at the same time (that is, you cannot
     11 U00a2							; use a variable in overlay #1 while at the same time using a variable in
     12 U00a2							; overlay #2
     13 U00a2
     14 U00a2							; for clarity, prefix ALL overlay variables with double-underscore (__)
     15 U00a2
     16 U00a2							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
     17 U00a2							; ensure this by using the VALIDATE_OVERLAY macro
     18 U00a2							;---------------------------------------------------------------------------------------------------
     19 U00a2
     20 U00a2					      MAC	overlay
     21 U00a2				   OVERLAY_NAME SET	{1}
     22 U00a2					      SEG.U	OVERLAY_{1}
     23 U00a2					      org	Overlay
     24 U00a2					      ENDM		; {name}
     25 U00a2
     26 U00a2							;---------------------------------------------------------------------------------------------------
     27 U00a2
     28 U00a2					      MAC	validate_overlay
     29 U00a2					      LIST	OFF
     30 U00a2				   OVERLAY_DELTA SET	* - Overlay
     31 U00a2					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
     32 U00a2				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
     33 U00a2					      ENDIF
     34 U00a2					      IF	OVERLAY_DELTA > OVERLAY_SIZE
     35 U00a2					      ECHO	"Overlay", OVERLAY_NAME, "is too big!"
     36 U00a2					      ECHO	"REQUIRED SIZE =", OVERLAY_DELTA
     37 U00a2					      ERR
     38 U00a2					      ENDIF
     39 U00a2					      LIST	ON
     40 U00a2					      ECHO	OVERLAY_NAME, "-", OVERLAY_SIZE - ( * - Overlay ), "bytes available"
     41 U00a2					      ENDM
     42 U00a2
     43 U00a2							;---------------------------------------------------------------------------------------------------
     44 U00a2
     45 U00a2				   OVERLAY_SIZE SET	$4C	; maximum size
     46 U00a2				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	0
     47 U00a2
     48 U00a2
     49 U00a2							; This overlay variable is used for the overlay variables.  That's OK.
     50 U00a2							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
     51 U00a2							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
     52 U00a2							; (especially the latter ones) are only used in rare occasions.
     53 U00a2
     54 U00a2							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
     55 U00a2							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
     56 U00a2
      0 U00a2					      DEF	Overlay
      1 U00a2				   BANK_Overlay SET	_CURRENT_BANK
      2 U00a2				   Overlay
      3 U00a2				   TEMPORARY_VAR SET	Overlay
      4 U00a2				   TEMPORARY_OFFSET SET	0
      5 U00a2				   VAR_BOUNDARY_Overlay SET	TEMPORARY_OFFSET
      6 U00a2				   FUNCTION_NAME SET	Overlay
      7 U00a2					      SUBROUTINE
     58 U00a2		       00 00 00 00*	      ds	OVERLAY_SIZE	;--> overlay (share) variables
     59 U00ee				   END_OF_OVERLAY
     60 U00ee
     61 U00ee							;---------------------------------------------------------------------------------------------------
     62 U00ee							; And now... the overlays....
     63 U00ee
 ---- OVERLAYS ( $4c bytes ) ----
     64 U00ee					      ECHO	"---- OVERLAYS (", OVERLAY_SIZE, "bytes ) ----"
     65 U00ee
     66 U00ee							;---------------------------------------------------------------------------------------------------
     67 U00ee
     68 U00ee							; Some overlays are used across multiple routines/calls, and they will need to be defined
     69 U00ee							; "globally" in this file.
     70 U00ee
      0 U00ee					      VAR	__pieceShapeBuffer, PIECE_SHAPE_SIZE
      1 U00ee		       00 a2	   __pieceShapeBuffer =	TEMPORARY_VAR
      2 U00ee				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + PIECE_SHAPE_SIZE
      3 U00ee
      4 U00ee				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00ee					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00ee				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00ee					      ENDIF
      8 U00ee				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00ee				  -	      ECHO	"Temporary Variable", __pieceShapeBuffer, "overflow!"
     10 U00ee				  -	      ERR
     11 U00ee					      ENDIF
     12 U00ee					      LIST	ON
      0 U00ee					      VAR	__ptr, 2
      1 U00ee		       00 ea	   __ptr      =	TEMPORARY_VAR
      2 U00ee				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3 U00ee
      4 U00ee				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00ee					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00ee				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00ee					      ENDIF
      8 U00ee				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00ee				  -	      ECHO	"Temporary Variable", __ptr, "overflow!"
     10 U00ee				  -	      ERR
     11 U00ee					      ENDIF
     12 U00ee					      LIST	ON
      0 U00ee					      VAR	__ptr2, 2
      1 U00ee		       00 ec	   __ptr2     =	TEMPORARY_VAR
      2 U00ee				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3 U00ee
      4 U00ee				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00ee					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00ee				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00ee					      ENDIF
      8 U00ee				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00ee				  -	      ECHO	"Temporary Variable", __ptr2, "overflow!"
     10 U00ee				  -	      ERR
     11 U00ee					      ENDIF
     12 U00ee					      LIST	ON
     74 U00ee
     75 U00ee							;---------------------------------------------------------------------------------------------------
     76 U00ee
     77 U00ee
     78 U00ee					      ORG	END_OF_OVERLAY
 ---- END OF OVERLAYS ----
     79 U00ee					      ECHO	"---- END OF OVERLAYS ----"
 MAXIMUM OVERLAY SIZE NEEDED =  $4c
     80 U00ee					      ECHO	"MAXIMUM OVERLAY SIZE NEEDED = ", MAXIMUM_REQUIRED_OVERLAY_SIZE
     81 U00ee
     82 U00ee							;EOF
------- FILE ./chess.asm
------- FILE stack.asm LEVEL 2 PASS 5
      0 U00ee					      include	"stack.asm"
      1 U00ee							; Chess
      2 U00ee							; Atari 2600 Chess display system
      3 U00ee							; Copyright (c) 2019-2020 Andrew Davie
      4 U00ee							; andrew@taswegian.com
      5 U00ee
      6 U00ee
      7 U00ee		       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
      8 U00ee
      9 U00ee		       00 00 00 00*	      ds	RESERVED_FOR_STACK
     10 U00fa
     11 U00fa							; WARNING/NOTE - the alphabeta search violates the above size constraints
     12 U00fa							; HOWEVER, the "OVERLAY" segment is beneath this, and will be stomped, depending on # plys
     13 U00fa							;  but since overlay is not generally stressed during alphabeta, we're good.
------- FILE ./chess.asm
    449 U00fa
 FREE BYTES IN ZERO PAGE =  $5
    450 U00fa					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    451 U00fa				  -	      IF	* > $FF
    452 U00fa				  -	      ERR	"Zero Page overflow!"
    453 U00fa					      ENDIF
    454 U00fa
    455 U00fa							;------------------------------------------------------------------------------
    456 U00fa							;##############################################################################
    457 U00fa							;------------------------------------------------------------------------------
    458 U00fa
    459 U00fa							; NOW THE VERY INTERESTING '3E' RAM BANKS
    460 U00fa							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 1k TOTAL ACCESSIBLE
    461 U00fa							; IN A 2K MEMORY SPACE
    462 U00fa
      0 U00fa					      NEWRAMBANK	CHESS_BOARD_ROW
      1 U00fa
      2 U00fa
      3 U00fa
      4 U0000 ????				      SEG.U	CHESS_BOARD_ROW
      5 U0000					      ORG	ORIGIN_RAM
      6 U0000					      RORG	RAM_3E
      7 U0000				   BANK_START SET	*
      8 U0000				   RAMBANK_CHESS_BOARD_ROW SET	ORIGIN_RAM / RAM_SIZE
      9 U0000				   _CURRENT_RAMBANK SET	RAMBANK_CHESS_BOARD_ROW
     10 U0000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    464 U0000					      REPEAT	(CHESSBOARD_ROWS) - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U0000
      2 U0000
      3 U0000
      4 U1c00 ????				      SEG.U	.DUMMY
      5 U0400					      ORG	ORIGIN_RAM
      6 U0400					      RORG	RAM_3E
      7 U0400				   BANK_START SET	*
      8 U0400				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U0400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U0400					      VALIDATE_RAM_SIZE
      1 U0400				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U0400				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U0400				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U0400				  -	      ERR
      5 U0400					      ENDIF
    464 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400
      2 U0400
      3 U0400
      4 U0400					      SEG.U	.DUMMY
      5 U0800					      ORG	ORIGIN_RAM
      6 U0800					      RORG	RAM_3E
      7 U0800				   BANK_START SET	*
      8 U0800				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U0800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U0800					      VALIDATE_RAM_SIZE
      1 U0800				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U0800				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U0800				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U0800				  -	      ERR
      5 U0800					      ENDIF
    464 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800
      2 U0800
      3 U0800
      4 U0800					      SEG.U	.DUMMY
      5 U0c00					      ORG	ORIGIN_RAM
      6 U0c00					      RORG	RAM_3E
      7 U0c00				   BANK_START SET	*
      8 U0c00				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U0c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U0c00					      VALIDATE_RAM_SIZE
      1 U0c00				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U0c00				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U0c00				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U0c00				  -	      ERR
      5 U0c00					      ENDIF
    464 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00
      2 U0c00
      3 U0c00
      4 U0c00					      SEG.U	.DUMMY
      5 U1000					      ORG	ORIGIN_RAM
      6 U1000					      RORG	RAM_3E
      7 U1000				   BANK_START SET	*
      8 U1000				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U1000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1000					      VALIDATE_RAM_SIZE
      1 U1000				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U1000				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U1000				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U1000				  -	      ERR
      5 U1000					      ENDIF
    464 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000
      2 U1000
      3 U1000
      4 U1000					      SEG.U	.DUMMY
      5 U1400					      ORG	ORIGIN_RAM
      6 U1400					      RORG	RAM_3E
      7 U1400				   BANK_START SET	*
      8 U1400				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U1400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1400					      VALIDATE_RAM_SIZE
      1 U1400				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U1400				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U1400				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U1400				  -	      ERR
      5 U1400					      ENDIF
    464 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400
      2 U1400
      3 U1400
      4 U1400					      SEG.U	.DUMMY
      5 U1800					      ORG	ORIGIN_RAM
      6 U1800					      RORG	RAM_3E
      7 U1800				   BANK_START SET	*
      8 U1800				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U1800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1800					      VALIDATE_RAM_SIZE
      1 U1800				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U1800				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U1800				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U1800				  -	      ERR
      5 U1800					      ENDIF
    464 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800
      2 U1800
      3 U1800
      4 U1800					      SEG.U	.DUMMY
      5 U1c00					      ORG	ORIGIN_RAM
      6 U1c00					      RORG	RAM_3E
      7 U1c00				   BANK_START SET	*
      8 U1c00				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U1c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1c00					      VALIDATE_RAM_SIZE
      1 U1c00				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U1c00				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U1c00				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U1c00				  -	      ERR
      5 U1c00					      ENDIF
    467 U1c00					      REPEND
    468 U1c00
    469 U1c00							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    470 U1c00							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    471 U1c00							; The variable definitions are also in that ROM bank (even though they're RAM :)
    472 U1c00
    473 U1c00							; A neat feature of having multiple copies of the same code in different RAM banks
    474 U1c00							; is that we can use that code to switch between banks, and the system will happily
    475 U1c00							; execute the next instruction from the newly switched-in bank without a problem.
    476 U1c00
    477 U1c00							; Now we have the actual graphics data for each of the rows.  This consists of an
    478 U1c00							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    479 U1c00							; character shapes are masked/copied. The depth of the character shapes may be
    480 U1c00							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    481 U1c00							; a multiple of 3, so that the RGB scanlines match at character joins.
    482 U1c00
    483 U1c00							; We have one bank for each chessboard row.  These banks are duplicates of the above,
    484 U1c00							; accessed via the above labels but with the appropriate bank switched in.
    485 U1c00
    486 U1c00							;------------------------------------------------------------------------------
    487 U1c00
    488 U1c00
    489 U1c00							;---------------------------------------------------------------------------------------------------
    490 U1c00
    491 U1c00
    492 U1c00		       00 fe	   RND_EOR_VAL =	$FE	;B4
    493 U1c00
    494 U1c00					      MAC	next_random
    495 U1c00					      lda	rnd
    496 U1c00					      lsr
    497 U1c00					      bcc	.skipEOR
    498 U1c00					      eor	#RND_EOR_VAL
    499 U1c00				   .skipEOR   sta	rnd
    500 U1c00					      ENDM
    501 U1c00
    502 U1c00							;--------------------------------------------------------------------------------
    503 U1c00
    504 U1c00					      MAC	phase
    505 U1c00					      lda	#{1}
    506 U1c00					      sta	aiState
    507 U1c00					      ENDM		;#
    508 U1c00
    509 U1c00
    510 U1c00					      MAC	common_vars_alphabeta
    511 U1c00
    512 U1c00					      VAR	__bestMove, 1
    513 U1c00					      VAR	__bestScore, 2
    514 U1c00					      VAR	__alpha, 2
    515 U1c00					      VAR	__beta, 2
    516 U1c00
    517 U1c00					      ENDM
    518 U1c00
    519 U1c00							;--------------------------------------------------------------------------------
    520 U1c00
    521 U1c00							;ORIGIN      SET 0
    522 U1c00
------- FILE Handler_MACROS.asm LEVEL 2 PASS 5
      0 U1c00					      include	"Handler_MACROS.asm"
      1 U1c00							; Copyright (C)2020 Andrew Davie
      2 U1c00							; Common macros for piece move handlers
      3 U1c00
      4 U1c00							;---------------------------------------------------------------------------------------------------
      5 U1c00							; Looks at a square offset {1} to see if piece can move to it
      6 U1c00							; Adds the square to the movelist if it can
      7 U1c00							; Keeps moving in the same direction until it's blocked/off=board
      8 U1c00
      9 U1c00					      MAC	move_towards
     10 U1c00					      SUBROUTINE
     11 U1c00
     12 U1c00							; = 76 for single square (empty/take)
     13 U1c00
     14 U1c00					      ldx	currentSquare	; 3
     15 U1c00					      bne	.project	; 3   unconditional
     16 U1c00
     17 U1c00				   .empty     jsr	AddMove	; 57
     18 U1c00				   .project   ldy	ValidSquare+{1},x	; 4
     19 U1c00					      bmi	.invalid	; 2/3 off board!
     20 U1c00					      lda	Board,y	; 4   piece @ destination
     21 U1c00					      beq	.empty	; 2/3
     22 U1c00					      eor	currentPiece	; 3
     23 U1c00					      bpl	.invalid	; 2/3 same colour
     24 U1c00					      jsr	AddMove	; 57  and exit
     25 U1c00
     26 U1c00				   .invalid
     27 U1c00					      ENDM
     28 U1c00
     29 U1c00
     30 U1c00							;---------------------------------------------------------------------------------------------------
     31 U1c00
     32 U1c00					      MAC	move_to
     33 U1c00					      SUBROUTINE
     34 U1c00					      ldy	ValidSquare+{1},x
     35 U1c00					      bmi	.invalid	; off board!
     36 U1c00					      lda	Board,y	; piece @ destination
     37 U1c00					      beq	.squareEmpty
     38 U1c00					      eor	currentPiece
     39 U1c00					      bpl	.invalid	; same colour
     40 U1c00				   .squareEmpty jsr	AddMove
     41 U1c00				   .invalid
     42 U1c00					      ENDM
     43 U1c00
     44 U1c00
     45 U1c00							;---------------------------------------------------------------------------------------------------
     46 U1c00
     47 U1c00					      MAC	move_to_x
     48 U1c00					      ldx	currentSquare
     49 U1c00					      MOVE_TO	{1}
     50 U1c00					      ENDM
     51 U1c00
     52 U1c00
     53 U1c00							;---------------------------------------------------------------------------------------------------
     54 U1c00							; EOF
------- FILE ./chess.asm
    524 U1c00
------- FILE BANK_GENERIC.asm LEVEL 2 PASS 5
      0 U1c00					      include	"BANK_GENERIC.asm"
      1 U1c00
      0 U1c00					      NEWBANK	GENERIC_BANK_1
      1  0748 ????				      SEG	GENERIC_BANK_1
      2  0000					      ORG	ORIGIN
      3  0000					      RORG	$F000
      4  0000				   BANK_START SET	*
      5  0000				   GENERIC_BANK_1 SET	ORIGIN / 2048
      6  0000				   ORIGIN     SET	ORIGIN + 2048
      7  0000				   _CURRENT_BANK SET	GENERIC_BANK_1
      3  0000
      0  0000					      DEFINE_1K_SEGMENT	DECODE_LEVEL_SHADOW
      1  0000					      ALIGN	$400
      2  0000				   SEGMENT_DECODE_LEVEL_SHADOW SET	*
      3  0000				   BANK_DECODE_LEVEL_SHADOW SET	_CURRENT_BANK
      5  0000
      6  0000				  -	      if	0
      7  0000				  -	      IF	PLUSCART = YES
      8  0000				  -	      .byte	"ChessAPI.php", #0 //TODO: change!
      9  0000				  -	      .byte	"pluscart.firmaplus.de", #0
     10  0000				  -	      ENDIF
     11  0000					      endif
     12  0000
     13  0000		       85 3e a9 00 STELLA_AUTODETECT .byte.b	$85,$3e,$a9,$00	; 3E
     14  0004
     15  0004
     16  0004							;---------------------------------------------------------------------------------------------------
     17  0004							; ... the above is a (potentially) RAM-copied section -- the following is ROM-only.  Note that
     18  0004							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     19  0004							; bank finishes.  Just continue on from where it left off...
     20  0004							;---------------------------------------------------------------------------------------------------
     21  0004
      0  0004					      DEF	Cart_Init
      1  0004				   BANK_Cart_Init SET	_CURRENT_BANK
      2  0004				   Cart_Init
      3  0004				   TEMPORARY_VAR SET	Overlay
      4  0004				   TEMPORARY_OFFSET SET	0
      5  0004				   VAR_BOUNDARY_Cart_Init SET	TEMPORARY_OFFSET
      6  0004				   FUNCTION_NAME SET	Cart_Init
      7  0004					      SUBROUTINE
     23  0004					      SUBROUTINE
     24  0004
      0  0004					      REFER	Reset
      1  0004				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  0004				  -TEMPORARY_VAR SET	VAREND_Reset
      3  0004					      ENDIF
      0  0004					      VEND	Cart_Init
      1  0004				  -	      IFNCONST	Cart_Init
      2  0004				  -	      ECHO	"Incorrect VEND label", Cart_Init
      3  0004				  -	      ERR
      4  0004					      ENDIF
      5  0004		       00 a2	   VAREND_Cart_Init =	TEMPORARY_VAR
     27  0004
     28  0004		       a9 00		      lda	#0
     29  0006		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     30  0009		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     31  000c		       85 6b		      sta	HMCLR
     32  000e
     33  000e							; cleanup remains of title screen
     34  000e		       85 5b		      sta	GRP0
     35  0010		       85 5c		      sta	GRP1
     36  0012
     37  0012		       a9 10		      lda	#%00010000	; double width missile, double width player
     38  0014		       85 44		      sta	NUSIZ0
     39  0016		       85 45		      sta	NUSIZ1
     40  0018
     41  0018		       a9 04		      lda	#%100	; players/missiles BEHIND BG
     42  001a		       85 4a		      sta	CTRLPF
     43  001c
     44  001c		       60		      rts
     45  001d
     46  001d							;---------------------------------------------------------------------------------------------------
     47  001d
     48  001d				  -	      if	0
     49  001d				  -	      DEF	Resync
     50  001d				  -	      SUBROUTINE
     51  001d				  -
     52  001d				  -	      RESYNC
     53  001d				  -	      rts
     54  001d					      endif
     55  001d
     56  001d							;---------------------------------------------------------------------------------------------------
     57  001d
      0  001d					      DEF	aiStartClearBoard
      1  001d				   BANK_aiStartClearBoard SET	_CURRENT_BANK
      2  001d				   aiStartClearBoard
      3  001d				   TEMPORARY_VAR SET	Overlay
      4  001d				   TEMPORARY_OFFSET SET	0
      5  001d				   VAR_BOUNDARY_aiStartClearBoard SET	TEMPORARY_OFFSET
      6  001d				   FUNCTION_NAME SET	aiStartClearBoard
      7  001d					      SUBROUTINE
     59  001d					      SUBROUTINE
     60  001d
      0  001d					      REFER	AiStateMachine
      1  001d				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  001d				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  001d					      ENDIF
      0  001d					      VEND	aiStartClearBoard
      1  001d				  -	      IFNCONST	aiStartClearBoard
      2  001d				  -	      ECHO	"Incorrect VEND label", aiStartClearBoard
      3  001d				  -	      ERR
      4  001d					      ENDIF
      5  001d		       00 a2	   VAREND_aiStartClearBoard =	TEMPORARY_VAR
     63  001d
     64  001d		       a2 08		      ldx	#8
     65  001f		       86 84		      stx	drawCount	; = bank
     66  0021
     67  0021		       a9 ff		      lda	#-1
     68  0023		       85 88		      sta	cursorX12
     69  0025
      0  0025					      PHASE	AI_ClearEachRow
      1  0025		       a9 0e		      lda	#AI_ClearEachRow
      2  0027		       85 8c		      sta	aiState
     71  0029		       60		      rts
     72  002a
     73  002a							;---------------------------------------------------------------------------------------------------
     74  002a
      0  002a					      DEF	aiClearEachRow
      1  002a				   BANK_aiClearEachRow SET	_CURRENT_BANK
      2  002a				   aiClearEachRow
      3  002a				   TEMPORARY_VAR SET	Overlay
      4  002a				   TEMPORARY_OFFSET SET	0
      5  002a				   VAR_BOUNDARY_aiClearEachRow SET	TEMPORARY_OFFSET
      6  002a				   FUNCTION_NAME SET	aiClearEachRow
      7  002a					      SUBROUTINE
     76  002a					      SUBROUTINE
     77  002a
      0  002a					      REFER	AiStateMachine
      1  002a				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  002a				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  002a					      ENDIF
      0  002a					      VEND	aiClearEachRow
      1  002a				  -	      IFNCONST	aiClearEachRow
      2  002a				  -	      ECHO	"Incorrect VEND label", aiClearEachRow
      3  002a				  -	      ERR
      4  002a					      ENDIF
      5  002a		       00 a2	   VAREND_aiClearEachRow =	TEMPORARY_VAR
     80  002a
     81  002a		       c6 84		      dec	drawCount
     82  002c		       30 05		      bmi	.bitmapCleared
     83  002e		       a4 84		      ldy	drawCount
     84  0030		       4c aa f8 	      jmp	CallClear
     85  0033
     86  0033				   .bitmapCleared
     87  0033
     88  0033		       a9 63		      lda	#99
     89  0035		       85 80		      sta	squareToDraw
     90  0037
      0  0037					      PHASE	AI_DrawEntireBoard
      1  0037		       a9 0f		      lda	#AI_DrawEntireBoard
      2  0039		       85 8c		      sta	aiState
     92  003b		       60		      rts
     93  003c
     94  003c
     95  003c
     96  003c							;---------------------------------------------------------------------------------------------------
     97  003c
      0  003c					      DEF	aiMoveIsSelected
      1  003c				   BANK_aiMoveIsSelected SET	_CURRENT_BANK
      2  003c				   aiMoveIsSelected
      3  003c				   TEMPORARY_VAR SET	Overlay
      4  003c				   TEMPORARY_OFFSET SET	0
      5  003c				   VAR_BOUNDARY_aiMoveIsSelected SET	TEMPORARY_OFFSET
      6  003c				   FUNCTION_NAME SET	aiMoveIsSelected
      7  003c					      SUBROUTINE
     99  003c					      SUBROUTINE
    100  003c
      0  003c					      REFER	AiStateMachine
      1  003c				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  003c				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  003c					      ENDIF
      0  003c					      VEND	aiMoveIsSelected
      1  003c				  -	      IFNCONST	aiMoveIsSelected
      2  003c				  -	      ECHO	"Incorrect VEND label", aiMoveIsSelected
      3  003c				  -	      ERR
      4  003c					      ENDIF
      5  003c		       00 a2	   VAREND_aiMoveIsSelected =	TEMPORARY_VAR
    103  003c
    104  003c
    105  003c							; Both computer and human have now seleted a move, and converge here
    106  003c
    107  003c
    108  003c							; fromPiece	 piece doing the move
    109  003c							; fromX12	 current square X12
    110  003c							; originX12	 starting square X12
    111  003c							; toX12	 ending square X12
    112  003c
    113  003c		       20 b6 f9 	      jsr	AdjustMaterialPositionalValue
    114  003f
    115  003f		       a9 00		      lda	#BLANK
    116  0041		       85 9a		      sta	previousPiece
    117  0043
    118  0043							;lda toSquare
    119  0043							;cmp fromSquare
    120  0043							;beq .idleErase
    121  0043
    122  0043		       a9 06		      lda	#6	; on/off count
    123  0045		       85 84		      sta	drawCount	; flashing for piece about to move
    124  0047		       a9 00		      lda	#0
    125  0049		       85 82		      sta	drawDelay
    126  004b
      0  004b					      PHASE	AI_WriteStartPieceBlank
      1  004b		       a9 16		      lda	#AI_WriteStartPieceBlank
      2  004d		       85 8c		      sta	aiState
    128  004f		       60	   .idleErase rts
    129  0050
    130  0050
    131  0050							;---------------------------------------------------------------------------------------------------
    132  0050
      0  0050					      DEF	aiWriteStartPieceBlank
      1  0050				   BANK_aiWriteStartPieceBlank SET	_CURRENT_BANK
      2  0050				   aiWriteStartPieceBlank
      3  0050				   TEMPORARY_VAR SET	Overlay
      4  0050				   TEMPORARY_OFFSET SET	0
      5  0050				   VAR_BOUNDARY_aiWriteStartPieceBlank SET	TEMPORARY_OFFSET
      6  0050				   FUNCTION_NAME SET	aiWriteStartPieceBlank
      7  0050					      SUBROUTINE
    134  0050					      SUBROUTINE
    135  0050
      0  0050					      REFER	AiStateMachine
      1  0050				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0050				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0050					      ENDIF
      0  0050					      VEND	aiWriteStartPieceBlank
      1  0050				  -	      IFNCONST	aiWriteStartPieceBlank
      2  0050				  -	      ECHO	"Incorrect VEND label", aiWriteStartPieceBlank
      3  0050				  -	      ERR
      4  0050					      ENDIF
      5  0050		       00 a2	   VAREND_aiWriteStartPieceBlank =	TEMPORARY_VAR
    138  0050
    139  0050							; Flash the piece in-place preparatory to moving it.
    140  0050							; drawDelay = flash speed
    141  0050							; drawCount = # of flashes
    142  0050
    143  0050		       a5 82		      lda	drawDelay
    144  0052		       f0 03		      beq	deCount
    145  0054		       c6 82		      dec	drawDelay
    146  0056		       60		      rts
    147  0057				   deCount
    148  0057
    149  0057		       a5 84		      lda	drawCount
    150  0059		       f0 0e		      beq	flashDone
    151  005b		       c6 84		      dec	drawCount
    152  005d
    153  005d		       a9 0a		      lda	#READY_TO_MOVE_FLASH
    154  005f		       85 82		      sta	drawDelay	; "getting ready to move" flash
    155  0061
    156  0061		       a5 85		      lda	fromX12
    157  0063		       85 80		      sta	squareToDraw
    158  0065
    159  0065		       20 a4 fc 	      jsr	CopySinglePiece	; EOR-draw = flash
    160  0068		       60		      rts
    161  0069
      0  0069				   flashDone  PHASE	AI_MarchToTargetA
      1  0069		       a9 17		      lda	#AI_MarchToTargetA
      2  006b		       85 8c		      sta	aiState
    163  006d		       60		      rts
    164  006e
    165  006e
    166  006e							;---------------------------------------------------------------------------------------------------
    167  006e
      0  006e					      DEF	aiDrawPart2
      1  006e				   BANK_aiDrawPart2 SET	_CURRENT_BANK
      2  006e				   aiDrawPart2
      3  006e				   TEMPORARY_VAR SET	Overlay
      4  006e				   TEMPORARY_OFFSET SET	0
      5  006e				   VAR_BOUNDARY_aiDrawPart2 SET	TEMPORARY_OFFSET
      6  006e				   FUNCTION_NAME SET	aiDrawPart2
      7  006e					      SUBROUTINE
    169  006e					      SUBROUTINE
    170  006e
      0  006e					      REFER	AiStateMachine
      1  006e				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  006e				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  006e					      ENDIF
      0  006e					      VEND	aiDrawPart2
      1  006e				  -	      IFNCONST	aiDrawPart2
      2  006e				  -	      ECHO	"Incorrect VEND label", aiDrawPart2
      3  006e				  -	      ERR
      4  006e					      ENDIF
      5  006e		       00 a2	   VAREND_aiDrawPart2 =	TEMPORARY_VAR
    173  006e
    174  006e		       20 a4 fc 	      jsr	CopySinglePiece
    175  0071
      0  0071					      DEF	aiDrawPart3
      1  0071				   BANK_aiDrawPart3 SET	_CURRENT_BANK
      2  0071				   aiDrawPart3
      3  0071				   TEMPORARY_VAR SET	Overlay
      4  0071				   TEMPORARY_OFFSET SET	0
      5  0071				   VAR_BOUNDARY_aiDrawPart3 SET	TEMPORARY_OFFSET
      6  0071				   FUNCTION_NAME SET	aiDrawPart3
      7  0071					      SUBROUTINE
    177  0071					      SUBROUTINE
    178  0071
    179  0071		       c6 80		      dec	squareToDraw
    180  0073		       a5 80		      lda	squareToDraw
    181  0075		       c9 16		      cmp	#22
    182  0077		       90 05		      bcc	.comp
    183  0079
      0  0079					      PHASE	AI_DrawEntireBoard
      1  0079		       a9 0f		      lda	#AI_DrawEntireBoard
      2  007b		       85 8c		      sta	aiState
    185  007d		       60		      rts
    186  007e
      0  007e				   .comp      PHASE	AI_FlipBuffers
      1  007e		       a9 12		      lda	#AI_FlipBuffers
      2  0080		       85 8c		      sta	aiState
    188  0082		       60		      rts
    189  0083
    190  0083
    191  0083
    192  0083							;---------------------------------------------------------------------------------------------------
    193  0083
      0  0083					      DEF	aiMarchB
      1  0083				   BANK_aiMarchB SET	_CURRENT_BANK
      2  0083				   aiMarchB
      3  0083				   TEMPORARY_VAR SET	Overlay
      4  0083				   TEMPORARY_OFFSET SET	0
      5  0083				   VAR_BOUNDARY_aiMarchB SET	TEMPORARY_OFFSET
      6  0083				   FUNCTION_NAME SET	aiMarchB
      7  0083					      SUBROUTINE
    195  0083					      SUBROUTINE
    196  0083
      0  0083					      REFER	AiStateMachine
      1  0083				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0083				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0083					      ENDIF
      0  0083					      VEND	aiMarchB
      1  0083				  -	      IFNCONST	aiMarchB
      2  0083				  -	      ECHO	"Incorrect VEND label", aiMarchB
      3  0083				  -	      ERR
      4  0083					      ENDIF
      5  0083		       00 a2	   VAREND_aiMarchB =	TEMPORARY_VAR
    199  0083
    200  0083							; Draw the piece in the new square
    201  0083
    202  0083		       a5 85		      lda	fromX12
    203  0085		       85 80		      sta	squareToDraw
    204  0087
    205  0087		       20 a4 fc 	      jsr	CopySinglePiece	; draw the moving piece into the new square
    206  008a
    207  008a		       a9 06		      lda	#6	; snail trail delay
    208  008c		       85 82		      sta	drawDelay
    209  008e
      0  008e					      PHASE	AI_MarchToTargetB
      1  008e		       a9 19		      lda	#AI_MarchToTargetB
      2  0090		       85 8c		      sta	aiState
    211  0092		       60		      rts
    212  0093
    213  0093
    214  0093							;---------------------------------------------------------------------------------------------------
    215  0093
      0  0093					      DEF	aiFinalFlash
      1  0093				   BANK_aiFinalFlash SET	_CURRENT_BANK
      2  0093				   aiFinalFlash
      3  0093				   TEMPORARY_VAR SET	Overlay
      4  0093				   TEMPORARY_OFFSET SET	0
      5  0093				   VAR_BOUNDARY_aiFinalFlash SET	TEMPORARY_OFFSET
      6  0093				   FUNCTION_NAME SET	aiFinalFlash
      7  0093					      SUBROUTINE
    217  0093					      SUBROUTINE
    218  0093
      0  0093					      REFER	AiStateMachine
      1  0093				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0093				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0093					      ENDIF
      0  0093					      VEND	aiFinalFlash
      1  0093				  -	      IFNCONST	aiFinalFlash
      2  0093				  -	      ECHO	"Incorrect VEND label", aiFinalFlash
      3  0093				  -	      ERR
      4  0093					      ENDIF
      5  0093		       00 a2	   VAREND_aiFinalFlash =	TEMPORARY_VAR
    221  0093
    222  0093
    223  0093		       a5 82		      lda	drawDelay
    224  0095		       f0 03		      beq	.deCount
    225  0097		       c6 82		      dec	drawDelay
    226  0099		       60		      rts
    227  009a
    228  009a		       a5 84	   .deCount   lda	drawCount
    229  009c		       f0 0e		      beq	flashDone2
    230  009e		       c6 84		      dec	drawCount
    231  00a0
    232  00a0		       a9 0a		      lda	#10
    233  00a2		       85 82		      sta	drawDelay	; "getting ready to move" flash
    234  00a4
    235  00a4		       a5 85		      lda	fromX12
    236  00a6		       85 80		      sta	squareToDraw
    237  00a8
    238  00a8		       20 a4 fc 	      jsr	CopySinglePiece
    239  00ab		       60		      rts
    240  00ac
      0  00ac				   flashDone2 PHASE	AI_SpecialMoveFixup
      1  00ac		       a9 1c		      lda	#AI_SpecialMoveFixup
      2  00ae		       85 8c		      sta	aiState
    242  00b0		       60		      rts
    243  00b1
    244  00b1
    245  00b1							;---------------------------------------------------------------------------------------------------
    246  00b1
      0  00b1					      CHECK_HALF_BANK_SIZE	"GENERIC_BANK_1"
      1  00b1
      2  00b1
      3  00b1		       00 b1	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 (1K) SIZE =  $b1 , FREE= $34f
      4  00b1					      ECHO	"GENERIC_BANK_1", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  00b1				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  00b1				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  00b1				  -	      ERR
      8  00b1					      endif
    248  00b1
    249  00b1
    250  00b1							;---------------------------------------------------------------------------------------------------
    251  00b1
------- FILE piece_vectors.asm LEVEL 3 PASS 5
      0  00b1					      include	"piece_vectors.asm"
      1  00b1							; Created by ConvertChessPieces.py
      0  00b1					      DEF	PIECE_VECTOR_LO
      1  00b1				   BANK_PIECE_VECTOR_LO SET	_CURRENT_BANK
      2  00b1				   PIECE_VECTOR_LO
      3  00b1				   TEMPORARY_VAR SET	Overlay
      4  00b1				   TEMPORARY_OFFSET SET	0
      5  00b1				   VAR_BOUNDARY_PIECE_VECTOR_LO SET	TEMPORARY_OFFSET
      6  00b1				   FUNCTION_NAME SET	PIECE_VECTOR_LO
      7  00b1					      SUBROUTINE
      3  00b1		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_0
      4  00b2		       48		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_1
      5  00b3		       90		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_2
      6  00b4		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_3
      7  00b5		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_0
      8  00b6		       90		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_1
      9  00b7		       00		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_2
     10  00b8		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_3
     11  00b9		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_0
     12  00ba		       00		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_1
     13  00bb		       48		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_2
     14  00bc		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_3
     15  00bd		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_0
     16  00be		       48		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_1
     17  00bf		       90		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_2
     18  00c0		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_3
     19  00c1		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_0
     20  00c2		       90		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_1
     21  00c3		       00		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_2
     22  00c4		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_3
     23  00c5		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_0
     24  00c6		       00		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_1
     25  00c7		       48		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_2
     26  00c8		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_3
     27  00c9		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_0
     28  00ca		       48		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_1
     29  00cb		       90		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_2
     30  00cc		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_3
     31  00cd		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_0
     32  00ce		       90		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_1
     33  00cf		       00		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_2
     34  00d0		       00		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_3
     35  00d1		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_0
     36  00d2		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_1
     37  00d3		       00		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_2
     38  00d4		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_3
     39  00d5		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_0
     40  00d6		       90		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_1
     41  00d7		       00		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_2
     42  00d8		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_3
     43  00d9		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_0
     44  00da		       00		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_1
     45  00db		       48		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_2
     46  00dc		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_3
     47  00dd		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_0
     48  00de		       48		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_1
     49  00df		       90		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_2
     50  00e0		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_3
     51  00e1		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_0
     52  00e2		       90		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_1
     53  00e3		       00		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_2
     54  00e4		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_3
     55  00e5		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_0
     56  00e6		       00		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_1
     57  00e7		       48		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_2
     58  00e8		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_3
     59  00e9		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_0
     60  00ea		       48		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_1
     61  00eb		       90		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_2
     62  00ec		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_3
     63  00ed		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_0
     64  00ee		       90		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_1
     65  00ef		       00		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_2
     66  00f0		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_3
     67  00f1		       00		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_0
     68  00f2		       48		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_1
     69  00f3		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_2
     70  00f4		       00		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_3
     71  00f5		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_0
     72  00f6		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_1
     73  00f7		       90		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_2
     74  00f8		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_3
     75  00f9		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_0
     76  00fa		       00		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_1
     77  00fb		       48		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_2
     78  00fc		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_3
     79  00fd		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_0
     80  00fe		       48		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_1
     81  00ff		       90		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_2
     82  0100		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_3
     83  0101		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_0
     84  0102		       90		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_1
     85  0103		       00		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_2
     86  0104		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_3
     87  0105		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_0
     88  0106		       00		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_1
     89  0107		       48		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_2
     90  0108		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_3
     91  0109		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_0
     92  010a		       48		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_1
     93  010b		       90		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_2
     94  010c		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_3
     95  010d		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_0
     96  010e		       90		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_1
     97  010f		       00		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_2
     98  0110		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_3
     99  0111		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_0
    100  0112		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_1
    101  0113		       48		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_2
    102  0114		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_3
    103  0115		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_0
    104  0116		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_1
    105  0117		       48		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_2
    106  0118		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_3
    107  0119		       90		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_0
    108  011a		       00		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_1
    109  011b		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_2
    110  011c		       90		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_3
    111  011d		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_0
    112  011e		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_1
    113  011f		       90		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_2
    114  0120		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_3
    115  0121		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_0
    116  0122		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_1
    117  0123		       00		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_2
    118  0124		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_3
    119  0125		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_0
    120  0126		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_1
    121  0127		       48		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_2
    122  0128		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_3
    123  0129		       87		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_0
    124  012a		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_1
    125  012b		       48		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_2
    126  012c		       90		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_3
    127  012d		       00		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_0
    128  012e		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_1
    129  012f		       90		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_2
    130  0130		       00		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_3
    131  0131		       48		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_0
    132  0132		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_1
    133  0133		       00		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_2
    134  0134		       48		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_3
    135  0135		       90		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_0
    136  0136		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_1
    137  0137		       48		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_2
    138  0138		       90		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_3
    139  0139		       38		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_0
    140  013a		       80		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_1
    141  013b		       00		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_2
    142  013c		       48		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_3
    143  013d		       61		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_0
    144  013e		       a9		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_1
    145  013f		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_2
    146  0140		       48		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  0141					      DEF	PIECE_VECTOR_HI
      1  0141				   BANK_PIECE_VECTOR_HI SET	_CURRENT_BANK
      2  0141				   PIECE_VECTOR_HI
      3  0141				   TEMPORARY_VAR SET	Overlay
      4  0141				   TEMPORARY_OFFSET SET	0
      5  0141				   VAR_BOUNDARY_PIECE_VECTOR_HI SET	TEMPORARY_OFFSET
      6  0141				   FUNCTION_NAME SET	PIECE_VECTOR_HI
      7  0141					      SUBROUTINE
    148  0141		       f0		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_0
    149  0142		       f0		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_1
    150  0143		       f0		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_2
    151  0144		       f1		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_3
    152  0145		       f1		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_0
    153  0146		       f1		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_1
    154  0147		       f2		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_2
    155  0148		       f2		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_3
    156  0149		       f2		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_0
    157  014a		       f3		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_1
    158  014b		       f3		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_2
    159  014c		       f3		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_3
    160  014d		       f4		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_0
    161  014e		       f4		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_1
    162  014f		       f4		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_2
    163  0150		       f5		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_3
    164  0151		       f5		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_0
    165  0152		       f5		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_1
    166  0153		       f6		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_2
    167  0154		       f6		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_3
    168  0155		       f6		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_0
    169  0156		       f7		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_1
    170  0157		       f7		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_2
    171  0158		       f7		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_3
    172  0159		       f0		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_0
    173  015a		       f0		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_1
    174  015b		       f0		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_2
    175  015c		       f1		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_3
    176  015d		       f6		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_0
    177  015e		       f6		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_1
    178  015f		       f7		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_2
    179  0160		       f7		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_3
    180  0161		       f5		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_0
    181  0162		       f5		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_1
    182  0163		       f6		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_2
    183  0164		       f6		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_3
    184  0165		       f1		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_0
    185  0166		       f1		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_1
    186  0167		       f2		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_2
    187  0168		       f2		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_3
    188  0169		       f2		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_0
    189  016a		       f3		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_1
    190  016b		       f3		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_2
    191  016c		       f3		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_3
    192  016d		       f4		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_0
    193  016e		       f4		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_1
    194  016f		       f4		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_2
    195  0170		       f5		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_3
    196  0171		       f5		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_0
    197  0172		       f5		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_1
    198  0173		       f6		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_2
    199  0174		       f6		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_3
    200  0175		       f6		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_0
    201  0176		       f7		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_1
    202  0177		       f7		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_2
    203  0178		       f7		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_3
    204  0179		       f0		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_0
    205  017a		       f0		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_1
    206  017b		       f0		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_2
    207  017c		       f1		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_3
    208  017d		       f1		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_0
    209  017e		       f1		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_1
    210  017f		       f2		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_2
    211  0180		       f2		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_3
    212  0181		       f5		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_0
    213  0182		       f5		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_1
    214  0183		       f5		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_2
    215  0184		       f6		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_3
    216  0185		       f4		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_0
    217  0186		       f4		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_1
    218  0187		       f4		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_2
    219  0188		       f5		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_3
    220  0189		       f2		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_0
    221  018a		       f3		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_1
    222  018b		       f3		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_2
    223  018c		       f3		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_3
    224  018d		       f4		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_0
    225  018e		       f4		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_1
    226  018f		       f4		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_2
    227  0190		       f5		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_3
    228  0191		       f5		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_0
    229  0192		       f5		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_1
    230  0193		       f6		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_2
    231  0194		       f6		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_3
    232  0195		       f6		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_0
    233  0196		       f7		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_1
    234  0197		       f7		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_2
    235  0198		       f7		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_3
    236  0199		       f0		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_0
    237  019a		       f0		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_1
    238  019b		       f0		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_2
    239  019c		       f1		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_3
    240  019d		       f1		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_0
    241  019e		       f1		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_1
    242  019f		       f2		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_2
    243  01a0		       f2		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_3
    244  01a1		       f2		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_0
    245  01a2		       f3		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_1
    246  01a3		       f3		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_2
    247  01a4		       f3		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_3
    248  01a5		       f5		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_0
    249  01a6		       f6		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_1
    250  01a7		       f6		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_2
    251  01a8		       f6		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_3
    252  01a9		       f3		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_0
    253  01aa		       f4		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_1
    254  01ab		       f4		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_2
    255  01ac		       f4		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_3
    256  01ad		       f4		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_0
    257  01ae		       f4		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_1
    258  01af		       f4		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_2
    259  01b0		       f5		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_3
    260  01b1		       f5		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_0
    261  01b2		       f5		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_1
    262  01b3		       f6		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_2
    263  01b4		       f6		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_3
    264  01b5		       f6		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_0
    265  01b6		       f7		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_1
    266  01b7		       f7		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_2
    267  01b8		       f7		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_3
    268  01b9		       f1		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_0
    269  01ba		       f2		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_1
    270  01bb		       f2		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_2
    271  01bc		       f2		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_3
    272  01bd		       f3		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_0
    273  01be		       f3		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_1
    274  01bf		       f3		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_2
    275  01c0		       f4		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_3
    276  01c1		       f4		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_0
    277  01c2		       f4		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_1
    278  01c3		       f5		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_2
    279  01c4		       f5		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_3
    280  01c5		       f5		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_0
    281  01c6		       f6		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_1
    282  01c7		       f6		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_2
    283  01c8		       f6		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_3
    284  01c9		       f4		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_0
    285  01ca		       f4		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_1
    286  01cb		       f5		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_2
    287  01cc		       f5		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_3
    288  01cd		       f2		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_0
    289  01ce		       f2		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_1
    290  01cf		       f3		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_2
    291  01d0		       f3		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  01d1					      DEF	PIECE_VECTOR_BANK
      1  01d1				   BANK_PIECE_VECTOR_BANK SET	_CURRENT_BANK
      2  01d1				   PIECE_VECTOR_BANK
      3  01d1				   TEMPORARY_VAR SET	Overlay
      4  01d1				   TEMPORARY_OFFSET SET	0
      5  01d1				   VAR_BOUNDARY_PIECE_VECTOR_BANK SET	TEMPORARY_OFFSET
      6  01d1				   FUNCTION_NAME SET	PIECE_VECTOR_BANK
      7  01d1					      SUBROUTINE
    293  01d1		       02		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_0
    294  01d2		       02		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_1
    295  01d3		       02		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_2
    296  01d4		       02		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_3
    297  01d5		       02		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_0
    298  01d6		       02		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_1
    299  01d7		       02		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_2
    300  01d8		       02		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_3
    301  01d9		       02		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0
    302  01da		       02		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1
    303  01db		       02		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2
    304  01dc		       02		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3
    305  01dd		       02		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_0
    306  01de		       02		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_1
    307  01df		       02		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_2
    308  01e0		       02		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_3
    309  01e1		       02		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_0
    310  01e2		       02		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_1
    311  01e3		       02		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_2
    312  01e4		       02		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_3
    313  01e5		       02		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_0
    314  01e6		       02		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_1
    315  01e7		       02		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_2
    316  01e8		       02		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_3
    317  01e9		       03		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_0
    318  01ea		       03		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_1
    319  01eb		       03		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_2
    320  01ec		       03		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_3
    321  01ed		       00		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_0
    322  01ee		       00		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_1
    323  01ef		       00		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_2
    324  01f0		       09		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_3
    325  01f1		       0a		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0
    326  01f2		       0a		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1
    327  01f3		       0a		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2
    328  01f4		       0a		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3
    329  01f5		       03		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_0
    330  01f6		       03		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_1
    331  01f7		       03		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_2
    332  01f8		       03		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_3
    333  01f9		       03		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_0
    334  01fa		       03		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_1
    335  01fb		       03		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_2
    336  01fc		       03		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_3
    337  01fd		       03		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0
    338  01fe		       03		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1
    339  01ff		       03		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2
    340  0200		       03		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3
    341  0201		       03		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_0
    342  0202		       03		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_1
    343  0203		       03		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_2
    344  0204		       03		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_3
    345  0205		       03		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_0
    346  0206		       03		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_1
    347  0207		       03		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_2
    348  0208		       03		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_3
    349  0209		       04		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_0
    350  020a		       04		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_1
    351  020b		       04		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_2
    352  020c		       04		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_3
    353  020d		       04		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_0
    354  020e		       04		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_1
    355  020f		       04		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_2
    356  0210		       04		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_3
    357  0211		       00		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_0
    358  0212		       00		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_1
    359  0213		       00		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_2
    360  0214		       00		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_3
    361  0215		       0a		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0
    362  0216		       0a		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1
    363  0217		       0a		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2
    364  0218		       0a		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3
    365  0219		       04		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_0
    366  021a		       04		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_1
    367  021b		       04		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_2
    368  021c		       04		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_3
    369  021d		       04		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_0
    370  021e		       04		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_1
    371  021f		       04		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_2
    372  0220		       04		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_3
    373  0221		       04		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0
    374  0222		       04		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1
    375  0223		       04		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2
    376  0224		       04		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3
    377  0225		       04		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_0
    378  0226		       04		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_1
    379  0227		       04		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_2
    380  0228		       04		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_3
    381  0229		       05		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_0
    382  022a		       05		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_1
    383  022b		       05		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_2
    384  022c		       05		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_3
    385  022d		       05		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_0
    386  022e		       05		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_1
    387  022f		       05		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_2
    388  0230		       05		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_3
    389  0231		       05		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_0
    390  0232		       05		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_1
    391  0233		       05		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_2
    392  0234		       05		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_3
    393  0235		       06		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_0
    394  0236		       06		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_1
    395  0237		       06		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_2
    396  0238		       06		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_3
    397  0239		       00		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0
    398  023a		       00		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1
    399  023b		       00		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2
    400  023c		       00		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3
    401  023d		       05		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_0
    402  023e		       05		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_1
    403  023f		       05		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_2
    404  0240		       05		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_3
    405  0241		       05		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_0
    406  0242		       05		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_1
    407  0243		       05		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_2
    408  0244		       05		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_3
    409  0245		       05		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0
    410  0246		       05		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1
    411  0247		       05		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2
    412  0248		       05		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3
    413  0249		       09		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_0
    414  024a		       09		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_1
    415  024b		       09		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_2
    416  024c		       09		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_3
    417  024d		       09		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_0
    418  024e		       09		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_1
    419  024f		       09		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_2
    420  0250		       09		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_3
    421  0251		       09		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_0
    422  0252		       09		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_1
    423  0253		       09		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_2
    424  0254		       09		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_3
    425  0255		       09		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_0
    426  0256		       09		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_1
    427  0257		       09		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_2
    428  0258		       09		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_3
    429  0259		       06		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_0
    430  025a		       06		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_1
    431  025b		       06		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_2
    432  025c		       06		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_3
    433  025d		       00		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0
    434  025e		       00		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1
    435  025f		       00		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2
    436  0260		       00		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3
    437  0261
    438  0261							; piece index equates...
    439  0261		       00 00	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_0 =	0
    440  0261		       00 01	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_1 =	1
    441  0261		       00 02	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_2 =	2
    442  0261		       00 03	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_3 =	3
    443  0261		       00 04	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_0 =	4
    444  0261		       00 05	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_1 =	5
    445  0261		       00 06	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_2 =	6
    446  0261		       00 07	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_3 =	7
    447  0261		       00 08	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0 =	8
    448  0261		       00 09	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_1 =	9
    449  0261		       00 0a	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_2 =	10
    450  0261		       00 0b	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_3 =	11
    451  0261		       00 0c	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0 =	12
    452  0261		       00 0d	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_1 =	13
    453  0261		       00 0e	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_2 =	14
    454  0261		       00 0f	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_3 =	15
    455  0261		       00 10	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_0 =	16
    456  0261		       00 11	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_1 =	17
    457  0261		       00 12	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_2 =	18
    458  0261		       00 13	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_3 =	19
    459  0261		       00 14	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0 =	20
    460  0261		       00 15	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_1 =	21
    461  0261		       00 16	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_2 =	22
    462  0261		       00 17	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_3 =	23
    463  0261		       00 18	   INDEX_WHITE_KING_on_WHITE_SQUARE_0 =	24
    464  0261		       00 19	   INDEX_WHITE_KING_on_WHITE_SQUARE_1 =	25
    465  0261		       00 1a	   INDEX_WHITE_KING_on_WHITE_SQUARE_2 =	26
    466  0261		       00 1b	   INDEX_WHITE_KING_on_WHITE_SQUARE_3 =	27
    467  0261		       00 1c	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_0 =	28
    468  0261		       00 1d	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_1 =	29
    469  0261		       00 1e	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_2 =	30
    470  0261		       00 1f	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_3 =	31
    471  0261		       00 20	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0 =	32
    472  0261		       00 21	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_1 =	33
    473  0261		       00 22	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_2 =	34
    474  0261		       00 23	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_3 =	35
    475  0261		       00 24	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_0 =	36
    476  0261		       00 25	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_1 =	37
    477  0261		       00 26	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_2 =	38
    478  0261		       00 27	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_3 =	39
    479  0261		       00 28	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_0 =	40
    480  0261		       00 29	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_1 =	41
    481  0261		       00 2a	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_2 =	42
    482  0261		       00 2b	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_3 =	43
    483  0261		       00 2c	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_0 =	44
    484  0261		       00 2d	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_1 =	45
    485  0261		       00 2e	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_2 =	46
    486  0261		       00 2f	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_3 =	47
    487  0261		       00 30	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_0 =	48
    488  0261		       00 31	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_1 =	49
    489  0261		       00 32	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_2 =	50
    490  0261		       00 33	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_3 =	51
    491  0261		       00 34	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_0 =	52
    492  0261		       00 35	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_1 =	53
    493  0261		       00 36	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_2 =	54
    494  0261		       00 37	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_3 =	55
    495  0261		       00 38	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_0 =	56
    496  0261		       00 39	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_1 =	57
    497  0261		       00 3a	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_2 =	58
    498  0261		       00 3b	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_3 =	59
    499  0261		       00 3c	   INDEX_WHITE_KING_on_BLACK_SQUARE_0 =	60
    500  0261		       00 3d	   INDEX_WHITE_KING_on_BLACK_SQUARE_1 =	61
    501  0261		       00 3e	   INDEX_WHITE_KING_on_BLACK_SQUARE_2 =	62
    502  0261		       00 3f	   INDEX_WHITE_KING_on_BLACK_SQUARE_3 =	63
    503  0261		       00 40	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_0 =	64
    504  0261		       00 41	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_1 =	65
    505  0261		       00 42	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_2 =	66
    506  0261		       00 43	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_3 =	67
    507  0261		       00 44	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_0 =	68
    508  0261		       00 45	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_1 =	69
    509  0261		       00 46	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_2 =	70
    510  0261		       00 47	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_3 =	71
    511  0261		       00 48	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_0 =	72
    512  0261		       00 49	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_1 =	73
    513  0261		       00 4a	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_2 =	74
    514  0261		       00 4b	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_3 =	75
    515  0261		       00 4c	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_0 =	76
    516  0261		       00 4d	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_1 =	77
    517  0261		       00 4e	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_2 =	78
    518  0261		       00 4f	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_3 =	79
    519  0261		       00 50	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0 =	80
    520  0261		       00 51	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_1 =	81
    521  0261		       00 52	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_2 =	82
    522  0261		       00 53	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_3 =	83
    523  0261		       00 54	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0 =	84
    524  0261		       00 55	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_1 =	85
    525  0261		       00 56	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_2 =	86
    526  0261		       00 57	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_3 =	87
    527  0261		       00 58	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_0 =	88
    528  0261		       00 59	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_1 =	89
    529  0261		       00 5a	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_2 =	90
    530  0261		       00 5b	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_3 =	91
    531  0261		       00 5c	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0 =	92
    532  0261		       00 5d	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_1 =	93
    533  0261		       00 5e	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_2 =	94
    534  0261		       00 5f	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_3 =	95
    535  0261		       00 60	   INDEX_BLACK_KING_on_WHITE_SQUARE_0 =	96
    536  0261		       00 61	   INDEX_BLACK_KING_on_WHITE_SQUARE_1 =	97
    537  0261		       00 62	   INDEX_BLACK_KING_on_WHITE_SQUARE_2 =	98
    538  0261		       00 63	   INDEX_BLACK_KING_on_WHITE_SQUARE_3 =	99
    539  0261		       00 64	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_0 =	100
    540  0261		       00 65	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_1 =	101
    541  0261		       00 66	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_2 =	102
    542  0261		       00 67	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_3 =	103
    543  0261		       00 68	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0 =	104
    544  0261		       00 69	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_1 =	105
    545  0261		       00 6a	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_2 =	106
    546  0261		       00 6b	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_3 =	107
    547  0261		       00 6c	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_0 =	108
    548  0261		       00 6d	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_1 =	109
    549  0261		       00 6e	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_2 =	110
    550  0261		       00 6f	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_3 =	111
    551  0261		       00 70	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_0 =	112
    552  0261		       00 71	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_1 =	113
    553  0261		       00 72	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_2 =	114
    554  0261		       00 73	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_3 =	115
    555  0261		       00 74	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_0 =	116
    556  0261		       00 75	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_1 =	117
    557  0261		       00 76	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_2 =	118
    558  0261		       00 77	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_3 =	119
    559  0261		       00 78	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_0 =	120
    560  0261		       00 79	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_1 =	121
    561  0261		       00 7a	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_2 =	122
    562  0261		       00 7b	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_3 =	123
    563  0261		       00 7c	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_0 =	124
    564  0261		       00 7d	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_1 =	125
    565  0261		       00 7e	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_2 =	126
    566  0261		       00 7f	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_3 =	127
    567  0261		       00 80	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_0 =	128
    568  0261		       00 81	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_1 =	129
    569  0261		       00 82	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_2 =	130
    570  0261		       00 83	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_3 =	131
    571  0261		       00 84	   INDEX_BLACK_KING_on_BLACK_SQUARE_0 =	132
    572  0261		       00 85	   INDEX_BLACK_KING_on_BLACK_SQUARE_1 =	133
    573  0261		       00 86	   INDEX_BLACK_KING_on_BLACK_SQUARE_2 =	134
    574  0261		       00 87	   INDEX_BLACK_KING_on_BLACK_SQUARE_3 =	135
    575  0261		       00 88	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_0 =	136
    576  0261		       00 89	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_1 =	137
    577  0261		       00 8a	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_2 =	138
    578  0261		       00 8b	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_3 =	139
    579  0261		       00 8c	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_0 =	140
    580  0261		       00 8d	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_1 =	141
    581  0261		       00 8e	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_2 =	142
    582  0261		       00 8f	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_3 =	143
------- FILE BANK_GENERIC.asm
    253  0261
    254  0261							; include "gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
    255  0261							; include "gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
    256  0261							; include "gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
    257  0261							; include "gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
    258  0261							; include "gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
    259  0261							; include "gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
    260  0261							; include "gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
    261  0261							; include "gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
    262  0261
    263  0261							; include "gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
    264  0261							; include "gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
    265  0261							; include "gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
    266  0261							; include "gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
    267  0261							; include "gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
    268  0261							; include "gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
    269  0261							; include "gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
    270  0261							; include "gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
    271  0261
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  0261					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  0261					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_0", 72
     12  0261					      LIST	ON
      0  0261					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_0
      1  0261				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  0261				   BLACK_PROMOTE_on_BLACK_SQUARE_0
      3  0261				   TEMPORARY_VAR SET	Overlay
      4  0261				   TEMPORARY_OFFSET SET	0
      5  0261				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  0261				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_0
      7  0261					      SUBROUTINE
      3  0261		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0279		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0291		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  02a9					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  02a9					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_1", 72
     12  02a9					      LIST	ON
      0  02a9					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_1
      1  02a9				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  02a9				   BLACK_PROMOTE_on_BLACK_SQUARE_1
      3  02a9				   TEMPORARY_VAR SET	Overlay
      4  02a9				   TEMPORARY_OFFSET SET	0
      5  02a9				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  02a9				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_1
      7  02a9					      SUBROUTINE
      3  02a9		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  02c1		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  02d9		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  02f1					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  02f1					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_2", 72
     12  0300					      LIST	ON
      0  0300					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_2
      1  0300				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  0300				   BLACK_PROMOTE_on_BLACK_SQUARE_2
      3  0300				   TEMPORARY_VAR SET	Overlay
      4  0300				   TEMPORARY_OFFSET SET	0
      5  0300				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  0300				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_2
      7  0300					      SUBROUTINE
      3  0300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0318		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0330		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  0348					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  0348					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_3", 72
     12  0348					      LIST	ON
      0  0348					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_3
      1  0348				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  0348				   BLACK_PROMOTE_on_BLACK_SQUARE_3
      3  0348				   TEMPORARY_VAR SET	Overlay
      4  0348				   TEMPORARY_OFFSET SET	0
      5  0348				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  0348				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_3
      7  0348					      SUBROUTINE
      3  0348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0378		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 5
      0  0390					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  0390					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_0", 72
     12  0390					      LIST	ON
      0  0390					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_0
      1  0390				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  0390				   BLACK_PROMOTE_on_WHITE_SQUARE_0
      3  0390				   TEMPORARY_VAR SET	Overlay
      4  0390				   TEMPORARY_OFFSET SET	0
      5  0390				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  0390				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_0
      7  0390					      SUBROUTINE
      3  0390		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  03a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  03c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 5
      0  03d8					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  03d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_1", 72
     12  0400					      LIST	ON
      0  0400					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_1
      1  0400				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  0400				   BLACK_PROMOTE_on_WHITE_SQUARE_1
      3  0400				   TEMPORARY_VAR SET	Overlay
      4  0400				   TEMPORARY_OFFSET SET	0
      5  0400				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  0400				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_1
      7  0400					      SUBROUTINE
      3  0400		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0418		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  0430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 5
      0  0448					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  0448					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_2", 72
     12  0448					      LIST	ON
      0  0448					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_2
      1  0448				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  0448				   BLACK_PROMOTE_on_WHITE_SQUARE_2
      3  0448				   TEMPORARY_VAR SET	Overlay
      4  0448				   TEMPORARY_OFFSET SET	0
      5  0448				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  0448				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_2
      7  0448					      SUBROUTINE
      3  0448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0460		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  0478		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 5
      0  0490					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  0490					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_3", 72
     12  0490					      LIST	ON
      0  0490					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_3
      1  0490				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  0490				   BLACK_PROMOTE_on_WHITE_SQUARE_3
      3  0490				   TEMPORARY_VAR SET	Overlay
      4  0490				   TEMPORARY_OFFSET SET	0
      5  0490				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  0490				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_3
      7  0490					      SUBROUTINE
      3  0490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  04a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  04c0		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE BANK_GENERIC.asm
    280  04d8
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  04d8					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm"
      0  04d8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_0", 72
     12  0500					      LIST	ON
      0  0500					      DEF	WHITE_MARKER_on_BLACK_SQUARE_0
      1  0500				   BANK_WHITE_MARKER_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  0500				   WHITE_MARKER_on_BLACK_SQUARE_0
      3  0500				   TEMPORARY_VAR SET	Overlay
      4  0500				   TEMPORARY_OFFSET SET	0
      5  0500				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  0500				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_0
      7  0500					      SUBROUTINE
      3  0500		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00	;PF0
      4  0518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0530		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  0548					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm"
      0  0548					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_1", 72
     12  0548					      LIST	ON
      0  0548					      DEF	WHITE_MARKER_on_BLACK_SQUARE_1
      1  0548				   BANK_WHITE_MARKER_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  0548				   WHITE_MARKER_on_BLACK_SQUARE_1
      3  0548				   TEMPORARY_VAR SET	Overlay
      4  0548				   TEMPORARY_OFFSET SET	0
      5  0548				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  0548				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_1
      7  0548					      SUBROUTINE
      3  0548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0560		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00	;PF1
      5  0578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  0590					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm"
      0  0590					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_2", 72
     12  0590					      LIST	ON
      0  0590					      DEF	WHITE_MARKER_on_BLACK_SQUARE_2
      1  0590				   BANK_WHITE_MARKER_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  0590				   WHITE_MARKER_on_BLACK_SQUARE_2
      3  0590				   TEMPORARY_VAR SET	Overlay
      4  0590				   TEMPORARY_OFFSET SET	0
      5  0590				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  0590				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_2
      7  0590					      SUBROUTINE
      3  0590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  05a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  05c0		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  05d8					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm"
      0  05d8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_3", 72
     12  0600					      LIST	ON
      0  0600					      DEF	WHITE_MARKER_on_BLACK_SQUARE_3
      1  0600				   BANK_WHITE_MARKER_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  0600				   WHITE_MARKER_on_BLACK_SQUARE_3
      3  0600				   TEMPORARY_VAR SET	Overlay
      4  0600				   TEMPORARY_OFFSET SET	0
      5  0600				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  0600				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_3
      7  0600					      SUBROUTINE
      3  0600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0630		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 5
      0  0648					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm"
      0  0648					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_0", 72
     12  0648					      LIST	ON
      0  0648					      DEF	WHITE_MARKER_on_WHITE_SQUARE_0
      1  0648				   BANK_WHITE_MARKER_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  0648				   WHITE_MARKER_on_WHITE_SQUARE_0
      3  0648				   TEMPORARY_VAR SET	Overlay
      4  0648				   TEMPORARY_OFFSET SET	0
      5  0648				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  0648				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_0
      7  0648					      SUBROUTINE
      3  0648		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0678		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 5
      0  0690					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm"
      0  0690					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_1", 72
     12  0690					      LIST	ON
      0  0690					      DEF	WHITE_MARKER_on_WHITE_SQUARE_1
      1  0690				   BANK_WHITE_MARKER_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  0690				   WHITE_MARKER_on_WHITE_SQUARE_1
      3  0690				   TEMPORARY_VAR SET	Overlay
      4  0690				   TEMPORARY_OFFSET SET	0
      5  0690				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  0690				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_1
      7  0690					      SUBROUTINE
      3  0690		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  06a8		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  06c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 5
      0  06d8					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm"
      0  06d8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_2", 72
     12  0700					      LIST	ON
      0  0700					      DEF	WHITE_MARKER_on_WHITE_SQUARE_2
      1  0700				   BANK_WHITE_MARKER_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  0700				   WHITE_MARKER_on_WHITE_SQUARE_2
      3  0700				   TEMPORARY_VAR SET	Overlay
      4  0700				   TEMPORARY_OFFSET SET	0
      5  0700				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  0700				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_2
      7  0700					      SUBROUTINE
      3  0700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0718		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0730		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
    288  0748
      0  0748					      CHECK_BANK_SIZE	"GENERIC_BANK_1 -- full 2K"
      1  0748		       07 48	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 -- full 2K (2K) SIZE =  $748 , FREE= $b8
      2  0748					      ECHO	"GENERIC_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0748				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0748				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0748				  -	      ERR
      6  0748					      endif
------- FILE ./chess.asm
------- FILE BANK_ROM_SHADOW_SCREEN.asm LEVEL 2 PASS 5
      0  0748					      include	"BANK_ROM_SHADOW_SCREEN.asm"
      1  0748
      0  0748					      NEWBANK	BANK_ROM_SHADOW_OF_CHESS_BITMAP
      1  0b06 ????				      SEG	BANK_ROM_SHADOW_OF_CHESS_BITMAP
      2  0800					      ORG	ORIGIN
      3  0800					      RORG	$F000
      4  0800				   BANK_START SET	*
      5  0800				   BANK_ROM_SHADOW_OF_CHESS_BITMAP SET	ORIGIN / 2048
      6  0800				   ORIGIN     SET	ORIGIN + 2048
      7  0800				   _CURRENT_BANK SET	BANK_ROM_SHADOW_OF_CHESS_BITMAP
      3  0800
      4  0800							; Template bank for a SINGLE ROW of the chessboard display.
      5  0800							; There are 8x of these.
      6  0800							; The bank contains the definition of the bitmap, and also the code to draw the bitmap
      7  0800							; The bank is copied from ROM into RAM at startup.
      8  0800							; The draw switches between consecutive row banks, with the last returning
      9  0800							; we effectively have 1K
     10  0800							;---------------------------------------------------------------------------------------------------
     11  0800
     12  0800		       00 a4	   COLOUR_LINE_1 =	$a4
     13  0800		       00 4a	   COLOUR_LINE_2 =	$4a
     14  0800		       00 2a	   COLOUR_LINE_3 =	$2A
     15  0800		       00 00	   BACKGCOL   =	$00
     16  0800
     17  0800
     18  0800
     19  0800							; good/contrast
     20  0800							;COLOUR_LINE_1 = $a6
     21  0800							;COLOUR_LINE_2 = $4a
     22  0800							;COLOUR_LINE_3 = $2A
     23  0800
     24  0800							;COLOUR_LINE_1 = $94 ; square col
     25  0800							;COLOUR_LINE_2 = $C6
     26  0800							;COLOUR_LINE_3 = $48
     27  0800							;BACKGCOL	= 0 ;$F0
     28  0800
     29  0800
     30  0800							; good 94/46/28/0
     31  0800							; good 94/44/26/0
     32  0800
     33  0800
     34  0800		       00 90	   ROW_BITMAP_SIZE =	6 * 24	; PF0/PF1/PF2/(PF0)/(PF1)/(PF2) x 8 ICC pixels
     35  0800
     36  0800
      0  0800					      ALLOCATE	ChessBitmap, ROW_BITMAP_SIZE
      0  0800					      OPTIONAL_PAGEBREAK	"Table", ROW_BITMAP_SIZE
     12  0800					      LIST	ON
      0  0800					      DEF	ChessBitmap
      1  0800				   BANK_ChessBitmap SET	_CURRENT_BANK
      2  0800				   ChessBitmap
      3  0800				   TEMPORARY_VAR SET	Overlay
      4  0800				   TEMPORARY_OFFSET SET	0
      5  0800				   VAR_BOUNDARY_ChessBitmap SET	TEMPORARY_OFFSET
      6  0800				   FUNCTION_NAME SET	ChessBitmap
      7  0800					      SUBROUTINE
     38  0800		       00 00 00 00*ChessBitmap0 ds	24
     39  0818		       00 00 00 00*ChessBitmap1 ds	24
     40  0830		       00 00 00 00*ChessBitmap2 ds	24
     41  0848		       00 00 00 00*ChessBitmap3 ds	24
     42  0860		       00 00 00 00*ChessBitmap4 ds	24
     43  0878		       00 00 00 00*ChessBitmap5 ds	24
     44  0890
      0  0890					      ALLOCATE	BlankSprite, 8
      0  0890					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0890					      LIST	ON
      0  0890					      DEF	BlankSprite
      1  0890				   BANK_BlankSprite SET	_CURRENT_BANK
      2  0890				   BlankSprite
      3  0890				   TEMPORARY_VAR SET	Overlay
      4  0890				   TEMPORARY_OFFSET SET	0
      5  0890				   VAR_BOUNDARY_BlankSprite SET	TEMPORARY_OFFSET
      6  0890				   FUNCTION_NAME SET	BlankSprite
      7  0890					      SUBROUTINE
     46  0890		       00 00 00 00*	      ds	8, 0
     47  0898
      0  0898					      ALLOCATE	SpriteBuffer, 24
      0  0898					      OPTIONAL_PAGEBREAK	"Table", 24
     12  0898					      LIST	ON
      0  0898					      DEF	SpriteBuffer
      1  0898				   BANK_SpriteBuffer SET	_CURRENT_BANK
      2  0898				   SpriteBuffer
      3  0898				   TEMPORARY_VAR SET	Overlay
      4  0898				   TEMPORARY_OFFSET SET	0
      5  0898				   VAR_BOUNDARY_SpriteBuffer SET	TEMPORARY_OFFSET
      6  0898				   FUNCTION_NAME SET	SpriteBuffer
      7  0898					      SUBROUTINE
     49  0898				   SpriteBuffer2
     50  0898					      REPEAT	24
     51  0898		       f8		      .byte.b	%11111000
     50  0898					      REPEND
     51  0899		       f8		      .byte.b	%11111000
     50  0899					      REPEND
     51  089a		       f8		      .byte.b	%11111000
     50  089a					      REPEND
     51  089b		       f8		      .byte.b	%11111000
     50  089b					      REPEND
     51  089c		       f8		      .byte.b	%11111000
     50  089c					      REPEND
     51  089d		       f8		      .byte.b	%11111000
     50  089d					      REPEND
     51  089e		       f8		      .byte.b	%11111000
     50  089e					      REPEND
     51  089f		       f8		      .byte.b	%11111000
     50  089f					      REPEND
     51  08a0		       f8		      .byte.b	%11111000
     50  08a0					      REPEND
     51  08a1		       f8		      .byte.b	%11111000
     50  08a1					      REPEND
     51  08a2		       f8		      .byte.b	%11111000
     50  08a2					      REPEND
     51  08a3		       f8		      .byte.b	%11111000
     50  08a3					      REPEND
     51  08a4		       f8		      .byte.b	%11111000
     50  08a4					      REPEND
     51  08a5		       f8		      .byte.b	%11111000
     50  08a5					      REPEND
     51  08a6		       f8		      .byte.b	%11111000
     50  08a6					      REPEND
     51  08a7		       f8		      .byte.b	%11111000
     50  08a7					      REPEND
     51  08a8		       f8		      .byte.b	%11111000
     50  08a8					      REPEND
     51  08a9		       f8		      .byte.b	%11111000
     50  08a9					      REPEND
     51  08aa		       f8		      .byte.b	%11111000
     50  08aa					      REPEND
     51  08ab		       f8		      .byte.b	%11111000
     50  08ab					      REPEND
     51  08ac		       f8		      .byte.b	%11111000
     50  08ac					      REPEND
     51  08ad		       f8		      .byte.b	%11111000
     50  08ad					      REPEND
     51  08ae		       f8		      .byte.b	%11111000
     50  08ae					      REPEND
     51  08af		       f8		      .byte.b	%11111000
     52  08b0					      REPEND
     53  08b0
      0  08b0					      ALLOCATE	BackupBitmap, ROW_BITMAP_SIZE
      0  08b0					      OPTIONAL_PAGEBREAK	"Table", ROW_BITMAP_SIZE
     12  0900					      LIST	ON
      0  0900					      DEF	BackupBitmap
      1  0900				   BANK_BackupBitmap SET	_CURRENT_BANK
      2  0900				   BackupBitmap
      3  0900				   TEMPORARY_VAR SET	Overlay
      4  0900				   TEMPORARY_OFFSET SET	0
      5  0900				   VAR_BOUNDARY_BackupBitmap SET	TEMPORARY_OFFSET
      6  0900				   FUNCTION_NAME SET	BackupBitmap
      7  0900					      SUBROUTINE
     55  0900		       00 00 00 00*	      ds	ROW_BITMAP_SIZE, 0
     56  0990
     57  0990							;---------------------------------------------------------------------------------------------------
     58  0990
      0  0990					      DEF	ClearRowBitmap
      1  0990				   BANK_ClearRowBitmap SET	_CURRENT_BANK
      2  0990				   ClearRowBitmap
      3  0990				   TEMPORARY_VAR SET	Overlay
      4  0990				   TEMPORARY_OFFSET SET	0
      5  0990				   VAR_BOUNDARY_ClearRowBitmap SET	TEMPORARY_OFFSET
      6  0990				   FUNCTION_NAME SET	ClearRowBitmap
      7  0990					      SUBROUTINE
     60  0990					      SUBROUTINE
     61  0990
      0  0990					      REFER	CallClear
      1  0990				  -	      IF	VAREND_CallClear > TEMPORARY_VAR
      2  0990				  -TEMPORARY_VAR SET	VAREND_CallClear
      3  0990					      ENDIF
      0  0990					      VEND	ClearRowBitmap
      1  0990				  -	      IFNCONST	ClearRowBitmap
      2  0990				  -	      ECHO	"Incorrect VEND label", ClearRowBitmap
      3  0990				  -	      ERR
      4  0990					      ENDIF
      5  0990		       00 a2	   VAREND_ClearRowBitmap =	TEMPORARY_VAR
     64  0990
     65  0990							; No transient variable dependencies/calls
     66  0990
     67  0990		       a9 00		      lda	#0
     68  0992		       a0 90		      ldy	#ROW_BITMAP_SIZE
      0  0994				   .clearRow  sta@RAM	ChessBitmap-1,y
      1  0994		       99 ff f3 	      sta	[RAM]+ChessBitmap-1,y
     70  0997		       88		      dey
     71  0998		       d0 fa		      bne	.clearRow
     72  099a		       60		      rts
     73  099b
     74  099b
     75  099b							;---------------------------------------------------------------------------------------------------
     76  099b
      0  099b					      DEF	CopyPieceToRowBitmap
      1  099b				   BANK_CopyPieceToRowBitmap SET	_CURRENT_BANK
      2  099b				   CopyPieceToRowBitmap
      3  099b				   TEMPORARY_VAR SET	Overlay
      4  099b				   TEMPORARY_OFFSET SET	0
      5  099b				   VAR_BOUNDARY_CopyPieceToRowBitmap SET	TEMPORARY_OFFSET
      6  099b				   FUNCTION_NAME SET	CopyPieceToRowBitmap
      7  099b					      SUBROUTINE
     78  099b					      SUBROUTINE
     79  099b
      0  099b					      REFER	CopySinglePiece	; special-case due to 'intercept'
      1  099b					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  099b				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  099b					      ENDIF
      0  099b					      VEND	CopyPieceToRowBitmap
      1  099b				  -	      IFNCONST	CopyPieceToRowBitmap
      2  099b				  -	      ECHO	"Incorrect VEND label", CopyPieceToRowBitmap
      3  099b				  -	      ERR
      4  099b					      ENDIF
      5  099b		       00 a9	   VAREND_CopyPieceToRowBitmap =	TEMPORARY_VAR
     82  099b
     83  099b		       a0 11		      ldy	#17
     84  099d		       b0 30		      bcs	.rightSide
     85  099f
     86  099f		       b9 a2 00    .copyPiece lda	__pieceShapeBuffer,y
     87  09a2		       f0 06		      beq	.blank1
     88  09a4		       59 00 f0 	      eor	ChessBitmap,y
      0  09a7					      sta@RAM	ChessBitmap,y
      1  09a7		       99 00 f4 	      sta	[RAM]+ChessBitmap,y
     90  09aa
     91  09aa		       b9 b4 00    .blank1    lda	__pieceShapeBuffer+18,y
     92  09ad		       f0 06		      beq	.blank2
     93  09af		       59 12 f0 	      eor	ChessBitmap+18,y
      0  09b2					      sta@RAM	ChessBitmap+18,y
      1  09b2		       99 12 f4 	      sta	[RAM]+ChessBitmap+18,y
     95  09b5
     96  09b5		       b9 c6 00    .blank2    lda	__pieceShapeBuffer+36,y
     97  09b8		       f0 06		      beq	.blank3
     98  09ba		       59 24 f0 	      eor	ChessBitmap+36,y
      0  09bd					      sta@RAM	ChessBitmap+36,y
      1  09bd		       99 24 f4 	      sta	[RAM]+ChessBitmap+36,y
    100  09c0
    101  09c0		       b9 d8 00    .blank3    lda	__pieceShapeBuffer+54,y
    102  09c3		       f0 06		      beq	.blank4
    103  09c5		       59 36 f0 	      eor	ChessBitmap+54,y
      0  09c8					      sta@RAM	ChessBitmap+54,y
      1  09c8		       99 36 f4 	      sta	[RAM]+ChessBitmap+54,y
    105  09cb
    106  09cb		       88	   .blank4    dey
    107  09cc		       10 d1		      bpl	.copyPiece
    108  09ce		       60		      rts
    109  09cf
    110  09cf				   .rightSide
    111  09cf
    112  09cf					      SUBROUTINE
    113  09cf
    114  09cf		       b9 a2 00    .copyPieceR lda	__pieceShapeBuffer,y
    115  09d2		       f0 06		      beq	.blank1
    116  09d4		       59 48 f0 	      eor	ChessBitmap+72,y
      0  09d7					      sta@RAM	ChessBitmap+72,y
      1  09d7		       99 48 f4 	      sta	[RAM]+ChessBitmap+72,y
    118  09da
    119  09da		       b9 b4 00    .blank1    lda	__pieceShapeBuffer+18,y
    120  09dd		       f0 06		      beq	.blank2
    121  09df		       59 5a f0 	      eor	ChessBitmap+72+18,y
      0  09e2					      sta@RAM	ChessBitmap+72+18,y
      1  09e2		       99 5a f4 	      sta	[RAM]+ChessBitmap+72+18,y
    123  09e5
    124  09e5		       b9 c6 00    .blank2    lda	__pieceShapeBuffer+36,y
    125  09e8		       f0 06		      beq	.blank3
    126  09ea		       59 6c f0 	      eor	ChessBitmap+72+36,y
      0  09ed					      sta@RAM	ChessBitmap+72+36,y
      1  09ed		       99 6c f4 	      sta	[RAM]+ChessBitmap+72+36,y
    128  09f0
    129  09f0		       b9 d8 00    .blank3    lda	__pieceShapeBuffer+54,y
    130  09f3		       f0 06		      beq	.blank4
    131  09f5		       59 7e f0 	      eor	ChessBitmap+72+54,y
      0  09f8					      sta@RAM	ChessBitmap+72+54,y
      1  09f8		       99 7e f4 	      sta	[RAM]+ChessBitmap+72+54,y
    133  09fb
    134  09fb		       88	   .blank4    dey
    135  09fc		       10 d1		      bpl	.copyPieceR
    136  09fe		       60		      rts
    137  09ff
    138  09ff
    139  09ff							;---------------------------------------------------------------------------------------------------
    140  09ff
    141  0a00		       00		      ALIGN	256
    142  0a00					      SUBROUTINE
    143  0a00
      0  0a00					      REFER	Reset
      1  0a00				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  0a00				  -TEMPORARY_VAR SET	VAREND_Reset
      3  0a00					      ENDIF
    145  0a00				   __dummy
      0  0a00					      VEND	__dummy
      1  0a00				  -	      IFNCONST	__dummy
      2  0a00				  -	      ECHO	"Incorrect VEND label", __dummy
      3  0a00				  -	      ERR
      4  0a00					      ENDIF
      5  0a00		       00 a9	   VAREND___dummy =	TEMPORARY_VAR
    147  0a00
    148  0a00							; x = row # (and bank#)
    149  0a00
    150  0a00				   .endline
    151  0a00
    152  0a00							;@59
    153  0a00
    154  0a00							; The following 'inx' is replaced in the LAST row bank with a 'RTS', thus ending the draw loop
    155  0a00							; Note that the other 7 row banks are unmodified (keeping the 'inx')
    156  0a00				   SELFMOD_RTS_ON_LAST_ROW
    157  0a00
    158  0a00		       e8		      inx		; 2
    159  0a01		       86 3e		      stx	SET_BANK_RAM	; 3 @64     BANK switch to next row
    160  0a03
      0  0a03					      DEF	DrawRow
      1  0a03				   BANK_DrawRow SET	_CURRENT_BANK
      2  0a03				   DrawRow
      3  0a03				   TEMPORARY_VAR SET	Overlay
      4  0a03				   TEMPORARY_OFFSET SET	0
      5  0a03				   VAR_BOUNDARY_DrawRow SET	TEMPORARY_OFFSET
      6  0a03				   FUNCTION_NAME SET	DrawRow
      7  0a03					      SUBROUTINE
    162  0a03
    163  0a03							;@64
    164  0a03		       a0 07		      ldy	#7	; 2
    165  0a05		       10 3b		      bpl	.dl2	; 3   (must be 69 here)
    166  0a07
    167  0a07							;@58...
    168  0a07
    169  0a07				   .l3
    170  0a07
    171  0a07		       b9 a8 f0    SMSPRITE16_0 lda	SpriteBuffer+16,y	; 4
    172  0a0a		       85 5b		      sta	GRP0	; 3
    173  0a0c		       b9 a8 f0    SMSPRITE16_1 lda	SpriteBuffer2+16,y	; 4
    174  0a0f		       85 5c		      sta	GRP1	; 3
    175  0a11
    176  0a11							;@-4
    177  0a11
    178  0a11		       a9 a4		      lda	#COLOUR_LINE_1	;#$94			  ; 2
    179  0a13		       85 48		      sta	COLUPF	; 3 @1
    180  0a15
    181  0a15		       b9 10 f0 	      lda	ChessBitmap0+16,y	; 4
    182  0a18		       85 4d		      sta	PF0	; 3
    183  0a1a		       b9 28 f0 	      lda	ChessBitmap1+16,y	; 4
    184  0a1d		       85 4e		      sta	PF1	; 3
    185  0a1f		       b9 40 f0 	      lda	ChessBitmap2+16,y	; 4
    186  0a22		       85 4f		      sta	PF2	; 3 @22
    187  0a24
      0  0a24					      SLEEP	6	; 6 @28
      1  0a24				   .CYCLES    SET	6
      2  0a24
      3  0a24				  -	      IF	.CYCLES < 2
      4  0a24				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0a24				  -	      ERR
      6  0a24					      ENDIF
      7  0a24
      8  0a24				  -	      IF	.CYCLES & 1
      9  0a24				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0a24				  -	      nop	0
     11  0a24				  -	      ELSE
     12  0a24				  -	      bit	VSYNC
     13  0a24				  -	      ENDIF
     14  0a24				  -.CYCLES    SET	.CYCLES - 3
     15  0a24					      ENDIF
     16  0a24
     17  0a24					      REPEAT	.CYCLES / 2
     18  0a24		       ea		      nop
     17  0a24					      REPEND
     18  0a25		       ea		      nop
     17  0a25					      REPEND
     18  0a26		       ea		      nop
     19  0a27					      REPEND
    189  0a27
    190  0a27		       b9 58 f0 	      lda	ChessBitmap3+16,y	; 4
    191  0a2a		       85 4d		      sta	PF0	; 3
    192  0a2c		       b9 70 f0 	      lda	ChessBitmap4+16,y	; 4
    193  0a2f		       85 4e		      sta	PF1	; 3
    194  0a31		       b9 88 f0 	      lda	ChessBitmap5+16,y	; 4
    195  0a34		       8d 4f 00 	      sta.w	PF2	; 4 @50
    196  0a37
      0  0a37					      SLEEP	4	; 4
      1  0a37				   .CYCLES    SET	4
      2  0a37
      3  0a37				  -	      IF	.CYCLES < 2
      4  0a37				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0a37				  -	      ERR
      6  0a37					      ENDIF
      7  0a37
      8  0a37				  -	      IF	.CYCLES & 1
      9  0a37				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0a37				  -	      nop	0
     11  0a37				  -	      ELSE
     12  0a37				  -	      bit	VSYNC
     13  0a37				  -	      ENDIF
     14  0a37				  -.CYCLES    SET	.CYCLES - 3
     15  0a37					      ENDIF
     16  0a37
     17  0a37					      REPEAT	.CYCLES / 2
     18  0a37		       ea		      nop
     17  0a37					      REPEND
     18  0a38		       ea		      nop
     19  0a39					      REPEND
    198  0a39
    199  0a39		       88		      dey		; 2
    200  0a3a		       30 c4		      bmi	.endline	; 2 (3)
    201  0a3c
    202  0a3c							;@57
    203  0a3c				   .drawLine
    204  0a3c
      0  0a3c					      SLEEP	11
      1  0a3c				   .CYCLES    SET	11
      2  0a3c
      3  0a3c				  -	      IF	.CYCLES < 2
      4  0a3c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0a3c				  -	      ERR
      6  0a3c					      ENDIF
      7  0a3c
      8  0a3c					      IF	.CYCLES & 1
      9  0a3c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0a3c		       04 00		      nop	0
     11  0a3e				  -	      ELSE
     12  0a3e				  -	      bit	VSYNC
     13  0a3e					      ENDIF
     14  0a3e				   .CYCLES    SET	.CYCLES - 3
     15  0a3e					      ENDIF
     16  0a3e
     17  0a3e					      REPEAT	.CYCLES / 2
     18  0a3e		       ea		      nop
     17  0a3e					      REPEND
     18  0a3f		       ea		      nop
     17  0a3f					      REPEND
     18  0a40		       ea		      nop
     17  0a40					      REPEND
     18  0a41		       ea		      nop
     19  0a42					      REPEND
    206  0a42
    207  0a42				   .dl2
    208  0a42		       b9 98 f0    SMSPRITE0_0 lda	SpriteBuffer,y	; 4
    209  0a45		       85 5b		      sta	GRP0	; 3
    210  0a47		       b9 98 f0    SMSPRITE0_1 lda	SpriteBuffer2,y	; 4
    211  0a4a		       85 5c		      sta	GRP1	; 3
    212  0a4c
    213  0a4c							;@7
    214  0a4c
    215  0a4c		       a9 4a		      lda	#COLOUR_LINE_2	;#$4A			  ; 2
    216  0a4e		       85 48		      sta	COLUPF	; 3 @12
    217  0a50
    218  0a50		       b9 00 f0 	      lda	ChessBitmap0,y	; 4
    219  0a53		       85 4d		      sta	PF0	; 3
    220  0a55		       b9 18 f0 	      lda	ChessBitmap1,y	; 4
    221  0a58		       85 4e		      sta	PF1	; 3
    222  0a5a		       b9 30 f0 	      lda	ChessBitmap2,y	; 4
    223  0a5d		       85 4f		      sta	PF2	; 3 @33
    224  0a5f
      0  0a5f					      SLEEP	3	; 3 @36
      1  0a5f				   .CYCLES    SET	3
      2  0a5f
      3  0a5f				  -	      IF	.CYCLES < 2
      4  0a5f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0a5f				  -	      ERR
      6  0a5f					      ENDIF
      7  0a5f
      8  0a5f					      IF	.CYCLES & 1
      9  0a5f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0a5f		       04 00		      nop	0
     11  0a61				  -	      ELSE
     12  0a61				  -	      bit	VSYNC
     13  0a61					      ENDIF
     14  0a61				   .CYCLES    SET	.CYCLES - 3
     15  0a61					      ENDIF
     16  0a61
     17  0a61				  -	      REPEAT	.CYCLES / 2
     18  0a61				  -	      nop
     19  0a61					      REPEND
    226  0a61
    227  0a61		       b9 48 f0 	      lda	ChessBitmap3,y	; 4
    228  0a64		       85 4d		      sta	PF0	; 3
    229  0a66		       b9 60 f0 	      lda	ChessBitmap4,y	; 4
    230  0a69		       85 4e		      sta	PF1	; 3
    231  0a6b		       b9 78 f0 	      lda	ChessBitmap5,y	; 4
    232  0a6e		       85 4f		      sta	PF2	; 3 @57
    233  0a70
      0  0a70					      SLEEP	5
      1  0a70				   .CYCLES    SET	5
      2  0a70
      3  0a70				  -	      IF	.CYCLES < 2
      4  0a70				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0a70				  -	      ERR
      6  0a70					      ENDIF
      7  0a70
      8  0a70					      IF	.CYCLES & 1
      9  0a70					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0a70		       04 00		      nop	0
     11  0a72				  -	      ELSE
     12  0a72				  -	      bit	VSYNC
     13  0a72					      ENDIF
     14  0a72				   .CYCLES    SET	.CYCLES - 3
     15  0a72					      ENDIF
     16  0a72
     17  0a72					      REPEAT	.CYCLES / 2
     18  0a72		       ea		      nop
     19  0a73					      REPEND
    235  0a73
    236  0a73		       b9 a0 f0    SMSPRITE8_0 lda	SpriteBuffer+8,y	; 4
    237  0a76		       85 5b		      sta	GRP0	; 3
    238  0a78		       b9 a0 f0    SMSPRITE8_1 lda	SpriteBuffer2+8,y	; 4
    239  0a7b		       85 5c		      sta	GRP1	; 3
    240  0a7d
    241  0a7d							;@0
    242  0a7d		       a9 2a		      lda	#COLOUR_LINE_3	;#$28			  ; 2
    243  0a7f		       85 48		      sta	COLUPF	; 3 @5
    244  0a81
    245  0a81		       b9 08 f0 	      lda	ChessBitmap0+8,y	; 4
    246  0a84		       85 4d		      sta	PF0	; 3
    247  0a86		       b9 20 f0 	      lda	ChessBitmap1+8,y	; 4
    248  0a89		       85 4e		      sta	PF1	; 3
    249  0a8b		       b9 38 f0 	      lda	ChessBitmap2+8,y	; 4
    250  0a8e		       85 4f		      sta	PF2	; 3 @26
    251  0a90
      0  0a90					      SLEEP	8	; 6 @34
      1  0a90				   .CYCLES    SET	8
      2  0a90
      3  0a90				  -	      IF	.CYCLES < 2
      4  0a90				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0a90				  -	      ERR
      6  0a90					      ENDIF
      7  0a90
      8  0a90				  -	      IF	.CYCLES & 1
      9  0a90				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0a90				  -	      nop	0
     11  0a90				  -	      ELSE
     12  0a90				  -	      bit	VSYNC
     13  0a90				  -	      ENDIF
     14  0a90				  -.CYCLES    SET	.CYCLES - 3
     15  0a90					      ENDIF
     16  0a90
     17  0a90					      REPEAT	.CYCLES / 2
     18  0a90		       ea		      nop
     17  0a90					      REPEND
     18  0a91		       ea		      nop
     17  0a91					      REPEND
     18  0a92		       ea		      nop
     17  0a92					      REPEND
     18  0a93		       ea		      nop
     19  0a94					      REPEND
    253  0a94
    254  0a94		       b9 50 f0 	      lda	ChessBitmap3+8,y	; 4
    255  0a97		       85 4d		      sta	PF0	; 3
    256  0a99		       b9 68 f0 	      lda	ChessBitmap4+8,y	; 4
    257  0a9c		       85 4e		      sta	PF1	; 3
    258  0a9e		       b9 80 f0 	      lda	ChessBitmap5+8,y	; 4
    259  0aa1		       85 4f		      sta	PF2	; 3 @55
    260  0aa3
    261  0aa3		       4c 07 f2 	      jmp	.l3	; 3 @58
    262  0aa6
    263  0aa6
    264  0aa6							;---------------------------------------------------------------------------------------------------
    265  0aa6
      0  0aa6					      DEF	WriteBlank
      1  0aa6				   BANK_WriteBlank SET	_CURRENT_BANK
      2  0aa6				   WriteBlank
      3  0aa6				   TEMPORARY_VAR SET	Overlay
      4  0aa6				   TEMPORARY_OFFSET SET	0
      5  0aa6				   VAR_BOUNDARY_WriteBlank SET	TEMPORARY_OFFSET
      6  0aa6				   FUNCTION_NAME SET	WriteBlank
      7  0aa6					      SUBROUTINE
    267  0aa6					      SUBROUTINE
    268  0aa6
      0  0aa6					      REFER	Reset
      1  0aa6				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  0aa6				  -TEMPORARY_VAR SET	VAREND_Reset
      3  0aa6					      ENDIF
      0  0aa6					      VEND	WriteBlank
      1  0aa6				  -	      IFNCONST	WriteBlank
      2  0aa6				  -	      ECHO	"Incorrect VEND label", WriteBlank
      3  0aa6				  -	      ERR
      4  0aa6					      ENDIF
      5  0aa6		       00 a2	   VAREND_WriteBlank =	TEMPORARY_VAR
    271  0aa6
    272  0aa6		       a9 90		      lda	#<BlankSprite
      0  0aa8					      sta@RAM	SMSPRITE0_0+1
      1  0aa8		       8d 43 f6 	      sta	[RAM]+SMSPRITE0_0+1
      0  0aab					      sta@RAM	SMSPRITE8_0+1
      1  0aab		       8d 74 f6 	      sta	[RAM]+SMSPRITE8_0+1
      0  0aae					      sta@RAM	SMSPRITE16_0+1
      1  0aae		       8d 08 f6 	      sta	[RAM]+SMSPRITE16_0+1
      0  0ab1					      sta@RAM	SMSPRITE0_1+1
      1  0ab1		       8d 48 f6 	      sta	[RAM]+SMSPRITE0_1+1
      0  0ab4					      sta@RAM	SMSPRITE8_1+1
      1  0ab4		       8d 79 f6 	      sta	[RAM]+SMSPRITE8_1+1
      0  0ab7					      sta@RAM	SMSPRITE16_1+1
      1  0ab7		       8d 0d f6 	      sta	[RAM]+SMSPRITE16_1+1
    279  0aba
    280  0aba		       a9 f0		      lda	#>BlankSprite
      0  0abc					      sta@RAM	SMSPRITE0_0+2
      1  0abc		       8d 44 f6 	      sta	[RAM]+SMSPRITE0_0+2
      0  0abf					      sta@RAM	SMSPRITE8_0+2
      1  0abf		       8d 75 f6 	      sta	[RAM]+SMSPRITE8_0+2
      0  0ac2					      sta@RAM	SMSPRITE16_0+2
      1  0ac2		       8d 09 f6 	      sta	[RAM]+SMSPRITE16_0+2
      0  0ac5					      sta@RAM	SMSPRITE0_1+2
      1  0ac5		       8d 49 f6 	      sta	[RAM]+SMSPRITE0_1+2
      0  0ac8					      sta@RAM	SMSPRITE8_1+2
      1  0ac8		       8d 7a f6 	      sta	[RAM]+SMSPRITE8_1+2
      0  0acb					      sta@RAM	SMSPRITE16_1+2
      1  0acb		       8d 0e f6 	      sta	[RAM]+SMSPRITE16_1+2
    287  0ace
    288  0ace		       60		      rts
    289  0acf
    290  0acf
    291  0acf							;---------------------------------------------------------------------------------------------------
    292  0acf
      0  0acf					      DEF	WriteCursor
      1  0acf				   BANK_WriteCursor SET	_CURRENT_BANK
      2  0acf				   WriteCursor
      3  0acf				   TEMPORARY_VAR SET	Overlay
      4  0acf				   TEMPORARY_OFFSET SET	0
      5  0acf				   VAR_BOUNDARY_WriteCursor SET	TEMPORARY_OFFSET
      6  0acf				   FUNCTION_NAME SET	WriteCursor
      7  0acf					      SUBROUTINE
    294  0acf					      SUBROUTINE
    295  0acf
      0  0acf					      REFER	Reset
      1  0acf				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  0acf				  -TEMPORARY_VAR SET	VAREND_Reset
      3  0acf					      ENDIF
      0  0acf					      VEND	WriteCursor
      1  0acf				  -	      IFNCONST	WriteCursor
      2  0acf				  -	      ECHO	"Incorrect VEND label", WriteCursor
      3  0acf				  -	      ERR
      4  0acf					      ENDIF
      5  0acf		       00 a2	   VAREND_WriteCursor =	TEMPORARY_VAR
    298  0acf
    299  0acf		       38		      sec
    300  0ad0		       a5 88		      lda	cursorX12
    301  0ad2		       30 1f		      bmi	.exit
    302  0ad4		       a2 0a		      ldx	#10
    303  0ad6		       e9 0a	   .sub10     sbc	#10
    304  0ad8		       ca		      dex
    305  0ad9		       b0 fb		      bcs	.sub10
    306  0adb
    307  0adb		       86 3e		      stx	SET_BANK_RAM
    308  0add		       a9 98		      lda	#<SpriteBuffer
      0  0adf					      sta@RAM	SMSPRITE0_0+1
      1  0adf		       8d 43 f6 	      sta	[RAM]+SMSPRITE0_0+1
      0  0ae2					      sta@RAM	SMSPRITE8_0+1
      1  0ae2		       8d 74 f6 	      sta	[RAM]+SMSPRITE8_0+1
      0  0ae5					      sta@RAM	SMSPRITE16_0+1
      1  0ae5		       8d 08 f6 	      sta	[RAM]+SMSPRITE16_0+1
    312  0ae8		       a9 f0		      lda	#>SpriteBuffer
      0  0aea					      sta@RAM	SMSPRITE0_0+2
      1  0aea		       8d 44 f6 	      sta	[RAM]+SMSPRITE0_0+2
      0  0aed					      sta@RAM	SMSPRITE8_0+2
      1  0aed		       8d 75 f6 	      sta	[RAM]+SMSPRITE8_0+2
      0  0af0					      sta@RAM	SMSPRITE16_0+2
      1  0af0		       8d 09 f6 	      sta	[RAM]+SMSPRITE16_0+2
    316  0af3
    317  0af3		       60	   .exit      rts
    318  0af4
    319  0af4
    320  0af4							;---------------------------------------------------------------------------------------------------
    321  0af4
      0  0af4					      DEF	SaveBitmap
      1  0af4				   BANK_SaveBitmap SET	_CURRENT_BANK
      2  0af4				   SaveBitmap
      3  0af4				   TEMPORARY_VAR SET	Overlay
      4  0af4				   TEMPORARY_OFFSET SET	0
      5  0af4				   VAR_BOUNDARY_SaveBitmap SET	TEMPORARY_OFFSET
      6  0af4				   FUNCTION_NAME SET	SaveBitmap
      7  0af4					      SUBROUTINE
    323  0af4					      SUBROUTINE
    324  0af4
      0  0af4					      REFER	SAFE_BackupBitmaps
      1  0af4				  -	      IF	VAREND_SAFE_BackupBitmaps > TEMPORARY_VAR
      2  0af4				  -TEMPORARY_VAR SET	VAREND_SAFE_BackupBitmaps
      3  0af4					      ENDIF
      0  0af4					      VEND	SaveBitmap
      1  0af4				  -	      IFNCONST	SaveBitmap
      2  0af4				  -	      ECHO	"Incorrect VEND label", SaveBitmap
      3  0af4				  -	      ERR
      4  0af4					      ENDIF
      5  0af4		       00 a2	   VAREND_SaveBitmap =	TEMPORARY_VAR
    327  0af4
    328  0af4		       a0 47		      ldy	#71
    329  0af6		       b9 00 f0    .fromTo    lda	ChessBitmap,y
      0  0af9					      sta@RAM	BackupBitmap,y
      1  0af9		       99 00 f5 	      sta	[RAM]+BackupBitmap,y
    331  0afc		       b9 48 f0 	      lda	ChessBitmap+72,y
      0  0aff					      sta@RAM	BackupBitmap+72,y
      1  0aff		       99 48 f5 	      sta	[RAM]+BackupBitmap+72,y
    333  0b02		       88		      dey
    334  0b03		       10 f1		      bpl	.fromTo
    335  0b05		       60		      rts
    336  0b06
    337  0b06
    338  0b06							;---------------------------------------------------------------------------------------------------
    339  0b06
    340  0b06				  -	      if	0
    341  0b06				  -	      DEF	RestoreBitmap
    342  0b06				  -	      SUBROUTINE
    343  0b06				  -
    344  0b06				  -	      VEND	RestoreBitmap
    345  0b06				  -
    346  0b06				  -	      ldy	#71
    347  0b06				  -.fromTo    lda	BackupBitmap,y
    348  0b06				  -	      sta@RAM	ChessBitmap,y
    349  0b06				  -	      lda	BackupBitmap+72,y
    350  0b06				  -	      sta@RAM	ChessBitmap+72,y
    351  0b06				  -	      dey
    352  0b06				  -	      bpl	.fromTo
    353  0b06				  -	      rts
    354  0b06					      endif
    355  0b06
    356  0b06							;---------------------------------------------------------------------------------------------------
    357  0b06
    358  0b06				  -	      if	0
    359  0b06				  -	      DEF	CopyTextToRowBitmap
    360  0b06				  -	      SUBROUTINE
    361  0b06				  -
    362  0b06				  -	      VEND	CopyTextToRowBitmap
    363  0b06				  -
    364  0b06				  -			; An OR-draw, used for placing matricies/text onscreen
    365  0b06				  -			; Similar to the EOR - first copy data into __pieceShapeBuffer, then call this function
    366  0b06				  -			; The draw can be bracketed by "SaveBitmap" and "RestoreBitmap" to leave screen
    367  0b06				  -			; in original state once text disappears
    368  0b06				  -
    369  0b06				  -	      ldy	#71
    370  0b06				  -	      bcs	.rightSide
    371  0b06				  -
    372  0b06				  -.copy      lda	__pieceShapeBuffer,y
    373  0b06				  -	      ora	ChessBitmap,y
    374  0b06				  -	      sta@RAM	ChessBitmap,y
    375  0b06				  -	      dey
    376  0b06				  -	      bpl	.copy
    377  0b06				  -
    378  0b06				  -	      rts
    379  0b06				  -
    380  0b06				  -.rightSide
    381  0b06				  -
    382  0b06				  -	      SUBROUTINE
    383  0b06				  -
    384  0b06				  -.copy      lda	__pieceShapeBuffer,y
    385  0b06				  -	      ora	ChessBitmap+72,y
    386  0b06				  -	      sta@RAM	ChessBitmap+72,y
    387  0b06				  -	      dey
    388  0b06				  -	      bpl	.copy
    389  0b06				  -
    390  0b06				  -	      rts
    391  0b06				  -
    392  0b06					      endif
    393  0b06
    394  0b06							;---------------------------------------------------------------------------------------------------
    395  0b06
      0  0b06					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_SCREEN"
      1  0b06
      2  0b06
      3  0b06		       03 06	   .TEMP      =	* - BANK_START
 ROM_SHADOW_SCREEN (1K) SIZE =  $306 , FREE= $fa
      4  0b06					      ECHO	"ROM_SHADOW_SCREEN", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0b06				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  0b06				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0b06				  -	      ERR
      8  0b06					      endif
    397  0b06							;VALIDATE_RAM_SIZE
------- FILE ./chess.asm
------- FILE BANK_CHESS_INCLUDES.asm LEVEL 2 PASS 5
      0  0b06					      include	"BANK_CHESS_INCLUDES.asm"
      1  0b06							; Copyright (c) 2019-2020 Andrew Davie
      2  0b06							; andrew@taswegian.com
      3  0b06
      4  0b06
      5  0b06							; Each piece is defined as 3 PF bytes (horizontal) x 24 scanlines (vertical)
      6  0b06							; The pieces are converted by ConvertChessPieces.py (in tools), which takes
      7  0b06							; a single gif of the format..
      8  0b06							; a row of white pieces on black squares
      9  0b06							; a row of white pieces on white squares
     10  0b06							; a row of black pieces on black squares
     11  0b06							; a row of black pieces on white squares
     12  0b06
     13  0b06							; each row has the pieces ordered thus:
     14  0b06							; a blank, then pawn, knight, bishop, rook, queen, king
     15  0b06							; each piece is 5 pixels wide x 8 pixels deep
     16  0b06							; each pixel is from an 8-colour palette.
     17  0b06							; Given a pixel colour 0-7 (represented in binary 000 - 111) then if the bits
     18  0b06							; for the colour are abc (i.e., colour #3 = binary 011 = bits 0bc)
     19  0b06							; then bit "a" becomes the first interleaved chronocolour pixel (line 1)
     20  0b06							; bit "b" becomes the second ICC pixel line (2)
     21  0b06							; bit "c" becomes the third ICC pixel line (3)
     22  0b06							; Thus, a 5 pxel x 8 pixel shape becomes 24 lines deep
     23  0b06							; The tool produces 4 variants of the piece; shifted into the 4 squares
     24  0b06							; in the PF - thus, at pixel 0, pixel 5, pixel 10, pixel 15.
     25  0b06							; These 4 shifted positions are stored consecutively in the shape definition
     26  0b06
     27  0b06							; Example...
     28  0b06							;DEF WHITE_BISHOP_on_BLACK_SQUARE_0
     29  0b06							;.byte $00,$40,$40,$40,$00,$00,$e0,$e0,$e0,$d0,$d0,$d0,$b0,$b0,$b0,$f0,$f0,$f0,$e0,$60,$e0,$f0,$f0,$f0 ;PF0
     30  0b06							;.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$00,$80,$80,$00,$80,$80,$00,$80,$00,$00,$00,$00,$80,$00 ;PF1
     31  0b06							;.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00 ;PF2
     32  0b06
     33  0b06							; The above defines the three 24-byte vertical strips for the 3 PF bytes that
     34  0b06							; the piece (could) overlay. In this case, on square 0 (leftmost), it doesn't
     35  0b06							; actually have any data in PF1 or PF2.
     36  0b06
------- FILE piece_graphics.asm LEVEL 3 PASS 5
      0  0b06					      include	"piece_graphics.asm"
      1  0b06							; Import the graphics definitions generated by ConvertChessPieces.py
      0  0b06					      NEWBANK	PIECES_0
      1  17d8 ????				      SEG	PIECES_0
      2  1000					      ORG	ORIGIN
      3  1000					      RORG	$F000
      4  1000				   BANK_START SET	*
      5  1000				   PIECES_0   SET	ORIGIN / 2048
      6  1000				   ORIGIN     SET	ORIGIN + 2048
      7  1000				   _CURRENT_BANK SET	PIECES_0
      3  1000
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1000					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm"
      0  1000					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_0", 72
     12  1000					      LIST	ON
      0  1000					      DEF	WHITE_BLANK_on_WHITE_SQUARE_0
      1  1000				   BANK_WHITE_BLANK_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1000				   WHITE_BLANK_on_WHITE_SQUARE_0
      3  1000				   TEMPORARY_VAR SET	Overlay
      4  1000				   TEMPORARY_OFFSET SET	0
      5  1000				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1000				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_0
      7  1000					      SUBROUTINE
      3  1000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  1018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  1030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1048					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm"
      0  1048					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_1", 72
     12  1048					      LIST	ON
      0  1048					      DEF	WHITE_BLANK_on_WHITE_SQUARE_1
      1  1048				   BANK_WHITE_BLANK_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1048				   WHITE_BLANK_on_WHITE_SQUARE_1
      3  1048				   TEMPORARY_VAR SET	Overlay
      4  1048				   TEMPORARY_OFFSET SET	0
      5  1048				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1048				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_1
      7  1048					      SUBROUTINE
      3  1048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1060		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  1078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1090					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm"
      0  1090					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_2", 72
     12  1090					      LIST	ON
      0  1090					      DEF	WHITE_BLANK_on_WHITE_SQUARE_2
      1  1090				   BANK_WHITE_BLANK_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1090				   WHITE_BLANK_on_WHITE_SQUARE_2
      3  1090				   TEMPORARY_VAR SET	Overlay
      4  1090				   TEMPORARY_OFFSET SET	0
      5  1090				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1090				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_2
      7  1090					      SUBROUTINE
      3  1090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  10a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  10c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  10d8					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm"
      0  10d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_3", 72
     12  1100					      LIST	ON
      0  1100					      DEF	WHITE_BLANK_on_WHITE_SQUARE_3
      1  1100				   BANK_WHITE_BLANK_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1100				   WHITE_BLANK_on_WHITE_SQUARE_3
      3  1100				   TEMPORARY_VAR SET	Overlay
      4  1100				   TEMPORARY_OFFSET SET	0
      5  1100				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1100				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_3
      7  1100					      SUBROUTINE
      3  1100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1130		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1148					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm"
      0  1148					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_0", 72
     12  1148					      LIST	ON
      0  1148					      DEF	WHITE_PAWN_on_WHITE_SQUARE_0
      1  1148				   BANK_WHITE_PAWN_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1148				   WHITE_PAWN_on_WHITE_SQUARE_0
      3  1148				   TEMPORARY_VAR SET	Overlay
      4  1148				   TEMPORARY_OFFSET SET	0
      5  1148				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1148				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_0
      7  1148					      SUBROUTINE
      3  1148		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1160		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1190					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm"
      0  1190					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_1", 72
     12  1190					      LIST	ON
      0  1190					      DEF	WHITE_PAWN_on_WHITE_SQUARE_1
      1  1190				   BANK_WHITE_PAWN_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1190				   WHITE_PAWN_on_WHITE_SQUARE_1
      3  1190				   TEMPORARY_VAR SET	Overlay
      4  1190				   TEMPORARY_OFFSET SET	0
      5  1190				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1190				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_1
      7  1190					      SUBROUTINE
      3  1190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  11a8		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  11c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  11d8					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm"
      0  11d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_2", 72
     12  1200					      LIST	ON
      0  1200					      DEF	WHITE_PAWN_on_WHITE_SQUARE_2
      1  1200				   BANK_WHITE_PAWN_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1200				   WHITE_PAWN_on_WHITE_SQUARE_2
      3  1200				   TEMPORARY_VAR SET	Overlay
      4  1200				   TEMPORARY_OFFSET SET	0
      5  1200				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1200				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_2
      7  1200					      SUBROUTINE
      3  1200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1218		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1230		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  1248					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm"
      0  1248					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_3", 72
     12  1248					      LIST	ON
      0  1248					      DEF	WHITE_PAWN_on_WHITE_SQUARE_3
      1  1248				   BANK_WHITE_PAWN_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1248				   WHITE_PAWN_on_WHITE_SQUARE_3
      3  1248				   TEMPORARY_VAR SET	Overlay
      4  1248				   TEMPORARY_OFFSET SET	0
      5  1248				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1248				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_3
      7  1248					      SUBROUTINE
      3  1248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1278		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1290					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  1290					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_0", 72
     12  1290					      LIST	ON
      0  1290					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_0
      1  1290				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1290				   WHITE_KNIGHT_on_WHITE_SQUARE_0
      3  1290				   TEMPORARY_VAR SET	Overlay
      4  1290				   TEMPORARY_OFFSET SET	0
      5  1290				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1290				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_0
      7  1290					      SUBROUTINE
      3  1290		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  12a8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  12c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  12d8					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  12d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_1", 72
     12  1300					      LIST	ON
      0  1300					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_1
      1  1300				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1300				   WHITE_KNIGHT_on_WHITE_SQUARE_1
      3  1300				   TEMPORARY_VAR SET	Overlay
      4  1300				   TEMPORARY_OFFSET SET	0
      5  1300				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1300				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_1
      7  1300					      SUBROUTINE
      3  1300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1318		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1348					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  1348					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_2", 72
     12  1348					      LIST	ON
      0  1348					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_2
      1  1348				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1348				   WHITE_KNIGHT_on_WHITE_SQUARE_2
      3  1348				   TEMPORARY_VAR SET	Overlay
      4  1348				   TEMPORARY_OFFSET SET	0
      5  1348				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1348				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_2
      7  1348					      SUBROUTINE
      3  1348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1360		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1378		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  1390					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  1390					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_3", 72
     12  1390					      LIST	ON
      0  1390					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_3
      1  1390				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1390				   WHITE_KNIGHT_on_WHITE_SQUARE_3
      3  1390				   TEMPORARY_VAR SET	Overlay
      4  1390				   TEMPORARY_OFFSET SET	0
      5  1390				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1390				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_3
      7  1390					      SUBROUTINE
      3  1390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  13a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  13c0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  13d8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm"
      0  13d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_0", 72
     12  1400					      LIST	ON
      0  1400					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_0
      1  1400				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1400				   WHITE_BISHOP_on_WHITE_SQUARE_0
      3  1400				   TEMPORARY_VAR SET	Overlay
      4  1400				   TEMPORARY_OFFSET SET	0
      5  1400				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1400				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_0
      7  1400					      SUBROUTINE
      3  1400		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$40,$20,$00,$00,$00	;PF0
      4  1418		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1448					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm"
      0  1448					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_1", 72
     12  1448					      LIST	ON
      0  1448					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_1
      1  1448				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1448				   WHITE_BISHOP_on_WHITE_SQUARE_1
      3  1448				   TEMPORARY_VAR SET	Overlay
      4  1448				   TEMPORARY_OFFSET SET	0
      5  1448				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1448				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_1
      7  1448					      SUBROUTINE
      3  1448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1460		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$10,$20,$00,$00,$00	;PF1
      5  1478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1490					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm"
      0  1490					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_2", 72
     12  1490					      LIST	ON
      0  1490					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_2
      1  1490				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1490				   WHITE_BISHOP_on_WHITE_SQUARE_2
      3  1490				   TEMPORARY_VAR SET	Overlay
      4  1490				   TEMPORARY_OFFSET SET	0
      5  1490				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1490				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_2
      7  1490					      SUBROUTINE
      3  1490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  14a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$01,$00,$00,$00	;PF1
      5  14c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$01,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  14d8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm"
      0  14d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_3", 72
     12  1500					      LIST	ON
      0  1500					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_3
      1  1500				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1500				   WHITE_BISHOP_on_WHITE_SQUARE_3
      3  1500				   TEMPORARY_VAR SET	Overlay
      4  1500				   TEMPORARY_OFFSET SET	0
      5  1500				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1500				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_3
      7  1500					      SUBROUTINE
      3  1500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1530		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$20,$10,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1548					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm"
      0  1548					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_0", 72
     12  1548					      LIST	ON
      0  1548					      DEF	WHITE_ROOK_on_WHITE_SQUARE_0
      1  1548				   BANK_WHITE_ROOK_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1548				   WHITE_ROOK_on_WHITE_SQUARE_0
      3  1548				   TEMPORARY_VAR SET	Overlay
      4  1548				   TEMPORARY_OFFSET SET	0
      5  1548				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1548				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_0
      7  1548					      SUBROUTINE
      3  1548		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1560		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1590					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm"
      0  1590					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_1", 72
     12  1590					      LIST	ON
      0  1590					      DEF	WHITE_ROOK_on_WHITE_SQUARE_1
      1  1590				   BANK_WHITE_ROOK_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1590				   WHITE_ROOK_on_WHITE_SQUARE_1
      3  1590				   TEMPORARY_VAR SET	Overlay
      4  1590				   TEMPORARY_OFFSET SET	0
      5  1590				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1590				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_1
      7  1590					      SUBROUTINE
      3  1590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  15a8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  15c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  15d8					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm"
      0  15d8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_2", 72
     12  1600					      LIST	ON
      0  1600					      DEF	WHITE_ROOK_on_WHITE_SQUARE_2
      1  1600				   BANK_WHITE_ROOK_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1600				   WHITE_ROOK_on_WHITE_SQUARE_2
      3  1600				   TEMPORARY_VAR SET	Overlay
      4  1600				   TEMPORARY_OFFSET SET	0
      5  1600				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1600				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_2
      7  1600					      SUBROUTINE
      3  1600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1618		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1630		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  1648					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm"
      0  1648					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_3", 72
     12  1648					      LIST	ON
      0  1648					      DEF	WHITE_ROOK_on_WHITE_SQUARE_3
      1  1648				   BANK_WHITE_ROOK_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1648				   WHITE_ROOK_on_WHITE_SQUARE_3
      3  1648				   TEMPORARY_VAR SET	Overlay
      4  1648				   TEMPORARY_OFFSET SET	0
      5  1648				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1648				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_3
      7  1648					      SUBROUTINE
      3  1648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1678		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1690					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm"
      0  1690					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_0", 72
     12  1690					      LIST	ON
      0  1690					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_0
      1  1690				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1690				   WHITE_QUEEN_on_WHITE_SQUARE_0
      3  1690				   TEMPORARY_VAR SET	Overlay
      4  1690				   TEMPORARY_OFFSET SET	0
      5  1690				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1690				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_0
      7  1690					      SUBROUTINE
      3  1690		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  16a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  16c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  16d8					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm"
      0  16d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_1", 72
     12  1700					      LIST	ON
      0  1700					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_1
      1  1700				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1700				   WHITE_QUEEN_on_WHITE_SQUARE_1
      3  1700				   TEMPORARY_VAR SET	Overlay
      4  1700				   TEMPORARY_OFFSET SET	0
      5  1700				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1700				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_1
      7  1700					      SUBROUTINE
      3  1700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1718		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1748					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm"
      0  1748					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_2", 72
     12  1748					      LIST	ON
      0  1748					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_2
      1  1748				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1748				   WHITE_QUEEN_on_WHITE_SQUARE_2
      3  1748				   TEMPORARY_VAR SET	Overlay
      4  1748				   TEMPORARY_OFFSET SET	0
      5  1748				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1748				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_2
      7  1748					      SUBROUTINE
      3  1748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1760		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1778		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  1790					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm"
      0  1790					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_3", 72
     12  1790					      LIST	ON
      0  1790					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_3
      1  1790				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1790				   WHITE_QUEEN_on_WHITE_SQUARE_3
      3  1790				   TEMPORARY_VAR SET	Overlay
      4  1790				   TEMPORARY_OFFSET SET	0
      5  1790				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1790				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_3
      7  1790					      SUBROUTINE
      3  1790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  17a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  17c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  17d8					      CHECK_BANK_SIZE	"PIECE_0 (2K)"
      1  17d8		       07 d8	   .TEMP      =	* - BANK_START
 PIECE_0 (2K) (2K) SIZE =  $7d8 , FREE= $28
      2  17d8					      ECHO	"PIECE_0 (2K)", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  17d8				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  17d8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  17d8				  -	      ERR
      6  17d8					      endif
      0  17d8					      NEWBANK	PIECES_1
      1  1fd8 ????				      SEG	PIECES_1
      2  1800					      ORG	ORIGIN
      3  1800					      RORG	$F000
      4  1800				   BANK_START SET	*
      5  1800				   PIECES_1   SET	ORIGIN / 2048
      6  1800				   ORIGIN     SET	ORIGIN + 2048
      7  1800				   _CURRENT_BANK SET	PIECES_1
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1800					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_0.asm"
      0  1800					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_0", 72
     12  1800					      LIST	ON
      0  1800					      DEF	WHITE_KING_on_WHITE_SQUARE_0
      1  1800				   BANK_WHITE_KING_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1800				   WHITE_KING_on_WHITE_SQUARE_0
      3  1800				   TEMPORARY_VAR SET	Overlay
      4  1800				   TEMPORARY_OFFSET SET	0
      5  1800				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1800				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_0
      7  1800					      SUBROUTINE
      3  1800		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$a0,$80,$40,$00,$00	;PF0
      4  1818		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1848					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_1.asm"
      0  1848					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_1", 72
     12  1848					      LIST	ON
      0  1848					      DEF	WHITE_KING_on_WHITE_SQUARE_1
      1  1848				   BANK_WHITE_KING_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1848				   WHITE_KING_on_WHITE_SQUARE_1
      3  1848				   TEMPORARY_VAR SET	Overlay
      4  1848				   TEMPORARY_OFFSET SET	0
      5  1848				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1848				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_1
      7  1848					      SUBROUTINE
      3  1848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1860		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$28,$08,$10,$00,$00	;PF1
      5  1878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1890					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_2.asm"
      0  1890					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_2", 72
     12  1890					      LIST	ON
      0  1890					      DEF	WHITE_KING_on_WHITE_SQUARE_2
      1  1890				   BANK_WHITE_KING_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1890				   WHITE_KING_on_WHITE_SQUARE_2
      3  1890				   TEMPORARY_VAR SET	Overlay
      4  1890				   TEMPORARY_OFFSET SET	0
      5  1890				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1890				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_2
      7  1890					      SUBROUTINE
      3  1890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  18a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$01,$00,$00,$00,$00	;PF1
      5  18c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$02,$02,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  18d8					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_3.asm"
      0  18d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_3", 72
     12  1900					      LIST	ON
      0  1900					      DEF	WHITE_KING_on_WHITE_SQUARE_3
      1  1900				   BANK_WHITE_KING_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1900				   WHITE_KING_on_WHITE_SQUARE_3
      3  1900				   TEMPORARY_VAR SET	Overlay
      4  1900				   TEMPORARY_OFFSET SET	0
      5  1900				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1900				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_3
      7  1900					      SUBROUTINE
      3  1900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1930		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$50,$40,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  1948					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm"
      0  1948					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_0", 72
     12  1948					      LIST	ON
      0  1948					      DEF	WHITE_BLANK_on_BLACK_SQUARE_0
      1  1948				   BANK_WHITE_BLANK_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  1948				   WHITE_BLANK_on_BLACK_SQUARE_0
      3  1948				   TEMPORARY_VAR SET	Overlay
      4  1948				   TEMPORARY_OFFSET SET	0
      5  1948				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1948				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_0
      7  1948					      SUBROUTINE
      3  1948		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  1990					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm"
      0  1990					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_1", 72
     12  1990					      LIST	ON
      0  1990					      DEF	WHITE_BLANK_on_BLACK_SQUARE_1
      1  1990				   BANK_WHITE_BLANK_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  1990				   WHITE_BLANK_on_BLACK_SQUARE_1
      3  1990				   TEMPORARY_VAR SET	Overlay
      4  1990				   TEMPORARY_OFFSET SET	0
      5  1990				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1990				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_1
      7  1990					      SUBROUTINE
      3  1990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  19a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  19c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  19d8					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm"
      0  19d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_2", 72
     12  1a00					      LIST	ON
      0  1a00					      DEF	WHITE_BLANK_on_BLACK_SQUARE_2
      1  1a00				   BANK_WHITE_BLANK_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  1a00				   WHITE_BLANK_on_BLACK_SQUARE_2
      3  1a00				   TEMPORARY_VAR SET	Overlay
      4  1a00				   TEMPORARY_OFFSET SET	0
      5  1a00				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1a00				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_2
      7  1a00					      SUBROUTINE
      3  1a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1a18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1a30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  1a48					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm"
      0  1a48					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_3", 72
     12  1a48					      LIST	ON
      0  1a48					      DEF	WHITE_BLANK_on_BLACK_SQUARE_3
      1  1a48				   BANK_WHITE_BLANK_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  1a48				   WHITE_BLANK_on_BLACK_SQUARE_3
      3  1a48				   TEMPORARY_VAR SET	Overlay
      4  1a48				   TEMPORARY_OFFSET SET	0
      5  1a48				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1a48				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_3
      7  1a48					      SUBROUTINE
      3  1a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1a78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  1a90					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm"
      0  1a90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_0", 72
     12  1a90					      LIST	ON
      0  1a90					      DEF	WHITE_PAWN_on_BLACK_SQUARE_0
      1  1a90				   BANK_WHITE_PAWN_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  1a90				   WHITE_PAWN_on_BLACK_SQUARE_0
      3  1a90				   TEMPORARY_VAR SET	Overlay
      4  1a90				   TEMPORARY_OFFSET SET	0
      5  1a90				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1a90				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_0
      7  1a90					      SUBROUTINE
      3  1a90		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  1aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  1ad8					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm"
      0  1ad8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_1", 72
     12  1b00					      LIST	ON
      0  1b00					      DEF	WHITE_PAWN_on_BLACK_SQUARE_1
      1  1b00				   BANK_WHITE_PAWN_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  1b00				   WHITE_PAWN_on_BLACK_SQUARE_1
      3  1b00				   TEMPORARY_VAR SET	Overlay
      4  1b00				   TEMPORARY_OFFSET SET	0
      5  1b00				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1b00				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_1
      7  1b00					      SUBROUTINE
      3  1b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1b18		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  1b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  1b48					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm"
      0  1b48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_2", 72
     12  1b48					      LIST	ON
      0  1b48					      DEF	WHITE_PAWN_on_BLACK_SQUARE_2
      1  1b48				   BANK_WHITE_PAWN_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  1b48				   WHITE_PAWN_on_BLACK_SQUARE_2
      3  1b48				   TEMPORARY_VAR SET	Overlay
      4  1b48				   TEMPORARY_OFFSET SET	0
      5  1b48				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1b48				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_2
      7  1b48					      SUBROUTINE
      3  1b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1b60		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  1b78		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  1b90					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm"
      0  1b90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_3", 72
     12  1b90					      LIST	ON
      0  1b90					      DEF	WHITE_PAWN_on_BLACK_SQUARE_3
      1  1b90				   BANK_WHITE_PAWN_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  1b90				   WHITE_PAWN_on_BLACK_SQUARE_3
      3  1b90				   TEMPORARY_VAR SET	Overlay
      4  1b90				   TEMPORARY_OFFSET SET	0
      5  1b90				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1b90				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_3
      7  1b90					      SUBROUTINE
      3  1b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1bc0		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  1bd8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  1bd8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_0", 72
     12  1c00					      LIST	ON
      0  1c00					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_0
      1  1c00				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  1c00				   WHITE_KNIGHT_on_BLACK_SQUARE_0
      3  1c00				   TEMPORARY_VAR SET	Overlay
      4  1c00				   TEMPORARY_OFFSET SET	0
      5  1c00				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1c00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_0
      7  1c00					      SUBROUTINE
      3  1c00		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$f0,$e0,$e0,$f0,$f0,$40,$00	;PF0
      4  1c18		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  1c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  1c48					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  1c48					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_1", 72
     12  1c48					      LIST	ON
      0  1c48					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_1
      1  1c48				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  1c48				   WHITE_KNIGHT_on_BLACK_SQUARE_1
      3  1c48				   TEMPORARY_VAR SET	Overlay
      4  1c48				   TEMPORARY_OFFSET SET	0
      5  1c48				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1c48				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_1
      7  1c48					      SUBROUTINE
      3  1c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1c60		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$78,$38,$3c,$7c,$7c,$14,$00	;PF1
      5  1c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  1c90					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  1c90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_2", 72
     12  1c90					      LIST	ON
      0  1c90					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_2
      1  1c90				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  1c90				   WHITE_KNIGHT_on_BLACK_SQUARE_2
      3  1c90				   TEMPORARY_VAR SET	Overlay
      4  1c90				   TEMPORARY_OFFSET SET	0
      5  1c90				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1c90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_2
      7  1c90					      SUBROUTINE
      3  1c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1ca8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$01,$03,$03,$00,$00	;PF1
      5  1cc0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$03,$03,$07,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  1cd8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  1cd8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_3", 72
     12  1d00					      LIST	ON
      0  1d00					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_3
      1  1d00				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  1d00				   WHITE_KNIGHT_on_BLACK_SQUARE_3
      3  1d00				   TEMPORARY_VAR SET	Overlay
      4  1d00				   TEMPORARY_OFFSET SET	0
      5  1d00				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1d00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_3
      7  1d00					      SUBROUTINE
      3  1d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1d30		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$78,$70,$f0,$f8,$f8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  1d48					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm"
      0  1d48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_0", 72
     12  1d48					      LIST	ON
      0  1d48					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_0
      1  1d48				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  1d48				   WHITE_BISHOP_on_BLACK_SQUARE_0
      3  1d48				   TEMPORARY_VAR SET	Overlay
      4  1d48				   TEMPORARY_OFFSET SET	0
      5  1d48				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1d48				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_0
      7  1d48					      SUBROUTINE
      3  1d48		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$b0,$d0,$e0,$40,$40	;PF0
      4  1d60		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  1d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  1d90					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm"
      0  1d90					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_1", 72
     12  1d90					      LIST	ON
      0  1d90					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_1
      1  1d90				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  1d90				   WHITE_BISHOP_on_BLACK_SQUARE_1
      3  1d90				   TEMPORARY_VAR SET	Overlay
      4  1d90				   TEMPORARY_OFFSET SET	0
      5  1d90				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1d90				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_1
      7  1d90					      SUBROUTINE
      3  1d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1da8		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$6c,$5c,$38,$10,$10	;PF1
      5  1dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  1dd8					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm"
      0  1dd8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_2", 72
     12  1e00					      LIST	ON
      0  1e00					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_2
      1  1e00				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  1e00				   WHITE_BISHOP_on_BLACK_SQUARE_2
      3  1e00				   TEMPORARY_VAR SET	Overlay
      4  1e00				   TEMPORARY_OFFSET SET	0
      5  1e00				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1e00				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_2
      7  1e00					      SUBROUTINE
      3  1e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1e18		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  1e30		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$06,$07,$03,$01,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  1e48					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm"
      0  1e48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_3", 72
     12  1e48					      LIST	ON
      0  1e48					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_3
      1  1e48				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  1e48				   WHITE_BISHOP_on_BLACK_SQUARE_3
      3  1e48				   TEMPORARY_VAR SET	Overlay
      4  1e48				   TEMPORARY_OFFSET SET	0
      5  1e48				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1e48				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_3
      7  1e48					      SUBROUTINE
      3  1e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1e78		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$d8,$e8,$70,$20,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  1e90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm"
      0  1e90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_0", 72
     12  1e90					      LIST	ON
      0  1e90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_0
      1  1e90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  1e90				   WHITE_ROOK_on_BLACK_SQUARE_0
      3  1e90				   TEMPORARY_VAR SET	Overlay
      4  1e90				   TEMPORARY_OFFSET SET	0
      5  1e90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1e90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_0
      7  1e90					      SUBROUTINE
      3  1e90		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$f0,$50,$00	;PF0
      4  1ea8		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  1ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  1ed8					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm"
      0  1ed8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_1", 72
     12  1f00					      LIST	ON
      0  1f00					      DEF	WHITE_ROOK_on_BLACK_SQUARE_1
      1  1f00				   BANK_WHITE_ROOK_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  1f00				   WHITE_ROOK_on_BLACK_SQUARE_1
      3  1f00				   TEMPORARY_VAR SET	Overlay
      4  1f00				   TEMPORARY_OFFSET SET	0
      5  1f00				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1f00				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_1
      7  1f00					      SUBROUTINE
      3  1f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1f18		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$7c,$54,$00	;PF1
      5  1f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  1f48					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm"
      0  1f48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_2", 72
     12  1f48					      LIST	ON
      0  1f48					      DEF	WHITE_ROOK_on_BLACK_SQUARE_2
      1  1f48				   BANK_WHITE_ROOK_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  1f48				   WHITE_ROOK_on_BLACK_SQUARE_2
      3  1f48				   TEMPORARY_VAR SET	Overlay
      4  1f48				   TEMPORARY_OFFSET SET	0
      5  1f48				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1f48				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_2
      7  1f48					      SUBROUTINE
      3  1f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1f60		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$03,$02,$00	;PF1
      5  1f78		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  1f90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm"
      0  1f90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_3", 72
     12  1f90					      LIST	ON
      0  1f90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_3
      1  1f90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  1f90				   WHITE_ROOK_on_BLACK_SQUARE_3
      3  1f90				   TEMPORARY_VAR SET	Overlay
      4  1f90				   TEMPORARY_OFFSET SET	0
      5  1f90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1f90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_3
      7  1f90					      SUBROUTINE
      3  1f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1fc0		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$f8,$a8,$00	;PF2
------- FILE piece_graphics.asm
      0  1fd8					      CHECK_BANK_SIZE	"PIECE_1 (2K)"
      1  1fd8		       07 d8	   .TEMP      =	* - BANK_START
 PIECE_1 (2K) (2K) SIZE =  $7d8 , FREE= $28
      2  1fd8					      ECHO	"PIECE_1 (2K)", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1fd8				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  1fd8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1fd8				  -	      ERR
      6  1fd8					      endif
      0  1fd8					      NEWBANK	PIECES_2
      1  27d8 ????				      SEG	PIECES_2
      2  2000					      ORG	ORIGIN
      3  2000					      RORG	$F000
      4  2000				   BANK_START SET	*
      5  2000				   PIECES_2   SET	ORIGIN / 2048
      6  2000				   ORIGIN     SET	ORIGIN + 2048
      7  2000				   _CURRENT_BANK SET	PIECES_2
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2000					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm"
      0  2000					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_0", 72
     12  2000					      LIST	ON
      0  2000					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_0
      1  2000				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2000				   WHITE_QUEEN_on_BLACK_SQUARE_0
      3  2000				   TEMPORARY_VAR SET	Overlay
      4  2000				   TEMPORARY_OFFSET SET	0
      5  2000				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2000				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_0
      7  2000					      SUBROUTINE
      3  2000		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  2018		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00,$80,$00	;PF1
      5  2030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2048					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm"
      0  2048					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_1", 72
     12  2048					      LIST	ON
      0  2048					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_1
      1  2048				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2048				   WHITE_QUEEN_on_BLACK_SQUARE_1
      3  2048				   TEMPORARY_VAR SET	Overlay
      4  2048				   TEMPORARY_OFFSET SET	0
      5  2048				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2048				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_1
      7  2048					      SUBROUTINE
      3  2048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2060		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$7c,$7c,$54,$00,$54,$00	;PF1
      5  2078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  2090					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm"
      0  2090					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_2", 72
     12  2090					      LIST	ON
      0  2090					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_2
      1  2090				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2090				   WHITE_QUEEN_on_BLACK_SQUARE_2
      3  2090				   TEMPORARY_VAR SET	Overlay
      4  2090				   TEMPORARY_OFFSET SET	0
      5  2090				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2090				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_2
      7  2090					      SUBROUTINE
      3  2090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  20a8		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  20c0		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$07,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  20d8					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm"
      0  20d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_3", 72
     12  2100					      LIST	ON
      0  2100					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_3
      1  2100				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2100				   WHITE_QUEEN_on_BLACK_SQUARE_3
      3  2100				   TEMPORARY_VAR SET	Overlay
      4  2100				   TEMPORARY_OFFSET SET	0
      5  2100				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2100				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_3
      7  2100					      SUBROUTINE
      3  2100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2130		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$f8,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2148					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_0.asm"
      0  2148					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_0", 72
     12  2148					      LIST	ON
      0  2148					      DEF	WHITE_KING_on_BLACK_SQUARE_0
      1  2148				   BANK_WHITE_KING_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2148				   WHITE_KING_on_BLACK_SQUARE_0
      3  2148				   TEMPORARY_VAR SET	Overlay
      4  2148				   TEMPORARY_OFFSET SET	0
      5  2148				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2148				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_0
      7  2148					      SUBROUTINE
      3  2148		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$f0,$50,$70,$b0,$e0,$40	;PF0
      4  2160		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$00,$00	;PF1
      5  2178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2190					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_1.asm"
      0  2190					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_1", 72
     12  2190					      LIST	ON
      0  2190					      DEF	WHITE_KING_on_BLACK_SQUARE_1
      1  2190				   BANK_WHITE_KING_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2190				   WHITE_KING_on_BLACK_SQUARE_1
      3  2190				   TEMPORARY_VAR SET	Overlay
      4  2190				   TEMPORARY_OFFSET SET	0
      5  2190				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2190				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_1
      7  2190					      SUBROUTINE
      3  2190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  21a8		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$7c,$54,$74,$6c,$38,$10	;PF1
      5  21c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  21d8					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_2.asm"
      0  21d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_2", 72
     12  2200					      LIST	ON
      0  2200					      DEF	WHITE_KING_on_BLACK_SQUARE_2
      1  2200				   BANK_WHITE_KING_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2200				   WHITE_KING_on_BLACK_SQUARE_2
      3  2200				   TEMPORARY_VAR SET	Overlay
      4  2200				   TEMPORARY_OFFSET SET	0
      5  2200				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2200				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_2
      7  2200					      SUBROUTINE
      3  2200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2218		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$03,$02,$03,$03,$01,$00	;PF1
      5  2230		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$07,$05,$05,$06,$03,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  2248					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_3.asm"
      0  2248					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_3", 72
     12  2248					      LIST	ON
      0  2248					      DEF	WHITE_KING_on_BLACK_SQUARE_3
      1  2248				   BANK_WHITE_KING_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2248				   WHITE_KING_on_BLACK_SQUARE_3
      3  2248				   TEMPORARY_VAR SET	Overlay
      4  2248				   TEMPORARY_OFFSET SET	0
      5  2248				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2248				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_3
      7  2248					      SUBROUTINE
      3  2248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2278		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$f8,$a8,$b8,$d8,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2290					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm"
      0  2290					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_0", 72
     12  2290					      LIST	ON
      0  2290					      DEF	BLACK_BLANK_on_WHITE_SQUARE_0
      1  2290				   BANK_BLACK_BLANK_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2290				   BLACK_BLANK_on_WHITE_SQUARE_0
      3  2290				   TEMPORARY_VAR SET	Overlay
      4  2290				   TEMPORARY_OFFSET SET	0
      5  2290				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2290				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_0
      7  2290					      SUBROUTINE
      3  2290		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  22a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  22c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  22d8					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm"
      0  22d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_1", 72
     12  2300					      LIST	ON
      0  2300					      DEF	BLACK_BLANK_on_WHITE_SQUARE_1
      1  2300				   BANK_BLACK_BLANK_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2300				   BLACK_BLANK_on_WHITE_SQUARE_1
      3  2300				   TEMPORARY_VAR SET	Overlay
      4  2300				   TEMPORARY_OFFSET SET	0
      5  2300				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2300				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_1
      7  2300					      SUBROUTINE
      3  2300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2318		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  2330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2348					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm"
      0  2348					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_2", 72
     12  2348					      LIST	ON
      0  2348					      DEF	BLACK_BLANK_on_WHITE_SQUARE_2
      1  2348				   BANK_BLACK_BLANK_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2348				   BLACK_BLANK_on_WHITE_SQUARE_2
      3  2348				   TEMPORARY_VAR SET	Overlay
      4  2348				   TEMPORARY_OFFSET SET	0
      5  2348				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2348				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_2
      7  2348					      SUBROUTINE
      3  2348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  2378		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  2390					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm"
      0  2390					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_3", 72
     12  2390					      LIST	ON
      0  2390					      DEF	BLACK_BLANK_on_WHITE_SQUARE_3
      1  2390				   BANK_BLACK_BLANK_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2390				   BLACK_BLANK_on_WHITE_SQUARE_3
      3  2390				   TEMPORARY_VAR SET	Overlay
      4  2390				   TEMPORARY_OFFSET SET	0
      5  2390				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2390				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_3
      7  2390					      SUBROUTINE
      3  2390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  23a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  23c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  23d8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm"
      0  23d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_0", 72
     12  2400					      LIST	ON
      0  2400					      DEF	BLACK_PAWN_on_WHITE_SQUARE_0
      1  2400				   BANK_BLACK_PAWN_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2400				   BLACK_PAWN_on_WHITE_SQUARE_0
      3  2400				   TEMPORARY_VAR SET	Overlay
      4  2400				   TEMPORARY_OFFSET SET	0
      5  2400				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2400				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_0
      7  2400					      SUBROUTINE
      3  2400		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  2418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2448					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm"
      0  2448					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_1", 72
     12  2448					      LIST	ON
      0  2448					      DEF	BLACK_PAWN_on_WHITE_SQUARE_1
      1  2448				   BANK_BLACK_PAWN_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2448				   BLACK_PAWN_on_WHITE_SQUARE_1
      3  2448				   TEMPORARY_VAR SET	Overlay
      4  2448				   TEMPORARY_OFFSET SET	0
      5  2448				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2448				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_1
      7  2448					      SUBROUTINE
      3  2448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2460		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  2478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2490					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm"
      0  2490					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_2", 72
     12  2490					      LIST	ON
      0  2490					      DEF	BLACK_PAWN_on_WHITE_SQUARE_2
      1  2490				   BANK_BLACK_PAWN_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2490				   BLACK_PAWN_on_WHITE_SQUARE_2
      3  2490				   TEMPORARY_VAR SET	Overlay
      4  2490				   TEMPORARY_OFFSET SET	0
      5  2490				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2490				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_2
      7  2490					      SUBROUTINE
      3  2490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  24a8		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  24c0		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  24d8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm"
      0  24d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_3", 72
     12  2500					      LIST	ON
      0  2500					      DEF	BLACK_PAWN_on_WHITE_SQUARE_3
      1  2500				   BANK_BLACK_PAWN_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2500				   BLACK_PAWN_on_WHITE_SQUARE_3
      3  2500				   TEMPORARY_VAR SET	Overlay
      4  2500				   TEMPORARY_OFFSET SET	0
      5  2500				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2500				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_3
      7  2500					      SUBROUTINE
      3  2500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2530		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2548					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  2548					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_0", 72
     12  2548					      LIST	ON
      0  2548					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_0
      1  2548				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2548				   BLACK_KNIGHT_on_WHITE_SQUARE_0
      3  2548				   TEMPORARY_VAR SET	Overlay
      4  2548				   TEMPORARY_OFFSET SET	0
      5  2548				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2548				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_0
      7  2548					      SUBROUTINE
      3  2548		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00	;PF0
      4  2560		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  2578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2590					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  2590					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_1", 72
     12  2590					      LIST	ON
      0  2590					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_1
      1  2590				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2590				   BLACK_KNIGHT_on_WHITE_SQUARE_1
      3  2590				   TEMPORARY_VAR SET	Overlay
      4  2590				   TEMPORARY_OFFSET SET	0
      5  2590				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2590				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_1
      7  2590					      SUBROUTINE
      3  2590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  25a8		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$70,$38,$1c,$7c,$6c,$14,$00	;PF1
      5  25c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  25d8					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  25d8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_2", 72
     12  2600					      LIST	ON
      0  2600					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_2
      1  2600				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2600				   BLACK_KNIGHT_on_WHITE_SQUARE_2
      3  2600				   TEMPORARY_VAR SET	Overlay
      4  2600				   TEMPORARY_OFFSET SET	0
      5  2600				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2600				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_2
      7  2600					      SUBROUTINE
      3  2600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2618		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00	;PF1
      5  2630		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$01,$03,$07,$07,$06,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  2648					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  2648					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_3", 72
     12  2648					      LIST	ON
      0  2648					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_3
      1  2648				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2648				   BLACK_KNIGHT_on_WHITE_SQUARE_3
      3  2648				   TEMPORARY_VAR SET	Overlay
      4  2648				   TEMPORARY_OFFSET SET	0
      5  2648				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2648				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_3
      7  2648					      SUBROUTINE
      3  2648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2678		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$38,$70,$e0,$f8,$d8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2690					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm"
      0  2690					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_0", 72
     12  2690					      LIST	ON
      0  2690					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_0
      1  2690				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2690				   BLACK_BISHOP_on_WHITE_SQUARE_0
      3  2690				   TEMPORARY_VAR SET	Overlay
      4  2690				   TEMPORARY_OFFSET SET	0
      5  2690				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2690				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_0
      7  2690					      SUBROUTINE
      3  2690		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$f0,$f0,$e0,$00,$40	;PF0
      4  26a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  26c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  26d8					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm"
      0  26d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_1", 72
     12  2700					      LIST	ON
      0  2700					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_1
      1  2700				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2700				   BLACK_BISHOP_on_WHITE_SQUARE_1
      3  2700				   TEMPORARY_VAR SET	Overlay
      4  2700				   TEMPORARY_OFFSET SET	0
      5  2700				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2700				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_1
      7  2700					      SUBROUTINE
      3  2700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2718		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$7c,$7c,$38,$00,$10	;PF1
      5  2730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2748					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm"
      0  2748					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_2", 72
     12  2748					      LIST	ON
      0  2748					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_2
      1  2748				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2748				   BLACK_BISHOP_on_WHITE_SQUARE_2
      3  2748				   TEMPORARY_VAR SET	Overlay
      4  2748				   TEMPORARY_OFFSET SET	0
      5  2748				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2748				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_2
      7  2748					      SUBROUTINE
      3  2748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2760		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$03,$01,$00,$00	;PF1
      5  2778		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$07,$07,$03,$00,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  2790					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm"
      0  2790					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_3", 72
     12  2790					      LIST	ON
      0  2790					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_3
      1  2790				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2790				   BLACK_BISHOP_on_WHITE_SQUARE_3
      3  2790				   TEMPORARY_VAR SET	Overlay
      4  2790				   TEMPORARY_OFFSET SET	0
      5  2790				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2790				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_3
      7  2790					      SUBROUTINE
      3  2790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  27a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  27c0		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$f8,$f8,$70,$00,$20	;PF2
------- FILE piece_graphics.asm
      0  27d8					      CHECK_BANK_SIZE	"PIECE_2 (2K)"
      1  27d8		       07 d8	   .TEMP      =	* - BANK_START
 PIECE_2 (2K) (2K) SIZE =  $7d8 , FREE= $28
      2  27d8					      ECHO	"PIECE_2 (2K)", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  27d8				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  27d8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  27d8				  -	      ERR
      6  27d8					      endif
      0  27d8					      NEWBANK	PIECES_3
      1  2fd8 ????				      SEG	PIECES_3
      2  2800					      ORG	ORIGIN
      3  2800					      RORG	$F000
      4  2800				   BANK_START SET	*
      5  2800				   PIECES_3   SET	ORIGIN / 2048
      6  2800				   ORIGIN     SET	ORIGIN + 2048
      7  2800				   _CURRENT_BANK SET	PIECES_3
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2800					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm"
      0  2800					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_0", 72
     12  2800					      LIST	ON
      0  2800					      DEF	BLACK_ROOK_on_WHITE_SQUARE_0
      1  2800				   BANK_BLACK_ROOK_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2800				   BLACK_ROOK_on_WHITE_SQUARE_0
      3  2800				   TEMPORARY_VAR SET	Overlay
      4  2800				   TEMPORARY_OFFSET SET	0
      5  2800				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2800				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_0
      7  2800					      SUBROUTINE
      3  2800		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$50,$50,$00	;PF0
      4  2818		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  2830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2848					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm"
      0  2848					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_1", 72
     12  2848					      LIST	ON
      0  2848					      DEF	BLACK_ROOK_on_WHITE_SQUARE_1
      1  2848				   BANK_BLACK_ROOK_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2848				   BLACK_ROOK_on_WHITE_SQUARE_1
      3  2848				   TEMPORARY_VAR SET	Overlay
      4  2848				   TEMPORARY_OFFSET SET	0
      5  2848				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2848				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_1
      7  2848					      SUBROUTINE
      3  2848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2860		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$54,$54,$00	;PF1
      5  2878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2890					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm"
      0  2890					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_2", 72
     12  2890					      LIST	ON
      0  2890					      DEF	BLACK_ROOK_on_WHITE_SQUARE_2
      1  2890				   BANK_BLACK_ROOK_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2890				   BLACK_ROOK_on_WHITE_SQUARE_2
      3  2890				   TEMPORARY_VAR SET	Overlay
      4  2890				   TEMPORARY_OFFSET SET	0
      5  2890				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2890				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_2
      7  2890					      SUBROUTINE
      3  2890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  28a8		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$02,$02,$00	;PF1
      5  28c0		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$05,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  28d8					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm"
      0  28d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_3", 72
     12  2900					      LIST	ON
      0  2900					      DEF	BLACK_ROOK_on_WHITE_SQUARE_3
      1  2900				   BANK_BLACK_ROOK_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2900				   BLACK_ROOK_on_WHITE_SQUARE_3
      3  2900				   TEMPORARY_VAR SET	Overlay
      4  2900				   TEMPORARY_OFFSET SET	0
      5  2900				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2900				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_3
      7  2900					      SUBROUTINE
      3  2900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2930		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$a8,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2948					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm"
      0  2948					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_0", 72
     12  2948					      LIST	ON
      0  2948					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_0
      1  2948				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2948				   BLACK_QUEEN_on_WHITE_SQUARE_0
      3  2948				   TEMPORARY_VAR SET	Overlay
      4  2948				   TEMPORARY_OFFSET SET	0
      5  2948				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2948				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_0
      7  2948					      SUBROUTINE
      3  2948		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  2960		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$80,$80,$00,$80,$00	;PF1
      5  2978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2990					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm"
      0  2990					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_1", 72
     12  2990					      LIST	ON
      0  2990					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_1
      1  2990				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2990				   BLACK_QUEEN_on_WHITE_SQUARE_1
      3  2990				   TEMPORARY_VAR SET	Overlay
      4  2990				   TEMPORARY_OFFSET SET	0
      5  2990				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2990				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_1
      7  2990					      SUBROUTINE
      3  2990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  29a8		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$78,$7c,$54,$00,$54,$00	;PF1
      5  29c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  29d8					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm"
      0  29d8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_2", 72
     12  2a00					      LIST	ON
      0  2a00					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_2
      1  2a00				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2a00				   BLACK_QUEEN_on_WHITE_SQUARE_2
      3  2a00				   TEMPORARY_VAR SET	Overlay
      4  2a00				   TEMPORARY_OFFSET SET	0
      5  2a00				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2a00				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_2
      7  2a00					      SUBROUTINE
      3  2a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a18		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  2a30		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$03,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  2a48					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm"
      0  2a48					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_3", 72
     12  2a48					      LIST	ON
      0  2a48					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_3
      1  2a48				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2a48				   BLACK_QUEEN_on_WHITE_SQUARE_3
      3  2a48				   TEMPORARY_VAR SET	Overlay
      4  2a48				   TEMPORARY_OFFSET SET	0
      5  2a48				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2a48				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_3
      7  2a48					      SUBROUTINE
      3  2a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2a78		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$78,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2a90					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_0.asm"
      0  2a90					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_0", 72
     12  2a90					      LIST	ON
      0  2a90					      DEF	BLACK_KING_on_WHITE_SQUARE_0
      1  2a90				   BANK_BLACK_KING_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2a90				   BLACK_KING_on_WHITE_SQUARE_0
      3  2a90				   TEMPORARY_VAR SET	Overlay
      4  2a90				   TEMPORARY_OFFSET SET	0
      5  2a90				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2a90				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_0
      7  2a90					      SUBROUTINE
      3  2a90		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$f0,$f0,$40,$e0,$40	;PF0
      4  2aa8		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  2ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2ad8					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_1.asm"
      0  2ad8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_1", 72
     12  2b00					      LIST	ON
      0  2b00					      DEF	BLACK_KING_on_WHITE_SQUARE_1
      1  2b00				   BANK_BLACK_KING_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2b00				   BLACK_KING_on_WHITE_SQUARE_1
      3  2b00				   TEMPORARY_VAR SET	Overlay
      4  2b00				   TEMPORARY_OFFSET SET	0
      5  2b00				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2b00				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_1
      7  2b00					      SUBROUTINE
      3  2b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b18		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$7c,$7c,$10,$38,$10	;PF1
      5  2b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2b48					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_2.asm"
      0  2b48					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_2", 72
     12  2b48					      LIST	ON
      0  2b48					      DEF	BLACK_KING_on_WHITE_SQUARE_2
      1  2b48				   BANK_BLACK_KING_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2b48				   BLACK_KING_on_WHITE_SQUARE_2
      3  2b48				   TEMPORARY_VAR SET	Overlay
      4  2b48				   TEMPORARY_OFFSET SET	0
      5  2b48				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2b48				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_2
      7  2b48					      SUBROUTINE
      3  2b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b60		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$03,$03,$00,$01,$00	;PF1
      5  2b78		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$07,$07,$01,$03,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  2b90					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_3.asm"
      0  2b90					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_3", 72
     12  2b90					      LIST	ON
      0  2b90					      DEF	BLACK_KING_on_WHITE_SQUARE_3
      1  2b90				   BANK_BLACK_KING_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2b90				   BLACK_KING_on_WHITE_SQUARE_3
      3  2b90				   TEMPORARY_VAR SET	Overlay
      4  2b90				   TEMPORARY_OFFSET SET	0
      5  2b90				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2b90				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_3
      7  2b90					      SUBROUTINE
      3  2b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2bc0		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$f8,$f8,$20,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2bd8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm"
      0  2bd8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_0", 72
     12  2c00					      LIST	ON
      0  2c00					      DEF	BLACK_BLANK_on_BLACK_SQUARE_0
      1  2c00				   BANK_BLACK_BLANK_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2c00				   BLACK_BLANK_on_BLACK_SQUARE_0
      3  2c00				   TEMPORARY_VAR SET	Overlay
      4  2c00				   TEMPORARY_OFFSET SET	0
      5  2c00				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2c00				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_0
      7  2c00					      SUBROUTINE
      3  2c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2c48					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm"
      0  2c48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_1", 72
     12  2c48					      LIST	ON
      0  2c48					      DEF	BLACK_BLANK_on_BLACK_SQUARE_1
      1  2c48				   BANK_BLACK_BLANK_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2c48				   BLACK_BLANK_on_BLACK_SQUARE_1
      3  2c48				   TEMPORARY_VAR SET	Overlay
      4  2c48				   TEMPORARY_OFFSET SET	0
      5  2c48				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2c48				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_1
      7  2c48					      SUBROUTINE
      3  2c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  2c90					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm"
      0  2c90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_2", 72
     12  2c90					      LIST	ON
      0  2c90					      DEF	BLACK_BLANK_on_BLACK_SQUARE_2
      1  2c90				   BANK_BLACK_BLANK_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2c90				   BLACK_BLANK_on_BLACK_SQUARE_2
      3  2c90				   TEMPORARY_VAR SET	Overlay
      4  2c90				   TEMPORARY_OFFSET SET	0
      5  2c90				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2c90				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_2
      7  2c90					      SUBROUTINE
      3  2c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  2cd8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm"
      0  2cd8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_3", 72
     12  2d00					      LIST	ON
      0  2d00					      DEF	BLACK_BLANK_on_BLACK_SQUARE_3
      1  2d00				   BANK_BLACK_BLANK_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2d00				   BLACK_BLANK_on_BLACK_SQUARE_3
      3  2d00				   TEMPORARY_VAR SET	Overlay
      4  2d00				   TEMPORARY_OFFSET SET	0
      5  2d00				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2d00				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_3
      7  2d00					      SUBROUTINE
      3  2d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2d48					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm"
      0  2d48					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_0", 72
     12  2d48					      LIST	ON
      0  2d48					      DEF	BLACK_PAWN_on_BLACK_SQUARE_0
      1  2d48				   BANK_BLACK_PAWN_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2d48				   BLACK_PAWN_on_BLACK_SQUARE_0
      3  2d48				   TEMPORARY_VAR SET	Overlay
      4  2d48				   TEMPORARY_OFFSET SET	0
      5  2d48				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2d48				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_0
      7  2d48					      SUBROUTINE
      3  2d48		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2d90					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm"
      0  2d90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_1", 72
     12  2d90					      LIST	ON
      0  2d90					      DEF	BLACK_PAWN_on_BLACK_SQUARE_1
      1  2d90				   BANK_BLACK_PAWN_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2d90				   BLACK_PAWN_on_BLACK_SQUARE_1
      3  2d90				   TEMPORARY_VAR SET	Overlay
      4  2d90				   TEMPORARY_OFFSET SET	0
      5  2d90				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2d90				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_1
      7  2d90					      SUBROUTINE
      3  2d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2da8		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  2dd8					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm"
      0  2dd8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_2", 72
     12  2e00					      LIST	ON
      0  2e00					      DEF	BLACK_PAWN_on_BLACK_SQUARE_2
      1  2e00				   BANK_BLACK_PAWN_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2e00				   BLACK_PAWN_on_BLACK_SQUARE_2
      3  2e00				   TEMPORARY_VAR SET	Overlay
      4  2e00				   TEMPORARY_OFFSET SET	0
      5  2e00				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2e00				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_2
      7  2e00					      SUBROUTINE
      3  2e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e18		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e30		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  2e48					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm"
      0  2e48					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_3", 72
     12  2e48					      LIST	ON
      0  2e48					      DEF	BLACK_PAWN_on_BLACK_SQUARE_3
      1  2e48				   BANK_BLACK_PAWN_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2e48				   BLACK_PAWN_on_BLACK_SQUARE_3
      3  2e48				   TEMPORARY_VAR SET	Overlay
      4  2e48				   TEMPORARY_OFFSET SET	0
      5  2e48				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2e48				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_3
      7  2e48					      SUBROUTINE
      3  2e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e78		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2e90					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  2e90					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_0", 72
     12  2e90					      LIST	ON
      0  2e90					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_0
      1  2e90				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2e90				   BLACK_KNIGHT_on_BLACK_SQUARE_0
      3  2e90				   TEMPORARY_VAR SET	Overlay
      4  2e90				   TEMPORARY_OFFSET SET	0
      5  2e90				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2e90				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_0
      7  2e90					      SUBROUTINE
      3  2e90		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$40,$00,$00	;PF0
      4  2ea8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2ed8					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  2ed8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_1", 72
     12  2f00					      LIST	ON
      0  2f00					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_1
      1  2f00				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2f00				   BLACK_KNIGHT_on_BLACK_SQUARE_1
      3  2f00				   TEMPORARY_VAR SET	Overlay
      4  2f00				   TEMPORARY_OFFSET SET	0
      5  2f00				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2f00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_1
      7  2f00					      SUBROUTINE
      3  2f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f18		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$10,$00,$00	;PF1
      5  2f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  2f48					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  2f48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_2", 72
     12  2f48					      LIST	ON
      0  2f48					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_2
      1  2f48				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2f48				   BLACK_KNIGHT_on_BLACK_SQUARE_2
      3  2f48				   TEMPORARY_VAR SET	Overlay
      4  2f48				   TEMPORARY_OFFSET SET	0
      5  2f48				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2f48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_2
      7  2f48					      SUBROUTINE
      3  2f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f60		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2f78		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  2f90					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  2f90					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_3", 72
     12  2f90					      LIST	ON
      0  2f90					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_3
      1  2f90				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2f90				   BLACK_KNIGHT_on_BLACK_SQUARE_3
      3  2f90				   TEMPORARY_VAR SET	Overlay
      4  2f90				   TEMPORARY_OFFSET SET	0
      5  2f90				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2f90				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_3
      7  2f90					      SUBROUTINE
      3  2f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2fc0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  2fd8					      CHECK_BANK_SIZE	"PIECES_3 (2K)"
      1  2fd8		       07 d8	   .TEMP      =	* - BANK_START
 PIECES_3 (2K) (2K) SIZE =  $7d8 , FREE= $28
      2  2fd8					      ECHO	"PIECES_3 (2K)", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2fd8				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2fd8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2fd8				  -	      ERR
      6  2fd8					      endif
    107  2fd8							;    NEWBANK PIECES_4
    108  2fd8
    109  2fd8							;    CHECK_BANK_SIZE "PIECES_4 (2K)"
    110  2fd8
    111  2fd8							;    NEWBANK PIECES_5
    112  2fd8
    113  2fd8							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
    114  2fd8							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
    115  2fd8							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
    116  2fd8							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
    117  2fd8							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
    118  2fd8							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
    119  2fd8							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
    120  2fd8							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
    121  2fd8
    122  2fd8
    123  2fd8				  -	      if	0
    124  2fd8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    125  2fd8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    126  2fd8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    127  2fd8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    128  2fd8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    129  2fd8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    130  2fd8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    131  2fd8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    132  2fd8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    133  2fd8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    134  2fd8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    135  2fd8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    136  2fd8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    137  2fd8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    138  2fd8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    139  2fd8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    140  2fd8					      endif
    141  2fd8							;    CHECK_BANK_SIZE "PIECES_5 (2K)"
    142  2fd8
    143  2fd8				  -	      if	0
    144  2fd8				  -	      NEWBANK	PIECES_6
    145  2fd8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    146  2fd8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    147  2fd8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    148  2fd8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    149  2fd8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    150  2fd8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    151  2fd8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    152  2fd8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    153  2fd8				  -
    154  2fd8				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_0.asm"
    155  2fd8				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_1.asm"
    156  2fd8				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_2.asm"
    157  2fd8				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_3.asm"
    158  2fd8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    159  2fd8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    160  2fd8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    161  2fd8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    162  2fd8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    163  2fd8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    164  2fd8				  -
    165  2fd8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    166  2fd8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    167  2fd8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    168  2fd8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    169  2fd8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    170  2fd8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    171  2fd8				  -	      CHECK_BANK_SIZE	"PIECES_6 (2K)"
    172  2fd8				  -
    173  2fd8				  -
    174  2fd8				  -	      NEWBANK	PIECES_7
    175  2fd8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    176  2fd8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    177  2fd8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    178  2fd8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    179  2fd8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    180  2fd8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    181  2fd8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    182  2fd8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    183  2fd8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    184  2fd8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    185  2fd8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    186  2fd8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    187  2fd8				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_0.asm"
    188  2fd8				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_1.asm"
    189  2fd8				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_2.asm"
    190  2fd8				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_3.asm"
    191  2fd8				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    192  2fd8				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    193  2fd8				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    194  2fd8				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    195  2fd8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    196  2fd8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    197  2fd8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    198  2fd8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    199  2fd8				  -	      CHECK_BANK_SIZE	"PIECES_7 (2K)"
    200  2fd8				  -
    201  2fd8				  -
    202  2fd8				  -	      NEWBANK	PIECES_8
    203  2fd8				  -
    204  2fd8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    205  2fd8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    206  2fd8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    207  2fd8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    208  2fd8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    209  2fd8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    210  2fd8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    211  2fd8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    212  2fd8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    213  2fd8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    214  2fd8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    215  2fd8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    216  2fd8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    217  2fd8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    218  2fd8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    219  2fd8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    220  2fd8				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_0.asm"
    221  2fd8				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_1.asm"
    222  2fd8				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_2.asm"
    223  2fd8				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_3.asm"
    224  2fd8				  -
    225  2fd8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    226  2fd8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    227  2fd8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    228  2fd8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    229  2fd8				  -	      CHECK_BANK_SIZE	"PIECES_8 (2K)"
    230  2fd8				  -
    231  2fd8					      endif
    232  2fd8
    233  2fd8							;    NEWBANK PIECES_9
    234  2fd8
    235  2fd8							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    236  2fd8							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    237  2fd8							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    238  2fd8							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    239  2fd8							; include "gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    240  2fd8
    241  2fd8				  -	      if	0
    242  2fd8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    243  2fd8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    244  2fd8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    245  2fd8					      endif
    246  2fd8
    247  2fd8							;    CHECK_BANK_SIZE "PIECES_9 (2K)"
    248  2fd8
    249  2fd8				  -	      if	0
    250  2fd8				  -
    251  2fd8				  -
    252  2fd8				  -
    253  2fd8				  -
    254  2fd8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    255  2fd8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    256  2fd8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    257  2fd8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    258  2fd8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    259  2fd8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    260  2fd8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    261  2fd8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    262  2fd8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    263  2fd8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    264  2fd8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    265  2fd8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    266  2fd8				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_0.asm"
    267  2fd8				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_1.asm"
    268  2fd8				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_2.asm"
    269  2fd8				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_3.asm"
    270  2fd8				  -
    271  2fd8				  -
    272  2fd8					      endif
------- FILE BANK_CHESS_INCLUDES.asm
     38  2fd8
     39  2fd8							;    NEWBANK PIECE_VECTORS
     40  2fd8							;    include "piece_vectors.asm"
     41  2fd8							;    CHECK_BANK_SIZE "PIECE_VECTORS (2K)"
------- FILE ./chess.asm
------- FILE BANK_StateMachine.asm LEVEL 2 PASS 5
      0  2fd8					      include	"BANK_StateMachine.asm"
      0  2fd8					      NEWBANK	STATEMACHINE
      1  36d8 ????				      SEG	STATEMACHINE
      2  3000					      ORG	ORIGIN
      3  3000					      RORG	$F000
      4  3000				   BANK_START SET	*
      5  3000				   STATEMACHINE SET	ORIGIN / 2048
      6  3000				   ORIGIN     SET	ORIGIN + 2048
      7  3000				   _CURRENT_BANK SET	STATEMACHINE
      2  3000
      3  3000
      4  3000							; Banks holding data (ply 0 doubles as WHITE, and ply 1 as BLACK)
      5  3000
      6  3000		       00 09	   PLAYER     =	RAMBANK_PLY
      7  3000		       00 0a	   OPPONENT   =	PLAYER + 1
      8  3000
      9  3000		       00 10	   CURSOR_MOVE_SPEED =	16
     10  3000		       00 14	   CAP_SPEED  =	20
     11  3000		       00 28	   HOLD_DELAY =	40
     12  3000
     13  3000
     14  3000							;---------------------------------------------------------------------------------------------------
     15  3000
     16  3000				   P	      SET	0
     17  3000					      MAC	ain
     18  3000				   AI_{1}     SET	P
     19  3000				   P	      SET	P+1
     20  3000					      ENDM
     21  3000
     22  3000					      MAC	lo
     23  3000					      .byte	<ai{1}
     24  3000					      ENDM
     25  3000
     26  3000					      MAC	hi
     27  3000					      .byte	>ai{1}
     28  3000					      ENDM
     29  3000
     30  3000					      MAC	bk
     31  3000					      .byte	BANK_ai{1}
     32  3000					      ENDM
     33  3000
     34  3000
     35  3000		       00 28	   ONCEPERFRAME =	40
     36  3000
     37  3000					      MAC	tabdef
     38  3000
     39  3000					      {1}	BeginSelectMovePhase
     40  3000					      {1}	SelectStartSquare
     41  3000					      {1}	StartSquareSelected
     42  3000					      {1}	DrawMoves
     43  3000					      {1}	ShowMoveCaptures
     44  3000					      {1}	SlowFlash
     45  3000					      {1}	UnDrawTargetSquares
     46  3000					      {1}	SelectDestinationSquare
     47  3000					      {1}	Quiescent
     48  3000					      {1}	ReselectDebounce
     49  3000					      {1}	StartMoveGen
     50  3000					      {1}	StepMoveGen
     51  3000					      {1}	LookForCheck
     52  3000					      {1}	StartClearBoard
     53  3000					      {1}	ClearEachRow
     54  3000					      {1}	DrawEntireBoard
     55  3000					      {1}	DrawPart2
     56  3000					      {1}	DrawPart3
     57  3000					      {1}	FlipBuffers
     58  3000					      {1}	GenerateMoves
     59  3000					      {1}	ComputerMove
     60  3000					      {1}	MoveIsSelected
     61  3000					      {1}	WriteStartPieceBlank
     62  3000					      {1}	MarchToTargetA
     63  3000					      {1}	MarchB
     64  3000					      {1}	MarchToTargetB
     65  3000					      {1}	MarchB2
     66  3000					      {1}	FinalFlash
     67  3000					      {1}	SpecialMoveFixup
     68  3000					      {1}	InCheckBackup
     69  3000					      {1}	InCheckDelay
     70  3000					      {1}	PromotePawnStart
     71  3000					      {1}	RollPromotionPiece
     72  3000					      {1}	ChoosePromotePiece
     73  3000					      {1}	ChooseDebounce
     74  3000
     75  3000					      ENDM		; {1} = macro to use
     76  3000
      0  3000					      TABDEF	AIN
      1  3000
      0  3000					      AIN	BeginSelectMovePhase
      1  3000				   AI_BeginSelectMovePhase SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	SelectStartSquare
      1  3000				   AI_SelectStartSquare SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	StartSquareSelected
      1  3000				   AI_StartSquareSelected SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	DrawMoves
      1  3000				   AI_DrawMoves SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	ShowMoveCaptures
      1  3000				   AI_ShowMoveCaptures SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	SlowFlash
      1  3000				   AI_SlowFlash SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	UnDrawTargetSquares
      1  3000				   AI_UnDrawTargetSquares SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	SelectDestinationSquare
      1  3000				   AI_SelectDestinationSquare SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	Quiescent
      1  3000				   AI_Quiescent SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	ReselectDebounce
      1  3000				   AI_ReselectDebounce SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	StartMoveGen
      1  3000				   AI_StartMoveGen SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	StepMoveGen
      1  3000				   AI_StepMoveGen SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	LookForCheck
      1  3000				   AI_LookForCheck SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	StartClearBoard
      1  3000				   AI_StartClearBoard SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	ClearEachRow
      1  3000				   AI_ClearEachRow SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	DrawEntireBoard
      1  3000				   AI_DrawEntireBoard SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	DrawPart2
      1  3000				   AI_DrawPart2 SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	DrawPart3
      1  3000				   AI_DrawPart3 SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	FlipBuffers
      1  3000				   AI_FlipBuffers SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	GenerateMoves
      1  3000				   AI_GenerateMoves SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	ComputerMove
      1  3000				   AI_ComputerMove SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	MoveIsSelected
      1  3000				   AI_MoveIsSelected SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	WriteStartPieceBlank
      1  3000				   AI_WriteStartPieceBlank SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	MarchToTargetA
      1  3000				   AI_MarchToTargetA SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	MarchB
      1  3000				   AI_MarchB  SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	MarchToTargetB
      1  3000				   AI_MarchToTargetB SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	MarchB2
      1  3000				   AI_MarchB2 SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	FinalFlash
      1  3000				   AI_FinalFlash SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	SpecialMoveFixup
      1  3000				   AI_SpecialMoveFixup SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	InCheckBackup
      1  3000				   AI_InCheckBackup SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	InCheckDelay
      1  3000				   AI_InCheckDelay SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	PromotePawnStart
      1  3000				   AI_PromotePawnStart SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	RollPromotionPiece
      1  3000				   AI_RollPromotionPiece SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	ChoosePromotePiece
      1  3000				   AI_ChoosePromotePiece SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	ChooseDebounce
      1  3000				   AI_ChooseDebounce SET	P
      2  3000				   P	      SET	P+1
     37  3000
     78  3000
      0  3000					      DEF	AiVectorLO
      1  3000				   BANK_AiVectorLO SET	_CURRENT_BANK
      2  3000				   AiVectorLO
      3  3000				   TEMPORARY_VAR SET	Overlay
      4  3000				   TEMPORARY_OFFSET SET	0
      5  3000				   VAR_BOUNDARY_AiVectorLO SET	TEMPORARY_OFFSET
      6  3000				   FUNCTION_NAME SET	AiVectorLO
      7  3000					      SUBROUTINE
      0  3000					      TABDEF	LO
      1  3000
      0  3000					      LO	BeginSelectMovePhase
      1  3000		       ad		      .byte.b	<aiBeginSelectMovePhase
      0  3001					      LO	SelectStartSquare
      1  3001		       c2		      .byte.b	<aiSelectStartSquare
      0  3002					      LO	StartSquareSelected
      1  3002		       20		      .byte.b	<aiStartSquareSelected
      0  3003					      LO	DrawMoves
      1  3003		       3b		      .byte.b	<aiDrawMoves
      0  3004					      LO	ShowMoveCaptures
      1  3004		       e6		      .byte.b	<aiShowMoveCaptures
      0  3005					      LO	SlowFlash
      1  3005		       04		      .byte.b	<aiSlowFlash
      0  3006					      LO	UnDrawTargetSquares
      1  3006		       c4		      .byte.b	<aiUnDrawTargetSquares
      0  3007					      LO	SelectDestinationSquare
      1  3007		       6b		      .byte.b	<aiSelectDestinationSquare
      0  3008					      LO	Quiescent
      1  3008		       b7		      .byte.b	<aiQuiescent
      0  3009					      LO	ReselectDebounce
      1  3009		       ae		      .byte.b	<aiReselectDebounce
      0  300a					      LO	StartMoveGen
      1  300a		       7b		      .byte.b	<aiStartMoveGen
      0  300b					      LO	StepMoveGen
      1  300b		       14		      .byte.b	<aiStepMoveGen
      0  300c					      LO	LookForCheck
      1  300c		       8b		      .byte.b	<aiLookForCheck
      0  300d					      LO	StartClearBoard
      1  300d		       1d		      .byte.b	<aiStartClearBoard
      0  300e					      LO	ClearEachRow
      1  300e		       2a		      .byte.b	<aiClearEachRow
      0  300f					      LO	DrawEntireBoard
      1  300f		       b0		      .byte.b	<aiDrawEntireBoard
      0  3010					      LO	DrawPart2
      1  3010		       6e		      .byte.b	<aiDrawPart2
      0  3011					      LO	DrawPart3
      1  3011		       71		      .byte.b	<aiDrawPart3
      0  3012					      LO	FlipBuffers
      1  3012		       e4		      .byte.b	<aiFlipBuffers
      0  3013					      LO	GenerateMoves
      1  3013		       03		      .byte.b	<aiGenerateMoves
      0  3014					      LO	ComputerMove
      1  3014		       95		      .byte.b	<aiComputerMove
      0  3015					      LO	MoveIsSelected
      1  3015		       3c		      .byte.b	<aiMoveIsSelected
      0  3016					      LO	WriteStartPieceBlank
      1  3016		       50		      .byte.b	<aiWriteStartPieceBlank
      0  3017					      LO	MarchToTargetA
      1  3017		       59		      .byte.b	<aiMarchToTargetA
      0  3018					      LO	MarchB
      1  3018		       83		      .byte.b	<aiMarchB
      0  3019					      LO	MarchToTargetB
      1  3019		       f4		      .byte.b	<aiMarchToTargetB
      0  301a					      LO	MarchB2
      1  301a		       ca		      .byte.b	<aiMarchB2
      0  301b					      LO	FinalFlash
      1  301b		       93		      .byte.b	<aiFinalFlash
      0  301c					      LO	SpecialMoveFixup
      1  301c		       54		      .byte.b	<aiSpecialMoveFixup
      0  301d					      LO	InCheckBackup
      1  301d		       92		      .byte.b	<aiInCheckBackup
      0  301e					      LO	InCheckDelay
      1  301e		       a0		      .byte.b	<aiInCheckDelay
      0  301f					      LO	PromotePawnStart
      1  301f		       d7		      .byte.b	<aiPromotePawnStart
      0  3020					      LO	RollPromotionPiece
      1  3020		       f7		      .byte.b	<aiRollPromotionPiece
      0  3021					      LO	ChoosePromotePiece
      1  3021		       3d		      .byte.b	<aiChoosePromotePiece
      0  3022					      LO	ChooseDebounce
      1  3022		       a8		      .byte.b	<aiChooseDebounce
     37  3023
     81  3023
      0  3023					      DEF	AiVectorHI
      1  3023				   BANK_AiVectorHI SET	_CURRENT_BANK
      2  3023				   AiVectorHI
      3  3023				   TEMPORARY_VAR SET	Overlay
      4  3023				   TEMPORARY_OFFSET SET	0
      5  3023				   VAR_BOUNDARY_AiVectorHI SET	TEMPORARY_OFFSET
      6  3023				   FUNCTION_NAME SET	AiVectorHI
      7  3023					      SUBROUTINE
      0  3023					      TABDEF	HI
      1  3023
      0  3023					      HI	BeginSelectMovePhase
      1  3023		       f0		      .byte.b	>aiBeginSelectMovePhase
      0  3024					      HI	SelectStartSquare
      1  3024		       f0		      .byte.b	>aiSelectStartSquare
      0  3025					      HI	StartSquareSelected
      1  3025		       f1		      .byte.b	>aiStartSquareSelected
      0  3026					      HI	DrawMoves
      1  3026		       f1		      .byte.b	>aiDrawMoves
      0  3027					      HI	ShowMoveCaptures
      1  3027		       f1		      .byte.b	>aiShowMoveCaptures
      0  3028					      HI	SlowFlash
      1  3028		       f2		      .byte.b	>aiSlowFlash
      0  3029					      HI	UnDrawTargetSquares
      1  3029		       f1		      .byte.b	>aiUnDrawTargetSquares
      0  302a					      HI	SelectDestinationSquare
      1  302a		       f2		      .byte.b	>aiSelectDestinationSquare
      0  302b					      HI	Quiescent
      1  302b		       f2		      .byte.b	>aiQuiescent
      0  302c					      HI	ReselectDebounce
      1  302c		       f2		      .byte.b	>aiReselectDebounce
      0  302d					      HI	StartMoveGen
      1  302d		       f0		      .byte.b	>aiStartMoveGen
      0  302e					      HI	StepMoveGen
      1  302e		       f9		      .byte.b	>aiStepMoveGen
      0  302f					      HI	LookForCheck
      1  302f		       f0		      .byte.b	>aiLookForCheck
      0  3030					      HI	StartClearBoard
      1  3030		       f0		      .byte.b	>aiStartClearBoard
      0  3031					      HI	ClearEachRow
      1  3031		       f0		      .byte.b	>aiClearEachRow
      0  3032					      HI	DrawEntireBoard
      1  3032		       f8		      .byte.b	>aiDrawEntireBoard
      0  3033					      HI	DrawPart2
      1  3033		       f0		      .byte.b	>aiDrawPart2
      0  3034					      HI	DrawPart3
      1  3034		       f0		      .byte.b	>aiDrawPart3
      0  3035					      HI	FlipBuffers
      1  3035		       f8		      .byte.b	>aiFlipBuffers
      0  3036					      HI	GenerateMoves
      1  3036		       f9		      .byte.b	>aiGenerateMoves
      0  3037					      HI	ComputerMove
      1  3037		       f9		      .byte.b	>aiComputerMove
      0  3038					      HI	MoveIsSelected
      1  3038		       f0		      .byte.b	>aiMoveIsSelected
      0  3039					      HI	WriteStartPieceBlank
      1  3039		       f0		      .byte.b	>aiWriteStartPieceBlank
      0  303a					      HI	MarchToTargetA
      1  303a		       f0		      .byte.b	>aiMarchToTargetA
      0  303b					      HI	MarchB
      1  303b		       f0		      .byte.b	>aiMarchB
      0  303c					      HI	MarchToTargetB
      1  303c		       f0		      .byte.b	>aiMarchToTargetB
      0  303d					      HI	MarchB2
      1  303d		       f0		      .byte.b	>aiMarchB2
      0  303e					      HI	FinalFlash
      1  303e		       f0		      .byte.b	>aiFinalFlash
      0  303f					      HI	SpecialMoveFixup
      1  303f		       fa		      .byte.b	>aiSpecialMoveFixup
      0  3040					      HI	InCheckBackup
      1  3040		       f0		      .byte.b	>aiInCheckBackup
      0  3041					      HI	InCheckDelay
      1  3041		       f0		      .byte.b	>aiInCheckDelay
      0  3042					      HI	PromotePawnStart
      1  3042		       f2		      .byte.b	>aiPromotePawnStart
      0  3043					      HI	RollPromotionPiece
      1  3043		       f2		      .byte.b	>aiRollPromotionPiece
      0  3044					      HI	ChoosePromotePiece
      1  3044		       f3		      .byte.b	>aiChoosePromotePiece
      0  3045					      HI	ChooseDebounce
      1  3045		       f3		      .byte.b	>aiChooseDebounce
     37  3046
     84  3046
      0  3046					      DEF	AiVectorBANK
      1  3046				   BANK_AiVectorBANK SET	_CURRENT_BANK
      2  3046				   AiVectorBANK
      3  3046				   TEMPORARY_VAR SET	Overlay
      4  3046				   TEMPORARY_OFFSET SET	0
      5  3046				   VAR_BOUNDARY_AiVectorBANK SET	TEMPORARY_OFFSET
      6  3046				   FUNCTION_NAME SET	AiVectorBANK
      7  3046					      SUBROUTINE
      0  3046					      TABDEF	BK
      1  3046
      0  3046					      BK	BeginSelectMovePhase
      1  3046		       06		      .byte.b	BANK_aiBeginSelectMovePhase
      0  3047					      BK	SelectStartSquare
      1  3047		       06		      .byte.b	BANK_aiSelectStartSquare
      0  3048					      BK	StartSquareSelected
      1  3048		       06		      .byte.b	BANK_aiStartSquareSelected
      0  3049					      BK	DrawMoves
      1  3049		       06		      .byte.b	BANK_aiDrawMoves
      0  304a					      BK	ShowMoveCaptures
      1  304a		       06		      .byte.b	BANK_aiShowMoveCaptures
      0  304b					      BK	SlowFlash
      1  304b		       06		      .byte.b	BANK_aiSlowFlash
      0  304c					      BK	UnDrawTargetSquares
      1  304c		       06		      .byte.b	BANK_aiUnDrawTargetSquares
      0  304d					      BK	SelectDestinationSquare
      1  304d		       06		      .byte.b	BANK_aiSelectDestinationSquare
      0  304e					      BK	Quiescent
      1  304e		       06		      .byte.b	BANK_aiQuiescent
      0  304f					      BK	ReselectDebounce
      1  304f		       06		      .byte.b	BANK_aiReselectDebounce
      0  3050					      BK	StartMoveGen
      1  3050		       06		      .byte.b	BANK_aiStartMoveGen
      0  3051					      BK	StepMoveGen
      1  3051		       0f		      .byte.b	BANK_aiStepMoveGen
      0  3052					      BK	LookForCheck
      1  3052		       06		      .byte.b	BANK_aiLookForCheck
      0  3053					      BK	StartClearBoard
      1  3053		       00		      .byte.b	BANK_aiStartClearBoard
      0  3054					      BK	ClearEachRow
      1  3054		       00		      .byte.b	BANK_aiClearEachRow
      0  3055					      BK	DrawEntireBoard
      1  3055		       0f		      .byte.b	BANK_aiDrawEntireBoard
      0  3056					      BK	DrawPart2
      1  3056		       00		      .byte.b	BANK_aiDrawPart2
      0  3057					      BK	DrawPart3
      1  3057		       00		      .byte.b	BANK_aiDrawPart3
      0  3058					      BK	FlipBuffers
      1  3058		       0f		      .byte.b	BANK_aiFlipBuffers
      0  3059					      BK	GenerateMoves
      1  3059		       0f		      .byte.b	BANK_aiGenerateMoves
      0  305a					      BK	ComputerMove
      1  305a		       0f		      .byte.b	BANK_aiComputerMove
      0  305b					      BK	MoveIsSelected
      1  305b		       00		      .byte.b	BANK_aiMoveIsSelected
      0  305c					      BK	WriteStartPieceBlank
      1  305c		       00		      .byte.b	BANK_aiWriteStartPieceBlank
      0  305d					      BK	MarchToTargetA
      1  305d		       09		      .byte.b	BANK_aiMarchToTargetA
      0  305e					      BK	MarchB
      1  305e		       00		      .byte.b	BANK_aiMarchB
      0  305f					      BK	MarchToTargetB
      1  305f		       09		      .byte.b	BANK_aiMarchToTargetB
      0  3060					      BK	MarchB2
      1  3060		       09		      .byte.b	BANK_aiMarchB2
      0  3061					      BK	FinalFlash
      1  3061		       00		      .byte.b	BANK_aiFinalFlash
      0  3062					      BK	SpecialMoveFixup
      1  3062		       0f		      .byte.b	BANK_aiSpecialMoveFixup
      0  3063					      BK	InCheckBackup
      1  3063		       06		      .byte.b	BANK_aiInCheckBackup
      0  3064					      BK	InCheckDelay
      1  3064		       06		      .byte.b	BANK_aiInCheckDelay
      0  3065					      BK	PromotePawnStart
      1  3065		       06		      .byte.b	BANK_aiPromotePawnStart
      0  3066					      BK	RollPromotionPiece
      1  3066		       06		      .byte.b	BANK_aiRollPromotionPiece
      0  3067					      BK	ChoosePromotePiece
      1  3067		       06		      .byte.b	BANK_aiChoosePromotePiece
      0  3068					      BK	ChooseDebounce
      1  3068		       06		      .byte.b	BANK_aiChooseDebounce
     37  3069
     87  3069
     88  3069
     89  3069							;---------------------------------------------------------------------------------------------------
     90  3069
      0  3069					      DEF	AiSetupVectors
      1  3069				   BANK_AiSetupVectors SET	_CURRENT_BANK
      2  3069				   AiSetupVectors
      3  3069				   TEMPORARY_VAR SET	Overlay
      4  3069				   TEMPORARY_OFFSET SET	0
      5  3069				   VAR_BOUNDARY_AiSetupVectors SET	TEMPORARY_OFFSET
      6  3069				   FUNCTION_NAME SET	AiSetupVectors
      7  3069					      SUBROUTINE
     92  3069					      SUBROUTINE
     93  3069
      0  3069					      REFER	AiStateMachine
      1  3069				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3069				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3069					      ENDIF
      0  3069					      VEND	AiSetupVectors
      1  3069				  -	      IFNCONST	AiSetupVectors
      2  3069				  -	      ECHO	"Incorrect VEND label", AiSetupVectors
      3  3069				  -	      ERR
      4  3069					      ENDIF
      5  3069		       00 a2	   VAREND_AiSetupVectors =	TEMPORARY_VAR
     96  3069
     97  3069							; State machine vector setup - points to current routine to execute
     98  3069
     99  3069		       a6 8c		      ldx	aiState
    100  306b		       bd 00 f0 	      lda	AiVectorLO,x
    101  306e		       85 ea		      sta	__ptr
    102  3070		       bd 23 f0 	      lda	AiVectorHI,x
    103  3073		       85 eb		      sta	__ptr+1
    104  3075
    105  3075		       bd 46 f0 	      lda	AiVectorBANK,x
    106  3078		       85 8b		      sta	savedBank
    107  307a
    108  307a		       60		      rts
    109  307b
    110  307b
    111  307b							;---------------------------------------------------------------------------------------------------
    112  307b
      0  307b					      DEF	aiStartMoveGen
      1  307b				   BANK_aiStartMoveGen SET	_CURRENT_BANK
      2  307b				   aiStartMoveGen
      3  307b				   TEMPORARY_VAR SET	Overlay
      4  307b				   TEMPORARY_OFFSET SET	0
      5  307b				   VAR_BOUNDARY_aiStartMoveGen SET	TEMPORARY_OFFSET
      6  307b				   FUNCTION_NAME SET	aiStartMoveGen
      7  307b					      SUBROUTINE
    114  307b					      SUBROUTINE
    115  307b
      0  307b					      REFER	AiStateMachine
      1  307b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  307b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  307b					      ENDIF
      0  307b					      VEND	aiStartMoveGen
      1  307b				  -	      IFNCONST	aiStartMoveGen
      2  307b				  -	      ECHO	"Incorrect VEND label", aiStartMoveGen
      3  307b				  -	      ERR
      4  307b					      ENDIF
      5  307b		       00 a2	   VAREND_aiStartMoveGen =	TEMPORARY_VAR
    118  307b
    119  307b							; To assist with castling, generate the moves for the opponent, giving us effectively
    120  307b							; a list of squares that are being attacked. The castling can't happen if the king is
    121  307b							; in check or if the squares it would have to move over are in check
    122  307b
    123  307b							; we don't need to worry about this if K has moved, or relevant R has moved or if
    124  307b							; the squares between are occupied. We can tell THAT by examining the movelist to see
    125  307b							; if there are K-moves marked "FLAG_CASTLE" - and the relevant squares
    126  307b
    127  307b		       e6 95		      inc	currentPly
    128  307d		       20 f0 f8 	      jsr	InitialiseMoveGeneration
    129  3080
    130  3080		       a5 97		      lda	sideToMove
    131  3082		       49 80		      eor	#128
    132  3084		       85 97		      sta	sideToMove	; for movegen to know
    133  3086
      0  3086					      PHASE	AI_StepMoveGen
      1  3086		       a9 0b		      lda	#AI_StepMoveGen
      2  3088		       85 8c		      sta	aiState
    135  308a		       60		      rts
    136  308b
    137  308b
    138  308b							;---------------------------------------------------------------------------------------------------
    139  308b
    140  308b
      0  308b					      DEF	aiLookForCheck
      1  308b				   BANK_aiLookForCheck SET	_CURRENT_BANK
      2  308b				   aiLookForCheck
      3  308b				   TEMPORARY_VAR SET	Overlay
      4  308b				   TEMPORARY_OFFSET SET	0
      5  308b				   VAR_BOUNDARY_aiLookForCheck SET	TEMPORARY_OFFSET
      6  308b				   FUNCTION_NAME SET	aiLookForCheck
      7  308b					      SUBROUTINE
    142  308b					      SUBROUTINE
    143  308b
      0  308b					      REFER	AiStateMachine
      1  308b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  308b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  308b					      ENDIF
      0  308b					      VEND	aiLookForCheck
      1  308b				  -	      IFNCONST	aiLookForCheck
      2  308b				  -	      ECHO	"Incorrect VEND label", aiLookForCheck
      3  308b				  -	      ERR
      4  308b					      ENDIF
      5  308b		       00 a2	   VAREND_aiLookForCheck =	TEMPORARY_VAR
    146  308b
    147  308b		       c6 95		      dec	currentPly
    148  308d
    149  308d
    150  308d				  -	      if	0
    151  308d				  -
    152  308d				  -			; now we've finished generating the opponent moves
    153  308d				  -			; See if the square our king is on is an attacked square (that is, it appears as a TO
    154  308d				  -			; square in the opponent's movelist)
    155  308d				  -
    156  308d				  -
    157  308d				  -	      jsr	SAFE_GetKingSquare	; king's current X12 square
    158  308d				  -
    159  308d				  -	      inc	currentPly
    160  308d				  -	      jsr	Go_IsSquareUnderAttack
    161  308d				  -	      dec	currentPly
    162  308d				  -	      bcc	.exit
    163  308d				  -
    164  308d				  -			; in check!
    165  308d				  -
    166  308d				  -	      lda	#$40
    167  308d				  -	      sta	COLUBK
    168  308d				  -
    169  308d				  -	      lda	#50
    170  308d				  -	      sta	mdelay
    171  308d				  -
    172  308d				  -	      lda	#8
    173  308d				  -	      sta	drawCount	; row #
    174  308d				  -
    175  308d				  -	      PHASE	AI_InCheckBackup
    176  308d				  -	      rts
    177  308d					      endif
    178  308d
      0  308d				   .exit      PHASE	AI_BeginSelectMovePhase
      1  308d		       a9 00		      lda	#AI_BeginSelectMovePhase
      2  308f		       85 8c		      sta	aiState
    180  3091		       60		      rts
    181  3092
    182  3092							;---------------------------------------------------------------------------------------------------
    183  3092
      0  3092					      DEF	aiInCheckBackup
      1  3092				   BANK_aiInCheckBackup SET	_CURRENT_BANK
      2  3092				   aiInCheckBackup
      3  3092				   TEMPORARY_VAR SET	Overlay
      4  3092				   TEMPORARY_OFFSET SET	0
      5  3092				   VAR_BOUNDARY_aiInCheckBackup SET	TEMPORARY_OFFSET
      6  3092				   FUNCTION_NAME SET	aiInCheckBackup
      7  3092					      SUBROUTINE
    185  3092					      SUBROUTINE
    186  3092
      0  3092					      REFER	AiStateMachine
      1  3092				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3092				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3092					      ENDIF
      0  3092					      VEND	aiInCheckBackup
      1  3092				  -	      IFNCONST	aiInCheckBackup
      2  3092				  -	      ECHO	"Incorrect VEND label", aiInCheckBackup
      3  3092				  -	      ERR
      4  3092					      ENDIF
      5  3092		       00 a2	   VAREND_aiInCheckBackup =	TEMPORARY_VAR
    189  3092
    190  3092							; We're about to draw some large text on the screen
    191  3092							; Make a backup copy of all of the row bitmaps, so that we can restore once text is done
    192  3092
    193  3092		       c6 84		      dec	drawCount
    194  3094		       30 05		      bmi	.exit	; done all rows
    195  3096		       a4 84		      ldy	drawCount
    196  3098		       4c 06 fd 	      jmp	SAFE_BackupBitmaps
    197  309b
      0  309b				   .exit      PHASE	AI_InCheckDelay
      1  309b		       a9 1e		      lda	#AI_InCheckDelay
      2  309d		       85 8c		      sta	aiState
    199  309f		       60		      rts
    200  30a0
    201  30a0
    202  30a0							;---------------------------------------------------------------------------------------------------
    203  30a0
      0  30a0					      DEF	aiInCheckDelay
      1  30a0				   BANK_aiInCheckDelay SET	_CURRENT_BANK
      2  30a0				   aiInCheckDelay
      3  30a0				   TEMPORARY_VAR SET	Overlay
      4  30a0				   TEMPORARY_OFFSET SET	0
      5  30a0				   VAR_BOUNDARY_aiInCheckDelay SET	TEMPORARY_OFFSET
      6  30a0				   FUNCTION_NAME SET	aiInCheckDelay
      7  30a0					      SUBROUTINE
    205  30a0					      SUBROUTINE
    206  30a0
      0  30a0					      REFER	AiStateMachine
      1  30a0				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  30a0				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  30a0					      ENDIF
      0  30a0					      VEND	aiInCheckDelay
      1  30a0				  -	      IFNCONST	aiInCheckDelay
      2  30a0				  -	      ECHO	"Incorrect VEND label", aiInCheckDelay
      3  30a0				  -	      ERR
      4  30a0					      ENDIF
      5  30a0		       00 a2	   VAREND_aiInCheckDelay =	TEMPORARY_VAR
    209  30a0
    210  30a0		       c6 89		      dec	mdelay
    211  30a2		       d0 08		      bne	.exit
    212  30a4
    213  30a4		       a9 00		      lda	#0
    214  30a6		       85 49		      sta	COLUBK
    215  30a8
      0  30a8					      PHASE	AI_BeginSelectMovePhase
      1  30a8		       a9 00		      lda	#AI_BeginSelectMovePhase
      2  30aa		       85 8c		      sta	aiState
    217  30ac		       60	   .exit      rts
    218  30ad
    219  30ad
    220  30ad							;---------------------------------------------------------------------------------------------------
    221  30ad
      0  30ad					      DEF	aiBeginSelectMovePhase
      1  30ad				   BANK_aiBeginSelectMovePhase SET	_CURRENT_BANK
      2  30ad				   aiBeginSelectMovePhase
      3  30ad				   TEMPORARY_VAR SET	Overlay
      4  30ad				   TEMPORARY_OFFSET SET	0
      5  30ad				   VAR_BOUNDARY_aiBeginSelectMovePhase SET	TEMPORARY_OFFSET
      6  30ad				   FUNCTION_NAME SET	aiBeginSelectMovePhase
      7  30ad					      SUBROUTINE
    223  30ad					      SUBROUTINE
    224  30ad
      0  30ad					      REFER	AiStateMachine
      1  30ad				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  30ad				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  30ad					      ENDIF
      0  30ad					      VEND	aiBeginSelectMovePhase
      1  30ad				  -	      IFNCONST	aiBeginSelectMovePhase
      2  30ad				  -	      ECHO	"Incorrect VEND label", aiBeginSelectMovePhase
      3  30ad				  -	      ERR
      4  30ad					      ENDIF
      5  30ad		       00 a2	   VAREND_aiBeginSelectMovePhase =	TEMPORARY_VAR
    227  30ad
    228  30ad		       a9 38		      lda	#$38
    229  30af		       85 88		      sta	cursorX12
    230  30b1
    231  30b1		       a9 00		      lda	#0
    232  30b3		       85 89		      sta	mdelay	;?
    233  30b5		       85 8f		      sta	aiFlashPhase	;?
    234  30b7
    235  30b7		       a9 ff		      lda	#-1
    236  30b9		       85 85		      sta	fromX12
    237  30bb		       85 86		      sta	toX12
    238  30bd
      0  30bd					      PHASE	AI_SelectStartSquare
      1  30bd		       a9 01		      lda	#AI_SelectStartSquare
      2  30bf		       85 8c		      sta	aiState
    240  30c1		       60		      rts
    241  30c2
    242  30c2							;---------------------------------------------------------------------------------------------------
    243  30c2
      0  30c2					      DEF	aiSelectStartSquare
      1  30c2				   BANK_aiSelectStartSquare SET	_CURRENT_BANK
      2  30c2				   aiSelectStartSquare
      3  30c2				   TEMPORARY_VAR SET	Overlay
      4  30c2				   TEMPORARY_OFFSET SET	0
      5  30c2				   VAR_BOUNDARY_aiSelectStartSquare SET	TEMPORARY_OFFSET
      6  30c2				   FUNCTION_NAME SET	aiSelectStartSquare
      7  30c2					      SUBROUTINE
    245  30c2					      SUBROUTINE
    246  30c2
      0  30c2					      REFER	AiStateMachine
      1  30c2				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  30c2				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  30c2					      ENDIF
      0  30c2					      VEND	aiSelectStartSquare
      1  30c2				  -	      IFNCONST	aiSelectStartSquare
      2  30c2				  -	      ECHO	"Incorrect VEND label", aiSelectStartSquare
      3  30c2				  -	      ERR
      4  30c2					      ENDIF
      5  30c2		       00 a2	   VAREND_aiSelectStartSquare =	TEMPORARY_VAR
    249  30c2
    250  30c2		       20 29 f2 	      jsr	moveCursor
    251  30c5		       20 58 fc 	      jsr	IsValidMoveFromSquare
    252  30c8
    253  30c8		       c6 8a		      dec	ccur	; pulse colour for valid squares
    254  30ca		       20 ed f0 	      jsr	setCursorColours
    255  30cd
    256  30cd		       98		      tya
    257  30ce		       05 4c		      ora	INPT4
    258  30d0		       30 04		      bmi	.exit	; illegal square or no button press
    259  30d2
      0  30d2					      PHASE	AI_StartSquareSelected
      1  30d2		       a9 02		      lda	#AI_StartSquareSelected
      2  30d4		       85 8c		      sta	aiState
    261  30d6
    262  30d6		       60	   .exit      rts
    263  30d7
    264  30d7							;---------------------------------------------------------------------------------------------------
    265  30d7
      0  30d7					      DEF	setCursorPriority
      1  30d7				   BANK_setCursorPriority SET	_CURRENT_BANK
      2  30d7				   setCursorPriority
      3  30d7				   TEMPORARY_VAR SET	Overlay
      4  30d7				   TEMPORARY_OFFSET SET	0
      5  30d7				   VAR_BOUNDARY_setCursorPriority SET	TEMPORARY_OFFSET
      6  30d7				   FUNCTION_NAME SET	setCursorPriority
      7  30d7					      SUBROUTINE
    267  30d7					      SUBROUTINE
    268  30d7
      0  30d7					      REFER	moveCursor
      1  30d7					      IF	VAREND_moveCursor > TEMPORARY_VAR
      2  30d7				   TEMPORARY_VAR SET	VAREND_moveCursor
      3  30d7					      ENDIF
      0  30d7					      VEND	setCursorPriority
      1  30d7				  -	      IFNCONST	setCursorPriority
      2  30d7				  -	      ECHO	"Incorrect VEND label", setCursorPriority
      3  30d7				  -	      ERR
      4  30d7					      ENDIF
      5  30d7		       00 a3	   VAREND_setCursorPriority =	TEMPORARY_VAR
    271  30d7
    272  30d7		       98		      tya
    273  30d8		       48		      pha
    274  30d9
    275  30d9		       a2 04		      ldx	#%100
    276  30db
    277  30db		       a4 88		      ldy	cursorX12
    278  30dd		       30 09		      bmi	.under
    279  30df		       20 34 fc 	      jsr	GetBoard
    280  30e2		       c9 00		      cmp	#0
    281  30e4		       d0 02		      bne	.under
    282  30e6		       a2 00		      ldx	#0
    283  30e8		       86 4a	   .under     stx	CTRLPF	; UNDER
    284  30ea
    285  30ea		       68		      pla
    286  30eb		       a8		      tay
    287  30ec		       60		      rts
    288  30ed
    289  30ed							;---------------------------------------------------------------------------------------------------
    290  30ed
      0  30ed					      DEF	setCursorColours
      1  30ed				   BANK_setCursorColours SET	_CURRENT_BANK
      2  30ed				   setCursorColours
      3  30ed				   TEMPORARY_VAR SET	Overlay
      4  30ed				   TEMPORARY_OFFSET SET	0
      5  30ed				   VAR_BOUNDARY_setCursorColours SET	TEMPORARY_OFFSET
      6  30ed				   FUNCTION_NAME SET	setCursorColours
      7  30ed					      SUBROUTINE
    292  30ed					      SUBROUTINE
    293  30ed
      0  30ed					      REFER	aiSelectStartSquare
      1  30ed				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  30ed				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  30ed					      ENDIF
      0  30ed					      REFER	aiDrawMoves
      1  30ed				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  30ed				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  30ed					      ENDIF
      0  30ed					      REFER	aiUnDrawTargetSquares
      1  30ed				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  30ed				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  30ed					      ENDIF
      0  30ed					      REFER	aiShowMoveCaptures
      1  30ed				  -	      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  30ed				  -TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  30ed					      ENDIF
      0  30ed					      REFER	aiSlowFlash
      1  30ed				  -	      IF	VAREND_aiSlowFlash > TEMPORARY_VAR
      2  30ed				  -TEMPORARY_VAR SET	VAREND_aiSlowFlash
      3  30ed					      ENDIF
      0  30ed					      REFER	aiSelectDestinationSquare
      1  30ed				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  30ed				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  30ed					      ENDIF
      0  30ed					      VEND	setCursorColours
      1  30ed				  -	      IFNCONST	setCursorColours
      2  30ed				  -	      ECHO	"Incorrect VEND label", setCursorColours
      3  30ed				  -	      ERR
      4  30ed					      ENDIF
      5  30ed		       00 a2	   VAREND_setCursorColours =	TEMPORARY_VAR
    301  30ed
    302  30ed							; pass y=-1 if move is NOT in the movelist
    303  30ed							; preserve y
    304  30ed
    305  30ed		       a9 44		      lda	#$44
    306  30ef
    307  30ef		       c0 ff		      cpy	#-1
    308  30f1		       f0 0a		      beq	.writeCursorCol	; NOT in the movelist
    309  30f3
    310  30f3		       a5 8a		      lda	ccur
    311  30f5		       4a		      lsr
    312  30f6		       4a		      lsr
    313  30f7		       4a		      lsr
    314  30f8		       29 03		      and	#3
    315  30fa		       18		      clc
    316  30fb		       69 c0		      adc	#$C0	;COLOUR_LINE_1
    317  30fd
    318  30fd		       85 46	   .writeCursorCol sta	COLUP0
    319  30ff		       60		      rts
    320  3100
    321  3100
    322  3100							;---------------------------------------------------------------------------------------------------
    323  3100
    324  3100							;	    RLDU RLD  RL U RL	R DU R D  R  U R     LDU  LD   L U  L	  DU   D     U
    325  3100							;	    0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    326  3100
      0  3100					      ALLOCATE	JoyCombined, 16
      0  3100					      OPTIONAL_PAGEBREAK	"Table", 16
     12  3100					      LIST	ON
      0  3100					      DEF	JoyCombined
      1  3100				   BANK_JoyCombined SET	_CURRENT_BANK
      2  3100				   JoyCombined
      3  3100				   TEMPORARY_VAR SET	Overlay
      4  3100				   TEMPORARY_OFFSET SET	0
      5  3100				   VAR_BOUNDARY_JoyCombined SET	TEMPORARY_OFFSET
      6  3100				   FUNCTION_NAME SET	JoyCombined
      7  3100					      SUBROUTINE
    328  3100		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, -1, 0
    329  3110
      0  3110					      ALLOCATE	JoyMoveCursor, 16
      0  3110					      OPTIONAL_PAGEBREAK	"Table", 16
     12  3110					      LIST	ON
      0  3110					      DEF	JoyMoveCursor
      1  3110				   BANK_JoyMoveCursor SET	_CURRENT_BANK
      2  3110				   JoyMoveCursor
      3  3110				   TEMPORARY_VAR SET	Overlay
      4  3110				   TEMPORARY_OFFSET SET	0
      5  3110				   VAR_BOUNDARY_JoyMoveCursor SET	TEMPORARY_OFFSET
      6  3110				   FUNCTION_NAME SET	JoyMoveCursor
      7  3110					      SUBROUTINE
    331  3110		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, -9, 11, 1, 0, -11, 9, -1, 0, -10, 10, 0
    332  3120
    333  3120
    334  3120							;---------------------------------------------------------------------------------------------------
    335  3120
      0  3120					      DEF	aiStartSquareSelected
      1  3120				   BANK_aiStartSquareSelected SET	_CURRENT_BANK
      2  3120				   aiStartSquareSelected
      3  3120				   TEMPORARY_VAR SET	Overlay
      4  3120				   TEMPORARY_OFFSET SET	0
      5  3120				   VAR_BOUNDARY_aiStartSquareSelected SET	TEMPORARY_OFFSET
      6  3120				   FUNCTION_NAME SET	aiStartSquareSelected
      7  3120					      SUBROUTINE
    337  3120					      SUBROUTINE
    338  3120
      0  3120					      REFER	AiStateMachine
      1  3120				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3120				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3120					      ENDIF
      0  3120					      VEND	aiStartSquareSelected
      1  3120				  -	      IFNCONST	aiStartSquareSelected
      2  3120				  -	      ECHO	"Incorrect VEND label", aiStartSquareSelected
      3  3120				  -	      ERR
      4  3120					      ENDIF
      5  3120		       00 a2	   VAREND_aiStartSquareSelected =	TEMPORARY_VAR
    341  3120
    342  3120
    343  3120							; Mark all the valid moves for the selected piece on the board
    344  3120							; and then start pulsing the piece
    345  3120							; AND start choosing for selection of TO square
    346  3120
    347  3120							; Iterate the movelist and for all from squares which = drawPieceNumber
    348  3120							; then draw a BLANK at that square
    349  3120							; do 1 by one, when none found then increment state
    350  3120
    351  3120		       a5 88		      lda	cursorX12
    352  3122		       85 80		      sta	squareToDraw
    353  3124
    354  3124		       a9 0a		      lda	#10
    355  3126		       85 8d		      sta	aiFlashDelay
    356  3128
    357  3128		       a9 00		      lda	#0
    358  312a		       85 86		      sta	toX12	;aiToSquareX12
    359  312c		       85 8f		      sta	aiFlashPhase	; for debounce exit timing
    360  312e
    361  312e		       a9 ff		      lda	#-1
    362  3130		       85 8e		      sta	aiMoveIndex
    363  3132
    364  3132		       a9 28		      lda	#HOLD_DELAY
    365  3134		       85 89		      sta	mdelay	; hold-down delay before moves are shown
    366  3136
      0  3136					      PHASE	AI_DrawMoves
      1  3136		       a9 03		      lda	#AI_DrawMoves
      2  3138		       85 8c		      sta	aiState
    368  313a		       60		      rts
    369  313b
    370  313b
    371  313b							;---------------------------------------------------------------------------------------------------
    372  313b
      0  313b					      DEF	aiDrawMoves
      1  313b				   BANK_aiDrawMoves SET	_CURRENT_BANK
      2  313b				   aiDrawMoves
      3  313b				   TEMPORARY_VAR SET	Overlay
      4  313b				   TEMPORARY_OFFSET SET	0
      5  313b				   VAR_BOUNDARY_aiDrawMoves SET	TEMPORARY_OFFSET
      6  313b				   FUNCTION_NAME SET	aiDrawMoves
      7  313b					      SUBROUTINE
    374  313b					      SUBROUTINE
    375  313b
      0  313b					      REFER	AiStateMachine
      1  313b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  313b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  313b					      ENDIF
      0  313b					      VEND	aiDrawMoves
      1  313b				  -	      IFNCONST	aiDrawMoves
      2  313b				  -	      ECHO	"Incorrect VEND label", aiDrawMoves
      3  313b				  -	      ERR
      4  313b					      ENDIF
      5  313b		       00 a2	   VAREND_aiDrawMoves =	TEMPORARY_VAR
    378  313b
    379  313b		       c6 8a		      dec	ccur
    380  313d		       20 ed f0 	      jsr	setCursorColours
    381  3140
    382  3140		       c6 89		      dec	mdelay
    383  3142		       d0 21		      bne	.exit
    384  3144		       a9 01		      lda	#1	; larger number will slow the draw of available moves
    385  3146		       85 89		      sta	mdelay	; once triggered, runs always
    386  3148
    387  3148		       a5 8e		      lda	aiMoveIndex
    388  314a		       10 05		      bpl	.valid
    389  314c		       20 e0 fc 	      jsr	SAFE_getMoveIndex
    390  314f		       85 8e		      sta	aiMoveIndex
    391  3151				   .valid
    392  3151
    393  3151		       20 72 f1 	      jsr	SAFE_showMoveOptions	; draw potential moves one at a time
    394  3154		       a5 8e		      lda	aiMoveIndex
    395  3156		       10 19		      bpl	.unsure	; still drawing in this phase
    396  3158
    397  3158		       a9 14		      lda	#CAP_SPEED
    398  315a		       85 89		      sta	mdelay
    399  315c
    400  315c		       a9 00		      lda	#0
    401  315e		       85 8f		      sta	aiFlashPhase	; controls odd/even exit of flashing
    402  3160
      0  3160					      PHASE	AI_ShowMoveCaptures
      1  3160		       a9 04		      lda	#AI_ShowMoveCaptures
      2  3162		       85 8c		      sta	aiState
    404  3164		       60		      rts
    405  3165
    406  3165				   .exit
    407  3165
    408  3165							; Initial piece selection has happened, but the button hasn't been released yet
    409  3165							; AND we're still in the waiting phase to see if the button was held long enough for move show
    410  3165
    411  3165		       a5 4c		      lda	INPT4
    412  3167		       10 08		      bpl	.unsure	; button still pressed, so still unsure what to do
    413  3169
    414  3169							; Aha! Button released, so we know the selected piece and can start flashing it
    415  3169							; and allowing movement of the selector to a destination square...
    416  3169
    417  3169		       a9 18		      lda	#6*4
    418  316b		       85 8a		      sta	ccur	; bright green square for selection
    419  316d
      0  316d					      PHASE	AI_SelectDestinationSquare
      1  316d		       a9 07		      lda	#AI_SelectDestinationSquare
      2  316f		       85 8c		      sta	aiState
    421  3171
    422  3171		       60	   .unsure    rts
    423  3172
    424  3172
    425  3172							;---------------------------------------------------------------------------------------------------
    426  3172
      0  3172					      DEF	SAFE_showMoveOptions
      1  3172				   BANK_SAFE_showMoveOptions SET	_CURRENT_BANK
      2  3172				   SAFE_showMoveOptions
      3  3172				   TEMPORARY_VAR SET	Overlay
      4  3172				   TEMPORARY_OFFSET SET	0
      5  3172				   VAR_BOUNDARY_SAFE_showMoveOptions SET	TEMPORARY_OFFSET
      6  3172				   FUNCTION_NAME SET	SAFE_showMoveOptions
      7  3172					      SUBROUTINE
    428  3172					      SUBROUTINE
    429  3172
      0  3172					      REFER	aiDrawMoves
      1  3172				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  3172				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  3172					      ENDIF
      0  3172					      REFER	aiUnDrawTargetSquares
      1  3172				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  3172				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  3172					      ENDIF
      0  3172					      VAR	__saveIdx, 1
      1  3172		       00 a2	   __saveIdx  =	TEMPORARY_VAR
      2  3172				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  3172
      4  3172				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  3172				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  3172				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  3172					      ENDIF
      8  3172				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  3172				  -	      ECHO	"Temporary Variable", __saveIdx, "overflow!"
     10  3172				  -	      ERR
     11  3172					      ENDIF
     12  3172					      LIST	ON
      0  3172					      VAR	__piece, 1
      1  3172		       00 a3	   __piece    =	TEMPORARY_VAR
      2  3172				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  3172
      4  3172				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  3172				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  3172				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  3172					      ENDIF
      8  3172				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  3172				  -	      ECHO	"Temporary Variable", __piece, "overflow!"
     10  3172				  -	      ERR
     11  3172					      ENDIF
     12  3172					      LIST	ON
      0  3172					      VEND	SAFE_showMoveOptions
      1  3172				  -	      IFNCONST	SAFE_showMoveOptions
      2  3172				  -	      ECHO	"Incorrect VEND label", SAFE_showMoveOptions
      3  3172				  -	      ERR
      4  3172					      ENDIF
      5  3172		       00 a4	   VAREND_SAFE_showMoveOptions =	TEMPORARY_VAR
    435  3172
    436  3172							; place a marker on the board for any square matching the piece
    437  3172							; EXCEPT for squares which are occupied (we'll flash those later)
    438  3172
    439  3172		       a6 8e	   .next      ldx	aiMoveIndex
    440  3174		       86 a2		      stx	__saveIdx
    441  3176		       30 47		      bmi	.skip
    442  3178
    443  3178		       ad 84 02 	      lda	INTIM
    444  317b		       c9 05		      cmp	#5
    445  317d		       90 40		      bcc	.skip
    446  317f
    447  317f		       c6 8e		      dec	aiMoveIndex
    448  3181
    449  3181		       20 1c fd 	      jsr	GetMoveFrom
    450  3184		       c5 85		      cmp	fromX12
    451  3186		       d0 ea		      bne	.next
    452  3188
    453  3188		       20 28 fd 	      jsr	GetMoveTo
    454  318b		       85 80		      sta	squareToDraw
    455  318d
    456  318d		       20 34 fd 	      jsr	GetMovePiece
    457  3190		       85 a3		      sta	__piece
    458  3192
    459  3192							; If it's a pawn promote (duplicate "to" AND piece different (TODO) then skip others)
    460  3192
    461  3192		       ca	   .sk	      dex
    462  3193		       30 16		      bmi	.prom
    463  3195		       20 28 fd 	      jsr	GetMoveTo
    464  3198		       c5 80		      cmp	squareToDraw
    465  319a		       d0 0f		      bne	.prom
    466  319c		       20 34 fd 	      jsr	GetMovePiece
    467  319f		       45 a3		      eor	__piece
    468  31a1		       29 0f		      and	#PIECE_MASK
    469  31a3		       f0 06		      beq	.prom	; same piece type so not a promote
    470  31a5
    471  31a5		       c6 8e		      dec	aiMoveIndex
    472  31a7		       c6 8e		      dec	aiMoveIndex
    473  31a9		       c6 8e		      dec	aiMoveIndex
    474  31ab				   .prom
    475  31ab
    476  31ab		       a4 80		      ldy	squareToDraw
    477  31ad		       20 34 fc 	      jsr	GetBoard
    478  31b0		       29 0f		      and	#PIECE_MASK
    479  31b2		       d0 be		      bne	.next	; don't draw dots on captures - they are flashed later
    480  31b4
    481  31b4
    482  31b4		       ad 84 02 	      lda	INTIM
    483  31b7		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    484  31b9		       90 04		      bcc	.skip
    485  31bb
    486  31bb							;lda aiMoveIndex
    487  31bb							;sta __saveIdx
    488  31bb
    489  31bb		       20 ec fc 	      jsr	markerDraw
    490  31be		       60		      rts
    491  31bf
    492  31bf		       a5 a2	   .skip      lda	__saveIdx
    493  31c1		       85 8e		      sta	aiMoveIndex
    494  31c3		       60		      rts
    495  31c4
    496  31c4
    497  31c4							;---------------------------------------------------------------------------------------------------
    498  31c4
      0  31c4					      DEF	aiUnDrawTargetSquares
      1  31c4				   BANK_aiUnDrawTargetSquares SET	_CURRENT_BANK
      2  31c4				   aiUnDrawTargetSquares
      3  31c4				   TEMPORARY_VAR SET	Overlay
      4  31c4				   TEMPORARY_OFFSET SET	0
      5  31c4				   VAR_BOUNDARY_aiUnDrawTargetSquares SET	TEMPORARY_OFFSET
      6  31c4				   FUNCTION_NAME SET	aiUnDrawTargetSquares
      7  31c4					      SUBROUTINE
    500  31c4					      SUBROUTINE
    501  31c4
      0  31c4					      REFER	AiStateMachine
      1  31c4				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  31c4				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  31c4					      ENDIF
      0  31c4					      VEND	aiUnDrawTargetSquares
      1  31c4				  -	      IFNCONST	aiUnDrawTargetSquares
      2  31c4				  -	      ECHO	"Incorrect VEND label", aiUnDrawTargetSquares
      3  31c4				  -	      ERR
      4  31c4					      ENDIF
      5  31c4		       00 a2	   VAREND_aiUnDrawTargetSquares =	TEMPORARY_VAR
    504  31c4
    505  31c4
    506  31c4		       c6 8a		      dec	ccur
    507  31c6		       20 ed f0 	      jsr	setCursorColours
    508  31c9
    509  31c9		       c6 89		      dec	mdelay
    510  31cb		       d0 18		      bne	.exit
    511  31cd		       a9 01		      lda	#1
    512  31cf		       85 89		      sta	mdelay	; once triggered, runs always
    513  31d1
    514  31d1		       a5 8e		      lda	aiMoveIndex
    515  31d3		       10 05		      bpl	.valid
    516  31d5		       20 e0 fc 	      jsr	SAFE_getMoveIndex
    517  31d8		       85 8e		      sta	aiMoveIndex
    518  31da				   .valid
    519  31da
    520  31da		       20 72 f1 	      jsr	SAFE_showMoveOptions	; draw potential moves one at a time
    521  31dd		       a5 8e		      lda	aiMoveIndex
    522  31df		       10 04		      bpl	.exit	; still drawing in this phase
    523  31e1
      0  31e1					      PHASE	AI_SelectStartSquare
      1  31e1		       a9 01		      lda	#AI_SelectStartSquare
      2  31e3		       85 8c		      sta	aiState
    525  31e5
    526  31e5		       60	   .exit      rts
    527  31e6
    528  31e6
    529  31e6							;---------------------------------------------------------------------------------------------------
    530  31e6
    531  31e6
      0  31e6					      DEF	aiShowMoveCaptures
      1  31e6				   BANK_aiShowMoveCaptures SET	_CURRENT_BANK
      2  31e6				   aiShowMoveCaptures
      3  31e6				   TEMPORARY_VAR SET	Overlay
      4  31e6				   TEMPORARY_OFFSET SET	0
      5  31e6				   VAR_BOUNDARY_aiShowMoveCaptures SET	TEMPORARY_OFFSET
      6  31e6				   FUNCTION_NAME SET	aiShowMoveCaptures
      7  31e6					      SUBROUTINE
    533  31e6					      SUBROUTINE
    534  31e6
      0  31e6					      REFER	AiStateMachine
      1  31e6				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  31e6				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  31e6					      ENDIF
      0  31e6					      VEND	aiShowMoveCaptures
      1  31e6				  -	      IFNCONST	aiShowMoveCaptures
      2  31e6				  -	      ECHO	"Incorrect VEND label", aiShowMoveCaptures
      3  31e6				  -	      ERR
      4  31e6					      ENDIF
      5  31e6		       00 a2	   VAREND_aiShowMoveCaptures =	TEMPORARY_VAR
    537  31e6
    538  31e6							; draw/undraw ALL captured pieces
    539  31e6							; we should do this an even number of times so that pieces don't disappEOR
    540  31e6
    541  31e6		       c6 8a		      dec	ccur
    542  31e8		       20 ed f0 	      jsr	setCursorColours
    543  31eb
    544  31eb		       c6 89		      dec	mdelay	; flash speed UNVARYING despite draw happening
    545  31ed
    546  31ed		       a5 8e		      lda	aiMoveIndex
    547  31ef		       10 05		      bpl	.valid	; guaranteed -1 on 1st call
    548  31f1		       20 e0 fc 	      jsr	SAFE_getMoveIndex
    549  31f4		       85 8e		      sta	aiMoveIndex
    550  31f6				   .valid
    551  31f6
    552  31f6		       20 10 fd 	      jsr	SAFE_showMoveCaptures
    553  31f9		       a5 8e		      lda	aiMoveIndex
    554  31fb		       10 06		      bpl	.exit
    555  31fd
    556  31fd		       e6 8f		      inc	aiFlashPhase
    557  31ff
      0  31ff					      PHASE	AI_SlowFlash
      1  31ff		       a9 05		      lda	#AI_SlowFlash
      2  3201		       85 8c		      sta	aiState
    559  3203
    560  3203		       60	   .exit      rts
    561  3204
    562  3204
    563  3204							;---------------------------------------------------------------------------------------------------
    564  3204
      0  3204					      DEF	aiSlowFlash
      1  3204				   BANK_aiSlowFlash SET	_CURRENT_BANK
      2  3204				   aiSlowFlash
      3  3204				   TEMPORARY_VAR SET	Overlay
      4  3204				   TEMPORARY_OFFSET SET	0
      5  3204				   VAR_BOUNDARY_aiSlowFlash SET	TEMPORARY_OFFSET
      6  3204				   FUNCTION_NAME SET	aiSlowFlash
      7  3204					      SUBROUTINE
    566  3204					      SUBROUTINE
    567  3204
      0  3204					      REFER	AiStateMachine
      1  3204				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3204				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3204					      ENDIF
      0  3204					      VEND	aiSlowFlash
      1  3204				  -	      IFNCONST	aiSlowFlash
      2  3204				  -	      ECHO	"Incorrect VEND label", aiSlowFlash
      3  3204				  -	      ERR
      4  3204					      ENDIF
      5  3204		       00 a2	   VAREND_aiSlowFlash =	TEMPORARY_VAR
    570  3204
    571  3204							; Joystick button is held down, so we're displaying the available moves
    572  3204							; They have all been drawn, so now we "slow" flash any pieces that can be captures
    573  3204
    574  3204		       c6 8a		      dec	ccur
    575  3206		       20 ed f0 	      jsr	setCursorColours
    576  3209
    577  3209		       a5 8f		      lda	aiFlashPhase
    578  320b		       29 01		      and	#1
    579  320d		       d0 04		      bne	.notEven	; only exit after even # EOR-draws
    580  320f
    581  320f		       a5 4c		      lda	INPT4
    582  3211		       30 0d		      bmi	.butpress	; exit on button release
    583  3213
    584  3213				   .notEven
    585  3213
    586  3213							; Wait for delay to expire then back and flash 'em again
    587  3213
    588  3213		       c6 89		      dec	mdelay
    589  3215		       10 08		      bpl	.slowWait
    590  3217
    591  3217		       a9 14		      lda	#CAP_SPEED
    592  3219		       85 89		      sta	mdelay
    593  321b
      0  321b					      PHASE	AI_ShowMoveCaptures	; go back and rEORdraw all captures again
      1  321b		       a9 04		      lda	#AI_ShowMoveCaptures
      2  321d		       85 8c		      sta	aiState
    595  321f
    596  321f		       60	   .slowWait  rts
    597  3220
    598  3220
    599  3220		       a9 01	   .butpress  lda	#1
    600  3222		       85 89		      sta	mdelay
    601  3224
      0  3224					      PHASE	AI_UnDrawTargetSquares
      1  3224		       a9 06		      lda	#AI_UnDrawTargetSquares
      2  3226		       85 8c		      sta	aiState
    603  3228		       60		      rts
    604  3229
    605  3229
    606  3229							;---------------------------------------------------------------------------------------------------
    607  3229
      0  3229					      DEF	moveCursor
      1  3229				   BANK_moveCursor SET	_CURRENT_BANK
      2  3229				   moveCursor
      3  3229				   TEMPORARY_VAR SET	Overlay
      4  3229				   TEMPORARY_OFFSET SET	0
      5  3229				   VAR_BOUNDARY_moveCursor SET	TEMPORARY_OFFSET
      6  3229				   FUNCTION_NAME SET	moveCursor
      7  3229					      SUBROUTINE
    609  3229					      SUBROUTINE
    610  3229
      0  3229					      REFER	aiSelectStartSquare
      1  3229				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  3229				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  3229					      ENDIF
      0  3229					      REFER	aiSelectDestinationSquare
      1  3229				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  3229				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  3229					      ENDIF
      0  3229					      VAR	__newCursor, 1
      1  3229		       00 a2	   __newCursor =	TEMPORARY_VAR
      2  3229				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  3229
      4  3229				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  3229				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  3229				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  3229					      ENDIF
      8  3229				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  3229				  -	      ECHO	"Temporary Variable", __newCursor, "overflow!"
     10  3229				  -	      ERR
     11  3229					      ENDIF
     12  3229					      LIST	ON
      0  3229					      VEND	moveCursor
      1  3229				  -	      IFNCONST	moveCursor
      2  3229				  -	      ECHO	"Incorrect VEND label", moveCursor
      3  3229				  -	      ERR
      4  3229					      ENDIF
      5  3229		       00 a3	   VAREND_moveCursor =	TEMPORARY_VAR
    615  3229
    616  3229							; Part (a) move cursor around the board waiting for joystick press
    617  3229
    618  3229
    619  3229		       ad 80 02 	      lda	SWCHA
    620  322c		       4a		      lsr
    621  322d		       4a		      lsr
    622  322e		       4a		      lsr
    623  322f		       4a		      lsr
    624  3230		       a8		      tay
    625  3231
    626  3231		       c9 0f		      cmp	#15
    627  3233		       f0 20		      beq	.cursor	; nothing pressed - skip delays
    628  3235
    629  3235		       c6 89		      dec	mdelay
    630  3237		       10 23		      bpl	.delaym
    631  3239
    632  3239		       18		      clc
    633  323a		       a5 88		      lda	cursorX12
    634  323c		       79 10 f1 	      adc	JoyMoveCursor,y
    635  323f		       85 a2		      sta	__newCursor
    636  3241		       a8		      tay
    637  3242		       20 28 fc 	      jsr	GetValid
    638  3245		       c9 ff		      cmp	#-1
    639  3247		       f0 04		      beq	.invalid
    640  3249		       a5 a2		      lda	__newCursor
    641  324b		       85 88		      sta	cursorX12
    642  324d				   .invalid
    643  324d
    644  324d		       a9 10		      lda	#CURSOR_MOVE_SPEED
    645  324f		       85 89		      sta	mdelay
    646  3251		       20 d7 f0 	      jsr	setCursorPriority
    647  3254		       60		      rts
    648  3255
    649  3255
    650  3255		       a9 00	   .cursor    lda	#0
    651  3257		       85 89		      sta	mdelay
    652  3259		       20 d7 f0 	      jsr	setCursorPriority
    653  325c
    654  325c		       60	   .delaym    rts
    655  325d
    656  325d
    657  325d							;---------------------------------------------------------------------------------------------------
    658  325d
      0  325d					      DEF	FlashPiece
      1  325d				   BANK_FlashPiece SET	_CURRENT_BANK
      2  325d				   FlashPiece
      3  325d				   TEMPORARY_VAR SET	Overlay
      4  325d				   TEMPORARY_OFFSET SET	0
      5  325d				   VAR_BOUNDARY_FlashPiece SET	TEMPORARY_OFFSET
      6  325d				   FUNCTION_NAME SET	FlashPiece
      7  325d					      SUBROUTINE
    660  325d					      SUBROUTINE
    661  325d
      0  325d					      REFER	aiSelectDestinationSquare
      1  325d				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  325d				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  325d					      ENDIF
      0  325d					      VEND	FlashPiece
      1  325d				  -	      IFNCONST	FlashPiece
      2  325d				  -	      ECHO	"Incorrect VEND label", FlashPiece
      3  325d				  -	      ERR
      4  325d					      ENDIF
      5  325d		       00 a2	   VAREND_FlashPiece =	TEMPORARY_VAR
    664  325d
    665  325d							; Flash the selected piece
    666  325d
    667  325d		       c6 8d		      dec	aiFlashDelay
    668  325f		       d0 09		      bne	.exit	; don't flash
    669  3261		       a9 14		      lda	#CAP_SPEED
    670  3263		       85 8d		      sta	aiFlashDelay
    671  3265
    672  3265		       e6 8f		      inc	aiFlashPhase
    673  3267
    674  3267		       20 a4 fc 	      jsr	CopySinglePiece
    675  326a
    676  326a		       60	   .exit      rts
    677  326b
    678  326b
    679  326b							;---------------------------------------------------------------------------------------------------
    680  326b
      0  326b					      DEF	aiSelectDestinationSquare
      1  326b				   BANK_aiSelectDestinationSquare SET	_CURRENT_BANK
      2  326b				   aiSelectDestinationSquare
      3  326b				   TEMPORARY_VAR SET	Overlay
      4  326b				   TEMPORARY_OFFSET SET	0
      5  326b				   VAR_BOUNDARY_aiSelectDestinationSquare SET	TEMPORARY_OFFSET
      6  326b				   FUNCTION_NAME SET	aiSelectDestinationSquare
      7  326b					      SUBROUTINE
    682  326b					      SUBROUTINE
    683  326b
      0  326b					      REFER	AiStateMachine
      1  326b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  326b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  326b					      ENDIF
      0  326b					      VEND	aiSelectDestinationSquare
      1  326b				  -	      IFNCONST	aiSelectDestinationSquare
      2  326b				  -	      ECHO	"Incorrect VEND label", aiSelectDestinationSquare
      3  326b				  -	      ERR
      4  326b					      ENDIF
      5  326b		       00 a2	   VAREND_aiSelectDestinationSquare =	TEMPORARY_VAR
    686  326b
    687  326b							; Piece is selected and now we're looking for a button press on a destination square
    688  326b							; we flash the piece on-and-off while we're doing that
    689  326b
    690  326b		       20 5d f2 	      jsr	FlashPiece
    691  326e
    692  326e		       ad 84 02 	      lda	INTIM
    693  3271		       c9 14		      cmp	#20
    694  3273		       90 38		      bcc	.noButton
    695  3275
    696  3275		       20 29 f2 	      jsr	moveCursor
    697  3278
    698  3278		       a4 88		      ldy	cursorX12
    699  327a		       84 86		      sty	toX12
    700  327c
    701  327c		       20 68 fc 	      jsr	GetPiece
    702  327f		       20 ed f0 	      jsr	setCursorColours
    703  3282
    704  3282
    705  3282							; y = valid square
    706  3282
    707  3282		       a5 4c		      lda	INPT4
    708  3284		       30 27		      bmi	.noButton
    709  3286
    710  3286		       a5 86		      lda	toX12
    711  3288		       c5 85		      cmp	fromX12
    712  328a		       f0 0d		      beq	.cancel
    713  328c
    714  328c		       c0 ff		      cpy	#-1
    715  328e		       f0 1d		      beq	.noButton	; not a valid square
    716  3290
    717  3290		       a5 8f		      lda	aiFlashPhase
    718  3292		       29 01		      and	#1
    719  3294		       f0 13		      beq	.done
    720  3296		       85 8d		      sta	aiFlashDelay	; EOR-phase incorrect - force quick fix to allow next-frame button detect
    721  3298		       60		      rts
    722  3299
    723  3299				   .cancel
    724  3299
    725  3299		       a5 8f		      lda	aiFlashPhase
    726  329b		       29 01		      and	#1
    727  329d		       f0 05		      beq	.doCancel
    728  329f
    729  329f							; EOR-phase incorrect - force quick fix to allow next-frame button detect
    730  329f
    731  329f		       a9 01		      lda	#1
    732  32a1		       85 8d		      sta	aiFlashDelay
    733  32a3		       60		      rts
    734  32a4
    735  32a4
      0  32a4				   .doCancel  PHASE	AI_ReselectDebounce
      1  32a4		       a9 09		      lda	#AI_ReselectDebounce
      2  32a6		       85 8c		      sta	aiState
    737  32a8		       60		      rts
    738  32a9
      0  32a9				   .done      PHASE	AI_Quiescent	; destination selected!
      1  32a9		       a9 08		      lda	#AI_Quiescent
      2  32ab		       85 8c		      sta	aiState
    740  32ad		       60	   .noButton  rts
    741  32ae
    742  32ae
    743  32ae							;---------------------------------------------------------------------------------------------------
    744  32ae
      0  32ae					      DEF	aiReselectDebounce
      1  32ae				   BANK_aiReselectDebounce SET	_CURRENT_BANK
      2  32ae				   aiReselectDebounce
      3  32ae				   TEMPORARY_VAR SET	Overlay
      4  32ae				   TEMPORARY_OFFSET SET	0
      5  32ae				   VAR_BOUNDARY_aiReselectDebounce SET	TEMPORARY_OFFSET
      6  32ae				   FUNCTION_NAME SET	aiReselectDebounce
      7  32ae					      SUBROUTINE
    746  32ae					      SUBROUTINE
    747  32ae
      0  32ae					      REFER	AiStateMachine
      1  32ae				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  32ae				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  32ae					      ENDIF
      0  32ae					      VEND	aiReselectDebounce
      1  32ae				  -	      IFNCONST	aiReselectDebounce
      2  32ae				  -	      ECHO	"Incorrect VEND label", aiReselectDebounce
      3  32ae				  -	      ERR
      4  32ae					      ENDIF
      5  32ae		       00 a2	   VAREND_aiReselectDebounce =	TEMPORARY_VAR
    750  32ae
    751  32ae							; We've just cancelled the move. Wait for the button to be released
    752  32ae							; and then go back to selecting a piece to move
    753  32ae
    754  32ae		       a5 4c		      lda	INPT4
    755  32b0		       10 04		      bpl	.exit	; button still pressed, so wait
    756  32b2
      0  32b2					      PHASE	AI_SelectStartSquare
      1  32b2		       a9 01		      lda	#AI_SelectStartSquare
      2  32b4		       85 8c		      sta	aiState
    758  32b6		       60	   .exit      rts
    759  32b7
    760  32b7
    761  32b7							;---------------------------------------------------------------------------------------------------
    762  32b7
      0  32b7					      DEF	aiQuiescent
      1  32b7				   BANK_aiQuiescent SET	_CURRENT_BANK
      2  32b7				   aiQuiescent
      3  32b7				   TEMPORARY_VAR SET	Overlay
      4  32b7				   TEMPORARY_OFFSET SET	0
      5  32b7				   VAR_BOUNDARY_aiQuiescent SET	TEMPORARY_OFFSET
      6  32b7				   FUNCTION_NAME SET	aiQuiescent
      7  32b7					      SUBROUTINE
    764  32b7					      SUBROUTINE
    765  32b7
      0  32b7					      REFER	AiStateMachine
      1  32b7				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  32b7				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  32b7					      ENDIF
      0  32b7					      VEND	aiQuiescent
      1  32b7				  -	      IFNCONST	aiQuiescent
      2  32b7				  -	      ECHO	"Incorrect VEND label", aiQuiescent
      3  32b7				  -	      ERR
      4  32b7					      ENDIF
      5  32b7		       00 a2	   VAREND_aiQuiescent =	TEMPORARY_VAR
    768  32b7
    769  32b7							; Move has been selected
    770  32b7
    771  32b7		       a9 ff		      lda	#-1
    772  32b9		       85 88		      sta	cursorX12
    773  32bb
    774  32bb		       a5 85		      lda	fromX12
    775  32bd		       85 87		      sta	originX12
    776  32bf		       20 68 fc 	      jsr	GetPiece	; from the movelist
    777  32c2
    778  32c2		       a4 85		      ldy	fromX12
    779  32c4		       20 34 fc 	      jsr	GetBoard	; get the piece from the board itself
    780  32c7
    781  32c7		       45 98		      eor	fromPiece
    782  32c9		       29 0f		      and	#PIECE_MASK	; if not the same piece board/movelist...
    783  32cb		       d0 05		      bne	.promote	; promote a pawn
    784  32cd
      0  32cd					      PHASE	AI_MoveIsSelected
      1  32cd		       a9 15		      lda	#AI_MoveIsSelected
      2  32cf		       85 8c		      sta	aiState
    786  32d1		       60		      rts
    787  32d2
      0  32d2				   .promote   PHASE	AI_PromotePawnStart
      1  32d2		       a9 1f		      lda	#AI_PromotePawnStart
      2  32d4		       85 8c		      sta	aiState
    789  32d6		       60		      rts
    790  32d7
    791  32d7
    792  32d7							;---------------------------------------------------------------------------------------------------
    793  32d7
      0  32d7					      DEF	aiPromotePawnStart
      1  32d7				   BANK_aiPromotePawnStart SET	_CURRENT_BANK
      2  32d7				   aiPromotePawnStart
      3  32d7				   TEMPORARY_VAR SET	Overlay
      4  32d7				   TEMPORARY_OFFSET SET	0
      5  32d7				   VAR_BOUNDARY_aiPromotePawnStart SET	TEMPORARY_OFFSET
      6  32d7				   FUNCTION_NAME SET	aiPromotePawnStart
      7  32d7					      SUBROUTINE
    795  32d7					      SUBROUTINE
    796  32d7
      0  32d7					      REFER	AiStateMachine
      1  32d7				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  32d7				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  32d7					      ENDIF
      0  32d7					      VEND	aiPromotePawnStart
      1  32d7				  -	      IFNCONST	aiPromotePawnStart
      2  32d7				  -	      ECHO	"Incorrect VEND label", aiPromotePawnStart
      3  32d7				  -	      ERR
      4  32d7					      ENDIF
      5  32d7		       00 a2	   VAREND_aiPromotePawnStart =	TEMPORARY_VAR
    799  32d7
    800  32d7		       ad 84 02 	      lda	INTIM
    801  32da		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    802  32dc		       90 18		      bcc	.exit
    803  32de
    804  32de		       a9 00		      lda	#0
    805  32e0		       85 8f		      sta	aiFlashPhase
    806  32e2		       85 8d		      sta	aiFlashDelay
    807  32e4
    808  32e4		       a4 86		      ldy	toX12
    809  32e6		       84 80		      sty	squareToDraw
    810  32e8
    811  32e8		       20 34 fc 	      jsr	GetBoard
    812  32eb		       29 0f		      and	#PIECE_MASK
    813  32ed		       f0 03		      beq	.empty
    814  32ef
    815  32ef		       20 a4 fc 	      jsr	CopySinglePiece	; remove any capturable piece for display purposes
    816  32f2
      0  32f2				   .empty     PHASE	AI_RollPromotionPiece
      1  32f2		       a9 20		      lda	#AI_RollPromotionPiece
      2  32f4		       85 8c		      sta	aiState
    818  32f6		       60	   .exit      rts
    819  32f7
    820  32f7
    821  32f7							;---------------------------------------------------------------------------------------------------
    822  32f7
      0  32f7					      DEF	aiRollPromotionPiece
      1  32f7				   BANK_aiRollPromotionPiece SET	_CURRENT_BANK
      2  32f7				   aiRollPromotionPiece
      3  32f7				   TEMPORARY_VAR SET	Overlay
      4  32f7				   TEMPORARY_OFFSET SET	0
      5  32f7				   VAR_BOUNDARY_aiRollPromotionPiece SET	TEMPORARY_OFFSET
      6  32f7				   FUNCTION_NAME SET	aiRollPromotionPiece
      7  32f7					      SUBROUTINE
    824  32f7					      SUBROUTINE
    825  32f7
      0  32f7					      REFER	AiStateMachine
      1  32f7				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  32f7				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  32f7					      ENDIF
      0  32f7					      VEND	aiRollPromotionPiece
      1  32f7				  -	      IFNCONST	aiRollPromotionPiece
      2  32f7				  -	      ECHO	"Incorrect VEND label", aiRollPromotionPiece
      3  32f7				  -	      ERR
      4  32f7					      ENDIF
      5  32f7		       00 a2	   VAREND_aiRollPromotionPiece =	TEMPORARY_VAR
    828  32f7
    829  32f7							; Flash the '?' and wait for an UDLR move
    830  32f7
    831  32f7		       ad 84 02 	      lda	INTIM
    832  32fa		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    833  32fc		       90 28		      bcc	.exit
    834  32fe
    835  32fe		       ad 80 02 	      lda	SWCHA
    836  3301		       29 f0		      and	#$F0
    837  3303		       c9 f0		      cmp	#$F0
    838  3305		       f0 0a		      beq	.nojoy
    839  3307
    840  3307		       a9 00		      lda	#0
    841  3309		       85 8d		      sta	aiFlashDelay
    842  330b
    843  330b		       a5 8f		      lda	aiFlashPhase
    844  330d		       29 01		      and	#1
    845  330f		       f0 16		      beq	.even
    846  3311
    847  3311		       c6 8d	   .nojoy     dec	aiFlashDelay
    848  3313		       10 11		      bpl	.exit
    849  3315
    850  3315		       a9 0a		      lda	#10
    851  3317		       85 8d		      sta	aiFlashDelay
    852  3319
    853  3319		       a2 20		      ldx	#INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0
    854  331b		       a5 97		      lda	sideToMove
    855  331d		       10 02		      bpl	.wtm
    856  331f		       a2 68		      ldx	#INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0
    857  3321				   .wtm
    858  3321		       20 f8 fc 	      jsr	showPromoteOptions
    859  3324
    860  3324		       e6 8f		      inc	aiFlashPhase
    861  3326
    862  3326		       60	   .exit      rts
    863  3327
    864  3327
    865  3327		       a9 03	   .even      lda	#3	; QUEEN
    866  3329		       85 98		      sta	fromPiece	; cycles as index to NBRQ
    867  332b
    868  332b		       e6 8f		      inc	aiFlashPhase
    869  332d
    870  332d
    871  332d		       a2 14		      ldx	#INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0	;TODO: fix for colour
    872  332f		       a5 97		      lda	sideToMove
    873  3331		       10 02		      bpl	.whiteToMove
    874  3333		       a2 5c		      ldx	#INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    875  3335				   .whiteToMove
    876  3335
    877  3335		       20 f8 fc 	      jsr	showPromoteOptions
    878  3338
      0  3338					      PHASE	AI_ChooseDebounce
      1  3338		       a9 22		      lda	#AI_ChooseDebounce
      2  333a		       85 8c		      sta	aiState
    880  333c		       60		      rts
    881  333d
    882  333d
    883  333d							;---------------------------------------------------------------------------------------------------
    884  333d
      0  333d					      DEF	aiChoosePromotePiece
      1  333d				   BANK_aiChoosePromotePiece SET	_CURRENT_BANK
      2  333d				   aiChoosePromotePiece
      3  333d				   TEMPORARY_VAR SET	Overlay
      4  333d				   TEMPORARY_OFFSET SET	0
      5  333d				   VAR_BOUNDARY_aiChoosePromotePiece SET	TEMPORARY_OFFSET
      6  333d				   FUNCTION_NAME SET	aiChoosePromotePiece
      7  333d					      SUBROUTINE
    886  333d					      SUBROUTINE
    887  333d
      0  333d					      REFER	AiStateMachine
      1  333d				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  333d				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  333d					      ENDIF
      0  333d					      VEND	aiChoosePromotePiece
      1  333d				  -	      IFNCONST	aiChoosePromotePiece
      2  333d				  -	      ECHO	"Incorrect VEND label", aiChoosePromotePiece
      3  333d				  -	      ERR
      4  333d					      ENDIF
      5  333d		       00 a2	   VAREND_aiChoosePromotePiece =	TEMPORARY_VAR
    890  333d
    891  333d							; Question-mark phase has exited via joystick direction
    892  333d							; Now we cycle through the selectable pieces
    893  333d
    894  333d		       ad 84 02 	      lda	INTIM
    895  3340		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    896  3342		       90 40		      bcc	.exit
    897  3344
    898  3344		       a5 4c		      lda	INPT4
    899  3346		       30 0a		      bmi	.nobut	; no press
    900  3348
    901  3348							; button pressed but make sure phase is correct for exit
    902  3348
    903  3348		       a9 00		      lda	#0
    904  334a		       85 8d		      sta	aiFlashDelay
    905  334c
    906  334c		       a5 8f		      lda	aiFlashPhase
    907  334e		       29 01		      and	#1
    908  3350		       f0 33		      beq	.chosen	; button pressed --> selection made
    909  3352
    910  3352				   .nobut
    911  3352		       ad 80 02 	      lda	SWCHA
    912  3355		       29 f0		      and	#$F0
    913  3357		       c9 f0		      cmp	#$F0
    914  3359		       f0 17		      beq	.odd	; no direction pressed
    915  335b
    916  335b		       4a		      lsr
    917  335c		       4a		      lsr
    918  335d		       4a		      lsr
    919  335e		       4a		      lsr
    920  335f		       a8		      tay
    921  3360
    922  3360							; joystick but make sure phase is correct
    923  3360
    924  3360		       a5 8f		      lda	aiFlashPhase
    925  3362		       4a		      lsr
    926  3363		       b0 0d		      bcs	.odd	; must wait until piece undrawn
    927  3365
    928  3365							; cycle to the next promotable piece (N/B/R/Q)
    929  3365							; TODO; use joy table for mod instead of just incrementing all the time
    930  3365
    931  3365							;clc
    932  3365		       a5 98		      lda	fromPiece
    933  3367		       79 00 f1 	      adc	JoyCombined,y
    934  336a		       29 03		      and	#3
    935  336c		       85 98		      sta	fromPiece
    936  336e
      0  336e					      PHASE	AI_ChooseDebounce	; wait for release
      1  336e		       a9 22		      lda	#AI_ChooseDebounce
      2  3370		       85 8c		      sta	aiState
    938  3372
    939  3372		       c6 8d	   .odd       dec	aiFlashDelay
    940  3374		       10 0e		      bpl	.exit
    941  3376
    942  3376		       a9 0a	   .force     lda	#10
    943  3378		       85 8d		      sta	aiFlashDelay
    944  337a
    945  337a		       e6 8f		      inc	aiFlashPhase
    946  337c
    947  337c		       a4 98		      ldy	fromPiece
    948  337e		       be a0 f3 	      ldx	promotePiece,y
    949  3381		       20 f8 fc 	      jsr	showPromoteOptions
    950  3384
    951  3384		       60	   .exit      rts
    952  3385
    953  3385
    954  3385				   .chosen
    955  3385		       a5 98		      lda	fromPiece
    956  3387		       29 0f		      and	#PIECE_MASK
    957  3389		       aa		      tax
    958  338a
    959  338a		       bd a4 f3 	      lda	promoteType,x
    960  338d		       85 98		      sta	fromPiece
    961  338f
    962  338f		       a4 86		      ldy	toX12
    963  3391		       20 34 fc 	      jsr	GetBoard
    964  3394		       29 0f		      and	#PIECE_MASK
    965  3396		       f0 03		      beq	.nothing
    966  3398
    967  3398		       20 a4 fc 	      jsr	CopySinglePiece	; put back whatever was there to start
    968  339b
      0  339b				   .nothing   PHASE	AI_MoveIsSelected
      1  339b		       a9 15		      lda	#AI_MoveIsSelected
      2  339d		       85 8c		      sta	aiState
    970  339f		       60		      rts
    971  33a0
      0  33a0					      ALLOCATE	promotePiece, 4
      0  33a0					      OPTIONAL_PAGEBREAK	"Table", 4
     12  33a0					      LIST	ON
      0  33a0					      DEF	promotePiece
      1  33a0				   BANK_promotePiece SET	_CURRENT_BANK
      2  33a0				   promotePiece
      3  33a0				   TEMPORARY_VAR SET	Overlay
      4  33a0				   TEMPORARY_OFFSET SET	0
      5  33a0				   VAR_BOUNDARY_promotePiece SET	TEMPORARY_OFFSET
      6  33a0				   FUNCTION_NAME SET	promotePiece
      7  33a0					      SUBROUTINE
    973  33a0		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    974  33a1		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    975  33a2		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    976  33a3		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    977  33a4
      0  33a4					      ALLOCATE	promoteType,4
      0  33a4					      OPTIONAL_PAGEBREAK	"Table", 4
     12  33a4					      LIST	ON
      0  33a4					      DEF	promoteType
      1  33a4				   BANK_promoteType SET	_CURRENT_BANK
      2  33a4				   promoteType
      3  33a4				   TEMPORARY_VAR SET	Overlay
      4  33a4				   TEMPORARY_OFFSET SET	0
      5  33a4				   VAR_BOUNDARY_promoteType SET	TEMPORARY_OFFSET
      6  33a4				   FUNCTION_NAME SET	promoteType
      7  33a4					      SUBROUTINE
    979  33a4		       03 04 05 06	      .byte.b	KNIGHT, BISHOP, ROOK, QUEEN
    980  33a8
    981  33a8
    982  33a8							;---------------------------------------------------------------------------------------------------
    983  33a8
      0  33a8					      DEF	aiChooseDebounce
      1  33a8				   BANK_aiChooseDebounce SET	_CURRENT_BANK
      2  33a8				   aiChooseDebounce
      3  33a8				   TEMPORARY_VAR SET	Overlay
      4  33a8				   TEMPORARY_OFFSET SET	0
      5  33a8				   VAR_BOUNDARY_aiChooseDebounce SET	TEMPORARY_OFFSET
      6  33a8				   FUNCTION_NAME SET	aiChooseDebounce
      7  33a8					      SUBROUTINE
    985  33a8					      SUBROUTINE
    986  33a8
      0  33a8					      REFER	AiStateMachine
      1  33a8				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  33a8				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  33a8					      ENDIF
      0  33a8					      VEND	aiChooseDebounce
      1  33a8				  -	      IFNCONST	aiChooseDebounce
      2  33a8				  -	      ECHO	"Incorrect VEND label", aiChooseDebounce
      3  33a8				  -	      ERR
      4  33a8					      ENDIF
      5  33a8		       00 a2	   VAREND_aiChooseDebounce =	TEMPORARY_VAR
    989  33a8
    990  33a8							; We've changed promotion piece, but wait for joystick to be released
    991  33a8
    992  33a8		       ad 80 02 	      lda	SWCHA
    993  33ab		       29 f0		      and	#$F0
    994  33ad		       c9 f0		      cmp	#$F0
    995  33af		       d0 08		      bne	.exit	; wait while joystick still pressed
    996  33b1
    997  33b1		       a9 01		      lda	#1
    998  33b3		       85 8d		      sta	aiFlashDelay
    999  33b5
      0  33b5					      PHASE	AI_ChoosePromotePiece
      1  33b5		       a9 21		      lda	#AI_ChoosePromotePiece
      2  33b7		       85 8c		      sta	aiState
   1001  33b9		       60	   .exit      rts
   1002  33ba
   1003  33ba
   1004  33ba							;---------------------------------------------------------------------------------------------------
   1005  33ba
   1006  3400		       00 00 00 00*	      align	256
      0  3400					      DEF	PositionSprites
      1  3400				   BANK_PositionSprites SET	_CURRENT_BANK
      2  3400				   PositionSprites
      3  3400				   TEMPORARY_VAR SET	Overlay
      4  3400				   TEMPORARY_OFFSET SET	0
      5  3400				   VAR_BOUNDARY_PositionSprites SET	TEMPORARY_OFFSET
      6  3400				   FUNCTION_NAME SET	PositionSprites
      7  3400					      SUBROUTINE
   1008  3400					      SUBROUTINE
   1009  3400
      0  3400					      REFER	Reset
      1  3400				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  3400				  -TEMPORARY_VAR SET	VAREND_Reset
      3  3400					      ENDIF
      0  3400					      VEND	PositionSprites
      1  3400				  -	      IFNCONST	PositionSprites
      2  3400				  -	      ECHO	"Incorrect VEND label", PositionSprites
      3  3400				  -	      ERR
      4  3400					      ENDIF
      5  3400		       00 a2	   VAREND_PositionSprites =	TEMPORARY_VAR
   1012  3400
   1013  3400
   1014  3400		       a5 88		      lda	cursorX12
   1015  3402		       38		      sec
   1016  3403		       e9 0a	   .sub10     sbc	#10
   1017  3405		       b0 fc		      bcs	.sub10
   1018  3407		       69 08		      adc	#8
   1019  3409		       a8		      tay
   1020  340a
   1021  340a		       85 42		      sta	WSYNC	; 00	  Sync to start of scanline.
   1022  340c
   1023  340c		       b9 30 f4 	      lda	colToPixel,y
   1024  340f
   1025  340f		       38		      sec		; 02	  Set the carry flag so no borrow will be applied during the division.
   1026  3410		       e9 0f	   .divideby15 sbc	#15	; 04	  Waste the necessary amount of time dividing X-pos by 15!
   1027  3412		       b0 fc		      bcs	.divideby15	; 06/07  11/16/21/26/31/36/41/46/51/56/61/66
   1028  3414
   1029  3414		       a8		      tay
   1030  3415		       b9 30 f3 	      lda	fineAdjustTable,y	; 13 -> Consume 5 cycles by guaranteeing we cross a page boundary
   1031  3418		       85 60		      sta	HMP0
   1032  341a		       85 50		      sta	RESP0	; 21/ 26/31/36/41/46/51/56/61/66/71 - Set the rough position.
   1033  341c
   1034  341c		       85 42		      sta	WSYNC
   1035  341e		       85 6a		      sta	HMOVE
   1036  3420
   1037  3420		       60		      rts
   1038  3421
   1039  3421							; This table converts the "remainder" of the division by 15 (-1 to -15) to the correct
   1040  3421							; fine adjustment value. This table is on a page boundary to guarantee the processor
   1041  3421							; will cross a page boundary and waste a cycle in order to be at the precise position
   1042  3421							; for a RESP0,x write
   1043  3421
   1044  3421				   fineAdjustBegin
   1045  3421
   1046  3421		       70		      DC.B	%01110000	; Left 7
   1047  3422		       60		      DC.B	%01100000	; Left 6
   1048  3423		       50		      DC.B	%01010000	; Left 5
   1049  3424		       40		      DC.B	%01000000	; Left 4
   1050  3425		       30		      DC.B	%00110000	; Left 3
   1051  3426		       20		      DC.B	%00100000	; Left 2
   1052  3427		       10		      DC.B	%00010000	; Left 1
   1053  3428		       00		      DC.B	%00000000	; No movement.
   1054  3429		       f0		      DC.B	%11110000	; Right 1
   1055  342a		       e0		      DC.B	%11100000	; Right 2
   1056  342b		       d0		      DC.B	%11010000	; Right 3
   1057  342c		       c0		      DC.B	%11000000	; Right 4
   1058  342d		       b0		      DC.B	%10110000	; Right 5
   1059  342e		       a0		      DC.B	%10100000	; Right 6
   1060  342f		       90		      DC.B	%10010000	; Right 7
   1061  3430
   1062  3430		       f3 30	   fineAdjustTable EQU	fineAdjustBegin - %11110001	; NOTE: %11110001 = -15
   1063  3430
   1064  3430
      0  3430					      ALLOCATE	colToPixel, 8
      0  3430					      OPTIONAL_PAGEBREAK	"Table", 8
     12  3430					      LIST	ON
      0  3430					      DEF	colToPixel
      1  3430				   BANK_colToPixel SET	_CURRENT_BANK
      2  3430				   colToPixel
      3  3430				   TEMPORARY_VAR SET	Overlay
      4  3430				   TEMPORARY_OFFSET SET	0
      5  3430				   VAR_BOUNDARY_colToPixel SET	TEMPORARY_OFFSET
      6  3430				   FUNCTION_NAME SET	colToPixel
      7  3430					      SUBROUTINE
   1066  3430		       00 14 28 3c*	      .byte.b	0,20,40,60,80,100,120,140
   1067  3438
   1068  3438							;---------------------------------------------------------------------------------------------------
   1069  3438
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  3438					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
      0  3438					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_0", 72
     12  3438					      LIST	ON
      0  3438					      DEF	BLACK_MARKER_on_BLACK_SQUARE_0
      1  3438				   BANK_BLACK_MARKER_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  3438				   BLACK_MARKER_on_BLACK_SQUARE_0
      3  3438				   TEMPORARY_VAR SET	Overlay
      4  3438				   TEMPORARY_OFFSET SET	0
      5  3438				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3438				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_0
      7  3438					      SUBROUTINE
      3  3438		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3450		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3468		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  3480					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
      0  3480					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_1", 72
     12  3480					      LIST	ON
      0  3480					      DEF	BLACK_MARKER_on_BLACK_SQUARE_1
      1  3480				   BANK_BLACK_MARKER_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  3480				   BLACK_MARKER_on_BLACK_SQUARE_1
      3  3480				   TEMPORARY_VAR SET	Overlay
      4  3480				   TEMPORARY_OFFSET SET	0
      5  3480				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3480				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_1
      7  3480					      SUBROUTINE
      3  3480		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3498		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  34b0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  34c8					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
      0  34c8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_2", 72
     12  3500					      LIST	ON
      0  3500					      DEF	BLACK_MARKER_on_BLACK_SQUARE_2
      1  3500				   BANK_BLACK_MARKER_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  3500				   BLACK_MARKER_on_BLACK_SQUARE_2
      3  3500				   TEMPORARY_VAR SET	Overlay
      4  3500				   TEMPORARY_OFFSET SET	0
      5  3500				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3500				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_2
      7  3500					      SUBROUTINE
      3  3500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3530		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  3548					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
      0  3548					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_3", 72
     12  3548					      LIST	ON
      0  3548					      DEF	BLACK_MARKER_on_BLACK_SQUARE_3
      1  3548				   BANK_BLACK_MARKER_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  3548				   BLACK_MARKER_on_BLACK_SQUARE_3
      3  3548				   TEMPORARY_VAR SET	Overlay
      4  3548				   TEMPORARY_OFFSET SET	0
      5  3548				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3548				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_3
      7  3548					      SUBROUTINE
      3  3548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3578		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 5
      0  3590					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
      0  3590					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_0", 72
     12  3590					      LIST	ON
      0  3590					      DEF	BLACK_MARKER_on_WHITE_SQUARE_0
      1  3590				   BANK_BLACK_MARKER_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  3590				   BLACK_MARKER_on_WHITE_SQUARE_0
      3  3590				   TEMPORARY_VAR SET	Overlay
      4  3590				   TEMPORARY_OFFSET SET	0
      5  3590				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3590				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_0
      7  3590					      SUBROUTINE
      3  3590		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00	;PF0
      4  35a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  35c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 5
      0  35d8					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
      0  35d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_1", 72
     12  3600					      LIST	ON
      0  3600					      DEF	BLACK_MARKER_on_WHITE_SQUARE_1
      1  3600				   BANK_BLACK_MARKER_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  3600				   BLACK_MARKER_on_WHITE_SQUARE_1
      3  3600				   TEMPORARY_VAR SET	Overlay
      4  3600				   TEMPORARY_OFFSET SET	0
      5  3600				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3600				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_1
      7  3600					      SUBROUTINE
      3  3600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3618		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00	;PF1
      5  3630		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 5
      0  3648					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
      0  3648					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_2", 72
     12  3648					      LIST	ON
      0  3648					      DEF	BLACK_MARKER_on_WHITE_SQUARE_2
      1  3648				   BANK_BLACK_MARKER_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  3648				   BLACK_MARKER_on_WHITE_SQUARE_2
      3  3648				   TEMPORARY_VAR SET	Overlay
      4  3648				   TEMPORARY_OFFSET SET	0
      5  3648				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3648				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_2
      7  3648					      SUBROUTINE
      3  3648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3678		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 5
      0  3690					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
      0  3690					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_3", 72
     12  3690					      LIST	ON
      0  3690					      DEF	BLACK_MARKER_on_WHITE_SQUARE_3
      1  3690				   BANK_BLACK_MARKER_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  3690				   BLACK_MARKER_on_WHITE_SQUARE_3
      3  3690				   TEMPORARY_VAR SET	Overlay
      4  3690				   TEMPORARY_OFFSET SET	0
      5  3690				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3690				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_3
      7  3690					      SUBROUTINE
      3  3690		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  36a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  36c0		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
   1078  36d8
   1079  36d8							;---------------------------------------------------------------------------------------------------
   1080  36d8
      0  36d8					      CHECK_BANK_SIZE	"BANK_StateMachine"
      1  36d8		       06 d8	   .TEMP      =	* - BANK_START
 BANK_StateMachine (2K) SIZE =  $6d8 , FREE= $128
      2  36d8					      ECHO	"BANK_StateMachine", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  36d8				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  36d8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  36d8				  -	      ERR
      6  36d8					      endif
   1082  36d8
   1083  36d8
   1084  36d8							;---------------------------------------------------------------------------------------------------
   1085  36d8
   1086  36d8							; EOF
------- FILE ./chess.asm
------- FILE BANK_TEXT_OVERLAYS.asm LEVEL 2 PASS 5
      0  36d8					      include	"BANK_TEXT_OVERLAYS.asm"
      0  36d8					      NEWBANK	TEXT_OVERLAYS
      1  3802 ????				      SEG	TEXT_OVERLAYS
      2  3800					      ORG	ORIGIN
      3  3800					      RORG	$F000
      4  3800				   BANK_START SET	*
      5  3800				   TEXT_OVERLAYS SET	ORIGIN / 2048
      6  3800				   ORIGIN     SET	ORIGIN + 2048
      7  3800				   _CURRENT_BANK SET	TEXT_OVERLAYS
      2  3800
      3  3800
      4  3800
      5  3800
      6  3800				   sample
      7  3800		       48 aa		      .byte.b	72,%10101010
      8  3802
      9  3802
     10  3802
     11  3802							;EOF
------- FILE ./chess.asm
    530  3802
------- FILE titleScreen.asm LEVEL 2 PASS 5
      0  3802					      include	"titleScreen.asm"
      0  3802					      NEWBANK	TITLESCREEN
      1  47c0 ????				      SEG	TITLESCREEN
      2  4000					      ORG	ORIGIN
      3  4000					      RORG	$F000
      4  4000				   BANK_START SET	*
      5  4000				   TITLESCREEN SET	ORIGIN / 2048
      6  4000				   ORIGIN     SET	ORIGIN + 2048
      7  4000				   _CURRENT_BANK SET	TITLESCREEN
      2  4000
      3  4000				   OverscanTime2
      4  4000		       1a 1a		      .byte.b	26, 26
      5  4002		       20 20		      .byte.b	32, 32
      6  4004
      7  4004				   colvec
      8  4004		       00 f1 d8 f1	      .word.w	colr_ntsc2, colr_pal
      9  4008
     10  4008
     11  4008		       32 32	   VBlankTime .byte.b	50,50
     12  400a
      0  400a					      DEF	TitleScreen
      1  400a				   BANK_TitleScreen SET	_CURRENT_BANK
      2  400a				   TitleScreen
      3  400a				   TEMPORARY_VAR SET	Overlay
      4  400a				   TEMPORARY_OFFSET SET	0
      5  400a				   VAR_BOUNDARY_TitleScreen SET	TEMPORARY_OFFSET
      6  400a				   FUNCTION_NAME SET	TitleScreen
      7  400a					      SUBROUTINE
     14  400a					      SUBROUTINE
     15  400a
      0  400a					      VAR	__colour_table, 2
      1  400a		       00 a2	   __colour_table =	TEMPORARY_VAR
      2  400a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  400a
      4  400a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  400a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  400a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  400a					      ENDIF
      8  400a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  400a				  -	      ECHO	"Temporary Variable", __colour_table, "overflow!"
     10  400a				  -	      ERR
     11  400a					      ENDIF
     12  400a					      LIST	ON
     17  400a
     18  400a							; Start of new frame
     19  400a
     20  400a							; Start of vertical blank processing
     21  400a
     22  400a				   TitleSequence
     23  400a
     24  400a		       a9 00		      lda	#%00000000
     25  400c		       85 4a		      sta	CTRLPF
     26  400e		       85 49		      sta	COLUBK
     27  4010
     28  4010		       a2 00		      ldx	#0	;Platform
     29  4012		       a9 00		      lda	#<colr_ntsc2	;colvec,x
     30  4014		       85 a2		      sta	__colour_table
     31  4016		       a9 f1		      lda	#>colr_ntsc2	;colvec+1,x
     32  4018		       85 a3		      sta	__colour_table+1
     33  401a
     34  401a							;		  sta rndHi
     35  401a							;		  sta rnd
     36  401a
     37  401a
     38  401a				  -	      if	0
     39  401a				  -	      lda	#0
     40  401a				  -	      sta	digit
     41  401a				  -	      lda	#$10
     42  401a				  -	      sta	digit+1
     43  401a				  -	      lda	#$20
     44  401a				  -	      sta	digit+2
     45  401a					      endif
     46  401a
     47  401a
     48  401a
     49  401a
     50  401a							;RESYNC
     51  401a
     52  401a				   RestartFrame0
     53  401a
     54  401a				  -	      if	0
     55  401a				  -	      ldx	#2
     56  401a				  -rollcols   clc
     57  401a				  -	      lda	digit+2
     58  401a				  -	      adc	#$10
     59  401a				  -	      sta	digit+2
     60  401a				  -	      bcc	finxc
     61  401a				  -	      dex
     62  401a				  -	      bpl	rollcols
     63  401a				  -finxc
     64  401a					      endif
     65  401a
      0  401a					      DEF	RestartFrame
      1  401a				   BANK_RestartFrame SET	_CURRENT_BANK
      2  401a				   RestartFrame
      3  401a				   TEMPORARY_VAR SET	Overlay
      4  401a				   TEMPORARY_OFFSET SET	0
      5  401a				   VAR_BOUNDARY_RestartFrame SET	TEMPORARY_OFFSET
      6  401a				   FUNCTION_NAME SET	RestartFrame
      7  401a					      SUBROUTINE
     67  401a		       a9 00		      LDA	#0
     68  401c		       a9 0e		      lda	#%1110	; VSYNC ON
     69  401e		       85 42	   .loopVSync2 sta	WSYNC
     70  4020		       85 40		      sta	VSYNC
     71  4022		       4a		      lsr
     72  4023		       d0 f9		      bne	.loopVSync2	; branch until VYSNC has been reset
     73  4025
     74  4025							;------------------------------------------------------------------
     75  4025
     76  4025		       a6 9b		      ldx	Platform
     77  4027		       bc 08 f0 	      ldy	VBlankTime,x
     78  402a		       8c 96 02 	      sty	TIM64T
     79  402d
     80  402d
     81  402d				  -	      if	0
     82  402d				  -	      lda	SWCHB
     83  402d				  -	      rol
     84  402d				  -	      rol
     85  402d				  -	      rol
     86  402d				  -	      and	#%11
     87  402d				  -	      eor	#PAL
     88  402d				  -	      cmp	Platform
     89  402d				  -	      beq	platOK
     90  402d				  -	      sta	Platform
     91  402d				  -	      jmp	TitleSequence
     92  402d				  -platOK
     93  402d					      endif
     94  402d
     95  402d		       e6 81	   k2	      inc	rnd
     96  402f		       f0 fc		      beq	k2
     97  4031
     98  4031
     99  4031		       85 42	   VerticalBlank sta	WSYNC
    100  4033		       ad 84 02 	      lda	INTIM
    101  4036		       d0 f9		      bne	VerticalBlank
    102  4038		       85 41		      sta	VBLANK
    103  403a
    104  403a							;sta COLUBK
    105  403a
    106  403a							;------------------------------------------------------------------
    107  403a
    108  403a							; Do X scanlines of color-changing (our picture)
    109  403a
    110  403a		       a0 d1		      ldy	#210-1	; this counts our scanline number
    111  403c		       a2 03	   SokoLogo   ldx	#3
    112  403e		       b1 a2	   triplet    lda	(__colour_table),y
    113  4040							;    eor digit-1,x
    114  4040		       85 42		      sta	WSYNC
    115  4042		       85 48		      sta	COLUPF	; 3
    116  4044
    117  4044		       b9 b0 f2 	      lda	COL_0,y	; 5
    118  4047		       85 4d		      sta	PF0	; 3   @11
    119  4049		       b9 88 f3 	      lda	COL_1,y	; 5
    120  404c		       85 4e		      sta	PF1	; 3   @19
    121  404e		       b9 60 f4 	      lda	COL_2,y	; 5
    122  4051		       85 4f		      sta	PF2	; 3   @27
    123  4053
    124  4053		       b9 38 f5 	      lda	COL_3,y	; 5
    125  4056		       85 4d		      sta	PF0	; 3   @35
      0  4058					      SLEEP	2	; @37
      1  4058				   .CYCLES    SET	2
      2  4058
      3  4058				  -	      IF	.CYCLES < 2
      4  4058				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4058				  -	      ERR
      6  4058					      ENDIF
      7  4058
      8  4058				  -	      IF	.CYCLES & 1
      9  4058				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  4058				  -	      nop	0
     11  4058				  -	      ELSE
     12  4058				  -	      bit	VSYNC
     13  4058				  -	      ENDIF
     14  4058				  -.CYCLES    SET	.CYCLES - 3
     15  4058					      ENDIF
     16  4058
     17  4058					      REPEAT	.CYCLES / 2
     18  4058		       ea		      nop
     19  4059					      REPEND
    127  4059		       b9 10 f6 	      lda	COL_4,y	; 5
    128  405c		       85 4e		      sta	PF1	; 3   @45
      0  405e					      SLEEP	3	; @45
      1  405e				   .CYCLES    SET	3
      2  405e
      3  405e				  -	      IF	.CYCLES < 2
      4  405e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  405e				  -	      ERR
      6  405e					      ENDIF
      7  405e
      8  405e					      IF	.CYCLES & 1
      9  405e					      IFNCONST	NO_ILLEGAL_OPCODES
     10  405e		       04 00		      nop	0
     11  4060				  -	      ELSE
     12  4060				  -	      bit	VSYNC
     13  4060					      ENDIF
     14  4060				   .CYCLES    SET	.CYCLES - 3
     15  4060					      ENDIF
     16  4060
     17  4060				  -	      REPEAT	.CYCLES / 2
     18  4060				  -	      nop
     19  4060					      REPEND
    130  4060		       b9 e8 f6 	      lda	COL_5,y	; 5
    131  4063		       85 4f		      sta	PF2	; 3
    132  4065
    133  4065		       88		      dey		; 2
    134  4066		       ca		      dex		; 2
    135  4067		       d0 d5		      bne	triplet	; 2(3)
    136  4069
    137  4069		       c0 ff		      cpy	#-1	; 2
    138  406b		       d0 cf		      bne	SokoLogo	; 2(3)
    139  406d
    140  406d							;lda #0
    141  406d							;sta PF0
    142  406d							;sta PF1
    143  406d							;sta PF2
    144  406d
    145  406d		       a6 9b		      ldx	Platform
    146  406f		       bd 00 f0 	      lda	OverscanTime2,x
    147  4072		       8d 96 02 	      sta	TIM64T
    148  4075
    149  4075				  -	      if	0
    150  4075				  -	      sta	WSYNC
    151  4075				  -	      sta	WSYNC
    152  4075				  -	      sta	WSYNC
    153  4075				  -	      sta	WSYNC
    154  4075				  -	      sta	WSYNC
    155  4075				  -	      SLEEP	8
    156  4075				  -	      jsr	SokoScreen
    157  4075				  -
    158  4075				  -	      lda	#0
    159  4075				  -	      sta	BoardScrollX
    160  4075				  -	      sta	BoardScrollY
    161  4075					      endif
    162  4075
    163  4075							;		ldy #63
    164  4075							;bot2		 sta WSYNC
    165  4075							;		dey
    166  4075							;		bpl bot2
    167  4075
    168  4075							;--------------------------------------------------------------------------
    169  4075
    170  4075		       a9 00		      lda	#0
    171  4077		       85 4d		      sta	PF0
    172  4079		       85 4e		      sta	PF1
    173  407b		       85 4f		      sta	PF2
    174  407d
    175  407d
      0  407d					      NEXT_RANDOM
      1  407d		       a5 81		      lda	rnd
      2  407f		       4a		      lsr
      3  4080		       90 02		      bcc	.skipEOR
      4  4082		       49 fe		      eor	#RND_EOR_VAL
      5  4084		       85 81	   .skipEOR   sta	rnd
    177  4086
    178  4086							; D1 VBLANK turns off beam
    179  4086							; It needs to be turned on 37 scanlines later
    180  4086
    181  4086				   oscan
    182  4086		       ad 84 02 	      lda	INTIM
    183  4089		       d0 fb		      bne	oscan
    184  408b
    185  408b		       a9 42		      lda	#%01000010	; bit6 is not required
    186  408d		       85 41		      sta	VBLANK	; end of screen - enter blanking
    187  408f
    188  408f				  -	      if	0
    189  408f				  -	      inc	rnd
    190  408f				  -	      bne	rdd
    191  408f				  -	      inc	rndHi
    192  408f				  -rdd
    193  408f				  -
    194  408f				  -	      dec	digitick
    195  408f				  -	      bpl	ret2
    196  408f				  -	      lda	#40
    197  408f				  -	      sta	digitick
    198  408f				  -
    199  408f				  -	      jsr	Random
    200  408f				  -	      and	#3
    201  408f				  -	      beq	ret2
    202  408f				  -	      tax
    203  408f				  -	      jsr	Random
    204  408f				  -	      and	#$F0
    205  408f				  -	      sta	digit-1,x
    206  408f				  -	      jmp	RestartFrame0
    207  408f				  -
    208  408f				  -ret2
    209  408f					      endif
    210  408f
    211  408f
    212  408f		       a5 4c		      lda	INPT4
    213  4091		       10 03		      bpl	ret
    214  4093
    215  4093		       4c 1a f0 	      jmp	RestartFrame
    216  4096
    217  4096				   ret
    218  4096		       60		      rts
    219  4097
    220  4097
    221  4097
    222  4097					      MAC	lumtable
    223  4097							; {4} MIN LUM 1
    224  4097							; {5} MIN LUM 2
    225  4097							; {6} MIN LUM 3
    226  4097
    227  4097				   .LUM1      SET	{4}*256
    228  4097				   .LUM2      SET	{5}*256
    229  4097				   .LUM3      SET	{6}*256
    230  4097
    231  4097				   .STEP1     =	(256*({7}-{4}))/72
    232  4097				   .STEP2     =	(256*({8}-{5}))/72
    233  4097				   .STEP3     =	(256*({9}-{6}))/72
    234  4097
    235  4097					      REPEAT	72
    236  4097					      .byte	{1}+(.LUM1/256)
    237  4097					      .byte	{2}+(.LUM2/256)
    238  4097					      .byte	{3}+(.LUM3/256)
    239  4097
    240  4097							;    ECHO {1}+(.LUM1/256)
    241  4097							;    ECHO {2}+(.LUM1/256)
    242  4097							;    ECHO {3}+(.LUM1/256)
    243  4097
    244  4097				   .LUM1      SET	.LUM1 + .STEP1
    245  4097				   .LUM2      SET	.LUM2 + .STEP2
    246  4097				   .LUM3      SET	.LUM3 + .STEP3
    247  4097					      REPEND
    248  4097					      ENDM		;{1}{2}{3} base colours
    249  4097
    250  4097							;colr_pal    LUMTABLE $B0,$30,$A0,0,8,4 ;2,4,6
    251  4097							;    OPTIONAL_PAGEBREAK "colr_ntsc", 72*3
    252  4097
    253  4100		       00 00 00 00*	      align	256
    254  4100							;    ECHO "NTSC LUMS"
    255  4100				   colr_ntsc2
      0  4100					      LUMTABLE	$40,$20,$90,$4,$6,$8,$4,$6,$8
      1  4100
      2  4100
      3  4100
      4  4100
      5  4100				   .LUM1      SET	$4*256
      6  4100				   .LUM2      SET	$6*256
      7  4100				   .LUM3      SET	$8*256
      8  4100
      9  4100		       00 00	   .STEP1     =	(256*($4-$4))/72
     10  4100		       00 00	   .STEP2     =	(256*($6-$6))/72
     11  4100		       00 00	   .STEP3     =	(256*($8-$8))/72
     12  4100
     13  4100					      REPEAT	72
     14  4100		       44		      .byte.b	$40+(.LUM1/256)
     15  4101		       26		      .byte.b	$20+(.LUM2/256)
     16  4102		       98		      .byte.b	$90+(.LUM3/256)
     17  4103
     18  4103
     19  4103
     20  4103
     21  4103
     22  4103				   .LUM1      SET	.LUM1 + .STEP1
     23  4103				   .LUM2      SET	.LUM2 + .STEP2
     24  4103				   .LUM3      SET	.LUM3 + .STEP3
     13  4103					      REPEND
     14  4103		       44		      .byte.b	$40+(.LUM1/256)
     15  4104		       26		      .byte.b	$20+(.LUM2/256)
     16  4105		       98		      .byte.b	$90+(.LUM3/256)
     17  4106
     18  4106
     19  4106
     20  4106
     21  4106
     22  4106				   .LUM1      SET	.LUM1 + .STEP1
     23  4106				   .LUM2      SET	.LUM2 + .STEP2
     24  4106				   .LUM3      SET	.LUM3 + .STEP3
     13  4106					      REPEND
     14  4106		       44		      .byte.b	$40+(.LUM1/256)
     15  4107		       26		      .byte.b	$20+(.LUM2/256)
     16  4108		       98		      .byte.b	$90+(.LUM3/256)
     17  4109
     18  4109
     19  4109
     20  4109
     21  4109
     22  4109				   .LUM1      SET	.LUM1 + .STEP1
     23  4109				   .LUM2      SET	.LUM2 + .STEP2
     24  4109				   .LUM3      SET	.LUM3 + .STEP3
     13  4109					      REPEND
     14  4109		       44		      .byte.b	$40+(.LUM1/256)
     15  410a		       26		      .byte.b	$20+(.LUM2/256)
     16  410b		       98		      .byte.b	$90+(.LUM3/256)
     17  410c
     18  410c
     19  410c
     20  410c
     21  410c
     22  410c				   .LUM1      SET	.LUM1 + .STEP1
     23  410c				   .LUM2      SET	.LUM2 + .STEP2
     24  410c				   .LUM3      SET	.LUM3 + .STEP3
     13  410c					      REPEND
     14  410c		       44		      .byte.b	$40+(.LUM1/256)
     15  410d		       26		      .byte.b	$20+(.LUM2/256)
     16  410e		       98		      .byte.b	$90+(.LUM3/256)
     17  410f
     18  410f
     19  410f
     20  410f
     21  410f
     22  410f				   .LUM1      SET	.LUM1 + .STEP1
     23  410f				   .LUM2      SET	.LUM2 + .STEP2
     24  410f				   .LUM3      SET	.LUM3 + .STEP3
     13  410f					      REPEND
     14  410f		       44		      .byte.b	$40+(.LUM1/256)
     15  4110		       26		      .byte.b	$20+(.LUM2/256)
     16  4111		       98		      .byte.b	$90+(.LUM3/256)
     17  4112
     18  4112
     19  4112
     20  4112
     21  4112
     22  4112				   .LUM1      SET	.LUM1 + .STEP1
     23  4112				   .LUM2      SET	.LUM2 + .STEP2
     24  4112				   .LUM3      SET	.LUM3 + .STEP3
     13  4112					      REPEND
     14  4112		       44		      .byte.b	$40+(.LUM1/256)
     15  4113		       26		      .byte.b	$20+(.LUM2/256)
     16  4114		       98		      .byte.b	$90+(.LUM3/256)
     17  4115
     18  4115
     19  4115
     20  4115
     21  4115
     22  4115				   .LUM1      SET	.LUM1 + .STEP1
     23  4115				   .LUM2      SET	.LUM2 + .STEP2
     24  4115				   .LUM3      SET	.LUM3 + .STEP3
     13  4115					      REPEND
     14  4115		       44		      .byte.b	$40+(.LUM1/256)
     15  4116		       26		      .byte.b	$20+(.LUM2/256)
     16  4117		       98		      .byte.b	$90+(.LUM3/256)
     17  4118
     18  4118
     19  4118
     20  4118
     21  4118
     22  4118				   .LUM1      SET	.LUM1 + .STEP1
     23  4118				   .LUM2      SET	.LUM2 + .STEP2
     24  4118				   .LUM3      SET	.LUM3 + .STEP3
     13  4118					      REPEND
     14  4118		       44		      .byte.b	$40+(.LUM1/256)
     15  4119		       26		      .byte.b	$20+(.LUM2/256)
     16  411a		       98		      .byte.b	$90+(.LUM3/256)
     17  411b
     18  411b
     19  411b
     20  411b
     21  411b
     22  411b				   .LUM1      SET	.LUM1 + .STEP1
     23  411b				   .LUM2      SET	.LUM2 + .STEP2
     24  411b				   .LUM3      SET	.LUM3 + .STEP3
     13  411b					      REPEND
     14  411b		       44		      .byte.b	$40+(.LUM1/256)
     15  411c		       26		      .byte.b	$20+(.LUM2/256)
     16  411d		       98		      .byte.b	$90+(.LUM3/256)
     17  411e
     18  411e
     19  411e
     20  411e
     21  411e
     22  411e				   .LUM1      SET	.LUM1 + .STEP1
     23  411e				   .LUM2      SET	.LUM2 + .STEP2
     24  411e				   .LUM3      SET	.LUM3 + .STEP3
     13  411e					      REPEND
     14  411e		       44		      .byte.b	$40+(.LUM1/256)
     15  411f		       26		      .byte.b	$20+(.LUM2/256)
     16  4120		       98		      .byte.b	$90+(.LUM3/256)
     17  4121
     18  4121
     19  4121
     20  4121
     21  4121
     22  4121				   .LUM1      SET	.LUM1 + .STEP1
     23  4121				   .LUM2      SET	.LUM2 + .STEP2
     24  4121				   .LUM3      SET	.LUM3 + .STEP3
     13  4121					      REPEND
     14  4121		       44		      .byte.b	$40+(.LUM1/256)
     15  4122		       26		      .byte.b	$20+(.LUM2/256)
     16  4123		       98		      .byte.b	$90+(.LUM3/256)
     17  4124
     18  4124
     19  4124
     20  4124
     21  4124
     22  4124				   .LUM1      SET	.LUM1 + .STEP1
     23  4124				   .LUM2      SET	.LUM2 + .STEP2
     24  4124				   .LUM3      SET	.LUM3 + .STEP3
     13  4124					      REPEND
     14  4124		       44		      .byte.b	$40+(.LUM1/256)
     15  4125		       26		      .byte.b	$20+(.LUM2/256)
     16  4126		       98		      .byte.b	$90+(.LUM3/256)
     17  4127
     18  4127
     19  4127
     20  4127
     21  4127
     22  4127				   .LUM1      SET	.LUM1 + .STEP1
     23  4127				   .LUM2      SET	.LUM2 + .STEP2
     24  4127				   .LUM3      SET	.LUM3 + .STEP3
     13  4127					      REPEND
     14  4127		       44		      .byte.b	$40+(.LUM1/256)
     15  4128		       26		      .byte.b	$20+(.LUM2/256)
     16  4129		       98		      .byte.b	$90+(.LUM3/256)
     17  412a
     18  412a
     19  412a
     20  412a
     21  412a
     22  412a				   .LUM1      SET	.LUM1 + .STEP1
     23  412a				   .LUM2      SET	.LUM2 + .STEP2
     24  412a				   .LUM3      SET	.LUM3 + .STEP3
     13  412a					      REPEND
     14  412a		       44		      .byte.b	$40+(.LUM1/256)
     15  412b		       26		      .byte.b	$20+(.LUM2/256)
     16  412c		       98		      .byte.b	$90+(.LUM3/256)
     17  412d
     18  412d
     19  412d
     20  412d
     21  412d
     22  412d				   .LUM1      SET	.LUM1 + .STEP1
     23  412d				   .LUM2      SET	.LUM2 + .STEP2
     24  412d				   .LUM3      SET	.LUM3 + .STEP3
     13  412d					      REPEND
     14  412d		       44		      .byte.b	$40+(.LUM1/256)
     15  412e		       26		      .byte.b	$20+(.LUM2/256)
     16  412f		       98		      .byte.b	$90+(.LUM3/256)
     17  4130
     18  4130
     19  4130
     20  4130
     21  4130
     22  4130				   .LUM1      SET	.LUM1 + .STEP1
     23  4130				   .LUM2      SET	.LUM2 + .STEP2
     24  4130				   .LUM3      SET	.LUM3 + .STEP3
     13  4130					      REPEND
     14  4130		       44		      .byte.b	$40+(.LUM1/256)
     15  4131		       26		      .byte.b	$20+(.LUM2/256)
     16  4132		       98		      .byte.b	$90+(.LUM3/256)
     17  4133
     18  4133
     19  4133
     20  4133
     21  4133
     22  4133				   .LUM1      SET	.LUM1 + .STEP1
     23  4133				   .LUM2      SET	.LUM2 + .STEP2
     24  4133				   .LUM3      SET	.LUM3 + .STEP3
     13  4133					      REPEND
     14  4133		       44		      .byte.b	$40+(.LUM1/256)
     15  4134		       26		      .byte.b	$20+(.LUM2/256)
     16  4135		       98		      .byte.b	$90+(.LUM3/256)
     17  4136
     18  4136
     19  4136
     20  4136
     21  4136
     22  4136				   .LUM1      SET	.LUM1 + .STEP1
     23  4136				   .LUM2      SET	.LUM2 + .STEP2
     24  4136				   .LUM3      SET	.LUM3 + .STEP3
     13  4136					      REPEND
     14  4136		       44		      .byte.b	$40+(.LUM1/256)
     15  4137		       26		      .byte.b	$20+(.LUM2/256)
     16  4138		       98		      .byte.b	$90+(.LUM3/256)
     17  4139
     18  4139
     19  4139
     20  4139
     21  4139
     22  4139				   .LUM1      SET	.LUM1 + .STEP1
     23  4139				   .LUM2      SET	.LUM2 + .STEP2
     24  4139				   .LUM3      SET	.LUM3 + .STEP3
     13  4139					      REPEND
     14  4139		       44		      .byte.b	$40+(.LUM1/256)
     15  413a		       26		      .byte.b	$20+(.LUM2/256)
     16  413b		       98		      .byte.b	$90+(.LUM3/256)
     17  413c
     18  413c
     19  413c
     20  413c
     21  413c
     22  413c				   .LUM1      SET	.LUM1 + .STEP1
     23  413c				   .LUM2      SET	.LUM2 + .STEP2
     24  413c				   .LUM3      SET	.LUM3 + .STEP3
     13  413c					      REPEND
     14  413c		       44		      .byte.b	$40+(.LUM1/256)
     15  413d		       26		      .byte.b	$20+(.LUM2/256)
     16  413e		       98		      .byte.b	$90+(.LUM3/256)
     17  413f
     18  413f
     19  413f
     20  413f
     21  413f
     22  413f				   .LUM1      SET	.LUM1 + .STEP1
     23  413f				   .LUM2      SET	.LUM2 + .STEP2
     24  413f				   .LUM3      SET	.LUM3 + .STEP3
     13  413f					      REPEND
     14  413f		       44		      .byte.b	$40+(.LUM1/256)
     15  4140		       26		      .byte.b	$20+(.LUM2/256)
     16  4141		       98		      .byte.b	$90+(.LUM3/256)
     17  4142
     18  4142
     19  4142
     20  4142
     21  4142
     22  4142				   .LUM1      SET	.LUM1 + .STEP1
     23  4142				   .LUM2      SET	.LUM2 + .STEP2
     24  4142				   .LUM3      SET	.LUM3 + .STEP3
     13  4142					      REPEND
     14  4142		       44		      .byte.b	$40+(.LUM1/256)
     15  4143		       26		      .byte.b	$20+(.LUM2/256)
     16  4144		       98		      .byte.b	$90+(.LUM3/256)
     17  4145
     18  4145
     19  4145
     20  4145
     21  4145
     22  4145				   .LUM1      SET	.LUM1 + .STEP1
     23  4145				   .LUM2      SET	.LUM2 + .STEP2
     24  4145				   .LUM3      SET	.LUM3 + .STEP3
     13  4145					      REPEND
     14  4145		       44		      .byte.b	$40+(.LUM1/256)
     15  4146		       26		      .byte.b	$20+(.LUM2/256)
     16  4147		       98		      .byte.b	$90+(.LUM3/256)
     17  4148
     18  4148
     19  4148
     20  4148
     21  4148
     22  4148				   .LUM1      SET	.LUM1 + .STEP1
     23  4148				   .LUM2      SET	.LUM2 + .STEP2
     24  4148				   .LUM3      SET	.LUM3 + .STEP3
     13  4148					      REPEND
     14  4148		       44		      .byte.b	$40+(.LUM1/256)
     15  4149		       26		      .byte.b	$20+(.LUM2/256)
     16  414a		       98		      .byte.b	$90+(.LUM3/256)
     17  414b
     18  414b
     19  414b
     20  414b
     21  414b
     22  414b				   .LUM1      SET	.LUM1 + .STEP1
     23  414b				   .LUM2      SET	.LUM2 + .STEP2
     24  414b				   .LUM3      SET	.LUM3 + .STEP3
     13  414b					      REPEND
     14  414b		       44		      .byte.b	$40+(.LUM1/256)
     15  414c		       26		      .byte.b	$20+(.LUM2/256)
     16  414d		       98		      .byte.b	$90+(.LUM3/256)
     17  414e
     18  414e
     19  414e
     20  414e
     21  414e
     22  414e				   .LUM1      SET	.LUM1 + .STEP1
     23  414e				   .LUM2      SET	.LUM2 + .STEP2
     24  414e				   .LUM3      SET	.LUM3 + .STEP3
     13  414e					      REPEND
     14  414e		       44		      .byte.b	$40+(.LUM1/256)
     15  414f		       26		      .byte.b	$20+(.LUM2/256)
     16  4150		       98		      .byte.b	$90+(.LUM3/256)
     17  4151
     18  4151
     19  4151
     20  4151
     21  4151
     22  4151				   .LUM1      SET	.LUM1 + .STEP1
     23  4151				   .LUM2      SET	.LUM2 + .STEP2
     24  4151				   .LUM3      SET	.LUM3 + .STEP3
     13  4151					      REPEND
     14  4151		       44		      .byte.b	$40+(.LUM1/256)
     15  4152		       26		      .byte.b	$20+(.LUM2/256)
     16  4153		       98		      .byte.b	$90+(.LUM3/256)
     17  4154
     18  4154
     19  4154
     20  4154
     21  4154
     22  4154				   .LUM1      SET	.LUM1 + .STEP1
     23  4154				   .LUM2      SET	.LUM2 + .STEP2
     24  4154				   .LUM3      SET	.LUM3 + .STEP3
     13  4154					      REPEND
     14  4154		       44		      .byte.b	$40+(.LUM1/256)
     15  4155		       26		      .byte.b	$20+(.LUM2/256)
     16  4156		       98		      .byte.b	$90+(.LUM3/256)
     17  4157
     18  4157
     19  4157
     20  4157
     21  4157
     22  4157				   .LUM1      SET	.LUM1 + .STEP1
     23  4157				   .LUM2      SET	.LUM2 + .STEP2
     24  4157				   .LUM3      SET	.LUM3 + .STEP3
     13  4157					      REPEND
     14  4157		       44		      .byte.b	$40+(.LUM1/256)
     15  4158		       26		      .byte.b	$20+(.LUM2/256)
     16  4159		       98		      .byte.b	$90+(.LUM3/256)
     17  415a
     18  415a
     19  415a
     20  415a
     21  415a
     22  415a				   .LUM1      SET	.LUM1 + .STEP1
     23  415a				   .LUM2      SET	.LUM2 + .STEP2
     24  415a				   .LUM3      SET	.LUM3 + .STEP3
     13  415a					      REPEND
     14  415a		       44		      .byte.b	$40+(.LUM1/256)
     15  415b		       26		      .byte.b	$20+(.LUM2/256)
     16  415c		       98		      .byte.b	$90+(.LUM3/256)
     17  415d
     18  415d
     19  415d
     20  415d
     21  415d
     22  415d				   .LUM1      SET	.LUM1 + .STEP1
     23  415d				   .LUM2      SET	.LUM2 + .STEP2
     24  415d				   .LUM3      SET	.LUM3 + .STEP3
     13  415d					      REPEND
     14  415d		       44		      .byte.b	$40+(.LUM1/256)
     15  415e		       26		      .byte.b	$20+(.LUM2/256)
     16  415f		       98		      .byte.b	$90+(.LUM3/256)
     17  4160
     18  4160
     19  4160
     20  4160
     21  4160
     22  4160				   .LUM1      SET	.LUM1 + .STEP1
     23  4160				   .LUM2      SET	.LUM2 + .STEP2
     24  4160				   .LUM3      SET	.LUM3 + .STEP3
     13  4160					      REPEND
     14  4160		       44		      .byte.b	$40+(.LUM1/256)
     15  4161		       26		      .byte.b	$20+(.LUM2/256)
     16  4162		       98		      .byte.b	$90+(.LUM3/256)
     17  4163
     18  4163
     19  4163
     20  4163
     21  4163
     22  4163				   .LUM1      SET	.LUM1 + .STEP1
     23  4163				   .LUM2      SET	.LUM2 + .STEP2
     24  4163				   .LUM3      SET	.LUM3 + .STEP3
     13  4163					      REPEND
     14  4163		       44		      .byte.b	$40+(.LUM1/256)
     15  4164		       26		      .byte.b	$20+(.LUM2/256)
     16  4165		       98		      .byte.b	$90+(.LUM3/256)
     17  4166
     18  4166
     19  4166
     20  4166
     21  4166
     22  4166				   .LUM1      SET	.LUM1 + .STEP1
     23  4166				   .LUM2      SET	.LUM2 + .STEP2
     24  4166				   .LUM3      SET	.LUM3 + .STEP3
     13  4166					      REPEND
     14  4166		       44		      .byte.b	$40+(.LUM1/256)
     15  4167		       26		      .byte.b	$20+(.LUM2/256)
     16  4168		       98		      .byte.b	$90+(.LUM3/256)
     17  4169
     18  4169
     19  4169
     20  4169
     21  4169
     22  4169				   .LUM1      SET	.LUM1 + .STEP1
     23  4169				   .LUM2      SET	.LUM2 + .STEP2
     24  4169				   .LUM3      SET	.LUM3 + .STEP3
     13  4169					      REPEND
     14  4169		       44		      .byte.b	$40+(.LUM1/256)
     15  416a		       26		      .byte.b	$20+(.LUM2/256)
     16  416b		       98		      .byte.b	$90+(.LUM3/256)
     17  416c
     18  416c
     19  416c
     20  416c
     21  416c
     22  416c				   .LUM1      SET	.LUM1 + .STEP1
     23  416c				   .LUM2      SET	.LUM2 + .STEP2
     24  416c				   .LUM3      SET	.LUM3 + .STEP3
     13  416c					      REPEND
     14  416c		       44		      .byte.b	$40+(.LUM1/256)
     15  416d		       26		      .byte.b	$20+(.LUM2/256)
     16  416e		       98		      .byte.b	$90+(.LUM3/256)
     17  416f
     18  416f
     19  416f
     20  416f
     21  416f
     22  416f				   .LUM1      SET	.LUM1 + .STEP1
     23  416f				   .LUM2      SET	.LUM2 + .STEP2
     24  416f				   .LUM3      SET	.LUM3 + .STEP3
     13  416f					      REPEND
     14  416f		       44		      .byte.b	$40+(.LUM1/256)
     15  4170		       26		      .byte.b	$20+(.LUM2/256)
     16  4171		       98		      .byte.b	$90+(.LUM3/256)
     17  4172
     18  4172
     19  4172
     20  4172
     21  4172
     22  4172				   .LUM1      SET	.LUM1 + .STEP1
     23  4172				   .LUM2      SET	.LUM2 + .STEP2
     24  4172				   .LUM3      SET	.LUM3 + .STEP3
     13  4172					      REPEND
     14  4172		       44		      .byte.b	$40+(.LUM1/256)
     15  4173		       26		      .byte.b	$20+(.LUM2/256)
     16  4174		       98		      .byte.b	$90+(.LUM3/256)
     17  4175
     18  4175
     19  4175
     20  4175
     21  4175
     22  4175				   .LUM1      SET	.LUM1 + .STEP1
     23  4175				   .LUM2      SET	.LUM2 + .STEP2
     24  4175				   .LUM3      SET	.LUM3 + .STEP3
     13  4175					      REPEND
     14  4175		       44		      .byte.b	$40+(.LUM1/256)
     15  4176		       26		      .byte.b	$20+(.LUM2/256)
     16  4177		       98		      .byte.b	$90+(.LUM3/256)
     17  4178
     18  4178
     19  4178
     20  4178
     21  4178
     22  4178				   .LUM1      SET	.LUM1 + .STEP1
     23  4178				   .LUM2      SET	.LUM2 + .STEP2
     24  4178				   .LUM3      SET	.LUM3 + .STEP3
     13  4178					      REPEND
     14  4178		       44		      .byte.b	$40+(.LUM1/256)
     15  4179		       26		      .byte.b	$20+(.LUM2/256)
     16  417a		       98		      .byte.b	$90+(.LUM3/256)
     17  417b
     18  417b
     19  417b
     20  417b
     21  417b
     22  417b				   .LUM1      SET	.LUM1 + .STEP1
     23  417b				   .LUM2      SET	.LUM2 + .STEP2
     24  417b				   .LUM3      SET	.LUM3 + .STEP3
     13  417b					      REPEND
     14  417b		       44		      .byte.b	$40+(.LUM1/256)
     15  417c		       26		      .byte.b	$20+(.LUM2/256)
     16  417d		       98		      .byte.b	$90+(.LUM3/256)
     17  417e
     18  417e
     19  417e
     20  417e
     21  417e
     22  417e				   .LUM1      SET	.LUM1 + .STEP1
     23  417e				   .LUM2      SET	.LUM2 + .STEP2
     24  417e				   .LUM3      SET	.LUM3 + .STEP3
     13  417e					      REPEND
     14  417e		       44		      .byte.b	$40+(.LUM1/256)
     15  417f		       26		      .byte.b	$20+(.LUM2/256)
     16  4180		       98		      .byte.b	$90+(.LUM3/256)
     17  4181
     18  4181
     19  4181
     20  4181
     21  4181
     22  4181				   .LUM1      SET	.LUM1 + .STEP1
     23  4181				   .LUM2      SET	.LUM2 + .STEP2
     24  4181				   .LUM3      SET	.LUM3 + .STEP3
     13  4181					      REPEND
     14  4181		       44		      .byte.b	$40+(.LUM1/256)
     15  4182		       26		      .byte.b	$20+(.LUM2/256)
     16  4183		       98		      .byte.b	$90+(.LUM3/256)
     17  4184
     18  4184
     19  4184
     20  4184
     21  4184
     22  4184				   .LUM1      SET	.LUM1 + .STEP1
     23  4184				   .LUM2      SET	.LUM2 + .STEP2
     24  4184				   .LUM3      SET	.LUM3 + .STEP3
     13  4184					      REPEND
     14  4184		       44		      .byte.b	$40+(.LUM1/256)
     15  4185		       26		      .byte.b	$20+(.LUM2/256)
     16  4186		       98		      .byte.b	$90+(.LUM3/256)
     17  4187
     18  4187
     19  4187
     20  4187
     21  4187
     22  4187				   .LUM1      SET	.LUM1 + .STEP1
     23  4187				   .LUM2      SET	.LUM2 + .STEP2
     24  4187				   .LUM3      SET	.LUM3 + .STEP3
     13  4187					      REPEND
     14  4187		       44		      .byte.b	$40+(.LUM1/256)
     15  4188		       26		      .byte.b	$20+(.LUM2/256)
     16  4189		       98		      .byte.b	$90+(.LUM3/256)
     17  418a
     18  418a
     19  418a
     20  418a
     21  418a
     22  418a				   .LUM1      SET	.LUM1 + .STEP1
     23  418a				   .LUM2      SET	.LUM2 + .STEP2
     24  418a				   .LUM3      SET	.LUM3 + .STEP3
     13  418a					      REPEND
     14  418a		       44		      .byte.b	$40+(.LUM1/256)
     15  418b		       26		      .byte.b	$20+(.LUM2/256)
     16  418c		       98		      .byte.b	$90+(.LUM3/256)
     17  418d
     18  418d
     19  418d
     20  418d
     21  418d
     22  418d				   .LUM1      SET	.LUM1 + .STEP1
     23  418d				   .LUM2      SET	.LUM2 + .STEP2
     24  418d				   .LUM3      SET	.LUM3 + .STEP3
     13  418d					      REPEND
     14  418d		       44		      .byte.b	$40+(.LUM1/256)
     15  418e		       26		      .byte.b	$20+(.LUM2/256)
     16  418f		       98		      .byte.b	$90+(.LUM3/256)
     17  4190
     18  4190
     19  4190
     20  4190
     21  4190
     22  4190				   .LUM1      SET	.LUM1 + .STEP1
     23  4190				   .LUM2      SET	.LUM2 + .STEP2
     24  4190				   .LUM3      SET	.LUM3 + .STEP3
     13  4190					      REPEND
     14  4190		       44		      .byte.b	$40+(.LUM1/256)
     15  4191		       26		      .byte.b	$20+(.LUM2/256)
     16  4192		       98		      .byte.b	$90+(.LUM3/256)
     17  4193
     18  4193
     19  4193
     20  4193
     21  4193
     22  4193				   .LUM1      SET	.LUM1 + .STEP1
     23  4193				   .LUM2      SET	.LUM2 + .STEP2
     24  4193				   .LUM3      SET	.LUM3 + .STEP3
     13  4193					      REPEND
     14  4193		       44		      .byte.b	$40+(.LUM1/256)
     15  4194		       26		      .byte.b	$20+(.LUM2/256)
     16  4195		       98		      .byte.b	$90+(.LUM3/256)
     17  4196
     18  4196
     19  4196
     20  4196
     21  4196
     22  4196				   .LUM1      SET	.LUM1 + .STEP1
     23  4196				   .LUM2      SET	.LUM2 + .STEP2
     24  4196				   .LUM3      SET	.LUM3 + .STEP3
     13  4196					      REPEND
     14  4196		       44		      .byte.b	$40+(.LUM1/256)
     15  4197		       26		      .byte.b	$20+(.LUM2/256)
     16  4198		       98		      .byte.b	$90+(.LUM3/256)
     17  4199
     18  4199
     19  4199
     20  4199
     21  4199
     22  4199				   .LUM1      SET	.LUM1 + .STEP1
     23  4199				   .LUM2      SET	.LUM2 + .STEP2
     24  4199				   .LUM3      SET	.LUM3 + .STEP3
     13  4199					      REPEND
     14  4199		       44		      .byte.b	$40+(.LUM1/256)
     15  419a		       26		      .byte.b	$20+(.LUM2/256)
     16  419b		       98		      .byte.b	$90+(.LUM3/256)
     17  419c
     18  419c
     19  419c
     20  419c
     21  419c
     22  419c				   .LUM1      SET	.LUM1 + .STEP1
     23  419c				   .LUM2      SET	.LUM2 + .STEP2
     24  419c				   .LUM3      SET	.LUM3 + .STEP3
     13  419c					      REPEND
     14  419c		       44		      .byte.b	$40+(.LUM1/256)
     15  419d		       26		      .byte.b	$20+(.LUM2/256)
     16  419e		       98		      .byte.b	$90+(.LUM3/256)
     17  419f
     18  419f
     19  419f
     20  419f
     21  419f
     22  419f				   .LUM1      SET	.LUM1 + .STEP1
     23  419f				   .LUM2      SET	.LUM2 + .STEP2
     24  419f				   .LUM3      SET	.LUM3 + .STEP3
     13  419f					      REPEND
     14  419f		       44		      .byte.b	$40+(.LUM1/256)
     15  41a0		       26		      .byte.b	$20+(.LUM2/256)
     16  41a1		       98		      .byte.b	$90+(.LUM3/256)
     17  41a2
     18  41a2
     19  41a2
     20  41a2
     21  41a2
     22  41a2				   .LUM1      SET	.LUM1 + .STEP1
     23  41a2				   .LUM2      SET	.LUM2 + .STEP2
     24  41a2				   .LUM3      SET	.LUM3 + .STEP3
     13  41a2					      REPEND
     14  41a2		       44		      .byte.b	$40+(.LUM1/256)
     15  41a3		       26		      .byte.b	$20+(.LUM2/256)
     16  41a4		       98		      .byte.b	$90+(.LUM3/256)
     17  41a5
     18  41a5
     19  41a5
     20  41a5
     21  41a5
     22  41a5				   .LUM1      SET	.LUM1 + .STEP1
     23  41a5				   .LUM2      SET	.LUM2 + .STEP2
     24  41a5				   .LUM3      SET	.LUM3 + .STEP3
     13  41a5					      REPEND
     14  41a5		       44		      .byte.b	$40+(.LUM1/256)
     15  41a6		       26		      .byte.b	$20+(.LUM2/256)
     16  41a7		       98		      .byte.b	$90+(.LUM3/256)
     17  41a8
     18  41a8
     19  41a8
     20  41a8
     21  41a8
     22  41a8				   .LUM1      SET	.LUM1 + .STEP1
     23  41a8				   .LUM2      SET	.LUM2 + .STEP2
     24  41a8				   .LUM3      SET	.LUM3 + .STEP3
     13  41a8					      REPEND
     14  41a8		       44		      .byte.b	$40+(.LUM1/256)
     15  41a9		       26		      .byte.b	$20+(.LUM2/256)
     16  41aa		       98		      .byte.b	$90+(.LUM3/256)
     17  41ab
     18  41ab
     19  41ab
     20  41ab
     21  41ab
     22  41ab				   .LUM1      SET	.LUM1 + .STEP1
     23  41ab				   .LUM2      SET	.LUM2 + .STEP2
     24  41ab				   .LUM3      SET	.LUM3 + .STEP3
     13  41ab					      REPEND
     14  41ab		       44		      .byte.b	$40+(.LUM1/256)
     15  41ac		       26		      .byte.b	$20+(.LUM2/256)
     16  41ad		       98		      .byte.b	$90+(.LUM3/256)
     17  41ae
     18  41ae
     19  41ae
     20  41ae
     21  41ae
     22  41ae				   .LUM1      SET	.LUM1 + .STEP1
     23  41ae				   .LUM2      SET	.LUM2 + .STEP2
     24  41ae				   .LUM3      SET	.LUM3 + .STEP3
     13  41ae					      REPEND
     14  41ae		       44		      .byte.b	$40+(.LUM1/256)
     15  41af		       26		      .byte.b	$20+(.LUM2/256)
     16  41b0		       98		      .byte.b	$90+(.LUM3/256)
     17  41b1
     18  41b1
     19  41b1
     20  41b1
     21  41b1
     22  41b1				   .LUM1      SET	.LUM1 + .STEP1
     23  41b1				   .LUM2      SET	.LUM2 + .STEP2
     24  41b1				   .LUM3      SET	.LUM3 + .STEP3
     13  41b1					      REPEND
     14  41b1		       44		      .byte.b	$40+(.LUM1/256)
     15  41b2		       26		      .byte.b	$20+(.LUM2/256)
     16  41b3		       98		      .byte.b	$90+(.LUM3/256)
     17  41b4
     18  41b4
     19  41b4
     20  41b4
     21  41b4
     22  41b4				   .LUM1      SET	.LUM1 + .STEP1
     23  41b4				   .LUM2      SET	.LUM2 + .STEP2
     24  41b4				   .LUM3      SET	.LUM3 + .STEP3
     13  41b4					      REPEND
     14  41b4		       44		      .byte.b	$40+(.LUM1/256)
     15  41b5		       26		      .byte.b	$20+(.LUM2/256)
     16  41b6		       98		      .byte.b	$90+(.LUM3/256)
     17  41b7
     18  41b7
     19  41b7
     20  41b7
     21  41b7
     22  41b7				   .LUM1      SET	.LUM1 + .STEP1
     23  41b7				   .LUM2      SET	.LUM2 + .STEP2
     24  41b7				   .LUM3      SET	.LUM3 + .STEP3
     13  41b7					      REPEND
     14  41b7		       44		      .byte.b	$40+(.LUM1/256)
     15  41b8		       26		      .byte.b	$20+(.LUM2/256)
     16  41b9		       98		      .byte.b	$90+(.LUM3/256)
     17  41ba
     18  41ba
     19  41ba
     20  41ba
     21  41ba
     22  41ba				   .LUM1      SET	.LUM1 + .STEP1
     23  41ba				   .LUM2      SET	.LUM2 + .STEP2
     24  41ba				   .LUM3      SET	.LUM3 + .STEP3
     13  41ba					      REPEND
     14  41ba		       44		      .byte.b	$40+(.LUM1/256)
     15  41bb		       26		      .byte.b	$20+(.LUM2/256)
     16  41bc		       98		      .byte.b	$90+(.LUM3/256)
     17  41bd
     18  41bd
     19  41bd
     20  41bd
     21  41bd
     22  41bd				   .LUM1      SET	.LUM1 + .STEP1
     23  41bd				   .LUM2      SET	.LUM2 + .STEP2
     24  41bd				   .LUM3      SET	.LUM3 + .STEP3
     13  41bd					      REPEND
     14  41bd		       44		      .byte.b	$40+(.LUM1/256)
     15  41be		       26		      .byte.b	$20+(.LUM2/256)
     16  41bf		       98		      .byte.b	$90+(.LUM3/256)
     17  41c0
     18  41c0
     19  41c0
     20  41c0
     21  41c0
     22  41c0				   .LUM1      SET	.LUM1 + .STEP1
     23  41c0				   .LUM2      SET	.LUM2 + .STEP2
     24  41c0				   .LUM3      SET	.LUM3 + .STEP3
     13  41c0					      REPEND
     14  41c0		       44		      .byte.b	$40+(.LUM1/256)
     15  41c1		       26		      .byte.b	$20+(.LUM2/256)
     16  41c2		       98		      .byte.b	$90+(.LUM3/256)
     17  41c3
     18  41c3
     19  41c3
     20  41c3
     21  41c3
     22  41c3				   .LUM1      SET	.LUM1 + .STEP1
     23  41c3				   .LUM2      SET	.LUM2 + .STEP2
     24  41c3				   .LUM3      SET	.LUM3 + .STEP3
     13  41c3					      REPEND
     14  41c3		       44		      .byte.b	$40+(.LUM1/256)
     15  41c4		       26		      .byte.b	$20+(.LUM2/256)
     16  41c5		       98		      .byte.b	$90+(.LUM3/256)
     17  41c6
     18  41c6
     19  41c6
     20  41c6
     21  41c6
     22  41c6				   .LUM1      SET	.LUM1 + .STEP1
     23  41c6				   .LUM2      SET	.LUM2 + .STEP2
     24  41c6				   .LUM3      SET	.LUM3 + .STEP3
     13  41c6					      REPEND
     14  41c6		       44		      .byte.b	$40+(.LUM1/256)
     15  41c7		       26		      .byte.b	$20+(.LUM2/256)
     16  41c8		       98		      .byte.b	$90+(.LUM3/256)
     17  41c9
     18  41c9
     19  41c9
     20  41c9
     21  41c9
     22  41c9				   .LUM1      SET	.LUM1 + .STEP1
     23  41c9				   .LUM2      SET	.LUM2 + .STEP2
     24  41c9				   .LUM3      SET	.LUM3 + .STEP3
     13  41c9					      REPEND
     14  41c9		       44		      .byte.b	$40+(.LUM1/256)
     15  41ca		       26		      .byte.b	$20+(.LUM2/256)
     16  41cb		       98		      .byte.b	$90+(.LUM3/256)
     17  41cc
     18  41cc
     19  41cc
     20  41cc
     21  41cc
     22  41cc				   .LUM1      SET	.LUM1 + .STEP1
     23  41cc				   .LUM2      SET	.LUM2 + .STEP2
     24  41cc				   .LUM3      SET	.LUM3 + .STEP3
     13  41cc					      REPEND
     14  41cc		       44		      .byte.b	$40+(.LUM1/256)
     15  41cd		       26		      .byte.b	$20+(.LUM2/256)
     16  41ce		       98		      .byte.b	$90+(.LUM3/256)
     17  41cf
     18  41cf
     19  41cf
     20  41cf
     21  41cf
     22  41cf				   .LUM1      SET	.LUM1 + .STEP1
     23  41cf				   .LUM2      SET	.LUM2 + .STEP2
     24  41cf				   .LUM3      SET	.LUM3 + .STEP3
     13  41cf					      REPEND
     14  41cf		       44		      .byte.b	$40+(.LUM1/256)
     15  41d0		       26		      .byte.b	$20+(.LUM2/256)
     16  41d1		       98		      .byte.b	$90+(.LUM3/256)
     17  41d2
     18  41d2
     19  41d2
     20  41d2
     21  41d2
     22  41d2				   .LUM1      SET	.LUM1 + .STEP1
     23  41d2				   .LUM2      SET	.LUM2 + .STEP2
     24  41d2				   .LUM3      SET	.LUM3 + .STEP3
     13  41d2					      REPEND
     14  41d2		       44		      .byte.b	$40+(.LUM1/256)
     15  41d3		       26		      .byte.b	$20+(.LUM2/256)
     16  41d4		       98		      .byte.b	$90+(.LUM3/256)
     17  41d5
     18  41d5
     19  41d5
     20  41d5
     21  41d5
     22  41d5				   .LUM1      SET	.LUM1 + .STEP1
     23  41d5				   .LUM2      SET	.LUM2 + .STEP2
     24  41d5				   .LUM3      SET	.LUM3 + .STEP3
     13  41d5					      REPEND
     14  41d5		       44		      .byte.b	$40+(.LUM1/256)
     15  41d6		       26		      .byte.b	$20+(.LUM2/256)
     16  41d7		       98		      .byte.b	$90+(.LUM3/256)
     17  41d8
     18  41d8
     19  41d8
     20  41d8
     21  41d8
     22  41d8				   .LUM1      SET	.LUM1 + .STEP1
     23  41d8				   .LUM2      SET	.LUM2 + .STEP2
     24  41d8				   .LUM3      SET	.LUM3 + .STEP3
     25  41d8					      REPEND
    257  41d8							;colr_ntsc   LUMTABLE $70,$40,$a0,$A,$2,$E,$8,$E,$8
    258  41d8
    259  41d8							;    ECHO "PAL LUMS"
    260  41d8							;    OPTIONAL_PAGEBREAK "colr_pal", 72*3
      0  41d8				   colr_pal   LUMTABLE	$60, $80, $10, $6,$4,$8,$6,$4,$8
      1  41d8
      2  41d8
      3  41d8
      4  41d8
      5  41d8				   .LUM1      SET	$6*256
      6  41d8				   .LUM2      SET	$4*256
      7  41d8				   .LUM3      SET	$8*256
      8  41d8
      9  41d8		       00 00	   .STEP1     =	(256*($6-$6))/72
     10  41d8		       00 00	   .STEP2     =	(256*($4-$4))/72
     11  41d8		       00 00	   .STEP3     =	(256*($8-$8))/72
     12  41d8
     13  41d8					      REPEAT	72
     14  41d8		       66		      .byte.b	$60+(.LUM1/256)
     15  41d9		       84		      .byte.b	$80+(.LUM2/256)
     16  41da		       18		      .byte.b	$10+(.LUM3/256)
     17  41db
     18  41db
     19  41db
     20  41db
     21  41db
     22  41db				   .LUM1      SET	.LUM1 + .STEP1
     23  41db				   .LUM2      SET	.LUM2 + .STEP2
     24  41db				   .LUM3      SET	.LUM3 + .STEP3
     13  41db					      REPEND
     14  41db		       66		      .byte.b	$60+(.LUM1/256)
     15  41dc		       84		      .byte.b	$80+(.LUM2/256)
     16  41dd		       18		      .byte.b	$10+(.LUM3/256)
     17  41de
     18  41de
     19  41de
     20  41de
     21  41de
     22  41de				   .LUM1      SET	.LUM1 + .STEP1
     23  41de				   .LUM2      SET	.LUM2 + .STEP2
     24  41de				   .LUM3      SET	.LUM3 + .STEP3
     13  41de					      REPEND
     14  41de		       66		      .byte.b	$60+(.LUM1/256)
     15  41df		       84		      .byte.b	$80+(.LUM2/256)
     16  41e0		       18		      .byte.b	$10+(.LUM3/256)
     17  41e1
     18  41e1
     19  41e1
     20  41e1
     21  41e1
     22  41e1				   .LUM1      SET	.LUM1 + .STEP1
     23  41e1				   .LUM2      SET	.LUM2 + .STEP2
     24  41e1				   .LUM3      SET	.LUM3 + .STEP3
     13  41e1					      REPEND
     14  41e1		       66		      .byte.b	$60+(.LUM1/256)
     15  41e2		       84		      .byte.b	$80+(.LUM2/256)
     16  41e3		       18		      .byte.b	$10+(.LUM3/256)
     17  41e4
     18  41e4
     19  41e4
     20  41e4
     21  41e4
     22  41e4				   .LUM1      SET	.LUM1 + .STEP1
     23  41e4				   .LUM2      SET	.LUM2 + .STEP2
     24  41e4				   .LUM3      SET	.LUM3 + .STEP3
     13  41e4					      REPEND
     14  41e4		       66		      .byte.b	$60+(.LUM1/256)
     15  41e5		       84		      .byte.b	$80+(.LUM2/256)
     16  41e6		       18		      .byte.b	$10+(.LUM3/256)
     17  41e7
     18  41e7
     19  41e7
     20  41e7
     21  41e7
     22  41e7				   .LUM1      SET	.LUM1 + .STEP1
     23  41e7				   .LUM2      SET	.LUM2 + .STEP2
     24  41e7				   .LUM3      SET	.LUM3 + .STEP3
     13  41e7					      REPEND
     14  41e7		       66		      .byte.b	$60+(.LUM1/256)
     15  41e8		       84		      .byte.b	$80+(.LUM2/256)
     16  41e9		       18		      .byte.b	$10+(.LUM3/256)
     17  41ea
     18  41ea
     19  41ea
     20  41ea
     21  41ea
     22  41ea				   .LUM1      SET	.LUM1 + .STEP1
     23  41ea				   .LUM2      SET	.LUM2 + .STEP2
     24  41ea				   .LUM3      SET	.LUM3 + .STEP3
     13  41ea					      REPEND
     14  41ea		       66		      .byte.b	$60+(.LUM1/256)
     15  41eb		       84		      .byte.b	$80+(.LUM2/256)
     16  41ec		       18		      .byte.b	$10+(.LUM3/256)
     17  41ed
     18  41ed
     19  41ed
     20  41ed
     21  41ed
     22  41ed				   .LUM1      SET	.LUM1 + .STEP1
     23  41ed				   .LUM2      SET	.LUM2 + .STEP2
     24  41ed				   .LUM3      SET	.LUM3 + .STEP3
     13  41ed					      REPEND
     14  41ed		       66		      .byte.b	$60+(.LUM1/256)
     15  41ee		       84		      .byte.b	$80+(.LUM2/256)
     16  41ef		       18		      .byte.b	$10+(.LUM3/256)
     17  41f0
     18  41f0
     19  41f0
     20  41f0
     21  41f0
     22  41f0				   .LUM1      SET	.LUM1 + .STEP1
     23  41f0				   .LUM2      SET	.LUM2 + .STEP2
     24  41f0				   .LUM3      SET	.LUM3 + .STEP3
     13  41f0					      REPEND
     14  41f0		       66		      .byte.b	$60+(.LUM1/256)
     15  41f1		       84		      .byte.b	$80+(.LUM2/256)
     16  41f2		       18		      .byte.b	$10+(.LUM3/256)
     17  41f3
     18  41f3
     19  41f3
     20  41f3
     21  41f3
     22  41f3				   .LUM1      SET	.LUM1 + .STEP1
     23  41f3				   .LUM2      SET	.LUM2 + .STEP2
     24  41f3				   .LUM3      SET	.LUM3 + .STEP3
     13  41f3					      REPEND
     14  41f3		       66		      .byte.b	$60+(.LUM1/256)
     15  41f4		       84		      .byte.b	$80+(.LUM2/256)
     16  41f5		       18		      .byte.b	$10+(.LUM3/256)
     17  41f6
     18  41f6
     19  41f6
     20  41f6
     21  41f6
     22  41f6				   .LUM1      SET	.LUM1 + .STEP1
     23  41f6				   .LUM2      SET	.LUM2 + .STEP2
     24  41f6				   .LUM3      SET	.LUM3 + .STEP3
     13  41f6					      REPEND
     14  41f6		       66		      .byte.b	$60+(.LUM1/256)
     15  41f7		       84		      .byte.b	$80+(.LUM2/256)
     16  41f8		       18		      .byte.b	$10+(.LUM3/256)
     17  41f9
     18  41f9
     19  41f9
     20  41f9
     21  41f9
     22  41f9				   .LUM1      SET	.LUM1 + .STEP1
     23  41f9				   .LUM2      SET	.LUM2 + .STEP2
     24  41f9				   .LUM3      SET	.LUM3 + .STEP3
     13  41f9					      REPEND
     14  41f9		       66		      .byte.b	$60+(.LUM1/256)
     15  41fa		       84		      .byte.b	$80+(.LUM2/256)
     16  41fb		       18		      .byte.b	$10+(.LUM3/256)
     17  41fc
     18  41fc
     19  41fc
     20  41fc
     21  41fc
     22  41fc				   .LUM1      SET	.LUM1 + .STEP1
     23  41fc				   .LUM2      SET	.LUM2 + .STEP2
     24  41fc				   .LUM3      SET	.LUM3 + .STEP3
     13  41fc					      REPEND
     14  41fc		       66		      .byte.b	$60+(.LUM1/256)
     15  41fd		       84		      .byte.b	$80+(.LUM2/256)
     16  41fe		       18		      .byte.b	$10+(.LUM3/256)
     17  41ff
     18  41ff
     19  41ff
     20  41ff
     21  41ff
     22  41ff				   .LUM1      SET	.LUM1 + .STEP1
     23  41ff				   .LUM2      SET	.LUM2 + .STEP2
     24  41ff				   .LUM3      SET	.LUM3 + .STEP3
     13  41ff					      REPEND
     14  41ff		       66		      .byte.b	$60+(.LUM1/256)
     15  4200		       84		      .byte.b	$80+(.LUM2/256)
     16  4201		       18		      .byte.b	$10+(.LUM3/256)
     17  4202
     18  4202
     19  4202
     20  4202
     21  4202
     22  4202				   .LUM1      SET	.LUM1 + .STEP1
     23  4202				   .LUM2      SET	.LUM2 + .STEP2
     24  4202				   .LUM3      SET	.LUM3 + .STEP3
     13  4202					      REPEND
     14  4202		       66		      .byte.b	$60+(.LUM1/256)
     15  4203		       84		      .byte.b	$80+(.LUM2/256)
     16  4204		       18		      .byte.b	$10+(.LUM3/256)
     17  4205
     18  4205
     19  4205
     20  4205
     21  4205
     22  4205				   .LUM1      SET	.LUM1 + .STEP1
     23  4205				   .LUM2      SET	.LUM2 + .STEP2
     24  4205				   .LUM3      SET	.LUM3 + .STEP3
     13  4205					      REPEND
     14  4205		       66		      .byte.b	$60+(.LUM1/256)
     15  4206		       84		      .byte.b	$80+(.LUM2/256)
     16  4207		       18		      .byte.b	$10+(.LUM3/256)
     17  4208
     18  4208
     19  4208
     20  4208
     21  4208
     22  4208				   .LUM1      SET	.LUM1 + .STEP1
     23  4208				   .LUM2      SET	.LUM2 + .STEP2
     24  4208				   .LUM3      SET	.LUM3 + .STEP3
     13  4208					      REPEND
     14  4208		       66		      .byte.b	$60+(.LUM1/256)
     15  4209		       84		      .byte.b	$80+(.LUM2/256)
     16  420a		       18		      .byte.b	$10+(.LUM3/256)
     17  420b
     18  420b
     19  420b
     20  420b
     21  420b
     22  420b				   .LUM1      SET	.LUM1 + .STEP1
     23  420b				   .LUM2      SET	.LUM2 + .STEP2
     24  420b				   .LUM3      SET	.LUM3 + .STEP3
     13  420b					      REPEND
     14  420b		       66		      .byte.b	$60+(.LUM1/256)
     15  420c		       84		      .byte.b	$80+(.LUM2/256)
     16  420d		       18		      .byte.b	$10+(.LUM3/256)
     17  420e
     18  420e
     19  420e
     20  420e
     21  420e
     22  420e				   .LUM1      SET	.LUM1 + .STEP1
     23  420e				   .LUM2      SET	.LUM2 + .STEP2
     24  420e				   .LUM3      SET	.LUM3 + .STEP3
     13  420e					      REPEND
     14  420e		       66		      .byte.b	$60+(.LUM1/256)
     15  420f		       84		      .byte.b	$80+(.LUM2/256)
     16  4210		       18		      .byte.b	$10+(.LUM3/256)
     17  4211
     18  4211
     19  4211
     20  4211
     21  4211
     22  4211				   .LUM1      SET	.LUM1 + .STEP1
     23  4211				   .LUM2      SET	.LUM2 + .STEP2
     24  4211				   .LUM3      SET	.LUM3 + .STEP3
     13  4211					      REPEND
     14  4211		       66		      .byte.b	$60+(.LUM1/256)
     15  4212		       84		      .byte.b	$80+(.LUM2/256)
     16  4213		       18		      .byte.b	$10+(.LUM3/256)
     17  4214
     18  4214
     19  4214
     20  4214
     21  4214
     22  4214				   .LUM1      SET	.LUM1 + .STEP1
     23  4214				   .LUM2      SET	.LUM2 + .STEP2
     24  4214				   .LUM3      SET	.LUM3 + .STEP3
     13  4214					      REPEND
     14  4214		       66		      .byte.b	$60+(.LUM1/256)
     15  4215		       84		      .byte.b	$80+(.LUM2/256)
     16  4216		       18		      .byte.b	$10+(.LUM3/256)
     17  4217
     18  4217
     19  4217
     20  4217
     21  4217
     22  4217				   .LUM1      SET	.LUM1 + .STEP1
     23  4217				   .LUM2      SET	.LUM2 + .STEP2
     24  4217				   .LUM3      SET	.LUM3 + .STEP3
     13  4217					      REPEND
     14  4217		       66		      .byte.b	$60+(.LUM1/256)
     15  4218		       84		      .byte.b	$80+(.LUM2/256)
     16  4219		       18		      .byte.b	$10+(.LUM3/256)
     17  421a
     18  421a
     19  421a
     20  421a
     21  421a
     22  421a				   .LUM1      SET	.LUM1 + .STEP1
     23  421a				   .LUM2      SET	.LUM2 + .STEP2
     24  421a				   .LUM3      SET	.LUM3 + .STEP3
     13  421a					      REPEND
     14  421a		       66		      .byte.b	$60+(.LUM1/256)
     15  421b		       84		      .byte.b	$80+(.LUM2/256)
     16  421c		       18		      .byte.b	$10+(.LUM3/256)
     17  421d
     18  421d
     19  421d
     20  421d
     21  421d
     22  421d				   .LUM1      SET	.LUM1 + .STEP1
     23  421d				   .LUM2      SET	.LUM2 + .STEP2
     24  421d				   .LUM3      SET	.LUM3 + .STEP3
     13  421d					      REPEND
     14  421d		       66		      .byte.b	$60+(.LUM1/256)
     15  421e		       84		      .byte.b	$80+(.LUM2/256)
     16  421f		       18		      .byte.b	$10+(.LUM3/256)
     17  4220
     18  4220
     19  4220
     20  4220
     21  4220
     22  4220				   .LUM1      SET	.LUM1 + .STEP1
     23  4220				   .LUM2      SET	.LUM2 + .STEP2
     24  4220				   .LUM3      SET	.LUM3 + .STEP3
     13  4220					      REPEND
     14  4220		       66		      .byte.b	$60+(.LUM1/256)
     15  4221		       84		      .byte.b	$80+(.LUM2/256)
     16  4222		       18		      .byte.b	$10+(.LUM3/256)
     17  4223
     18  4223
     19  4223
     20  4223
     21  4223
     22  4223				   .LUM1      SET	.LUM1 + .STEP1
     23  4223				   .LUM2      SET	.LUM2 + .STEP2
     24  4223				   .LUM3      SET	.LUM3 + .STEP3
     13  4223					      REPEND
     14  4223		       66		      .byte.b	$60+(.LUM1/256)
     15  4224		       84		      .byte.b	$80+(.LUM2/256)
     16  4225		       18		      .byte.b	$10+(.LUM3/256)
     17  4226
     18  4226
     19  4226
     20  4226
     21  4226
     22  4226				   .LUM1      SET	.LUM1 + .STEP1
     23  4226				   .LUM2      SET	.LUM2 + .STEP2
     24  4226				   .LUM3      SET	.LUM3 + .STEP3
     13  4226					      REPEND
     14  4226		       66		      .byte.b	$60+(.LUM1/256)
     15  4227		       84		      .byte.b	$80+(.LUM2/256)
     16  4228		       18		      .byte.b	$10+(.LUM3/256)
     17  4229
     18  4229
     19  4229
     20  4229
     21  4229
     22  4229				   .LUM1      SET	.LUM1 + .STEP1
     23  4229				   .LUM2      SET	.LUM2 + .STEP2
     24  4229				   .LUM3      SET	.LUM3 + .STEP3
     13  4229					      REPEND
     14  4229		       66		      .byte.b	$60+(.LUM1/256)
     15  422a		       84		      .byte.b	$80+(.LUM2/256)
     16  422b		       18		      .byte.b	$10+(.LUM3/256)
     17  422c
     18  422c
     19  422c
     20  422c
     21  422c
     22  422c				   .LUM1      SET	.LUM1 + .STEP1
     23  422c				   .LUM2      SET	.LUM2 + .STEP2
     24  422c				   .LUM3      SET	.LUM3 + .STEP3
     13  422c					      REPEND
     14  422c		       66		      .byte.b	$60+(.LUM1/256)
     15  422d		       84		      .byte.b	$80+(.LUM2/256)
     16  422e		       18		      .byte.b	$10+(.LUM3/256)
     17  422f
     18  422f
     19  422f
     20  422f
     21  422f
     22  422f				   .LUM1      SET	.LUM1 + .STEP1
     23  422f				   .LUM2      SET	.LUM2 + .STEP2
     24  422f				   .LUM3      SET	.LUM3 + .STEP3
     13  422f					      REPEND
     14  422f		       66		      .byte.b	$60+(.LUM1/256)
     15  4230		       84		      .byte.b	$80+(.LUM2/256)
     16  4231		       18		      .byte.b	$10+(.LUM3/256)
     17  4232
     18  4232
     19  4232
     20  4232
     21  4232
     22  4232				   .LUM1      SET	.LUM1 + .STEP1
     23  4232				   .LUM2      SET	.LUM2 + .STEP2
     24  4232				   .LUM3      SET	.LUM3 + .STEP3
     13  4232					      REPEND
     14  4232		       66		      .byte.b	$60+(.LUM1/256)
     15  4233		       84		      .byte.b	$80+(.LUM2/256)
     16  4234		       18		      .byte.b	$10+(.LUM3/256)
     17  4235
     18  4235
     19  4235
     20  4235
     21  4235
     22  4235				   .LUM1      SET	.LUM1 + .STEP1
     23  4235				   .LUM2      SET	.LUM2 + .STEP2
     24  4235				   .LUM3      SET	.LUM3 + .STEP3
     13  4235					      REPEND
     14  4235		       66		      .byte.b	$60+(.LUM1/256)
     15  4236		       84		      .byte.b	$80+(.LUM2/256)
     16  4237		       18		      .byte.b	$10+(.LUM3/256)
     17  4238
     18  4238
     19  4238
     20  4238
     21  4238
     22  4238				   .LUM1      SET	.LUM1 + .STEP1
     23  4238				   .LUM2      SET	.LUM2 + .STEP2
     24  4238				   .LUM3      SET	.LUM3 + .STEP3
     13  4238					      REPEND
     14  4238		       66		      .byte.b	$60+(.LUM1/256)
     15  4239		       84		      .byte.b	$80+(.LUM2/256)
     16  423a		       18		      .byte.b	$10+(.LUM3/256)
     17  423b
     18  423b
     19  423b
     20  423b
     21  423b
     22  423b				   .LUM1      SET	.LUM1 + .STEP1
     23  423b				   .LUM2      SET	.LUM2 + .STEP2
     24  423b				   .LUM3      SET	.LUM3 + .STEP3
     13  423b					      REPEND
     14  423b		       66		      .byte.b	$60+(.LUM1/256)
     15  423c		       84		      .byte.b	$80+(.LUM2/256)
     16  423d		       18		      .byte.b	$10+(.LUM3/256)
     17  423e
     18  423e
     19  423e
     20  423e
     21  423e
     22  423e				   .LUM1      SET	.LUM1 + .STEP1
     23  423e				   .LUM2      SET	.LUM2 + .STEP2
     24  423e				   .LUM3      SET	.LUM3 + .STEP3
     13  423e					      REPEND
     14  423e		       66		      .byte.b	$60+(.LUM1/256)
     15  423f		       84		      .byte.b	$80+(.LUM2/256)
     16  4240		       18		      .byte.b	$10+(.LUM3/256)
     17  4241
     18  4241
     19  4241
     20  4241
     21  4241
     22  4241				   .LUM1      SET	.LUM1 + .STEP1
     23  4241				   .LUM2      SET	.LUM2 + .STEP2
     24  4241				   .LUM3      SET	.LUM3 + .STEP3
     13  4241					      REPEND
     14  4241		       66		      .byte.b	$60+(.LUM1/256)
     15  4242		       84		      .byte.b	$80+(.LUM2/256)
     16  4243		       18		      .byte.b	$10+(.LUM3/256)
     17  4244
     18  4244
     19  4244
     20  4244
     21  4244
     22  4244				   .LUM1      SET	.LUM1 + .STEP1
     23  4244				   .LUM2      SET	.LUM2 + .STEP2
     24  4244				   .LUM3      SET	.LUM3 + .STEP3
     13  4244					      REPEND
     14  4244		       66		      .byte.b	$60+(.LUM1/256)
     15  4245		       84		      .byte.b	$80+(.LUM2/256)
     16  4246		       18		      .byte.b	$10+(.LUM3/256)
     17  4247
     18  4247
     19  4247
     20  4247
     21  4247
     22  4247				   .LUM1      SET	.LUM1 + .STEP1
     23  4247				   .LUM2      SET	.LUM2 + .STEP2
     24  4247				   .LUM3      SET	.LUM3 + .STEP3
     13  4247					      REPEND
     14  4247		       66		      .byte.b	$60+(.LUM1/256)
     15  4248		       84		      .byte.b	$80+(.LUM2/256)
     16  4249		       18		      .byte.b	$10+(.LUM3/256)
     17  424a
     18  424a
     19  424a
     20  424a
     21  424a
     22  424a				   .LUM1      SET	.LUM1 + .STEP1
     23  424a				   .LUM2      SET	.LUM2 + .STEP2
     24  424a				   .LUM3      SET	.LUM3 + .STEP3
     13  424a					      REPEND
     14  424a		       66		      .byte.b	$60+(.LUM1/256)
     15  424b		       84		      .byte.b	$80+(.LUM2/256)
     16  424c		       18		      .byte.b	$10+(.LUM3/256)
     17  424d
     18  424d
     19  424d
     20  424d
     21  424d
     22  424d				   .LUM1      SET	.LUM1 + .STEP1
     23  424d				   .LUM2      SET	.LUM2 + .STEP2
     24  424d				   .LUM3      SET	.LUM3 + .STEP3
     13  424d					      REPEND
     14  424d		       66		      .byte.b	$60+(.LUM1/256)
     15  424e		       84		      .byte.b	$80+(.LUM2/256)
     16  424f		       18		      .byte.b	$10+(.LUM3/256)
     17  4250
     18  4250
     19  4250
     20  4250
     21  4250
     22  4250				   .LUM1      SET	.LUM1 + .STEP1
     23  4250				   .LUM2      SET	.LUM2 + .STEP2
     24  4250				   .LUM3      SET	.LUM3 + .STEP3
     13  4250					      REPEND
     14  4250		       66		      .byte.b	$60+(.LUM1/256)
     15  4251		       84		      .byte.b	$80+(.LUM2/256)
     16  4252		       18		      .byte.b	$10+(.LUM3/256)
     17  4253
     18  4253
     19  4253
     20  4253
     21  4253
     22  4253				   .LUM1      SET	.LUM1 + .STEP1
     23  4253				   .LUM2      SET	.LUM2 + .STEP2
     24  4253				   .LUM3      SET	.LUM3 + .STEP3
     13  4253					      REPEND
     14  4253		       66		      .byte.b	$60+(.LUM1/256)
     15  4254		       84		      .byte.b	$80+(.LUM2/256)
     16  4255		       18		      .byte.b	$10+(.LUM3/256)
     17  4256
     18  4256
     19  4256
     20  4256
     21  4256
     22  4256				   .LUM1      SET	.LUM1 + .STEP1
     23  4256				   .LUM2      SET	.LUM2 + .STEP2
     24  4256				   .LUM3      SET	.LUM3 + .STEP3
     13  4256					      REPEND
     14  4256		       66		      .byte.b	$60+(.LUM1/256)
     15  4257		       84		      .byte.b	$80+(.LUM2/256)
     16  4258		       18		      .byte.b	$10+(.LUM3/256)
     17  4259
     18  4259
     19  4259
     20  4259
     21  4259
     22  4259				   .LUM1      SET	.LUM1 + .STEP1
     23  4259				   .LUM2      SET	.LUM2 + .STEP2
     24  4259				   .LUM3      SET	.LUM3 + .STEP3
     13  4259					      REPEND
     14  4259		       66		      .byte.b	$60+(.LUM1/256)
     15  425a		       84		      .byte.b	$80+(.LUM2/256)
     16  425b		       18		      .byte.b	$10+(.LUM3/256)
     17  425c
     18  425c
     19  425c
     20  425c
     21  425c
     22  425c				   .LUM1      SET	.LUM1 + .STEP1
     23  425c				   .LUM2      SET	.LUM2 + .STEP2
     24  425c				   .LUM3      SET	.LUM3 + .STEP3
     13  425c					      REPEND
     14  425c		       66		      .byte.b	$60+(.LUM1/256)
     15  425d		       84		      .byte.b	$80+(.LUM2/256)
     16  425e		       18		      .byte.b	$10+(.LUM3/256)
     17  425f
     18  425f
     19  425f
     20  425f
     21  425f
     22  425f				   .LUM1      SET	.LUM1 + .STEP1
     23  425f				   .LUM2      SET	.LUM2 + .STEP2
     24  425f				   .LUM3      SET	.LUM3 + .STEP3
     13  425f					      REPEND
     14  425f		       66		      .byte.b	$60+(.LUM1/256)
     15  4260		       84		      .byte.b	$80+(.LUM2/256)
     16  4261		       18		      .byte.b	$10+(.LUM3/256)
     17  4262
     18  4262
     19  4262
     20  4262
     21  4262
     22  4262				   .LUM1      SET	.LUM1 + .STEP1
     23  4262				   .LUM2      SET	.LUM2 + .STEP2
     24  4262				   .LUM3      SET	.LUM3 + .STEP3
     13  4262					      REPEND
     14  4262		       66		      .byte.b	$60+(.LUM1/256)
     15  4263		       84		      .byte.b	$80+(.LUM2/256)
     16  4264		       18		      .byte.b	$10+(.LUM3/256)
     17  4265
     18  4265
     19  4265
     20  4265
     21  4265
     22  4265				   .LUM1      SET	.LUM1 + .STEP1
     23  4265				   .LUM2      SET	.LUM2 + .STEP2
     24  4265				   .LUM3      SET	.LUM3 + .STEP3
     13  4265					      REPEND
     14  4265		       66		      .byte.b	$60+(.LUM1/256)
     15  4266		       84		      .byte.b	$80+(.LUM2/256)
     16  4267		       18		      .byte.b	$10+(.LUM3/256)
     17  4268
     18  4268
     19  4268
     20  4268
     21  4268
     22  4268				   .LUM1      SET	.LUM1 + .STEP1
     23  4268				   .LUM2      SET	.LUM2 + .STEP2
     24  4268				   .LUM3      SET	.LUM3 + .STEP3
     13  4268					      REPEND
     14  4268		       66		      .byte.b	$60+(.LUM1/256)
     15  4269		       84		      .byte.b	$80+(.LUM2/256)
     16  426a		       18		      .byte.b	$10+(.LUM3/256)
     17  426b
     18  426b
     19  426b
     20  426b
     21  426b
     22  426b				   .LUM1      SET	.LUM1 + .STEP1
     23  426b				   .LUM2      SET	.LUM2 + .STEP2
     24  426b				   .LUM3      SET	.LUM3 + .STEP3
     13  426b					      REPEND
     14  426b		       66		      .byte.b	$60+(.LUM1/256)
     15  426c		       84		      .byte.b	$80+(.LUM2/256)
     16  426d		       18		      .byte.b	$10+(.LUM3/256)
     17  426e
     18  426e
     19  426e
     20  426e
     21  426e
     22  426e				   .LUM1      SET	.LUM1 + .STEP1
     23  426e				   .LUM2      SET	.LUM2 + .STEP2
     24  426e				   .LUM3      SET	.LUM3 + .STEP3
     13  426e					      REPEND
     14  426e		       66		      .byte.b	$60+(.LUM1/256)
     15  426f		       84		      .byte.b	$80+(.LUM2/256)
     16  4270		       18		      .byte.b	$10+(.LUM3/256)
     17  4271
     18  4271
     19  4271
     20  4271
     21  4271
     22  4271				   .LUM1      SET	.LUM1 + .STEP1
     23  4271				   .LUM2      SET	.LUM2 + .STEP2
     24  4271				   .LUM3      SET	.LUM3 + .STEP3
     13  4271					      REPEND
     14  4271		       66		      .byte.b	$60+(.LUM1/256)
     15  4272		       84		      .byte.b	$80+(.LUM2/256)
     16  4273		       18		      .byte.b	$10+(.LUM3/256)
     17  4274
     18  4274
     19  4274
     20  4274
     21  4274
     22  4274				   .LUM1      SET	.LUM1 + .STEP1
     23  4274				   .LUM2      SET	.LUM2 + .STEP2
     24  4274				   .LUM3      SET	.LUM3 + .STEP3
     13  4274					      REPEND
     14  4274		       66		      .byte.b	$60+(.LUM1/256)
     15  4275		       84		      .byte.b	$80+(.LUM2/256)
     16  4276		       18		      .byte.b	$10+(.LUM3/256)
     17  4277
     18  4277
     19  4277
     20  4277
     21  4277
     22  4277				   .LUM1      SET	.LUM1 + .STEP1
     23  4277				   .LUM2      SET	.LUM2 + .STEP2
     24  4277				   .LUM3      SET	.LUM3 + .STEP3
     13  4277					      REPEND
     14  4277		       66		      .byte.b	$60+(.LUM1/256)
     15  4278		       84		      .byte.b	$80+(.LUM2/256)
     16  4279		       18		      .byte.b	$10+(.LUM3/256)
     17  427a
     18  427a
     19  427a
     20  427a
     21  427a
     22  427a				   .LUM1      SET	.LUM1 + .STEP1
     23  427a				   .LUM2      SET	.LUM2 + .STEP2
     24  427a				   .LUM3      SET	.LUM3 + .STEP3
     13  427a					      REPEND
     14  427a		       66		      .byte.b	$60+(.LUM1/256)
     15  427b		       84		      .byte.b	$80+(.LUM2/256)
     16  427c		       18		      .byte.b	$10+(.LUM3/256)
     17  427d
     18  427d
     19  427d
     20  427d
     21  427d
     22  427d				   .LUM1      SET	.LUM1 + .STEP1
     23  427d				   .LUM2      SET	.LUM2 + .STEP2
     24  427d				   .LUM3      SET	.LUM3 + .STEP3
     13  427d					      REPEND
     14  427d		       66		      .byte.b	$60+(.LUM1/256)
     15  427e		       84		      .byte.b	$80+(.LUM2/256)
     16  427f		       18		      .byte.b	$10+(.LUM3/256)
     17  4280
     18  4280
     19  4280
     20  4280
     21  4280
     22  4280				   .LUM1      SET	.LUM1 + .STEP1
     23  4280				   .LUM2      SET	.LUM2 + .STEP2
     24  4280				   .LUM3      SET	.LUM3 + .STEP3
     13  4280					      REPEND
     14  4280		       66		      .byte.b	$60+(.LUM1/256)
     15  4281		       84		      .byte.b	$80+(.LUM2/256)
     16  4282		       18		      .byte.b	$10+(.LUM3/256)
     17  4283
     18  4283
     19  4283
     20  4283
     21  4283
     22  4283				   .LUM1      SET	.LUM1 + .STEP1
     23  4283				   .LUM2      SET	.LUM2 + .STEP2
     24  4283				   .LUM3      SET	.LUM3 + .STEP3
     13  4283					      REPEND
     14  4283		       66		      .byte.b	$60+(.LUM1/256)
     15  4284		       84		      .byte.b	$80+(.LUM2/256)
     16  4285		       18		      .byte.b	$10+(.LUM3/256)
     17  4286
     18  4286
     19  4286
     20  4286
     21  4286
     22  4286				   .LUM1      SET	.LUM1 + .STEP1
     23  4286				   .LUM2      SET	.LUM2 + .STEP2
     24  4286				   .LUM3      SET	.LUM3 + .STEP3
     13  4286					      REPEND
     14  4286		       66		      .byte.b	$60+(.LUM1/256)
     15  4287		       84		      .byte.b	$80+(.LUM2/256)
     16  4288		       18		      .byte.b	$10+(.LUM3/256)
     17  4289
     18  4289
     19  4289
     20  4289
     21  4289
     22  4289				   .LUM1      SET	.LUM1 + .STEP1
     23  4289				   .LUM2      SET	.LUM2 + .STEP2
     24  4289				   .LUM3      SET	.LUM3 + .STEP3
     13  4289					      REPEND
     14  4289		       66		      .byte.b	$60+(.LUM1/256)
     15  428a		       84		      .byte.b	$80+(.LUM2/256)
     16  428b		       18		      .byte.b	$10+(.LUM3/256)
     17  428c
     18  428c
     19  428c
     20  428c
     21  428c
     22  428c				   .LUM1      SET	.LUM1 + .STEP1
     23  428c				   .LUM2      SET	.LUM2 + .STEP2
     24  428c				   .LUM3      SET	.LUM3 + .STEP3
     13  428c					      REPEND
     14  428c		       66		      .byte.b	$60+(.LUM1/256)
     15  428d		       84		      .byte.b	$80+(.LUM2/256)
     16  428e		       18		      .byte.b	$10+(.LUM3/256)
     17  428f
     18  428f
     19  428f
     20  428f
     21  428f
     22  428f				   .LUM1      SET	.LUM1 + .STEP1
     23  428f				   .LUM2      SET	.LUM2 + .STEP2
     24  428f				   .LUM3      SET	.LUM3 + .STEP3
     13  428f					      REPEND
     14  428f		       66		      .byte.b	$60+(.LUM1/256)
     15  4290		       84		      .byte.b	$80+(.LUM2/256)
     16  4291		       18		      .byte.b	$10+(.LUM3/256)
     17  4292
     18  4292
     19  4292
     20  4292
     21  4292
     22  4292				   .LUM1      SET	.LUM1 + .STEP1
     23  4292				   .LUM2      SET	.LUM2 + .STEP2
     24  4292				   .LUM3      SET	.LUM3 + .STEP3
     13  4292					      REPEND
     14  4292		       66		      .byte.b	$60+(.LUM1/256)
     15  4293		       84		      .byte.b	$80+(.LUM2/256)
     16  4294		       18		      .byte.b	$10+(.LUM3/256)
     17  4295
     18  4295
     19  4295
     20  4295
     21  4295
     22  4295				   .LUM1      SET	.LUM1 + .STEP1
     23  4295				   .LUM2      SET	.LUM2 + .STEP2
     24  4295				   .LUM3      SET	.LUM3 + .STEP3
     13  4295					      REPEND
     14  4295		       66		      .byte.b	$60+(.LUM1/256)
     15  4296		       84		      .byte.b	$80+(.LUM2/256)
     16  4297		       18		      .byte.b	$10+(.LUM3/256)
     17  4298
     18  4298
     19  4298
     20  4298
     21  4298
     22  4298				   .LUM1      SET	.LUM1 + .STEP1
     23  4298				   .LUM2      SET	.LUM2 + .STEP2
     24  4298				   .LUM3      SET	.LUM3 + .STEP3
     13  4298					      REPEND
     14  4298		       66		      .byte.b	$60+(.LUM1/256)
     15  4299		       84		      .byte.b	$80+(.LUM2/256)
     16  429a		       18		      .byte.b	$10+(.LUM3/256)
     17  429b
     18  429b
     19  429b
     20  429b
     21  429b
     22  429b				   .LUM1      SET	.LUM1 + .STEP1
     23  429b				   .LUM2      SET	.LUM2 + .STEP2
     24  429b				   .LUM3      SET	.LUM3 + .STEP3
     13  429b					      REPEND
     14  429b		       66		      .byte.b	$60+(.LUM1/256)
     15  429c		       84		      .byte.b	$80+(.LUM2/256)
     16  429d		       18		      .byte.b	$10+(.LUM3/256)
     17  429e
     18  429e
     19  429e
     20  429e
     21  429e
     22  429e				   .LUM1      SET	.LUM1 + .STEP1
     23  429e				   .LUM2      SET	.LUM2 + .STEP2
     24  429e				   .LUM3      SET	.LUM3 + .STEP3
     13  429e					      REPEND
     14  429e		       66		      .byte.b	$60+(.LUM1/256)
     15  429f		       84		      .byte.b	$80+(.LUM2/256)
     16  42a0		       18		      .byte.b	$10+(.LUM3/256)
     17  42a1
     18  42a1
     19  42a1
     20  42a1
     21  42a1
     22  42a1				   .LUM1      SET	.LUM1 + .STEP1
     23  42a1				   .LUM2      SET	.LUM2 + .STEP2
     24  42a1				   .LUM3      SET	.LUM3 + .STEP3
     13  42a1					      REPEND
     14  42a1		       66		      .byte.b	$60+(.LUM1/256)
     15  42a2		       84		      .byte.b	$80+(.LUM2/256)
     16  42a3		       18		      .byte.b	$10+(.LUM3/256)
     17  42a4
     18  42a4
     19  42a4
     20  42a4
     21  42a4
     22  42a4				   .LUM1      SET	.LUM1 + .STEP1
     23  42a4				   .LUM2      SET	.LUM2 + .STEP2
     24  42a4				   .LUM3      SET	.LUM3 + .STEP3
     13  42a4					      REPEND
     14  42a4		       66		      .byte.b	$60+(.LUM1/256)
     15  42a5		       84		      .byte.b	$80+(.LUM2/256)
     16  42a6		       18		      .byte.b	$10+(.LUM3/256)
     17  42a7
     18  42a7
     19  42a7
     20  42a7
     21  42a7
     22  42a7				   .LUM1      SET	.LUM1 + .STEP1
     23  42a7				   .LUM2      SET	.LUM2 + .STEP2
     24  42a7				   .LUM3      SET	.LUM3 + .STEP3
     13  42a7					      REPEND
     14  42a7		       66		      .byte.b	$60+(.LUM1/256)
     15  42a8		       84		      .byte.b	$80+(.LUM2/256)
     16  42a9		       18		      .byte.b	$10+(.LUM3/256)
     17  42aa
     18  42aa
     19  42aa
     20  42aa
     21  42aa
     22  42aa				   .LUM1      SET	.LUM1 + .STEP1
     23  42aa				   .LUM2      SET	.LUM2 + .STEP2
     24  42aa				   .LUM3      SET	.LUM3 + .STEP3
     13  42aa					      REPEND
     14  42aa		       66		      .byte.b	$60+(.LUM1/256)
     15  42ab		       84		      .byte.b	$80+(.LUM2/256)
     16  42ac		       18		      .byte.b	$10+(.LUM3/256)
     17  42ad
     18  42ad
     19  42ad
     20  42ad
     21  42ad
     22  42ad				   .LUM1      SET	.LUM1 + .STEP1
     23  42ad				   .LUM2      SET	.LUM2 + .STEP2
     24  42ad				   .LUM3      SET	.LUM3 + .STEP3
     13  42ad					      REPEND
     14  42ad		       66		      .byte.b	$60+(.LUM1/256)
     15  42ae		       84		      .byte.b	$80+(.LUM2/256)
     16  42af		       18		      .byte.b	$10+(.LUM3/256)
     17  42b0
     18  42b0
     19  42b0
     20  42b0
     21  42b0
     22  42b0				   .LUM1      SET	.LUM1 + .STEP1
     23  42b0				   .LUM2      SET	.LUM2 + .STEP2
     24  42b0				   .LUM3      SET	.LUM3 + .STEP3
     25  42b0					      REPEND
    262  42b0							;colr_pal	  LUMTABLE $90, $20, $60, $6,$A,$a,$C,$6,$8
    263  42b0
------- FILE titleData.asm LEVEL 3 PASS 5
      0  42b0					      include	"titleData.asm"
      1  42b0				   COL_0
      2  42b0		       00		      .byte.b	0	;R (71)
      3  42b1		       00		      .byte.b	0	;G
      4  42b2		       00		      .byte.b	0	;B
      5  42b3		       40		      .byte.b	64	;R (70)
      6  42b4		       40		      .byte.b	64	;G
      7  42b5		       00		      .byte.b	0	;B
      8  42b6		       00		      .byte.b	0	;R (69)
      9  42b7		       00		      .byte.b	0	;G
     10  42b8		       00		      .byte.b	0	;B
     11  42b9		       00		      .byte.b	0	;R (68)
     12  42ba		       80		      .byte.b	128	;G
     13  42bb		       00		      .byte.b	0	;B
     14  42bc		       00		      .byte.b	0	;R (67)
     15  42bd		       20		      .byte.b	32	;G
     16  42be		       00		      .byte.b	0	;B
     17  42bf		       80		      .byte.b	128	;R (66)
     18  42c0		       80		      .byte.b	128	;G
     19  42c1		       00		      .byte.b	0	;B
     20  42c2		       c0		      .byte.b	192	;R (65)
     21  42c3		       c0		      .byte.b	192	;G
     22  42c4		       00		      .byte.b	0	;B
     23  42c5		       40		      .byte.b	64	;R (64)
     24  42c6		       c0		      .byte.b	192	;G
     25  42c7		       00		      .byte.b	0	;B
     26  42c8		       00		      .byte.b	0	;R (63)
     27  42c9		       a0		      .byte.b	160	;G
     28  42ca		       00		      .byte.b	0	;B
     29  42cb		       10		      .byte.b	16	;R (62)
     30  42cc		       70		      .byte.b	112	;G
     31  42cd		       00		      .byte.b	0	;B
     32  42ce		       00		      .byte.b	0	;R (61)
     33  42cf		       80		      .byte.b	128	;G
     34  42d0		       40		      .byte.b	64	;B
     35  42d1		       00		      .byte.b	0	;R (60)
     36  42d2		       c0		      .byte.b	192	;G
     37  42d3		       00		      .byte.b	0	;B
     38  42d4		       00		      .byte.b	0	;R (59)
     39  42d5		       c0		      .byte.b	192	;G
     40  42d6		       00		      .byte.b	0	;B
     41  42d7		       00		      .byte.b	0	;R (58)
     42  42d8		       40		      .byte.b	64	;G
     43  42d9		       00		      .byte.b	0	;B
     44  42da		       00		      .byte.b	0	;R (57)
     45  42db		       c0		      .byte.b	192	;G
     46  42dc		       00		      .byte.b	0	;B
     47  42dd		       00		      .byte.b	0	;R (56)
     48  42de		       60		      .byte.b	96	;G
     49  42df		       00		      .byte.b	0	;B
     50  42e0		       00		      .byte.b	0	;R (55)
     51  42e1		       80		      .byte.b	128	;G
     52  42e2		       00		      .byte.b	0	;B
     53  42e3		       00		      .byte.b	0	;R (54)
     54  42e4		       40		      .byte.b	64	;G
     55  42e5		       00		      .byte.b	0	;B
     56  42e6		       00		      .byte.b	0	;R (53)
     57  42e7		       80		      .byte.b	128	;G
     58  42e8		       00		      .byte.b	0	;B
     59  42e9		       00		      .byte.b	0	;R (52)
     60  42ea		       80		      .byte.b	128	;G
     61  42eb		       00		      .byte.b	0	;B
     62  42ec		       00		      .byte.b	0	;R (51)
     63  42ed		       10		      .byte.b	16	;G
     64  42ee		       00		      .byte.b	0	;B
     65  42ef		       00		      .byte.b	0	;R (50)
     66  42f0		       00		      .byte.b	0	;G
     67  42f1		       00		      .byte.b	0	;B
     68  42f2		       00		      .byte.b	0	;R (49)
     69  42f3		       00		      .byte.b	0	;G
     70  42f4		       00		      .byte.b	0	;B
     71  42f5		       00		      .byte.b	0	;R (48)
     72  42f6		       00		      .byte.b	0	;G
     73  42f7		       00		      .byte.b	0	;B
     74  42f8		       00		      .byte.b	0	;R (47)
     75  42f9		       00		      .byte.b	0	;G
     76  42fa		       00		      .byte.b	0	;B
     77  42fb		       00		      .byte.b	0	;R (46)
     78  42fc		       40		      .byte.b	64	;G
     79  42fd		       00		      .byte.b	0	;B
     80  42fe		       00		      .byte.b	0	;R (45)
     81  42ff		       00		      .byte.b	0	;G
     82  4300		       00		      .byte.b	0	;B
     83  4301		       00		      .byte.b	0	;R (44)
     84  4302		       00		      .byte.b	0	;G
     85  4303		       00		      .byte.b	0	;B
     86  4304		       00		      .byte.b	0	;R (43)
     87  4305		       00		      .byte.b	0	;G
     88  4306		       00		      .byte.b	0	;B
     89  4307		       00		      .byte.b	0	;R (42)
     90  4308		       40		      .byte.b	64	;G
     91  4309		       00		      .byte.b	0	;B
     92  430a		       00		      .byte.b	0	;R (41)
     93  430b		       00		      .byte.b	0	;G
     94  430c		       00		      .byte.b	0	;B
     95  430d		       00		      .byte.b	0	;R (40)
     96  430e		       00		      .byte.b	0	;G
     97  430f		       00		      .byte.b	0	;B
     98  4310		       00		      .byte.b	0	;R (39)
     99  4311		       20		      .byte.b	32	;G
    100  4312		       00		      .byte.b	0	;B
    101  4313		       00		      .byte.b	0	;R (38)
    102  4314		       00		      .byte.b	0	;G
    103  4315		       00		      .byte.b	0	;B
    104  4316		       00		      .byte.b	0	;R (37)
    105  4317		       10		      .byte.b	16	;G
    106  4318		       00		      .byte.b	0	;B
    107  4319		       00		      .byte.b	0	;R (36)
    108  431a		       00		      .byte.b	0	;G
    109  431b		       00		      .byte.b	0	;B
    110  431c		       00		      .byte.b	0	;R (35)
    111  431d		       40		      .byte.b	64	;G
    112  431e		       00		      .byte.b	0	;B
    113  431f		       00		      .byte.b	0	;R (34)
    114  4320		       20		      .byte.b	32	;G
    115  4321		       00		      .byte.b	0	;B
    116  4322		       00		      .byte.b	0	;R (33)
    117  4323		       00		      .byte.b	0	;G
    118  4324		       00		      .byte.b	0	;B
    119  4325		       00		      .byte.b	0	;R (32)
    120  4326		       00		      .byte.b	0	;G
    121  4327		       00		      .byte.b	0	;B
    122  4328		       00		      .byte.b	0	;R (31)
    123  4329		       20		      .byte.b	32	;G
    124  432a		       00		      .byte.b	0	;B
    125  432b		       00		      .byte.b	0	;R (30)
    126  432c		       00		      .byte.b	0	;G
    127  432d		       00		      .byte.b	0	;B
    128  432e		       00		      .byte.b	0	;R (29)
    129  432f		       80		      .byte.b	128	;G
    130  4330		       00		      .byte.b	0	;B
    131  4331		       00		      .byte.b	0	;R (28)
    132  4332		       00		      .byte.b	0	;G
    133  4333		       00		      .byte.b	0	;B
    134  4334		       00		      .byte.b	0	;R (27)
    135  4335		       20		      .byte.b	32	;G
    136  4336		       00		      .byte.b	0	;B
    137  4337		       00		      .byte.b	0	;R (26)
    138  4338		       00		      .byte.b	0	;G
    139  4339		       00		      .byte.b	0	;B
    140  433a		       00		      .byte.b	0	;R (25)
    141  433b		       00		      .byte.b	0	;G
    142  433c		       00		      .byte.b	0	;B
    143  433d		       00		      .byte.b	0	;R (24)
    144  433e		       20		      .byte.b	32	;G
    145  433f		       00		      .byte.b	0	;B
    146  4340		       00		      .byte.b	0	;R (23)
    147  4341		       00		      .byte.b	0	;G
    148  4342		       00		      .byte.b	0	;B
    149  4343		       00		      .byte.b	0	;R (22)
    150  4344		       00		      .byte.b	0	;G
    151  4345		       00		      .byte.b	0	;B
    152  4346		       00		      .byte.b	0	;R (21)
    153  4347		       20		      .byte.b	32	;G
    154  4348		       00		      .byte.b	0	;B
    155  4349		       00		      .byte.b	0	;R (20)
    156  434a		       00		      .byte.b	0	;G
    157  434b		       00		      .byte.b	0	;B
    158  434c		       00		      .byte.b	0	;R (19)
    159  434d		       00		      .byte.b	0	;G
    160  434e		       00		      .byte.b	0	;B
    161  434f		       00		      .byte.b	0	;R (18)
    162  4350		       00		      .byte.b	0	;G
    163  4351		       00		      .byte.b	0	;B
    164  4352		       00		      .byte.b	0	;R (17)
    165  4353		       80		      .byte.b	128	;G
    166  4354		       00		      .byte.b	0	;B
    167  4355		       00		      .byte.b	0	;R (16)
    168  4356		       00		      .byte.b	0	;G
    169  4357		       00		      .byte.b	0	;B
    170  4358		       00		      .byte.b	0	;R (15)
    171  4359		       10		      .byte.b	16	;G
    172  435a		       00		      .byte.b	0	;B
    173  435b		       00		      .byte.b	0	;R (14)
    174  435c		       00		      .byte.b	0	;G
    175  435d		       00		      .byte.b	0	;B
    176  435e		       00		      .byte.b	0	;R (13)
    177  435f		       00		      .byte.b	0	;G
    178  4360		       00		      .byte.b	0	;B
    179  4361		       00		      .byte.b	0	;R (12)
    180  4362		       80		      .byte.b	128	;G
    181  4363		       00		      .byte.b	0	;B
    182  4364		       00		      .byte.b	0	;R (11)
    183  4365		       00		      .byte.b	0	;G
    184  4366		       00		      .byte.b	0	;B
    185  4367		       00		      .byte.b	0	;R (10)
    186  4368		       00		      .byte.b	0	;G
    187  4369		       00		      .byte.b	0	;B
    188  436a		       00		      .byte.b	0	;R (9)
    189  436b		       80		      .byte.b	128	;G
    190  436c		       00		      .byte.b	0	;B
    191  436d		       00		      .byte.b	0	;R (8)
    192  436e		       00		      .byte.b	0	;G
    193  436f		       00		      .byte.b	0	;B
    194  4370		       00		      .byte.b	0	;R (7)
    195  4371		       20		      .byte.b	32	;G
    196  4372		       00		      .byte.b	0	;B
    197  4373		       00		      .byte.b	0	;R (6)
    198  4374		       00		      .byte.b	0	;G
    199  4375		       00		      .byte.b	0	;B
    200  4376		       00		      .byte.b	0	;R (5)
    201  4377		       10		      .byte.b	16	;G
    202  4378		       00		      .byte.b	0	;B
    203  4379		       00		      .byte.b	0	;R (4)
    204  437a		       00		      .byte.b	0	;G
    205  437b		       00		      .byte.b	0	;B
    206  437c		       00		      .byte.b	0	;R (3)
    207  437d		       00		      .byte.b	0	;G
    208  437e		       00		      .byte.b	0	;B
    209  437f		       00		      .byte.b	0	;R (2)
    210  4380		       40		      .byte.b	64	;G
    211  4381		       00		      .byte.b	0	;B
    212  4382		       00		      .byte.b	0	;R (1)
    213  4383		       00		      .byte.b	0	;G
    214  4384		       00		      .byte.b	0	;B
    215  4385		       00		      .byte.b	0	;R (0)
    216  4386		       00		      .byte.b	0	;G
    217  4387		       00		      .byte.b	0	;B
    218  4388				   COL_1
    219  4388		       80		      .byte.b	128	;R (71)
    220  4389		       80		      .byte.b	128	;G
    221  438a		       00		      .byte.b	0	;B
    222  438b		       10		      .byte.b	16	;R (70)
    223  438c		       14		      .byte.b	20	;G
    224  438d		       00		      .byte.b	0	;B
    225  438e		       00		      .byte.b	0	;R (69)
    226  438f		       41		      .byte.b	65	;G
    227  4390		       00		      .byte.b	0	;B
    228  4391		       00		      .byte.b	0	;R (68)
    229  4392		       08		      .byte.b	8	;G
    230  4393		       00		      .byte.b	0	;B
    231  4394		       20		      .byte.b	32	;R (67)
    232  4395		       20		      .byte.b	32	;G
    233  4396		       00		      .byte.b	0	;B
    234  4397		       63		      .byte.b	99	;R (66)
    235  4398		       6b		      .byte.b	107	;G
    236  4399		       00		      .byte.b	0	;B
    237  439a		       ff		      .byte.b	255	;R (65)
    238  439b		       f5		      .byte.b	245	;G
    239  439c		       00		      .byte.b	0	;B
    240  439d		       80		      .byte.b	128	;R (64)
    241  439e		       fb		      .byte.b	251	;G
    242  439f		       04		      .byte.b	4	;B
    243  43a0		       00		      .byte.b	0	;R (63)
    244  43a1		       b7		      .byte.b	183	;G
    245  43a2		       00		      .byte.b	0	;B
    246  43a3		       00		      .byte.b	0	;R (62)
    247  43a4		       b5		      .byte.b	181	;G
    248  43a5		       00		      .byte.b	0	;B
    249  43a6		       00		      .byte.b	0	;R (61)
    250  43a7		       ef		      .byte.b	239	;G
    251  43a8		       10		      .byte.b	16	;B
    252  43a9		       00		      .byte.b	0	;R (60)
    253  43aa		       bd		      .byte.b	189	;G
    254  43ab		       42		      .byte.b	66	;B
    255  43ac		       00		      .byte.b	0	;R (59)
    256  43ad		       77		      .byte.b	119	;G
    257  43ae		       00		      .byte.b	0	;B
    258  43af		       00		      .byte.b	0	;R (58)
    259  43b0		       ee		      .byte.b	238	;G
    260  43b1		       00		      .byte.b	0	;B
    261  43b2		       00		      .byte.b	0	;R (57)
    262  43b3		       9b		      .byte.b	155	;G
    263  43b4		       00		      .byte.b	0	;B
    264  43b5		       00		      .byte.b	0	;R (56)
    265  43b6		       f2		      .byte.b	242	;G
    266  43b7		       00		      .byte.b	0	;B
    267  43b8		       00		      .byte.b	0	;R (55)
    268  43b9		       40		      .byte.b	64	;G
    269  43ba		       00		      .byte.b	0	;B
    270  43bb		       00		      .byte.b	0	;R (54)
    271  43bc		       df		      .byte.b	223	;G
    272  43bd		       00		      .byte.b	0	;B
    273  43be		       10		      .byte.b	16	;R (53)
    274  43bf		       69		      .byte.b	105	;G
    275  43c0		       10		      .byte.b	16	;B
    276  43c1		       00		      .byte.b	0	;R (52)
    277  43c2		       4b		      .byte.b	75	;G
    278  43c3		       00		      .byte.b	0	;B
    279  43c4		       00		      .byte.b	0	;R (51)
    280  43c5		       b0		      .byte.b	176	;G
    281  43c6		       00		      .byte.b	0	;B
    282  43c7		       00		      .byte.b	0	;R (50)
    283  43c8		       a7		      .byte.b	167	;G
    284  43c9		       00		      .byte.b	0	;B
    285  43ca		       00		      .byte.b	0	;R (49)
    286  43cb		       7d		      .byte.b	125	;G
    287  43cc		       02		      .byte.b	2	;B
    288  43cd		       00		      .byte.b	0	;R (48)
    289  43ce		       db		      .byte.b	219	;G
    290  43cf		       20		      .byte.b	32	;B
    291  43d0		       00		      .byte.b	0	;R (47)
    292  43d1		       6d		      .byte.b	109	;G
    293  43d2		       00		      .byte.b	0	;B
    294  43d3		       00		      .byte.b	0	;R (46)
    295  43d4		       ea		      .byte.b	234	;G
    296  43d5		       00		      .byte.b	0	;B
    297  43d6		       00		      .byte.b	0	;R (45)
    298  43d7		       13		      .byte.b	19	;G
    299  43d8		       00		      .byte.b	0	;B
    300  43d9		       00		      .byte.b	0	;R (44)
    301  43da		       7e		      .byte.b	126	;G
    302  43db		       01		      .byte.b	1	;B
    303  43dc		       22		      .byte.b	34	;R (43)
    304  43dd		       77		      .byte.b	119	;G
    305  43de		       08		      .byte.b	8	;B
    306  43df		       04		      .byte.b	4	;R (42)
    307  43e0		       5f		      .byte.b	95	;G
    308  43e1		       00		      .byte.b	0	;B
    309  43e2		       00		      .byte.b	0	;R (41)
    310  43e3		       6f		      .byte.b	111	;G
    311  43e4		       00		      .byte.b	0	;B
    312  43e5		       00		      .byte.b	0	;R (40)
    313  43e6		       b5		      .byte.b	181	;G
    314  43e7		       00		      .byte.b	0	;B
    315  43e8		       00		      .byte.b	0	;R (39)
    316  43e9		       5b		      .byte.b	91	;G
    317  43ea		       00		      .byte.b	0	;B
    318  43eb		       00		      .byte.b	0	;R (38)
    319  43ec		       57		      .byte.b	87	;G
    320  43ed		       00		      .byte.b	0	;B
    321  43ee		       20		      .byte.b	32	;R (37)
    322  43ef		       4d		      .byte.b	77	;G
    323  43f0		       22		      .byte.b	34	;B
    324  43f1		       00		      .byte.b	0	;R (36)
    325  43f2		       55		      .byte.b	85	;G
    326  43f3		       00		      .byte.b	0	;B
    327  43f4		       01		      .byte.b	1	;R (35)
    328  43f5		       56		      .byte.b	86	;G
    329  43f6		       00		      .byte.b	0	;B
    330  43f7		       02		      .byte.b	2	;R (34)
    331  43f8		       57		      .byte.b	87	;G
    332  43f9		       00		      .byte.b	0	;B
    333  43fa		       00		      .byte.b	0	;R (33)
    334  43fb		       2a		      .byte.b	42	;G
    335  43fc		       01		      .byte.b	1	;B
    336  43fd		       01		      .byte.b	1	;R (32)
    337  43fe		       ab		      .byte.b	171	;G
    338  43ff		       00		      .byte.b	0	;B
    339  4400		       22		      .byte.b	34	;R (31)
    340  4401		       17		      .byte.b	23	;G
    341  4402		       20		      .byte.b	32	;B
    342  4403		       00		      .byte.b	0	;R (30)
    343  4404		       55		      .byte.b	85	;G
    344  4405		       02		      .byte.b	2	;B
    345  4406		       22		      .byte.b	34	;R (29)
    346  4407		       17		      .byte.b	23	;G
    347  4408		       20		      .byte.b	32	;B
    348  4409		       00		      .byte.b	0	;R (28)
    349  440a		       2b		      .byte.b	43	;G
    350  440b		       00		      .byte.b	0	;B
    351  440c		       00		      .byte.b	0	;R (27)
    352  440d		       95		      .byte.b	149	;G
    353  440e		       02		      .byte.b	2	;B
    354  440f		       00		      .byte.b	0	;R (26)
    355  4410		       17		      .byte.b	23	;G
    356  4411		       00		      .byte.b	0	;B
    357  4412		       00		      .byte.b	0	;R (25)
    358  4413		       2d		      .byte.b	45	;G
    359  4414		       00		      .byte.b	0	;B
    360  4415		       00		      .byte.b	0	;R (24)
    361  4416		       b4		      .byte.b	180	;G
    362  4417		       00		      .byte.b	0	;B
    363  4418		       00		      .byte.b	0	;R (23)
    364  4419		       0a		      .byte.b	10	;G
    365  441a		       00		      .byte.b	0	;B
    366  441b		       10		      .byte.b	16	;R (22)
    367  441c		       3c		      .byte.b	60	;G
    368  441d		       00		      .byte.b	0	;B
    369  441e		       10		      .byte.b	16	;R (21)
    370  441f		       98		      .byte.b	152	;G
    371  4420		       00		      .byte.b	0	;B
    372  4421		       10		      .byte.b	16	;R (20)
    373  4422		       1a		      .byte.b	26	;G
    374  4423		       00		      .byte.b	0	;B
    375  4424		       00		      .byte.b	0	;R (19)
    376  4425		       14		      .byte.b	20	;G
    377  4426		       00		      .byte.b	0	;B
    378  4427		       00		      .byte.b	0	;R (18)
    379  4428		       5a		      .byte.b	90	;G
    380  4429		       00		      .byte.b	0	;B
    381  442a		       00		      .byte.b	0	;R (17)
    382  442b		       09		      .byte.b	9	;G
    383  442c		       00		      .byte.b	0	;B
    384  442d		       08		      .byte.b	8	;R (16)
    385  442e		       1d		      .byte.b	29	;G
    386  442f		       00		      .byte.b	0	;B
    387  4430		       00		      .byte.b	0	;R (15)
    388  4431		       1a		      .byte.b	26	;G
    389  4432		       00		      .byte.b	0	;B
    390  4433		       20		      .byte.b	32	;R (14)
    391  4434		       ba		      .byte.b	186	;G
    392  4435		       00		      .byte.b	0	;B
    393  4436		       00		      .byte.b	0	;R (13)
    394  4437		       12		      .byte.b	18	;G
    395  4438		       00		      .byte.b	0	;B
    396  4439		       00		      .byte.b	0	;R (12)
    397  443a		       1a		      .byte.b	26	;G
    398  443b		       00		      .byte.b	0	;B
    399  443c		       00		      .byte.b	0	;R (11)
    400  443d		       2d		      .byte.b	45	;G
    401  443e		       10		      .byte.b	16	;B
    402  443f		       10		      .byte.b	16	;R (10)
    403  4440		       3b		      .byte.b	59	;G
    404  4441		       00		      .byte.b	0	;B
    405  4442		       24		      .byte.b	36	;R (9)
    406  4443		       39		      .byte.b	57	;G
    407  4444		       04		      .byte.b	4	;B
    408  4445		       20		      .byte.b	32	;R (8)
    409  4446		       35		      .byte.b	53	;G
    410  4447		       00		      .byte.b	0	;B
    411  4448		       00		      .byte.b	0	;R (7)
    412  4449		       3d		      .byte.b	61	;G
    413  444a		       00		      .byte.b	0	;B
    414  444b		       00		      .byte.b	0	;R (6)
    415  444c		       32		      .byte.b	50	;G
    416  444d		       00		      .byte.b	0	;B
    417  444e		       00		      .byte.b	0	;R (5)
    418  444f		       98		      .byte.b	152	;G
    419  4450		       00		      .byte.b	0	;B
    420  4451		       00		      .byte.b	0	;R (4)
    421  4452		       12		      .byte.b	18	;G
    422  4453		       00		      .byte.b	0	;B
    423  4454		       00		      .byte.b	0	;R (3)
    424  4455		       20		      .byte.b	32	;G
    425  4456		       00		      .byte.b	0	;B
    426  4457		       01		      .byte.b	1	;R (2)
    427  4458		       49		      .byte.b	73	;G
    428  4459		       00		      .byte.b	0	;B
    429  445a		       20		      .byte.b	32	;R (1)
    430  445b		       20		      .byte.b	32	;G
    431  445c		       00		      .byte.b	0	;B
    432  445d		       00		      .byte.b	0	;R (0)
    433  445e		       00		      .byte.b	0	;G
    434  445f		       00		      .byte.b	0	;B
    435  4460				   COL_2
    436  4460		       14		      .byte.b	20	;R (71)
    437  4461		       14		      .byte.b	20	;G
    438  4462		       00		      .byte.b	0	;B
    439  4463		       40		      .byte.b	64	;R (70)
    440  4464		       42		      .byte.b	66	;G
    441  4465		       00		      .byte.b	0	;B
    442  4466		       a8		      .byte.b	168	;R (69)
    443  4467		       a8		      .byte.b	168	;G
    444  4468		       00		      .byte.b	0	;B
    445  4469		       fd		      .byte.b	253	;R (68)
    446  446a		       1d		      .byte.b	29	;G
    447  446b		       00		      .byte.b	0	;B
    448  446c		       f0		      .byte.b	240	;R (67)
    449  446d		       44		      .byte.b	68	;G
    450  446e		       08		      .byte.b	8	;B
    451  446f		       ff		      .byte.b	255	;R (66)
    452  4470		       2f		      .byte.b	47	;G
    453  4471		       00		      .byte.b	0	;B
    454  4472		       ff		      .byte.b	255	;R (65)
    455  4473		       0e		      .byte.b	14	;G
    456  4474		       00		      .byte.b	0	;B
    457  4475		       f8		      .byte.b	248	;R (64)
    458  4476		       0f		      .byte.b	15	;G
    459  4477		       00		      .byte.b	0	;B
    460  4478		       f8		      .byte.b	248	;R (63)
    461  4479		       2e		      .byte.b	46	;G
    462  447a		       00		      .byte.b	0	;B
    463  447b		       f8		      .byte.b	248	;R (62)
    464  447c		       1e		      .byte.b	30	;G
    465  447d		       01		      .byte.b	1	;B
    466  447e		       74		      .byte.b	116	;R (61)
    467  447f		       23		      .byte.b	35	;G
    468  4480		       88		      .byte.b	136	;B
    469  4481		       fc		      .byte.b	252	;R (60)
    470  4482		       0f		      .byte.b	15	;G
    471  4483		       00		      .byte.b	0	;B
    472  4484		       f8		      .byte.b	248	;R (59)
    473  4485		       06		      .byte.b	6	;G
    474  4486		       01		      .byte.b	1	;B
    475  4487		       f8		      .byte.b	248	;R (58)
    476  4488		       8f		      .byte.b	143	;G
    477  4489		       00		      .byte.b	0	;B
    478  448a		       e8		      .byte.b	232	;R (57)
    479  448b		       0e		      .byte.b	14	;G
    480  448c		       10		      .byte.b	16	;B
    481  448d		       e0		      .byte.b	224	;R (56)
    482  448e		       97		      .byte.b	151	;G
    483  448f		       00		      .byte.b	0	;B
    484  4490		       f0		      .byte.b	240	;R (55)
    485  4491		       3a		      .byte.b	58	;G
    486  4492		       00		      .byte.b	0	;B
    487  4493		       e0		      .byte.b	224	;R (54)
    488  4494		       bb		      .byte.b	187	;G
    489  4495		       04		      .byte.b	4	;B
    490  4496		       e0		      .byte.b	224	;R (53)
    491  4497		       3e		      .byte.b	62	;G
    492  4498		       00		      .byte.b	0	;B
    493  4499		       c0		      .byte.b	192	;R (52)
    494  449a		       2a		      .byte.b	42	;G
    495  449b		       00		      .byte.b	0	;B
    496  449c		       80		      .byte.b	128	;R (51)
    497  449d		       3f		      .byte.b	63	;G
    498  449e		       40		      .byte.b	64	;B
    499  449f		       f5		      .byte.b	245	;R (50)
    500  44a0		       3f		      .byte.b	63	;G
    501  44a1		       00		      .byte.b	0	;B
    502  44a2		       e8		      .byte.b	232	;R (49)
    503  44a3		       7f		      .byte.b	127	;G
    504  44a4		       00		      .byte.b	0	;B
    505  44a5		       e0		      .byte.b	224	;R (48)
    506  44a6		       7a		      .byte.b	122	;G
    507  44a7		       04		      .byte.b	4	;B
    508  44a8		       c0		      .byte.b	192	;R (47)
    509  44a9		       5f		      .byte.b	95	;G
    510  44aa		       00		      .byte.b	0	;B
    511  44ab		       90		      .byte.b	144	;R (46)
    512  44ac		       dd		      .byte.b	221	;G
    513  44ad		       02		      .byte.b	2	;B
    514  44ae		       84		      .byte.b	132	;R (45)
    515  44af		       9f		      .byte.b	159	;G
    516  44b0		       00		      .byte.b	0	;B
    517  44b1		       c4		      .byte.b	196	;R (44)
    518  44b2		       cf		      .byte.b	207	;G
    519  44b3		       00		      .byte.b	0	;B
    520  44b4		       c5		      .byte.b	197	;R (43)
    521  44b5		       1f		      .byte.b	31	;G
    522  44b6		       00		      .byte.b	0	;B
    523  44b7		       d4		      .byte.b	212	;R (42)
    524  44b8		       9f		      .byte.b	159	;G
    525  44b9		       20		      .byte.b	32	;B
    526  44ba		       c8		      .byte.b	200	;R (41)
    527  44bb		       1e		      .byte.b	30	;G
    528  44bc		       01		      .byte.b	1	;B
    529  44bd		       c8		      .byte.b	200	;R (40)
    530  44be		       5f		      .byte.b	95	;G
    531  44bf		       00		      .byte.b	0	;B
    532  44c0		       cd		      .byte.b	205	;R (39)
    533  44c1		       5e		      .byte.b	94	;G
    534  44c2		       00		      .byte.b	0	;B
    535  44c3		       c7		      .byte.b	199	;R (38)
    536  44c4		       5b		      .byte.b	91	;G
    537  44c5		       00		      .byte.b	0	;B
    538  44c6		       8b		      .byte.b	139	;R (37)
    539  44c7		       1c		      .byte.b	28	;G
    540  44c8		       00		      .byte.b	0	;B
    541  44c9		       81		      .byte.b	129	;R (36)
    542  44ca		       9a		      .byte.b	154	;G
    543  44cb		       04		      .byte.b	4	;B
    544  44cc		       8e		      .byte.b	142	;R (35)
    545  44cd		       9d		      .byte.b	157	;G
    546  44ce		       00		      .byte.b	0	;B
    547  44cf		       2b		      .byte.b	43	;R (34)
    548  44d0		       36		      .byte.b	54	;G
    549  44d1		       00		      .byte.b	0	;B
    550  44d2		       3a		      .byte.b	58	;R (33)
    551  44d3		       0d		      .byte.b	13	;G
    552  44d4		       00		      .byte.b	0	;B
    553  44d5		       3e		      .byte.b	62	;R (32)
    554  44d6		       85		      .byte.b	133	;G
    555  44d7		       40		      .byte.b	64	;B
    556  44d8		       fa		      .byte.b	250	;R (31)
    557  44d9		       17		      .byte.b	23	;G
    558  44da		       00		      .byte.b	0	;B
    559  44db		       ff		      .byte.b	255	;R (30)
    560  44dc		       03		      .byte.b	3	;G
    561  44dd		       00		      .byte.b	0	;B
    562  44de		       fc		      .byte.b	252	;R (29)
    563  44df		       93		      .byte.b	147	;G
    564  44e0		       00		      .byte.b	0	;B
    565  44e1		       f7		      .byte.b	247	;R (28)
    566  44e2		       81		      .byte.b	129	;G
    567  44e3		       08		      .byte.b	8	;B
    568  44e4		       ff		      .byte.b	255	;R (27)
    569  44e5		       03		      .byte.b	3	;G
    570  44e6		       00		      .byte.b	0	;B
    571  44e7		       fe		      .byte.b	254	;R (26)
    572  44e8		       2b		      .byte.b	43	;G
    573  44e9		       00		      .byte.b	0	;B
    574  44ea		       fe		      .byte.b	254	;R (25)
    575  44eb		       0a		      .byte.b	10	;G
    576  44ec		       00		      .byte.b	0	;B
    577  44ed		       fc		      .byte.b	252	;R (24)
    578  44ee		       4f		      .byte.b	79	;G
    579  44ef		       00		      .byte.b	0	;B
    580  44f0		       fc		      .byte.b	252	;R (23)
    581  44f1		       55		      .byte.b	85	;G
    582  44f2		       00		      .byte.b	0	;B
    583  44f3		       f8		      .byte.b	248	;R (22)
    584  44f4		       45		      .byte.b	69	;G
    585  44f5		       00		      .byte.b	0	;B
    586  44f6		       e8		      .byte.b	232	;R (21)
    587  44f7		       05		      .byte.b	5	;G
    588  44f8		       10		      .byte.b	16	;B
    589  44f9		       f8		      .byte.b	248	;R (20)
    590  44fa		       5b		      .byte.b	91	;G
    591  44fb		       00		      .byte.b	0	;B
    592  44fc		       f8		      .byte.b	248	;R (19)
    593  44fd		       1d		      .byte.b	29	;G
    594  44fe		       00		      .byte.b	0	;B
    595  44ff		       f0		      .byte.b	240	;R (18)
    596  4500		       55		      .byte.b	85	;G
    597  4501		       00		      .byte.b	0	;B
    598  4502		       f0		      .byte.b	240	;R (17)
    599  4503		       16		      .byte.b	22	;G
    600  4504		       00		      .byte.b	0	;B
    601  4505		       f0		      .byte.b	240	;R (16)
    602  4506		       b2		      .byte.b	178	;G
    603  4507		       00		      .byte.b	0	;B
    604  4508		       e0		      .byte.b	224	;R (15)
    605  4509		       0e		      .byte.b	14	;G
    606  450a		       10		      .byte.b	16	;B
    607  450b		       f0		      .byte.b	240	;R (14)
    608  450c		       93		      .byte.b	147	;G
    609  450d		       00		      .byte.b	0	;B
    610  450e		       e0		      .byte.b	224	;R (13)
    611  450f		       25		      .byte.b	37	;G
    612  4510		       00		      .byte.b	0	;B
    613  4511		       c0		      .byte.b	192	;R (12)
    614  4512		       e5		      .byte.b	229	;G
    615  4513		       00		      .byte.b	0	;B
    616  4514		       80		      .byte.b	128	;R (11)
    617  4515		       0e		      .byte.b	14	;G
    618  4516		       00		      .byte.b	0	;B
    619  4517		       c0		      .byte.b	192	;R (10)
    620  4518		       ca		      .byte.b	202	;G
    621  4519		       00		      .byte.b	0	;B
    622  451a		       84		      .byte.b	132	;R (9)
    623  451b		       8e		      .byte.b	142	;G
    624  451c		       00		      .byte.b	0	;B
    625  451d		       00		      .byte.b	0	;R (8)
    626  451e		       8e		      .byte.b	142	;G
    627  451f		       00		      .byte.b	0	;B
    628  4520		       00		      .byte.b	0	;R (7)
    629  4521		       15		      .byte.b	21	;G
    630  4522		       00		      .byte.b	0	;B
    631  4523		       00		      .byte.b	0	;R (6)
    632  4524		       14		      .byte.b	20	;G
    633  4525		       00		      .byte.b	0	;B
    634  4526		       00		      .byte.b	0	;R (5)
    635  4527		       14		      .byte.b	20	;G
    636  4528		       00		      .byte.b	0	;B
    637  4529		       00		      .byte.b	0	;R (4)
    638  452a		       0a		      .byte.b	10	;G
    639  452b		       00		      .byte.b	0	;B
    640  452c		       00		      .byte.b	0	;R (3)
    641  452d		       10		      .byte.b	16	;G
    642  452e		       00		      .byte.b	0	;B
    643  452f		       08		      .byte.b	8	;R (2)
    644  4530		       88		      .byte.b	136	;G
    645  4531		       00		      .byte.b	0	;B
    646  4532		       40		      .byte.b	64	;R (1)
    647  4533		       42		      .byte.b	66	;G
    648  4534		       00		      .byte.b	0	;B
    649  4535		       00		      .byte.b	0	;R (0)
    650  4536		       00		      .byte.b	0	;G
    651  4537		       00		      .byte.b	0	;B
    652  4538				   COL_3
    653  4538		       90		      .byte.b	144	;R (71)
    654  4539		       90		      .byte.b	144	;G
    655  453a		       00		      .byte.b	0	;B
    656  453b		       40		      .byte.b	64	;R (70)
    657  453c		       40		      .byte.b	64	;G
    658  453d		       00		      .byte.b	0	;B
    659  453e		       b0		      .byte.b	176	;R (69)
    660  453f		       b0		      .byte.b	176	;G
    661  4540		       00		      .byte.b	0	;B
    662  4541		       d0		      .byte.b	208	;R (68)
    663  4542		       00		      .byte.b	0	;G
    664  4543		       20		      .byte.b	32	;B
    665  4544		       f0		      .byte.b	240	;R (67)
    666  4545		       00		      .byte.b	0	;G
    667  4546		       00		      .byte.b	0	;B
    668  4547		       f0		      .byte.b	240	;R (66)
    669  4548		       d0		      .byte.b	208	;G
    670  4549		       00		      .byte.b	0	;B
    671  454a		       f0		      .byte.b	240	;R (65)
    672  454b		       00		      .byte.b	0	;G
    673  454c		       00		      .byte.b	0	;B
    674  454d		       f0		      .byte.b	240	;R (64)
    675  454e		       00		      .byte.b	0	;G
    676  454f		       00		      .byte.b	0	;B
    677  4550		       f0		      .byte.b	240	;R (63)
    678  4551		       50		      .byte.b	80	;G
    679  4552		       00		      .byte.b	0	;B
    680  4553		       f0		      .byte.b	240	;R (62)
    681  4554		       00		      .byte.b	0	;G
    682  4555		       00		      .byte.b	0	;B
    683  4556		       f0		      .byte.b	240	;R (61)
    684  4557		       a0		      .byte.b	160	;G
    685  4558		       00		      .byte.b	0	;B
    686  4559		       f0		      .byte.b	240	;R (60)
    687  455a		       00		      .byte.b	0	;G
    688  455b		       00		      .byte.b	0	;B
    689  455c		       f0		      .byte.b	240	;R (59)
    690  455d		       d0		      .byte.b	208	;G
    691  455e		       00		      .byte.b	0	;B
    692  455f		       f0		      .byte.b	240	;R (58)
    693  4560		       c0		      .byte.b	192	;G
    694  4561		       00		      .byte.b	0	;B
    695  4562		       f0		      .byte.b	240	;R (57)
    696  4563		       90		      .byte.b	144	;G
    697  4564		       00		      .byte.b	0	;B
    698  4565		       f0		      .byte.b	240	;R (56)
    699  4566		       80		      .byte.b	128	;G
    700  4567		       00		      .byte.b	0	;B
    701  4568		       f0		      .byte.b	240	;R (55)
    702  4569		       40		      .byte.b	64	;G
    703  456a		       00		      .byte.b	0	;B
    704  456b		       70		      .byte.b	112	;R (54)
    705  456c		       00		      .byte.b	0	;G
    706  456d		       80		      .byte.b	128	;B
    707  456e		       d0		      .byte.b	208	;R (53)
    708  456f		       00		      .byte.b	0	;G
    709  4570		       20		      .byte.b	32	;B
    710  4571		       f0		      .byte.b	240	;R (52)
    711  4572		       80		      .byte.b	128	;G
    712  4573		       00		      .byte.b	0	;B
    713  4574		       f0		      .byte.b	240	;R (51)
    714  4575		       00		      .byte.b	0	;G
    715  4576		       00		      .byte.b	0	;B
    716  4577		       f0		      .byte.b	240	;R (50)
    717  4578		       a0		      .byte.b	160	;G
    718  4579		       00		      .byte.b	0	;B
    719  457a		       f0		      .byte.b	240	;R (49)
    720  457b		       80		      .byte.b	128	;G
    721  457c		       00		      .byte.b	0	;B
    722  457d		       f0		      .byte.b	240	;R (48)
    723  457e		       40		      .byte.b	64	;G
    724  457f		       00		      .byte.b	0	;B
    725  4580		       f0		      .byte.b	240	;R (47)
    726  4581		       20		      .byte.b	32	;G
    727  4582		       00		      .byte.b	0	;B
    728  4583		       f0		      .byte.b	240	;R (46)
    729  4584		       00		      .byte.b	0	;G
    730  4585		       00		      .byte.b	0	;B
    731  4586		       f0		      .byte.b	240	;R (45)
    732  4587		       80		      .byte.b	128	;G
    733  4588		       00		      .byte.b	0	;B
    734  4589		       f0		      .byte.b	240	;R (44)
    735  458a		       00		      .byte.b	0	;G
    736  458b		       00		      .byte.b	0	;B
    737  458c		       f0		      .byte.b	240	;R (43)
    738  458d		       40		      .byte.b	64	;G
    739  458e		       00		      .byte.b	0	;B
    740  458f		       f0		      .byte.b	240	;R (42)
    741  4590		       00		      .byte.b	0	;G
    742  4591		       00		      .byte.b	0	;B
    743  4592		       f0		      .byte.b	240	;R (41)
    744  4593		       20		      .byte.b	32	;G
    745  4594		       00		      .byte.b	0	;B
    746  4595		       f0		      .byte.b	240	;R (40)
    747  4596		       20		      .byte.b	32	;G
    748  4597		       00		      .byte.b	0	;B
    749  4598		       f0		      .byte.b	240	;R (39)
    750  4599		       50		      .byte.b	80	;G
    751  459a		       00		      .byte.b	0	;B
    752  459b		       f0		      .byte.b	240	;R (38)
    753  459c		       10		      .byte.b	16	;G
    754  459d		       00		      .byte.b	0	;B
    755  459e		       70		      .byte.b	112	;R (37)
    756  459f		       80		      .byte.b	128	;G
    757  45a0		       80		      .byte.b	128	;B
    758  45a1		       f0		      .byte.b	240	;R (36)
    759  45a2		       50		      .byte.b	80	;G
    760  45a3		       00		      .byte.b	0	;B
    761  45a4		       f0		      .byte.b	240	;R (35)
    762  45a5		       00		      .byte.b	0	;G
    763  45a6		       00		      .byte.b	0	;B
    764  45a7		       f0		      .byte.b	240	;R (34)
    765  45a8		       40		      .byte.b	64	;G
    766  45a9		       00		      .byte.b	0	;B
    767  45aa		       f0		      .byte.b	240	;R (33)
    768  45ab		       10		      .byte.b	16	;G
    769  45ac		       00		      .byte.b	0	;B
    770  45ad		       f0		      .byte.b	240	;R (32)
    771  45ae		       b0		      .byte.b	176	;G
    772  45af		       00		      .byte.b	0	;B
    773  45b0		       e0		      .byte.b	224	;R (31)
    774  45b1		       00		      .byte.b	0	;G
    775  45b2		       10		      .byte.b	16	;B
    776  45b3		       e0		      .byte.b	224	;R (30)
    777  45b4		       40		      .byte.b	64	;G
    778  45b5		       00		      .byte.b	0	;B
    779  45b6		       e0		      .byte.b	224	;R (29)
    780  45b7		       20		      .byte.b	32	;G
    781  45b8		       00		      .byte.b	0	;B
    782  45b9		       c0		      .byte.b	192	;R (28)
    783  45ba		       00		      .byte.b	0	;G
    784  45bb		       00		      .byte.b	0	;B
    785  45bc		       c0		      .byte.b	192	;R (27)
    786  45bd		       10		      .byte.b	16	;G
    787  45be		       00		      .byte.b	0	;B
    788  45bf		       c0		      .byte.b	192	;R (26)
    789  45c0		       40		      .byte.b	64	;G
    790  45c1		       10		      .byte.b	16	;B
    791  45c2		       90		      .byte.b	144	;R (25)
    792  45c3		       00		      .byte.b	0	;G
    793  45c4		       00		      .byte.b	0	;B
    794  45c5		       f0		      .byte.b	240	;R (24)
    795  45c6		       60		      .byte.b	96	;G
    796  45c7		       00		      .byte.b	0	;B
    797  45c8		       f0		      .byte.b	240	;R (23)
    798  45c9		       00		      .byte.b	0	;G
    799  45ca		       00		      .byte.b	0	;B
    800  45cb		       f0		      .byte.b	240	;R (22)
    801  45cc		       40		      .byte.b	64	;G
    802  45cd		       00		      .byte.b	0	;B
    803  45ce		       f0		      .byte.b	240	;R (21)
    804  45cf		       10		      .byte.b	16	;G
    805  45d0		       00		      .byte.b	0	;B
    806  45d1		       f0		      .byte.b	240	;R (20)
    807  45d2		       00		      .byte.b	0	;G
    808  45d3		       00		      .byte.b	0	;B
    809  45d4		       f0		      .byte.b	240	;R (19)
    810  45d5		       60		      .byte.b	96	;G
    811  45d6		       00		      .byte.b	0	;B
    812  45d7		       f0		      .byte.b	240	;R (18)
    813  45d8		       20		      .byte.b	32	;G
    814  45d9		       00		      .byte.b	0	;B
    815  45da		       f0		      .byte.b	240	;R (17)
    816  45db		       50		      .byte.b	80	;G
    817  45dc		       00		      .byte.b	0	;B
    818  45dd		       f0		      .byte.b	240	;R (16)
    819  45de		       40		      .byte.b	64	;G
    820  45df		       00		      .byte.b	0	;B
    821  45e0		       f0		      .byte.b	240	;R (15)
    822  45e1		       80		      .byte.b	128	;G
    823  45e2		       00		      .byte.b	0	;B
    824  45e3		       f0		      .byte.b	240	;R (14)
    825  45e4		       40		      .byte.b	64	;G
    826  45e5		       00		      .byte.b	0	;B
    827  45e6		       f0		      .byte.b	240	;R (13)
    828  45e7		       00		      .byte.b	0	;G
    829  45e8		       00		      .byte.b	0	;B
    830  45e9		       f0		      .byte.b	240	;R (12)
    831  45ea		       10		      .byte.b	16	;G
    832  45eb		       00		      .byte.b	0	;B
    833  45ec		       f0		      .byte.b	240	;R (11)
    834  45ed		       50		      .byte.b	80	;G
    835  45ee		       00		      .byte.b	0	;B
    836  45ef		       f0		      .byte.b	240	;R (10)
    837  45f0		       00		      .byte.b	0	;G
    838  45f1		       00		      .byte.b	0	;B
    839  45f2		       f0		      .byte.b	240	;R (9)
    840  45f3		       b0		      .byte.b	176	;G
    841  45f4		       00		      .byte.b	0	;B
    842  45f5		       f0		      .byte.b	240	;R (8)
    843  45f6		       90		      .byte.b	144	;G
    844  45f7		       00		      .byte.b	0	;B
    845  45f8		       e0		      .byte.b	224	;R (7)
    846  45f9		       e0		      .byte.b	224	;G
    847  45fa		       00		      .byte.b	0	;B
    848  45fb		       f0		      .byte.b	240	;R (6)
    849  45fc		       d0		      .byte.b	208	;G
    850  45fd		       00		      .byte.b	0	;B
    851  45fe		       60		      .byte.b	96	;R (5)
    852  45ff		       00		      .byte.b	0	;G
    853  4600		       00		      .byte.b	0	;B
    854  4601		       60		      .byte.b	96	;R (4)
    855  4602		       40		      .byte.b	64	;G
    856  4603		       00		      .byte.b	0	;B
    857  4604		       40		      .byte.b	64	;R (3)
    858  4605		       50		      .byte.b	80	;G
    859  4606		       00		      .byte.b	0	;B
    860  4607		       00		      .byte.b	0	;R (2)
    861  4608		       00		      .byte.b	0	;G
    862  4609		       00		      .byte.b	0	;B
    863  460a		       00		      .byte.b	0	;R (1)
    864  460b		       80		      .byte.b	128	;G
    865  460c		       00		      .byte.b	0	;B
    866  460d		       00		      .byte.b	0	;R (0)
    867  460e		       00		      .byte.b	0	;G
    868  460f		       00		      .byte.b	0	;B
    869  4610				   COL_4
    870  4610		       25		      .byte.b	37	;R (71)
    871  4611		       25		      .byte.b	37	;G
    872  4612		       00		      .byte.b	0	;B
    873  4613		       48		      .byte.b	72	;R (70)
    874  4614		       48		      .byte.b	72	;G
    875  4615		       00		      .byte.b	0	;B
    876  4616		       25		      .byte.b	37	;R (69)
    877  4617		       25		      .byte.b	37	;G
    878  4618		       88		      .byte.b	136	;B
    879  4619		       ff		      .byte.b	255	;R (68)
    880  461a		       00		      .byte.b	0	;G
    881  461b		       00		      .byte.b	0	;B
    882  461c		       ff		      .byte.b	255	;R (67)
    883  461d		       04		      .byte.b	4	;G
    884  461e		       00		      .byte.b	0	;B
    885  461f		       ef		      .byte.b	239	;R (66)
    886  4620		       40		      .byte.b	64	;G
    887  4621		       10		      .byte.b	16	;B
    888  4622		       ff		      .byte.b	255	;R (65)
    889  4623		       00		      .byte.b	0	;G
    890  4624		       00		      .byte.b	0	;B
    891  4625		       ff		      .byte.b	255	;R (64)
    892  4626		       02		      .byte.b	2	;G
    893  4627		       00		      .byte.b	0	;B
    894  4628		       ff		      .byte.b	255	;R (63)
    895  4629		       20		      .byte.b	32	;G
    896  462a		       00		      .byte.b	0	;B
    897  462b		       ff		      .byte.b	255	;R (62)
    898  462c		       a5		      .byte.b	165	;G
    899  462d		       00		      .byte.b	0	;B
    900  462e		       ff		      .byte.b	255	;R (61)
    901  462f		       09		      .byte.b	9	;G
    902  4630		       00		      .byte.b	0	;B
    903  4631		       ff		      .byte.b	255	;R (60)
    904  4632		       00		      .byte.b	0	;G
    905  4633		       00		      .byte.b	0	;B
    906  4634		       7f		      .byte.b	127	;R (59)
    907  4635		       42		      .byte.b	66	;G
    908  4636		       80		      .byte.b	128	;B
    909  4637		       ff		      .byte.b	255	;R (58)
    910  4638		       88		      .byte.b	136	;G
    911  4639		       00		      .byte.b	0	;B
    912  463a		       ff		      .byte.b	255	;R (57)
    913  463b		       40		      .byte.b	64	;G
    914  463c		       00		      .byte.b	0	;B
    915  463d		       ff		      .byte.b	255	;R (56)
    916  463e		       09		      .byte.b	9	;G
    917  463f		       00		      .byte.b	0	;B
    918  4640		       7f		      .byte.b	127	;R (55)
    919  4641		       01		      .byte.b	1	;G
    920  4642		       80		      .byte.b	128	;B
    921  4643		       ff		      .byte.b	255	;R (54)
    922  4644		       91		      .byte.b	145	;G
    923  4645		       00		      .byte.b	0	;B
    924  4646		       fe		      .byte.b	254	;R (53)
    925  4647		       81		      .byte.b	129	;G
    926  4648		       00		      .byte.b	0	;B
    927  4649		       fe		      .byte.b	254	;R (52)
    928  464a		       20		      .byte.b	32	;G
    929  464b		       00		      .byte.b	0	;B
    930  464c		       ff		      .byte.b	255	;R (51)
    931  464d		       03		      .byte.b	3	;G
    932  464e		       00		      .byte.b	0	;B
    933  464f		       ff		      .byte.b	255	;R (50)
    934  4650		       83		      .byte.b	131	;G
    935  4651		       00		      .byte.b	0	;B
    936  4652		       fe		      .byte.b	254	;R (49)
    937  4653		       90		      .byte.b	144	;G
    938  4654		       00		      .byte.b	0	;B
    939  4655		       fe		      .byte.b	254	;R (48)
    940  4656		       83		      .byte.b	131	;G
    941  4657		       00		      .byte.b	0	;B
    942  4658		       7e		      .byte.b	126	;R (47)
    943  4659		       12		      .byte.b	18	;G
    944  465a		       80		      .byte.b	128	;B
    945  465b		       fc		      .byte.b	252	;R (46)
    946  465c		       00		      .byte.b	0	;G
    947  465d		       00		      .byte.b	0	;B
    948  465e		       fe		      .byte.b	254	;R (45)
    949  465f		       07		      .byte.b	7	;G
    950  4660		       00		      .byte.b	0	;B
    951  4661		       ef		      .byte.b	239	;R (44)
    952  4662		       03		      .byte.b	3	;G
    953  4663		       10		      .byte.b	16	;B
    954  4664		       ff		      .byte.b	255	;R (43)
    955  4665		       40		      .byte.b	64	;G
    956  4666		       00		      .byte.b	0	;B
    957  4667		       ff		      .byte.b	255	;R (42)
    958  4668		       01		      .byte.b	1	;G
    959  4669		       00		      .byte.b	0	;B
    960  466a		       ff		      .byte.b	255	;R (41)
    961  466b		       01		      .byte.b	1	;G
    962  466c		       00		      .byte.b	0	;B
    963  466d		       bf		      .byte.b	191	;R (40)
    964  466e		       01		      .byte.b	1	;G
    965  466f		       40		      .byte.b	64	;B
    966  4670		       f7		      .byte.b	247	;R (39)
    967  4671		       80		      .byte.b	128	;G
    968  4672		       08		      .byte.b	8	;B
    969  4673		       ff		      .byte.b	255	;R (38)
    970  4674		       40		      .byte.b	64	;G
    971  4675		       00		      .byte.b	0	;B
    972  4676		       ff		      .byte.b	255	;R (37)
    973  4677		       00		      .byte.b	0	;G
    974  4678		       00		      .byte.b	0	;B
    975  4679		       ff		      .byte.b	255	;R (36)
    976  467a		       40		      .byte.b	64	;G
    977  467b		       00		      .byte.b	0	;B
    978  467c		       ff		      .byte.b	255	;R (35)
    979  467d		       a1		      .byte.b	161	;G
    980  467e		       00		      .byte.b	0	;B
    981  467f		       7f		      .byte.b	127	;R (34)
    982  4680		       05		      .byte.b	5	;G
    983  4681		       80		      .byte.b	128	;B
    984  4682		       ff		      .byte.b	255	;R (33)
    985  4683		       21		      .byte.b	33	;G
    986  4684		       00		      .byte.b	0	;B
    987  4685		       bf		      .byte.b	191	;R (32)
    988  4686		       40		      .byte.b	64	;G
    989  4687		       40		      .byte.b	64	;B
    990  4688		       ff		      .byte.b	255	;R (31)
    991  4689		       61		      .byte.b	97	;G
    992  468a		       00		      .byte.b	0	;B
    993  468b		       7f		      .byte.b	127	;R (30)
    994  468c		       81		      .byte.b	129	;G
    995  468d		       80		      .byte.b	128	;B
    996  468e		       f7		      .byte.b	247	;R (29)
    997  468f		       60		      .byte.b	96	;G
    998  4690		       08		      .byte.b	8	;B
    999  4691		       ff		      .byte.b	255	;R (28)
   1000  4692		       81		      .byte.b	129	;G
   1001  4693		       00		      .byte.b	0	;B
   1002  4694		       ef		      .byte.b	239	;R (27)
   1003  4695		       40		      .byte.b	64	;G
   1004  4696		       10		      .byte.b	16	;B
   1005  4697		       ff		      .byte.b	255	;R (26)
   1006  4698		       60		      .byte.b	96	;G
   1007  4699		       00		      .byte.b	0	;B
   1008  469a		       ff		      .byte.b	255	;R (25)
   1009  469b		       18		      .byte.b	24	;G
   1010  469c		       00		      .byte.b	0	;B
   1011  469d		       ff		      .byte.b	255	;R (24)
   1012  469e		       20		      .byte.b	32	;G
   1013  469f		       00		      .byte.b	0	;B
   1014  46a0		       ff		      .byte.b	255	;R (23)
   1015  46a1		       8a		      .byte.b	138	;G
   1016  46a2		       00		      .byte.b	0	;B
   1017  46a3		       f7		      .byte.b	247	;R (22)
   1018  46a4		       10		      .byte.b	16	;G
   1019  46a5		       08		      .byte.b	8	;B
   1020  46a6		       ff		      .byte.b	255	;R (21)
   1021  46a7		       04		      .byte.b	4	;G
   1022  46a8		       00		      .byte.b	0	;B
   1023  46a9		       df		      .byte.b	223	;R (20)
   1024  46aa		       10		      .byte.b	16	;G
   1025  46ab		       20		      .byte.b	32	;B
   1026  46ac		       ff		      .byte.b	255	;R (19)
   1027  46ad		       90		      .byte.b	144	;G
   1028  46ae		       00		      .byte.b	0	;B
   1029  46af		       ff		      .byte.b	255	;R (18)
   1030  46b0		       12		      .byte.b	18	;G
   1031  46b1		       00		      .byte.b	0	;B
   1032  46b2		       ff		      .byte.b	255	;R (17)
   1033  46b3		       00		      .byte.b	0	;G
   1034  46b4		       00		      .byte.b	0	;B
   1035  46b5		       ff		      .byte.b	255	;R (16)
   1036  46b6		       45		      .byte.b	69	;G
   1037  46b7		       00		      .byte.b	0	;B
   1038  46b8		       ff		      .byte.b	255	;R (15)
   1039  46b9		       10		      .byte.b	16	;G
   1040  46ba		       00		      .byte.b	0	;B
   1041  46bb		       ff		      .byte.b	255	;R (14)
   1042  46bc		       23		      .byte.b	35	;G
   1043  46bd		       00		      .byte.b	0	;B
   1044  46be		       fc		      .byte.b	252	;R (13)
   1045  46bf		       12		      .byte.b	18	;G
   1046  46c0		       00		      .byte.b	0	;B
   1047  46c1		       fc		      .byte.b	252	;R (12)
   1048  46c2		       20		      .byte.b	32	;G
   1049  46c3		       00		      .byte.b	0	;B
   1050  46c4		       fe		      .byte.b	254	;R (11)
   1051  46c5		       46		      .byte.b	70	;G
   1052  46c6		       00		      .byte.b	0	;B
   1053  46c7		       f8		      .byte.b	248	;R (10)
   1054  46c8		       48		      .byte.b	72	;G
   1055  46c9		       00		      .byte.b	0	;B
   1056  46ca		       f0		      .byte.b	240	;R (9)
   1057  46cb		       04		      .byte.b	4	;G
   1058  46cc		       00		      .byte.b	0	;B
   1059  46cd		       e0		      .byte.b	224	;R (8)
   1060  46ce		       20		      .byte.b	32	;G
   1061  46cf		       00		      .byte.b	0	;B
   1062  46d0		       e0		      .byte.b	224	;R (7)
   1063  46d1		       29		      .byte.b	41	;G
   1064  46d2		       00		      .byte.b	0	;B
   1065  46d3		       e0		      .byte.b	224	;R (6)
   1066  46d4		       20		      .byte.b	32	;G
   1067  46d5		       00		      .byte.b	0	;B
   1068  46d6		       e0		      .byte.b	224	;R (5)
   1069  46d7		       84		      .byte.b	132	;G
   1070  46d8		       00		      .byte.b	0	;B
   1071  46d9		       60		      .byte.b	96	;R (4)
   1072  46da		       40		      .byte.b	64	;G
   1073  46db		       00		      .byte.b	0	;B
   1074  46dc		       00		      .byte.b	0	;R (3)
   1075  46dd		       88		      .byte.b	136	;G
   1076  46de		       00		      .byte.b	0	;B
   1077  46df		       00		      .byte.b	0	;R (2)
   1078  46e0		       11		      .byte.b	17	;G
   1079  46e1		       00		      .byte.b	0	;B
   1080  46e2		       24		      .byte.b	36	;R (1)
   1081  46e3		       24		      .byte.b	36	;G
   1082  46e4		       00		      .byte.b	0	;B
   1083  46e5		       00		      .byte.b	0	;R (0)
   1084  46e6		       00		      .byte.b	0	;G
   1085  46e7		       00		      .byte.b	0	;B
   1086  46e8				   COL_5
   1087  46e8		       02		      .byte.b	2	;R (71)
   1088  46e9		       12		      .byte.b	18	;G
   1089  46ea		       00		      .byte.b	0	;B
   1090  46eb		       00		      .byte.b	0	;R (70)
   1091  46ec		       00		      .byte.b	0	;G
   1092  46ed		       00		      .byte.b	0	;B
   1093  46ee		       00		      .byte.b	0	;R (69)
   1094  46ef		       02		      .byte.b	2	;G
   1095  46f0		       00		      .byte.b	0	;B
   1096  46f1		       03		      .byte.b	3	;R (68)
   1097  46f2		       12		      .byte.b	18	;G
   1098  46f3		       00		      .byte.b	0	;B
   1099  46f4		       0b		      .byte.b	11	;R (67)
   1100  46f5		       09		      .byte.b	9	;G
   1101  46f6		       00		      .byte.b	0	;B
   1102  46f7		       07		      .byte.b	7	;R (66)
   1103  46f8		       05		      .byte.b	5	;G
   1104  46f9		       00		      .byte.b	0	;B
   1105  46fa		       03		      .byte.b	3	;R (65)
   1106  46fb		       06		      .byte.b	6	;G
   1107  46fc		       00		      .byte.b	0	;B
   1108  46fd		       01		      .byte.b	1	;R (64)
   1109  46fe		       20		      .byte.b	32	;G
   1110  46ff		       00		      .byte.b	0	;B
   1111  4700		       03		      .byte.b	3	;R (63)
   1112  4701		       03		      .byte.b	3	;G
   1113  4702		       00		      .byte.b	0	;B
   1114  4703		       03		      .byte.b	3	;R (62)
   1115  4704		       0a		      .byte.b	10	;G
   1116  4705		       00		      .byte.b	0	;B
   1117  4706		       03		      .byte.b	3	;R (61)
   1118  4707		       02		      .byte.b	2	;G
   1119  4708		       00		      .byte.b	0	;B
   1120  4709		       03		      .byte.b	3	;R (60)
   1121  470a		       00		      .byte.b	0	;G
   1122  470b		       00		      .byte.b	0	;B
   1123  470c		       03		      .byte.b	3	;R (59)
   1124  470d		       0a		      .byte.b	10	;G
   1125  470e		       00		      .byte.b	0	;B
   1126  470f		       03		      .byte.b	3	;R (58)
   1127  4710		       02		      .byte.b	2	;G
   1128  4711		       00		      .byte.b	0	;B
   1129  4712		       01		      .byte.b	1	;R (57)
   1130  4713		       03		      .byte.b	3	;G
   1131  4714		       00		      .byte.b	0	;B
   1132  4715		       01		      .byte.b	1	;R (56)
   1133  4716		       01		      .byte.b	1	;G
   1134  4717		       00		      .byte.b	0	;B
   1135  4718		       00		      .byte.b	0	;R (55)
   1136  4719		       25		      .byte.b	37	;G
   1137  471a		       00		      .byte.b	0	;B
   1138  471b		       00		      .byte.b	0	;R (54)
   1139  471c		       00		      .byte.b	0	;G
   1140  471d		       00		      .byte.b	0	;B
   1141  471e		       00		      .byte.b	0	;R (53)
   1142  471f		       20		      .byte.b	32	;G
   1143  4720		       00		      .byte.b	0	;B
   1144  4721		       00		      .byte.b	0	;R (52)
   1145  4722		       08		      .byte.b	8	;G
   1146  4723		       00		      .byte.b	0	;B
   1147  4724		       00		      .byte.b	0	;R (51)
   1148  4725		       02		      .byte.b	2	;G
   1149  4726		       00		      .byte.b	0	;B
   1150  4727		       00		      .byte.b	0	;R (50)
   1151  4728		       40		      .byte.b	64	;G
   1152  4729		       00		      .byte.b	0	;B
   1153  472a		       00		      .byte.b	0	;R (49)
   1154  472b		       11		      .byte.b	17	;G
   1155  472c		       00		      .byte.b	0	;B
   1156  472d		       00		      .byte.b	0	;R (48)
   1157  472e		       00		      .byte.b	0	;G
   1158  472f		       00		      .byte.b	0	;B
   1159  4730		       00		      .byte.b	0	;R (47)
   1160  4731		       20		      .byte.b	32	;G
   1161  4732		       00		      .byte.b	0	;B
   1162  4733		       00		      .byte.b	0	;R (46)
   1163  4734		       08		      .byte.b	8	;G
   1164  4735		       00		      .byte.b	0	;B
   1165  4736		       00		      .byte.b	0	;R (45)
   1166  4737		       00		      .byte.b	0	;G
   1167  4738		       00		      .byte.b	0	;B
   1168  4739		       00		      .byte.b	0	;R (44)
   1169  473a		       24		      .byte.b	36	;G
   1170  473b		       00		      .byte.b	0	;B
   1171  473c		       00		      .byte.b	0	;R (43)
   1172  473d		       00		      .byte.b	0	;G
   1173  473e		       00		      .byte.b	0	;B
   1174  473f		       00		      .byte.b	0	;R (42)
   1175  4740		       04		      .byte.b	4	;G
   1176  4741		       00		      .byte.b	0	;B
   1177  4742		       00		      .byte.b	0	;R (41)
   1178  4743		       21		      .byte.b	33	;G
   1179  4744		       00		      .byte.b	0	;B
   1180  4745		       01		      .byte.b	1	;R (40)
   1181  4746		       01		      .byte.b	1	;G
   1182  4747		       00		      .byte.b	0	;B
   1183  4748		       01		      .byte.b	1	;R (39)
   1184  4749		       25		      .byte.b	37	;G
   1185  474a		       00		      .byte.b	0	;B
   1186  474b		       01		      .byte.b	1	;R (38)
   1187  474c		       01		      .byte.b	1	;G
   1188  474d		       00		      .byte.b	0	;B
   1189  474e		       03		      .byte.b	3	;R (37)
   1190  474f		       23		      .byte.b	35	;G
   1191  4750		       00		      .byte.b	0	;B
   1192  4751		       03		      .byte.b	3	;R (36)
   1193  4752		       13		      .byte.b	19	;G
   1194  4753		       00		      .byte.b	0	;B
   1195  4754		       01		      .byte.b	1	;R (35)
   1196  4755		       02		      .byte.b	2	;G
   1197  4756		       00		      .byte.b	0	;B
   1198  4757		       01		      .byte.b	1	;R (34)
   1199  4758		       10		      .byte.b	16	;G
   1200  4759		       00		      .byte.b	0	;B
   1201  475a		       03		      .byte.b	3	;R (33)
   1202  475b		       02		      .byte.b	2	;G
   1203  475c		       00		      .byte.b	0	;B
   1204  475d		       01		      .byte.b	1	;R (32)
   1205  475e		       08		      .byte.b	8	;G
   1206  475f		       00		      .byte.b	0	;B
   1207  4760		       03		      .byte.b	3	;R (31)
   1208  4761		       20		      .byte.b	32	;G
   1209  4762		       00		      .byte.b	0	;B
   1210  4763		       03		      .byte.b	3	;R (30)
   1211  4764		       00		      .byte.b	0	;G
   1212  4765		       00		      .byte.b	0	;B
   1213  4766		       03		      .byte.b	3	;R (29)
   1214  4767		       10		      .byte.b	16	;G
   1215  4768		       00		      .byte.b	0	;B
   1216  4769		       03		      .byte.b	3	;R (28)
   1217  476a		       00		      .byte.b	0	;G
   1218  476b		       00		      .byte.b	0	;B
   1219  476c		       07		      .byte.b	7	;R (27)
   1220  476d		       0e		      .byte.b	14	;G
   1221  476e		       00		      .byte.b	0	;B
   1222  476f		       03		      .byte.b	3	;R (26)
   1223  4770		       41		      .byte.b	65	;G
   1224  4771		       00		      .byte.b	0	;B
   1225  4772		       07		      .byte.b	7	;R (25)
   1226  4773		       04		      .byte.b	4	;G
   1227  4774		       00		      .byte.b	0	;B
   1228  4775		       03		      .byte.b	3	;R (24)
   1229  4776		       21		      .byte.b	33	;G
   1230  4777		       00		      .byte.b	0	;B
   1231  4778		       03		      .byte.b	3	;R (23)
   1232  4779		       04		      .byte.b	4	;G
   1233  477a		       00		      .byte.b	0	;B
   1234  477b		       03		      .byte.b	3	;R (22)
   1235  477c		       02		      .byte.b	2	;G
   1236  477d		       00		      .byte.b	0	;B
   1237  477e		       03		      .byte.b	3	;R (21)
   1238  477f		       26		      .byte.b	38	;G
   1239  4780		       00		      .byte.b	0	;B
   1240  4781		       01		      .byte.b	1	;R (20)
   1241  4782		       01		      .byte.b	1	;G
   1242  4783		       00		      .byte.b	0	;B
   1243  4784		       00		      .byte.b	0	;R (19)
   1244  4785		       21		      .byte.b	33	;G
   1245  4786		       00		      .byte.b	0	;B
   1246  4787		       01		      .byte.b	1	;R (18)
   1247  4788		       09		      .byte.b	9	;G
   1248  4789		       00		      .byte.b	0	;B
   1249  478a		       23		      .byte.b	35	;R (17)
   1250  478b		       22		      .byte.b	34	;G
   1251  478c		       00		      .byte.b	0	;B
   1252  478d		       01		      .byte.b	1	;R (16)
   1253  478e		       01		      .byte.b	1	;G
   1254  478f		       00		      .byte.b	0	;B
   1255  4790		       00		      .byte.b	0	;R (15)
   1256  4791		       29		      .byte.b	41	;G
   1257  4792		       00		      .byte.b	0	;B
   1258  4793		       00		      .byte.b	0	;R (14)
   1259  4794		       00		      .byte.b	0	;G
   1260  4795		       00		      .byte.b	0	;B
   1261  4796		       00		      .byte.b	0	;R (13)
   1262  4797		       04		      .byte.b	4	;G
   1263  4798		       00		      .byte.b	0	;B
   1264  4799		       00		      .byte.b	0	;R (12)
   1265  479a		       20		      .byte.b	32	;G
   1266  479b		       00		      .byte.b	0	;B
   1267  479c		       10		      .byte.b	16	;R (11)
   1268  479d		       12		      .byte.b	18	;G
   1269  479e		       00		      .byte.b	0	;B
   1270  479f		       00		      .byte.b	0	;R (10)
   1271  47a0		       00		      .byte.b	0	;G
   1272  47a1		       00		      .byte.b	0	;B
   1273  47a2		       00		      .byte.b	0	;R (9)
   1274  47a3		       21		      .byte.b	33	;G
   1275  47a4		       00		      .byte.b	0	;B
   1276  47a5		       00		      .byte.b	0	;R (8)
   1277  47a6		       08		      .byte.b	8	;G
   1278  47a7		       00		      .byte.b	0	;B
   1279  47a8		       00		      .byte.b	0	;R (7)
   1280  47a9		       20		      .byte.b	32	;G
   1281  47aa		       00		      .byte.b	0	;B
   1282  47ab		       00		      .byte.b	0	;R (6)
   1283  47ac		       04		      .byte.b	4	;G
   1284  47ad		       00		      .byte.b	0	;B
   1285  47ae		       20		      .byte.b	32	;R (5)
   1286  47af		       20		      .byte.b	32	;G
   1287  47b0		       00		      .byte.b	0	;B
   1288  47b1		       00		      .byte.b	0	;R (4)
   1289  47b2		       09		      .byte.b	9	;G
   1290  47b3		       00		      .byte.b	0	;B
   1291  47b4		       00		      .byte.b	0	;R (3)
   1292  47b5		       00		      .byte.b	0	;G
   1293  47b6		       00		      .byte.b	0	;B
   1294  47b7		       00		      .byte.b	0	;R (2)
   1295  47b8		       48		      .byte.b	72	;G
   1296  47b9		       00		      .byte.b	0	;B
   1297  47ba		       02		      .byte.b	2	;R (1)
   1298  47bb		       02		      .byte.b	2	;G
   1299  47bc		       00		      .byte.b	0	;B
   1300  47bd		       00		      .byte.b	0	;R (0)
   1301  47be		       00		      .byte.b	0	;G
   1302  47bf		       00		      .byte.b	0	;B
------- FILE titleScreen.asm
    265  47c0							;    include "pizza.asm"
    266  47c0
      0  47c0					      CHECK_BANK_SIZE	"TITLESCREEN"
      1  47c0		       07 c0	   .TEMP      =	* - BANK_START
 TITLESCREEN (2K) SIZE =  $7c0 , FREE= $40
      2  47c0					      ECHO	"TITLESCREEN", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  47c0				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  47c0				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  47c0				  -	      ERR
      6  47c0					      endif
------- FILE ./chess.asm
------- FILE BANK_RECON.asm LEVEL 2 PASS 5
      0  47c0					      include	"BANK_RECON.asm"
      0  47c0					      NEWBANK	RECON
      1  4f48 ????				      SEG	RECON
      2  4800					      ORG	ORIGIN
      3  4800					      RORG	$F000
      4  4800				   BANK_START SET	*
      5  4800				   RECON      SET	ORIGIN / 2048
      6  4800				   ORIGIN     SET	ORIGIN + 2048
      7  4800				   _CURRENT_BANK SET	RECON
      2  4800
      3  4800							;---------------------------------------------------------------------------------------------------
      4  4800
      0  4800					      DEF	UNSAFE_showMoveCaptures
      1  4800				   BANK_UNSAFE_showMoveCaptures SET	_CURRENT_BANK
      2  4800				   UNSAFE_showMoveCaptures
      3  4800				   TEMPORARY_VAR SET	Overlay
      4  4800				   TEMPORARY_OFFSET SET	0
      5  4800				   VAR_BOUNDARY_UNSAFE_showMoveCaptures SET	TEMPORARY_OFFSET
      6  4800				   FUNCTION_NAME SET	UNSAFE_showMoveCaptures
      7  4800					      SUBROUTINE
      6  4800					      SUBROUTINE
      7  4800
      0  4800					      REFER	SAFE_showMoveCaptures
      1  4800				  -	      IF	VAREND_SAFE_showMoveCaptures > TEMPORARY_VAR
      2  4800				  -TEMPORARY_VAR SET	VAREND_SAFE_showMoveCaptures
      3  4800					      ENDIF
      0  4800					      VAR	__toSquareX12, 1
      1  4800		       00 a2	   __toSquareX12 =	TEMPORARY_VAR
      2  4800				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4800
      4  4800				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4800				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4800				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4800					      ENDIF
      8  4800				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4800				  -	      ECHO	"Temporary Variable", __toSquareX12, "overflow!"
     10  4800				  -	      ERR
     11  4800					      ENDIF
     12  4800					      LIST	ON
      0  4800					      VAR	__fromPiece, 1
      1  4800		       00 a3	   __fromPiece =	TEMPORARY_VAR
      2  4800				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4800
      4  4800				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4800				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4800				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4800					      ENDIF
      8  4800				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4800				  -	      ECHO	"Temporary Variable", __fromPiece, "overflow!"
     10  4800				  -	      ERR
     11  4800					      ENDIF
     12  4800					      LIST	ON
      0  4800					      VAR	__aiMoveIndex, 1
      1  4800		       00 a4	   __aiMoveIndex =	TEMPORARY_VAR
      2  4800				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4800
      4  4800				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4800				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4800				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4800					      ENDIF
      8  4800				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4800				  -	      ECHO	"Temporary Variable", __aiMoveIndex, "overflow!"
     10  4800				  -	      ERR
     11  4800					      ENDIF
     12  4800					      LIST	ON
      0  4800					      VEND	UNSAFE_showMoveCaptures
      1  4800				  -	      IFNCONST	UNSAFE_showMoveCaptures
      2  4800				  -	      ECHO	"Incorrect VEND label", UNSAFE_showMoveCaptures
      3  4800				  -	      ERR
      4  4800					      ENDIF
      5  4800		       00 a5	   VAREND_UNSAFE_showMoveCaptures =	TEMPORARY_VAR
     13  4800
     14  4800							; place a marker on the board for any square matching the piece
     15  4800							; EXCEPT for squares which are occupied (we'll flash those later)
     16  4800							; x = movelist item # being checked
     17  4800
     18  4800		       a5 8b		      lda	savedBank
     19  4802		       48		      pha
     20  4803
     21  4803		       a9 09		      lda	#BANK_UNSAFE_showMoveCaptures
     22  4805		       85 8b		      sta	savedBank
     23  4807
     24  4807
     25  4807		       a6 8e	   .next      ldx	aiMoveIndex
     26  4809		       86 a4		      stx	__aiMoveIndex
     27  480b		       30 41		      bmi	.skip	; no moves in list
     28  480d
     29  480d		       ad 84 02 	      lda	INTIM
     30  4810		       c9 14		      cmp	#20
     31  4812		       90 3a		      bcc	.skip
     32  4814
     33  4814		       c6 8e		      dec	aiMoveIndex
     34  4816
     35  4816		       20 1c fd 	      jsr	GetMoveFrom
     36  4819		       c5 85		      cmp	fromX12
     37  481b		       d0 ea		      bne	.next
     38  481d
     39  481d
     40  481d		       20 28 fd 	      jsr	GetMoveTo
     41  4820		       85 a2		      sta	__toSquareX12
     42  4822		       a8		      tay
     43  4823		       20 34 fc 	      jsr	GetBoard
     44  4826		       29 0f		      and	#PIECE_MASK
     45  4828		       f0 dd		      beq	.next
     46  482a
     47  482a							; There's something on the board at destination, so it's a capture
     48  482a							; Let's see if we are doing a pawn promote...
     49  482a
     50  482a		       a4 85		      ldy	fromX12
     51  482c		       20 34 fc 	      jsr	GetBoard
     52  482f		       85 a3		      sta	__fromPiece
     53  4831
     54  4831		       20 34 fd 	      jsr	GetMovePiece
     55  4834		       45 a3		      eor	__fromPiece
     56  4836		       29 0f		      and	#PIECE_MASK
     57  4838		       f0 06		      beq	.legit	; from == to, so not a promote
     58  483a
     59  483a							; Have detected a promotion duplicate - skip all 3 of them
     60  483a
     61  483a		       c6 8e		      dec	aiMoveIndex	; skip "KBRQ" promotes
     62  483c		       c6 8e		      dec	aiMoveIndex
     63  483e		       c6 8e		      dec	aiMoveIndex
     64  4840
     65  4840				   .legit
     66  4840
      0  4840					      TIMECHECK	COPYSINGLEPIECE, restoreIndex	; not enough time to draw
      1  4840		       ad 84 02 	      lda	INTIM
      2  4843		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
      3  4845		       90 0b		      bcc	restoreIndex
     68  4847
     69  4847		       a5 a2		      lda	__toSquareX12
     70  4849		       85 80		      sta	squareToDraw
     71  484b
     72  484b		       20 a4 fc 	      jsr	CopySinglePiece
     73  484e
     74  484e		       68	   .skip      pla
     75  484f		       85 8b		      sta	savedBank
     76  4851		       60		      rts
     77  4852
     78  4852		       a5 a4	   restoreIndex lda	__aiMoveIndex
     79  4854		       85 8e		      sta	aiMoveIndex
     80  4856		       4c 4e f0 	      jmp	.skip
     81  4859
     82  4859
     83  4859							;---------------------------------------------------------------------------------------------------
     84  4859
      0  4859					      DEF	aiMarchToTargetA
      1  4859				   BANK_aiMarchToTargetA SET	_CURRENT_BANK
      2  4859				   aiMarchToTargetA
      3  4859				   TEMPORARY_VAR SET	Overlay
      4  4859				   TEMPORARY_OFFSET SET	0
      5  4859				   VAR_BOUNDARY_aiMarchToTargetA SET	TEMPORARY_OFFSET
      6  4859				   FUNCTION_NAME SET	aiMarchToTargetA
      7  4859					      SUBROUTINE
     86  4859					      SUBROUTINE
     87  4859
      0  4859					      REFER	AiStateMachine
      1  4859				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  4859				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  4859					      ENDIF
      0  4859					      VAR	__fromRow, 1
      1  4859		       00 a2	   __fromRow  =	TEMPORARY_VAR
      2  4859				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4859
      4  4859				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4859				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4859				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4859					      ENDIF
      8  4859				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4859				  -	      ECHO	"Temporary Variable", __fromRow, "overflow!"
     10  4859				  -	      ERR
     11  4859					      ENDIF
     12  4859					      LIST	ON
      0  4859					      VAR	__boardIndex, 1
      1  4859		       00 a3	   __boardIndex =	TEMPORARY_VAR
      2  4859				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4859
      4  4859				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4859				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4859				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4859					      ENDIF
      8  4859				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4859				  -	      ECHO	"Temporary Variable", __boardIndex, "overflow!"
     10  4859				  -	      ERR
     11  4859					      ENDIF
     12  4859					      LIST	ON
      0  4859					      VAR	__fromCol, 1
      1  4859		       00 a4	   __fromCol  =	TEMPORARY_VAR
      2  4859				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4859
      4  4859				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4859				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4859				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4859					      ENDIF
      8  4859				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4859				  -	      ECHO	"Temporary Variable", __fromCol, "overflow!"
     10  4859				  -	      ERR
     11  4859					      ENDIF
     12  4859					      LIST	ON
      0  4859					      VAR	__toCol, 1
      1  4859		       00 a5	   __toCol    =	TEMPORARY_VAR
      2  4859				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4859
      4  4859				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4859				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4859				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4859					      ENDIF
      8  4859				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4859				  -	      ECHO	"Temporary Variable", __toCol, "overflow!"
     10  4859				  -	      ERR
     11  4859					      ENDIF
     12  4859					      LIST	ON
      0  4859					      VEND	aiMarchToTargetA
      1  4859				  -	      IFNCONST	aiMarchToTargetA
      2  4859				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetA
      3  4859				  -	      ERR
      4  4859					      ENDIF
      5  4859		       00 a6	   VAREND_aiMarchToTargetA =	TEMPORARY_VAR
     94  4859
     95  4859
     96  4859							; Now we calculate move to new square
     97  4859
     98  4859		       a5 85		      lda	fromX12
     99  485b		       c5 86		      cmp	toX12
    100  485d		       f0 6a		      beq	.unmovedx
    101  485f		       85 83		      sta	lastSquareX12
    102  4861
    103  4861		       38		      sec
    104  4862		       a2 fd		      ldx	#-3
    105  4864		       e9 0a	   .sub10     sbc	#10
    106  4866		       e8		      inx
    107  4867		       b0 fb		      bcs	.sub10
    108  4869		       69 08		      adc	#8
    109  486b		       85 a4		      sta	__fromCol
    110  486d		       86 a2		      stx	__fromRow
    111  486f
    112  486f		       a5 86		      lda	toX12
    113  4871		       38		      sec
    114  4872		       a2 fd		      ldx	#-3
    115  4874		       e9 0a	   .sub10b    sbc	#10
    116  4876		       e8		      inx
    117  4877		       b0 fb		      bcs	.sub10b
    118  4879		       69 08		      adc	#8
    119  487b		       85 a5		      sta	__toCol
    120  487d
    121  487d
    122  487d		       e4 a2		      cpx	__fromRow
    123  487f		       f0 13		      beq	.rowDone
    124  4881
    125  4881		       b0 0a		      bcs	.incRow
    126  4883
    127  4883		       38		      sec
    128  4884		       a5 85		      lda	fromX12
    129  4886		       e9 0a		      sbc	#10
    130  4888		       85 85		      sta	fromX12
    131  488a		       4c 94 f0 	      jmp	.rowDone
    132  488d
    133  488d		       18	   .incRow    clc
    134  488e		       a5 85		      lda	fromX12
    135  4890		       69 0a		      adc	#10
    136  4892		       85 85		      sta	fromX12
    137  4894
    138  4894				   .rowDone
    139  4894
    140  4894		       a5 a5		      lda	__toCol
    141  4896		       c5 a4		      cmp	__fromCol
    142  4898		       f0 09		      beq	.colDone
    143  489a
    144  489a		       b0 05		      bcs	.incCol
    145  489c
    146  489c		       c6 85		      dec	fromX12
    147  489e		       4c a3 f0 	      jmp	.colDone
    148  48a1
    149  48a1		       e6 85	   .incCol    inc	fromX12
    150  48a3				   .colDone
    151  48a3
    152  48a3
    153  48a3
    154  48a3
    155  48a3							; erase object in new sqare --> blank
    156  48a3
    157  48a3		       a4 85		      ldy	fromX12
    158  48a5		       84 80		      sty	squareToDraw
    159  48a7
    160  48a7		       20 34 fc 	      jsr	GetBoard
    161  48aa		       c9 00		      cmp	#0
    162  48ac		       f0 03		      beq	.skipbl
    163  48ae		       20 a4 fc 	      jsr	CopySinglePiece	; erase next square along --> blank
    164  48b1
    165  48b1				   .skipbl
    166  48b1		       a4 85		      ldy	fromX12
    167  48b3		       84 a3		      sty	__boardIndex
    168  48b5
    169  48b5		       20 34 fc 	      jsr	GetBoard
    170  48b8		       85 99		      sta	lastPiece	; what we are overwriting
    171  48ba		       a5 98		      lda	fromPiece
    172  48bc		       09 40		      ora	#FLAG_MOVED	; prevents usage in castling for K/R
    173  48be		       29 df		      and	#~FLAG_ENPASSANT
    174  48c0		       a4 a3		      ldy	__boardIndex
    175  48c2		       20 4c fc 	      jsr	PutBoard
    176  48c5
      0  48c5					      PHASE	AI_MarchB
      1  48c5		       a9 18		      lda	#AI_MarchB
      2  48c7		       85 8c		      sta	aiState
    178  48c9
    179  48c9				   .unmovedx
    180  48c9		       60		      rts
    181  48ca
    182  48ca
    183  48ca							;---------------------------------------------------------------------------------------------------
    184  48ca
      0  48ca					      DEF	aiMarchB2
      1  48ca				   BANK_aiMarchB2 SET	_CURRENT_BANK
      2  48ca				   aiMarchB2
      3  48ca				   TEMPORARY_VAR SET	Overlay
      4  48ca				   TEMPORARY_OFFSET SET	0
      5  48ca				   VAR_BOUNDARY_aiMarchB2 SET	TEMPORARY_OFFSET
      6  48ca				   FUNCTION_NAME SET	aiMarchB2
      7  48ca					      SUBROUTINE
    186  48ca					      SUBROUTINE
    187  48ca
      0  48ca					      REFER	AiStateMachine
      1  48ca				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  48ca				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  48ca					      ENDIF
      0  48ca					      VEND	aiMarchB2
      1  48ca				  -	      IFNCONST	aiMarchB2
      2  48ca				  -	      ECHO	"Incorrect VEND label", aiMarchB2
      3  48ca				  -	      ERR
      4  48ca					      ENDIF
      5  48ca		       00 a2	   VAREND_aiMarchB2 =	TEMPORARY_VAR
    190  48ca
    191  48ca		       a4 83		      ldy	lastSquareX12
    192  48cc		       84 80		      sty	squareToDraw
    193  48ce
    194  48ce		       20 34 fc 	      jsr	GetBoard
    195  48d1		       c9 00		      cmp	#0
    196  48d3		       f0 03		      beq	.skipbl2
    197  48d5
    198  48d5		       20 a4 fc 	      jsr	CopySinglePiece	; draw previous piece back in old position
    199  48d8				   .skipbl2
    200  48d8
    201  48d8		       a5 85		      lda	fromX12
    202  48da		       c5 86		      cmp	toX12
    203  48dc		       f0 09		      beq	xhalt
    204  48de
    205  48de		       a9 00		      lda	#0	; inter-move segment speed (can be 0)
    206  48e0		       85 82		      sta	drawDelay
      0  48e2					      PHASE	AI_MarchToTargetA
      1  48e2		       a9 17		      lda	#AI_MarchToTargetA
      2  48e4		       85 8c		      sta	aiState
    208  48e6
    209  48e6		       60		      rts
    210  48e7
    211  48e7				   xhalt
    212  48e7
    213  48e7							;??? jsr FinaliseMove
    214  48e7
    215  48e7		       a9 04		      lda	#4	; on/off count
    216  48e9		       85 84		      sta	drawCount	; flashing for piece about to move
    217  48eb		       a9 00		      lda	#0
    218  48ed		       85 82		      sta	drawDelay
    219  48ef
      0  48ef					      PHASE	AI_FinalFlash
      1  48ef		       a9 1b		      lda	#AI_FinalFlash
      2  48f1		       85 8c		      sta	aiState
    221  48f3		       60		      rts
    222  48f4
    223  48f4
    224  48f4							;---------------------------------------------------------------------------------------------------
    225  48f4
    226  48f4				  -	      if	0
    227  48f4				  -	      DEF	FinaliseMove
    228  48f4				  -	      SUBROUTINE
    229  48f4				  -
    230  48f4				  -	      REFER	aiMarchB2
    231  48f4				  -	      VEND	FinaliseMove
    232  48f4				  -
    233  48f4				  -			; Now the visible movement on the board has happened, fix up the pointers to the pieces
    234  48f4				  -			; for both sides.
    235  48f4				  -
    236  48f4				  -	      lda	#BANK_FinaliseMove
    237  48f4				  -	      sta	savedBank
    238  48f4				  -
    239  48f4				  -			;lda sideToMove
    240  48f4				  -			;asl
    241  48f4				  -			;lda #RAMBANK_PLY
    242  48f4				  -			;adc #0
    243  48f4				  -			;jsr GoFixPieceList
    244  48f4				  -
    245  48f4				  -	      lda	toX12
    246  48f4				  -	      sta	fromX12	; there MAY be no other-side piece at this square - that is OK!
    247  48f4				  -	      sta	originX12
    248  48f4				  -
    249  48f4				  -	      lda	#0
    250  48f4				  -	      sta	toX12	; --> deleted (square=0)
    251  48f4				  -
    252  48f4				  -			;lda lastPiece
    253  48f4				  -			;beq .notake
    254  48f4				  -
    255  48f4				  -			;lda sideToMove
    256  48f4				  -			;eor #128
    257  48f4				  -			;asl
    258  48f4				  -			;lda #RAMBANK_PLY
    259  48f4				  -			;adc #0
    260  48f4				  -			;jsr GoFixPieceList		    ; REMOVE any captured object
    261  48f4				  -
    262  48f4				  -.notake    rts
    263  48f4					      endif
    264  48f4
    265  48f4
    266  48f4							;---------------------------------------------------------------------------------------------------
    267  48f4
      0  48f4					      DEF	aiMarchToTargetB
      1  48f4				   BANK_aiMarchToTargetB SET	_CURRENT_BANK
      2  48f4				   aiMarchToTargetB
      3  48f4				   TEMPORARY_VAR SET	Overlay
      4  48f4				   TEMPORARY_OFFSET SET	0
      5  48f4				   VAR_BOUNDARY_aiMarchToTargetB SET	TEMPORARY_OFFSET
      6  48f4				   FUNCTION_NAME SET	aiMarchToTargetB
      7  48f4					      SUBROUTINE
    269  48f4					      SUBROUTINE
    270  48f4
      0  48f4					      REFER	AiStateMachine
      1  48f4				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  48f4				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  48f4					      ENDIF
      0  48f4					      VEND	aiMarchToTargetB
      1  48f4				  -	      IFNCONST	aiMarchToTargetB
      2  48f4				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetB
      3  48f4				  -	      ERR
      4  48f4					      ENDIF
      5  48f4		       00 a2	   VAREND_aiMarchToTargetB =	TEMPORARY_VAR
    273  48f4
    274  48f4							; now we want to undraw the piece in the old square
    275  48f4
    276  48f4		       a5 83		      lda	lastSquareX12
    277  48f6		       85 80		      sta	squareToDraw
    278  48f8
    279  48f8		       20 a4 fc 	      jsr	CopySinglePiece	; erase whatever was on the previous square (completely blank)
    280  48fb
    281  48fb		       a4 83		      ldy	lastSquareX12
    282  48fd		       a5 9a		      lda	previousPiece
    283  48ff		       20 4c fc 	      jsr	PutBoard
    284  4902
    285  4902		       a5 99		      lda	lastPiece
    286  4904		       85 9a		      sta	previousPiece
    287  4906
      0  4906					      PHASE	AI_MarchB2
      1  4906		       a9 1a		      lda	#AI_MarchB2
      2  4908		       85 8c		      sta	aiState
    289  490a		       60		      rts
    290  490b
    291  490b
    292  490b							;---------------------------------------------------------------------------------------------------
    293  490b
    294  490b
    295  490b							;---------------------------------------------------------------------------------------------------
    296  490b
      0  490b					      DEF	CopySetupForMarker
      1  490b				   BANK_CopySetupForMarker SET	_CURRENT_BANK
      2  490b				   CopySetupForMarker
      3  490b				   TEMPORARY_VAR SET	Overlay
      4  490b				   TEMPORARY_OFFSET SET	0
      5  490b				   VAR_BOUNDARY_CopySetupForMarker SET	TEMPORARY_OFFSET
      6  490b				   FUNCTION_NAME SET	CopySetupForMarker
      7  490b					      SUBROUTINE
    298  490b					      SUBROUTINE
    299  490b
      0  490b					      REFER	markerDraw
      1  490b					      IF	VAREND_markerDraw > TEMPORARY_VAR
      2  490b				   TEMPORARY_VAR SET	VAREND_markerDraw
      3  490b					      ENDIF
      0  490b					      REFER	showPromoteOptions
      1  490b				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  490b				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  490b					      ENDIF
      0  490b					      VAR	__pieceColour, 1
      1  490b		       00 a4	   __pieceColour =	TEMPORARY_VAR
      2  490b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  490b
      4  490b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  490b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  490b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  490b					      ENDIF
      8  490b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  490b				  -	      ECHO	"Temporary Variable", __pieceColour, "overflow!"
     10  490b				  -	      ERR
     11  490b					      ENDIF
     12  490b					      LIST	ON
      0  490b					      VAR	__oddeven, 1
      1  490b		       00 a5	   __oddeven  =	TEMPORARY_VAR
      2  490b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  490b
      4  490b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  490b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  490b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  490b					      ENDIF
      8  490b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  490b				  -	      ECHO	"Temporary Variable", __oddeven, "overflow!"
     10  490b				  -	      ERR
     11  490b					      ENDIF
     12  490b					      LIST	ON
      0  490b					      VAR	__pmcol, 1
      1  490b		       00 a6	   __pmcol    =	TEMPORARY_VAR
      2  490b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  490b
      4  490b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  490b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  490b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  490b					      ENDIF
      8  490b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  490b				  -	      ECHO	"Temporary Variable", __pmcol, "overflow!"
     10  490b				  -	      ERR
     11  490b					      ENDIF
     12  490b					      LIST	ON
      0  490b					      VEND	CopySetupForMarker
      1  490b				  -	      IFNCONST	CopySetupForMarker
      2  490b				  -	      ECHO	"Incorrect VEND label", CopySetupForMarker
      3  490b				  -	      ERR
      4  490b					      ENDIF
      5  490b		       00 a7	   VAREND_CopySetupForMarker =	TEMPORARY_VAR
    306  490b
    307  490b		       a5 80		      lda	squareToDraw
    308  490d		       38		      sec
    309  490e		       a0 0a		      ldy	#10
    310  4910		       e9 0a	   .sub10     sbc	#10
    311  4912		       88		      dey
    312  4913		       b0 fb		      bcs	.sub10
    313  4915		       84 a5		      sty	__oddeven
    314  4917		       69 08		      adc	#8
    315  4919		       85 a6		      sta	__pmcol
    316  491b		       65 a5		      adc	__oddeven
    317  491d
    318  491d		       29 01		      and	#1
    319  491f		       49 01		      eor	#1
    320  4921		       f0 02		      beq	.white
    321  4923		       a9 24		      lda	#36
    322  4925				   .white
    323  4925		       85 a4		      sta	__pieceColour	; actually SQUARE black/white
    324  4927
    325  4927		       8a		      txa
    326  4928		       18		      clc
    327  4929		       65 a4		      adc	__pieceColour
    328  492b		       85 a4		      sta	__pieceColour
    329  492d
    330  492d		       a5 a6		      lda	__pmcol
    331  492f		       29 03		      and	#3
    332  4931
    333  4931		       18		      clc
    334  4932		       65 a4		      adc	__pieceColour
    335  4934		       a8		      tay
    336  4935		       60		      rts
    337  4936
    338  4936							;---------------------------------------------------------------------------------------------------
    339  4936
      0  4936					      DEF	CopySetup
      1  4936				   BANK_CopySetup SET	_CURRENT_BANK
      2  4936				   CopySetup
      3  4936				   TEMPORARY_VAR SET	Overlay
      4  4936				   TEMPORARY_OFFSET SET	0
      5  4936				   VAR_BOUNDARY_CopySetup SET	TEMPORARY_OFFSET
      6  4936				   FUNCTION_NAME SET	CopySetup
      7  4936					      SUBROUTINE
    341  4936					      SUBROUTINE
    342  4936
      0  4936					      REFER	CopySinglePiece
      1  4936					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  4936				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  4936					      ENDIF
      0  4936					      VAR	__tmp, 1
      1  4936		       00 a9	   __tmp      =	TEMPORARY_VAR
      2  4936				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4936
      4  4936				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4936				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4936				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4936					      ENDIF
      8  4936				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4936				  -	      ECHO	"Temporary Variable", __tmp, "overflow!"
     10  4936				  -	      ERR
     11  4936					      ENDIF
     12  4936					      LIST	ON
      0  4936					      VAR	__shiftx, 1
      1  4936		       00 aa	   __shiftx   =	TEMPORARY_VAR
      2  4936				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4936
      4  4936				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4936				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4936				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4936					      ENDIF
      8  4936				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4936				  -	      ECHO	"Temporary Variable", __shiftx, "overflow!"
     10  4936				  -	      ERR
     11  4936					      ENDIF
     12  4936					      LIST	ON
      0  4936					      VEND	CopySetup
      1  4936				  -	      IFNCONST	CopySetup
      2  4936				  -	      ECHO	"Incorrect VEND label", CopySetup
      3  4936				  -	      ERR
      4  4936					      ENDIF
      5  4936		       00 ab	   VAREND_CopySetup =	TEMPORARY_VAR
    347  4936
    348  4936		       a5 8b		      lda	savedBank
    349  4938		       48		      pha
    350  4939		       a9 09		      lda	#BANK_CopySetup
    351  493b		       85 8b		      sta	savedBank
    352  493d
    353  493d							; figure colouration of square
    354  493d
    355  493d		       a5 80		      lda	squareToDraw
    356  493f		       a2 0a		      ldx	#10
    357  4941		       38		      sec
    358  4942		       e9 0a	   .sub10     sbc	#10
    359  4944		       ca		      dex
    360  4945		       b0 fb		      bcs	.sub10
    361  4947		       69 08		      adc	#8
    362  4949		       85 aa		      sta	__shiftx
    363  494b		       86 a9		      stx	__tmp
    364  494d		       65 a9		      adc	__tmp
    365  494f
    366  494f
    367  494f		       29 01		      and	#1
    368  4951		       49 01		      eor	#1
    369  4953		       f0 02		      beq	.white
    370  4955		       a9 24		      lda	#36
    371  4957		       85 a4	   .white     sta	__pieceColour	; actually SQUARE black/white
    372  4959
    373  4959							; PieceColour = 0 for white square, 36 for black square
    374  4959
    375  4959							;lda #RAMBANK_MOVES_RAM
    376  4959							;sta SET_BANK_RAM
    377  4959
    378  4959		       a4 80		      ldy	squareToDraw
    379  495b		       20 34 fc 	      jsr	GetBoard	;lda Board,x
    380  495e		       0a		      asl
    381  495f		       90 02		      bcc	.blackAdjust
    382  4961		       09 10		      ora	#16
    383  4963		       4a	   .blackAdjust lsr
    384  4964		       29 0f		      and	#%1111
    385  4966		       aa		      tax
    386  4967
    387  4967		       a5 aa		      lda	__shiftx
    388  4969		       29 03		      and	#3	; shift position in P
    389  496b
    390  496b		       18		      clc
    391  496c		       7d 77 f1 	      adc	PieceToShape,x
    392  496f		       18		      clc
    393  4970		       65 a4		      adc	__pieceColour
    394  4972		       a8		      tay
    395  4973
    396  4973		       68		      pla
    397  4974		       85 8b		      sta	savedBank
    398  4976		       60		      rts
    399  4977
    400  4977				   PieceToShape
    401  4977
    402  4977		       00		      .byte.b	INDEX_WHITE_BLANK_on_WHITE_SQUARE_0
    403  4978		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    404  4979		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    405  497a		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    406  497b		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    407  497c		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    408  497d		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    409  497e		       18		      .byte.b	INDEX_WHITE_KING_on_WHITE_SQUARE_0
    410  497f
    411  497f		       48		      .byte.b	INDEX_BLACK_BLANK_on_WHITE_SQUARE_0
    412  4980		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    413  4981		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    414  4982		       50		      .byte.b	INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0
    415  4983		       54		      .byte.b	INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0
    416  4984		       58		      .byte.b	INDEX_BLACK_ROOK_on_WHITE_SQUARE_0
    417  4985		       5c		      .byte.b	INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    418  4986		       60		      .byte.b	INDEX_BLACK_KING_on_WHITE_SQUARE_0
    419  4987
    420  4987							;---------------------------------------------------------------------------------------------------
    421  4987
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  4987					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm"
      0  4987					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_0", 72
     12  4987					      LIST	ON
      0  4987					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_0
      1  4987				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  4987				   BLACK_BISHOP_on_BLACK_SQUARE_0
      3  4987				   TEMPORARY_VAR SET	Overlay
      4  4987				   TEMPORARY_OFFSET SET	0
      5  4987				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  4987				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_0
      7  4987					      SUBROUTINE
      3  4987		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$40,$00	;PF0
      4  499f		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  49b7		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  49cf					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm"
      0  49cf					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_1", 72
     12  4a00					      LIST	ON
      0  4a00					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_1
      1  4a00				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  4a00				   BLACK_BISHOP_on_BLACK_SQUARE_1
      3  4a00				   TEMPORARY_VAR SET	Overlay
      4  4a00				   TEMPORARY_OFFSET SET	0
      5  4a00				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  4a00				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_1
      7  4a00					      SUBROUTINE
      3  4a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a18		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$00,$00,$00,$10,$00	;PF1
      5  4a30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  4a48					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm"
      0  4a48					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_2", 72
     12  4a48					      LIST	ON
      0  4a48					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_2
      1  4a48				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  4a48				   BLACK_BISHOP_on_BLACK_SQUARE_2
      3  4a48				   TEMPORARY_VAR SET	Overlay
      4  4a48				   TEMPORARY_OFFSET SET	0
      5  4a48				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  4a48				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_2
      7  4a48					      SUBROUTINE
      3  4a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a60		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4a78		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$00,$00,$00,$01,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  4a90					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm"
      0  4a90					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_3", 72
     12  4a90					      LIST	ON
      0  4a90					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_3
      1  4a90				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  4a90				   BLACK_BISHOP_on_BLACK_SQUARE_3
      3  4a90				   TEMPORARY_VAR SET	Overlay
      4  4a90				   TEMPORARY_OFFSET SET	0
      5  4a90				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  4a90				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_3
      7  4a90					      SUBROUTINE
      3  4a90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4ac0		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$00,$00,$00,$20,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  4ad8					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm"
      0  4ad8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_0", 72
     12  4b00					      LIST	ON
      0  4b00					      DEF	BLACK_ROOK_on_BLACK_SQUARE_0
      1  4b00				   BANK_BLACK_ROOK_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  4b00				   BLACK_ROOK_on_BLACK_SQUARE_0
      3  4b00				   TEMPORARY_VAR SET	Overlay
      4  4b00				   TEMPORARY_OFFSET SET	0
      5  4b00				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  4b00				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_0
      7  4b00					      SUBROUTINE
      3  4b00		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$a0,$00,$00	;PF0
      4  4b18		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  4b48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm"
      0  4b48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_1", 72
     12  4b48					      LIST	ON
      0  4b48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_1
      1  4b48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  4b48				   BLACK_ROOK_on_BLACK_SQUARE_1
      3  4b48				   TEMPORARY_VAR SET	Overlay
      4  4b48				   TEMPORARY_OFFSET SET	0
      5  4b48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  4b48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_1
      7  4b48					      SUBROUTINE
      3  4b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4b60		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$28,$00,$00	;PF1
      5  4b78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  4b90					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm"
      0  4b90					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_2", 72
     12  4b90					      LIST	ON
      0  4b90					      DEF	BLACK_ROOK_on_BLACK_SQUARE_2
      1  4b90				   BANK_BLACK_ROOK_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  4b90				   BLACK_ROOK_on_BLACK_SQUARE_2
      3  4b90				   TEMPORARY_VAR SET	Overlay
      4  4b90				   TEMPORARY_OFFSET SET	0
      5  4b90				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  4b90				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_2
      7  4b90					      SUBROUTINE
      3  4b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ba8		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF1
      5  4bc0		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$02,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  4bd8					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm"
      0  4bd8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_3", 72
     12  4c00					      LIST	ON
      0  4c00					      DEF	BLACK_ROOK_on_BLACK_SQUARE_3
      1  4c00				   BANK_BLACK_ROOK_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  4c00				   BLACK_ROOK_on_BLACK_SQUARE_3
      3  4c00				   TEMPORARY_VAR SET	Overlay
      4  4c00				   TEMPORARY_OFFSET SET	0
      5  4c00				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  4c00				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_3
      7  4c00					      SUBROUTINE
      3  4c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4c30		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  4c48					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm"
      0  4c48					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_0", 72
     12  4c48					      LIST	ON
      0  4c48					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_0
      1  4c48				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  4c48				   BLACK_QUEEN_on_BLACK_SQUARE_0
      3  4c48				   TEMPORARY_VAR SET	Overlay
      4  4c48				   TEMPORARY_OFFSET SET	0
      5  4c48				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  4c48				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_0
      7  4c48					      SUBROUTINE
      3  4c48		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4c60		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  4c90					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm"
      0  4c90					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_1", 72
     12  4c90					      LIST	ON
      0  4c90					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_1
      1  4c90				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  4c90				   BLACK_QUEEN_on_BLACK_SQUARE_1
      3  4c90				   TEMPORARY_VAR SET	Overlay
      4  4c90				   TEMPORARY_OFFSET SET	0
      5  4c90				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  4c90				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_1
      7  4c90					      SUBROUTINE
      3  4c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ca8		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  4cd8					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm"
      0  4cd8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_2", 72
     12  4d00					      LIST	ON
      0  4d00					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_2
      1  4d00				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  4d00				   BLACK_QUEEN_on_BLACK_SQUARE_2
      3  4d00				   TEMPORARY_VAR SET	Overlay
      4  4d00				   TEMPORARY_OFFSET SET	0
      5  4d00				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  4d00				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_2
      7  4d00					      SUBROUTINE
      3  4d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4d18		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4d30		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  4d48					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm"
      0  4d48					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_3", 72
     12  4d48					      LIST	ON
      0  4d48					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_3
      1  4d48				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  4d48				   BLACK_QUEEN_on_BLACK_SQUARE_3
      3  4d48				   TEMPORARY_VAR SET	Overlay
      4  4d48				   TEMPORARY_OFFSET SET	0
      5  4d48				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  4d48				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_3
      7  4d48					      SUBROUTINE
      3  4d48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4d78		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  4d90					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_0.asm"
      0  4d90					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_0", 72
     12  4d90					      LIST	ON
      0  4d90					      DEF	BLACK_KING_on_BLACK_SQUARE_0
      1  4d90				   BANK_BLACK_KING_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  4d90				   BLACK_KING_on_BLACK_SQUARE_0
      3  4d90				   TEMPORARY_VAR SET	Overlay
      4  4d90				   TEMPORARY_OFFSET SET	0
      5  4d90				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  4d90				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_0
      7  4d90					      SUBROUTINE
      3  4d90		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$a0,$00,$00,$b0,$00,$00	;PF0
      4  4da8		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00	;PF1
      5  4dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  4dd8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_1.asm"
      0  4dd8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_1", 72
     12  4e00					      LIST	ON
      0  4e00					      DEF	BLACK_KING_on_BLACK_SQUARE_1
      1  4e00				   BANK_BLACK_KING_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  4e00				   BLACK_KING_on_BLACK_SQUARE_1
      3  4e00				   TEMPORARY_VAR SET	Overlay
      4  4e00				   TEMPORARY_OFFSET SET	0
      5  4e00				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  4e00				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_1
      7  4e00					      SUBROUTINE
      3  4e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4e18		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$28,$00,$00,$6c,$00,$00	;PF1
      5  4e30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  4e48					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_2.asm"
      0  4e48					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_2", 72
     12  4e48					      LIST	ON
      0  4e48					      DEF	BLACK_KING_on_BLACK_SQUARE_2
      1  4e48				   BANK_BLACK_KING_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  4e48				   BLACK_KING_on_BLACK_SQUARE_2
      3  4e48				   TEMPORARY_VAR SET	Overlay
      4  4e48				   TEMPORARY_OFFSET SET	0
      5  4e48				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  4e48				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_2
      7  4e48					      SUBROUTINE
      3  4e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4e60		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$01,$00,$00,$03,$00,$00	;PF1
      5  4e78		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$02,$00,$00,$06,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  4e90					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_3.asm"
      0  4e90					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_3", 72
     12  4e90					      LIST	ON
      0  4e90					      DEF	BLACK_KING_on_BLACK_SQUARE_3
      1  4e90				   BANK_BLACK_KING_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  4e90				   BLACK_KING_on_BLACK_SQUARE_3
      3  4e90				   TEMPORARY_VAR SET	Overlay
      4  4e90				   TEMPORARY_OFFSET SET	0
      5  4e90				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  4e90				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_3
      7  4e90					      SUBROUTINE
      3  4e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4ec0		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$50,$00,$00,$d8,$00,$00	;PF2
------- FILE BANK_RECON.asm
    438  4ed8
    439  4ed8
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 5
      0  4ed8					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm"
      0  4ed8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_3", 72
     12  4f00					      LIST	ON
      0  4f00					      DEF	WHITE_MARKER_on_WHITE_SQUARE_3
      1  4f00				   BANK_WHITE_MARKER_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  4f00				   WHITE_MARKER_on_WHITE_SQUARE_3
      3  4f00				   TEMPORARY_VAR SET	Overlay
      4  4f00				   TEMPORARY_OFFSET SET	0
      5  4f00				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  4f00				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_3
      7  4f00					      SUBROUTINE
      3  4f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4f18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4f30		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
    441  4f48
      0  4f48					      CHECK_BANK_SIZE	"BANK_RECON"
      1  4f48		       07 48	   .TEMP      =	* - BANK_START
 BANK_RECON (2K) SIZE =  $748 , FREE= $b8
      2  4f48					      ECHO	"BANK_RECON", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  4f48				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  4f48				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  4f48				  -	      ERR
      6  4f48					      endif
    443  4f48
    444  4f48							; EOF
------- FILE ./chess.asm
    533  4f48
    534  4f48							; The handlers for piece move generation
------- FILE Handler_BANK1.asm LEVEL 2 PASS 5
      0  4f48					      include	"Handler_BANK1.asm"
      1  4f48							; Copyright (C)2020 Andrew Davie
      2  4f48
      3  4f48							;---------------------------------------------------------------------------------------------------
      4  4f48
      0  4f48					      NEWRAMBANK	MOVES_RAM	; RAM bank for holding the following ROM shadow
      1  4f48
      2  4f48
      3  4f48
      4 U2000 ????				      SEG.U	MOVES_RAM
      5 U2000					      ORG	ORIGIN_RAM
      6 U2000					      RORG	RAM_3E
      7 U2000				   BANK_START SET	*
      8 U2000				   RAMBANK_MOVES_RAM SET	ORIGIN_RAM / RAM_SIZE
      9 U2000				   _CURRENT_RAMBANK SET	RAMBANK_MOVES_RAM
     10 U2000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U2000					      NEWBANK	MOVES	; copy the following bank to RAMBANK_MOVES_RAM
      1  5690 ????				      SEG	MOVES
      2  5000					      ORG	ORIGIN
      3  5000					      RORG	$F000
      4  5000				   BANK_START SET	*
      5  5000				   MOVES      SET	ORIGIN / 2048
      6  5000				   ORIGIN     SET	ORIGIN + 2048
      7  5000				   _CURRENT_BANK SET	MOVES
      7  5000
      8  5000							; Board is a 10 x 12 object which simplifies the generation of moves
      9  5000							; The squares marked '░░░' are illegal. The ("X12") index of each square is the left
     10  5000							; number + the bottom number. Bottom left legal square (AS VISIBLE ON SCREEN) is #22
     11  5000
     12  5000							;     X12 numbering
     13  5000							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     14  5000							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     15  5000							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     16  5000							; 90 ┃░░░┊░░░┊ 92┊ 93┊ 94┊ 95┊ 96┊ 97┊ 98┊ 99┃ 8 BLACK
     17  5000							; 80 ┃░░░┊░░░┊ 82┊ 83┊ 84┊ 85┊ 86┊ 87┊ 88┊ 89┃ 7 BLACK
     18  5000							; 70 ┃░░░┊░░░┊ 72┊ 73┊ 74┊ 75┊ 76┊ 77┊ 78┊ 79┃ 6
     19  5000							; 60 ┃░░░┊░░░┊ 62┊ 63┊ 64┊ 65┊ 66┊ 67┊ 68┊ 69┃ 5
     20  5000							; 50 ┃░░░┊░░░┊ 52┊ 53┊ 54┊ 55┊ 56┊ 57┊ 58┊ 59┃ 4
     21  5000							; 40 ┃░░░┊░░░┊ 42┊ 43┊ 44┊ 45┊ 46┊ 47┊ 48┊ 49┃ 3
     22  5000							; 30 ┃░░░┊░░░┊ 32┊ 33┊ 34┊ 35┊ 36┊ 37┊ 38┊ 39┃ 2 WHITE
     23  5000							; 20 ┃░░░┊░░░┊ 22┊ 23┊ 24┊ 25┊ 26┊ 27┊ 28┊ 29┃ 1 WHITE
     24  5000							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     25  5000							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     26  5000							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     27  5000							;	0   1	2   3	4   5	6   7	8   9
     28  5000							;		A   B	C   D	E   F	G   H
     29  5000
     30  5000							;     HEX X12
     31  5000							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     32  5000							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     33  5000							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     34  5000							; 90 ┃░░░┊░░░┊$5C┊$5D┊$5E┊$5F┊$60┊$61┊$62┊$63┃ 8
     35  5000							; 80 ┃░░░┊░░░┊$52┊$53┊$54┊$55┊$56┊$57┊$58┊$59┃ 7
     36  5000							; 70 ┃░░░┊░░░┊$48┊$49┊$4A┊$4B┊$4C┊$4D┊$4E┊$4F┃ 6
     37  5000							; 60 ┃░░░┊░░░┊$3E┊$3F┊$40┊$41┊$42┊$43┊$44┊$45┃ 5
     38  5000							; 50 ┃░░░┊░░░┊$34┊$35┊$36┊$37┊$38┊$39┊$3A┊$3B┃ 4
     39  5000							; 40 ┃░░░┊░░░┊$2A┊$2B┊$2C┊$2D┊$2E┊$2F┊$30┊$31┃ 3
     40  5000							; 30 ┃░░░┊░░░┊$20┊$21┊$22┊$23┊$24┊$25┊$26|$27┃ 2
     41  5000							; 20 ┃░░░┊░░░┊$16┊$17┊$18┊$19┊$1A┊$1B┊$1C┊$1D┃ 1
     42  5000							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     43  5000							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     44  5000							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     45  5000							;	0   1	2   3	4   5	6   7	8   9
     46  5000							;		A   B	C   D	E   F	G   H
     47  5000
     48  5000
     49  5000							; We put a short buffer before 'ValidSquare' when it is at the start of the bank, so that
     50  5000							; the move indexing (ie., "ValidSquare+{1},x" won't drop off the beginning of the bank
     51  5000							; and sause "segfaults". 21 is the max offset (a knight move). These spare bytes can
     52  5000							; be re-used for something else - we just need to guarantee there are 21 of them there
     53  5000
      0  5000					      ALLOCATE	Valid, 120 + 80 + 21
      0  5000					      OPTIONAL_PAGEBREAK	"Table", 120 + 80 + 21
     12  5000					      LIST	ON
      0  5000					      DEF	Valid
      1  5000				   BANK_Valid SET	_CURRENT_BANK
      2  5000				   Valid
      3  5000				   TEMPORARY_VAR SET	Overlay
      4  5000				   TEMPORARY_OFFSET SET	0
      5  5000				   VAR_BOUNDARY_Valid SET	TEMPORARY_OFFSET
      6  5000				   FUNCTION_NAME SET	Valid
      7  5000					      SUBROUTINE
     55  5000		       00 00 00 00*	      ds	21	; so indexing of "ValidSquare-21,x" won't fail
     56  5015
     57  5015							; Note, we will never index INTO the above bytes - x will always be >= 22
     58  5015							; We just need to make sure that the actual indexing will not have an address before
     59  5015							; the index of outside the page.
     60  5015
      0  5015					      DEF	ValidSquare
      1  5015				   BANK_ValidSquare SET	_CURRENT_BANK
      2  5015				   ValidSquare
      3  5015				   TEMPORARY_VAR SET	Overlay
      4  5015				   TEMPORARY_OFFSET SET	0
      5  5015				   VAR_BOUNDARY_ValidSquare SET	TEMPORARY_OFFSET
      6  5015				   FUNCTION_NAME SET	ValidSquare
      7  5015					      SUBROUTINE
     62  5015
     63  5015
     64  5015							; Use this table to
     65  5015							;   a) Determine if a square is valid (-1 = NO)
     66  5015							;   b) Move pieces without addition.  e.g., "lda ValidSquareTable+10,x" will let you know
     67  5015							;	if a white pawn on square "x" can move "up" the board.
     68  5015
     69  5015		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     70  501f		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     71  5029		       ff ff 16 17*	      .byte.b	-1, -1, 22, 23, 24, 25, 26, 27, 28, 29
     72  5033		       ff ff 20 21*	      .byte.b	-1, -1, 32, 33, 34, 35, 36, 37, 38, 39
     73  503d		       ff ff 2a 2b*	      .byte.b	-1, -1, 42, 43, 44, 45, 46, 47, 48, 49
     74  5047		       ff ff 34 35*	      .byte.b	-1, -1, 52, 53, 54, 55, 56, 57, 58, 59
     75  5051		       ff ff 3e 3f*	      .byte.b	-1, -1, 62, 63, 64, 65, 66, 67, 68, 69
     76  505b		       ff ff 48 49*	      .byte.b	-1, -1, 72, 73, 74, 75, 76, 77, 78, 79
     77  5065		       ff ff 52 53*	      .byte.b	-1, -1, 82, 83, 84, 85, 86, 87, 88, 89
     78  506f		       ff ff 5c 5d*	      .byte.b	-1, -1, 92, 93, 94, 95, 96, 97, 98, 99	; CONTINUES...
     79  5079
      0  5079					      DEF	Board
      1  5079				   BANK_Board SET	_CURRENT_BANK
      2  5079				   Board
      3  5079				   TEMPORARY_VAR SET	Overlay
      4  5079				   TEMPORARY_OFFSET SET	0
      5  5079				   VAR_BOUNDARY_Board SET	TEMPORARY_OFFSET
      6  5079				   FUNCTION_NAME SET	Board
      7  5079					      SUBROUTINE
     81  5079
     82  5079							; A 10X10... we should never write using invalid square
     83  5079							; ON COPY TO RAM BANK, 'BOARD' SELF-INITIALISES TO THE FOLLOWING VALUES
     84  5079							; FROM THEN ON IT'S WRITEABLE (REMEMBER TO +RAM_WRITE) FOR MODIFICATIONS
     85  5079
     86  5079		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     87  5083		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     88  508d
     89  508d					      REPEAT	8
     90  508d		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     89  508d					      REPEND
     90  5097		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     89  5097					      REPEND
     90  50a1		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     89  50a1					      REPEND
     90  50ab		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     89  50ab					      REPEND
     90  50b5		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     89  50b5					      REPEND
     90  50bf		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     89  50bf					      REPEND
     90  50c9		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     89  50c9					      REPEND
     90  50d3		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     91  50dd					      REPEND
     92  50dd
     93  50dd							; DON'T OVERSTEP BOUNDS WHEN WRITING BOARD - MAXIMUM INDEX = 99
     94  50dd
     95  50dd
     96  50dd							;---------------------------------------------------------------------------------------------------
     97  50dd
------- FILE Handler_QUEEN.asm LEVEL 3 PASS 5
      0  50dd					      include	"Handler_QUEEN.asm"
      1  50dd							; Copyright (C)2020 Andrew Davie
      2  50dd
      3  50dd							;---------------------------------------------------------------------------------------------------
      4  50dd							; QUEEN
      5  50dd							;---------------------------------------------------------------------------------------------------
      6  50dd
      0  50dd					      DEF	Handle_QUEEN
      1  50dd				   BANK_Handle_QUEEN SET	_CURRENT_BANK
      2  50dd				   Handle_QUEEN
      3  50dd				   TEMPORARY_VAR SET	Overlay
      4  50dd				   TEMPORARY_OFFSET SET	0
      5  50dd				   VAR_BOUNDARY_Handle_QUEEN SET	TEMPORARY_OFFSET
      6  50dd				   FUNCTION_NAME SET	Handle_QUEEN
      7  50dd					      SUBROUTINE
      8  50dd					      SUBROUTINE
      9  50dd
      0  50dd					      REFER	GenerateAllMoves
      1  50dd					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  50dd				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  50dd					      ENDIF
      0  50dd					      VEND	Handle_QUEEN
      1  50dd				  -	      IFNCONST	Handle_QUEEN
      2  50dd				  -	      ECHO	"Incorrect VEND label", Handle_QUEEN
      3  50dd				  -	      ERR
      4  50dd					      ENDIF
      5  50dd		       00 ab	   VAREND_Handle_QUEEN =	TEMPORARY_VAR
     12  50dd
     13  50dd							; Pass...
     14  50dd							; x = currentSquare (square the piece is on)
     15  50dd							; currentPiece (with flags/colour attached)
     16  50dd
      0  50dd					      MOVE_TOWARDS	_DOWN+_LEFT
      1  50dd					      SUBROUTINE
      2  50dd
      3  50dd
      4  50dd
      5  50dd		       a6 93		      ldx	currentSquare
      6  50df		       d0 03		      bne	.project
      7  50e1
      8  50e1		       20 a5 fb    .empty     jsr	AddMove
      9  50e4		       bc 0a f0    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     10  50e7		       30 0c		      bmi	.invalid
     11  50e9		       b9 79 f0 	      lda	Board,y
     12  50ec		       f0 f3		      beq	.empty
     13  50ee		       45 92		      eor	currentPiece
     14  50f0		       10 03		      bpl	.invalid
     15  50f2		       20 a5 fb 	      jsr	AddMove
     16  50f5
     17  50f5				   .invalid
      0  50f5					      MOVE_TOWARDS	_DOWN
      1  50f5					      SUBROUTINE
      2  50f5
      3  50f5
      4  50f5
      5  50f5		       a6 93		      ldx	currentSquare
      6  50f7		       d0 03		      bne	.project
      7  50f9
      8  50f9		       20 a5 fb    .empty     jsr	AddMove
      9  50fc		       bc 0b f0    .project   ldy	ValidSquare+_DOWN,x
     10  50ff		       30 0c		      bmi	.invalid
     11  5101		       b9 79 f0 	      lda	Board,y
     12  5104		       f0 f3		      beq	.empty
     13  5106		       45 92		      eor	currentPiece
     14  5108		       10 03		      bpl	.invalid
     15  510a		       20 a5 fb 	      jsr	AddMove
     16  510d
     17  510d				   .invalid
      0  510d					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  510d					      SUBROUTINE
      2  510d
      3  510d
      4  510d
      5  510d		       a6 93		      ldx	currentSquare
      6  510f		       d0 03		      bne	.project
      7  5111
      8  5111		       20 a5 fb    .empty     jsr	AddMove
      9  5114		       bc 0c f0    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     10  5117		       30 0c		      bmi	.invalid
     11  5119		       b9 79 f0 	      lda	Board,y
     12  511c		       f0 f3		      beq	.empty
     13  511e		       45 92		      eor	currentPiece
     14  5120		       10 03		      bpl	.invalid
     15  5122		       20 a5 fb 	      jsr	AddMove
     16  5125
     17  5125				   .invalid
      0  5125					      MOVE_TOWARDS	_RIGHT
      1  5125					      SUBROUTINE
      2  5125
      3  5125
      4  5125
      5  5125		       a6 93		      ldx	currentSquare
      6  5127		       d0 03		      bne	.project
      7  5129
      8  5129		       20 a5 fb    .empty     jsr	AddMove
      9  512c		       bc 16 f0    .project   ldy	ValidSquare+_RIGHT,x
     10  512f		       30 0c		      bmi	.invalid
     11  5131		       b9 79 f0 	      lda	Board,y
     12  5134		       f0 f3		      beq	.empty
     13  5136		       45 92		      eor	currentPiece
     14  5138		       10 03		      bpl	.invalid
     15  513a		       20 a5 fb 	      jsr	AddMove
     16  513d
     17  513d				   .invalid
      0  513d					      MOVE_TOWARDS	_UP+_RIGHT
      1  513d					      SUBROUTINE
      2  513d
      3  513d
      4  513d
      5  513d		       a6 93		      ldx	currentSquare
      6  513f		       d0 03		      bne	.project
      7  5141
      8  5141		       20 a5 fb    .empty     jsr	AddMove
      9  5144		       bc 20 f0    .project   ldy	ValidSquare+_UP+_RIGHT,x
     10  5147		       30 0c		      bmi	.invalid
     11  5149		       b9 79 f0 	      lda	Board,y
     12  514c		       f0 f3		      beq	.empty
     13  514e		       45 92		      eor	currentPiece
     14  5150		       10 03		      bpl	.invalid
     15  5152		       20 a5 fb 	      jsr	AddMove
     16  5155
     17  5155				   .invalid
      0  5155					      MOVE_TOWARDS	_UP
      1  5155					      SUBROUTINE
      2  5155
      3  5155
      4  5155
      5  5155		       a6 93		      ldx	currentSquare
      6  5157		       d0 03		      bne	.project
      7  5159
      8  5159		       20 a5 fb    .empty     jsr	AddMove
      9  515c		       bc 1f f0    .project   ldy	ValidSquare+_UP,x
     10  515f		       30 0c		      bmi	.invalid
     11  5161		       b9 79 f0 	      lda	Board,y
     12  5164		       f0 f3		      beq	.empty
     13  5166		       45 92		      eor	currentPiece
     14  5168		       10 03		      bpl	.invalid
     15  516a		       20 a5 fb 	      jsr	AddMove
     16  516d
     17  516d				   .invalid
      0  516d					      MOVE_TOWARDS	_UP+_LEFT
      1  516d					      SUBROUTINE
      2  516d
      3  516d
      4  516d
      5  516d		       a6 93		      ldx	currentSquare
      6  516f		       d0 03		      bne	.project
      7  5171
      8  5171		       20 a5 fb    .empty     jsr	AddMove
      9  5174		       bc 1e f0    .project   ldy	ValidSquare+_UP+_LEFT,x
     10  5177		       30 0c		      bmi	.invalid
     11  5179		       b9 79 f0 	      lda	Board,y
     12  517c		       f0 f3		      beq	.empty
     13  517e		       45 92		      eor	currentPiece
     14  5180		       10 03		      bpl	.invalid
     15  5182		       20 a5 fb 	      jsr	AddMove
     16  5185
     17  5185				   .invalid
      0  5185					      MOVE_TOWARDS	_LEFT
      1  5185					      SUBROUTINE
      2  5185
      3  5185
      4  5185
      5  5185		       a6 93		      ldx	currentSquare
      6  5187		       d0 03		      bne	.project
      7  5189
      8  5189		       20 a5 fb    .empty     jsr	AddMove
      9  518c		       bc 14 f0    .project   ldy	ValidSquare+_LEFT,x
     10  518f		       30 0c		      bmi	.invalid
     11  5191		       b9 79 f0 	      lda	Board,y
     12  5194		       f0 f3		      beq	.empty
     13  5196		       45 92		      eor	currentPiece
     14  5198		       10 03		      bpl	.invalid
     15  519a		       20 a5 fb 	      jsr	AddMove
     16  519d
     17  519d				   .invalid
     25  519d
     26  519d		       4c 33 f9 	      jmp	MoveReturn
     27  51a0
     28  51a0							; EOF
------- FILE Handler_BANK1.asm
------- FILE Handler_BISHOP.asm LEVEL 3 PASS 5
      0  51a0					      include	"Handler_BISHOP.asm"
      1  51a0							; Copyright (C)2020 Andrew Davie
      2  51a0
      3  51a0							;---------------------------------------------------------------------------------------------------
      4  51a0							; BISHOP
      5  51a0							;---------------------------------------------------------------------------------------------------
      6  51a0
      0  51a0					      DEF	Handle_BISHOP
      1  51a0				   BANK_Handle_BISHOP SET	_CURRENT_BANK
      2  51a0				   Handle_BISHOP
      3  51a0				   TEMPORARY_VAR SET	Overlay
      4  51a0				   TEMPORARY_OFFSET SET	0
      5  51a0				   VAR_BOUNDARY_Handle_BISHOP SET	TEMPORARY_OFFSET
      6  51a0				   FUNCTION_NAME SET	Handle_BISHOP
      7  51a0					      SUBROUTINE
      8  51a0					      SUBROUTINE
      9  51a0
      0  51a0					      REFER	GenerateAllMoves
      1  51a0					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  51a0				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  51a0					      ENDIF
      0  51a0					      VEND	Handle_BISHOP
      1  51a0				  -	      IFNCONST	Handle_BISHOP
      2  51a0				  -	      ECHO	"Incorrect VEND label", Handle_BISHOP
      3  51a0				  -	      ERR
      4  51a0					      ENDIF
      5  51a0		       00 ab	   VAREND_Handle_BISHOP =	TEMPORARY_VAR
     12  51a0
     13  51a0							; x = currentSquare (square the piece is on)
     14  51a0							; currentPiece (with flags/colour attached)
     15  51a0
      0  51a0					      MOVE_TOWARDS	_DOWN+_LEFT
      1  51a0					      SUBROUTINE
      2  51a0
      3  51a0
      4  51a0
      5  51a0		       a6 93		      ldx	currentSquare
      6  51a2		       d0 03		      bne	.project
      7  51a4
      8  51a4		       20 a5 fb    .empty     jsr	AddMove
      9  51a7		       bc 0a f0    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     10  51aa		       30 0c		      bmi	.invalid
     11  51ac		       b9 79 f0 	      lda	Board,y
     12  51af		       f0 f3		      beq	.empty
     13  51b1		       45 92		      eor	currentPiece
     14  51b3		       10 03		      bpl	.invalid
     15  51b5		       20 a5 fb 	      jsr	AddMove
     16  51b8
     17  51b8				   .invalid
      0  51b8					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  51b8					      SUBROUTINE
      2  51b8
      3  51b8
      4  51b8
      5  51b8		       a6 93		      ldx	currentSquare
      6  51ba		       d0 03		      bne	.project
      7  51bc
      8  51bc		       20 a5 fb    .empty     jsr	AddMove
      9  51bf		       bc 0c f0    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     10  51c2		       30 0c		      bmi	.invalid
     11  51c4		       b9 79 f0 	      lda	Board,y
     12  51c7		       f0 f3		      beq	.empty
     13  51c9		       45 92		      eor	currentPiece
     14  51cb		       10 03		      bpl	.invalid
     15  51cd		       20 a5 fb 	      jsr	AddMove
     16  51d0
     17  51d0				   .invalid
      0  51d0					      MOVE_TOWARDS	_UP+_LEFT
      1  51d0					      SUBROUTINE
      2  51d0
      3  51d0
      4  51d0
      5  51d0		       a6 93		      ldx	currentSquare
      6  51d2		       d0 03		      bne	.project
      7  51d4
      8  51d4		       20 a5 fb    .empty     jsr	AddMove
      9  51d7		       bc 1e f0    .project   ldy	ValidSquare+_UP+_LEFT,x
     10  51da		       30 0c		      bmi	.invalid
     11  51dc		       b9 79 f0 	      lda	Board,y
     12  51df		       f0 f3		      beq	.empty
     13  51e1		       45 92		      eor	currentPiece
     14  51e3		       10 03		      bpl	.invalid
     15  51e5		       20 a5 fb 	      jsr	AddMove
     16  51e8
     17  51e8				   .invalid
      0  51e8					      MOVE_TOWARDS	_UP+_RIGHT
      1  51e8					      SUBROUTINE
      2  51e8
      3  51e8
      4  51e8
      5  51e8		       a6 93		      ldx	currentSquare
      6  51ea		       d0 03		      bne	.project
      7  51ec
      8  51ec		       20 a5 fb    .empty     jsr	AddMove
      9  51ef		       bc 20 f0    .project   ldy	ValidSquare+_UP+_RIGHT,x
     10  51f2		       30 0c		      bmi	.invalid
     11  51f4		       b9 79 f0 	      lda	Board,y
     12  51f7		       f0 f3		      beq	.empty
     13  51f9		       45 92		      eor	currentPiece
     14  51fb		       10 03		      bpl	.invalid
     15  51fd		       20 a5 fb 	      jsr	AddMove
     16  5200
     17  5200				   .invalid
     20  5200
     21  5200		       4c 33 f9 	      jmp	MoveReturn
     22  5203
     23  5203							;---------------------------------------------------------------------------------------------------
     24  5203							; EOF
------- FILE Handler_BANK1.asm
------- FILE Handler_ROOK.asm LEVEL 3 PASS 5
      0  5203					      include	"Handler_ROOK.asm"
      1  5203							; Copyright (C)2020 Andrew Davie
      2  5203							; Rook move handler
      3  5203
      4  5203							;---------------------------------------------------------------------------------------------------
      5  5203							; ROOK
      6  5203							;---------------------------------------------------------------------------------------------------
      7  5203
      0  5203					      DEF	Handle_ROOK
      1  5203				   BANK_Handle_ROOK SET	_CURRENT_BANK
      2  5203				   Handle_ROOK
      3  5203				   TEMPORARY_VAR SET	Overlay
      4  5203				   TEMPORARY_OFFSET SET	0
      5  5203				   VAR_BOUNDARY_Handle_ROOK SET	TEMPORARY_OFFSET
      6  5203				   FUNCTION_NAME SET	Handle_ROOK
      7  5203					      SUBROUTINE
      9  5203					      SUBROUTINE
     10  5203
      0  5203					      REFER	GenerateAllMoves
      1  5203					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5203				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5203					      ENDIF
      0  5203					      VEND	Handle_ROOK
      1  5203				  -	      IFNCONST	Handle_ROOK
      2  5203				  -	      ECHO	"Incorrect VEND label", Handle_ROOK
      3  5203				  -	      ERR
      4  5203					      ENDIF
      5  5203		       00 ab	   VAREND_Handle_ROOK =	TEMPORARY_VAR
     13  5203
     14  5203							; Pass...
     15  5203							; x = currentSquare (square the piece is on)
     16  5203							; currentPiece (with flags/colour attached)
     17  5203
      0  5203					      MOVE_TOWARDS	_DOWN
      1  5203					      SUBROUTINE
      2  5203
      3  5203
      4  5203
      5  5203		       a6 93		      ldx	currentSquare
      6  5205		       d0 03		      bne	.project
      7  5207
      8  5207		       20 a5 fb    .empty     jsr	AddMove
      9  520a		       bc 0b f0    .project   ldy	ValidSquare+_DOWN,x
     10  520d		       30 0c		      bmi	.invalid
     11  520f		       b9 79 f0 	      lda	Board,y
     12  5212		       f0 f3		      beq	.empty
     13  5214		       45 92		      eor	currentPiece
     14  5216		       10 03		      bpl	.invalid
     15  5218		       20 a5 fb 	      jsr	AddMove
     16  521b
     17  521b				   .invalid
      0  521b					      MOVE_TOWARDS	_RIGHT
      1  521b					      SUBROUTINE
      2  521b
      3  521b
      4  521b
      5  521b		       a6 93		      ldx	currentSquare
      6  521d		       d0 03		      bne	.project
      7  521f
      8  521f		       20 a5 fb    .empty     jsr	AddMove
      9  5222		       bc 16 f0    .project   ldy	ValidSquare+_RIGHT,x
     10  5225		       30 0c		      bmi	.invalid
     11  5227		       b9 79 f0 	      lda	Board,y
     12  522a		       f0 f3		      beq	.empty
     13  522c		       45 92		      eor	currentPiece
     14  522e		       10 03		      bpl	.invalid
     15  5230		       20 a5 fb 	      jsr	AddMove
     16  5233
     17  5233				   .invalid
      0  5233					      MOVE_TOWARDS	_UP
      1  5233					      SUBROUTINE
      2  5233
      3  5233
      4  5233
      5  5233		       a6 93		      ldx	currentSquare
      6  5235		       d0 03		      bne	.project
      7  5237
      8  5237		       20 a5 fb    .empty     jsr	AddMove
      9  523a		       bc 1f f0    .project   ldy	ValidSquare+_UP,x
     10  523d		       30 0c		      bmi	.invalid
     11  523f		       b9 79 f0 	      lda	Board,y
     12  5242		       f0 f3		      beq	.empty
     13  5244		       45 92		      eor	currentPiece
     14  5246		       10 03		      bpl	.invalid
     15  5248		       20 a5 fb 	      jsr	AddMove
     16  524b
     17  524b				   .invalid
      0  524b					      MOVE_TOWARDS	_LEFT
      1  524b					      SUBROUTINE
      2  524b
      3  524b
      4  524b
      5  524b		       a6 93		      ldx	currentSquare
      6  524d		       d0 03		      bne	.project
      7  524f
      8  524f		       20 a5 fb    .empty     jsr	AddMove
      9  5252		       bc 14 f0    .project   ldy	ValidSquare+_LEFT,x
     10  5255		       30 0c		      bmi	.invalid
     11  5257		       b9 79 f0 	      lda	Board,y
     12  525a		       f0 f3		      beq	.empty
     13  525c		       45 92		      eor	currentPiece
     14  525e		       10 03		      bpl	.invalid
     15  5260		       20 a5 fb 	      jsr	AddMove
     16  5263
     17  5263				   .invalid
     22  5263
     23  5263		       4c 33 f9 	      jmp	MoveReturn
     24  5266
     25  5266							;---------------------------------------------------------------------------------------------------
     26  5266							; EOF
------- FILE Handler_BANK1.asm
------- FILE Handler_KING.asm LEVEL 3 PASS 5
      0  5266					      include	"Handler_KING.asm"
      1  5266							; Copyright (C)2020 Andrew Davie
      2  5266
      3  5266							;---------------------------------------------------------------------------------------------------
      4  5266							; KING
      5  5266							; This is the move handler for a KING
      6  5266							; "Check" is detected in the next ply of the search.
      7  5266
      8  5266
      9  5266							;---------------------------------------------------------------------------------------------------
     10  5266
     11  5266							; MACRO - Castling
     12  5266
     13  5266		       00 03	   KINGSIDE   =	3
     14  5266		       ff ff ff fc QUEENSIDE  =	-4
     15  5266
     16  5266					      MAC	castle
     17  5266							; {1} = "KINGSIDE" or "QUEENSIDE"
     18  5266
     19  5266					      ldx	currentSquare
     20  5266					      lda	Board+{1},x	; kingside/queenside R position
     21  5266					      and	#PIECE_MASK|FLAG_MOVED
     22  5266					      cmp	#ROOK
     23  5266					      bne	.noCastle	; not a R that hasn't moved
     24  5266
     25  5266							; It's a R and it *HAS* to be correct colour because it hasn't moved!
     26  5266							; AND the K hasn't moved (earlier check), so check for vacant squares between K and R
     27  5266
     28  5266					      IF	{1} = QUEENSIDE
     29  5266					      lda	Board-3,x	; N pos
     30  5266					      ora	Board-2,x	; B pos
     31  5266					      ora	Board-1,x	; Q pos
     32  5266					      bne	.noCastle	; not vacant?
     33  5266
     34  5266					      ENDIF
     35  5266
     36  5266					      IF	{1} = KINGSIDE
     37  5266					      lda	Board+2,x	; N pos
     38  5266					      ora	Board+1,x	; B pos
     39  5266					      bne	.noCastle	; not vacant?
     40  5266					      ENDIF
     41  5266
     42  5266							; appropriate N/B/(Q) squares are vacant so we proceed...
     43  5266
     44  5266							; FINALLY -- king can castle
     45  5266							; note: when we actually DO the move we MUST insert "Phantom" kings onto the board over the
     46  5266							; squares the king traverses so that "check" (and thus illegal moves) can be detected on the
     47  5266							; next move. Castling will be detected by K moving > 1 square. (TODO: FIX?? not CASTLE flag??)
     48  5266
     49  5266					      lda	currentPiece
     50  5266					      ora	#FLAG_CASTLE	; flag it's a castling move
     51  5266					      sta	currentPiece
     52  5266
     53  5266					      IF	{1} = KINGSIDE
     54  5266					      ldy	ValidSquare+2,x
     55  5266					      ENDIF
     56  5266
     57  5266					      IF	{1} = QUEENSIDE
     58  5266					      ldy	ValidSquare-2,x
     59  5266					      ENDIF
     60  5266
     61  5266					      jsr	AddMove	; 57
     62  5266
     63  5266				   .noCastle
     64  5266					      ENDM
     65  5266
     66  5266
     67  5266							;---------------------------------------------------------------------------------------------------
     68  5266
      0  5266					      DEF	Handle_KING
      1  5266				   BANK_Handle_KING SET	_CURRENT_BANK
      2  5266				   Handle_KING
      3  5266				   TEMPORARY_VAR SET	Overlay
      4  5266				   TEMPORARY_OFFSET SET	0
      5  5266				   VAR_BOUNDARY_Handle_KING SET	TEMPORARY_OFFSET
      6  5266				   FUNCTION_NAME SET	Handle_KING
      7  5266					      SUBROUTINE
     70  5266					      SUBROUTINE
     71  5266
      0  5266					      REFER	GenerateAllMoves
      1  5266					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5266				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5266					      ENDIF
      0  5266					      VEND	Handle_KING
      1  5266				  -	      IFNCONST	Handle_KING
      2  5266				  -	      ECHO	"Incorrect VEND label", Handle_KING
      3  5266				  -	      ERR
      4  5266					      ENDIF
      5  5266		       00 ab	   VAREND_Handle_KING =	TEMPORARY_VAR
     74  5266
     75  5266							; x = currentSquare (square the KING is on)
     76  5266							; currentPiece (KING of course, but with flags/colour attached)
     77  5266
      0  5266					      MOVE_TO	_DOWN+_LEFT
      1  5266					      SUBROUTINE
      2  5266		       bc 0a f0 	      ldy	ValidSquare+_DOWN+_LEFT,x
      3  5269		       30 0c		      bmi	.invalid
      4  526b		       b9 79 f0 	      lda	Board,y
      5  526e		       f0 04		      beq	.squareEmpty
      6  5270		       45 92		      eor	currentPiece
      7  5272		       10 03		      bpl	.invalid
      8  5274		       20 a5 fb    .squareEmpty jsr	AddMove
      9  5277				   .invalid
      0  5277					      MOVE_TO_X	_DOWN
      1  5277		       a6 93		      ldx	currentSquare
      0  5279					      MOVE_TO	_DOWN
      1  5279					      SUBROUTINE
      2  5279		       bc 0b f0 	      ldy	ValidSquare+_DOWN,x
      3  527c		       30 0c		      bmi	.invalid
      4  527e		       b9 79 f0 	      lda	Board,y
      5  5281		       f0 04		      beq	.squareEmpty
      6  5283		       45 92		      eor	currentPiece
      7  5285		       10 03		      bpl	.invalid
      8  5287		       20 a5 fb    .squareEmpty jsr	AddMove
      9  528a				   .invalid
      0  528a					      MOVE_TO_X	_DOWN+_RIGHT
      1  528a		       a6 93		      ldx	currentSquare
      0  528c					      MOVE_TO	_DOWN+_RIGHT
      1  528c					      SUBROUTINE
      2  528c		       bc 0c f0 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      3  528f		       30 0c		      bmi	.invalid
      4  5291		       b9 79 f0 	      lda	Board,y
      5  5294		       f0 04		      beq	.squareEmpty
      6  5296		       45 92		      eor	currentPiece
      7  5298		       10 03		      bpl	.invalid
      8  529a		       20 a5 fb    .squareEmpty jsr	AddMove
      9  529d				   .invalid
      0  529d					      MOVE_TO_X	_RIGHT
      1  529d		       a6 93		      ldx	currentSquare
      0  529f					      MOVE_TO	_RIGHT
      1  529f					      SUBROUTINE
      2  529f		       bc 16 f0 	      ldy	ValidSquare+_RIGHT,x
      3  52a2		       30 0c		      bmi	.invalid
      4  52a4		       b9 79 f0 	      lda	Board,y
      5  52a7		       f0 04		      beq	.squareEmpty
      6  52a9		       45 92		      eor	currentPiece
      7  52ab		       10 03		      bpl	.invalid
      8  52ad		       20 a5 fb    .squareEmpty jsr	AddMove
      9  52b0				   .invalid
      0  52b0					      MOVE_TO_X	_UP+_RIGHT
      1  52b0		       a6 93		      ldx	currentSquare
      0  52b2					      MOVE_TO	_UP+_RIGHT
      1  52b2					      SUBROUTINE
      2  52b2		       bc 20 f0 	      ldy	ValidSquare+_UP+_RIGHT,x
      3  52b5		       30 0c		      bmi	.invalid
      4  52b7		       b9 79 f0 	      lda	Board,y
      5  52ba		       f0 04		      beq	.squareEmpty
      6  52bc		       45 92		      eor	currentPiece
      7  52be		       10 03		      bpl	.invalid
      8  52c0		       20 a5 fb    .squareEmpty jsr	AddMove
      9  52c3				   .invalid
      0  52c3					      MOVE_TO_X	_UP
      1  52c3		       a6 93		      ldx	currentSquare
      0  52c5					      MOVE_TO	_UP
      1  52c5					      SUBROUTINE
      2  52c5		       bc 1f f0 	      ldy	ValidSquare+_UP,x
      3  52c8		       30 0c		      bmi	.invalid
      4  52ca		       b9 79 f0 	      lda	Board,y
      5  52cd		       f0 04		      beq	.squareEmpty
      6  52cf		       45 92		      eor	currentPiece
      7  52d1		       10 03		      bpl	.invalid
      8  52d3		       20 a5 fb    .squareEmpty jsr	AddMove
      9  52d6				   .invalid
      0  52d6					      MOVE_TO_X	_UP+_LEFT
      1  52d6		       a6 93		      ldx	currentSquare
      0  52d8					      MOVE_TO	_UP+_LEFT
      1  52d8					      SUBROUTINE
      2  52d8		       bc 1e f0 	      ldy	ValidSquare+_UP+_LEFT,x
      3  52db		       30 0c		      bmi	.invalid
      4  52dd		       b9 79 f0 	      lda	Board,y
      5  52e0		       f0 04		      beq	.squareEmpty
      6  52e2		       45 92		      eor	currentPiece
      7  52e4		       10 03		      bpl	.invalid
      8  52e6		       20 a5 fb    .squareEmpty jsr	AddMove
      9  52e9				   .invalid
      0  52e9					      MOVE_TO_X	_LEFT
      1  52e9		       a6 93		      ldx	currentSquare
      0  52eb					      MOVE_TO	_LEFT
      1  52eb					      SUBROUTINE
      2  52eb		       bc 14 f0 	      ldy	ValidSquare+_LEFT,x
      3  52ee		       30 0c		      bmi	.invalid
      4  52f0		       b9 79 f0 	      lda	Board,y
      5  52f3		       f0 04		      beq	.squareEmpty
      6  52f5		       45 92		      eor	currentPiece
      7  52f7		       10 03		      bpl	.invalid
      8  52f9		       20 a5 fb    .squareEmpty jsr	AddMove
      9  52fc				   .invalid
     86  52fc
     87  52fc							;IF CASTLING_ENABLED
     88  52fc
     89  52fc		       24 92		      bit	currentPiece
     90  52fe		       70 41		      bvs	.exit	; king has moved, so no castling
     91  5300
      0  5300					      CASTLE	KINGSIDE
      1  5300
      2  5300
      3  5300		       a6 93		      ldx	currentSquare
      4  5302		       bd 7c f0 	      lda	Board+KINGSIDE,x
      5  5305		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  5307		       c9 05		      cmp	#ROOK
      7  5309		       d0 14		      bne	.noCastle
      8  530b
      9  530b
     10  530b
     11  530b
     12  530b				  -	      IF	KINGSIDE = QUEENSIDE
     13  530b				  -	      lda	Board-3,x
     14  530b				  -	      ora	Board-2,x
     15  530b				  -	      ora	Board-1,x
     16  530b				  -	      bne	.noCastle
     17  530b				  -
     18  530b					      ENDIF
     19  530b
     20  530b					      IF	KINGSIDE = KINGSIDE
     21  530b		       bd 7b f0 	      lda	Board+2,x
     22  530e		       1d 7a f0 	      ora	Board+1,x
     23  5311		       d0 0c		      bne	.noCastle
     24  5313					      ENDIF
     25  5313
     26  5313
     27  5313
     28  5313
     29  5313
     30  5313
     31  5313
     32  5313
     33  5313		       a5 92		      lda	currentPiece
     34  5315		       09 10		      ora	#FLAG_CASTLE
     35  5317		       85 92		      sta	currentPiece
     36  5319
     37  5319					      IF	KINGSIDE = KINGSIDE
     38  5319		       bc 17 f0 	      ldy	ValidSquare+2,x
     39  531c					      ENDIF
     40  531c
     41  531c				  -	      IF	KINGSIDE = QUEENSIDE
     42  531c				  -	      ldy	ValidSquare-2,x
     43  531c					      ENDIF
     44  531c
     45  531c		       20 a5 fb 	      jsr	AddMove
     46  531f
     47  531f				   .noCastle
      0  531f					      CASTLE	QUEENSIDE
      1  531f
      2  531f
      3  531f		       a6 93		      ldx	currentSquare
      4  5321		       bd 75 f0 	      lda	Board+QUEENSIDE,x
      5  5324		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  5326		       c9 05		      cmp	#ROOK
      7  5328		       d0 17		      bne	.noCastle
      8  532a
      9  532a
     10  532a
     11  532a
     12  532a					      IF	QUEENSIDE = QUEENSIDE
     13  532a		       bd 76 f0 	      lda	Board-3,x
     14  532d		       1d 77 f0 	      ora	Board-2,x
     15  5330		       1d 78 f0 	      ora	Board-1,x
     16  5333		       d0 0c		      bne	.noCastle
     17  5335
     18  5335					      ENDIF
     19  5335
     20  5335				  -	      IF	QUEENSIDE = KINGSIDE
     21  5335				  -	      lda	Board+2,x
     22  5335				  -	      ora	Board+1,x
     23  5335				  -	      bne	.noCastle
     24  5335					      ENDIF
     25  5335
     26  5335
     27  5335
     28  5335
     29  5335
     30  5335
     31  5335
     32  5335
     33  5335		       a5 92		      lda	currentPiece
     34  5337		       09 10		      ora	#FLAG_CASTLE
     35  5339		       85 92		      sta	currentPiece
     36  533b
     37  533b				  -	      IF	QUEENSIDE = KINGSIDE
     38  533b				  -	      ldy	ValidSquare+2,x
     39  533b					      ENDIF
     40  533b
     41  533b					      IF	QUEENSIDE = QUEENSIDE
     42  533b		       bc 13 f0 	      ldy	ValidSquare-2,x
     43  533e					      ENDIF
     44  533e
     45  533e		       20 a5 fb 	      jsr	AddMove
     46  5341
     47  5341				   .noCastle
     94  5341
     95  5341							;ENDIF
     96  5341
     97  5341		       4c 33 f9    .exit      jmp	MoveReturn
     98  5344
     99  5344							;---------------------------------------------------------------------------------------------------
    100  5344							; EOF
------- FILE Handler_BANK1.asm
------- FILE Handler_KNIGHT.asm LEVEL 3 PASS 5
      0  5344					      include	"Handler_KNIGHT.asm"
      1  5344							; Copyright (C)2020 Andrew Davie
      2  5344							; Knight move handler
      3  5344
      4  5344							;---------------------------------------------------------------------------------------------------
      5  5344							; KNIGHT
      6  5344							;---------------------------------------------------------------------------------------------------
      7  5344
      0  5344					      DEF	Handle_KNIGHT
      1  5344				   BANK_Handle_KNIGHT SET	_CURRENT_BANK
      2  5344				   Handle_KNIGHT
      3  5344				   TEMPORARY_VAR SET	Overlay
      4  5344				   TEMPORARY_OFFSET SET	0
      5  5344				   VAR_BOUNDARY_Handle_KNIGHT SET	TEMPORARY_OFFSET
      6  5344				   FUNCTION_NAME SET	Handle_KNIGHT
      7  5344					      SUBROUTINE
      9  5344					      SUBROUTINE
     10  5344
      0  5344					      REFER	GenerateAllMoves
      1  5344					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5344				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5344					      ENDIF
      0  5344					      VEND	Handle_KNIGHT
      1  5344				  -	      IFNCONST	Handle_KNIGHT
      2  5344				  -	      ECHO	"Incorrect VEND label", Handle_KNIGHT
      3  5344				  -	      ERR
      4  5344					      ENDIF
      5  5344		       00 ab	   VAREND_Handle_KNIGHT =	TEMPORARY_VAR
     13  5344
     14  5344							; x = currentSquare (square the piece is on)
     15  5344							; currentPiece (with flags/colour attached)
     16  5344
      0  5344					      MOVE_TO	_DOWN+_DOWN+_LEFT
      1  5344					      SUBROUTINE
      2  5344		       bc 00 f0 	      ldy	ValidSquare+_DOWN+_DOWN+_LEFT,x
      3  5347		       30 0c		      bmi	.invalid
      4  5349		       b9 79 f0 	      lda	Board,y
      5  534c		       f0 04		      beq	.squareEmpty
      6  534e		       45 92		      eor	currentPiece
      7  5350		       10 03		      bpl	.invalid
      8  5352		       20 a5 fb    .squareEmpty jsr	AddMove
      9  5355				   .invalid
      0  5355					      MOVE_TO_X	_DOWN+_DOWN+_RIGHT
      1  5355		       a6 93		      ldx	currentSquare
      0  5357					      MOVE_TO	_DOWN+_DOWN+_RIGHT
      1  5357					      SUBROUTINE
      2  5357		       bc 02 f0 	      ldy	ValidSquare+_DOWN+_DOWN+_RIGHT,x
      3  535a		       30 0c		      bmi	.invalid
      4  535c		       b9 79 f0 	      lda	Board,y
      5  535f		       f0 04		      beq	.squareEmpty
      6  5361		       45 92		      eor	currentPiece
      7  5363		       10 03		      bpl	.invalid
      8  5365		       20 a5 fb    .squareEmpty jsr	AddMove
      9  5368				   .invalid
      0  5368					      MOVE_TO_X	_UP+_UP+_LEFT
      1  5368		       a6 93		      ldx	currentSquare
      0  536a					      MOVE_TO	_UP+_UP+_LEFT
      1  536a					      SUBROUTINE
      2  536a		       bc 28 f0 	      ldy	ValidSquare+_UP+_UP+_LEFT,x
      3  536d		       30 0c		      bmi	.invalid
      4  536f		       b9 79 f0 	      lda	Board,y
      5  5372		       f0 04		      beq	.squareEmpty
      6  5374		       45 92		      eor	currentPiece
      7  5376		       10 03		      bpl	.invalid
      8  5378		       20 a5 fb    .squareEmpty jsr	AddMove
      9  537b				   .invalid
      0  537b					      MOVE_TO_X	_UP+_UP+_RIGHT
      1  537b		       a6 93		      ldx	currentSquare
      0  537d					      MOVE_TO	_UP+_UP+_RIGHT
      1  537d					      SUBROUTINE
      2  537d		       bc 2a f0 	      ldy	ValidSquare+_UP+_UP+_RIGHT,x
      3  5380		       30 0c		      bmi	.invalid
      4  5382		       b9 79 f0 	      lda	Board,y
      5  5385		       f0 04		      beq	.squareEmpty
      6  5387		       45 92		      eor	currentPiece
      7  5389		       10 03		      bpl	.invalid
      8  538b		       20 a5 fb    .squareEmpty jsr	AddMove
      9  538e				   .invalid
     21  538e
      0  538e					      MOVE_TO_X	_DOWN+_LEFT+_LEFT
      1  538e		       a6 93		      ldx	currentSquare
      0  5390					      MOVE_TO	_DOWN+_LEFT+_LEFT
      1  5390					      SUBROUTINE
      2  5390		       bc 09 f0 	      ldy	ValidSquare+_DOWN+_LEFT+_LEFT,x
      3  5393		       30 0c		      bmi	.invalid
      4  5395		       b9 79 f0 	      lda	Board,y
      5  5398		       f0 04		      beq	.squareEmpty
      6  539a		       45 92		      eor	currentPiece
      7  539c		       10 03		      bpl	.invalid
      8  539e		       20 a5 fb    .squareEmpty jsr	AddMove
      9  53a1				   .invalid
      0  53a1					      MOVE_TO_X	_DOWN+_RIGHT+_RIGHT
      1  53a1		       a6 93		      ldx	currentSquare
      0  53a3					      MOVE_TO	_DOWN+_RIGHT+_RIGHT
      1  53a3					      SUBROUTINE
      2  53a3		       bc 0d f0 	      ldy	ValidSquare+_DOWN+_RIGHT+_RIGHT,x
      3  53a6		       30 0c		      bmi	.invalid
      4  53a8		       b9 79 f0 	      lda	Board,y
      5  53ab		       f0 04		      beq	.squareEmpty
      6  53ad		       45 92		      eor	currentPiece
      7  53af		       10 03		      bpl	.invalid
      8  53b1		       20 a5 fb    .squareEmpty jsr	AddMove
      9  53b4				   .invalid
      0  53b4					      MOVE_TO_X	_UP+_LEFT+_LEFT
      1  53b4		       a6 93		      ldx	currentSquare
      0  53b6					      MOVE_TO	_UP+_LEFT+_LEFT
      1  53b6					      SUBROUTINE
      2  53b6		       bc 1d f0 	      ldy	ValidSquare+_UP+_LEFT+_LEFT,x
      3  53b9		       30 0c		      bmi	.invalid
      4  53bb		       b9 79 f0 	      lda	Board,y
      5  53be		       f0 04		      beq	.squareEmpty
      6  53c0		       45 92		      eor	currentPiece
      7  53c2		       10 03		      bpl	.invalid
      8  53c4		       20 a5 fb    .squareEmpty jsr	AddMove
      9  53c7				   .invalid
      0  53c7					      MOVE_TO_X	_UP+_RIGHT+_RIGHT
      1  53c7		       a6 93		      ldx	currentSquare
      0  53c9					      MOVE_TO	_UP+_RIGHT+_RIGHT
      1  53c9					      SUBROUTINE
      2  53c9		       bc 21 f0 	      ldy	ValidSquare+_UP+_RIGHT+_RIGHT,x
      3  53cc		       30 0c		      bmi	.invalid
      4  53ce		       b9 79 f0 	      lda	Board,y
      5  53d1		       f0 04		      beq	.squareEmpty
      6  53d3		       45 92		      eor	currentPiece
      7  53d5		       10 03		      bpl	.invalid
      8  53d7		       20 a5 fb    .squareEmpty jsr	AddMove
      9  53da				   .invalid
     26  53da
     27  53da		       4c 33 f9 	      jmp	MoveReturn
     28  53dd
     29  53dd							; EOF
------- FILE Handler_BANK1.asm
    103  53dd
    104  53dd
    105  53dd							;---------------------------------------------------------------------------------------------------
    106  53dd
      0  53dd					      CHECK_HALF_BANK_SIZE	"HANDLER_BANK1 -- 1K"
      1  53dd
      2  53dd
      3  53dd		       03 dd	   .TEMP      =	* - BANK_START
 HANDLER_BANK1 -- 1K (1K) SIZE =  $3dd , FREE= $23
      4  53dd					      ECHO	"HANDLER_BANK1 -- 1K", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  53dd				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  53dd				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  53dd				  -	      ERR
      8  53dd					      endif
    108  53dd
    109  53dd
    110  53dd							; There is space here (1K) for use as ROM
    111  53dd							; but NOT when the above bank is switched in as RAM, of course!
    112  53dd
    113  53dd
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  53dd					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  53dd					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_0", 72
     12  5400					      LIST	ON
      0  5400					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_0
      1  5400				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  5400				   WHITE_PROMOTE_on_BLACK_SQUARE_0
      3  5400				   TEMPORARY_VAR SET	Overlay
      4  5400				   TEMPORARY_OFFSET SET	0
      5  5400				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  5400				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_0
      7  5400					      SUBROUTINE
      3  5400		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  5418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  5448					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  5448					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_1", 72
     12  5448					      LIST	ON
      0  5448					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_1
      1  5448				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  5448				   WHITE_PROMOTE_on_BLACK_SQUARE_1
      3  5448				   TEMPORARY_VAR SET	Overlay
      4  5448				   TEMPORARY_OFFSET SET	0
      5  5448				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  5448				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_1
      7  5448					      SUBROUTINE
      3  5448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5460		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  5478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  5490					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  5490					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_2", 72
     12  5490					      LIST	ON
      0  5490					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_2
      1  5490				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  5490				   WHITE_PROMOTE_on_BLACK_SQUARE_2
      3  5490				   TEMPORARY_VAR SET	Overlay
      4  5490				   TEMPORARY_OFFSET SET	0
      5  5490				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  5490				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_2
      7  5490					      SUBROUTINE
      3  5490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  54a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  54c0		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  54d8					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  54d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_3", 72
     12  5500					      LIST	ON
      0  5500					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_3
      1  5500				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  5500				   WHITE_PROMOTE_on_BLACK_SQUARE_3
      3  5500				   TEMPORARY_VAR SET	Overlay
      4  5500				   TEMPORARY_OFFSET SET	0
      5  5500				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  5500				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_3
      7  5500					      SUBROUTINE
      3  5500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5530		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 5
      0  5548					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  5548					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_0", 72
     12  5548					      LIST	ON
      0  5548					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_0
      1  5548				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  5548				   WHITE_PROMOTE_on_WHITE_SQUARE_0
      3  5548				   TEMPORARY_VAR SET	Overlay
      4  5548				   TEMPORARY_OFFSET SET	0
      5  5548				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  5548				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_0
      7  5548					      SUBROUTINE
      3  5548		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 5
      0  5590					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  5590					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_1", 72
     12  5590					      LIST	ON
      0  5590					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_1
      1  5590				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  5590				   WHITE_PROMOTE_on_WHITE_SQUARE_1
      3  5590				   TEMPORARY_VAR SET	Overlay
      4  5590				   TEMPORARY_OFFSET SET	0
      5  5590				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  5590				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_1
      7  5590					      SUBROUTINE
      3  5590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  55a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  55c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 5
      0  55d8					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  55d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_2", 72
     12  5600					      LIST	ON
      0  5600					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_2
      1  5600				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  5600				   WHITE_PROMOTE_on_WHITE_SQUARE_2
      3  5600				   TEMPORARY_VAR SET	Overlay
      4  5600				   TEMPORARY_OFFSET SET	0
      5  5600				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  5600				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_2
      7  5600					      SUBROUTINE
      3  5600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5630		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 5
      0  5648					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  5648					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_3", 72
     12  5648					      LIST	ON
      0  5648					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_3
      1  5648				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  5648				   WHITE_PROMOTE_on_WHITE_SQUARE_3
      3  5648				   TEMPORARY_VAR SET	Overlay
      4  5648				   TEMPORARY_OFFSET SET	0
      5  5648				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  5648				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_3
      7  5648					      SUBROUTINE
      3  5648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5678		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
    122  5690
    123  5690							;---------------------------------------------------------------------------------------------------
    124  5690
      0  5690					      CHECK_BANK_SIZE	"HANDLER_BANK_1 -- full 2K"
      1  5690		       06 90	   .TEMP      =	* - BANK_START
 HANDLER_BANK_1 -- full 2K (2K) SIZE =  $690 , FREE= $170
      2  5690					      ECHO	"HANDLER_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  5690				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  5690				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  5690				  -	      ERR
      6  5690					      endif
    126  5690
    127  5690							;---------------------------------------------------------------------------------------------------
    128  5690							; EOF
------- FILE ./chess.asm
------- FILE ply.asm LEVEL 2 PASS 5
      0  5690					      include	"ply.asm"
      1  5690							; Copyright (C)2020 Andrew Davie
      2  5690							; andrew@taswegian.com
      3  5690
      4  5690
      5  5690							;---------------------------------------------------------------------------------------------------
      6  5690							; Define the RAM banks
      7  5690							; A "PLY" bank represents all the data required on any single ply of the search tree.
      8  5690							; The banks are organised sequentially, MAX_PLY of them starting at RAMBANK_PLY
      9  5690							; The startup code copies the ROM shadow into each of these PLY banks, and from then on
     10  5690							; they act as independant switchable banks usable for data on each ply during the search.
     11  5690							; A ply will hold the move list for that position
     12  5690
     13  5690
     14  5690		       00 0a	   MAX_PLY    =	10
      0  5690					      NEWRAMBANK	PLY	; RAM bank for holding the following ROM shadow
      1  5690
      2  5690
      3  5690
      4 U2400 ????				      SEG.U	PLY
      5 U2400					      ORG	ORIGIN_RAM
      6 U2400					      RORG	RAM_3E
      7 U2400				   BANK_START SET	*
      8 U2400				   RAMBANK_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U2400				   _CURRENT_RAMBANK SET	RAMBANK_PLY
     10 U2400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     16 U2400					      REPEAT	MAX_PLY-1
      0 U2400					      NEWRAMBANK	.DUMMY_PLY
      1 U2400
      2 U2400
      3 U2400
      4 U4800 ????				      SEG.U	.DUMMY_PLY
      5 U2800					      ORG	ORIGIN_RAM
      6 U2800					      RORG	RAM_3E
      7 U2800				   BANK_START SET	*
      8 U2800				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U2800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     16 U2800					      REPEND
      0 U2800					      NEWRAMBANK	.DUMMY_PLY
      1 U2800
      2 U2800
      3 U2800
      4 U2800					      SEG.U	.DUMMY_PLY
      5 U2c00					      ORG	ORIGIN_RAM
      6 U2c00					      RORG	RAM_3E
      7 U2c00				   BANK_START SET	*
      8 U2c00				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U2c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     16 U2c00					      REPEND
      0 U2c00					      NEWRAMBANK	.DUMMY_PLY
      1 U2c00
      2 U2c00
      3 U2c00
      4 U2c00					      SEG.U	.DUMMY_PLY
      5 U3000					      ORG	ORIGIN_RAM
      6 U3000					      RORG	RAM_3E
      7 U3000				   BANK_START SET	*
      8 U3000				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U3000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     16 U3000					      REPEND
      0 U3000					      NEWRAMBANK	.DUMMY_PLY
      1 U3000
      2 U3000
      3 U3000
      4 U3000					      SEG.U	.DUMMY_PLY
      5 U3400					      ORG	ORIGIN_RAM
      6 U3400					      RORG	RAM_3E
      7 U3400				   BANK_START SET	*
      8 U3400				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U3400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     16 U3400					      REPEND
      0 U3400					      NEWRAMBANK	.DUMMY_PLY
      1 U3400
      2 U3400
      3 U3400
      4 U3400					      SEG.U	.DUMMY_PLY
      5 U3800					      ORG	ORIGIN_RAM
      6 U3800					      RORG	RAM_3E
      7 U3800				   BANK_START SET	*
      8 U3800				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U3800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     16 U3800					      REPEND
      0 U3800					      NEWRAMBANK	.DUMMY_PLY
      1 U3800
      2 U3800
      3 U3800
      4 U3800					      SEG.U	.DUMMY_PLY
      5 U3c00					      ORG	ORIGIN_RAM
      6 U3c00					      RORG	RAM_3E
      7 U3c00				   BANK_START SET	*
      8 U3c00				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U3c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     16 U3c00					      REPEND
      0 U3c00					      NEWRAMBANK	.DUMMY_PLY
      1 U3c00
      2 U3c00
      3 U3c00
      4 U3c00					      SEG.U	.DUMMY_PLY
      5 U4000					      ORG	ORIGIN_RAM
      6 U4000					      RORG	RAM_3E
      7 U4000				   BANK_START SET	*
      8 U4000				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U4000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U4000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     16 U4000					      REPEND
      0 U4000					      NEWRAMBANK	.DUMMY_PLY
      1 U4000
      2 U4000
      3 U4000
      4 U4000					      SEG.U	.DUMMY_PLY
      5 U4400					      ORG	ORIGIN_RAM
      6 U4400					      RORG	RAM_3E
      7 U4400				   BANK_START SET	*
      8 U4400				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U4400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U4400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     16 U4400					      REPEND
      0 U4400					      NEWRAMBANK	.DUMMY_PLY
      1 U4400
      2 U4400
      3 U4400
      4 U4400					      SEG.U	.DUMMY_PLY
      5 U4800					      ORG	ORIGIN_RAM
      6 U4800					      RORG	RAM_3E
      7 U4800				   BANK_START SET	*
      8 U4800				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U4800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U4800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     18 U4800					      REPEND
     19 U4800
     20 U4800		       00 13	   MAX_PLY_DEPTH_BANK =	MAX_PLY + RAMBANK_PLY
     21 U4800
     22 U4800							;---------------------------------------------------------------------------------------------------
     23 U4800							; and now the ROM shadow - this is copied to ALL of the RAM ply banks
     24 U4800
      0 U4800					      NEWBANK	BANK_PLY	; ROM SHADOW
      1  5bc1 ????				      SEG	BANK_PLY
      2  5800					      ORG	ORIGIN
      3  5800					      RORG	$F000
      4  5800				   BANK_START SET	*
      5  5800				   BANK_PLY   SET	ORIGIN / 2048
      6  5800				   ORIGIN     SET	ORIGIN + 2048
      7  5800				   _CURRENT_BANK SET	BANK_PLY
     26  5800
     27  5800							;---------------------------------------------------------------------------------------------------
     28  5800							; The piece-lists
     29  5800							; ONLY the very first bank piecelist is used - all other banks switch to the first for
     30  5800							; piecelist usage. Note that this initialisation (below) comes from the shadow ROM/RAM copy
     31  5800							; but this needs to be initialised programatically on new game.
     32  5800
     33  5800							; We have TWO piecelists, in different banks
     34  5800							; WHITE pieces in bank BANK_PLY
     35  5800							; BLACK pieces in bank BANK_PLY+1
     36  5800
      0  5800					      VARIABLE	plyValue, 2	; 16-bit signed score value from alphabeta
      0  5800					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  5800					      LIST	ON
      2  5800		       00 00	   plyValue   ds	2
      0  5802					      VARIABLE	SavedEvaluation, 2	; THIS node's evaluation - used for reverting moves!
      0  5802					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  5802					      LIST	ON
      2  5802		       00 00	   SavedEvaluation ds	2
     39  5804
     40  5804
     41  5804							;---------------------------------------------------------------------------------------------------
     42  5804
     43  5804		       00 46	   MAX_MOVES  =	70
     44  5804
      0  5804					      VARIABLE	MoveFrom, MAX_MOVES
      0  5804					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  5804					      LIST	ON
      2  5804		       00 00 00 00*MoveFrom   ds	MAX_MOVES
      0  584a					      VARIABLE	MoveTo, MAX_MOVES
      0  584a					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  584a					      LIST	ON
      2  584a		       00 00 00 00*MoveTo     ds	MAX_MOVES
      0  5890					      VARIABLE	MovePiece, MAX_MOVES
      0  5890					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  5890					      LIST	ON
      2  5890		       00 00 00 00*MovePiece  ds	MAX_MOVES
     48  58d6
      0  58d6					      VARIABLE	MoveScoreLO, MAX_MOVES
      0  58d6					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  5900					      LIST	ON
      2  5900		       00 00 00 00*MoveScoreLO ds	MAX_MOVES
      0  5946					      VARIABLE	MoveScoreHI, MAX_MOVES
      0  5946					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  5946					      LIST	ON
      2  5946		       00 00 00 00*MoveScoreHI ds	MAX_MOVES
      0  598c					      VARIABLE	SortedMove, MAX_MOVES
      0  598c					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  598c					      LIST	ON
      2  598c		       00 00 00 00*SortedMove ds	MAX_MOVES
     52  59d2
     53  59d2							;---------------------------------------------------------------------------------------------------
     54  59d2
     55  59d2							; The X12 square at which a pawn CAN be taken en-passant. Normally 0.
     56  59d2							; This is set/cleared whenever a move is made. The flag is indicated in the move description.
     57  59d2
      0  59d2					      VARIABLE	enPassantSquare, 1
      0  59d2					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  59d2					      LIST	ON
      2  59d2		       00	   enPassantSquare ds	1
      0  59d3					      VARIABLE	capturedPiece, 1
      0  59d3					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  59d3					      LIST	ON
      2  59d3		       00	   capturedPiece ds	1
      0  59d4					      VARIABLE	secondaryPiece, 1	; original piece on secondary (castle, enpassant)
      0  59d4					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  59d4					      LIST	ON
      2  59d4		       00	   secondaryPiece ds	1
      0  59d5					      VARIABLE	secondarySquare, 1	; original square of secondary piece
      0  59d5					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  59d5					      LIST	ON
      2  59d5		       00	   secondarySquare ds	1
      0  59d6					      VARIABLE	secondaryBlank, 1	; square to blank on secondary
      0  59d6					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  59d6					      LIST	ON
      2  59d6		       00	   secondaryBlank ds	1
     63  59d7
     64  59d7							;---------------------------------------------------------------------------------------------------
     65  59d7							; Move tables hold piece moves for this current ply
     66  59d7
      0  59d7					      VARIABLE	moveIndex, 1	; points to first available 'slot' for move storage
      0  59d7					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  59d7					      LIST	ON
      2  59d7		       00	   moveIndex  ds	1
      0  59d8					      VARIABLE	movePtr, 1
      0  59d8					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  59d8					      LIST	ON
      2  59d8		       00	   movePtr    ds	1
      0  59d9					      VARIABLE	bestMove, 1
      0  59d9					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  59d9					      LIST	ON
      2  59d9		       00	   bestMove   ds	1
      0  59da					      VARIABLE	alpha, 2
      0  59da					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  59da					      LIST	ON
      2  59da		       00 00	   alpha      ds	2
      0  59dc					      VARIABLE	beta, 2
      0  59dc					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  59dc					      LIST	ON
      2  59dc		       00 00	   beta       ds	2
     72  59de							;    VARIABLE bestValue, 2
      0  59de					      VARIABLE	depthLeft, 1
      0  59de					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  59de					      LIST	ON
      2  59de		       00	   depthLeft  ds	1
      0  59df					      VARIABLE	bestScore, 2
      0  59df					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  59df					      LIST	ON
      2  59df		       00 00	   bestScore  ds	2
     75  59e1
     76  59e1							;---------------------------------------------------------------------------------------------------
     77  59e1
     78  59e1
     79  59e1				  -	      if	0
     80  59e1				  -			; reverting a move
     81  59e1				  -			; from/to/piece/toOriginal
     82  59e1				  -			; castling   affects 4 squares (2xfrom/to each with original piece)
     83  59e1				  -			; en-passant
     84  59e1				  -
     85  59e1				  -from/to/piece
     86  59e1				  -
     87  59e1				  -
     88  59e1				  -from       =	piece
     89  59e1				  -to	      =	originalPiece
     90  59e1				  -from2      =	piece2
     91  59e1				  -to2	      =	originalPiece2
     92  59e1				  -
     93  59e1				  -
     94  59e1				  -
     95  59e1				  -so,	      normal	move (N)
     96  59e1				  -
     97  59e1				  -B1	      =	knight
     98  59e1				  -C3	      =	blank
     99  59e1				  -null/null
    100  59e1				  -
    101  59e1				  -pawn       promot	with capture
    102  59e1				  -A7	      =	WP
    103  59e1				  -B8	      =	BLACK_ROOK
    104  59e1				  -
    105  59e1				  -
    106  59e1				  -castle
    107  59e1				  -E1	      =	king
    108  59e1				  -G1	      =	blank
    109  59e1				  -H1	      =	rook
    110  59e1				  -F1	      =	blank
    111  59e1				  -
    112  59e1				  -
    113  59e1				  -en-passant
    114  59e1				  -B4	      =	P
    115  59e1				  -A3	      =	blank
    116  59e1				  -A4	      =	P
    117  59e1				  -A3	      =	blank
    118  59e1				  -
    119  59e1				  -FROM
    120  59e1				  -TO
    121  59e1				  -CAPTURED_PIECE
    122  59e1				  -ORIG_PIECE
    123  59e1				  -FROM2
    124  59e1				  -TO2
    125  59e1				  -PIECE2
    126  59e1				  -
    127  59e1				  -board[FROM] =	ORIG_PIECE
    128  59e1				  -board[TO]  =	CAPTURED_PIECE
    129  59e1				  -
    130  59e1				  -value      =	-new_piece + orig_piece - captured_piece
    131  59e1				  -
    132  59e1				  -
    133  59e1					      endif
    134  59e1
    135  59e1
    136  59e1
    137  59e1							;---------------------------------------------------------------------------------------------------
    138  59e1
      0  59e1					      DEF	InitPieceLists
      1  59e1				   BANK_InitPieceLists SET	_CURRENT_BANK
      2  59e1				   InitPieceLists
      3  59e1				   TEMPORARY_VAR SET	Overlay
      4  59e1				   TEMPORARY_OFFSET SET	0
      5  59e1				   VAR_BOUNDARY_InitPieceLists SET	TEMPORARY_OFFSET
      6  59e1				   FUNCTION_NAME SET	InitPieceLists
      7  59e1					      SUBROUTINE
    140  59e1					      SUBROUTINE
    141  59e1
      0  59e1					      REFER	InitialisePieceSquares
      1  59e1					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  59e1				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  59e1					      ENDIF
      0  59e1					      VEND	InitPieceLists
      1  59e1				  -	      IFNCONST	InitPieceLists
      2  59e1				  -	      ECHO	"Incorrect VEND label", InitPieceLists
      3  59e1				  -	      ERR
      4  59e1					      ENDIF
      5  59e1		       00 a5	   VAREND_InitPieceLists =	TEMPORARY_VAR
    144  59e1
    145  59e1		       a9 ff		      lda	#-1
    146  59e3							;sta@RAM SquarePtr ;PieceListPtr
    147  59e3
    148  59e3							; TODO: move the following as they're called 2x due to double-call of InitPiecLists
    149  59e3
    150  59e3		       85 90		      sta	Evaluation
    151  59e5		       85 91		      sta	Evaluation+1	; tracks CURRENT value of everything (signed 16-bit)
    152  59e7
    153  59e7
    154  59e7							; General inits that are moved out of FIXED....
    155  59e7
    156  59e7		       a9 07		      lda	#%111	; 111= quad
    157  59e9		       85 44		      sta	NUSIZ0
    158  59eb		       85 45		      sta	NUSIZ1	; quad-width
    159  59ed
    160  59ed		       a9 04		      lda	#%00000100
    161  59ef		       85 4a		      sta	CTRLPF
    162  59f1		       a9 00		      lda	#BACKGCOL
    163  59f3		       85 49		      sta	COLUBK
    164  59f5
      0  59f5					      PHASE	AI_StartClearBoard
      1  59f5		       a9 0d		      lda	#AI_StartClearBoard
      2  59f7		       85 8c		      sta	aiState
    166  59f9		       60		      rts
    167  59fa
    168  59fa
    169  59fa							;---------------------------------------------------------------------------------------------------
    170  59fa
    171  59fa				  -	      if	ASSERTS
    172  59fa				  -
    173  59fa				  -	      DEF	checkPiecesBank
    174  59fa				  -	      SUBROUTINE
    175  59fa				  -
    176  59fa				  -	      REFER	DIAGNOSTIC_checkPiences
    177  59fa				  -	      VAR	__x, 1
    178  59fa				  -	      VAR	__bank, 1
    179  59fa				  -	      VEND	checkPiecesBank
    180  59fa				  -
    181  59fa				  -			; odd usage - switches between concurrent bank code
    182  59fa				  -
    183  59fa				  -	      ldx	#15
    184  59fa				  -.check     lda	__bank
    185  59fa				  -	      sta	SET_BANK_RAM
    186  59fa				  -	      ldy	PieceSquare,x
    187  59fa				  -	      beq	.nonehere
    188  59fa				  -
    189  59fa				  -	      stx	__x
    190  59fa				  -
    191  59fa				  -	      jsr	GetBoard
    192  59fa				  -.fail      beq	.fail
    193  59fa				  -	      cmp	#-1
    194  59fa				  -.fail2     beq	.fail2
    195  59fa				  -
    196  59fa				  -	      ldx	__x
    197  59fa				  -
    198  59fa				  -.nonehere  dex
    199  59fa				  -	      bpl	.check
    200  59fa				  -	      rts
    201  59fa				  -
    202  59fa					      endif
    203  59fa
    204  59fa
    205  59fa							;---------------------------------------------------------------------------------------------------
    206  59fa
    207  59fa				  -	      if	ASSERTS
    208  59fa				  -
    209  59fa				  -	      DEF	DIAGNOSTIC_checkPieces
    210  59fa				  -	      SUBROUTINE
    211  59fa				  -
    212  59fa				  -	      REFER	aiSpecialMoveFixup
    213  59fa				  -	      VEND	DIAGNOSTIC_checkPiences
    214  59fa				  -
    215  59fa				  -			; SAFE call
    216  59fa				  -			; DIAGNOSTIC ONLY
    217  59fa				  -			; Scan the piecelist and the board square it points to and make sure non blank, non -1
    218  59fa				  -
    219  59fa				  -	      lda	#RAMBANK_PLY
    220  59fa				  -	      sta	__bank
    221  59fa				  -	      jsr	checkPiecesBank
    222  59fa				  -	      inc	__bank
    223  59fa				  -	      jsr	checkPiecesBank
    224  59fa				  -	      rts
    225  59fa				  -
    226  59fa					      endif
    227  59fa
    228  59fa
    229  59fa							;---------------------------------------------------------------------------------------------------
    230  59fa
    231  59fa				   InitPieceList
    232  59fa
------- FILE setup_board.asm LEVEL 3 PASS 5
      0  59fa					      include	"setup_board.asm"
      1  59fa					      if	!TEST_POSITION
      2  59fa
      3  59fa		       06 19		      .byte.b	WHITE|Q, 25
      4  59fc		       04 18		      .byte.b	WHITE|B, 24
      5  59fe		       04 1b		      .byte.b	WHITE|B, 27
      6  5a00		       05 16		      .byte.b	WHITE|R, 22
      7  5a02		       05 1d		      .byte.b	WHITE|R, 29
      8  5a04		       03 17		      .byte.b	WHITE|N, 23
      9  5a06		       03 1c		      .byte.b	WHITE|N, 28
     10  5a08
     11  5a08		       01 23		      .byte.b	WHITE|WP, 35
     12  5a0a		       01 24		      .byte.b	WHITE|WP, 36
     13  5a0c		       01 22		      .byte.b	WHITE|WP, 34
     14  5a0e		       01 25		      .byte.b	WHITE|WP, 37
     15  5a10		       01 21		      .byte.b	WHITE|WP, 33
     16  5a12		       01 26		      .byte.b	WHITE|WP, 38
     17  5a14		       01 20		      .byte.b	WHITE|WP, 32
     18  5a16		       01 27		      .byte.b	WHITE|WP, 39
     19  5a18
     20  5a18		       07 1a		      .byte.b	WHITE|K, 26
     21  5a1a
     22  5a1a		       86 5f		      .byte.b	BLACK|Q, 95
     23  5a1c		       84 5e		      .byte.b	BLACK|B, 94
     24  5a1e		       84 61		      .byte.b	BLACK|B, 97
     25  5a20		       85 5c		      .byte.b	BLACK|R, 92
     26  5a22		       85 63		      .byte.b	BLACK|R, 99
     27  5a24		       83 5d		      .byte.b	BLACK|N, 93
     28  5a26		       83 62		      .byte.b	BLACK|N, 98
     29  5a28
     30  5a28		       82 55		      .byte.b	BLACK|BP, 85
     31  5a2a		       82 56		      .byte.b	BLACK|BP, 86
     32  5a2c		       82 54		      .byte.b	BLACK|BP, 84
     33  5a2e		       82 57		      .byte.b	BLACK|BP, 87
     34  5a30		       82 53		      .byte.b	BLACK|BP, 83
     35  5a32		       82 58		      .byte.b	BLACK|BP, 88
     36  5a34		       82 52		      .byte.b	BLACK|BP, 82
     37  5a36		       82 59		      .byte.b	BLACK|BP, 89
     38  5a38
     39  5a38		       87 60		      .byte.b	BLACK|K, 96
     40  5a3a
     41  5a3a		       00		      .byte.b	0	;end
     42  5a3b
     43  5a3b				  -	      else		; test position...
     44  5a3b				  -
     45  5a3b				  -	      .byte	WHITE|WP, 57
     46  5a3b				  -	      .byte	WHITE|WP|FLAG_MOVED, 69
     47  5a3b				  -	      .byte	BLACK|BP, 88
     48  5a3b				  -	      .byte	BLACK|BP, 86
     49  5a3b				  -	      .byte	WHITE|Q, 65
     50  5a3b				  -
     51  5a3b				  -	      .byte	0	;end
     52  5a3b				  -
     53  5a3b					      endif
------- FILE ply.asm
    234  5a3b
    235  5a3b
    236  5a3b							;---------------------------------------------------------------------------------------------------
    237  5a3b
      0  5a3b					      DEF	NewPlyInitialise
      1  5a3b				   BANK_NewPlyInitialise SET	_CURRENT_BANK
      2  5a3b				   NewPlyInitialise
      3  5a3b				   TEMPORARY_VAR SET	Overlay
      4  5a3b				   TEMPORARY_OFFSET SET	0
      5  5a3b				   VAR_BOUNDARY_NewPlyInitialise SET	TEMPORARY_OFFSET
      6  5a3b				   FUNCTION_NAME SET	NewPlyInitialise
      7  5a3b					      SUBROUTINE
    239  5a3b					      SUBROUTINE
    240  5a3b
      0  5a3b					      REFER	aiFlipBuffers
      1  5a3b				  -	      IF	VAREND_aiFlipBuffers > TEMPORARY_VAR
      2  5a3b				  -TEMPORARY_VAR SET	VAREND_aiFlipBuffers
      3  5a3b					      ENDIF
      0  5a3b					      REFER	InitialiseMoveGeneration
      1  5a3b				  -	      IF	VAREND_InitialiseMoveGeneration > TEMPORARY_VAR
      2  5a3b				  -TEMPORARY_VAR SET	VAREND_InitialiseMoveGeneration
      3  5a3b					      ENDIF
      0  5a3b					      REFER	quiesce
      1  5a3b					      IF	VAREND_quiesce > TEMPORARY_VAR
      2  5a3b				   TEMPORARY_VAR SET	VAREND_quiesce
      3  5a3b					      ENDIF
      0  5a3b					      REFER	alphaBeta
      1  5a3b				  -	      IF	VAREND_alphaBeta > TEMPORARY_VAR
      2  5a3b				  -TEMPORARY_VAR SET	VAREND_alphaBeta
      3  5a3b					      ENDIF
      0  5a3b					      VEND	NewPlyInitialise
      1  5a3b				  -	      IFNCONST	NewPlyInitialise
      2  5a3b				  -	      ECHO	"Incorrect VEND label", NewPlyInitialise
      3  5a3b				  -	      ERR
      4  5a3b					      ENDIF
      5  5a3b		       00 a9	   VAREND_NewPlyInitialise =	TEMPORARY_VAR
    246  5a3b
    247  5a3b							; This MUST be called at the start of a new ply
    248  5a3b							; It initialises the movelist to empty
    249  5a3b							; x must be preserved
    250  5a3b
    251  5a3b							; note that 'alpha' and 'beta' are set externally!!
    252  5a3b
    253  5a3b
    254  5a3b		       a9 ff		      lda	#-1
      0  5a3d					      sta@RAM	moveIndex	; no valid moves
      1  5a3d		       8d d7 f5 	      sta	[RAM]+moveIndex
      0  5a40					      sta@RAM	bestMove
      1  5a40		       8d d9 f5 	      sta	[RAM]+bestMove
    257  5a43
    258  5a43		       a5 94		      lda	enPassantPawn	; flag/square from last actual move made
      0  5a45					      sta@RAM	enPassantSquare	; used for backtracking, to reset the flag
      1  5a45		       8d d2 f5 	      sta	[RAM]+enPassantSquare
    260  5a48
    261  5a48
    262  5a48							; The value of the material (signed, 16-bit) is restored to the saved value at the reversion
    263  5a48							; of a move. It's quicker to restore than to re-sum. So we save the current evaluation at the
    264  5a48							; start of each new ply.
    265  5a48
    266  5a48		       a5 90		      lda	Evaluation
      0  5a4a					      sta@RAM	SavedEvaluation
      1  5a4a		       8d 02 f4 	      sta	[RAM]+SavedEvaluation
    268  5a4d		       a5 91		      lda	Evaluation+1
      0  5a4f					      sta@RAM	SavedEvaluation+1
      1  5a4f		       8d 03 f4 	      sta	[RAM]+SavedEvaluation+1
    270  5a52
    271  5a52		       60		      rts
    272  5a53
    273  5a53
    274  5a53							;---------------------------------------------------------------------------------------------------
    275  5a53
    276  5a53					      if	1
      0  5a53					      DEF	MoveViaListAtPly
      1  5a53				   BANK_MoveViaListAtPly SET	_CURRENT_BANK
      2  5a53				   MoveViaListAtPly
      3  5a53				   TEMPORARY_VAR SET	Overlay
      4  5a53				   TEMPORARY_OFFSET SET	0
      5  5a53				   VAR_BOUNDARY_MoveViaListAtPly SET	TEMPORARY_OFFSET
      6  5a53				   FUNCTION_NAME SET	MoveViaListAtPly
      7  5a53					      SUBROUTINE
    278  5a53					      SUBROUTINE
    279  5a53
      0  5a53					      REFER	aiComputerMove
      1  5a53				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  5a53				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  5a53					      ENDIF
      0  5a53					      VEND	MoveViaListAtPly
      1  5a53				  -	      IFNCONST	MoveViaListAtPly
      2  5a53				  -	      ECHO	"Incorrect VEND label", MoveViaListAtPly
      3  5a53				  -	      ERR
      4  5a53					      ENDIF
      5  5a53		       00 a2	   VAREND_MoveViaListAtPly =	TEMPORARY_VAR
    282  5a53
    283  5a53		       ac d7 f1 	      ldy	moveIndex
    284  5a56		       30 27		      bmi	.exit	; no valid moves (stalemate if not in check)
    285  5a58
      0  5a58					      NEXT_RANDOM
      1  5a58		       a5 81		      lda	rnd
      2  5a5a		       4a		      lsr
      3  5a5b		       90 02		      bcc	.skipEOR
      4  5a5d		       49 fe		      eor	#RND_EOR_VAL
      5  5a5f		       85 81	   .skipEOR   sta	rnd
    287  5a61
    288  5a61							; int(random * # moves) --> a random move #
    289  5a61
    290  5a61		       a9 00		      lda	#0
    291  5a63		       aa		      tax		; selected move
    292  5a64		       18		      clc
    293  5a65		       65 81	   .mulxcc    adc	rnd
    294  5a67		       90 02		      bcc	.mulx
    295  5a69		       18		      clc
    296  5a6a		       e8		      inx
    297  5a6b		       88	   .mulx      dey
    298  5a6c		       10 f7		      bpl	.mulxcc
    299  5a6e
    300  5a6e		       bd 04 f0 	      lda	MoveFrom,x
    301  5a71		       85 85		      sta	fromX12
    302  5a73		       85 87		      sta	originX12
    303  5a75
    304  5a75		       bd 4a f0 	      lda	MoveTo,x
    305  5a78		       85 86		      sta	toX12
    306  5a7a
    307  5a7a		       bd 90 f0 	      lda	MovePiece,x
    308  5a7d		       85 98		      sta	fromPiece
    309  5a7f
    310  5a7f		       60	   .exit      rts
    311  5a80					      endif
    312  5a80
    313  5a80							;---------------------------------------------------------------------------------------------------
    314  5a80
      0  5a80					      DEF	CheckMoveListFromSquare
      1  5a80				   BANK_CheckMoveListFromSquare SET	_CURRENT_BANK
      2  5a80				   CheckMoveListFromSquare
      3  5a80				   TEMPORARY_VAR SET	Overlay
      4  5a80				   TEMPORARY_OFFSET SET	0
      5  5a80				   VAR_BOUNDARY_CheckMoveListFromSquare SET	TEMPORARY_OFFSET
      6  5a80				   FUNCTION_NAME SET	CheckMoveListFromSquare
      7  5a80					      SUBROUTINE
    316  5a80					      SUBROUTINE
    317  5a80
      0  5a80					      REFER	IsValidMoveFromSquare
      1  5a80				  -	      IF	VAREND_IsValidMoveFromSquare > TEMPORARY_VAR
      2  5a80				  -TEMPORARY_VAR SET	VAREND_IsValidMoveFromSquare
      3  5a80					      ENDIF
      0  5a80					      VEND	CheckMoveListFromSquare
      1  5a80				  -	      IFNCONST	CheckMoveListFromSquare
      2  5a80				  -	      ECHO	"Incorrect VEND label", CheckMoveListFromSquare
      3  5a80				  -	      ERR
      4  5a80					      ENDIF
      5  5a80		       00 a2	   VAREND_CheckMoveListFromSquare =	TEMPORARY_VAR
    320  5a80
    321  5a80							; X12 in A
    322  5a80							; y = -1 on return if NOT FOUND
    323  5a80
    324  5a80		       ac d7 f1 	      ldy	moveIndex
    325  5a83		       30 08		      bmi	.exit
    326  5a85
    327  5a85		       d9 04 f0    .scan      cmp	MoveFrom,y
    328  5a88		       f0 04		      beq	.scanned
    329  5a8a		       88		      dey
    330  5a8b		       10 f8		      bpl	.scan
    331  5a8d		       60	   .exit      rts
    332  5a8e
    333  5a8e		       b9 90 f0    .scanned   lda	MovePiece,y
    334  5a91		       85 98		      sta	fromPiece
    335  5a93		       60		      rts
    336  5a94
    337  5a94
    338  5a94							;---------------------------------------------------------------------------------------------------
    339  5a94
    340  5a94				  -	      if	0
    341  5a94				  -	      DEF	IsSquareUnderAttack
    342  5a94				  -	      SUBROUTINE
    343  5a94				  -
    344  5a94				  -	      REFER	Go_IsSquareUnderAttack
    345  5a94				  -	      REFER	aiLookForCheck
    346  5a94				  -	      VEND	IsSquareUnderAttack
    347  5a94				  -
    348  5a94				  -			; Scan the movelist to find if given square is under attack
    349  5a94				  -
    350  5a94				  -			; Pass:	 A = X12 square to check
    351  5a94				  -			; Return:	 CC = no
    352  5a94				  -
    353  5a94				  -	      ldy	moveIndex
    354  5a94				  -	      bmi	.exit
    355  5a94				  -.scan      cmp	MoveTo,y
    356  5a94				  -	      beq	.found	; YES!
    357  5a94				  -	      dey
    358  5a94				  -	      bpl	.scan
    359  5a94				  -
    360  5a94				  -.exit      clc
    361  5a94				  -.found     rts
    362  5a94				  -
    363  5a94					      endif
    364  5a94
    365  5a94
    366  5a94							;---------------------------------------------------------------------------------------------------
    367  5a94
    368  5a94				  -	      if	0
    369  5a94				  -	      DEF	GetKingSquare
    370  5a94				  -	      SUBROUTINE
    371  5a94				  -
    372  5a94				  -	      REFER	SAFE_GetKingSquare
    373  5a94				  -	      VEND	GetKingSquare
    374  5a94				  -
    375  5a94				  -			; Return:	 a = square king is on (or -1)
    376  5a94				  -			;		 x = piece type
    377  5a94				  -
    378  5a94				  -
    379  5a94				  -
    380  5a94				  -	      ldy	PieceListPtr
    381  5a94				  -	      bmi	.exit	; no pieces?!
    382  5a94				  -.find      lda	PieceType,y
    383  5a94				  -	      and	#PIECE_MASK
    384  5a94				  -	      cmp	#KING
    385  5a94				  -	      beq	.found
    386  5a94				  -	      dey
    387  5a94				  -	      bpl	.find
    388  5a94				  -
    389  5a94				  -.exit      lda	#-1	; not found/no king square
    390  5a94				  -	      rts
    391  5a94				  -
    392  5a94				  -.found     lda	PieceSquare,y
    393  5a94				  -	      ldx	PieceType,y
    394  5a94				  -	      rts
    395  5a94					      endif
    396  5a94
    397  5a94							;---------------------------------------------------------------------------------------------------
    398  5a94
      0  5a94					      DEF	GetPieceGivenFromToSquares
      1  5a94				   BANK_GetPieceGivenFromToSquares SET	_CURRENT_BANK
      2  5a94				   GetPieceGivenFromToSquares
      3  5a94				   TEMPORARY_VAR SET	Overlay
      4  5a94				   TEMPORARY_OFFSET SET	0
      5  5a94				   VAR_BOUNDARY_GetPieceGivenFromToSquares SET	TEMPORARY_OFFSET
      6  5a94				   FUNCTION_NAME SET	GetPieceGivenFromToSquares
      7  5a94					      SUBROUTINE
    400  5a94					      SUBROUTINE
    401  5a94
      0  5a94					      REFER	GetPiece
      1  5a94				  -	      IF	VAREND_GetPiece > TEMPORARY_VAR
      2  5a94				  -TEMPORARY_VAR SET	VAREND_GetPiece
      3  5a94					      ENDIF
      0  5a94					      VEND	GetPieceGivenFromToSquares
      1  5a94				  -	      IFNCONST	GetPieceGivenFromToSquares
      2  5a94				  -	      ECHO	"Incorrect VEND label", GetPieceGivenFromToSquares
      3  5a94				  -	      ERR
      4  5a94					      ENDIF
      5  5a94		       00 a2	   VAREND_GetPieceGivenFromToSquares =	TEMPORARY_VAR
    404  5a94
    405  5a94							; returns piece in A+fromPiece
    406  5a94							; or Y=-1 if not found
    407  5a94
    408  5a94							; We need to get the piece from the movelist because it contains flags (e.g., castling) about
    409  5a94							; the move. We need to do from/to checks because moves can have multiple origin/desinations.
    410  5a94							; This fixes the move with/without castle flag
    411  5a94
    412  5a94		       ac d7 f1 	      ldy	moveIndex
    413  5a97		       30 11		      bmi	.fail	; shouldn't happen
    414  5a99		       a5 85	   .scan      lda	fromX12
    415  5a9b		       d9 04 f0 	      cmp	MoveFrom,y
    416  5a9e		       d0 07		      bne	.next
    417  5aa0		       a5 86		      lda	toX12
    418  5aa2		       d9 4a f0 	      cmp	MoveTo,y
    419  5aa5		       f0 04		      beq	.found
    420  5aa7		       88	   .next      dey
    421  5aa8		       10 ef		      bpl	.scan
    422  5aaa		       60	   .fail      rts
    423  5aab
    424  5aab		       b9 90 f0    .found     lda	MovePiece,y
    425  5aae		       85 98		      sta	fromPiece
    426  5ab0		       60		      rts
    427  5ab1
    428  5ab1
    429  5ab1
    430  5ab1							;---------------------------------------------------------------------------------------------------
    431  5ab1
    432  5ab1				  -	      if	0
    433  5ab1				  -	      DEF	CheckMoveListToSquare
    434  5ab1				  -	      SUBROUTINE
    435  5ab1				  -
    436  5ab1				  -	      VEND	CheckMoveListToSquare
    437  5ab1				  -
    438  5ab1				  -			; y = -1 on return if NOT FOUND
    439  5ab1				  -
    440  5ab1				  -	      ldy	moveIndex
    441  5ab1				  -	      bmi	.exit
    442  5ab1				  -.scan      lda	toX12
    443  5ab1				  -	      cmp	MoveTo,y
    444  5ab1				  -	      bne	.xscanned
    445  5ab1				  -	      lda	MoveFrom,y
    446  5ab1				  -	      cmp	fromX12
    447  5ab1				  -	      beq	.exit
    448  5ab1				  -.xscanned  dey
    449  5ab1				  -	      bpl	.scan
    450  5ab1				  -
    451  5ab1				  -.exit      rts
    452  5ab1					      endif
    453  5ab1
    454  5ab1
    455  5ab1							;---------------------------------------------------------------------------------------------------
    456  5ab1
      0  5ab1					      DEF	selectmove
      1  5ab1				   BANK_selectmove SET	_CURRENT_BANK
      2  5ab1				   selectmove
      3  5ab1				   TEMPORARY_VAR SET	Overlay
      4  5ab1				   TEMPORARY_OFFSET SET	0
      5  5ab1				   VAR_BOUNDARY_selectmove SET	TEMPORARY_OFFSET
      6  5ab1				   FUNCTION_NAME SET	selectmove
      7  5ab1					      SUBROUTINE
    458  5ab1					      SUBROUTINE
    459  5ab1
      0  5ab1					      COMMON_VARS_ALPHABETA
      1  5ab1
      0  5ab1					      VAR	__bestMove, 1
      1  5ab1		       00 a2	   __bestMove =	TEMPORARY_VAR
      2  5ab1				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5ab1
      4  5ab1				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5ab1				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5ab1				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5ab1					      ENDIF
      8  5ab1				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5ab1				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  5ab1				  -	      ERR
     11  5ab1					      ENDIF
     12  5ab1					      LIST	ON
      0  5ab1					      VAR	__bestScore, 2
      1  5ab1		       00 a3	   __bestScore =	TEMPORARY_VAR
      2  5ab1				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5ab1
      4  5ab1				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5ab1				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5ab1				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5ab1					      ENDIF
      8  5ab1				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5ab1				  -	      ECHO	"Temporary Variable", __bestScore, "overflow!"
     10  5ab1				  -	      ERR
     11  5ab1					      ENDIF
     12  5ab1					      LIST	ON
      0  5ab1					      VAR	__alpha, 2
      1  5ab1		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  5ab1				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5ab1
      4  5ab1				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5ab1				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5ab1				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5ab1					      ENDIF
      8  5ab1				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5ab1				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  5ab1				  -	      ERR
     11  5ab1					      ENDIF
     12  5ab1					      LIST	ON
      0  5ab1					      VAR	__beta, 2
      1  5ab1		       00 a7	   __beta     =	TEMPORARY_VAR
      2  5ab1				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5ab1
      4  5ab1				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5ab1				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5ab1				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5ab1					      ENDIF
      8  5ab1				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5ab1				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  5ab1				  -	      ERR
     11  5ab1					      ENDIF
     12  5ab1					      LIST	ON
      6  5ab1
      0  5ab1					      REFER	aiComputerMove
      1  5ab1				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  5ab1				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  5ab1					      ENDIF
      0  5ab1					      VEND	selectmove
      1  5ab1				  -	      IFNCONST	selectmove
      2  5ab1				  -	      ECHO	"Incorrect VEND label", selectmove
      3  5ab1				  -	      ERR
      4  5ab1					      ENDIF
      5  5ab1		       00 a9	   VAREND_selectmove =	TEMPORARY_VAR
    463  5ab1
    464  5ab1							; RAM bank already switched in!!!
    465  5ab1
      0  5ab1					      stx@RAM	depthLeft
      1  5ab1		       8e de f5 	      stx	[RAM]+depthLeft
    467  5ab4
    468  5ab4							; both player (pos) and opponent (neg) have worst value ever!
    469  5ab4
    470  5ab4		       a9 ff		      lda	#<INFINITY
      0  5ab6					      sta@RAM	beta
      1  5ab6		       8d dc f5 	      sta	[RAM]+beta
    472  5ab9		       a9 7f		      lda	#>INFINITY
      0  5abb					      sta@RAM	beta+1	; opponent tries to minimise
      1  5abb		       8d dd f5 	      sta	[RAM]+beta+1
    474  5abe
    475  5abe		       a9 01		      lda	#<-INFINITY
      0  5ac0					      sta@RAM	alpha
      1  5ac0		       8d da f5 	      sta	[RAM]+alpha
    477  5ac3		       a9 80		      lda	#>-INFINITY
      0  5ac5					      sta@RAM	alpha+1	; player tries to maximise
      1  5ac5		       8d db f5 	      sta	[RAM]+alpha+1
    479  5ac8
    480  5ac8
    481  5ac8							; "boardValue = -alphabeta( -beta, -alpha, depthleft - 1 )"
    482  5ac8
    483  5ac8		       38		      sec
    484  5ac9		       a9 00		      lda	#0
    485  5acb		       ed da f1 	      sbc	alpha
    486  5ace		       85 a5		      sta	__alpha
    487  5ad0		       a9 00		      lda	#0
    488  5ad2		       ed db f1 	      sbc	alpha+1
    489  5ad5		       85 a6		      sta	__alpha+1	; = -alpha
    490  5ad7
    491  5ad7		       38		      sec
    492  5ad8		       a9 00		      lda	#0
    493  5ada		       ed dc f1 	      sbc	beta
    494  5add		       85 a7		      sta	__beta
    495  5adf		       a9 00		      lda	#0
    496  5ae1		       ed dd f1 	      sbc	beta+1
    497  5ae4		       85 a8		      sta	__beta+1	; = -beta (effectively unchanged) - no αβ on ply 0
    498  5ae6
    499  5ae6		       ae de f1 	      ldx	depthLeft
    500  5ae9		       20 0d fe 	      jsr	alphaBeta	; recurse!
    501  5aec
    502  5aec		       ae d9 f1 	      ldx	bestMove
    503  5aef		       bd 4a f0 	      lda	MoveTo,x
    504  5af2		       85 86		      sta	toX12
    505  5af4		       bd 04 f0 	      lda	MoveFrom,x
    506  5af7		       85 87		      sta	originX12
    507  5af9		       85 85		      sta	fromX12
    508  5afb		       bd 90 f0 	      lda	MovePiece,x
    509  5afe		       85 98		      sta	fromPiece
    510  5b00
    511  5b00		       60		      rts
    512  5b01
    513  5b01
    514  5b01							;---------------------------------------------------------------------------------------------------
    515  5b01
      0  5b01					      DEF	GenCastleMoveForRook
      1  5b01				   BANK_GenCastleMoveForRook SET	_CURRENT_BANK
      2  5b01				   GenCastleMoveForRook
      3  5b01				   TEMPORARY_VAR SET	Overlay
      4  5b01				   TEMPORARY_OFFSET SET	0
      5  5b01				   VAR_BOUNDARY_GenCastleMoveForRook SET	TEMPORARY_OFFSET
      6  5b01				   FUNCTION_NAME SET	GenCastleMoveForRook
      7  5b01					      SUBROUTINE
    517  5b01					      SUBROUTINE
    518  5b01
      0  5b01					      REFER	MakeMove
      1  5b01					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  5b01				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  5b01					      ENDIF
      0  5b01					      REFER	CastleFixupDraw
      1  5b01				  -	      IF	VAREND_CastleFixupDraw > TEMPORARY_VAR
      2  5b01				  -TEMPORARY_VAR SET	VAREND_CastleFixupDraw
      3  5b01					      ENDIF
      0  5b01					      VEND	GenCastleMoveForRook
      1  5b01				  -	      IFNCONST	GenCastleMoveForRook
      2  5b01				  -	      ECHO	"Incorrect VEND label", GenCastleMoveForRook
      3  5b01				  -	      ERR
      4  5b01					      ENDIF
      5  5b01		       00 aa	   VAREND_GenCastleMoveForRook =	TEMPORARY_VAR
    522  5b01
    523  5b01		       18		      clc
    524  5b02
    525  5b02		       a5 98		      lda	fromPiece
    526  5b04		       29 10		      and	#FLAG_CASTLE
    527  5b06		       f0 2b		      beq	.exit	; NOT involved in castle!
    528  5b08
    529  5b08		       a2 04		      ldx	#4
    530  5b0a		       a5 85		      lda	fromX12	; *destination*
    531  5b0c		       18	   .findCast  clc
    532  5b0d		       ca		      dex
    533  5b0e		       30 23		      bmi	.exit
    534  5b10		       dd 48 f3 	      cmp	KSquare,x
    535  5b13		       d0 f7		      bne	.findCast
    536  5b15
    537  5b15		       bd 50 f3 	      lda	RSquareEnd,x
    538  5b18		       85 86		      sta	toX12
      0  5b1a					      sta@RAM	secondaryBlank
      1  5b1a		       8d d6 f5 	      sta	[RAM]+secondaryBlank
    540  5b1d		       bc 4c f3 	      ldy	RSquareStart,x
    541  5b20		       84 85		      sty	fromX12
    542  5b22		       84 87		      sty	originX12
      0  5b24					      sty@RAM	secondarySquare
      1  5b24		       8c d5 f5 	      sty	[RAM]+secondarySquare
    544  5b27
    545  5b27		       a5 98		      lda	fromPiece
    546  5b29		       29 80		      and	#128	; colour bit
    547  5b2b		       09 05		      ora	#ROOK	; preserve colour
    548  5b2d		       85 98		      sta	fromPiece
      0  5b2f					      sta@RAM	secondaryPiece
      1  5b2f		       8d d4 f5 	      sta	[RAM]+secondaryPiece
    550  5b32
    551  5b32		       38		      sec
    552  5b33		       60	   .exit      rts
    553  5b34
    554  5b34
    555  5b34							;---------------------------------------------------------------------------------------------------
    556  5b34
      0  5b34					      DEF	CastleFixupDraw
      1  5b34				   BANK_CastleFixupDraw SET	_CURRENT_BANK
      2  5b34				   CastleFixupDraw
      3  5b34				   TEMPORARY_VAR SET	Overlay
      4  5b34				   TEMPORARY_OFFSET SET	0
      5  5b34				   VAR_BOUNDARY_CastleFixupDraw SET	TEMPORARY_OFFSET
      6  5b34				   FUNCTION_NAME SET	CastleFixupDraw
      7  5b34					      SUBROUTINE
    558  5b34					      SUBROUTINE
    559  5b34
      0  5b34					      REFER	SpecialBody
      1  5b34					      IF	VAREND_SpecialBody > TEMPORARY_VAR
      2  5b34				   TEMPORARY_VAR SET	VAREND_SpecialBody
      3  5b34					      ENDIF
      0  5b34					      VEND	CastleFixupDraw
      1  5b34				  -	      IFNCONST	CastleFixupDraw
      2  5b34				  -	      ECHO	"Incorrect VEND label", CastleFixupDraw
      3  5b34				  -	      ERR
      4  5b34					      ENDIF
      5  5b34		       00 a9	   VAREND_CastleFixupDraw =	TEMPORARY_VAR
    562  5b34
    563  5b34							; fixup any castling issues
    564  5b34							; at this point the king has finished his two-square march
    565  5b34							; based on the finish square, we determine which rook we're interacting with
    566  5b34							; and generate a 'move' for the rook to position on the other side of the king
    567  5b34
    568  5b34
    569  5b34					      IF	CASTLING_ENABLED
    570  5b34		       20 01 f3 	      jsr	GenCastleMoveForRook
    571  5b37		       b0 07		      bcs	.phase
    572  5b39					      ENDIF
    573  5b39
    574  5b39		       a5 97		      lda	sideToMove
    575  5b3b		       49 80		      eor	#128
    576  5b3d		       85 97		      sta	sideToMove
    577  5b3f		       60		      rts
    578  5b40
    579  5b40				   .phase
    580  5b40
    581  5b40							; in this siutation (castle, rook moving) we do not change sides yet!
    582  5b40
    583  5b40		       20 23 fa 	      jsr	debug
    584  5b43
      0  5b43					      PHASE	AI_MoveIsSelected
      1  5b43		       a9 15		      lda	#AI_MoveIsSelected
      2  5b45		       85 8c		      sta	aiState
    586  5b47		       60		      rts
    587  5b48
    588  5b48
    589  5b48
    590  5b48		       18 1c 5e 62 KSquare    .byte.b	24,28,94,98
    591  5b4c		       16 1d 5c 63 RSquareStart .byte.b	22,29,92,99
    592  5b50		       19 1b 5f 61 RSquareEnd .byte.b	25,27,95,97
    593  5b54
    594  5b54
    595  5b54							;---------------------------------------------------------------------------------------------------
    596  5b54
      0  5b54					      DEF	SetupBanks
      1  5b54				   BANK_SetupBanks SET	_CURRENT_BANK
      2  5b54				   SetupBanks
      3  5b54				   TEMPORARY_VAR SET	Overlay
      4  5b54				   TEMPORARY_OFFSET SET	0
      5  5b54				   VAR_BOUNDARY_SetupBanks SET	TEMPORARY_OFFSET
      6  5b54				   FUNCTION_NAME SET	SetupBanks
      7  5b54					      SUBROUTINE
    598  5b54					      SUBROUTINE
    599  5b54
      0  5b54					      REFER	Reset
      1  5b54				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  5b54				  -TEMPORARY_VAR SET	VAREND_Reset
      3  5b54					      ENDIF
      0  5b54					      VAR	__plyBank, 1
      1  5b54		       00 a2	   __plyBank  =	TEMPORARY_VAR
      2  5b54				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5b54
      4  5b54				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5b54				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5b54				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5b54					      ENDIF
      8  5b54				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5b54				  -	      ECHO	"Temporary Variable", __plyBank, "overflow!"
     10  5b54				  -	      ERR
     11  5b54					      ENDIF
     12  5b54					      LIST	ON
      0  5b54					      VEND	SetupBanks
      1  5b54				  -	      IFNCONST	SetupBanks
      2  5b54				  -	      ECHO	"Incorrect VEND label", SetupBanks
      3  5b54				  -	      ERR
      4  5b54					      ENDIF
      5  5b54		       00 a3	   VAREND_SetupBanks =	TEMPORARY_VAR
    603  5b54
    604  5b54							; SAFE
    605  5b54
    606  5b54		       a0 07		      ldy	#7
    607  5b56		       a2 01	   .copyRowBanks ldx	#BANK_ROM_SHADOW_OF_CHESS_BITMAP
    608  5b58		       20 74 fc 	      jsr	CopyShadowROMtoRAM
    609  5b5b		       88		      dey
    610  5b5c		       10 f8		      bpl	.copyRowBanks
    611  5b5e
    612  5b5e							; copy the BOARD/MOVES bank
    613  5b5e
    614  5b5e		       a0 08		      ldy	#RAMBANK_MOVES_RAM
    615  5b60		       a2 0a		      ldx	#MOVES
    616  5b62		       20 74 fc 	      jsr	CopyShadowROMtoRAM	; this auto-initialises Board too
    617  5b65
    618  5b65							; copy the PLY banks
    619  5b65
    620  5b65		       a9 0a		      lda	#MAX_PLY
    621  5b67		       85 a2		      sta	__plyBank
    622  5b69		       a0 09		      ldy	#RAMBANK_PLY
    623  5b6b		       84 95		      sty	currentPly
    624  5b6d		       a2 0b	   .copyPlyBanks ldx	#BANK_PLY
    625  5b6f		       20 74 fc 	      jsr	CopyShadowROMtoRAM
    626  5b72		       c8		      iny
    627  5b73		       c6 a2		      dec	__plyBank
    628  5b75		       d0 f6		      bne	.copyPlyBanks
    629  5b77
    630  5b77		       60		      rts
    631  5b78
    632  5b78
    633  5b78							;---------------------------------------------------------------------------------------------------
    634  5b78
    635  5b78				  -	      if	0
    636  5b78				  -	      DEF	Sort
    637  5b78				  -	      SUBROUTINE
    638  5b78				  -
    639  5b78				  -	      VAR	__big, 2
    640  5b78				  -	      VAR	__biggest, 1
    641  5b78				  -	      VEND	Sort
    642  5b78				  -
    643  5b78				  -	      ldx	moveIndex
    644  5b78				  -	      bmi	.exit
    645  5b78				  -
    646  5b78				  -.fill      txa
    647  5b78				  -	      sta@RAM	SortedMove,x
    648  5b78				  -	      dex
    649  5b78				  -	      bpl	.fill
    650  5b78				  -
    651  5b78				  -
    652  5b78				  -	      ldy	moveIndex
    653  5b78				  -.getNext   ldx	moveIndex
    654  5b78				  -	      lda	#<-INFINITY
    655  5b78				  -	      sta	__big
    656  5b78				  -	      lda	#>-INFINITY
    657  5b78				  -	      sta	__big+1
    658  5b78				  -
    659  5b78				  -.findBig
    660  5b78				  -
    661  5b78				  -	      sec
    662  5b78				  -	      lda	MoveScoreLO,x
    663  5b78				  -	      sbc	__big
    664  5b78				  -	      lda	MoveScoreHI,x
    665  5b78				  -	      sbc	__big+1
    666  5b78				  -	      bvc	.l0
    667  5b78				  -	      eor	#$80
    668  5b78				  -.l0	      bmi	.lt
    669  5b78				  -
    670  5b78				  -	      lda	MoveScoreLO,x
    671  5b78				  -	      sta	__big
    672  5b78				  -	      lda	MoveScoreHI,x
    673  5b78				  -	      sta	__big+1
    674  5b78				  -
    675  5b78				  -	      stx	__biggest
    676  5b78				  -
    677  5b78				  -.lt	      dex
    678  5b78				  -	      bpl	.findBig
    679  5b78				  -
    680  5b78				  -	      lda	__biggest
    681  5b78				  -	      sta@RAM	SortedMove,y
    682  5b78				  -	      tax
    683  5b78				  -
    684  5b78				  -
    685  5b78				  -	      lda	#<-INFINITY
    686  5b78				  -	      sta@RAM	MoveScoreLO,x
    687  5b78				  -	      lda	#>-INFINITY
    688  5b78				  -	      sta@RAM	MoveScoreHI,x
    689  5b78				  -
    690  5b78				  -
    691  5b78				  -
    692  5b78				  -	      dey
    693  5b78				  -	      bpl	.getNext
    694  5b78				  -.exit      rts
    695  5b78					      endif
    696  5b78
    697  5b78
    698  5b78
      0  5b78					      DEF	Sort
      1  5b78				   BANK_Sort  SET	_CURRENT_BANK
      2  5b78				   Sort
      3  5b78				   TEMPORARY_VAR SET	Overlay
      4  5b78				   TEMPORARY_OFFSET SET	0
      5  5b78				   VAR_BOUNDARY_Sort SET	TEMPORARY_OFFSET
      6  5b78				   FUNCTION_NAME SET	Sort
      7  5b78					      SUBROUTINE
    700  5b78					      SUBROUTINE
    701  5b78
      0  5b78					      REFER	aiComputerMove
      1  5b78				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  5b78				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  5b78					      ENDIF
      0  5b78					      VAR	__xs, 1
      1  5b78		       00 a2	   __xs       =	TEMPORARY_VAR
      2  5b78				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5b78
      4  5b78				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5b78				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5b78				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5b78					      ENDIF
      8  5b78				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5b78				  -	      ECHO	"Temporary Variable", __xs, "overflow!"
     10  5b78				  -	      ERR
     11  5b78					      ENDIF
     12  5b78					      LIST	ON
      0  5b78					      VEND	Sort
      1  5b78				  -	      IFNCONST	Sort
      2  5b78				  -	      ECHO	"Incorrect VEND label", Sort
      3  5b78				  -	      ERR
      4  5b78					      ENDIF
      5  5b78		       00 a3	   VAREND_Sort =	TEMPORARY_VAR
    705  5b78
    706  5b78		       a5 95		      lda	currentPly
    707  5b7a		       85 8b		      sta	savedBank
    708  5b7c
    709  5b7c
    710  5b7c		       ae d7 f1 	      ldx	moveIndex
    711  5b7f		       ac d7 f1 	      ldy	moveIndex
    712  5b82		       88		      dey
    713  5b83		       84 a2	   .scan      sty	__xs
    714  5b85		       b9 4a f0 	      lda	MoveTo,y
    715  5b88		       a8		      tay
    716  5b89		       20 40 fc 	      jsr	GetBoardRAM
    717  5b8c		       a4 a2		      ldy	__xs
    718  5b8e		       29 0f		      and	#PIECE_MASK
    719  5b90		       f0 2b		      beq	.next
    720  5b92
    721  5b92
    722  5b92		       bd 4a f0 	      lda	MoveTo,x
    723  5b95		       48		      pha
    724  5b96		       bd 04 f0 	      lda	MoveFrom,x
    725  5b99		       48		      pha
    726  5b9a		       bd 90 f0 	      lda	MovePiece,x
    727  5b9d		       48		      pha
    728  5b9e
    729  5b9e		       b9 90 f0 	      lda	MovePiece,y
      0  5ba1					      sta@RAM	MovePiece,x
      1  5ba1		       9d 90 f4 	      sta	[RAM]+MovePiece,x
    731  5ba4		       68		      pla
      0  5ba5					      sta@RAM	MovePiece,y
      1  5ba5		       99 90 f4 	      sta	[RAM]+MovePiece,y
    733  5ba8
    734  5ba8		       b9 04 f0 	      lda	MoveFrom,y
      0  5bab					      sta@RAM	MoveFrom,x
      1  5bab		       9d 04 f4 	      sta	[RAM]+MoveFrom,x
    736  5bae		       68		      pla
      0  5baf					      sta@RAM	MoveFrom,y
      1  5baf		       99 04 f4 	      sta	[RAM]+MoveFrom,y
    738  5bb2
    739  5bb2		       b9 4a f0 	      lda	MoveTo,y
      0  5bb5					      sta@RAM	MoveTo,x
      1  5bb5		       9d 4a f4 	      sta	[RAM]+MoveTo,x
    741  5bb8		       68		      pla
      0  5bb9					      sta@RAM	MoveTo,y
      1  5bb9		       99 4a f4 	      sta	[RAM]+MoveTo,y
    743  5bbc
    744  5bbc		       ca		      dex
    745  5bbd
    746  5bbd		       88	   .next      dey
    747  5bbe		       10 c3		      bpl	.scan
    748  5bc0
    749  5bc0
    750  5bc0		       60		      rts
    751  5bc1
    752  5bc1
    753  5bc1
    754  5bc1
    755  5bc1
    756  5bc1				  -	      if	0
    757  5bc1				  -	      DEF	Sort
    758  5bc1				  -	      SUBROUTINE
    759  5bc1				  -
    760  5bc1				  -	      VAR	__idx, 1
    761  5bc1				  -	      VAR	__work1, 1
    762  5bc1				  -	      VAR	__work2, 2
    763  5bc1				  -	      VAR	__work3, 2
    764  5bc1				  -	      VAR	__sx, 1
    765  5bc1				  -	      VEND	Sort
    766  5bc1				  -
    767  5bc1				  -	      jsr	debug
    768  5bc1				  -
    769  5bc1				  -			; Fill the move pointer list (in order)
    770  5bc1				  -			; We want the LAST entry to be the index of the one with the BEST score
    771  5bc1				  -
    772  5bc1				  -	      ldx	moveIndex
    773  5bc1				  -	      stx	__idx
    774  5bc1				  -	      bmi	.exit
    775  5bc1				  -
    776  5bc1				  -.fill      txa
    777  5bc1				  -	      sta@RAM	SortedMove,x
    778  5bc1				  -	      dex
    779  5bc1				  -	      bpl	.fill
    780  5bc1				  -
    781  5bc1				  -			; Now that oddball sort!
    782  5bc1				  -
    783  5bc1				  -.sort      ldx	__idx
    784  5bc1				  -	      ldy	SortedMove,x
    785  5bc1				  -	      sty	__work3
    786  5bc1				  -	      jmp	.l2
    787  5bc1				  -
    788  5bc1				  -.l1	      ldx	__sx
    789  5bc1				  -	      dex
    790  5bc1				  -	      beq	.l3
    791  5bc1				  -	      stx	__sx
    792  5bc1				  -
    793  5bc1				  -
    794  5bc1				  -	      lda	SortedMove,x
    795  5bc1				  -	      ldy	__work2
    796  5bc1				  -	      ldx	SortedMove,y	; y = nval
    797  5bc1				  -	      tay		; x = "work2"
    798  5bc1				  -
    799  5bc1				  -	      sec
    800  5bc1				  -	      lda	MoveScoreLO,y
    801  5bc1				  -	      sbc	MoveScoreLO,x
    802  5bc1				  -	      lda	MoveScoreHI,y
    803  5bc1				  -	      sbc	MoveScoreHI,x
    804  5bc1				  -	      bvc	.lab0
    805  5bc1				  -	      eor	#$80
    806  5bc1				  -.lab0      bmi	.l1
    807  5bc1				  -
    808  5bc1				  -	      ldx	__sx
    809  5bc1				  -
    810  5bc1				  -			;If the N flag is 1, then A (signed) < NUM (signed) and BMI will branch
    811  5bc1				  -			;If the N flag is 0, then A (signed) >= NUM (signed) and BPL will branch
    812  5bc1				  -			;One way to remember which is which is to remember that minus (BMI) is less than, and plus (BPL) is greater than or equal to.
    813  5bc1				  -
    814  5bc1				  -.l2	      stx	__work1
    815  5bc1				  -	      sty	__work2
    816  5bc1				  -	      stx	__sx
    817  5bc1				  -	      jmp	.l1
    818  5bc1				  -
    819  5bc1				  -.l3	      ldy	__idx
    820  5bc1				  -	      lda	__work2
    821  5bc1				  -	      sta@RAM	SortedMove,y
    822  5bc1				  -	      ldy	__work1
    823  5bc1				  -	      lda	__work3
    824  5bc1				  -	      sta@RAM	SortedMove,y
    825  5bc1				  -
    826  5bc1				  -	      dec	__idx
    827  5bc1				  -	      bne	.sort
    828  5bc1				  -.exit      rts
    829  5bc1				  -
    830  5bc1				  -			;If the N flag is 1, then A (signed) < NUM (signed) and BMI will branch
    831  5bc1				  -			;If the N flag is 0, then A (signed) >= NUM (signed) and BPL will branch
    832  5bc1				  -			;One way to remember which is which is to remember that minus (BMI) is less than, and plus (BPL) is greater than or equal to.
    833  5bc1					      endif
    834  5bc1
    835  5bc1
    836  5bc1				  -	      if	0
    837  5bc1				  -.exit
    838  5bc1				  -
    839  5bc1				  -
    840  5bc1				  -			;
    841  5bc1				  -ZPADD      =	$30	;2 BYTE POINTER IN PAGE ZERO. SET BY CALLING PROGRAM
    842  5bc1				  -NVAL       =	$32	;SET BY CALLING PROGRAM
    843  5bc1				  -WORK1      =	$33	;3 BYTES USED AS WORKING AREA
    844  5bc1				  -WORK2      =	$34
    845  5bc1				  -WORK3      =	$35
    846  5bc1				  -	      *=$6000		;CODE ANYWHERE IN RAM OR ROM
    847  5bc1				  -SORT       LDY	NVAL	;START OF SUBROUTINE SORT
    848  5bc1				  -	      LDA	(ZPADD),Y	;LAST VALUE IN (WHAT IS LEFT OF) SEQUENCE TO BE SORTED
    849  5bc1				  -	      STA	WORK3	;SAVE VALUE. WILL BE OVER-WRITTEN BY LARGEST NUMBER
    850  5bc1				  -	      BRA	L2
    851  5bc1				  -L1	      DEY
    852  5bc1				  -	      BEQ	L3
    853  5bc1				  -	      LDA	(ZPADD),Y
    854  5bc1				  -	      CMP	WORK2
    855  5bc1				  -	      BCC	L1
    856  5bc1				  -L2	      STY	WORK1	;INDEX OF POTENTIALLY LARGEST VALUE
    857  5bc1				  -	      STA	WORK2	;POTENTIALLY LARGEST VALUE
    858  5bc1				  -	      BRA	L1
    859  5bc1				  -L3	      LDY	NVAL	;WHERE THE LARGEST VALUE SHALL BE PUT
    860  5bc1				  -	      LDA	WORK2	;THE LARGEST VALUE
    861  5bc1				  -	      STA	(ZPADD),Y	;PUT LARGEST VALUE IN PLACE
    862  5bc1				  -	      LDY	WORK1	;INDEX OF FREE SPACE
    863  5bc1				  -	      LDA	WORK3	;THE OVER-WRITTEN VALUE
    864  5bc1				  -	      STA	(ZPADD),Y	;PUT THE OVER-WRITTEN VALUE IN THE FREE SPACE
    865  5bc1				  -	      DEC	NVAL	;END OF THE SHORTER SEQUENCE STILL LEFT
    866  5bc1				  -	      BNE	SORT	;START WORKING WITH THE SHORTER SEQUENCE
    867  5bc1				  -	      RTS
    868  5bc1					      endif
    869  5bc1
    870  5bc1
    871  5bc1							;---------------------------------------------------------------------------------------------------
    872  5bc1
      0  5bc1					      CHECK_HALF_BANK_SIZE	"PLY -- 1K"
      1  5bc1
      2  5bc1
      3  5bc1		       03 c1	   .TEMP      =	* - BANK_START
 PLY -- 1K (1K) SIZE =  $3c1 , FREE= $3f
      4  5bc1					      ECHO	"PLY -- 1K", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  5bc1				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  5bc1				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  5bc1				  -	      ERR
      8  5bc1					      endif
    874  5bc1
    875  5bc1							;---------------------------------------------------------------------------------------------------
    876  5bc1
    877  5bc1							; There is space here (1K) for use as ROM
    878  5bc1							; but NOT when the above bank is switched in as RAM, of course!
    879  5bc1
    880  5bc1
    881  5bc1
    882  5bc1
    883  5bc1							;---------------------------------------------------------------------------------------------------
    884  5bc1							; EOF
------- FILE ./chess.asm
------- FILE BANK_EVAL.asm LEVEL 2 PASS 5
      0  5bc1					      include	"BANK_EVAL.asm"
      0  5bc1					      NEWBANK	EVAL
      1  632d ????				      SEG	EVAL
      2  6000					      ORG	ORIGIN
      3  6000					      RORG	$F000
      4  6000				   BANK_START SET	*
      5  6000				   EVAL       SET	ORIGIN / 2048
      6  6000				   ORIGIN     SET	ORIGIN + 2048
      7  6000				   _CURRENT_BANK SET	EVAL
      2  6000
      3  6000
      4  6000							; see https://www.chessprogramming.org/Simplified_Evaluation_Function
      5  6000
      6  6000
      7  6000		       00 64	   VALUE_P    =	100
      8  6000		       01 40	   VALUE_N    =	320
      9  6000		       01 4a	   VALUE_B    =	330
     10  6000		       01 f4	   VALUE_R    =	500
     11  6000		       03 84	   VALUE_Q    =	900
     12  6000		       4e 20	   VALUE_K    =	20000
     13  6000
     14  6000
     15  6000					      MAC	vequ
     16  6000				   VALUE_{1}  =	{2}
     17  6000					      ENDM
     18  6000
     19  6000					      MAC	lobyte
     20  6000					      .byte	<{2}
     21  6000					      ENDM
     22  6000
     23  6000					      MAC	hibyte
     24  6000					      .byte	>{2}
     25  6000					      ENDM
     26  6000
     27  6000
     28  6000					      MAC	valuetable
     29  6000					      {1}	BLANK, 0
     30  6000					      {1}	PAWN, 100	; white
     31  6000					      {1}	PAWN, 100	; black
     32  6000					      {1}	KNIGHT, 320
     33  6000					      {1}	BISHOP, 330
     34  6000					      {1}	ROOK, 500
     35  6000					      {1}	QUEEN, 900
     36  6000					      {1}	KING, 20000
     37  6000					      ENDM
     38  6000
     39  6000
      0  6000					      VALUETABLE	VEQU
      0  6000					      VEQU	BLANK, 0
      1  6000		       00 00	   VALUE_BLANK =	0
      0  6000					      VEQU	PAWN, 100
      1  6000		       00 64	   VALUE_PAWN =	100
      0  6000					      VEQU	PAWN, 100
      1  6000		       00 64	   VALUE_PAWN =	100
      0  6000					      VEQU	KNIGHT, 320
      1  6000		       01 40	   VALUE_KNIGHT =	320
      0  6000					      VEQU	BISHOP, 330
      1  6000		       01 4a	   VALUE_BISHOP =	330
      0  6000					      VEQU	ROOK, 500
      1  6000		       01 f4	   VALUE_ROOK =	500
      0  6000					      VEQU	QUEEN, 900
      1  6000		       03 84	   VALUE_QUEEN =	900
      0  6000					      VEQU	KING, 20000
      1  6000		       4e 20	   VALUE_KING =	20000
     41  6000
      0  6000					      DEF	PieceValueLO
      1  6000				   BANK_PieceValueLO SET	_CURRENT_BANK
      2  6000				   PieceValueLO
      3  6000				   TEMPORARY_VAR SET	Overlay
      4  6000				   TEMPORARY_OFFSET SET	0
      5  6000				   VAR_BOUNDARY_PieceValueLO SET	TEMPORARY_OFFSET
      6  6000				   FUNCTION_NAME SET	PieceValueLO
      7  6000					      SUBROUTINE
      0  6000					      VALUETABLE	LOBYTE
      0  6000					      LOBYTE	BLANK, 0
      1  6000		       00		      .byte.b	<0
      0  6001					      LOBYTE	PAWN, 100
      1  6001		       64		      .byte.b	<100
      0  6002					      LOBYTE	PAWN, 100
      1  6002		       64		      .byte.b	<100
      0  6003					      LOBYTE	KNIGHT, 320
      1  6003		       40		      .byte.b	<320
      0  6004					      LOBYTE	BISHOP, 330
      1  6004		       4a		      .byte.b	<330
      0  6005					      LOBYTE	ROOK, 500
      1  6005		       f4		      .byte.b	<500
      0  6006					      LOBYTE	QUEEN, 900
      1  6006		       84		      .byte.b	<900
      0  6007					      LOBYTE	KING, 20000
      1  6007		       20		      .byte.b	<20000
     44  6008
      0  6008					      DEF	PieceValueHI
      1  6008				   BANK_PieceValueHI SET	_CURRENT_BANK
      2  6008				   PieceValueHI
      3  6008				   TEMPORARY_VAR SET	Overlay
      4  6008				   TEMPORARY_OFFSET SET	0
      5  6008				   VAR_BOUNDARY_PieceValueHI SET	TEMPORARY_OFFSET
      6  6008				   FUNCTION_NAME SET	PieceValueHI
      7  6008					      SUBROUTINE
      0  6008					      VALUETABLE	HIBYTE
      0  6008					      HIBYTE	BLANK, 0
      1  6008		       00		      .byte.b	>0
      0  6009					      HIBYTE	PAWN, 100
      1  6009		       00		      .byte.b	>100
      0  600a					      HIBYTE	PAWN, 100
      1  600a		       00		      .byte.b	>100
      0  600b					      HIBYTE	KNIGHT, 320
      1  600b		       01		      .byte.b	>320
      0  600c					      HIBYTE	BISHOP, 330
      1  600c		       01		      .byte.b	>330
      0  600d					      HIBYTE	ROOK, 500
      1  600d		       01		      .byte.b	>500
      0  600e					      HIBYTE	QUEEN, 900
      1  600e		       03		      .byte.b	>900
      0  600f					      HIBYTE	KING, 20000
      1  600f		       4e		      .byte.b	>20000
     47  6010
     48  6010
     49  6010							;---------------------------------------------------------------------------------------------------
     50  6010
      0  6010					      DEF	AddPieceMaterialValue
      1  6010				   BANK_AddPieceMaterialValue SET	_CURRENT_BANK
      2  6010				   AddPieceMaterialValue
      3  6010				   TEMPORARY_VAR SET	Overlay
      4  6010				   TEMPORARY_OFFSET SET	0
      5  6010				   VAR_BOUNDARY_AddPieceMaterialValue SET	TEMPORARY_OFFSET
      6  6010				   FUNCTION_NAME SET	AddPieceMaterialValue
      7  6010					      SUBROUTINE
     52  6010					      SUBROUTINE
     53  6010
      0  6010					      REFER	AdjustMaterialPositionalValue
      1  6010					      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  6010				   TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  6010					      ENDIF
      0  6010					      REFER	DeletePiece
      1  6010				  -	      IF	VAREND_DeletePiece > TEMPORARY_VAR
      2  6010				  -TEMPORARY_VAR SET	VAREND_DeletePiece
      3  6010					      ENDIF
      0  6010					      REFER	InitialisePieceSquares
      1  6010				  -	      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  6010				  -TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  6010					      ENDIF
      0  6010					      VEND	AddPieceMaterialValue
      1  6010				  -	      IFNCONST	AddPieceMaterialValue
      2  6010				  -	      ECHO	"Incorrect VEND label", AddPieceMaterialValue
      3  6010				  -	      ERR
      4  6010					      ENDIF
      5  6010		       00 ac	   VAREND_AddPieceMaterialValue =	TEMPORARY_VAR
     58  6010
     59  6010							; Adjust the material score based on the piece
     60  6010							; y = piece type
     61  6010
     62  6010		       18		      clc
     63  6011		       b9 00 f0 	      lda	PieceValueLO,y
     64  6014		       65 90		      adc	Evaluation
     65  6016		       85 90		      sta	Evaluation
     66  6018		       b9 08 f0 	      lda	PieceValueHI,y
     67  601b		       65 91		      adc	Evaluation+1
     68  601d		       85 91		      sta	Evaluation+1
     69  601f		       60		      rts
     70  6020
     71  6020
     72  6020							;---------------------------------------------------------------------------------------------------
     73  6020
      0  6020					      DEF	AddPiecePositionValue
      1  6020				   BANK_AddPiecePositionValue SET	_CURRENT_BANK
      2  6020				   AddPiecePositionValue
      3  6020				   TEMPORARY_VAR SET	Overlay
      4  6020				   TEMPORARY_OFFSET SET	0
      5  6020				   VAR_BOUNDARY_AddPiecePositionValue SET	TEMPORARY_OFFSET
      6  6020				   FUNCTION_NAME SET	AddPiecePositionValue
      7  6020					      SUBROUTINE
     75  6020					      SUBROUTINE
     76  6020
      0  6020					      REFER	AdjustMaterialPositionalValue
      1  6020					      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  6020				   TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  6020					      ENDIF
      0  6020					      REFER	DeletePiece
      1  6020				  -	      IF	VAREND_DeletePiece > TEMPORARY_VAR
      2  6020				  -TEMPORARY_VAR SET	VAREND_DeletePiece
      3  6020					      ENDIF
      0  6020					      VAR	__pval3, 2
      1  6020		       00 ac	   __pval3    =	TEMPORARY_VAR
      2  6020				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6020
      4  6020				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6020				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6020				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6020					      ENDIF
      8  6020				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6020				  -	      ECHO	"Temporary Variable", __pval3, "overflow!"
     10  6020				  -	      ERR
     11  6020					      ENDIF
     12  6020					      LIST	ON
      0  6020					      VEND	AddPiecePositionValue
      1  6020				  -	      IFNCONST	AddPiecePositionValue
      2  6020				  -	      ECHO	"Incorrect VEND label", AddPiecePositionValue
      3  6020				  -	      ERR
      4  6020					      ENDIF
      5  6020		       00 ae	   VAREND_AddPiecePositionValue =	TEMPORARY_VAR
     81  6020
     82  6020
     83  6020							; adds value of square piece is on to the evaluation
     84  6020							; note to do the subtraction as -( -x + val) == x - val
     85  6020
     86  6020							; y = square
     87  6020							; a = piece type (+flags)
     88  6020
     89  6020
     90  6020
     91  6020		       c9 80		      cmp	#128	; black = CS
     92  6022		       29 0f		      and	#PIECE_MASK
     93  6024		       aa		      tax
     94  6025
     95  6025				  -	      IF	ASSERTS
     96  6025				  -.kill      beq	.kill	; can't have a 0-piece. something is wrong.
     97  6025					      ENDIF
     98  6025
     99  6025							; black pieces flip rows so we can use the same eval tables
    100  6025
    101  6025		       98		      tya
    102  6026		       90 04		      bcc	.white
    103  6028		       b9 49 f0 	      lda	FlipSquareIndex,y
    104  602b		       18		      clc
    105  602c				   .white
    106  602c		       7d ad f0 	      adc	PosValVecLO,x
    107  602f		       85 ac		      sta	__pval3
    108  6031		       bd b5 f0 	      lda	PosValVecHI,x
    109  6034		       69 00		      adc	#0
    110  6036		       85 ad		      sta	__pval3+1
    111  6038
    112  6038		       a0 00		      ldy	#0
    113  603a		       b1 ac		      lda	(__pval3),y
    114  603c		       10 01		      bpl	.pos
    115  603e		       88		      dey		; odd double-usage of y - now it's hi byte
    116  603f				   .pos
    117  603f
    118  603f							;clc
    119  603f		       65 90		      adc	Evaluation
    120  6041		       85 90		      sta	Evaluation
    121  6043		       98		      tya
    122  6044		       65 91		      adc	Evaluation+1
    123  6046		       85 91		      sta	Evaluation+1
    124  6048		       60		      rts
    125  6049
    126  6049
    127  6049							;---------------------------------------------------------------------------------------------------
    128  6049
      0  6049					      ALLOCATE	FlipSquareIndex, 100
      0  6049					      OPTIONAL_PAGEBREAK	"Table", 100
     12  6049					      LIST	ON
      0  6049					      DEF	FlipSquareIndex
      1  6049				   BANK_FlipSquareIndex SET	_CURRENT_BANK
      2  6049				   FlipSquareIndex
      3  6049				   TEMPORARY_VAR SET	Overlay
      4  6049				   TEMPORARY_OFFSET SET	0
      5  6049				   VAR_BOUNDARY_FlipSquareIndex SET	TEMPORARY_OFFSET
      6  6049				   FUNCTION_NAME SET	FlipSquareIndex
      7  6049					      SUBROUTINE
    130  6049
    131  6049		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    132  6053		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    133  605d
    134  605d				   .SQBASE    SET	90
    135  605d					      REPEAT	8
    136  605d		       00 00		      .byte.b	0,0
    137  605d				   .SQX       SET	2
    138  605f					      REPEAT	8
    139  605f		       5c		      .byte.b	(.SQBASE+.SQX)
    140  605f				   .SQX       SET	.SQX + 1
    138  605f					      REPEND
    139  6060		       5d		      .byte.b	(.SQBASE+.SQX)
    140  6060				   .SQX       SET	.SQX + 1
    138  6060					      REPEND
    139  6061		       5e		      .byte.b	(.SQBASE+.SQX)
    140  6061				   .SQX       SET	.SQX + 1
    138  6061					      REPEND
    139  6062		       5f		      .byte.b	(.SQBASE+.SQX)
    140  6062				   .SQX       SET	.SQX + 1
    138  6062					      REPEND
    139  6063		       60		      .byte.b	(.SQBASE+.SQX)
    140  6063				   .SQX       SET	.SQX + 1
    138  6063					      REPEND
    139  6064		       61		      .byte.b	(.SQBASE+.SQX)
    140  6064				   .SQX       SET	.SQX + 1
    138  6064					      REPEND
    139  6065		       62		      .byte.b	(.SQBASE+.SQX)
    140  6065				   .SQX       SET	.SQX + 1
    138  6065					      REPEND
    139  6066		       63		      .byte.b	(.SQBASE+.SQX)
    140  6066				   .SQX       SET	.SQX + 1
    141  6067					      REPEND
    142  6067				   .SQBASE    SET	.SQBASE - 10
    135  6067					      REPEND
    136  6067		       00 00		      .byte.b	0,0
    137  6067				   .SQX       SET	2
    138  6069					      REPEAT	8
    139  6069		       52		      .byte.b	(.SQBASE+.SQX)
    140  6069				   .SQX       SET	.SQX + 1
    138  6069					      REPEND
    139  606a		       53		      .byte.b	(.SQBASE+.SQX)
    140  606a				   .SQX       SET	.SQX + 1
    138  606a					      REPEND
    139  606b		       54		      .byte.b	(.SQBASE+.SQX)
    140  606b				   .SQX       SET	.SQX + 1
    138  606b					      REPEND
    139  606c		       55		      .byte.b	(.SQBASE+.SQX)
    140  606c				   .SQX       SET	.SQX + 1
    138  606c					      REPEND
    139  606d		       56		      .byte.b	(.SQBASE+.SQX)
    140  606d				   .SQX       SET	.SQX + 1
    138  606d					      REPEND
    139  606e		       57		      .byte.b	(.SQBASE+.SQX)
    140  606e				   .SQX       SET	.SQX + 1
    138  606e					      REPEND
    139  606f		       58		      .byte.b	(.SQBASE+.SQX)
    140  606f				   .SQX       SET	.SQX + 1
    138  606f					      REPEND
    139  6070		       59		      .byte.b	(.SQBASE+.SQX)
    140  6070				   .SQX       SET	.SQX + 1
    141  6071					      REPEND
    142  6071				   .SQBASE    SET	.SQBASE - 10
    135  6071					      REPEND
    136  6071		       00 00		      .byte.b	0,0
    137  6071				   .SQX       SET	2
    138  6073					      REPEAT	8
    139  6073		       48		      .byte.b	(.SQBASE+.SQX)
    140  6073				   .SQX       SET	.SQX + 1
    138  6073					      REPEND
    139  6074		       49		      .byte.b	(.SQBASE+.SQX)
    140  6074				   .SQX       SET	.SQX + 1
    138  6074					      REPEND
    139  6075		       4a		      .byte.b	(.SQBASE+.SQX)
    140  6075				   .SQX       SET	.SQX + 1
    138  6075					      REPEND
    139  6076		       4b		      .byte.b	(.SQBASE+.SQX)
    140  6076				   .SQX       SET	.SQX + 1
    138  6076					      REPEND
    139  6077		       4c		      .byte.b	(.SQBASE+.SQX)
    140  6077				   .SQX       SET	.SQX + 1
    138  6077					      REPEND
    139  6078		       4d		      .byte.b	(.SQBASE+.SQX)
    140  6078				   .SQX       SET	.SQX + 1
    138  6078					      REPEND
    139  6079		       4e		      .byte.b	(.SQBASE+.SQX)
    140  6079				   .SQX       SET	.SQX + 1
    138  6079					      REPEND
    139  607a		       4f		      .byte.b	(.SQBASE+.SQX)
    140  607a				   .SQX       SET	.SQX + 1
    141  607b					      REPEND
    142  607b				   .SQBASE    SET	.SQBASE - 10
    135  607b					      REPEND
    136  607b		       00 00		      .byte.b	0,0
    137  607b				   .SQX       SET	2
    138  607d					      REPEAT	8
    139  607d		       3e		      .byte.b	(.SQBASE+.SQX)
    140  607d				   .SQX       SET	.SQX + 1
    138  607d					      REPEND
    139  607e		       3f		      .byte.b	(.SQBASE+.SQX)
    140  607e				   .SQX       SET	.SQX + 1
    138  607e					      REPEND
    139  607f		       40		      .byte.b	(.SQBASE+.SQX)
    140  607f				   .SQX       SET	.SQX + 1
    138  607f					      REPEND
    139  6080		       41		      .byte.b	(.SQBASE+.SQX)
    140  6080				   .SQX       SET	.SQX + 1
    138  6080					      REPEND
    139  6081		       42		      .byte.b	(.SQBASE+.SQX)
    140  6081				   .SQX       SET	.SQX + 1
    138  6081					      REPEND
    139  6082		       43		      .byte.b	(.SQBASE+.SQX)
    140  6082				   .SQX       SET	.SQX + 1
    138  6082					      REPEND
    139  6083		       44		      .byte.b	(.SQBASE+.SQX)
    140  6083				   .SQX       SET	.SQX + 1
    138  6083					      REPEND
    139  6084		       45		      .byte.b	(.SQBASE+.SQX)
    140  6084				   .SQX       SET	.SQX + 1
    141  6085					      REPEND
    142  6085				   .SQBASE    SET	.SQBASE - 10
    135  6085					      REPEND
    136  6085		       00 00		      .byte.b	0,0
    137  6085				   .SQX       SET	2
    138  6087					      REPEAT	8
    139  6087		       34		      .byte.b	(.SQBASE+.SQX)
    140  6087				   .SQX       SET	.SQX + 1
    138  6087					      REPEND
    139  6088		       35		      .byte.b	(.SQBASE+.SQX)
    140  6088				   .SQX       SET	.SQX + 1
    138  6088					      REPEND
    139  6089		       36		      .byte.b	(.SQBASE+.SQX)
    140  6089				   .SQX       SET	.SQX + 1
    138  6089					      REPEND
    139  608a		       37		      .byte.b	(.SQBASE+.SQX)
    140  608a				   .SQX       SET	.SQX + 1
    138  608a					      REPEND
    139  608b		       38		      .byte.b	(.SQBASE+.SQX)
    140  608b				   .SQX       SET	.SQX + 1
    138  608b					      REPEND
    139  608c		       39		      .byte.b	(.SQBASE+.SQX)
    140  608c				   .SQX       SET	.SQX + 1
    138  608c					      REPEND
    139  608d		       3a		      .byte.b	(.SQBASE+.SQX)
    140  608d				   .SQX       SET	.SQX + 1
    138  608d					      REPEND
    139  608e		       3b		      .byte.b	(.SQBASE+.SQX)
    140  608e				   .SQX       SET	.SQX + 1
    141  608f					      REPEND
    142  608f				   .SQBASE    SET	.SQBASE - 10
    135  608f					      REPEND
    136  608f		       00 00		      .byte.b	0,0
    137  608f				   .SQX       SET	2
    138  6091					      REPEAT	8
    139  6091		       2a		      .byte.b	(.SQBASE+.SQX)
    140  6091				   .SQX       SET	.SQX + 1
    138  6091					      REPEND
    139  6092		       2b		      .byte.b	(.SQBASE+.SQX)
    140  6092				   .SQX       SET	.SQX + 1
    138  6092					      REPEND
    139  6093		       2c		      .byte.b	(.SQBASE+.SQX)
    140  6093				   .SQX       SET	.SQX + 1
    138  6093					      REPEND
    139  6094		       2d		      .byte.b	(.SQBASE+.SQX)
    140  6094				   .SQX       SET	.SQX + 1
    138  6094					      REPEND
    139  6095		       2e		      .byte.b	(.SQBASE+.SQX)
    140  6095				   .SQX       SET	.SQX + 1
    138  6095					      REPEND
    139  6096		       2f		      .byte.b	(.SQBASE+.SQX)
    140  6096				   .SQX       SET	.SQX + 1
    138  6096					      REPEND
    139  6097		       30		      .byte.b	(.SQBASE+.SQX)
    140  6097				   .SQX       SET	.SQX + 1
    138  6097					      REPEND
    139  6098		       31		      .byte.b	(.SQBASE+.SQX)
    140  6098				   .SQX       SET	.SQX + 1
    141  6099					      REPEND
    142  6099				   .SQBASE    SET	.SQBASE - 10
    135  6099					      REPEND
    136  6099		       00 00		      .byte.b	0,0
    137  6099				   .SQX       SET	2
    138  609b					      REPEAT	8
    139  609b		       20		      .byte.b	(.SQBASE+.SQX)
    140  609b				   .SQX       SET	.SQX + 1
    138  609b					      REPEND
    139  609c		       21		      .byte.b	(.SQBASE+.SQX)
    140  609c				   .SQX       SET	.SQX + 1
    138  609c					      REPEND
    139  609d		       22		      .byte.b	(.SQBASE+.SQX)
    140  609d				   .SQX       SET	.SQX + 1
    138  609d					      REPEND
    139  609e		       23		      .byte.b	(.SQBASE+.SQX)
    140  609e				   .SQX       SET	.SQX + 1
    138  609e					      REPEND
    139  609f		       24		      .byte.b	(.SQBASE+.SQX)
    140  609f				   .SQX       SET	.SQX + 1
    138  609f					      REPEND
    139  60a0		       25		      .byte.b	(.SQBASE+.SQX)
    140  60a0				   .SQX       SET	.SQX + 1
    138  60a0					      REPEND
    139  60a1		       26		      .byte.b	(.SQBASE+.SQX)
    140  60a1				   .SQX       SET	.SQX + 1
    138  60a1					      REPEND
    139  60a2		       27		      .byte.b	(.SQBASE+.SQX)
    140  60a2				   .SQX       SET	.SQX + 1
    141  60a3					      REPEND
    142  60a3				   .SQBASE    SET	.SQBASE - 10
    135  60a3					      REPEND
    136  60a3		       00 00		      .byte.b	0,0
    137  60a3				   .SQX       SET	2
    138  60a5					      REPEAT	8
    139  60a5		       16		      .byte.b	(.SQBASE+.SQX)
    140  60a5				   .SQX       SET	.SQX + 1
    138  60a5					      REPEND
    139  60a6		       17		      .byte.b	(.SQBASE+.SQX)
    140  60a6				   .SQX       SET	.SQX + 1
    138  60a6					      REPEND
    139  60a7		       18		      .byte.b	(.SQBASE+.SQX)
    140  60a7				   .SQX       SET	.SQX + 1
    138  60a7					      REPEND
    139  60a8		       19		      .byte.b	(.SQBASE+.SQX)
    140  60a8				   .SQX       SET	.SQX + 1
    138  60a8					      REPEND
    139  60a9		       1a		      .byte.b	(.SQBASE+.SQX)
    140  60a9				   .SQX       SET	.SQX + 1
    138  60a9					      REPEND
    139  60aa		       1b		      .byte.b	(.SQBASE+.SQX)
    140  60aa				   .SQX       SET	.SQX + 1
    138  60aa					      REPEND
    139  60ab		       1c		      .byte.b	(.SQBASE+.SQX)
    140  60ab				   .SQX       SET	.SQX + 1
    138  60ab					      REPEND
    139  60ac		       1d		      .byte.b	(.SQBASE+.SQX)
    140  60ac				   .SQX       SET	.SQX + 1
    141  60ad					      REPEND
    142  60ad				   .SQBASE    SET	.SQBASE - 10
    143  60ad					      REPEND
    144  60ad
    145  60ad
    146  60ad							;---------------------------------------------------------------------------------------------------
    147  60ad							; Vectors to the position value tables for each piece
    148  60ad
    149  60ad					      MAC	posval
    150  60ad					      .byte	0
    151  60ad					      .byte	{1}(PositionalValue_PAWN - 22)
    152  60ad					      .byte	{1}(PositionalValue_PAWN - 22)
    153  60ad					      .byte	{1}(PositionalValue_KNIGHT - 22)
    154  60ad					      .byte	{1}(PositionalValue_BISHOP - 22)
    155  60ad					      .byte	{1}(PositionalValue_ROOK - 22)
    156  60ad					      .byte	{1}(PositionalValue_QUEEN - 22)
    157  60ad					      .byte	{1}(PositionalValue_KING_MIDGAME - 22)
    158  60ad					      ENDM
    159  60ad
      0  60ad					      ALLOCATE	PosValVecLO, 8
      0  60ad					      OPTIONAL_PAGEBREAK	"Table", 8
     12  60ad					      LIST	ON
      0  60ad					      DEF	PosValVecLO
      1  60ad				   BANK_PosValVecLO SET	_CURRENT_BANK
      2  60ad				   PosValVecLO
      3  60ad				   TEMPORARY_VAR SET	Overlay
      4  60ad				   TEMPORARY_OFFSET SET	0
      5  60ad				   VAR_BOUNDARY_PosValVecLO SET	TEMPORARY_OFFSET
      6  60ad				   FUNCTION_NAME SET	PosValVecLO
      7  60ad					      SUBROUTINE
      0  60ad					      POSVAL	<
      1  60ad		       00		      .byte.b	0
      2  60ae		       a7		      .byte.b	<(PositionalValue_PAWN - 22)
      3  60af		       a7		      .byte.b	<(PositionalValue_PAWN - 22)
      4  60b0		       43		      .byte.b	<(PositionalValue_KNIGHT - 22)
      5  60b1		       91		      .byte.b	<(PositionalValue_BISHOP - 22)
      6  60b2		       df		      .byte.b	<(PositionalValue_ROOK - 22)
      7  60b3		       2d		      .byte.b	<(PositionalValue_QUEEN - 22)
      8  60b4		       7b		      .byte.b	<(PositionalValue_KING_MIDGAME - 22)
      0  60b5					      ALLOCATE	PosValVecHI, 8
      0  60b5					      OPTIONAL_PAGEBREAK	"Table", 8
     12  60b5					      LIST	ON
      0  60b5					      DEF	PosValVecHI
      1  60b5				   BANK_PosValVecHI SET	_CURRENT_BANK
      2  60b5				   PosValVecHI
      3  60b5				   TEMPORARY_VAR SET	Overlay
      4  60b5				   TEMPORARY_OFFSET SET	0
      5  60b5				   VAR_BOUNDARY_PosValVecHI SET	TEMPORARY_OFFSET
      6  60b5				   FUNCTION_NAME SET	PosValVecHI
      7  60b5					      SUBROUTINE
      0  60b5					      POSVAL	>
      1  60b5		       00		      .byte.b	0
      2  60b6		       f0		      .byte.b	>(PositionalValue_PAWN - 22)
      3  60b7		       f0		      .byte.b	>(PositionalValue_PAWN - 22)
      4  60b8		       f1		      .byte.b	>(PositionalValue_KNIGHT - 22)
      5  60b9		       f1		      .byte.b	>(PositionalValue_BISHOP - 22)
      6  60ba		       f1		      .byte.b	>(PositionalValue_ROOK - 22)
      7  60bb		       f2		      .byte.b	>(PositionalValue_QUEEN - 22)
      8  60bc		       f2		      .byte.b	>(PositionalValue_KING_MIDGAME - 22)
    164  60bd
    165  60bd
    166  60bd							;---------------------------------------------------------------------------------------------------
    167  60bd
    168  60bd				   PositionalValue_PAWN
    169  60bd
    170  60bd		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 0, 0, 0	; 20-29
    171  60c5		       00 00 05 0a*	      .byte.b	0,0, 5, 10, 10,-20,-20, 10, 10, 5	; 30-
    172  60cf		       00 00 05 fb*	      .byte.b	0,0, 5, -5,-10, 0, 0,-10, -5, 5	; 40-
    173  60d9		       00 00 00 00*	      .byte.b	0,0, 0, 0, 0, 20, 20, 0, 0, 0	; 50-
    174  60e3		       00 00 05 05*	      .byte.b	0,0, 5, 5, 10, 35, 35, 10, 5, 5	; 60-
    175  60ed		       00 00 0a 0a*	      .byte.b	0,0, 10, 10, 20, 40, 40, 20, 10, 10	; 70-
    176  60f7		       00 00 32 32*	      .byte.b	0,0, 50, 50, 50, 50, 50, 50, 50, 50	; 80-
    177  6101		       00 00 00 00*	      .byte.b	0,0, 0, 0, 0, 0, 0, 0, 0, 0	; 90-
    178  610b
    179  610b				   PositionalValue_PAWN_BLACK
    180  610b
    181  610b		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 0, 0, 0	; 20-29
    182  6113		       00 00 32 32*	      .byte.b	0,0, 50, 50, 50, 50, 50, 50, 50, 50	; 30-
    183  611d		       00 00 0a 0a*	      .byte.b	0,0, 10, 10, 20, 40, 40, 20, 10, 10	; 40-
    184  6127		       00 00 05 05*	      .byte.b	0,0, 5, 5, 10, 35, 35, 10, 5, 5	; 50-
    185  6131		       00 00 00 00*	      .byte.b	0,0, 0, 0, 0, 20, 20, 0, 0, 0	; 60-
    186  613b		       00 00 05 fb*	      .byte.b	0,0, 5, -5,-10, 0, 0,-10, -5, 5	; 70-
    187  6145		       00 00 05 0a*	      .byte.b	0,0, 5, 10, 10,-20,-20, 10, 10, 5	; 80-
    188  614f		       00 00 00 00*	      .byte.b	0,0, 0, 0, 0, 0, 0, 0, 0, 0	; 90-
    189  6159
    190  6159							;---------------------------------------------------------------------------------------------------
    191  6159
    192  6159				   PositionalValue_KNIGHT
    193  6159
    194  6159		       ce ec e2 e2*	      .byte.b	-50,-20,-30,-30,-30,-30,-20,-50
    195  6161		       00 00 d8 ec*	      .byte.b	0,0, -40,-20, 0, 5, 5, 0,-20,-40
    196  616b		       00 00 e2 00*	      .byte.b	0,0, -30, 0, 0, 15, 15, 0, 0,-30
    197  6175		       00 00 e2 00*	      .byte.b	0,0, -30, 0, 15, 40, 40, 15, 0,-30
    198  617f		       00 00 e2 05*	      .byte.b	0,0, -30, 5, 15, 40, 40, 15, 5,-30
    199  6189		       00 00 e2 00*	      .byte.b	0,0, -30, 0, 10, 15, 15, 10, 0,-30
    200  6193		       00 00 d8 ec*	      .byte.b	0,0, -40,-20, 30, 0, 0, 30,-20,-40
    201  619d		       00 00 ce d8*	      .byte.b	0,0, -50,-40,-30,-30,-30,-30,-40,-50
    202  61a7
    203  61a7
    204  61a7							;---------------------------------------------------------------------------------------------------
    205  61a7
    206  61a7				   PositionalValue_BISHOP
    207  61a7
    208  61a7		       ec f6 f6 f6*	      .byte.b	-20,-10,-10,-10,-10,-10,-10,-20
    209  61af		       00 00 f6 05*	      .byte.b	0,0, -10, 5, 0, 0, 0, 0, 5,-10
    210  61b9		       00 00 f6 0a*	      .byte.b	0,0, -10, 10, 10, 10, 10, 10, 10,-10
    211  61c3		       00 00 f6 00*	      .byte.b	0,0, -10, 0, 10, 10, 10, 10, 0,-10
    212  61cd		       00 00 f6 05*	      .byte.b	0,0, -10, 5, 5, 10, 10, 5, 5,-10
    213  61d7		       00 00 f6 00*	      .byte.b	0,0, -10, 0, 5, 10, 10, 5, 0,-10
    214  61e1		       00 00 f6 00*	      .byte.b	0,0, -10, 0, 0, 0, 0, 0, 0,-10
    215  61eb		       00 00 ec f6*	      .byte.b	0,0, -20,-10,-10,-10,-10,-10,-10,-20
    216  61f5
    217  61f5
    218  61f5							;---------------------------------------------------------------------------------------------------
    219  61f5
    220  61f5				   PositionalValue_ROOK
    221  61f5
    222  61f5		       00 00 00 05*	      .byte.b	0, 0, 0, 5, 5, 0, 0, 0
    223  61fd		       00 00 fb 00*	      .byte.b	0,0, -5, 0, 0, 0, 0, 0, 0, -5
    224  6207		       00 00 fb 00*	      .byte.b	0,0, -5, 0, 0, 0, 0, 0, 0, -5
    225  6211		       00 00 fb 00*	      .byte.b	0,0, -5, 0, 0, 0, 0, 0, 0, -5
    226  621b		       00 00 fb 00*	      .byte.b	0,0, -5, 0, 0, 0, 0, 0, 0, -5
    227  6225		       00 00 fb 00*	      .byte.b	0,0, -5, 0, 0, 0, 0, 0, 0, -5
    228  622f		       00 00 05 0a*	      .byte.b	0,0, 5, 10, 10, 10, 10, 10, 10, 5
    229  6239		       00 00 00 00*	      .byte.b	0,0, 0, 0, 0, 0, 0, 0, 0, 0
    230  6243
    231  6243
    232  6243							;---------------------------------------------------------------------------------------------------
    233  6243
    234  6243				   PositionalValue_QUEEN
    235  6243
    236  6243		       ec f6 f6 fb*	      .byte.b	-20,-10,-10, -5, -5,-10,-10,-20
    237  624b		       00 00 f6 00*	      .byte.b	0,0, -10, 0, 5, 0, 0, 0, 0,-10
    238  6255		       00 00 f6 05*	      .byte.b	0,0, -10, 5, 5, 5, 5, 5, 0,-10
    239  625f		       00 00 00 00*	      .byte.b	0,0, 0, 0, 5, 5, 5, 5, 0, -5
    240  6269		       00 00 fb 00*	      .byte.b	0,0, -5, 0, 15, 15, 15, 15, 0, -5
    241  6273		       00 00 f6 00*	      .byte.b	0,0, -10, 0, 25, 25, 25, 25, 0,-10
    242  627d		       00 00 f6 00*	      .byte.b	0,0, -10, 0, 0, 0, 0, 0, 0,-10
    243  6287		       00 00 ec f6*	      .byte.b	0,0, -20,-10,-10, -5, -5,-10,-10,-20
    244  6291
    245  6291
    246  6291							;---------------------------------------------------------------------------------------------------
    247  6291
    248  6291				   PositionalValue_KING_MIDGAME
    249  6291
    250  6291		       14 1e 0a 00*	      .byte.b	20, 30, 10, 0, 0, 10, 30, 20
    251  6299		       00 00 14 14*	      .byte.b	0,0, 20, 20, 0, 0, 0, 0, 20, 20
    252  62a3		       00 00 f6 ec*	      .byte.b	0,0, -10,-20,-20,-20,-20,-20,-20,-10
    253  62ad		       00 00 ec e2*	      .byte.b	0,0, -20,-30,-30,-40,-40,-30,-30,-20
    254  62b7		       00 00 e2 d8*	      .byte.b	0,0, -30,-40,-40,-50,-50,-40,-40,-30
    255  62c1		       00 00 e2 d8*	      .byte.b	0,0, -30,-40,-40,-50,-50,-40,-40,-30
    256  62cb		       00 00 e2 d8*	      .byte.b	0,0, -30,-40,-40,-50,-50,-40,-40,-30
    257  62d5		       00 00 e2 d8*	      .byte.b	0,0, -30,-40,-40,-50,-50,-40,-40,-30
    258  62df
    259  62df
    260  62df							;---------------------------------------------------------------------------------------------------
    261  62df
    262  62df				   PositionalValue_KING_ENDGAME
    263  62df
    264  62df		       ce e2 e2 e2*	      .byte.b	-50,-30,-30,-30,-30,-30,-30,-50
    265  62e7		       00 00 e2 e2*	      .byte.b	0,0, -30,-30, 0, 0, 0, 0,-30,-30
    266  62f1		       00 00 e2 f6*	      .byte.b	0,0, -30,-10, 20, 30, 30, 20,-10,-30
    267  62fb		       00 00 e2 f6*	      .byte.b	0,0, -30,-10, 30, 40, 40, 30,-10,-30
    268  6305		       00 00 e2 f6*	      .byte.b	0,0, -30,-10, 30, 40, 40, 30,-10,-30
    269  630f		       00 00 e2 f6*	      .byte.b	0,0, -30,-10, 20, 30, 30, 20,-10,-30
    270  6319		       00 00 e2 ec*	      .byte.b	0,0, -30,-20,-10, 0, 0,-10,-20,-30
    271  6323		       00 00 ce d8*	      .byte.b	0,0, -50,-40,-30,-20,-20,-30,-40,-50
    272  632d
    273  632d
      0  632d					      CHECK_BANK_SIZE	"BANK_EVAL"
      1  632d		       03 2d	   .TEMP      =	* - BANK_START
 BANK_EVAL (2K) SIZE =  $32d , FREE= $4d3
      2  632d					      ECHO	"BANK_EVAL", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  632d				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  632d				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  632d				  -	      ERR
      6  632d					      endif
    275  632d
    276  632d							;---------------------------------------------------------------------------------------------------
    277  632d							; EOF
------- FILE ./chess.asm
------- FILE BANK_SPEAK.asm LEVEL 2 PASS 5
      0  632d					      include	"BANK_SPEAK.asm"
      0  632d					      NEWBANK	SPEAK
      1  6876 ????				      SEG	SPEAK
      2  6800					      ORG	ORIGIN
      3  6800					      RORG	$F000
      4  6800				   BANK_START SET	*
      5  6800				   SPEAK      SET	ORIGIN / 2048
      6  6800				   ORIGIN     SET	ORIGIN + 2048
      7  6800				   _CURRENT_BANK SET	SPEAK
      2  6800
      3  6800							;
      4  6800							; speakjet.inc
      5  6800							;
      6  6800							;
      7  6800							; AtariVox Speech Synth Driver
      8  6800							;
      9  6800							; By Alex Herbert, 2004
     10  6800							;
     11  6800
     12  6800
     13  6800
     14  6800
     15  6800							; Constants
     16  6800
     17  6800
     18  6800		       00 01	   SERIAL_OUTMASK equ	$01
     19  6800		       00 02	   SERIAL_RDYMASK equ	$02
     20  6800
     21  6800
     22  6800
     23  6800							;---------------------------------------------------------------------------------------------------
     24  6800
     25  6800					      mac	speak
     26  6800
     27  6800					      lda	#<{1}
     28  6800					      sta	speech_addr
     29  6800					      lda	#>{1}
     30  6800					      sta	speech_addr+1
     31  6800
     32  6800					      endm
     33  6800
     34  6800
     35  6800							;---------------------------------------------------------------------------------------------------
     36  6800
      0  6800					      DEF	ShutYourMouth
      1  6800				   BANK_ShutYourMouth SET	_CURRENT_BANK
      2  6800				   ShutYourMouth
      3  6800				   TEMPORARY_VAR SET	Overlay
      4  6800				   TEMPORARY_OFFSET SET	0
      5  6800				   VAR_BOUNDARY_ShutYourMouth SET	TEMPORARY_OFFSET
      6  6800				   FUNCTION_NAME SET	ShutYourMouth
      7  6800					      SUBROUTINE
     38  6800					      SUBROUTINE
     39  6800
      0  6800					      REFER	Reset
      1  6800				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  6800				  -TEMPORARY_VAR SET	VAREND_Reset
      3  6800					      ENDIF
      0  6800					      VEND	ShutYourMouth
      1  6800				  -	      IFNCONST	ShutYourMouth
      2  6800				  -	      ECHO	"Incorrect VEND label", ShutYourMouth
      3  6800				  -	      ERR
      4  6800					      ENDIF
      5  6800		       00 a2	   VAREND_ShutYourMouth =	TEMPORARY_VAR
     42  6800
      0  6800					      SPEAK	silence_speech
      1  6800
      2  6800		       a9 74		      lda	#<silence_speech
      3  6802		       85 9c		      sta	speech_addr
      4  6804		       a9 f0		      lda	#>silence_speech
      5  6806		       85 9d		      sta	speech_addr+1
      6  6808
     44  6808		       60		      rts
     45  6809
     46  6809
     47  6809							;---------------------------------------------------------------------------------------------------
     48  6809
      0  6809					      DEF	GameSpeak
      1  6809				   BANK_GameSpeak SET	_CURRENT_BANK
      2  6809				   GameSpeak
      3  6809				   TEMPORARY_VAR SET	Overlay
      4  6809				   TEMPORARY_OFFSET SET	0
      5  6809				   VAR_BOUNDARY_GameSpeak SET	TEMPORARY_OFFSET
      6  6809				   FUNCTION_NAME SET	GameSpeak
      7  6809					      SUBROUTINE
     50  6809					      SUBROUTINE
     51  6809
      0  6809					      REFER	Reset
      1  6809				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  6809				  -TEMPORARY_VAR SET	VAREND_Reset
      3  6809					      ENDIF
      0  6809					      VAR	__speak_temp, 1
      1  6809		       00 a2	   __speak_temp =	TEMPORARY_VAR
      2  6809				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6809
      4  6809				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6809				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6809				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6809					      ENDIF
      8  6809				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6809				  -	      ECHO	"Temporary Variable", __speak_temp, "overflow!"
     10  6809				  -	      ERR
     11  6809					      ENDIF
     12  6809					      LIST	ON
      0  6809					      VEND	GameSpeak
      1  6809				  -	      IFNCONST	GameSpeak
      2  6809				  -	      ECHO	"Incorrect VEND label", GameSpeak
      3  6809				  -	      ERR
      4  6809					      ENDIF
      5  6809		       00 a3	   VAREND_GameSpeak =	TEMPORARY_VAR
     55  6809
     56  6809		       a0 00		      ldy	#0
     57  680b		       b1 9c		      lda	(speech_addr),y
     58  680d		       c9 ff		      cmp	#$ff
     59  680f		       d0 08		      bne	.talk
     60  6811
      0  6811					      SPEAK	left_speech
      1  6811
      2  6811		       a9 4a		      lda	#<left_speech
      3  6813		       85 9c		      sta	speech_addr
      4  6815		       a9 f0		      lda	#>left_speech
      5  6817		       85 9d		      sta	speech_addr+1
      6  6819
     62  6819
     63  6819
     64  6819				   .talk
     65  6819
     66  6819							; check buffer-full status
     67  6819
     68  6819		       ad 80 02 	      lda	SWCHA
     69  681c		       29 02		      and	#SERIAL_RDYMASK
     70  681e		       f0 29		      beq	.speech_done
     71  6820
     72  6820		       a0 00		      ldy	#0
     73  6822		       b1 9c		      lda	(speech_addr),y
     74  6824
     75  6824		       49 ff		      eor	#$ff
     76  6826		       f0 21		      beq	.speech_done
     77  6828		       85 a2		      sta	__speak_temp
     78  682a
     79  682a		       e6 9c		      inc	speech_addr
     80  682c		       d0 02		      bne	.incaddr_skip
     81  682e		       e6 9d		      inc	speech_addr+1
     82  6830				   .incaddr_skip
     83  6830
     84  6830		       38		      sec		; start bit
     85  6831				   .byteout_loop
     86  6831
     87  6831							; put carry flag into bit 0 of SWACNT, perserving other bits
     88  6831
     89  6831		       ad 81 02 	      lda	SWACNT	; 4
     90  6834		       29 fe		      and	#$fe	; 2 6
     91  6836		       69 00		      adc	#$00	; 2 8
     92  6838		       8d 81 02 	      sta	SWACNT	; 4 12
     93  683b
     94  683b							; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
     95  683b
     96  683b		       c0 09		      cpy	#$09	; 2 14
     97  683d		       f0 0a		      beq	.speech_done	; 2 16
     98  683f		       c8		      iny		; 2 18
     99  6840
    100  6840
    101  6840		       a2 07		      ldx	#$07	; 2 20
    102  6842		       ca	   .delay_loop dex		; { 2
    103  6843		       d0 fd		      bne	.delay_loop	;   3
    104  6845							; } = 7 * 5 - 1 = 34
    105  6845							; @54
    106  6845
    107  6845		       46 a2		      lsr	__speak_temp	; 5 59
    108  6847		       10 e8		      bpl	.byteout_loop	; 3 62 cycles for loop
    109  6849
    110  6849		       60	   .speech_done rts
    111  684a
    112  684a
    113  684a							;---------------------------------------------------------------------------------------------------
    114  684a
    115  684a							; Speech Data
    116  684a
    117  684a							;Dec. SpeakJet Use
    118  684a							;----- ------------------
    119  684a							;000 Pause 0
    120  684a							;001 Pause 1
    121  684a							;002 Pause 2
    122  684a							;003 Pause 3
    123  684a							;004 Pause 4
    124  684a							;005 Pause 5
    125  684a							;006 Pause 6
    126  684a							;007 Play Next Sound Fast
    127  684a							;008 Play Next Sound Slow
    128  684a							;014 Play Next Sound High Tone
    129  684a							;015 Play Next Sound Low Tone
    130  684a							;016 Wait
    131  684a							;020 Volume, X
    132  684a							;021 Speed, X
    133  684a							;022 Pitch, X
    134  684a							;023 Bend, X
    135  684a							;024 PortCtr, X
    136  684a							;025 Port, X
    137  684a							;026 Repeat, X
    138  684a							;028 Call Phrase, X
    139  684a							;029 Goto Phrase, X
    140  684a							;030 Delay, X
    141  684a							;031 Reset Defaults
    142  684a							;--------------------------------------------------------
    143  684a							;032 Reserved
    144  684a							;- to -
    145  684a							;127
    146  684a							;--------------------------------------------------------
    147  684a							;128 127 Sound codes
    148  684a							;- to -
    149  684a							;254
    150  684a							;--------------------------------------------------------
    151  684a							;255 End of Phrase.
    152  684a
    153  684a
    154  684a
    155  684a				   left_speech
    156  684a
    157  684a
    158  684a		       1f		      dc.b	31
    159  684b							;	  dc.b $ff
    160  684b
    161  684b
    162  684b
    163  684b
    164  684b
    165  684b
    166  684b
    167  684b		       15 74		      dc.b	21,116	; speed 116
    168  684d		       17 04		      dc.b	23,4	; bend, 4
    169  684f		       16 37		      dc.b	22,55	; pitch, 55
    170  6851		       b6		      dc.b	182	;CH
    171  6852		       81		      dc.b	129	;IH
    172  6853		       c2		      dc.b	194	;KE
    173  6854		       83		      dc.b	131	;EH
    174  6855		       8d		      dc.b	141	;NE
    175  6856		       02		      dc.b	2	; pause 2
    176  6857		       02		      dc.b	2	; pause 2
    177  6858
    178  6858
    179  6858		       08		      dc.b	8	; play next sound slow
    180  6859		       ba		      dc.b	186	;FF
    181  685a		       07		      dc.b	7	; play fast
    182  685b		       9b		      dc.b	155	;OHIY
    183  685c		       04		      dc.b	4	; pause 4
    184  685d		       bf		      dc.b	191	;TT
    185  685e		       06		      dc.b	6	; pause 6
    186  685f		       91		      dc.b	145	;LE
    187  6860		       07		      dc.b	7	; fast
    188  6861		       88		      dc.b	136	;AW
    189  6862		       07		      dc.b	7	; fast
    190  6863		       9b		      dc.b	155	;OHIY
    191  6864		       c4		      dc.b	196	;EK
    192  6865		       06		      dc.b	6	; pause 6
    193  6866		       9a		      dc.b	154	;EYIY
    194  6867		       80		      dc.b	128	;IY
    195  6868		       06		      dc.b	6	; pause 6
    196  6869		       94		      dc.b	148	;GR?
    197  686a		       07		      dc.b	7	; fast
    198  686b		       89		      dc.b	137	;OW
    199  686c		       07		      dc.b	7	; fast
    200  686d		       a4		      dc.b	164	;OWW
    201  686e		       12		      dc.b	18	;???
    202  686f		       ab		      dc.b	171	;BO
    203  6870		       88		      dc.b	136	;AW
    204  6871		       bf		      dc.b	191	;TT
    205  6872		       1f		      dc.b	31	; reset defaults
    206  6873		       ff		      dc.b	$ff
    207  6874
    208  6874
    209  6874				   silence_speech
    210  6874
    211  6874
    212  6874
    213  6874		       1f		      dc.b	31	;31
    214  6875
    215  6875
    216  6875		       ff		      dc.b	$ff
    217  6876
      0  6876					      CHECK_BANK_SIZE	"BANK_SPEAK"
      1  6876		       00 76	   .TEMP      =	* - BANK_START
 BANK_SPEAK (2K) SIZE =  $76 , FREE= $78a
      2  6876					      ECHO	"BANK_SPEAK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  6876				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  6876				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  6876				  -	      ERR
      6  6876					      endif
    219  6876
    220  6876				  -	      if	0
    221  6876				  -typedef    enum
    222  6876				  -	      182
    223  6876				  -	      183	Pause0 = 0, ///< Pause 0ms
    224  6876				  -	      184	Pause1 = 1, ///< Pause 100ms
    225  6876				  -	      185	Pause2 = 2, ///< Pause 200ms
    226  6876				  -	      186	Pause3 = 3, ///< Pause 700ms
    227  6876				  -	      187	Pause4 = 4, ///< Pause 30ms
    228  6876				  -	      188	Pause5 = 5, ///< Pause 60ms
    229  6876				  -	      189	Pause6 = 6, ///< Pause 90ms
    230  6876				  -	      190	Fast = 7, ///< Next phoneme at 0.5 speed
    231  6876				  -	      191	Slow = 8, ///< Next phoneme at 1.5 speed
    232  6876				  -	      192	Stress = 14, ///< Next phoneme with some stress
    233  6876				  -	      193	Relax = 15, ///< Next phoneme with relaxation
    234  6876				  -	      194	Wait = 16, ///< Stops and waits for a Start (see manual)
    235  6876				  -	      195	Soft = 18, ///< Stops and waits for a Start (see manual)
    236  6876				  -	      196	Volume = 20, ///< Next octet is volume 0 to 127. Default 96
    237  6876				  -	      197	Speed = 21, ///< Next octet is speed 0 to 127. Default 114
    238  6876				  -	      198	Pitch = 22, ///< Next octet is pitch in Hz = to 255
    239  6876				  -	      199	Bend = 23, ///< Next octet is frequency bend to 15. Default is 5
    240  6876				  -	      200	PortCtr = 24, ///< Next octet is port control value. See manual. Default is 7
    241  6876				  -	      201	Port = 25, ///< Next octet is Port Output Value. See manual. Default is 0
    242  6876				  -	      202	Repeat = 26, ///< Next octet is repeat count. 0 to 255
    243  6876				  -	      203	CallPhrase = 28, ///< Next octet is EEPROM phrase to play and return. See manual.
    244  6876				  -	      204	GotoPhrase = 29, ///< Next octet is EEPROM phgrase to go to. See manual.
    245  6876				  -	      205	Delay = 30, ///< Next octet is delay in multiples of 10ms. 0 to 255.
    246  6876				  -	      206	Reset = 31, ///< Reset Volume Speed, Pitch, Bend to defaults.
    247  6876				  -	      207
    248  6876				  -	      208	// 32 to 127 reserved
    249  6876				  -	      209
    250  6876				  -	      210	// 128 to 254 Sound codes
    251  6876				  -	      211	// Phonemes, standard names
    252  6876				  -	      212	Phoneme_IY = 128, ///< 70ms Voiced Long Vowel
    253  6876				  -	      213	Phoneme_IH = 129, ///< 70ms Voiced Long Vowel
    254  6876				  -	      214	Phoneme_EY = 130, ///< 70ms Voiced Long Vowel
    255  6876				  -	      215	Phoneme_EH = 131, ///< 70ms Voiced Long Vowel
    256  6876				  -	      216	Phoneme_AY = 132, ///< 70ms Voiced Long Vowel
    257  6876				  -	      217	Phoneme_AX = 133, ///< 70ms Voiced Long Vowel
    258  6876				  -	      218	Phoneme_UX = 134, ///< 70ms Voiced Long Vowel
    259  6876				  -	      219	Phoneme_OH = 135, ///< 70ms Voiced Long Vowel
    260  6876				  -	      220	Phoneme_AW = 136, ///< 70ms Voiced Long Vowel
    261  6876				  -	      221	Phoneme_OW = 137, ///< 70ms Voiced Long Vowel
    262  6876				  -	      222	Phoneme_UH = 138, ///< 70ms Voiced Long Vowel
    263  6876				  -	      223	Phoneme_UW = 139, ///< 70ms Voiced Long Vowel
    264  6876				  -	      224	Phoneme_MM = 140, ///< 70ms Voiced Nasal
    265  6876				  -	      225	Phoneme_NE = 141, ///< 70ms Voiced Nasal
    266  6876				  -	      226	Phoneme_NO = 142, ///< 70ms Voiced Nasal
    267  6876				  -	      227	Phoneme_NGE = 143, ///< 70ms Voiced Nasal
    268  6876				  -	      228	Phoneme_NGO = 144, ///< 70ms Voiced Nasal
    269  6876				  -	      229	Phoneme_LE = 145, ///< 70ms Voiced Resonate
    270  6876				  -	      230	Phoneme_LO = 146, ///< 70ms Voiced Resonate
    271  6876				  -	      231	Phoneme_WW = 147, ///< 70ms Voiced Resonate
    272  6876				  -	      232	Phoneme_RR = 149, //148? ///< 70ms Voiced Resonate
    273  6876				  -	      233	Phoneme_IYRR = 149, ///< 200ms Voiced R Color Vowel
    274  6876				  -	      234	Phoneme_EYRR = 150, ///< 200ms Voiced R Color Vowel
    275  6876				  -	      235	Phoneme_AXRR = 151, ///< 190ms Voiced R Color Vowel
    276  6876				  -	      236	Phoneme_AWRR = 152, ///< 200ms Voiced R Color Vowel
    277  6876				  -	      237	Phoneme_OWRR = 153, ///< 185ms Voiced R Color Vowel
    278  6876				  -	      238	Phoneme_EYIY = 154, ///< 165ms Voiced Diphthong
    279  6876				  -	      239	Phoneme_OHIY = 155, ///< 200ms Voiced Diphthong
    280  6876				  -	      240	Phoneme_OWIY = 156, ///< 225ms Voiced Diphthong
    281  6876				  -	      241	Phoneme_OHIH = 157, ///< 185ms Voiced Diphthong
    282  6876				  -	      242	Phoneme_IYEH = 158, ///< 170ms Voiced Diphthong
    283  6876				  -	      243	Phoneme_EHLE = 159, ///< 140ms Voiced Diphthong
    284  6876				  -	      244	Phoneme_IYUW = 160, ///< 180ms Voiced Diphthong
    285  6876				  -	      245	Phoneme_AXUW = 161, ///< 170ms Voiced Diphthong
    286  6876				  -	      246	Phoneme_IHWW = 162, ///< 170ms Voiced Diphthong
    287  6876				  -	      247	Phoneme_AYWW = 163, ///< 200ms Voiced Diphthong
    288  6876				  -	      248	Phoneme_OWWW = 164, ///< 131ms Voiced Diphthong
    289  6876				  -	      249	Phoneme_JH = 165, ///< 70ms Voiced Affricate
    290  6876				  -	      250	Phoneme_VV = 166, ///< 70ms Voiced Fricative
    291  6876				  -	      251	Phoneme_ZZ = 167, ///< 70ms Voiced Fricative
    292  6876				  -	      252	Phoneme_ZH = 168, ///< 70ms Voiced Fricative
    293  6876				  -	      253	Phoneme_DH = 169, ///< 70ms Voiced Fricative
    294  6876				  -	      254	Phoneme_BE = 170, ///< 45ms Voiced Stop
    295  6876				  -	      255	Phoneme_BO = 171, ///< 45ms Voiced Stop
    296  6876				  -	      256	Phoneme_EB = 172, ///< 10ms Voiced Stop
    297  6876				  -	      257	Phoneme_OB = 173, ///< 10ms Voiced Stop
    298  6876				  -	      258	Phoneme_DE = 174, ///< 45ms Voiced Stop
    299  6876				  -	      259	Phoneme_DO = 174, ///< 45ms Voiced Stop
    300  6876				  -	      260	Phoneme_ED = 176, ///< 10ms Voiced Stop
    301  6876				  -	      261	Phoneme_OD = 177, ///< 10ms Voiced Stop
    302  6876				  -	      262	Phoneme_GE = 178, ///< 55ms Voiced Stop
    303  6876				  -	      263	Phoneme_GO = 179, ///< 55ms Voiced Stop
    304  6876				  -	      264	Phoneme_EG = 180, ///< 55ms Voiced Stop
    305  6876				  -	      265	Phoneme_OG = 181, ///< 55ms Voiced Stop
    306  6876				  -	      266	Phoneme_CH = 182, ///< 70ms Voiceless Affricate
    307  6876				  -	      267	Phoneme_HE = 183, ///< 70ms Voiceless Fricative
    308  6876				  -	      268	Phoneme_HO = 184, ///< 70ms Voiceless Fricative
    309  6876				  -	      269	Phoneme_WH = 185, ///< 70ms Voiceless Fricative
    310  6876				  -	      270	Phoneme_FF = 186, ///< 70ms Voiceless Fricative
    311  6876				  -	      271	Phoneme_SE = 187, ///< 40ms Voiceless Fricative
    312  6876				  -	      272	Phoneme_SO = 188, ///< 40ms Voiceless Fricative
    313  6876				  -	      273	Phoneme_SH = 189, ///< 50ms Voiceless Fricative
    314  6876				  -	      274	Phoneme_TH = 190, ///< 40ms Voiceless Fricative
    315  6876				  -	      275	Phoneme_TT = 191, ///< 50ms Voiceless Stop
    316  6876				  -	      276	Phoneme_TU = 192, ///< 70ms Voiceless Stop
    317  6876				  -	      277	Phoneme_TS = 193, ///< 170ms Voiceless Stop
    318  6876				  -	      278	Phoneme_KE = 194, ///< 55ms Voiceless Stop
    319  6876				  -	      279	Phoneme_KO = 195, ///< 55ms Voiceless Stop
    320  6876				  -	      280	Phoneme_EK = 196, ///< 55ms Voiceless Stop
    321  6876				  -	      281	Phoneme_OK = 197, ///< 45ms Voiceless Stop
    322  6876				  -	      282	Phoneme_PE = 198, ///< 99ms Voiceless Stop
    323  6876				  -	      283	Phoneme_PO = 199, ///< 99ms Voiceless Stop
    324  6876				  -	      284	// Robot sound
    325  6876				  -	      285	Sound_R0 = 200, ///< 80ms Robot
    326  6876				  -	      286	Sound_R1 = 201, ///< 80ms Robot
    327  6876				  -	      287	Sound_R2 = 202, ///< 80ms Robot
    328  6876				  -	      288	Sound_R3 = 203, ///< 80ms Robot
    329  6876				  -	      289	Sound_R4 = 204, ///< 80ms Robot
    330  6876				  -	      290	Sound_R5 = 205, ///< 80ms Robot
    331  6876				  -	      291	Sound_R6 = 206, ///< 80ms Robot
    332  6876				  -	      292	Sound_R7 = 207, ///< 80ms Robot
    333  6876				  -	      293	Sound_R8 = 208, ///< 80ms Robot
    334  6876				  -	      294	Sound_R9 = 209, ///< 80ms Robot
    335  6876				  -	      295	// Alarm sound
    336  6876				  -	      296	Sound_A0 = 210, ///< 300ms Alarm
    337  6876				  -	      297	Sound_A1 = 211, ///< 101ms Alarm
    338  6876				  -	      298	Sound_A2 = 212, ///< 102ms Alarm
    339  6876				  -	      299	Sound_A3 = 213, ///< 540ms Alarm
    340  6876				  -	      300	Sound_A4 = 214, ///< 530ms Alarm
    341  6876				  -	      301	Sound_A5 = 215, ///< 500ms Alarm
    342  6876				  -	      302	Sound_A6 = 216, ///< 135ms Alarm
    343  6876				  -	      303	Sound_A7 = 217, ///< 600ms Alarm
    344  6876				  -	      304	Sound_A8 = 218, ///< 300ms Alarm
    345  6876				  -	      305	Sound_A9 = 219, ///< 250ms Alarm
    346  6876				  -	      306	// Beeps
    347  6876				  -	      307	Sound_B0 = 220, ///< 200ms Beep
    348  6876				  -	      308	Sound_B1 = 221, ///< 270ms Beep
    349  6876				  -	      309	Sound_B2 = 222, ///< 280ms Beep
    350  6876				  -	      310	Sound_B3 = 223, ///< 260ms Beep
    351  6876				  -	      311	Sound_B4 = 224, ///< 300ms Beep
    352  6876				  -	      312	Sound_B5 = 225, ///< 100ms Beep
    353  6876				  -	      313	Sound_B6 = 226, ///< 104ms Beep
    354  6876				  -	      314	Sound_B7 = 227, ///< 100ms Beep
    355  6876				  -	      315	Sound_B8 = 228, ///< 270ms Beep
    356  6876				  -	      316	Sound_B9 = 229, ///< 262ms Beep
    357  6876				  -	      317	// Biological
    358  6876				  -	      318	Sound_C0 = 230, ///< 160ms Biological
    359  6876				  -	      319	Sound_C1 = 231, ///< 300ms Biological
    360  6876				  -	      320	Sound_C2 = 232, ///< 182ms Biological
    361  6876				  -	      321	Sound_C3 = 233, ///< 120ms Biological
    362  6876				  -	      322	Sound_C4 = 234, ///< 175ms Biological
    363  6876				  -	      323	Sound_C5 = 235, ///< 350ms Biological
    364  6876				  -	      324	Sound_C6 = 236, ///< 160ms Biological
    365  6876				  -	      325	Sound_C7 = 237, ///< 260ms Biological
    366  6876				  -	      326	Sound_C8 = 238, ///< 95ms Biological
    367  6876				  -	      327	Sound_C9 = 239, ///< 75ms Biological
    368  6876				  -	      328	// DTMF
    369  6876				  -	      329	DTMF_0 = 240, ///< DTMF 0 95ms
    370  6876				  -	      330	DTMF_1 = 241, ///< DTMF 1 95ms
    371  6876				  -	      331	DTMF_2 = 242, ///< DTMF 2 95ms
    372  6876				  -	      332	DTMF_3 = 243, ///< DTMF 3 95ms
    373  6876				  -	      333	DTMF_4 = 244, ///< DTMF 4 95ms
    374  6876				  -	      334	DTMF_5 = 245, ///< DTMF 5 95ms
    375  6876				  -	      335	DTMF_6 = 246, ///< DTMF 6 95ms
    376  6876				  -	      336	DTMF_7 = 247, ///< DTMF 7 95ms
    377  6876				  -	      337	DTMF_8 = 248, ///< DTMF 8 95ms
    378  6876				  -	      338	DTMF_9 = 249, ///< DTMF 9 95ms
    379  6876				  -	      339	DTMF_STAR = 250, ///< DTMF * 95ms
    380  6876				  -	      340	DTMF_HASH = 251, ///< DTMF # 95ms
    381  6876				  -	      341	// Miscellaneous
    382  6876				  -	      342	Sound_M0 = 252, ///< Sonar ping 125ms
    383  6876				  -	      343	Sound_M1 = 253, ///< Pistol shot 250ms
    384  6876				  -	      344	Sound_M2 = 254, ///< WOW 530ms
    385  6876				  -	      345
    386  6876				  -	      346	EndOfPhrase = 255, ///< End of phrase marker. Required at end of code arrays
    387  6876				  -	      347
    388  6876				  -	      348	CommandCodes	;
    389  6876				  -	      349
    390  6876					      endif
------- FILE ./chess.asm
    539  6876
    540  6876							; MUST BE LAST...
------- FILE BANK_FIXED.asm LEVEL 2 PASS 5
      0  6876					      include	"BANK_FIXED.asm"
      1  6876							; Chess
      2  6876							; Copyright (c) 2019-2020 Andrew Davie
      3  6876							; andrew@taswegian.com
      4  6876
      5  6876
      6  6876							;---------------------------------------------------------------------------------------------------
      7  6876							;#########################################  FIXED BANK  ############################################
      8  6876							;---------------------------------------------------------------------------------------------------
      9  6876
     10  6876				   ORIGIN     SET	FIXED_BANK
     11  6876
      0  6876					      NEWBANK	THE_FIXED_BANK
      1  7f07 ????				      SEG	THE_FIXED_BANK
      2  7800					      ORG	ORIGIN
      3  7800					      RORG	$F000
      4  7800				   BANK_START SET	*
      5  7800				   THE_FIXED_BANK SET	ORIGIN / 2048
      6  7800				   ORIGIN     SET	ORIGIN + 2048
      7  7800				   _CURRENT_BANK SET	THE_FIXED_BANK
     13  7800					      RORG	$f800
     14  7800
     15  7800							;---------------------------------------------------------------------------------------------------
     16  7800
      0  7800					      DEF	Reset
      1  7800				   BANK_Reset SET	_CURRENT_BANK
      2  7800				   Reset
      3  7800				   TEMPORARY_VAR SET	Overlay
      4  7800				   TEMPORARY_OFFSET SET	0
      5  7800				   VAR_BOUNDARY_Reset SET	TEMPORARY_OFFSET
      6  7800				   FUNCTION_NAME SET	Reset
      7  7800					      SUBROUTINE
     18  7800					      SUBROUTINE
     19  7800
      0  7800					      VEND	Reset
      1  7800				  -	      IFNCONST	Reset
      2  7800				  -	      ECHO	"Incorrect VEND label", Reset
      3  7800				  -	      ERR
      4  7800					      ENDIF
      5  7800		       00 a2	   VAREND_Reset =	TEMPORARY_VAR
     21  7800
     22  7800		       78		      sei
     23  7801		       d8		      cld
     24  7802		       a2 ff		      ldx	#$FF
     25  7804		       9a		      txs
     26  7805
     27  7805
     28  7805							; See if we can come up with something 'random' for startup
     29  7805
     30  7805		       ac 84 02 	      ldy	INTIM
     31  7808		       d0 02		      bne	.toR
     32  780a		       a0 9a		      ldy	#$9A
     33  780c		       84 81	   .toR       sty	rnd
     34  780e
      0  780e					      JSROM	Cart_Init
      1  780e
      2  780e		       a9 00		      lda	#BANK_Cart_Init
      3  7810		       85 3f		      sta	SET_BANK
      4  7812		       20 04 f0 	      jsr	Cart_Init
     36  7815							;JSROM TitleScreen
     37  7815
     38  7815							;JSROM ShutYourMouth
     39  7815
     40  7815							; Move a copy of the row bank template to the first 8 banks of RAM
     41  7815							; and then terminate the draw subroutine by substituting in a RTS on the last one
     42  7815
      0  7815					      JSROM_SAFE	SetupBanks
      1  7815
      2  7815
      3  7815
      4  7815		       a9 0b		      lda	#BANK_SetupBanks
      5  7817		       85 8b		      sta	savedBank
      6  7819		       85 3f		      sta	SET_BANK
      7  781b		       20 54 f3 	      jsr	SetupBanks
     44  781e
     45  781e							; Patch the final row's "loop" to a RTS
     46  781e
     47  781e		       a2 07		      ldx	#7
     48  7820		       86 3e		      stx	SET_BANK_RAM
     49  7822		       a9 60		      lda	#$60	; "rts"
      0  7824					      sta@RAM	SELFMOD_RTS_ON_LAST_ROW
      1  7824		       8d 00 f6 	      sta	[RAM]+SELFMOD_RTS_ON_LAST_ROW
     51  7827
     52  7827							;lda currentPly
     53  7827							;sta SET_BANK_RAM
     54  7827							;jsr NewPlyInitialise		  ; must be called at the start of every new ply
     55  7827
     56  7827		       20 c4 fb 	      jsr	InitialisePieceSquares
     57  782a
     58  782a		       a9 00		      lda	#WHITE
     59  782c		       85 97		      sta	sideToMove
     60  782e
     61  782e							; Now the board is "living" in RAM (along with support code) we can do stuff with it
     62  782e
     63  782e							;---------------------------------------------------------------------------------------------------
     64  782e
     65  782e							;RESYNC
     66  782e				   .StartFrame
     67  782e
     68  782e
     69  782e							; START OF FRAME
     70  782e
     71  782e		       a9 0e		      lda	#%1110	; VSYNC ON
     72  7830		       85 42	   .loopVSync3 sta	WSYNC
     73  7832		       85 40		      sta	VSYNC
     74  7834		       4a		      lsr
     75  7835		       d0 f9		      bne	.loopVSync3	; branch until VYSNC has been reset
     76  7837
     77  7837		       a0 2f		      ldy	#TIME_PART_1
     78  7839		       8c 96 02 	      sty	TIM64T
     79  783c
     80  783c							; LOTS OF PROCESSING TIME - USE IT
     81  783c
     82  783c		       a2 00		      ldx	#0
     83  783e		       86 41		      stx	VBLANK
     84  7840
     85  7840		       20 9d f8 	      jsr	AiStateMachine
     86  7843
     87  7843				  -	      if	ASSERTS
     88  7843				  -			; Catch timer expired already
     89  7843				  -			;		      bit TIMINT
     90  7843				  -			;.whoops	      bmi .whoops
     91  7843					      endif
     92  7843
     93  7843
     94  7843		       2c 85 02    .wait      bit	TIMINT
     95  7846		       10 fb		      bpl	.wait
     96  7848
     97  7848
     98  7848
     99  7848							; START OF VISIBLE SCANLINES
    100  7848
    101  7848		       85 42		      sta	WSYNC
    102  784a
    103  784a		       20 9c f8 	      jsr	_rts
    104  784d		       20 9c f8 	      jsr	_rts
    105  7850		       20 9c f8 	      jsr	_rts
    106  7853		       20 9c f8 	      jsr	_rts
      0  7856					      SLEEP	3
      1  7856				   .CYCLES    SET	3
      2  7856
      3  7856				  -	      IF	.CYCLES < 2
      4  7856				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  7856				  -	      ERR
      6  7856					      ENDIF
      7  7856
      8  7856					      IF	.CYCLES & 1
      9  7856					      IFNCONST	NO_ILLEGAL_OPCODES
     10  7856		       04 00		      nop	0
     11  7858				  -	      ELSE
     12  7858				  -	      bit	VSYNC
     13  7858					      ENDIF
     14  7858				   .CYCLES    SET	.CYCLES - 3
     15  7858					      ENDIF
     16  7858
     17  7858				  -	      REPEAT	.CYCLES / 2
     18  7858				  -	      nop
     19  7858					      REPEND
    108  7858
    109  7858		       a2 00		      ldx	#0
    110  785a		       86 41		      stx	VBLANK
    111  785c
    112  785c		       86 3e		      stx	SET_BANK_RAM
    113  785e		       20 03 f2 	      jsr	DrawRow	; draw the ENTIRE visible screen!
    114  7861
    115  7861
    116  7861
    117  7861
    118  7861		       a9 00		      lda	#0
    119  7863		       85 4d		      sta	PF0
    120  7865		       85 4e		      sta	PF1
    121  7867		       85 4f		      sta	PF2
    122  7869		       85 5b		      sta	GRP0
    123  786b		       85 5c		      sta	GRP1
    124  786d
    125  786d		       a9 42		      lda	#%01000010	; bit6 is not required
    126  786f		       85 41		      sta	VBLANK	; end of screen - enter blanking
    127  7871
    128  7871
    129  7871							; END OF VISIBLE SCREEN
    130  7871							; HERE'S SOME TIME TO DO STUFF
    131  7871
    132  7871		       a9 2e		      lda	#TIME_PART_2
    133  7873		       8d 96 02 	      sta	TIM64T
    134  7876
      0  7876					      JSROM	GameSpeak
      1  7876
      2  7876		       a9 0d		      lda	#BANK_GameSpeak
      3  7878		       85 3f		      sta	SET_BANK
      4  787a		       20 09 f0 	      jsr	GameSpeak
    136  787d		       20 9d f8 	      jsr	AiStateMachine
    137  7880
      0  7880					      JSROM	PositionSprites
      1  7880
      2  7880		       a9 06		      lda	#BANK_PositionSprites
      3  7882		       85 3f		      sta	SET_BANK
      4  7884		       20 00 f4 	      jsr	PositionSprites
    139  7887
    140  7887
    141  7887
    142  7887							; "draw" sprite shapes into row banks
    143  7887
    144  7887		       a2 07		      ldx	#7
    145  7889		       86 3e	   zapem      stx	SET_BANK_RAM
    146  788b		       20 a6 f2 	      jsr	WriteBlank
    147  788e		       ca		      dex
    148  788f		       10 f8		      bpl	zapem
    149  7891
    150  7891		       20 cf f2 	      jsr	WriteCursor
    151  7894
    152  7894
    153  7894		       2c 85 02    Waitforit  bit	TIMINT
    154  7897		       10 fb		      bpl	Waitforit
    155  7899
    156  7899		       4c 2e f8 	      jmp	.StartFrame
    157  789c
    158  789c
    159  789c		       60	   _rts       rts
    160  789d
    161  789d
    162  789d							;---------------------------------------------------------------------------------------------------
    163  789d
      0  789d					      DEF	AiStateMachine
      1  789d				   BANK_AiStateMachine SET	_CURRENT_BANK
      2  789d				   AiStateMachine
      3  789d				   TEMPORARY_VAR SET	Overlay
      4  789d				   TEMPORARY_OFFSET SET	0
      5  789d				   VAR_BOUNDARY_AiStateMachine SET	TEMPORARY_OFFSET
      6  789d				   FUNCTION_NAME SET	AiStateMachine
      7  789d					      SUBROUTINE
    165  789d					      SUBROUTINE
    166  789d
      0  789d					      REFER	Reset
      1  789d				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  789d				  -TEMPORARY_VAR SET	VAREND_Reset
      3  789d					      ENDIF
      0  789d					      VEND	AiStateMachine
      1  789d				  -	      IFNCONST	AiStateMachine
      2  789d				  -	      ECHO	"Incorrect VEND label", AiStateMachine
      3  789d				  -	      ERR
      4  789d					      ENDIF
      5  789d		       00 a2	   VAREND_AiStateMachine =	TEMPORARY_VAR
    169  789d
      0  789d					      JSROM	AiSetupVectors
      1  789d
      2  789d		       a9 06		      lda	#BANK_AiSetupVectors
      3  789f		       85 3f		      sta	SET_BANK
      4  78a1		       20 69 f0 	      jsr	AiSetupVectors
    171  78a4							;bcs .exit		      ; not enough time
    172  78a4		       85 3f		      sta	SET_BANK
    173  78a6		       6c ea 00 	      jmp	(__ptr)	; TODO: OR branch back to squeeze cycles
    174  78a9
    175  78a9		       60	   .exit      rts
    176  78aa
    177  78aa
    178  78aa							;---------------------------------------------------------------------------------------------------
    179  78aa
      0  78aa					      DEF	CallClear
      1  78aa				   BANK_CallClear SET	_CURRENT_BANK
      2  78aa				   CallClear
      3  78aa				   TEMPORARY_VAR SET	Overlay
      4  78aa				   TEMPORARY_OFFSET SET	0
      5  78aa				   VAR_BOUNDARY_CallClear SET	TEMPORARY_OFFSET
      6  78aa				   FUNCTION_NAME SET	CallClear
      7  78aa					      SUBROUTINE
    181  78aa					      SUBROUTINE
    182  78aa
      0  78aa					      REFER	aiClearEachRow
      1  78aa				  -	      IF	VAREND_aiClearEachRow > TEMPORARY_VAR
      2  78aa				  -TEMPORARY_VAR SET	VAREND_aiClearEachRow
      3  78aa					      ENDIF
      0  78aa					      VEND	CallClear
      1  78aa				  -	      IFNCONST	CallClear
      2  78aa				  -	      ECHO	"Incorrect VEND label", CallClear
      3  78aa				  -	      ERR
      4  78aa					      ENDIF
      5  78aa		       00 a2	   VAREND_CallClear =	TEMPORARY_VAR
    185  78aa
    186  78aa							; No transient variable dependencies/calls
    187  78aa
    188  78aa		       84 3e		      sty	SET_BANK_RAM
    189  78ac		       20 90 f1 	      jsr	ClearRowBitmap
    190  78af		       60		      rts
    191  78b0
    192  78b0							;---------------------------------------------------------------------------------------------------
    193  78b0
    194  78b0
      0  78b0					      DEF	aiDrawEntireBoard
      1  78b0				   BANK_aiDrawEntireBoard SET	_CURRENT_BANK
      2  78b0				   aiDrawEntireBoard
      3  78b0				   TEMPORARY_VAR SET	Overlay
      4  78b0				   TEMPORARY_OFFSET SET	0
      5  78b0				   VAR_BOUNDARY_aiDrawEntireBoard SET	TEMPORARY_OFFSET
      6  78b0				   FUNCTION_NAME SET	aiDrawEntireBoard
      7  78b0					      SUBROUTINE
    196  78b0					      SUBROUTINE
    197  78b0
      0  78b0					      REFER	AiStateMachine
      1  78b0				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  78b0				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  78b0					      ENDIF
      0  78b0					      VEND	aiDrawEntireBoard
      1  78b0				  -	      IFNCONST	aiDrawEntireBoard
      2  78b0				  -	      ECHO	"Incorrect VEND label", aiDrawEntireBoard
      3  78b0				  -	      ERR
      4  78b0					      ENDIF
      5  78b0		       00 a2	   VAREND_aiDrawEntireBoard =	TEMPORARY_VAR
    200  78b0
    201  78b0
    202  78b0		       ad 84 02 	      lda	INTIM
    203  78b3		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    204  78b5		       90 2c		      bcc	.exit
    205  78b7
    206  78b7		       a9 08		      lda	#RAMBANK_MOVES_RAM
    207  78b9		       85 3e		      sta	SET_BANK_RAM
    208  78bb		       a4 80		      ldy	squareToDraw
    209  78bd		       b9 15 f0 	      lda	ValidSquare,y
    210  78c0		       30 1d		      bmi	.isablank2
    211  78c2
    212  78c2		       b9 79 f0 	      lda	Board,y
    213  78c5		       f0 13		      beq	.isablank
    214  78c7		       48		      pha
    215  78c8		       a9 00		      lda	#BLANK
      0  78ca					      sta@RAM	Board,y
      1  78ca		       99 79 f4 	      sta	[RAM]+Board,y
    217  78cd
    218  78cd		       20 a4 fc 	      jsr	CopySinglePiece
    219  78d0
    220  78d0		       a9 08		      lda	#RAMBANK_MOVES_RAM
    221  78d2		       85 3e		      sta	SET_BANK_RAM
    222  78d4
    223  78d4		       a4 80		      ldy	squareToDraw
    224  78d6		       68		      pla
      0  78d7					      sta@RAM	Board,y
      1  78d7		       99 79 f4 	      sta	[RAM]+Board,y
    226  78da
      0  78da				   .isablank  PHASE	AI_DrawPart2
      1  78da		       a9 10		      lda	#AI_DrawPart2
      2  78dc		       85 8c		      sta	aiState
    228  78de		       60		      rts
    229  78df
      0  78df				   .isablank2 PHASE	AI_DrawPart3
      1  78df		       a9 11		      lda	#AI_DrawPart3
      2  78e1		       85 8c		      sta	aiState
    231  78e3		       60	   .exit      rts
    232  78e4
    233  78e4							;---------------------------------------------------------------------------------------------------
    234  78e4
      0  78e4					      DEF	aiFlipBuffers
      1  78e4				   BANK_aiFlipBuffers SET	_CURRENT_BANK
      2  78e4				   aiFlipBuffers
      3  78e4				   TEMPORARY_VAR SET	Overlay
      4  78e4				   TEMPORARY_OFFSET SET	0
      5  78e4				   VAR_BOUNDARY_aiFlipBuffers SET	TEMPORARY_OFFSET
      6  78e4				   FUNCTION_NAME SET	aiFlipBuffers
      7  78e4					      SUBROUTINE
    236  78e4					      SUBROUTINE
    237  78e4
      0  78e4					      REFER	AiStateMachine
      1  78e4				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  78e4				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  78e4					      ENDIF
      0  78e4					      VEND	aiFlipBuffers
      1  78e4				  -	      IFNCONST	aiFlipBuffers
      2  78e4				  -	      ECHO	"Incorrect VEND label", aiFlipBuffers
      3  78e4				  -	      ERR
      4  78e4					      ENDIF
      5  78e4		       00 a2	   VAREND_aiFlipBuffers =	TEMPORARY_VAR
    240  78e4
    241  78e4							; Initialise for a new move
    242  78e4
    243  78e4		       a5 95		      lda	currentPly
    244  78e6		       85 3e		      sta	SET_BANK_RAM
    245  78e8
    246  78e8		       20 3b f2 	      jsr	NewPlyInitialise	; zap movelist for this ply
    247  78eb
      0  78eb					      PHASE	AI_GenerateMoves
      1  78eb		       a9 13		      lda	#AI_GenerateMoves
      2  78ed		       85 8c		      sta	aiState
    249  78ef		       60		      rts
    250  78f0
    251  78f0
    252  78f0							;---------------------------------------------------------------------------------------------------
    253  78f0
      0  78f0					      DEF	InitialiseMoveGeneration
      1  78f0				   BANK_InitialiseMoveGeneration SET	_CURRENT_BANK
      2  78f0				   InitialiseMoveGeneration
      3  78f0				   TEMPORARY_VAR SET	Overlay
      4  78f0				   TEMPORARY_OFFSET SET	0
      5  78f0				   VAR_BOUNDARY_InitialiseMoveGeneration SET	TEMPORARY_OFFSET
      6  78f0				   FUNCTION_NAME SET	InitialiseMoveGeneration
      7  78f0					      SUBROUTINE
    255  78f0					      SUBROUTINE
    256  78f0
      0  78f0					      VEND	InitialiseMoveGeneration
      1  78f0				  -	      IFNCONST	InitialiseMoveGeneration
      2  78f0				  -	      ECHO	"Incorrect VEND label", InitialiseMoveGeneration
      3  78f0				  -	      ERR
      4  78f0					      ENDIF
      5  78f0		       00 a2	   VAREND_InitialiseMoveGeneration =	TEMPORARY_VAR
    258  78f0
    259  78f0		       a5 95		      lda	currentPly
    260  78f2		       85 3e		      sta	SET_BANK_RAM
    261  78f4
    262  78f4		       20 3b f2 	      jsr	NewPlyInitialise
    263  78f7
    264  78f7		       a5 8b		      lda	savedBank
    265  78f9		       85 3f		      sta	SET_BANK
    266  78fb		       60		      rts
    267  78fc
    268  78fc
    269  78fc							;---------------------------------------------------------------------------------------------------
    270  78fc
      0  78fc					      DEF	newGen
      1  78fc				   BANK_newGen SET	_CURRENT_BANK
      2  78fc				   newGen
      3  78fc				   TEMPORARY_VAR SET	Overlay
      4  78fc				   TEMPORARY_OFFSET SET	0
      5  78fc				   VAR_BOUNDARY_newGen SET	TEMPORARY_OFFSET
      6  78fc				   FUNCTION_NAME SET	newGen
      7  78fc					      SUBROUTINE
    272  78fc					      SUBROUTINE
    273  78fc
      0  78fc					      REFER	selectmove
      1  78fc					      IF	VAREND_selectmove > TEMPORARY_VAR
      2  78fc				   TEMPORARY_VAR SET	VAREND_selectmove
      3  78fc					      ENDIF
      0  78fc					      VEND	newGen
      1  78fc				  -	      IFNCONST	newGen
      2  78fc				  -	      ECHO	"Incorrect VEND label", newGen
      3  78fc				  -	      ERR
      4  78fc					      ENDIF
      5  78fc		       00 a9	   VAREND_newGen =	TEMPORARY_VAR
    276  78fc
    277  78fc
    278  78fc		       20 3b f2 	      jsr	NewPlyInitialise
    279  78ff		       20 2f f9 	      jsr	GenerateAllMoves
    280  7902
    281  7902							;	  lda savedBank
    282  7902							;	  sta SET_BANK_RAM
    283  7902
    284  7902		       60		      rts
    285  7903
      0  7903					      DEF	aiGenerateMoves
      1  7903				   BANK_aiGenerateMoves SET	_CURRENT_BANK
      2  7903				   aiGenerateMoves
      3  7903				   TEMPORARY_VAR SET	Overlay
      4  7903				   TEMPORARY_OFFSET SET	0
      5  7903				   VAR_BOUNDARY_aiGenerateMoves SET	TEMPORARY_OFFSET
      6  7903				   FUNCTION_NAME SET	aiGenerateMoves
      7  7903					      SUBROUTINE
    287  7903					      SUBROUTINE
    288  7903
      0  7903					      REFER	AiStateMachine
      1  7903				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  7903				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  7903					      ENDIF
      0  7903					      VEND	aiGenerateMoves
      1  7903				  -	      IFNCONST	aiGenerateMoves
      2  7903				  -	      ECHO	"Incorrect VEND label", aiGenerateMoves
      3  7903				  -	      ERR
      4  7903					      ENDIF
      5  7903		       00 a2	   VAREND_aiGenerateMoves =	TEMPORARY_VAR
    291  7903
    292  7903							;		      jsr newGen
    293  7903		       20 2f f9 	      jsr	GenerateAllMoves
    294  7906
    295  7906				  -	      if	PVSP
    296  7906				  -	      jmp	.player	;tmp
    297  7906					      endif
    298  7906
    299  7906		       a6 97		      ldx	sideToMove
    300  7908		       10 05		      bpl	.player
    301  790a
    302  790a
      0  790a				   .computer  PHASE	AI_ComputerMove	; computer select move
      1  790a		       a9 14		      lda	#AI_ComputerMove
      2  790c		       85 8c		      sta	aiState
    304  790e		       60		      rts
    305  790f
    306  790f
      0  790f				   .player    PHASE	AI_StartMoveGen
      1  790f		       a9 0a		      lda	#AI_StartMoveGen
      2  7911		       85 8c		      sta	aiState
    308  7913		       60	   .wait      rts
    309  7914
      0  7914					      DEF	aiStepMoveGen
      1  7914				   BANK_aiStepMoveGen SET	_CURRENT_BANK
      2  7914				   aiStepMoveGen
      3  7914				   TEMPORARY_VAR SET	Overlay
      4  7914				   TEMPORARY_OFFSET SET	0
      5  7914				   VAR_BOUNDARY_aiStepMoveGen SET	TEMPORARY_OFFSET
      6  7914				   FUNCTION_NAME SET	aiStepMoveGen
      7  7914					      SUBROUTINE
    311  7914					      SUBROUTINE
    312  7914
      0  7914					      REFER	AiStateMachine
      1  7914				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  7914				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  7914					      ENDIF
      0  7914					      VEND	aiStepMoveGen
      1  7914				  -	      IFNCONST	aiStepMoveGen
      2  7914				  -	      ECHO	"Incorrect VEND label", aiStepMoveGen
      3  7914				  -	      ERR
      4  7914					      ENDIF
      5  7914		       00 a2	   VAREND_aiStepMoveGen =	TEMPORARY_VAR
    315  7914
    316  7914
    317  7914							; Because we're (possibly) running with the screen on, processing time is very short and
    318  7914							; we generate the opponent moves piece by piece. Time isn't really an isssue here, so
    319  7914							; this happens over multiple frames.
    320  7914
    321  7914
    322  7914		       20 2f f9 	      jsr	GenerateAllMoves
    323  7917
    324  7917		       a5 97		      lda	sideToMove
    325  7919		       49 80		      eor	#128
    326  791b		       85 97		      sta	sideToMove
    327  791d
    328  791d		       38		      sec
    329  791e		       a9 00		      lda	#0
    330  7920		       e5 90		      sbc	Evaluation
    331  7922		       85 90		      sta	Evaluation
    332  7924		       a9 00		      lda	#0
    333  7926		       e5 91		      sbc	Evaluation+1
    334  7928		       85 91		      sta	Evaluation+1	; -Evaluation
    335  792a
      0  792a					      PHASE	AI_LookForCheck
      1  792a		       a9 0c		      lda	#AI_LookForCheck
      2  792c		       85 8c		      sta	aiState
    337  792e		       60	   .wait      rts
    338  792f
    339  792f
    340  792f							;---------------------------------------------------------------------------------------------------
    341  792f
    342  792f
      0  792f					      DEF	GenerateAllMoves
      1  792f				   BANK_GenerateAllMoves SET	_CURRENT_BANK
      2  792f				   GenerateAllMoves
      3  792f				   TEMPORARY_VAR SET	Overlay
      4  792f				   TEMPORARY_OFFSET SET	0
      5  792f				   VAR_BOUNDARY_GenerateAllMoves SET	TEMPORARY_OFFSET
      6  792f				   FUNCTION_NAME SET	GenerateAllMoves
      7  792f					      SUBROUTINE
    344  792f					      SUBROUTINE
    345  792f
      0  792f					      REFER	quiesce
      1  792f					      IF	VAREND_quiesce > TEMPORARY_VAR
      2  792f				   TEMPORARY_VAR SET	VAREND_quiesce
      3  792f					      ENDIF
      0  792f					      REFER	alphaBeta
      1  792f				  -	      IF	VAREND_alphaBeta > TEMPORARY_VAR
      2  792f				  -TEMPORARY_VAR SET	VAREND_alphaBeta
      3  792f					      ENDIF
      0  792f					      REFER	aiStepMoveGen
      1  792f				  -	      IF	VAREND_aiStepMoveGen > TEMPORARY_VAR
      2  792f				  -TEMPORARY_VAR SET	VAREND_aiStepMoveGen
      3  792f					      ENDIF
      0  792f					      REFER	aiGenerateMoves
      1  792f				  -	      IF	VAREND_aiGenerateMoves > TEMPORARY_VAR
      2  792f				  -TEMPORARY_VAR SET	VAREND_aiGenerateMoves
      3  792f					      ENDIF
      0  792f					      VAR	__vector, 2
      1  792f		       00 a9	   __vector   =	TEMPORARY_VAR
      2  792f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  792f
      4  792f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  792f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  792f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  792f					      ENDIF
      8  792f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  792f				  -	      ECHO	"Temporary Variable", __vector, "overflow!"
     10  792f				  -	      ERR
     11  792f					      ENDIF
     12  792f					      LIST	ON
      0  792f					      VEND	GenerateAllMoves
      1  792f				  -	      IFNCONST	GenerateAllMoves
      2  792f				  -	      ECHO	"Incorrect VEND label", GenerateAllMoves
      3  792f				  -	      ERR
      4  792f					      ENDIF
      5  792f		       00 ab	   VAREND_GenerateAllMoves =	TEMPORARY_VAR
    352  792f
    353  792f
    354  792f		       a2 64		      ldx	#100
    355  7931		       d0 02		      bne	.next2
    356  7933
    357  7933		       a6 93	   MoveReturn ldx	currentSquare
    358  7935
    359  7935		       a9 08	   .next2     lda	#RAMBANK_MOVES_RAM
    360  7937		       85 3e		      sta	SET_BANK_RAM
    361  7939
    362  7939		       ca	   .next      dex
    363  793a		       e0 16		      cpx	#22
    364  793c		       90 25		      bcc	.exit
    365  793e
    366  793e		       bd 79 f0 	      lda	Board,x
    367  7941		       f0 f6		      beq	.next
    368  7943		       c9 ff		      cmp	#-1
    369  7945		       f0 f2		      beq	.next
    370  7947		       45 97		      eor	sideToMove
    371  7949		       30 ee		      bmi	.next
    372  794b
    373  794b		       86 93		      stx	currentSquare
    374  794d
    375  794d		       45 97		      eor	sideToMove
    376  794f		       29 ef		      and	#~FLAG_CASTLE	; todo: better part of the move, mmh?
    377  7951							;ora #FLAG_MOVED		  ; all moves mark piece as moved!
    378  7951		       85 92		      sta	currentPiece
    379  7953		       29 0f		      and	#PIECE_MASK
    380  7955		       a8		      tay
    381  7956
    382  7956		       b9 68 f9 	      lda	HandlerVectorLO-1,y
    383  7959		       85 a9		      sta	__vector
    384  795b		       b9 6f f9 	      lda	HandlerVectorHI-1,y
    385  795e		       85 aa		      sta	__vector+1
    386  7960		       6c a9 00 	      jmp	(__vector)
    387  7963
    388  7963
    389  7963		       a5 95	   .exit      lda	currentPly	;savedBank
    390  7965		       85 3e		      sta	SET_BANK_RAM
    391  7967		       60		      rts
    392  7968
    393  7968
    394  7968					      MAC	handlevec
    395  7968					      .byte	{1}Handle_WHITE_PAWN	; 1
    396  7968					      .byte	{1}Handle_BLACK_PAWN	; 2
    397  7968					      .byte	{1}Handle_KNIGHT	; 3
    398  7968					      .byte	{1}Handle_BISHOP	; 4
    399  7968					      .byte	{1}Handle_ROOK	; 5
    400  7968					      .byte	{1}Handle_QUEEN	; 6
    401  7968					      .byte	{1}Handle_KING	; 7
    402  7968					      ENDM
    403  7968
    404  7968
      0  7968					      ALLOCATE	Handlers, 15
      0  7968					      OPTIONAL_PAGEBREAK	"Table", 15
     12  7968					      LIST	ON
      0  7968					      DEF	Handlers
      1  7968				   BANK_Handlers SET	_CURRENT_BANK
      2  7968				   Handlers
      3  7968				   TEMPORARY_VAR SET	Overlay
      4  7968				   TEMPORARY_OFFSET SET	0
      5  7968				   VAR_BOUNDARY_Handlers SET	TEMPORARY_OFFSET
      6  7968				   FUNCTION_NAME SET	Handlers
      7  7968					      SUBROUTINE
    406  7968
    407  7968		       00		      .byte.b	0	; dummy to prevent page cross access on index 0
    408  7969
      0  7969				   HandlerVectorLO HANDLEVEC	<
      1  7969		       aa		      .byte.b	<Handle_WHITE_PAWN
      2  796a		       3c		      .byte.b	<Handle_BLACK_PAWN
      3  796b		       44		      .byte.b	<Handle_KNIGHT
      4  796c		       a0		      .byte.b	<Handle_BISHOP
      5  796d		       03		      .byte.b	<Handle_ROOK
      6  796e		       dd		      .byte.b	<Handle_QUEEN
      7  796f		       66		      .byte.b	<Handle_KING
      0  7970				   HandlerVectorHI HANDLEVEC	>
      1  7970		       fa		      .byte.b	>Handle_WHITE_PAWN
      2  7971		       fb		      .byte.b	>Handle_BLACK_PAWN
      3  7972		       f3		      .byte.b	>Handle_KNIGHT
      4  7973		       f1		      .byte.b	>Handle_BISHOP
      5  7974		       f2		      .byte.b	>Handle_ROOK
      6  7975		       f0		      .byte.b	>Handle_QUEEN
      7  7976		       f2		      .byte.b	>Handle_KING
    411  7977
    412  7977							;---------------------------------------------------------------------------------------------------
    413  7977
    414  7977							;TODO...
      0  7977					      DEF	SAFE_LookForCheck
      1  7977				   BANK_SAFE_LookForCheck SET	_CURRENT_BANK
      2  7977				   SAFE_LookForCheck
      3  7977				   TEMPORARY_VAR SET	Overlay
      4  7977				   TEMPORARY_OFFSET SET	0
      5  7977				   VAR_BOUNDARY_SAFE_LookForCheck SET	TEMPORARY_OFFSET
      6  7977				   FUNCTION_NAME SET	SAFE_LookForCheck
      7  7977					      SUBROUTINE
    416  7977					      SUBROUTINE
    417  7977
    418  7977		       a5 95		      lda	currentPly
    419  7979		       85 3e		      sta	SET_BANK_RAM
    420  797b
    421  797b		       ac d7 f1 	      ldy	moveIndex
    422  797e		       30 0f		      bmi	.failed
    423  7980
    424  7980		       be 4a f0    .scan      ldx	MoveTo,y
    425  7983		       bd 79 f0 	      lda	Board,x
    426  7986		       29 0f		      and	#PIECE_MASK
    427  7988		       c9 07		      cmp	#KING
    428  798a		       f0 04		      beq	.inCheck	; --> CS too
    429  798c		       88		      dey
    430  798d		       10 f1		      bpl	.scan
    431  798f
    432  798f		       18	   .failed    clc
    433  7990
    434  7990		       a5 8b	   .inCheck   lda	savedBank	; CS or CC
    435  7992		       85 3f		      sta	SET_BANK
    436  7994		       60		      rts
    437  7995
    438  7995
    439  7995							;---------------------------------------------------------------------------------------------------
    440  7995
      0  7995					      DEF	aiComputerMove
      1  7995				   BANK_aiComputerMove SET	_CURRENT_BANK
      2  7995				   aiComputerMove
      3  7995				   TEMPORARY_VAR SET	Overlay
      4  7995				   TEMPORARY_OFFSET SET	0
      5  7995				   VAR_BOUNDARY_aiComputerMove SET	TEMPORARY_OFFSET
      6  7995				   FUNCTION_NAME SET	aiComputerMove
      7  7995					      SUBROUTINE
    442  7995					      SUBROUTINE
    443  7995
      0  7995					      REFER	AiStateMachine
      1  7995				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  7995				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  7995					      ENDIF
      0  7995					      VEND	aiComputerMove
      1  7995				  -	      IFNCONST	aiComputerMove
      2  7995				  -	      ECHO	"Incorrect VEND label", aiComputerMove
      3  7995				  -	      ERR
      4  7995					      ENDIF
      5  7995		       00 a2	   VAREND_aiComputerMove =	TEMPORARY_VAR
    446  7995
    447  7995							; Choose one of the moves
    448  7995
    449  7995							;		      lda currentPly
    450  7995
    451  7995		       a9 09		      lda	#RAMBANK_PLY
    452  7997		       85 95		      sta	currentPly
    453  7999		       85 3e		      sta	SET_BANK_RAM	; switch in movelist
    454  799b		       85 8b		      sta	savedBank
    455  799d
    456  799d		       a9 ff		      lda	#-1
    457  799f		       cd d7 f1 	      cmp	moveIndex
    458  79a2		       f0 11		      beq	.halted	; no valid moves
    459  79a4
    460  79a4							;sta fromX12
    461  79a4		       85 87		      sta	originX12
    462  79a6		       85 86		      sta	toX12
    463  79a8
    464  79a8		       a5 97		      lda	sideToMove
    465  79aa		       10 05		      bpl	.notComputer
    466  79ac
    467  79ac
    468  79ac							;ldx #2
    469  79ac							;jsr selectmove
    470  79ac				   sorter		;jsr Sort
    471  79ac
    472  79ac
    473  79ac		       a2 04		      ldx	#4	; 3 ply search!!!
    474  79ae		       20 b1 f2 	      jsr	selectmove
    475  79b1							;jsr MoveViaListAtPly
    476  79b1
    477  79b1
      0  79b1				   .notComputer PHASE	AI_MoveIsSelected
      1  79b1		       a9 15		      lda	#AI_MoveIsSelected
      2  79b3		       85 8c		      sta	aiState
    479  79b5		       60	   .halted    rts
    480  79b6
    481  79b6
    482  79b6							;---------------------------------------------------------------------------------------------------
    483  79b6
      0  79b6					      DEF	AdjustMaterialPositionalValue
      1  79b6				   BANK_AdjustMaterialPositionalValue SET	_CURRENT_BANK
      2  79b6				   AdjustMaterialPositionalValue
      3  79b6				   TEMPORARY_VAR SET	Overlay
      4  79b6				   TEMPORARY_OFFSET SET	0
      5  79b6				   VAR_BOUNDARY_AdjustMaterialPositionalValue SET	TEMPORARY_OFFSET
      6  79b6				   FUNCTION_NAME SET	AdjustMaterialPositionalValue
      7  79b6					      SUBROUTINE
    485  79b6					      SUBROUTINE
    486  79b6
    487  79b6							; A move is about to be made, so  adjust material and positional values based on from/to and
    488  79b6							; capture.
    489  79b6
    490  79b6							; First, nominate referencing subroutines so that local variables can be adjusted properly
    491  79b6
      0  79b6					      REFER	alphaBeta
      1  79b6					      IF	VAREND_alphaBeta > TEMPORARY_VAR
      2  79b6				   TEMPORARY_VAR SET	VAREND_alphaBeta
      3  79b6					      ENDIF
      0  79b6					      REFER	MakeMove
      1  79b6					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  79b6				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  79b6					      ENDIF
      0  79b6					      REFER	aiMoveIsSelected
      1  79b6				  -	      IF	VAREND_aiMoveIsSelected > TEMPORARY_VAR
      2  79b6				  -TEMPORARY_VAR SET	VAREND_aiMoveIsSelected
      3  79b6					      ENDIF
      0  79b6					      VAR	__originalPiece, 1
      1  79b6		       00 aa	   __originalPiece =	TEMPORARY_VAR
      2  79b6				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  79b6
      4  79b6				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  79b6				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  79b6				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  79b6					      ENDIF
      8  79b6				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  79b6				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  79b6				  -	      ERR
     11  79b6					      ENDIF
     12  79b6					      LIST	ON
      0  79b6					      VAR	__capturedPiece, 1
      1  79b6		       00 ab	   __capturedPiece =	TEMPORARY_VAR
      2  79b6				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  79b6
      4  79b6				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  79b6				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  79b6				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  79b6					      ENDIF
      8  79b6				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  79b6				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  79b6				  -	      ERR
     11  79b6					      ENDIF
     12  79b6					      LIST	ON
      0  79b6					      VEND	AdjustMaterialPositionalValue
      1  79b6				  -	      IFNCONST	AdjustMaterialPositionalValue
      2  79b6				  -	      ECHO	"Incorrect VEND label", AdjustMaterialPositionalValue
      3  79b6				  -	      ERR
      4  79b6					      ENDIF
      5  79b6		       00 ac	   VAREND_AdjustMaterialPositionalValue =	TEMPORARY_VAR
    498  79b6
    499  79b6							; fromPiece	 piece doing the move (promoted type)
    500  79b6							; fromX12	 current square
    501  79b6							; originX12	 starting square
    502  79b6							; toX12	 ending square
    503  79b6
    504  79b6
    505  79b6							; get the piece types from the board
    506  79b6
    507  79b6		       a9 08		      lda	#RAMBANK_MOVES_RAM
    508  79b8		       85 3e		      sta	SET_BANK_RAM
    509  79ba		       a4 87		      ldy	originX12
    510  79bc		       b9 79 f0 	      lda	Board,y
    511  79bf		       85 aa		      sta	__originalPiece
    512  79c1		       a4 86		      ldy	toX12
    513  79c3		       b9 79 f0 	      lda	Board,y
    514  79c6		       85 ab		      sta	__capturedPiece
    515  79c8
    516  79c8							; {
    517  79c8							;   adjust the positional value  (originX12 --> fromX12)
    518  79c8
    519  79c8		       a9 0c		      lda	#BANK_AddPiecePositionValue
    520  79ca		       85 3f		      sta	SET_BANK
    521  79cc
    522  79cc
    523  79cc		       a4 86		      ldy	toX12
    524  79ce		       a5 98		      lda	fromPiece
    525  79d0		       20 20 f0 	      jsr	AddPiecePositionValue	; add pos value for new position
    526  79d3
    527  79d3
    528  79d3		       a5 aa		      lda	__originalPiece
    529  79d5		       45 98		      eor	fromPiece	; the new piece
    530  79d7		       29 0f		      and	#PIECE_MASK
    531  79d9		       f0 08		      beq	.same1	; unchanged, so skip
    532  79db
    533  79db		       a5 98		      lda	fromPiece	; new piece
    534  79dd		       29 0f		      and	#PIECE_MASK
    535  79df		       a8		      tay
    536  79e0		       20 10 f0 	      jsr	AddPieceMaterialValue
    537  79e3
    538  79e3				   .same1
    539  79e3
    540  79e3							; and now the 'subtracts'
    541  79e3
      0  79e3					      NEGEVAL
      1  79e3
      2  79e3		       38		      sec
      3  79e4		       a9 00		      lda	#0
      4  79e6		       e5 90		      sbc	Evaluation
      5  79e8		       85 90		      sta	Evaluation
      6  79ea		       a9 00		      lda	#0
      7  79ec		       e5 91		      sbc	Evaluation+1
      8  79ee		       85 91		      sta	Evaluation+1
      9  79f0
     10  79f0
     11  79f0
     12  79f0
     13  79f0
     14  79f0
     15  79f0
     16  79f0
     17  79f0
     18  79f0
     19  79f0
    543  79f0
    544  79f0		       a4 87		      ldy	originX12
    545  79f2		       a5 aa		      lda	__originalPiece
    546  79f4		       20 20 f0 	      jsr	AddPiecePositionValue	; remove pos value for original position
    547  79f7
    548  79f7
    549  79f7		       a5 aa		      lda	__originalPiece
    550  79f9		       45 98		      eor	fromPiece	; the new piece
    551  79fb		       29 0f		      and	#PIECE_MASK
    552  79fd		       f0 08		      beq	.same2	; unchanged, so skip
    553  79ff
    554  79ff		       a5 aa		      lda	__originalPiece
    555  7a01		       29 0f		      and	#PIECE_MASK
    556  7a03		       a8		      tay
    557  7a04		       20 10 f0 	      jsr	AddPieceMaterialValue	; remove material for original type
    558  7a07				   .same2
    559  7a07
      0  7a07					      NEGEVAL
      1  7a07
      2  7a07		       38		      sec
      3  7a08		       a9 00		      lda	#0
      4  7a0a		       e5 90		      sbc	Evaluation
      5  7a0c		       85 90		      sta	Evaluation
      6  7a0e		       a9 00		      lda	#0
      7  7a10		       e5 91		      sbc	Evaluation+1
      8  7a12		       85 91		      sta	Evaluation+1
      9  7a14
     10  7a14
     11  7a14
     12  7a14
     13  7a14
     14  7a14
     15  7a14
     16  7a14
     17  7a14
     18  7a14
     19  7a14
    561  7a14
    562  7a14							; If there's a capture, we adjust the material value
    563  7a14
    564  7a14							;		      lda __capturedPiece
    565  7a14							;		      eor __originalPiece
    566  7a14							;		      bpl .noCapture		      ; special-case capture rook castling onto king
    567  7a14
    568  7a14
    569  7a14		       a5 ab		      lda	__capturedPiece
    570  7a16		       29 0f		      and	#PIECE_MASK
    571  7a18		       f0 04		      beq	.noCapture
    572  7a1a		       a8		      tay
    573  7a1b		       20 10 f0 	      jsr	AddPieceMaterialValue	; -other colour = + my colour!
    574  7a1e				   .noCapture
    575  7a1e
    576  7a1e							; }
    577  7a1e		       a5 8b		      lda	savedBank
    578  7a20		       85 3f		      sta	SET_BANK
    579  7a22		       60		      rts
    580  7a23
    581  7a23
    582  7a23							;---------------------------------------------------------------------------------------------------
    583  7a23
      0  7a23					      DEF	debug
      1  7a23				   BANK_debug SET	_CURRENT_BANK
      2  7a23				   debug
      3  7a23				   TEMPORARY_VAR SET	Overlay
      4  7a23				   TEMPORARY_OFFSET SET	0
      5  7a23				   VAR_BOUNDARY_debug SET	TEMPORARY_OFFSET
      6  7a23				   FUNCTION_NAME SET	debug
      7  7a23					      SUBROUTINE
    585  7a23					      SUBROUTINE
    586  7a23
    587  7a23							; Use this to trap breakpoints in "unknown" banks. Just "jsr debug" from wherever you want
    588  7a23							; to catch the code, and put a breakpoint here instead. Then step, and you're at the place
    589  7a23							; you wanted to see, without knowing the bank.
    590  7a23
    591  7a23		       60		      rts
    592  7a24
    593  7a24
    594  7a24							;---------------------------------------------------------------------------------------------------
    595  7a24
      0  7a24					      DEF	EnPassantCheck
      1  7a24				   BANK_EnPassantCheck SET	_CURRENT_BANK
      2  7a24				   EnPassantCheck
      3  7a24				   TEMPORARY_VAR SET	Overlay
      4  7a24				   TEMPORARY_OFFSET SET	0
      5  7a24				   VAR_BOUNDARY_EnPassantCheck SET	TEMPORARY_OFFSET
      6  7a24				   FUNCTION_NAME SET	EnPassantCheck
      7  7a24					      SUBROUTINE
    597  7a24					      SUBROUTINE
    598  7a24
    599  7a24							; {
    600  7a24							; With en-passant flag, it is essentially dual-use.
    601  7a24							; First, it marks if the move is *involved* somehow in an en-passant
    602  7a24							; if the piece has MOVED already, then it's an en-passant capture
    603  7a24							; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
    604  7a24
    605  7a24		       a4 94		      ldy	enPassantPawn	; save from previous side move
    606  7a26
    607  7a26		       a2 00		      ldx	#0	; (probably) NO en-passant this time
    608  7a28		       a5 98		      lda	fromPiece
    609  7a2a		       29 60		      and	#FLAG_ENPASSANT|FLAG_MOVED
    610  7a2c		       c9 20		      cmp	#FLAG_ENPASSANT
    611  7a2e		       d0 06		      bne	.noep	; HAS moved, or not en-passant
    612  7a30
    613  7a30		       45 98		      eor	fromPiece	; clear FLAG_ENPASSANT
    614  7a32		       85 98		      sta	fromPiece
    615  7a34
    616  7a34		       a6 85		      ldx	fromX12	; this IS an en-passantable opening, so record the square
    617  7a36		       86 94	   .noep      stx	enPassantPawn	; capturable square for en-passant move (or none)
    618  7a38
    619  7a38							; }
    620  7a38
    621  7a38
    622  7a38							; Check to see if we are doing an actual en-passant capture...
    623  7a38
    624  7a38							; NOTE: If using test boards for debugging, the FLAG_MOVED flag is IMPORTANT
    625  7a38							;  as the en-passant will fail if the taking piece does not have this flag set correctly
    626  7a38
    627  7a38							;sty originX12 		  ; rqd for FixPieceList
    628  7a38
    629  7a38		       a5 98		      lda	fromPiece
    630  7a3a		       29 20		      and	#FLAG_ENPASSANT
    631  7a3c							;beq .notEnPassant		  ; not an en-passant, or it's enpassant by a MOVED piece
    632  7a3c		       60		      rts
    633  7a3d
    634  7a3d							;---------------------------------------------------------------------------------------------------
    635  7a3d
      0  7a3d					      DEF	EnPassantRemovePiece
      1  7a3d				   BANK_EnPassantRemovePiece SET	_CURRENT_BANK
      2  7a3d				   EnPassantRemovePiece
      3  7a3d				   TEMPORARY_VAR SET	Overlay
      4  7a3d				   TEMPORARY_OFFSET SET	0
      5  7a3d				   VAR_BOUNDARY_EnPassantRemovePiece SET	TEMPORARY_OFFSET
      6  7a3d				   FUNCTION_NAME SET	EnPassantRemovePiece
      7  7a3d					      SUBROUTINE
    637  7a3d					      SUBROUTINE
    638  7a3d
      0  7a3d					      REFER	SpecialBody
      1  7a3d					      IF	VAREND_SpecialBody > TEMPORARY_VAR
      2  7a3d				   TEMPORARY_VAR SET	VAREND_SpecialBody
      3  7a3d					      ENDIF
      0  7a3d					      VEND	EnPassantRemovePiece
      1  7a3d				  -	      IFNCONST	EnPassantRemovePiece
      2  7a3d				  -	      ECHO	"Incorrect VEND label", EnPassantRemovePiece
      3  7a3d				  -	      ERR
      4  7a3d					      ENDIF
      5  7a3d		       00 a9	   VAREND_EnPassantRemovePiece =	TEMPORARY_VAR
    641  7a3d
    642  7a3d		       20 64 fa 	      jsr	DeletePiece	; adjust material/position evaluation
    643  7a40
    644  7a40		       a5 97		      lda	sideToMove
    645  7a42		       49 80		      eor	#128
    646  7a44		       0a		      asl		; --> C
    647  7a45		       a9 00		      lda	#0
    648  7a47		       69 09		      adc	#RAMBANK_PLY	; <-- C
    649  7a49		       85 3e		      sta	SET_BANK_RAM
    650  7a4b
    651  7a4b		       60		      rts
    652  7a4c
    653  7a4c
    654  7a4c							;---------------------------------------------------------------------------------------------------
    655  7a4c
      0  7a4c					      DEF	SpecialBody
      1  7a4c				   BANK_SpecialBody SET	_CURRENT_BANK
      2  7a4c				   SpecialBody
      3  7a4c				   TEMPORARY_VAR SET	Overlay
      4  7a4c				   TEMPORARY_OFFSET SET	0
      5  7a4c				   VAR_BOUNDARY_SpecialBody SET	TEMPORARY_OFFSET
      6  7a4c				   FUNCTION_NAME SET	SpecialBody
      7  7a4c					      SUBROUTINE
    657  7a4c					      SUBROUTINE
    658  7a4c
      0  7a4c					      COMMON_VARS_ALPHABETA
      1  7a4c
      0  7a4c					      VAR	__bestMove, 1
      1  7a4c		       00 a2	   __bestMove =	TEMPORARY_VAR
      2  7a4c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7a4c
      4  7a4c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7a4c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7a4c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7a4c					      ENDIF
      8  7a4c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7a4c				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  7a4c				  -	      ERR
     11  7a4c					      ENDIF
     12  7a4c					      LIST	ON
      0  7a4c					      VAR	__bestScore, 2
      1  7a4c		       00 a3	   __bestScore =	TEMPORARY_VAR
      2  7a4c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7a4c
      4  7a4c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7a4c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7a4c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7a4c					      ENDIF
      8  7a4c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7a4c				  -	      ECHO	"Temporary Variable", __bestScore, "overflow!"
     10  7a4c				  -	      ERR
     11  7a4c					      ENDIF
     12  7a4c					      LIST	ON
      0  7a4c					      VAR	__alpha, 2
      1  7a4c		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  7a4c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7a4c
      4  7a4c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7a4c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7a4c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7a4c					      ENDIF
      8  7a4c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7a4c				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  7a4c				  -	      ERR
     11  7a4c					      ENDIF
     12  7a4c					      LIST	ON
      0  7a4c					      VAR	__beta, 2
      1  7a4c		       00 a7	   __beta     =	TEMPORARY_VAR
      2  7a4c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7a4c
      4  7a4c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7a4c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7a4c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7a4c					      ENDIF
      8  7a4c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7a4c				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  7a4c				  -	      ERR
     11  7a4c					      ENDIF
     12  7a4c					      LIST	ON
      6  7a4c
      0  7a4c					      REFER	aiSpecialMoveFixup
      1  7a4c				  -	      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  7a4c				  -TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  7a4c					      ENDIF
      0  7a4c					      VEND	SpecialBody
      1  7a4c				  -	      IFNCONST	SpecialBody
      2  7a4c				  -	      ECHO	"Incorrect VEND label", SpecialBody
      3  7a4c				  -	      ERR
      4  7a4c					      ENDIF
      5  7a4c		       00 a9	   VAREND_SpecialBody =	TEMPORARY_VAR
    662  7a4c
    663  7a4c				  -	      IF	ENPASSANT_ENABLED
    664  7a4c				  -
    665  7a4c				  -			; TODO - enpassant borked
    666  7a4c				  -
    667  7a4c				  -			; Handle en-passant captures
    668  7a4c				  -			; The (dual-use) FLAG_ENPASSANT will have been cleared if it was set for a home-rank move
    669  7a4c				  -			; but if we're here and the flag is still set, then it's an actual en-passant CAPTURE and we
    670  7a4c				  -			; need to do the appropriate things...
    671  7a4c				  -
    672  7a4c				  -	      jsr	EnPassantCheck
    673  7a4c				  -	      beq	.notEnPassant
    674  7a4c				  -
    675  7a4c				  -			; {
    676  7a4c				  -
    677  7a4c				  -			; Here we are the aggressor and we need to take the pawn 'en passant' fashion
    678  7a4c				  -			; y = the square containing the pawn to capture (i.e., previous value of 'enPassantPawn')
    679  7a4c				  -
    680  7a4c				  -			; Remove the pawn from the board and piecelist, and undraw
    681  7a4c				  -
    682  7a4c				  -	      sty	squareToDraw
    683  7a4c				  -	      jsr	CopySinglePiece	; undraw captured pawn
    684  7a4c				  -
    685  7a4c				  -	      ldy	originX12	; taken pawn's square
    686  7a4c				  -
    687  7a4c				  -	      jsr	EnPassantRemovePiece
    688  7a4c				  -
    689  7a4c				  -.notEnPassant
    690  7a4c				  -			; }
    691  7a4c				  -
    692  7a4c					      ENDIF
    693  7a4c
    694  7a4c
    695  7a4c		       a5 95		      lda	currentPly
    696  7a4e		       85 3e		      sta	SET_BANK_RAM
    697  7a50		       20 34 f3 	      jsr	CastleFixupDraw
    698  7a53		       60		      rts
    699  7a54
    700  7a54
    701  7a54							;---------------------------------------------------------------------------------------------------
    702  7a54
      0  7a54					      DEF	aiSpecialMoveFixup
      1  7a54				   BANK_aiSpecialMoveFixup SET	_CURRENT_BANK
      2  7a54				   aiSpecialMoveFixup
      3  7a54				   TEMPORARY_VAR SET	Overlay
      4  7a54				   TEMPORARY_OFFSET SET	0
      5  7a54				   VAR_BOUNDARY_aiSpecialMoveFixup SET	TEMPORARY_OFFSET
      6  7a54				   FUNCTION_NAME SET	aiSpecialMoveFixup
      7  7a54					      SUBROUTINE
    704  7a54					      SUBROUTINE
    705  7a54
      0  7a54					      REFER	AiStateMachine
      1  7a54				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  7a54				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  7a54					      ENDIF
      0  7a54					      VEND	aiSpecialMoveFixup
      1  7a54				  -	      IFNCONST	aiSpecialMoveFixup
      2  7a54				  -	      ECHO	"Incorrect VEND label", aiSpecialMoveFixup
      3  7a54				  -	      ERR
      4  7a54					      ENDIF
      5  7a54		       00 a2	   VAREND_aiSpecialMoveFixup =	TEMPORARY_VAR
    708  7a54
    709  7a54		       ad 84 02 	      lda	INTIM
    710  7a57		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    711  7a59		       b0 01		      bcs	.cont
    712  7a5b		       60		      rts
    713  7a5c
    714  7a5c				   .cont
      0  7a5c					      PHASE	AI_FlipBuffers
      1  7a5c		       a9 12		      lda	#AI_FlipBuffers
      2  7a5e		       85 8c		      sta	aiState
    716  7a60
    717  7a60		       20 4c fa 	      jsr	SpecialBody
    718  7a63		       60		      rts
    719  7a64
    720  7a64
    721  7a64							;---------------------------------------------------------------------------------------------------
    722  7a64
      0  7a64					      DEF	DeletePiece
      1  7a64				   BANK_DeletePiece SET	_CURRENT_BANK
      2  7a64				   DeletePiece
      3  7a64				   TEMPORARY_VAR SET	Overlay
      4  7a64				   TEMPORARY_OFFSET SET	0
      5  7a64				   VAR_BOUNDARY_DeletePiece SET	TEMPORARY_OFFSET
      6  7a64				   FUNCTION_NAME SET	DeletePiece
      7  7a64					      SUBROUTINE
    724  7a64					      SUBROUTINE
    725  7a64
    726  7a64
    727  7a64							; Based on piece square, adjust material and position value with piece deleted
    728  7a64							; y = piece square
    729  7a64
      0  7a64					      REFER	EnPassantRemovePiece
      1  7a64					      IF	VAREND_EnPassantRemovePiece > TEMPORARY_VAR
      2  7a64				   TEMPORARY_VAR SET	VAREND_EnPassantRemovePiece
      3  7a64					      ENDIF
      0  7a64					      REFER	SpecialBody
      1  7a64				  -	      IF	VAREND_SpecialBody > TEMPORARY_VAR
      2  7a64				  -TEMPORARY_VAR SET	VAREND_SpecialBody
      3  7a64					      ENDIF
      0  7a64					      VAR	__y, 1
      1  7a64		       00 a9	   __y	      =	TEMPORARY_VAR
      2  7a64				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7a64
      4  7a64				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7a64				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7a64				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7a64					      ENDIF
      8  7a64				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7a64				  -	      ECHO	"Temporary Variable", __y, "overflow!"
     10  7a64				  -	      ERR
     11  7a64					      ENDIF
     12  7a64					      LIST	ON
      0  7a64					      VAR	__col, 1
      1  7a64		       00 aa	   __col      =	TEMPORARY_VAR
      2  7a64				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7a64
      4  7a64				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7a64				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7a64				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7a64					      ENDIF
      8  7a64				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7a64				  -	      ECHO	"Temporary Variable", __col, "overflow!"
     10  7a64				  -	      ERR
     11  7a64					      ENDIF
     12  7a64					      LIST	ON
      0  7a64					      VEND	DeletePiece
      1  7a64				  -	      IFNCONST	DeletePiece
      2  7a64				  -	      ECHO	"Incorrect VEND label", DeletePiece
      3  7a64				  -	      ERR
      4  7a64					      ENDIF
      5  7a64		       00 ab	   VAREND_DeletePiece =	TEMPORARY_VAR
    735  7a64
    736  7a64		       84 a9		      sty	__y
    737  7a66
    738  7a66		       a9 08		      lda	#RAMBANK_MOVES_RAM
    739  7a68		       85 3e		      sta	SET_BANK_RAM
    740  7a6a		       b9 79 f0 	      lda	Board,y	; piece type
    741  7a6d
    742  7a6d		       85 aa		      sta	__col
    743  7a6f		       29 0f		      and	#PIECE_MASK
    744  7a71		       a8		      tay
    745  7a72
    746  7a72		       a9 0c		      lda	#BANK_AddPieceMaterialValue
    747  7a74		       85 3f		      sta	SET_BANK
    748  7a76		       20 10 f0 	      jsr	AddPieceMaterialValue	; adding for opponent = taking
    749  7a79
    750  7a79		       a5 aa		      lda	__col
    751  7a7b		       a4 a9		      ldy	__y
    752  7a7d		       20 20 f0 	      jsr	AddPiecePositionValue	; adding for opponent = taking
    753  7a80
    754  7a80		       60		      rts
    755  7a81
    756  7a81
    757  7a81							;---------------------------------------------------------------------------------------------------
    758  7a81
------- FILE Handler_PAWN.asm LEVEL 3 PASS 5
      0  7a81					      include	"Handler_PAWN.asm"
      1  7a81							; Copyright (C)2020 Andrew Davie
      2  7a81							; Pawn move handlers
      3  7a81
      4  7a81							;---------------------------------------------------------------------------------------------------
      5  7a81							; WHITE PAWN
      6  7a81							;---------------------------------------------------------------------------------------------------
      7  7a81
      8  7a81		       00 28	   WHITE_HOME_ROW =	40	; < this, on home row
      9  7a81		       00 52	   BLACK_HOME_ROW =	82	; >= this, on home row
     10  7a81
     11  7a81							;---------------------------------------------------------------------------------------------------
     12  7a81
     13  7a81					      MAC	en_passant
     14  7a81					      SUBROUTINE
     15  7a81							; {1} = _LEFT or _RIGHT
     16  7a81
     17  7a81					      ldx	currentSquare
     18  7a81					      ldy	ValidSquare+{1},x
     19  7a81					      cpy	enPassantPawn
     20  7a81					      bne	.invalid
     21  7a81					      ldy	ValidSquare+{1}+{2},x	; en-passant endpoint must be blank
     22  7a81					      lda	Board,y
     23  7a81					      bne	.invalid
     24  7a81					      jsr	AddMove	; the MOVE will need to deal with the details of en-passant??
     25  7a81				   .invalid
     26  7a81					      ENDM
     27  7a81
     28  7a81							;---------------------------------------------------------------------------------------------------
     29  7a81
     30  7a81					      MAC	promote_pawn
     31  7a81							;SUBROUTINE
     32  7a81
     33  7a81							;{1} = BLACK or WHITE
     34  7a81
     35  7a81
     36  7a81					      sty	__temp
     37  7a81					      lda	#{1}|QUEEN
     38  7a81					      sta	currentPiece
     39  7a81					      jsr	AddMove
     40  7a81
     41  7a81					      lda	#{1}|ROOK
     42  7a81					      sta	currentPiece
     43  7a81					      ldy	__temp
     44  7a81					      jsr	AddMove
     45  7a81
     46  7a81					      lda	#{1}|BISHOP
     47  7a81					      sta	currentPiece
     48  7a81					      ldy	__temp
     49  7a81					      jsr	AddMove
     50  7a81
     51  7a81					      lda	#{1}|KNIGHT
     52  7a81					      sta	currentPiece
     53  7a81					      ldy	__temp
     54  7a81					      jsr	AddMove
     55  7a81
     56  7a81					      IF	{1} = WHITE
     57  7a81					      lda	#WHITE|WP
     58  7a81					      ENDIF
     59  7a81					      IF	{1} = BLACK
     60  7a81					      lda	#BLACK|BP
     61  7a81					      ENDIF
     62  7a81					      sta	currentPiece
     63  7a81					      ENDM
     64  7a81
     65  7a81							;---------------------------------------------------------------------------------------------------
     66  7a81
     67  7a81					      MAC	move_or_promote_pawn
     68  7a81							;SUBROUTINE
     69  7a81							; {1} = BLACK or WHITE
     70  7a81
     71  7a81					      IF	{1} = WHITE
     72  7a81					      cpy	#90	; last rank?
     73  7a81					      bcc	.standard
     74  7a81					      jsr	PromoteWhitePawn
     75  7a81					      jmp	.pMoved
     76  7a81					      ENDIF
     77  7a81
     78  7a81					      IF	{1} = BLACK
     79  7a81					      cpy	#30	; last rank?
     80  7a81					      bcs	.standard
     81  7a81					      jsr	PromoteBlackPawn
     82  7a81					      jmp	.pMoved
     83  7a81					      ENDIF
     84  7a81
     85  7a81				   .standard  jsr	AddMove	; add +1UP move
     86  7a81				   .pMoved
     87  7a81
     88  7a81					      ENDM
     89  7a81
     90  7a81							;---------------------------------------------------------------------------------------------------
     91  7a81
     92  7a81					      MAC	take
     93  7a81							;SUBROUTINE
     94  7a81							; {1} = capture square offset
     95  7a81
     96  7a81					      ldx	currentSquare
     97  7a81					      ldy	ValidSquare+{1},x
     98  7a81					      bmi	.invalid
     99  7a81					      lda	Board,y
    100  7a81					      beq	.invalid	; square empty
    101  7a81					      eor	currentPiece
    102  7a81					      bpl	.invalid	; same colour
    103  7a81
    104  7a81					      MOVE_OR_PROMOTE_PAWN	{2}
    105  7a81				   .invalid
    106  7a81					      ENDM
    107  7a81
    108  7a81							;---------------------------------------------------------------------------------------------------
    109  7a81
      0  7a81					      DEF	PromoteWhitePawn
      1  7a81				   BANK_PromoteWhitePawn SET	_CURRENT_BANK
      2  7a81				   PromoteWhitePawn
      3  7a81				   TEMPORARY_VAR SET	Overlay
      4  7a81				   TEMPORARY_OFFSET SET	0
      5  7a81				   VAR_BOUNDARY_PromoteWhitePawn SET	TEMPORARY_OFFSET
      6  7a81				   FUNCTION_NAME SET	PromoteWhitePawn
      7  7a81					      SUBROUTINE
    111  7a81					      SUBROUTINE
    112  7a81
      0  7a81					      REFER	Handle_WHITE_PAWN
      1  7a81					      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  7a81				   TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  7a81					      ENDIF
      0  7a81					      VAR	__temp, 1
      1  7a81		       00 ab	   __temp     =	TEMPORARY_VAR
      2  7a81				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7a81
      4  7a81				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7a81				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7a81				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7a81					      ENDIF
      8  7a81				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7a81				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  7a81				  -	      ERR
     11  7a81					      ENDIF
     12  7a81					      LIST	ON
      0  7a81					      VEND	PromoteWhitePawn
      1  7a81				  -	      IFNCONST	PromoteWhitePawn
      2  7a81				  -	      ECHO	"Incorrect VEND label", PromoteWhitePawn
      3  7a81				  -	      ERR
      4  7a81					      ENDIF
      5  7a81		       00 ac	   VAREND_PromoteWhitePawn =	TEMPORARY_VAR
    116  7a81
      0  7a81					      PROMOTE_PAWN	WHITE
      1  7a81
      2  7a81
      3  7a81
      4  7a81
      5  7a81
      6  7a81		       84 ab		      sty	__temp
      7  7a83		       a9 06		      lda	#WHITE|QUEEN
      8  7a85		       85 92		      sta	currentPiece
      9  7a87		       20 a5 fb 	      jsr	AddMove
     10  7a8a
     11  7a8a		       a9 05		      lda	#WHITE|ROOK
     12  7a8c		       85 92		      sta	currentPiece
     13  7a8e		       a4 ab		      ldy	__temp
     14  7a90		       20 a5 fb 	      jsr	AddMove
     15  7a93
     16  7a93		       a9 04		      lda	#WHITE|BISHOP
     17  7a95		       85 92		      sta	currentPiece
     18  7a97		       a4 ab		      ldy	__temp
     19  7a99		       20 a5 fb 	      jsr	AddMove
     20  7a9c
     21  7a9c		       a9 03		      lda	#WHITE|KNIGHT
     22  7a9e		       85 92		      sta	currentPiece
     23  7aa0		       a4 ab		      ldy	__temp
     24  7aa2		       20 a5 fb 	      jsr	AddMove
     25  7aa5
     26  7aa5					      IF	WHITE = WHITE
     27  7aa5		       a9 01		      lda	#WHITE|WP
     28  7aa7					      ENDIF
     29  7aa7				  -	      IF	WHITE = BLACK
     30  7aa7				  -	      lda	#BLACK|BP
     31  7aa7					      ENDIF
     32  7aa7		       85 92		      sta	currentPiece
    118  7aa9		       60		      rts
    119  7aaa
    120  7aaa							;---------------------------------------------------------------------------------------------------
    121  7aaa
      0  7aaa					      DEF	Handle_WHITE_PAWN
      1  7aaa				   BANK_Handle_WHITE_PAWN SET	_CURRENT_BANK
      2  7aaa				   Handle_WHITE_PAWN
      3  7aaa				   TEMPORARY_VAR SET	Overlay
      4  7aaa				   TEMPORARY_OFFSET SET	0
      5  7aaa				   VAR_BOUNDARY_Handle_WHITE_PAWN SET	TEMPORARY_OFFSET
      6  7aaa				   FUNCTION_NAME SET	Handle_WHITE_PAWN
      7  7aaa					      SUBROUTINE
    123  7aaa					      SUBROUTINE
    124  7aaa
      0  7aaa					      REFER	GenerateAllMoves
      1  7aaa					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  7aaa				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  7aaa					      ENDIF
      0  7aaa					      VEND	Handle_WHITE_PAWN
      1  7aaa				  -	      IFNCONST	Handle_WHITE_PAWN
      2  7aaa				  -	      ECHO	"Incorrect VEND label", Handle_WHITE_PAWN
      3  7aaa				  -	      ERR
      4  7aaa					      ENDIF
      5  7aaa		       00 ab	   VAREND_Handle_WHITE_PAWN =	TEMPORARY_VAR
    127  7aaa
    128  7aaa		       bc 1f f0 	      ldy	ValidSquare+_UP,x	; square above must be blank (WILL NOT EVER be off-board!)
    129  7aad		       b9 79 f0 	      lda	Board,y
    130  7ab0		       d0 24		      bne	.pMoved	; occupied
    131  7ab2
    132  7ab2							; we may need to promote the pawn
    133  7ab2							; All possibilites (Q/R/B/N) are added as individual moves
    134  7ab2
      0  7ab2					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  7ab2
      2  7ab2
      3  7ab2
      4  7ab2					      IF	WHITE = WHITE
      5  7ab2		       c0 5a		      cpy	#90
      6  7ab4		       90 06		      bcc	.standard
      7  7ab6		       20 81 fa 	      jsr	PromoteWhitePawn
      8  7ab9		       4c bf fa 	      jmp	.pMoved
      9  7abc					      ENDIF
     10  7abc
     11  7abc				  -	      IF	WHITE = BLACK
     12  7abc				  -	      cpy	#30
     13  7abc				  -	      bcs	.standard
     14  7abc				  -	      jsr	PromoteBlackPawn
     15  7abc				  -	      jmp	.pMoved
     16  7abc					      ENDIF
     17  7abc
     18  7abc		       20 a5 fb    .standard  jsr	AddMove
     19  7abf				   .pMoved
     20  7abf
    136  7abf
    137  7abf							; the +2 move off the home rank...
    138  7abf
    139  7abf		       a6 93		      ldx	currentSquare
    140  7ac1		       e0 28		      cpx	#WHITE_HOME_ROW
    141  7ac3		       b0 11		      bcs	.pMoved	; pawn has moved so can't do +2
    142  7ac5		       bc 29 f0 	      ldy	ValidSquare+_UP+_UP,x	; WILL be a valid square
    143  7ac8		       b9 79 f0 	      lda	Board,y
    144  7acb		       d0 09		      bne	.pMoved	; destination square occupied
    145  7acd
    146  7acd		       a5 92		      lda	currentPiece
    147  7acf		       09 20		      ora	#FLAG_ENPASSANT
    148  7ad1		       85 92		      sta	currentPiece	; GENERATE en-passant opportunity
    149  7ad3
    150  7ad3		       20 a5 fb 	      jsr	AddMove	; add the +2UP move off home row
    151  7ad6
    152  7ad6				   .pMoved
    153  7ad6
    154  7ad6							; regular captures...
    155  7ad6
      0  7ad6					      TAKE	_UP+_LEFT, WHITE
      1  7ad6
      2  7ad6
      3  7ad6
      4  7ad6		       a6 93		      ldx	currentSquare
      5  7ad8		       bc 1e f0 	      ldy	ValidSquare+_UP+_LEFT,x
      6  7adb		       30 16		      bmi	.invalid
      7  7add		       b9 79 f0 	      lda	Board,y
      8  7ae0		       f0 11		      beq	.invalid
      9  7ae2		       45 92		      eor	currentPiece
     10  7ae4		       10 0d		      bpl	.invalid
     11  7ae6
      0  7ae6					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  7ae6
      2  7ae6
      3  7ae6
      4  7ae6					      IF	WHITE = WHITE
      5  7ae6		       c0 5a		      cpy	#90
      6  7ae8		       90 06		      bcc	.standard
      7  7aea		       20 81 fa 	      jsr	PromoteWhitePawn
      8  7aed		       4c f3 fa 	      jmp	.pMoved
      9  7af0					      ENDIF
     10  7af0
     11  7af0				  -	      IF	WHITE = BLACK
     12  7af0				  -	      cpy	#30
     13  7af0				  -	      bcs	.standard
     14  7af0				  -	      jsr	PromoteBlackPawn
     15  7af0				  -	      jmp	.pMoved
     16  7af0					      ENDIF
     17  7af0
     18  7af0		       20 a5 fb    .standard  jsr	AddMove
     19  7af3				   .pMoved
     20  7af3
     13  7af3				   .invalid
      0  7af3					      TAKE	_UP+_RIGHT, WHITE
      1  7af3
      2  7af3
      3  7af3
      4  7af3		       a6 93		      ldx	currentSquare
      5  7af5		       bc 20 f0 	      ldy	ValidSquare+_UP+_RIGHT,x
      6  7af8		       30 16		      bmi	.invalid
      7  7afa		       b9 79 f0 	      lda	Board,y
      8  7afd		       f0 11		      beq	.invalid
      9  7aff		       45 92		      eor	currentPiece
     10  7b01		       10 0d		      bpl	.invalid
     11  7b03
      0  7b03					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  7b03
      2  7b03
      3  7b03
      4  7b03					      IF	WHITE = WHITE
      5  7b03		       c0 5a		      cpy	#90
      6  7b05		       90 06		      bcc	.standard
      7  7b07		       20 81 fa 	      jsr	PromoteWhitePawn
      8  7b0a		       4c 10 fb 	      jmp	.pMoved
      9  7b0d					      ENDIF
     10  7b0d
     11  7b0d				  -	      IF	WHITE = BLACK
     12  7b0d				  -	      cpy	#30
     13  7b0d				  -	      bcs	.standard
     14  7b0d				  -	      jsr	PromoteBlackPawn
     15  7b0d				  -	      jmp	.pMoved
     16  7b0d					      ENDIF
     17  7b0d
     18  7b0d		       20 a5 fb    .standard  jsr	AddMove
     19  7b10				   .pMoved
     20  7b10
     13  7b10				   .invalid
    158  7b10
    159  7b10
    160  7b10				  -	      IF	ENPASSANT_ENABLED
    161  7b10				  -			; en-passant captures...
    162  7b10				  -
    163  7b10				  -	      lda	enPassantPawn
    164  7b10				  -	      beq	.noEnPassant	; previous move (opponent) enpassant square?
    165  7b10				  -
    166  7b10				  -	      lda	currentPiece
    167  7b10				  -	      ora	#FLAG_ENPASSANT
    168  7b10				  -	      sta	currentPiece	; CONSUME en-passant opportunity
    169  7b10				  -
    170  7b10				  -	      EN_PASSANT	_LEFT, _UP
    171  7b10				  -	      EN_PASSANT	_RIGHT, _UP
    172  7b10				  -
    173  7b10				  -.noEnPassant
    174  7b10					      ENDIF
    175  7b10
    176  7b10		       4c 33 f9 	      jmp	MoveReturn
    177  7b13
    178  7b13
    179  7b13							;---------------------------------------------------------------------------------------------------
    180  7b13							; BLACK PAWN
    181  7b13							;---------------------------------------------------------------------------------------------------
    182  7b13
      0  7b13					      DEF	PromoteBlackPawn
      1  7b13				   BANK_PromoteBlackPawn SET	_CURRENT_BANK
      2  7b13				   PromoteBlackPawn
      3  7b13				   TEMPORARY_VAR SET	Overlay
      4  7b13				   TEMPORARY_OFFSET SET	0
      5  7b13				   VAR_BOUNDARY_PromoteBlackPawn SET	TEMPORARY_OFFSET
      6  7b13				   FUNCTION_NAME SET	PromoteBlackPawn
      7  7b13					      SUBROUTINE
    184  7b13					      SUBROUTINE
    185  7b13
      0  7b13					      REFER	Handle_BLACK_PAWN
      1  7b13					      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  7b13				   TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  7b13					      ENDIF
      0  7b13					      VAR	__temp, 1
      1  7b13		       00 ab	   __temp     =	TEMPORARY_VAR
      2  7b13				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7b13
      4  7b13				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7b13				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7b13				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7b13					      ENDIF
      8  7b13				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7b13				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  7b13				  -	      ERR
     11  7b13					      ENDIF
     12  7b13					      LIST	ON
      0  7b13					      VEND	PromoteBlackPawn
      1  7b13				  -	      IFNCONST	PromoteBlackPawn
      2  7b13				  -	      ECHO	"Incorrect VEND label", PromoteBlackPawn
      3  7b13				  -	      ERR
      4  7b13					      ENDIF
      5  7b13		       00 ac	   VAREND_PromoteBlackPawn =	TEMPORARY_VAR
    189  7b13
      0  7b13					      PROMOTE_PAWN	BLACK
      1  7b13
      2  7b13
      3  7b13
      4  7b13
      5  7b13
      6  7b13		       84 ab		      sty	__temp
      7  7b15		       a9 86		      lda	#BLACK|QUEEN
      8  7b17		       85 92		      sta	currentPiece
      9  7b19		       20 a5 fb 	      jsr	AddMove
     10  7b1c
     11  7b1c		       a9 85		      lda	#BLACK|ROOK
     12  7b1e		       85 92		      sta	currentPiece
     13  7b20		       a4 ab		      ldy	__temp
     14  7b22		       20 a5 fb 	      jsr	AddMove
     15  7b25
     16  7b25		       a9 84		      lda	#BLACK|BISHOP
     17  7b27		       85 92		      sta	currentPiece
     18  7b29		       a4 ab		      ldy	__temp
     19  7b2b		       20 a5 fb 	      jsr	AddMove
     20  7b2e
     21  7b2e		       a9 83		      lda	#BLACK|KNIGHT
     22  7b30		       85 92		      sta	currentPiece
     23  7b32		       a4 ab		      ldy	__temp
     24  7b34		       20 a5 fb 	      jsr	AddMove
     25  7b37
     26  7b37				  -	      IF	BLACK = WHITE
     27  7b37				  -	      lda	#WHITE|WP
     28  7b37					      ENDIF
     29  7b37					      IF	BLACK = BLACK
     30  7b37		       a9 82		      lda	#BLACK|BP
     31  7b39					      ENDIF
     32  7b39		       85 92		      sta	currentPiece
    191  7b3b		       60		      rts
    192  7b3c
      0  7b3c					      DEF	Handle_BLACK_PAWN
      1  7b3c				   BANK_Handle_BLACK_PAWN SET	_CURRENT_BANK
      2  7b3c				   Handle_BLACK_PAWN
      3  7b3c				   TEMPORARY_VAR SET	Overlay
      4  7b3c				   TEMPORARY_OFFSET SET	0
      5  7b3c				   VAR_BOUNDARY_Handle_BLACK_PAWN SET	TEMPORARY_OFFSET
      6  7b3c				   FUNCTION_NAME SET	Handle_BLACK_PAWN
      7  7b3c					      SUBROUTINE
    194  7b3c					      SUBROUTINE
    195  7b3c
      0  7b3c					      REFER	GenerateAllMoves
      1  7b3c					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  7b3c				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  7b3c					      ENDIF
      0  7b3c					      VEND	Handle_BLACK_PAWN
      1  7b3c				  -	      IFNCONST	Handle_BLACK_PAWN
      2  7b3c				  -	      ECHO	"Incorrect VEND label", Handle_BLACK_PAWN
      3  7b3c				  -	      ERR
      4  7b3c					      ENDIF
      5  7b3c		       00 ab	   VAREND_Handle_BLACK_PAWN =	TEMPORARY_VAR
    198  7b3c
    199  7b3c		       bc 0b f0 	      ldy	ValidSquare+_DOWN,x	; square below must be blank (WILL NOT EVER be off-board!)
    200  7b3f		       b9 79 f0 	      lda	Board,y
    201  7b42		       d0 24		      bne	.pMoved	; occupied
    202  7b44
    203  7b44
    204  7b44							; we may need to promote the pawn
    205  7b44							; All possibilites (Q/R/B/N) are added as individual moves
    206  7b44
      0  7b44					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  7b44
      2  7b44
      3  7b44
      4  7b44				  -	      IF	BLACK = WHITE
      5  7b44				  -	      cpy	#90
      6  7b44				  -	      bcc	.standard
      7  7b44				  -	      jsr	PromoteWhitePawn
      8  7b44				  -	      jmp	.pMoved
      9  7b44					      ENDIF
     10  7b44
     11  7b44					      IF	BLACK = BLACK
     12  7b44		       c0 1e		      cpy	#30
     13  7b46		       b0 06		      bcs	.standard
     14  7b48		       20 13 fb 	      jsr	PromoteBlackPawn
     15  7b4b		       4c 51 fb 	      jmp	.pMoved
     16  7b4e					      ENDIF
     17  7b4e
     18  7b4e		       20 a5 fb    .standard  jsr	AddMove
     19  7b51				   .pMoved
     20  7b51
    208  7b51
    209  7b51							; the +2 move off the home rank...
    210  7b51
    211  7b51		       a6 93		      ldx	currentSquare
    212  7b53		       e0 52		      cpx	#BLACK_HOME_ROW
    213  7b55		       90 11		      bcc	.pMoved	; pawn has moved so can't do +2
    214  7b57
    215  7b57
    216  7b57		       bc 01 f0 	      ldy	ValidSquare+_DOWN+_DOWN,x	; WILL be a valid square
    217  7b5a		       b9 79 f0 	      lda	Board,y
    218  7b5d		       d0 09		      bne	.pMoved	; destination square occupied
    219  7b5f
    220  7b5f		       a5 92		      lda	currentPiece
    221  7b61		       09 20		      ora	#FLAG_ENPASSANT
    222  7b63		       85 92		      sta	currentPiece	; CAN en-passant
    223  7b65
    224  7b65		       20 a5 fb 	      jsr	AddMove	; add the +2DOWN move off home row
    225  7b68
    226  7b68				   .pMoved
    227  7b68
    228  7b68							; regular captures... (with promotion)
    229  7b68
      0  7b68					      TAKE	_DOWN+_LEFT, BLACK
      1  7b68
      2  7b68
      3  7b68
      4  7b68		       a6 93		      ldx	currentSquare
      5  7b6a		       bc 0a f0 	      ldy	ValidSquare+_DOWN+_LEFT,x
      6  7b6d		       30 16		      bmi	.invalid
      7  7b6f		       b9 79 f0 	      lda	Board,y
      8  7b72		       f0 11		      beq	.invalid
      9  7b74		       45 92		      eor	currentPiece
     10  7b76		       10 0d		      bpl	.invalid
     11  7b78
      0  7b78					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  7b78
      2  7b78
      3  7b78
      4  7b78				  -	      IF	BLACK = WHITE
      5  7b78				  -	      cpy	#90
      6  7b78				  -	      bcc	.standard
      7  7b78				  -	      jsr	PromoteWhitePawn
      8  7b78				  -	      jmp	.pMoved
      9  7b78					      ENDIF
     10  7b78
     11  7b78					      IF	BLACK = BLACK
     12  7b78		       c0 1e		      cpy	#30
     13  7b7a		       b0 06		      bcs	.standard
     14  7b7c		       20 13 fb 	      jsr	PromoteBlackPawn
     15  7b7f		       4c 85 fb 	      jmp	.pMoved
     16  7b82					      ENDIF
     17  7b82
     18  7b82		       20 a5 fb    .standard  jsr	AddMove
     19  7b85				   .pMoved
     20  7b85
     13  7b85				   .invalid
      0  7b85					      TAKE	_DOWN+_RIGHT, BLACK
      1  7b85
      2  7b85
      3  7b85
      4  7b85		       a6 93		      ldx	currentSquare
      5  7b87		       bc 0c f0 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      6  7b8a		       30 16		      bmi	.invalid
      7  7b8c		       b9 79 f0 	      lda	Board,y
      8  7b8f		       f0 11		      beq	.invalid
      9  7b91		       45 92		      eor	currentPiece
     10  7b93		       10 0d		      bpl	.invalid
     11  7b95
      0  7b95					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  7b95
      2  7b95
      3  7b95
      4  7b95				  -	      IF	BLACK = WHITE
      5  7b95				  -	      cpy	#90
      6  7b95				  -	      bcc	.standard
      7  7b95				  -	      jsr	PromoteWhitePawn
      8  7b95				  -	      jmp	.pMoved
      9  7b95					      ENDIF
     10  7b95
     11  7b95					      IF	BLACK = BLACK
     12  7b95		       c0 1e		      cpy	#30
     13  7b97		       b0 06		      bcs	.standard
     14  7b99		       20 13 fb 	      jsr	PromoteBlackPawn
     15  7b9c		       4c a2 fb 	      jmp	.pMoved
     16  7b9f					      ENDIF
     17  7b9f
     18  7b9f		       20 a5 fb    .standard  jsr	AddMove
     19  7ba2				   .pMoved
     20  7ba2
     13  7ba2				   .invalid
    232  7ba2
    233  7ba2
    234  7ba2				  -	      IF	ENPASSANT_ENABLED
    235  7ba2				  -			; en-passant captures...
    236  7ba2				  -
    237  7ba2				  -	      lda	enPassantPawn
    238  7ba2				  -	      beq	.noEnPassant	; was last move en-passantable?
    239  7ba2				  -
    240  7ba2				  -	      lda	currentPiece
    241  7ba2				  -	      ora	#FLAG_ENPASSANT
    242  7ba2				  -	      sta	currentPiece	; any en-passant move added will have flag set
    243  7ba2				  -
    244  7ba2				  -	      EN_PASSANT	_LEFT, _DOWN
    245  7ba2				  -	      EN_PASSANT	_RIGHT, _DOWN
    246  7ba2				  -
    247  7ba2				  -.noEnPassant
    248  7ba2					      ENDIF
    249  7ba2
    250  7ba2		       4c 33 f9 	      jmp	MoveReturn
    251  7ba5
    252  7ba5							; EOF
------- FILE BANK_FIXED.asm
    760  7ba5
    761  7ba5							;---------------------------------------------------------------------------------------------------
    762  7ba5
      0  7ba5					      DEF	AddMove
      1  7ba5				   BANK_AddMove SET	_CURRENT_BANK
      2  7ba5				   AddMove
      3  7ba5				   TEMPORARY_VAR SET	Overlay
      4  7ba5				   TEMPORARY_OFFSET SET	0
      5  7ba5				   VAR_BOUNDARY_AddMove SET	TEMPORARY_OFFSET
      6  7ba5				   FUNCTION_NAME SET	AddMove
      7  7ba5					      SUBROUTINE
    764  7ba5					      SUBROUTINE
    765  7ba5							; =57 including call
    766  7ba5
    767  7ba5							; add square in y register to movelist as destination (X12 format)
    768  7ba5							; [y]		     to square (X12)
    769  7ba5							; currentSquare     from square (X12)
    770  7ba5							; currentPiece      piece. ENPASSANT flag set if pawn double-moving off opening rank
    771  7ba5
    772  7ba5		       a5 95		      lda	currentPly	; 3
    773  7ba7		       85 3e		      sta	SET_BANK_RAM	; 3
    774  7ba9
    775  7ba9		       98		      tya		; 2
    776  7baa
    777  7baa		       ac d7 f1 	      ldy	moveIndex	; 3
    778  7bad		       c8		      iny		; 2
      0  7bae					      sty@RAM	moveIndex	; 4
      1  7bae		       8c d7 f5 	      sty	[RAM]+moveIndex
    780  7bb1
      0  7bb1					      sta@RAM	MoveTo,y	; 5
      1  7bb1		       99 4a f4 	      sta	[RAM]+MoveTo,y
    782  7bb4		       aa		      tax		; 2 new square (for projections)
    783  7bb5
    784  7bb5		       a5 93		      lda	currentSquare	; 3
      0  7bb7					      sta@RAM	MoveFrom,y	; 5
      1  7bb7		       99 04 f4 	      sta	[RAM]+MoveFrom,y
    786  7bba		       a5 92		      lda	currentPiece	; 3
      0  7bbc					      sta@RAM	MovePiece,y	; 5
      1  7bbc		       99 90 f4 	      sta	[RAM]+MovePiece,y
    788  7bbf
    789  7bbf		       a9 08		      lda	#RAMBANK_MOVES_RAM	; 2 TODO: NOT NEEDED IF FIXED BANK CALLED THIS
    790  7bc1		       85 3e		      sta	SET_BANK_RAM	; 3
    791  7bc3		       60		      rts		; 6
    792  7bc4
    793  7bc4
    794  7bc4							;---------------------------------------------------------------------------------------------------
    795  7bc4
      0  7bc4					      DEF	InitialisePieceSquares
      1  7bc4				   BANK_InitialisePieceSquares SET	_CURRENT_BANK
      2  7bc4				   InitialisePieceSquares
      3  7bc4				   TEMPORARY_VAR SET	Overlay
      4  7bc4				   TEMPORARY_OFFSET SET	0
      5  7bc4				   VAR_BOUNDARY_InitialisePieceSquares SET	TEMPORARY_OFFSET
      6  7bc4				   FUNCTION_NAME SET	InitialisePieceSquares
      7  7bc4					      SUBROUTINE
    797  7bc4					      SUBROUTINE
    798  7bc4
      0  7bc4					      REFER	Reset
      1  7bc4				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  7bc4				  -TEMPORARY_VAR SET	VAREND_Reset
      3  7bc4					      ENDIF
      0  7bc4					      VAR	__initPiece, 1
      1  7bc4		       00 a2	   __initPiece =	TEMPORARY_VAR
      2  7bc4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7bc4
      4  7bc4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7bc4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7bc4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7bc4					      ENDIF
      8  7bc4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7bc4				  -	      ECHO	"Temporary Variable", __initPiece, "overflow!"
     10  7bc4				  -	      ERR
     11  7bc4					      ENDIF
     12  7bc4					      LIST	ON
      0  7bc4					      VAR	__initSquare, 1
      1  7bc4		       00 a3	   __initSquare =	TEMPORARY_VAR
      2  7bc4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7bc4
      4  7bc4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7bc4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7bc4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7bc4					      ENDIF
      8  7bc4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7bc4				  -	      ECHO	"Temporary Variable", __initSquare, "overflow!"
     10  7bc4				  -	      ERR
     11  7bc4					      ENDIF
     12  7bc4					      LIST	ON
      0  7bc4					      VAR	__initListPtr, 1
      1  7bc4		       00 a4	   __initListPtr =	TEMPORARY_VAR
      2  7bc4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7bc4
      4  7bc4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7bc4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7bc4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7bc4					      ENDIF
      8  7bc4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7bc4				  -	      ECHO	"Temporary Variable", __initListPtr, "overflow!"
     10  7bc4				  -	      ERR
     11  7bc4					      ENDIF
     12  7bc4					      LIST	ON
      0  7bc4					      VEND	InitialisePieceSquares
      1  7bc4				  -	      IFNCONST	InitialisePieceSquares
      2  7bc4				  -	      ECHO	"Incorrect VEND label", InitialisePieceSquares
      3  7bc4				  -	      ERR
      4  7bc4					      ENDIF
      5  7bc4		       00 a5	   VAREND_InitialisePieceSquares =	TEMPORARY_VAR
    804  7bc4
    805  7bc4		       a9 09		      lda	#RAMBANK_PLY
    806  7bc6		       85 3e		      sta	SET_BANK_RAM
    807  7bc8		       20 e1 f1 	      jsr	InitPieceLists
    808  7bcb
    809  7bcb		       a2 00		      ldx	#0
    810  7bcd		       86 94		      stx	enPassantPawn	; no en-passant
    811  7bcf
    812  7bcf
    813  7bcf							; Now setup the board/piecelists
    814  7bcf
    815  7bcf		       a9 09	   .fillPieceLists lda	#RAMBANK_PLY
    816  7bd1		       85 3e		      sta	SET_BANK_RAM
    817  7bd3
    818  7bd3		       bd fa f1 	      lda	InitPieceList,x	; colour/-1
    819  7bd6		       f0 4f		      beq	.exit
    820  7bd8		       85 aa		      sta	__originalPiece	; type
    821  7bda
    822  7bda		       bc fb f1 	      ldy	InitPieceList+1,x	; square
    823  7bdd		       84 a3		      sty	__initSquare
    824  7bdf		       a9 08		      lda	#RAMBANK_MOVES_RAM
    825  7be1		       85 3e		      sta	SET_BANK_RAM
    826  7be3		       a5 aa		      lda	__originalPiece
      0  7be5					      sta@RAM	Board,y
      1  7be5		       99 79 f4 	      sta	[RAM]+Board,y
    828  7be8
    829  7be8		       10 0d		      bpl	.white
      0  7bea					      NEGEVAL
      1  7bea
      2  7bea		       38		      sec
      3  7beb		       a9 00		      lda	#0
      4  7bed		       e5 90		      sbc	Evaluation
      5  7bef		       85 90		      sta	Evaluation
      6  7bf1		       a9 00		      lda	#0
      7  7bf3		       e5 91		      sbc	Evaluation+1
      8  7bf5		       85 91		      sta	Evaluation+1
      9  7bf7
     10  7bf7
     11  7bf7
     12  7bf7
     13  7bf7
     14  7bf7
     15  7bf7
     16  7bf7
     17  7bf7
     18  7bf7
     19  7bf7
    831  7bf7				   .white
    832  7bf7
    833  7bf7							; Add the material value of the piece to the evaluation
    834  7bf7
    835  7bf7		       a5 aa		      lda	__originalPiece
    836  7bf9		       29 0f		      and	#PIECE_MASK
    837  7bfb		       a8		      tay
    838  7bfc
      0  7bfc					      JSROM	AddPieceMaterialValue
      1  7bfc
      2  7bfc		       a9 0c		      lda	#BANK_AddPieceMaterialValue
      3  7bfe		       85 3f		      sta	SET_BANK
      4  7c00		       20 10 f0 	      jsr	AddPieceMaterialValue
    840  7c03
    841  7c03		       86 a4		      stx	__initListPtr
    842  7c05
    843  7c05							; add the positional value of the piece to the evaluation
    844  7c05
    845  7c05		       a4 a3		      ldy	__initSquare
    846  7c07		       a5 aa		      lda	__originalPiece
    847  7c09
    848  7c09		       a2 0c		      ldx	#BANK_AddPiecePositionValue
    849  7c0b		       86 3f		      stx	SET_BANK
    850  7c0d		       20 20 f0 	      jsr	AddPiecePositionValue
    851  7c10
    852  7c10
    853  7c10
    854  7c10		       a5 aa		      lda	__originalPiece	; type/colour
    855  7c12		       10 0d		      bpl	.white2
      0  7c14					      NEGEVAL
      1  7c14
      2  7c14		       38		      sec
      3  7c15		       a9 00		      lda	#0
      4  7c17		       e5 90		      sbc	Evaluation
      5  7c19		       85 90		      sta	Evaluation
      6  7c1b		       a9 00		      lda	#0
      7  7c1d		       e5 91		      sbc	Evaluation+1
      8  7c1f		       85 91		      sta	Evaluation+1
      9  7c21
     10  7c21
     11  7c21
     12  7c21
     13  7c21
     14  7c21
     15  7c21
     16  7c21
     17  7c21
     18  7c21
     19  7c21
    857  7c21				   .white2
    858  7c21
    859  7c21		       a6 a4		      ldx	__initListPtr
    860  7c23		       e8		      inx
    861  7c24		       e8		      inx
    862  7c25		       10 a8		      bpl	.fillPieceLists
    863  7c27
    864  7c27		       60	   .exit      rts
    865  7c28
    866  7c28
    867  7c28							;---------------------------------------------------------------------------------------------------
    868  7c28
    869  7c28				  -	      if	0
    870  7c28				  -	      DEF	SAFE_GetKingSquare
    871  7c28				  -	      SUBROUTINE
    872  7c28				  -
    873  7c28				  -	      VEND	SAFE_GetKingSquare
    874  7c28				  -
    875  7c28				  -			; Pass:	 A = correct bank for current side (RAMBANK_PLY/+1)
    876  7c28				  -			; Return:	 A = square king is on (or -1)
    877  7c28				  -
    878  7c28				  -	      sta	SET_BANK_RAM
    879  7c28				  -	      jsr	GetKingSquare
    880  7c28				  -	      ldy	savedBank
    881  7c28				  -	      sty	SET_BANK
    882  7c28				  -	      rts
    883  7c28					      endif
    884  7c28
    885  7c28							;---------------------------------------------------------------------------------------------------
    886  7c28
      0  7c28					      DEF	GetValid
      1  7c28				   BANK_GetValid SET	_CURRENT_BANK
      2  7c28				   GetValid
      3  7c28				   TEMPORARY_VAR SET	Overlay
      4  7c28				   TEMPORARY_OFFSET SET	0
      5  7c28				   VAR_BOUNDARY_GetValid SET	TEMPORARY_OFFSET
      6  7c28				   FUNCTION_NAME SET	GetValid
      7  7c28					      SUBROUTINE
    888  7c28		       a9 08		      lda	#RAMBANK_MOVES_RAM
    889  7c2a		       85 3e		      sta	SET_BANK_RAM
    890  7c2c		       b9 15 f0 	      lda	ValidSquare,y
    891  7c2f		       a4 8b		      ldy	savedBank
    892  7c31		       84 3f		      sty	SET_BANK
    893  7c33		       60		      rts
    894  7c34
    895  7c34
    896  7c34							;---------------------------------------------------------------------------------------------------
    897  7c34
      0  7c34					      DEF	GetBoard
      1  7c34				   BANK_GetBoard SET	_CURRENT_BANK
      2  7c34				   GetBoard
      3  7c34				   TEMPORARY_VAR SET	Overlay
      4  7c34				   TEMPORARY_OFFSET SET	0
      5  7c34				   VAR_BOUNDARY_GetBoard SET	TEMPORARY_OFFSET
      6  7c34				   FUNCTION_NAME SET	GetBoard
      7  7c34					      SUBROUTINE
    899  7c34		       a9 08		      lda	#RAMBANK_MOVES_RAM
    900  7c36		       85 3e		      sta	SET_BANK_RAM
    901  7c38		       b9 79 f0 	      lda	Board,y
    902  7c3b		       a4 8b		      ldy	savedBank
    903  7c3d		       84 3f		      sty	SET_BANK
    904  7c3f		       60		      rts
    905  7c40
      0  7c40					      DEF	GetBoardRAM
      1  7c40				   BANK_GetBoardRAM SET	_CURRENT_BANK
      2  7c40				   GetBoardRAM
      3  7c40				   TEMPORARY_VAR SET	Overlay
      4  7c40				   TEMPORARY_OFFSET SET	0
      5  7c40				   VAR_BOUNDARY_GetBoardRAM SET	TEMPORARY_OFFSET
      6  7c40				   FUNCTION_NAME SET	GetBoardRAM
      7  7c40					      SUBROUTINE
    907  7c40		       a9 08		      lda	#RAMBANK_MOVES_RAM
    908  7c42		       85 3e		      sta	SET_BANK_RAM
    909  7c44		       b9 79 f0 	      lda	Board,y
    910  7c47		       a4 8b		      ldy	savedBank
    911  7c49		       84 3e		      sty	SET_BANK_RAM
    912  7c4b		       60		      rts
    913  7c4c
    914  7c4c							;---------------------------------------------------------------------------------------------------
    915  7c4c
      0  7c4c					      DEF	PutBoard
      1  7c4c				   BANK_PutBoard SET	_CURRENT_BANK
      2  7c4c				   PutBoard
      3  7c4c				   TEMPORARY_VAR SET	Overlay
      4  7c4c				   TEMPORARY_OFFSET SET	0
      5  7c4c				   VAR_BOUNDARY_PutBoard SET	TEMPORARY_OFFSET
      6  7c4c				   FUNCTION_NAME SET	PutBoard
      7  7c4c					      SUBROUTINE
    917  7c4c		       a2 08		      ldx	#RAMBANK_MOVES_RAM
    918  7c4e		       86 3e		      stx	SET_BANK_RAM
      0  7c50					      sta@RAM	Board,y	; and what's actually moving there
      1  7c50		       99 79 f4 	      sta	[RAM]+Board,y
    920  7c53		       a6 8b		      ldx	savedBank
    921  7c55		       86 3f		      stx	SET_BANK
    922  7c57		       60		      rts
    923  7c58
    924  7c58
    925  7c58							;---------------------------------------------------------------------------------------------------
    926  7c58
      0  7c58					      DEF	IsValidMoveFromSquare
      1  7c58				   BANK_IsValidMoveFromSquare SET	_CURRENT_BANK
      2  7c58				   IsValidMoveFromSquare
      3  7c58				   TEMPORARY_VAR SET	Overlay
      4  7c58				   TEMPORARY_OFFSET SET	0
      5  7c58				   VAR_BOUNDARY_IsValidMoveFromSquare SET	TEMPORARY_OFFSET
      6  7c58				   FUNCTION_NAME SET	IsValidMoveFromSquare
      7  7c58					      SUBROUTINE
    928  7c58					      SUBROUTINE
    929  7c58
      0  7c58					      REFER	aiSelectStartSquare
      1  7c58				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  7c58				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  7c58					      ENDIF
      0  7c58					      VEND	IsValidMoveFromSquare
      1  7c58				  -	      IFNCONST	IsValidMoveFromSquare
      2  7c58				  -	      ECHO	"Incorrect VEND label", IsValidMoveFromSquare
      3  7c58				  -	      ERR
      4  7c58					      ENDIF
      5  7c58		       00 a2	   VAREND_IsValidMoveFromSquare =	TEMPORARY_VAR
    932  7c58
    933  7c58							; Does the square exist in the movelist?
    934  7c58							; Return: y = -1 if NOT FOUND
    935  7c58
    936  7c58		       a5 88		      lda	cursorX12
    937  7c5a		       85 85		      sta	fromX12
    938  7c5c
    939  7c5c		       a4 95		      ldy	currentPly
    940  7c5e		       84 3e		      sty	SET_BANK_RAM
    941  7c60		       20 80 f2 	      jsr	CheckMoveListFromSquare
    942  7c63
    943  7c63		       a5 8b		      lda	savedBank
    944  7c65		       85 3f		      sta	SET_BANK
    945  7c67		       60		      rts
    946  7c68
    947  7c68
    948  7c68							;---------------------------------------------------------------------------------------------------
    949  7c68
      0  7c68					      DEF	GetPiece
      1  7c68				   BANK_GetPiece SET	_CURRENT_BANK
      2  7c68				   GetPiece
      3  7c68				   TEMPORARY_VAR SET	Overlay
      4  7c68				   TEMPORARY_OFFSET SET	0
      5  7c68				   VAR_BOUNDARY_GetPiece SET	TEMPORARY_OFFSET
      6  7c68				   FUNCTION_NAME SET	GetPiece
      7  7c68					      SUBROUTINE
    951  7c68					      SUBROUTINE
    952  7c68
      0  7c68					      REFER	aiSelectDestinationSquare
      1  7c68				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  7c68				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  7c68					      ENDIF
      0  7c68					      REFER	aiQuiescent
      1  7c68				  -	      IF	VAREND_aiQuiescent > TEMPORARY_VAR
      2  7c68				  -TEMPORARY_VAR SET	VAREND_aiQuiescent
      3  7c68					      ENDIF
      0  7c68					      VEND	GetPiece
      1  7c68				  -	      IFNCONST	GetPiece
      2  7c68				  -	      ECHO	"Incorrect VEND label", GetPiece
      3  7c68				  -	      ERR
      4  7c68					      ENDIF
      5  7c68		       00 a2	   VAREND_GetPiece =	TEMPORARY_VAR
    956  7c68
    957  7c68							; Retrieve the piece+flags from the movelist, given from/to squares
    958  7c68							; Required as moves have different flags but same origin squares (e.g., castling)
    959  7c68
    960  7c68		       a5 95		      lda	currentPly
    961  7c6a		       85 3e		      sta	SET_BANK_RAM
    962  7c6c
    963  7c6c		       20 94 f2 	      jsr	GetPieceGivenFromToSquares
    964  7c6f
    965  7c6f		       a5 8b		      lda	savedBank
    966  7c71		       85 3f		      sta	SET_BANK
    967  7c73		       60		      rts
    968  7c74
    969  7c74
    970  7c74							;---------------------------------------------------------------------------------------------------
    971  7c74
    972  7c74
      0  7c74					      DEF	CopyShadowROMtoRAM
      1  7c74				   BANK_CopyShadowROMtoRAM SET	_CURRENT_BANK
      2  7c74				   CopyShadowROMtoRAM
      3  7c74				   TEMPORARY_VAR SET	Overlay
      4  7c74				   TEMPORARY_OFFSET SET	0
      5  7c74				   VAR_BOUNDARY_CopyShadowROMtoRAM SET	TEMPORARY_OFFSET
      6  7c74				   FUNCTION_NAME SET	CopyShadowROMtoRAM
      7  7c74					      SUBROUTINE
    974  7c74					      SUBROUTINE
    975  7c74
      0  7c74					      REFER	SetupBanks
      1  7c74					      IF	VAREND_SetupBanks > TEMPORARY_VAR
      2  7c74				   TEMPORARY_VAR SET	VAREND_SetupBanks
      3  7c74					      ENDIF
      0  7c74					      VAR	__destinationBank, 1
      1  7c74		       00 a3	   __destinationBank =	TEMPORARY_VAR
      2  7c74				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7c74
      4  7c74				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7c74				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7c74				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7c74					      ENDIF
      8  7c74				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7c74				  -	      ECHO	"Temporary Variable", __destinationBank, "overflow!"
     10  7c74				  -	      ERR
     11  7c74					      ENDIF
     12  7c74					      LIST	ON
      0  7c74					      VAR	__sourceBank, 1
      1  7c74		       00 a4	   __sourceBank =	TEMPORARY_VAR
      2  7c74				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7c74
      4  7c74				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7c74				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7c74				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7c74					      ENDIF
      8  7c74				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7c74				  -	      ECHO	"Temporary Variable", __sourceBank, "overflow!"
     10  7c74				  -	      ERR
     11  7c74					      ENDIF
     12  7c74					      LIST	ON
      0  7c74					      VEND	CopyShadowROMtoRAM
      1  7c74				  -	      IFNCONST	CopyShadowROMtoRAM
      2  7c74				  -	      ECHO	"Incorrect VEND label", CopyShadowROMtoRAM
      3  7c74				  -	      ERR
      4  7c74					      ENDIF
      5  7c74		       00 a5	   VAREND_CopyShadowROMtoRAM =	TEMPORARY_VAR
    980  7c74
    981  7c74							; Copy a whole 1K ROM SHADOW into a destination RAM 1K bank
    982  7c74							; used to setup callable RAM code from ROM templates
    983  7c74
    984  7c74							; x = source ROM bank
    985  7c74							; y = destination RAM bank (preserved)
    986  7c74
    987  7c74		       86 a4		      stx	__sourceBank
    988  7c76
    989  7c76		       a2 00		      ldx	#0
    990  7c78		       a5 a4	   .copyPage  lda	__sourceBank
    991  7c7a		       85 3f		      sta	SET_BANK
    992  7c7c
    993  7c7c		       bd 00 f0 	      lda	$F000,x
    994  7c7f		       48		      pha
    995  7c80		       bd 00 f1 	      lda	$F100,x
    996  7c83		       48		      pha
    997  7c84		       bd 00 f2 	      lda	$F200,x
    998  7c87		       48		      pha
    999  7c88		       bd 00 f3 	      lda	$F300,x
   1000  7c8b
   1001  7c8b		       84 3e		      sty	SET_BANK_RAM
   1002  7c8d
      0  7c8d					      sta@RAM	$F300,x
      1  7c8d		       9d 00 f7 	      sta	[RAM]+$F300,x
   1004  7c90		       68		      pla
      0  7c91					      sta@RAM	$F200,x
      1  7c91		       9d 00 f6 	      sta	[RAM]+$F200,x
   1006  7c94		       68		      pla
      0  7c95					      sta@RAM	$F100,x
      1  7c95		       9d 00 f5 	      sta	[RAM]+$F100,x
   1008  7c98		       68		      pla
      0  7c99					      sta@RAM	$F000,x
      1  7c99		       9d 00 f4 	      sta	[RAM]+$F000,x
   1010  7c9c
   1011  7c9c		       ca		      dex
   1012  7c9d		       d0 d9		      bne	.copyPage
   1013  7c9f
   1014  7c9f		       a5 8b		      lda	savedBank
   1015  7ca1		       85 3f		      sta	SET_BANK
   1016  7ca3		       60		      rts
   1017  7ca4
   1018  7ca4
   1019  7ca4							;---------------------------------------------------------------------------------------------------
   1020  7ca4
      0  7ca4					      DEF	CopySinglePiece
      1  7ca4				   BANK_CopySinglePiece SET	_CURRENT_BANK
      2  7ca4				   CopySinglePiece
      3  7ca4				   TEMPORARY_VAR SET	Overlay
      4  7ca4				   TEMPORARY_OFFSET SET	0
      5  7ca4				   VAR_BOUNDARY_CopySinglePiece SET	TEMPORARY_OFFSET
      6  7ca4				   FUNCTION_NAME SET	CopySinglePiece
      7  7ca4					      SUBROUTINE
   1022  7ca4					      SUBROUTINE
      0  7ca4					      TIMING	COPYSINGLEPIECE, (2600)
      1  7ca4		       00 29	   SPEEDOF_COPYSINGLEPIECE =	((2600)/64) + 1
   1024  7ca4
      0  7ca4					      REFER	aiDrawEntireBoard
      1  7ca4				  -	      IF	VAREND_aiDrawEntireBoard > TEMPORARY_VAR
      2  7ca4				  -TEMPORARY_VAR SET	VAREND_aiDrawEntireBoard
      3  7ca4					      ENDIF
      0  7ca4					      REFER	SpecialBody
      1  7ca4					      IF	VAREND_SpecialBody > TEMPORARY_VAR
      2  7ca4				   TEMPORARY_VAR SET	VAREND_SpecialBody
      3  7ca4					      ENDIF
      0  7ca4					      REFER	aiWriteStartPieceBlank
      1  7ca4				  -	      IF	VAREND_aiWriteStartPieceBlank > TEMPORARY_VAR
      2  7ca4				  -TEMPORARY_VAR SET	VAREND_aiWriteStartPieceBlank
      3  7ca4					      ENDIF
      0  7ca4					      REFER	aiDrawPart2
      1  7ca4				  -	      IF	VAREND_aiDrawPart2 > TEMPORARY_VAR
      2  7ca4				  -TEMPORARY_VAR SET	VAREND_aiDrawPart2
      3  7ca4					      ENDIF
      0  7ca4					      REFER	aiMarchB
      1  7ca4				  -	      IF	VAREND_aiMarchB > TEMPORARY_VAR
      2  7ca4				  -TEMPORARY_VAR SET	VAREND_aiMarchB
      3  7ca4					      ENDIF
      0  7ca4					      REFER	aiFinalFlash
      1  7ca4				  -	      IF	VAREND_aiFinalFlash > TEMPORARY_VAR
      2  7ca4				  -TEMPORARY_VAR SET	VAREND_aiFinalFlash
      3  7ca4					      ENDIF
      0  7ca4					      REFER	UNSAFE_showMoveCaptures
      1  7ca4				  -	      IF	VAREND_UNSAFE_showMoveCaptures > TEMPORARY_VAR
      2  7ca4				  -TEMPORARY_VAR SET	VAREND_UNSAFE_showMoveCaptures
      3  7ca4					      ENDIF
      0  7ca4					      REFER	aiMarchToTargetA
      1  7ca4				  -	      IF	VAREND_aiMarchToTargetA > TEMPORARY_VAR
      2  7ca4				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetA
      3  7ca4					      ENDIF
      0  7ca4					      REFER	aiMarchB2
      1  7ca4				  -	      IF	VAREND_aiMarchB2 > TEMPORARY_VAR
      2  7ca4				  -TEMPORARY_VAR SET	VAREND_aiMarchB2
      3  7ca4					      ENDIF
      0  7ca4					      REFER	aiMarchToTargetB
      1  7ca4				  -	      IF	VAREND_aiMarchToTargetB > TEMPORARY_VAR
      2  7ca4				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetB
      3  7ca4					      ENDIF
      0  7ca4					      REFER	FlashPiece
      1  7ca4				  -	      IF	VAREND_FlashPiece > TEMPORARY_VAR
      2  7ca4				  -TEMPORARY_VAR SET	VAREND_FlashPiece
      3  7ca4					      ENDIF
      0  7ca4					      REFER	aiPromotePawnStart
      1  7ca4				  -	      IF	VAREND_aiPromotePawnStart > TEMPORARY_VAR
      2  7ca4				  -TEMPORARY_VAR SET	VAREND_aiPromotePawnStart
      3  7ca4					      ENDIF
      0  7ca4					      REFER	aiChoosePromotePiece
      1  7ca4				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  7ca4				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  7ca4					      ENDIF
      0  7ca4					      VEND	CopySinglePiece
      1  7ca4				  -	      IFNCONST	CopySinglePiece
      2  7ca4				  -	      ECHO	"Incorrect VEND label", CopySinglePiece
      3  7ca4				  -	      ERR
      4  7ca4					      ENDIF
      5  7ca4		       00 a9	   VAREND_CopySinglePiece =	TEMPORARY_VAR
   1039  7ca4
   1040  7ca4							; WARNING: CANNOT USE VAR/OVERLAY IN ANY ROUTINE CALLING THIS!!
   1041  7ca4							; ALSO CAN'T USE IN THIS ROUTINE
   1042  7ca4							; This routine will STOMP on those vars due to __pieceShapeBuffer occupying whole overlay
   1043  7ca4							; @2150 max
   1044  7ca4							; = 33 TIM64T
   1045  7ca4
      0  7ca4					      JSROM	CopySetup
      1  7ca4
      2  7ca4		       a9 09		      lda	#BANK_CopySetup
      3  7ca6		       85 3f		      sta	SET_BANK
      4  7ca8		       20 36 f1 	      jsr	CopySetup
   1047  7cab
      0  7cab					      DEF	InterceptMarkerCopy
      1  7cab				   BANK_InterceptMarkerCopy SET	_CURRENT_BANK
      2  7cab				   InterceptMarkerCopy
      3  7cab				   TEMPORARY_VAR SET	Overlay
      4  7cab				   TEMPORARY_OFFSET SET	0
      5  7cab				   VAR_BOUNDARY_InterceptMarkerCopy SET	TEMPORARY_OFFSET
      6  7cab				   FUNCTION_NAME SET	InterceptMarkerCopy
      7  7cab					      SUBROUTINE
   1049  7cab					      SUBROUTINE
   1050  7cab
   1051  7cab
   1052  7cab							; Copy a piece shape (3 PF bytes wide x 24 lines) to the RAM buffer
   1053  7cab							; y = piece index
   1054  7cab
   1055  7cab		       a9 00		      lda	#BANK_PIECE_VECTOR_BANK
   1056  7cad		       85 3f		      sta	SET_BANK
   1057  7caf
   1058  7caf		       b9 b1 f0 	      lda	PIECE_VECTOR_LO,y
   1059  7cb2		       85 ea		      sta	__ptr
   1060  7cb4		       b9 41 f1 	      lda	PIECE_VECTOR_HI,y
   1061  7cb7		       85 eb		      sta	__ptr+1
   1062  7cb9		       b9 d1 f1 	      lda	PIECE_VECTOR_BANK,y
   1063  7cbc		       85 3f		      sta	SET_BANK
   1064  7cbe
   1065  7cbe		       a0 47		      ldy	#PIECE_SHAPE_SIZE-1
   1066  7cc0		       b1 ea	   .copy      lda	(__ptr),y
   1067  7cc2		       99 a2 00 	      sta	__pieceShapeBuffer,y
   1068  7cc5		       88		      dey
   1069  7cc6		       10 f8		      bpl	.copy
   1070  7cc8
   1071  7cc8		       a5 80		      lda	squareToDraw
   1072  7cca		       38		      sec
   1073  7ccb		       a2 0a		      ldx	#10
   1074  7ccd		       e9 0a	   .sub10     sbc	#10
   1075  7ccf		       ca		      dex
   1076  7cd0		       b0 fb		      bcs	.sub10
   1077  7cd2
   1078  7cd2		       86 3e		      stx	SET_BANK_RAM	; row
   1079  7cd4
   1080  7cd4		       69 08		      adc	#8
   1081  7cd6		       c9 04		      cmp	#4	; CS = right side of screen
   1082  7cd8
   1083  7cd8		       20 9b f1 	      jsr	CopyPieceToRowBitmap
   1084  7cdb
   1085  7cdb		       a5 8b		      lda	savedBank
   1086  7cdd		       85 3f		      sta	SET_BANK
   1087  7cdf		       60		      rts
   1088  7ce0
   1089  7ce0
   1090  7ce0							;---------------------------------------------------------------------------------------------------
   1091  7ce0
      0  7ce0					      DEF	SAFE_getMoveIndex
      1  7ce0				   BANK_SAFE_getMoveIndex SET	_CURRENT_BANK
      2  7ce0				   SAFE_getMoveIndex
      3  7ce0				   TEMPORARY_VAR SET	Overlay
      4  7ce0				   TEMPORARY_OFFSET SET	0
      5  7ce0				   VAR_BOUNDARY_SAFE_getMoveIndex SET	TEMPORARY_OFFSET
      6  7ce0				   FUNCTION_NAME SET	SAFE_getMoveIndex
      7  7ce0					      SUBROUTINE
   1093  7ce0					      SUBROUTINE
   1094  7ce0
   1095  7ce0		       a9 09		      lda	#RAMBANK_PLY
   1096  7ce2		       85 3e		      sta	SET_BANK_RAM
   1097  7ce4		       ad d7 f1 	      lda	moveIndex
   1098  7ce7		       a6 8b		      ldx	savedBank
   1099  7ce9		       86 3f		      stx	SET_BANK
   1100  7ceb		       60		      rts
   1101  7cec
   1102  7cec
   1103  7cec							;---------------------------------------------------------------------------------------------------
   1104  7cec
   1105  7cec				  -	      if	0
   1106  7cec				  -	      DEF	GoFixPieceList
   1107  7cec				  -
   1108  7cec				  -	      sta	SET_BANK_RAM
   1109  7cec				  -	      jsr	FixPieceList
   1110  7cec				  -	      lda	savedBank
   1111  7cec				  -	      sta	SET_BANK
   1112  7cec				  -	      rts
   1113  7cec					      endif
   1114  7cec
   1115  7cec							;---------------------------------------------------------------------------------------------------
   1116  7cec
      0  7cec					      DEF	markerDraw
      1  7cec				   BANK_markerDraw SET	_CURRENT_BANK
      2  7cec				   markerDraw
      3  7cec				   TEMPORARY_VAR SET	Overlay
      4  7cec				   TEMPORARY_OFFSET SET	0
      5  7cec				   VAR_BOUNDARY_markerDraw SET	TEMPORARY_OFFSET
      6  7cec				   FUNCTION_NAME SET	markerDraw
      7  7cec					      SUBROUTINE
   1118  7cec					      SUBROUTINE
   1119  7cec
      0  7cec					      REFER	SAFE_showMoveOptions
      1  7cec					      IF	VAREND_SAFE_showMoveOptions > TEMPORARY_VAR
      2  7cec				   TEMPORARY_VAR SET	VAREND_SAFE_showMoveOptions
      3  7cec					      ENDIF
      0  7cec					      VEND	markerDraw
      1  7cec				  -	      IFNCONST	markerDraw
      2  7cec				  -	      ECHO	"Incorrect VEND label", markerDraw
      3  7cec				  -	      ERR
      4  7cec					      ENDIF
      5  7cec		       00 a4	   VAREND_markerDraw =	TEMPORARY_VAR
   1122  7cec
   1123  7cec		       a2 1c		      ldx	#INDEX_WHITE_MARKER_on_WHITE_SQUARE_0
      0  7cee					      JSROM	CopySetupForMarker
      1  7cee
      2  7cee		       a9 09		      lda	#BANK_CopySetupForMarker
      3  7cf0		       85 3f		      sta	SET_BANK
      4  7cf2		       20 0b f1 	      jsr	CopySetupForMarker
   1125  7cf5		       4c ab fc 	      jmp	InterceptMarkerCopy
   1126  7cf8
   1127  7cf8
   1128  7cf8							;---------------------------------------------------------------------------------------------------
   1129  7cf8
      0  7cf8					      DEF	showPromoteOptions
      1  7cf8				   BANK_showPromoteOptions SET	_CURRENT_BANK
      2  7cf8				   showPromoteOptions
      3  7cf8				   TEMPORARY_VAR SET	Overlay
      4  7cf8				   TEMPORARY_OFFSET SET	0
      5  7cf8				   VAR_BOUNDARY_showPromoteOptions SET	TEMPORARY_OFFSET
      6  7cf8				   FUNCTION_NAME SET	showPromoteOptions
      7  7cf8					      SUBROUTINE
   1131  7cf8					      SUBROUTINE
   1132  7cf8
      0  7cf8					      REFER	aiRollPromotionPiece
      1  7cf8				  -	      IF	VAREND_aiRollPromotionPiece > TEMPORARY_VAR
      2  7cf8				  -TEMPORARY_VAR SET	VAREND_aiRollPromotionPiece
      3  7cf8					      ENDIF
      0  7cf8					      REFER	aiChoosePromotePiece
      1  7cf8				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  7cf8				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  7cf8					      ENDIF
      0  7cf8					      VEND	showPromoteOptions
      1  7cf8				  -	      IFNCONST	showPromoteOptions
      2  7cf8				  -	      ECHO	"Incorrect VEND label", showPromoteOptions
      3  7cf8				  -	      ERR
      4  7cf8					      ENDIF
      5  7cf8		       00 a2	   VAREND_showPromoteOptions =	TEMPORARY_VAR
   1136  7cf8
   1137  7cf8							; X = character shape # (?/N/B/R/Q)
   1138  7cf8
   1139  7cf8		       a4 86		      ldy	toX12
   1140  7cfa		       84 80		      sty	squareToDraw
   1141  7cfc
      0  7cfc					      JSROM	CopySetupForMarker
      1  7cfc
      2  7cfc		       a9 09		      lda	#BANK_CopySetupForMarker
      3  7cfe		       85 3f		      sta	SET_BANK
      4  7d00		       20 0b f1 	      jsr	CopySetupForMarker
   1143  7d03		       4c ab fc 	      jmp	InterceptMarkerCopy
   1144  7d06
   1145  7d06
   1146  7d06							;---------------------------------------------------------------------------------------------------
   1147  7d06
      0  7d06					      DEF	SAFE_BackupBitmaps
      1  7d06				   BANK_SAFE_BackupBitmaps SET	_CURRENT_BANK
      2  7d06				   SAFE_BackupBitmaps
      3  7d06				   TEMPORARY_VAR SET	Overlay
      4  7d06				   TEMPORARY_OFFSET SET	0
      5  7d06				   VAR_BOUNDARY_SAFE_BackupBitmaps SET	TEMPORARY_OFFSET
      6  7d06				   FUNCTION_NAME SET	SAFE_BackupBitmaps
      7  7d06					      SUBROUTINE
   1149  7d06					      SUBROUTINE
   1150  7d06
      0  7d06					      VEND	SAFE_BackupBitmaps
      1  7d06				  -	      IFNCONST	SAFE_BackupBitmaps
      2  7d06				  -	      ECHO	"Incorrect VEND label", SAFE_BackupBitmaps
      3  7d06				  -	      ERR
      4  7d06					      ENDIF
      5  7d06		       00 a2	   VAREND_SAFE_BackupBitmaps =	TEMPORARY_VAR
   1152  7d06
   1153  7d06		       84 3e		      sty	SET_BANK_RAM
   1154  7d08		       20 f4 f2 	      jsr	SaveBitmap
   1155  7d0b		       a5 8b		      lda	savedBank
   1156  7d0d		       85 3f		      sta	SET_BANK
   1157  7d0f		       60		      rts
   1158  7d10
   1159  7d10
   1160  7d10							;---------------------------------------------------------------------------------------------------
   1161  7d10
   1162  7d10				  -	      if	0
   1163  7d10				  -	      DEF	Go_IsSquareUnderAttack
   1164  7d10				  -	      SUBROUTINE
   1165  7d10				  -
   1166  7d10				  -			;REFER aiLookForCheck
   1167  7d10				  -	      VEND	Go_IsSquareUnderAttack
   1168  7d10				  -
   1169  7d10				  -			; Check if passed X12 square is in the "TO" squares in the movelist (and thus under attack)
   1170  7d10				  -
   1171  7d10				  -			; Pass:	 currentPly = which movelist to check
   1172  7d10				  -			;		 A = X12 square to check
   1173  7d10				  -			; Return:	 CC = No, CS = Yes
   1174  7d10				  -
   1175  7d10				  -	      ldx	currentPly
   1176  7d10				  -	      stx	SET_BANK_RAM
   1177  7d10				  -	      jsr	IsSquareUnderAttack
   1178  7d10				  -	      lda	savedBank
   1179  7d10				  -	      sta	SET_BANK
   1180  7d10				  -	      rts
   1181  7d10					      endif
   1182  7d10
   1183  7d10							;---------------------------------------------------------------------------------------------------
   1184  7d10
      0  7d10					      DEF	SAFE_showMoveCaptures
      1  7d10				   BANK_SAFE_showMoveCaptures SET	_CURRENT_BANK
      2  7d10				   SAFE_showMoveCaptures
      3  7d10				   TEMPORARY_VAR SET	Overlay
      4  7d10				   TEMPORARY_OFFSET SET	0
      5  7d10				   VAR_BOUNDARY_SAFE_showMoveCaptures SET	TEMPORARY_OFFSET
      6  7d10				   FUNCTION_NAME SET	SAFE_showMoveCaptures
      7  7d10					      SUBROUTINE
   1186  7d10					      SUBROUTINE
   1187  7d10
      0  7d10					      VEND	SAFE_showMoveCaptures
      1  7d10				  -	      IFNCONST	SAFE_showMoveCaptures
      2  7d10				  -	      ECHO	"Incorrect VEND label", SAFE_showMoveCaptures
      3  7d10				  -	      ERR
      4  7d10					      ENDIF
      5  7d10		       00 a2	   VAREND_SAFE_showMoveCaptures =	TEMPORARY_VAR
   1189  7d10
      0  7d10					      JSROM	UNSAFE_showMoveCaptures
      1  7d10
      2  7d10		       a9 09		      lda	#BANK_UNSAFE_showMoveCaptures
      3  7d12		       85 3f		      sta	SET_BANK
      4  7d14		       20 00 f0 	      jsr	UNSAFE_showMoveCaptures
   1191  7d17		       a5 8b		      lda	savedBank
   1192  7d19		       85 3f		      sta	SET_BANK
   1193  7d1b		       60		      rts
   1194  7d1c
   1195  7d1c
   1196  7d1c							;---------------------------------------------------------------------------------------------------
   1197  7d1c
      0  7d1c					      DEF	GetMoveFrom
      1  7d1c				   BANK_GetMoveFrom SET	_CURRENT_BANK
      2  7d1c				   GetMoveFrom
      3  7d1c				   TEMPORARY_VAR SET	Overlay
      4  7d1c				   TEMPORARY_OFFSET SET	0
      5  7d1c				   VAR_BOUNDARY_GetMoveFrom SET	TEMPORARY_OFFSET
      6  7d1c				   FUNCTION_NAME SET	GetMoveFrom
      7  7d1c					      SUBROUTINE
   1199  7d1c		       a9 09		      lda	#RAMBANK_PLY
   1200  7d1e		       85 3e		      sta	SET_BANK_RAM
   1201  7d20		       a4 8b		      ldy	savedBank
   1202  7d22		       bd 04 f0 	      lda	MoveFrom,x
   1203  7d25		       84 3f		      sty	SET_BANK
   1204  7d27		       60		      rts
   1205  7d28
   1206  7d28
   1207  7d28							;---------------------------------------------------------------------------------------------------
   1208  7d28
      0  7d28					      DEF	GetMoveTo
      1  7d28				   BANK_GetMoveTo SET	_CURRENT_BANK
      2  7d28				   GetMoveTo
      3  7d28				   TEMPORARY_VAR SET	Overlay
      4  7d28				   TEMPORARY_OFFSET SET	0
      5  7d28				   VAR_BOUNDARY_GetMoveTo SET	TEMPORARY_OFFSET
      6  7d28				   FUNCTION_NAME SET	GetMoveTo
      7  7d28					      SUBROUTINE
   1210  7d28					      SUBROUTINE
   1211  7d28
   1212  7d28		       a9 09		      lda	#RAMBANK_PLY
   1213  7d2a		       85 3e		      sta	SET_BANK_RAM
   1214  7d2c		       a4 8b		      ldy	savedBank
   1215  7d2e		       bd 4a f0 	      lda	MoveTo,x
   1216  7d31		       84 3f		      sty	SET_BANK
   1217  7d33		       60		      rts
   1218  7d34
   1219  7d34
   1220  7d34							;---------------------------------------------------------------------------------------------------
   1221  7d34
      0  7d34					      DEF	GetMovePiece
      1  7d34				   BANK_GetMovePiece SET	_CURRENT_BANK
      2  7d34				   GetMovePiece
      3  7d34				   TEMPORARY_VAR SET	Overlay
      4  7d34				   TEMPORARY_OFFSET SET	0
      5  7d34				   VAR_BOUNDARY_GetMovePiece SET	TEMPORARY_OFFSET
      6  7d34				   FUNCTION_NAME SET	GetMovePiece
      7  7d34					      SUBROUTINE
   1223  7d34					      SUBROUTINE
   1224  7d34
   1225  7d34		       a9 09		      lda	#RAMBANK_PLY
   1226  7d36		       85 3e		      sta	SET_BANK_RAM
   1227  7d38		       a4 8b		      ldy	savedBank
   1228  7d3a		       bd 90 f0 	      lda	MovePiece,x
   1229  7d3d		       84 3f		      sty	SET_BANK
   1230  7d3f		       60		      rts
   1231  7d40
   1232  7d40
   1233  7d40							;---------------------------------------------------------------------------------------------------
   1234  7d40
      0  7d40					      DEF	MakeMove
      1  7d40				   BANK_MakeMove SET	_CURRENT_BANK
      2  7d40				   MakeMove
      3  7d40				   TEMPORARY_VAR SET	Overlay
      4  7d40				   TEMPORARY_OFFSET SET	0
      5  7d40				   VAR_BOUNDARY_MakeMove SET	TEMPORARY_OFFSET
      6  7d40				   FUNCTION_NAME SET	MakeMove
      7  7d40					      SUBROUTINE
   1236  7d40					      SUBROUTINE
   1237  7d40
      0  7d40					      REFER	quiesce
      1  7d40					      IF	VAREND_quiesce > TEMPORARY_VAR
      2  7d40				   TEMPORARY_VAR SET	VAREND_quiesce
      3  7d40					      ENDIF
      0  7d40					      REFER	alphaBeta
      1  7d40				  -	      IF	VAREND_alphaBeta > TEMPORARY_VAR
      2  7d40				  -TEMPORARY_VAR SET	VAREND_alphaBeta
      3  7d40					      ENDIF
      0  7d40					      VAR	__capture,1
      1  7d40		       00 a9	   __capture  =	TEMPORARY_VAR
      2  7d40				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7d40
      4  7d40				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7d40				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7d40				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7d40					      ENDIF
      8  7d40				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7d40				  -	      ECHO	"Temporary Variable", __capture, "overflow!"
     10  7d40				  -	      ERR
     11  7d40					      ENDIF
     12  7d40					      LIST	ON
      0  7d40					      VEND	MakeMove
      1  7d40				  -	      IFNCONST	MakeMove
      2  7d40				  -	      ECHO	"Incorrect VEND label", MakeMove
      3  7d40				  -	      ERR
      4  7d40					      ENDIF
      5  7d40		       00 aa	   VAREND_MakeMove =	TEMPORARY_VAR
   1242  7d40
   1243  7d40							; Do a move without any GUI stuff
   1244  7d40							; This function is ALWAYS paired with "unmake_move" - a call to both will leave board
   1245  7d40							; and all relevant flags in original state. This is NOT used for the visible move on the
   1246  7d40							; screen.
   1247  7d40
   1248  7d40
   1249  7d40							; fromPiece	 piece doing the move
   1250  7d40							; fromX12	 current square X12
   1251  7d40							; originX12	 starting square X12
   1252  7d40							; toX12	 ending square X12
   1253  7d40
   1254  7d40
   1255  7d40							; There are potentially "two" moves, with the following
   1256  7d40							; a) Castling, moving both rook and king
   1257  7d40							; b) en-Passant, capturing pawn on "odd" square
   1258  7d40							; These both set "secondary" movers which are used for restoring during unmake_move
   1259  7d40
   1260  7d40		       a9 00		      lda	#0
      0  7d42					      sta@RAM	secondaryPiece
      1  7d42		       8d d4 f5 	      sta	[RAM]+secondaryPiece
   1262  7d45
   1263  7d45
   1264  7d45
   1265  7d45		       ae d8 f1 	      ldx	movePtr
   1266  7d48							;lda SortedMove,x
   1267  7d48							;tax
   1268  7d48
   1269  7d48		       bd 04 f0 	      lda	MoveFrom,x
   1270  7d4b		       85 85		      sta	fromX12
   1271  7d4d		       85 87		      sta	originX12
   1272  7d4f		       bd 4a f0 	      lda	MoveTo,x
   1273  7d52		       85 86		      sta	toX12
   1274  7d54		       bd 90 f0 	      lda	MovePiece,x
   1275  7d57		       85 98		      sta	fromPiece
   1276  7d59
   1277  7d59		       20 b6 f9    .move      jsr	AdjustMaterialPositionalValue
   1278  7d5c
   1279  7d5c							; Modify the board
   1280  7d5c
   1281  7d5c		       a9 08		      lda	#RAMBANK_MOVES_RAM
   1282  7d5e		       85 3e		      sta	SET_BANK_RAM
   1283  7d60		       a4 87		      ldy	originX12
   1284  7d62		       a9 00		      lda	#0
      0  7d64					      sta@RAM	Board,y
      1  7d64		       99 79 f4 	      sta	[RAM]+Board,y
   1286  7d67		       a4 86		      ldy	toX12
   1287  7d69		       b9 79 f0 	      lda	Board,y
   1288  7d6c		       85 a9		      sta	__capture
   1289  7d6e		       a5 98		      lda	fromPiece
   1290  7d70		       29 8f		      and	#PIECE_MASK|FLAG_COLOUR
   1291  7d72		       09 40		      ora	#FLAG_MOVED
      0  7d74					      sta@RAM	Board,y
      1  7d74		       99 79 f4 	      sta	[RAM]+Board,y
   1293  7d77
   1294  7d77		       a5 95		      lda	currentPly
   1295  7d79		       85 3e		      sta	SET_BANK_RAM
   1296  7d7b		       a5 a9		      lda	__capture
      0  7d7d					      sta@RAM	capturedPiece
      1  7d7d		       8d d3 f5 	      sta	[RAM]+capturedPiece
   1298  7d80
   1299  7d80					      IF	CASTLING_ENABLED
   1300  7d80
   1301  7d80							; If the FROM piece has the castle bit set (i.e., it's a king that's just moved 2 squares)
   1302  7d80							; then we find the appropriate ROOK, set the secondary piece "undo" information, and then
   1303  7d80							; redo the moving code (for the rook, this time).
   1304  7d80
   1305  7d80		       20 01 f3 	      jsr	GenCastleMoveForRook
   1306  7d83		       b0 d4		      bcs	.move	; move the rook!
   1307  7d85					      ENDIF
   1308  7d85
   1309  7d85
   1310  7d85				  -	      IF	ENPASSANT_ENABLED
   1311  7d85				  -
   1312  7d85				  -			; TODO : piecelist
   1313  7d85				  -
   1314  7d85				  -	      JSROM	EnPassantCheck
   1315  7d85				  -	      beq	.notEnPassant
   1316  7d85				  -	      jsr	EnPassantRemovePiece	; y = origin X12
   1317  7d85				  -.notEnPassant
   1318  7d85					      ENDIF
   1319  7d85
   1320  7d85
   1321  7d85							;jsr FinaliseMove
   1322  7d85
   1323  7d85							; Swap over sides
   1324  7d85
   1325  7d85		       38		      sec
   1326  7d86		       a9 00		      lda	#0
   1327  7d88		       e5 90		      sbc	Evaluation
   1328  7d8a		       85 90		      sta	Evaluation
   1329  7d8c		       a9 00		      lda	#0
   1330  7d8e		       e5 91		      sbc	Evaluation+1
   1331  7d90		       85 91		      sta	Evaluation+1	; -Evaluation
   1332  7d92
   1333  7d92		       a5 97		      lda	sideToMove
   1334  7d94		       49 80		      eor	#128
   1335  7d96		       85 97		      sta	sideToMove
   1336  7d98
   1337  7d98		       60		      rts
   1338  7d99
   1339  7d99
   1340  7d99							;---------------------------------------------------------------------------------------------------
   1341  7d99
      0  7d99					      DEF	unmake_move
      1  7d99				   BANK_unmake_move SET	_CURRENT_BANK
      2  7d99				   unmake_move
      3  7d99				   TEMPORARY_VAR SET	Overlay
      4  7d99				   TEMPORARY_OFFSET SET	0
      5  7d99				   VAR_BOUNDARY_unmake_move SET	TEMPORARY_OFFSET
      6  7d99				   FUNCTION_NAME SET	unmake_move
      7  7d99					      SUBROUTINE
   1343  7d99					      SUBROUTINE
   1344  7d99
      0  7d99					      REFER	quiesce
      1  7d99					      IF	VAREND_quiesce > TEMPORARY_VAR
      2  7d99				   TEMPORARY_VAR SET	VAREND_quiesce
      3  7d99					      ENDIF
      0  7d99					      REFER	alphaBeta
      1  7d99				  -	      IF	VAREND_alphaBeta > TEMPORARY_VAR
      2  7d99				  -TEMPORARY_VAR SET	VAREND_alphaBeta
      3  7d99					      ENDIF
      0  7d99					      VAR	__unmake_capture, 1
      1  7d99		       00 a9	   __unmake_capture =	TEMPORARY_VAR
      2  7d99				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7d99
      4  7d99				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7d99				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7d99				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7d99					      ENDIF
      8  7d99				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7d99				  -	      ECHO	"Temporary Variable", __unmake_capture, "overflow!"
     10  7d99				  -	      ERR
     11  7d99					      ENDIF
     12  7d99					      LIST	ON
      0  7d99					      VAR	__secondaryBlank, 1
      1  7d99		       00 aa	   __secondaryBlank =	TEMPORARY_VAR
      2  7d99				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7d99
      4  7d99				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7d99				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7d99				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7d99					      ENDIF
      8  7d99				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7d99				  -	      ECHO	"Temporary Variable", __secondaryBlank, "overflow!"
     10  7d99				  -	      ERR
     11  7d99					      ENDIF
     12  7d99					      LIST	ON
      0  7d99					      VEND	unmake_move
      1  7d99				  -	      IFNCONST	unmake_move
      2  7d99				  -	      ECHO	"Incorrect VEND label", unmake_move
      3  7d99				  -	      ERR
      4  7d99					      ENDIF
      5  7d99		       00 ab	   VAREND_unmake_move =	TEMPORARY_VAR
   1350  7d99
   1351  7d99							; restore the board evaluation to what it was at the start of this ply
   1352  7d99							; TODO: note: moved flag seems wrong on restoration
   1353  7d99
   1354  7d99		       ad 02 f0 	      lda	SavedEvaluation
   1355  7d9c		       85 90		      sta	Evaluation
   1356  7d9e		       ad 03 f0 	      lda	SavedEvaluation+1
   1357  7da1		       85 91		      sta	Evaluation+1
   1358  7da3
   1359  7da3
   1360  7da3		       ae d8 f1 	      ldx	movePtr
   1361  7da6							;lda SortedMove,x
   1362  7da6							;tax
   1363  7da6
   1364  7da6		       bd 04 f0 	      lda	MoveFrom,x
   1365  7da9		       85 85		      sta	fromX12
   1366  7dab		       85 87		      sta	originX12
   1367  7dad		       bd 4a f0 	      lda	MoveTo,x
   1368  7db0		       85 86		      sta	toX12
   1369  7db2		       bd 90 f0 	      lda	MovePiece,x
   1370  7db5		       85 98		      sta	fromPiece
   1371  7db7
   1372  7db7		       ad d3 f1 	      lda	capturedPiece
   1373  7dba
   1374  7dba
   1375  7dba							; Modify the board (and the piecelists)
   1376  7dba
   1377  7dba		       a2 08		      ldx	#RAMBANK_MOVES_RAM
   1378  7dbc		       86 3e		      stx	SET_BANK_RAM
   1379  7dbe
   1380  7dbe		       a4 86		      ldy	toX12
      0  7dc0					      sta@RAM	Board,y
      1  7dc0		       99 79 f4 	      sta	[RAM]+Board,y
   1382  7dc3
   1383  7dc3		       a4 85		      ldy	fromX12
   1384  7dc5		       a5 98		      lda	fromPiece
      0  7dc7					      sta@RAM	Board,y
      1  7dc7		       99 79 f4 	      sta	[RAM]+Board,y
   1386  7dca
   1387  7dca
   1388  7dca		       a5 95		      lda	currentPly
   1389  7dcc		       85 3e		      sta	SET_BANK_RAM
   1390  7dce
   1391  7dce							; See if there are any 'secondary' pieces that moved
   1392  7dce							; here we're dealing with reverting a castling or enPassant move
   1393  7dce
   1394  7dce		       ad d4 f1 	      lda	secondaryPiece
   1395  7dd1		       f0 1a		      beq	.noSecondary
   1396  7dd3		       ac d6 f1 	      ldy	secondaryBlank
   1397  7dd6		       84 aa		      sty	__secondaryBlank
   1398  7dd8		       ac d5 f1 	      ldy	secondarySquare
   1399  7ddb
   1400  7ddb
   1401  7ddb		       a2 08		      ldx	#RAMBANK_MOVES_RAM
   1402  7ddd		       86 3e		      stx	SET_BANK_RAM
      0  7ddf					      sta@RAM	Board,y	; put piece back
      1  7ddf		       99 79 f4 	      sta	[RAM]+Board,y
   1404  7de2
   1405  7de2		       a4 aa		      ldy	__secondaryBlank
   1406  7de4		       a9 00		      lda	#0
      0  7de6					      sta@RAM	Board,y	; blank piece origin
      1  7de6		       99 79 f4 	      sta	[RAM]+Board,y
   1408  7de9
   1409  7de9		       a5 95		      lda	currentPly
   1410  7deb		       85 3e		      sta	SET_BANK_RAM
   1411  7ded
   1412  7ded
   1413  7ded				   .noSecondary
   1414  7ded		       a5 97		      lda	sideToMove
   1415  7def		       49 80		      eor	#128
   1416  7df1		       85 97		      sta	sideToMove
   1417  7df3
   1418  7df3		       60		      rts
   1419  7df4
   1420  7df4
   1421  7df4							;---------------------------------------------------------------------------------------------------
   1422  7df4
   1423  7df4							;def quiesce( alpha, beta ):
   1424  7df4							;    stand_pat = evaluate_board()
   1425  7df4							;    if( stand_pat >= beta ):
   1426  7df4							;	  return beta
   1427  7df4							;    if( alpha < stand_pat ):
   1428  7df4							;	  alpha = stand_pat
   1429  7df4							;
   1430  7df4							;    for move in board.legal_moves:
   1431  7df4							;	  if board.is_capture(move):
   1432  7df4							;	      make_move(move)
   1433  7df4							;	      score = -quiesce( -beta, -alpha )
   1434  7df4							;	      unmake_move()
   1435  7df4							;	      if( score >= beta ):
   1436  7df4							;		  return beta
   1437  7df4							;	      if( score > alpha ):
   1438  7df4							;		  alpha = score
   1439  7df4							;    return alpha
   1440  7df4
   1441  7df4
      0  7df4					      DEF	quiesce
      1  7df4				   BANK_quiesce SET	_CURRENT_BANK
      2  7df4				   quiesce
      3  7df4				   TEMPORARY_VAR SET	Overlay
      4  7df4				   TEMPORARY_OFFSET SET	0
      5  7df4				   VAR_BOUNDARY_quiesce SET	TEMPORARY_OFFSET
      6  7df4				   FUNCTION_NAME SET	quiesce
      7  7df4					      SUBROUTINE
   1443  7df4					      SUBROUTINE
   1444  7df4
   1445  7df4							; We are at the lowest level of the tree search, so we want to only continue if there
   1446  7df4							; are captures in effect. Keep going until there are no captures.
   1447  7df4
   1448  7df4							; requriement: correct PLY bank already switched in
   1449  7df4							; --> savedBank too
   1450  7df4
      0  7df4					      COMMON_VARS_ALPHABETA
      1  7df4
      0  7df4					      VAR	__bestMove, 1
      1  7df4		       00 a2	   __bestMove =	TEMPORARY_VAR
      2  7df4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7df4
      4  7df4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7df4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7df4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7df4					      ENDIF
      8  7df4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7df4				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  7df4				  -	      ERR
     11  7df4					      ENDIF
     12  7df4					      LIST	ON
      0  7df4					      VAR	__bestScore, 2
      1  7df4		       00 a3	   __bestScore =	TEMPORARY_VAR
      2  7df4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7df4
      4  7df4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7df4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7df4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7df4					      ENDIF
      8  7df4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7df4				  -	      ECHO	"Temporary Variable", __bestScore, "overflow!"
     10  7df4				  -	      ERR
     11  7df4					      ENDIF
     12  7df4					      LIST	ON
      0  7df4					      VAR	__alpha, 2
      1  7df4		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  7df4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7df4
      4  7df4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7df4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7df4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7df4					      ENDIF
      8  7df4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7df4				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  7df4				  -	      ERR
     11  7df4					      ENDIF
     12  7df4					      LIST	ON
      0  7df4					      VAR	__beta, 2
      1  7df4		       00 a7	   __beta     =	TEMPORARY_VAR
      2  7df4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7df4
      4  7df4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7df4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7df4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7df4					      ENDIF
      8  7df4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7df4				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  7df4				  -	      ERR
     11  7df4					      ENDIF
     12  7df4					      LIST	ON
      6  7df4
      0  7df4					      REFER	alphaBeta
      1  7df4				  -	      IF	VAREND_alphaBeta > TEMPORARY_VAR
      2  7df4				  -TEMPORARY_VAR SET	VAREND_alphaBeta
      3  7df4					      ENDIF
      0  7df4					      VEND	quiesce
      1  7df4				  -	      IFNCONST	quiesce
      2  7df4				  -	      ECHO	"Incorrect VEND label", quiesce
      3  7df4				  -	      ERR
      4  7df4					      ENDIF
      5  7df4		       00 a9	   VAREND_quiesce =	TEMPORARY_VAR
   1454  7df4
   1455  7df4				  -	      if	0
   1456  7df4				  -			; we have already done the Evaluation (incrementally)
   1457  7df4				  -
   1458  7df4				  -			; setup parameters
   1459  7df4				  -			; beta = -alpha, alpha = -beta
   1460  7df4				  -
   1461  7df4				  -	      lda	__beta
   1462  7df4				  -	      sta@RAM	alpha
   1463  7df4				  -	      lda	__beta+1
   1464  7df4				  -	      sta@RAM	alpha+1
   1465  7df4				  -
   1466  7df4				  -	      lda	__alpha
   1467  7df4				  -	      sta@RAM	beta
   1468  7df4				  -	      lda	__alpha+1
   1469  7df4				  -	      sta@RAM	beta+1
   1470  7df4				  -
   1471  7df4				  -	      DEF	QuiesceStart
   1472  7df4				  -
   1473  7df4				  -
   1474  7df4				  -
   1475  7df4				  -			;def quiesce( alpha, beta ):
   1476  7df4				  -			;    stand_pat = evaluate_board()
   1477  7df4				  -			;    if( stand_pat >= beta ):
   1478  7df4				  -			;	  return beta
   1479  7df4				  -			;    if( alpha < stand_pat ):
   1480  7df4				  -			;	  alpha = stand_pat
   1481  7df4				  -			;
   1482  7df4				  -			;    for move in board.legal_moves:
   1483  7df4				  -			;	  if board.is_capture(move):
   1484  7df4				  -			;	      make_move(move)
   1485  7df4				  -			;	      score = -quiesce( -beta, -alpha )
   1486  7df4				  -			;	      unmake_move()
   1487  7df4				  -			;	      if( score >= beta ):
   1488  7df4				  -			;		  return beta
   1489  7df4				  -			;	      if( score > alpha ):
   1490  7df4				  -			;		  alpha = score
   1491  7df4				  -			;    return alpha
   1492  7df4				  -
   1493  7df4				  -
   1494  7df4				  -
   1495  7df4				  -			;    if( stand_pat >= beta ):
   1496  7df4				  -			;	  return beta
   1497  7df4				  -
   1498  7df4				  -	      sec
   1499  7df4				  -	      lda	Evaluation
   1500  7df4				  -	      sbc	beta
   1501  7df4				  -	      lda	Evaluation+1
   1502  7df4				  -	      sbc	beta+1
   1503  7df4				  -	      bvc	.lab0	; if V is 0, N eor V = N, otherwise N eor V = N eor 1
   1504  7df4				  -	      eor	#$80	; A = A eor $80, and N= N eor 1
   1505  7df4				  -.lab0      bmi	.endif0
   1506  7df4				  -
   1507  7df4				  -			;If the N flag is 1, then A (signed) < NUM (signed) and BMI will branch
   1508  7df4				  -			;If the N flag is 0, then A (signed) >= NUM (signed) and BPL will branch
   1509  7df4				  -			;One way to remember which is which is to remember that minus (BMI) is less than, and plus (BPL) is greater than or equal to.
   1510  7df4				  -
   1511  7df4				  -	      lda	beta+1
   1512  7df4				  -	      sta	__bestScore+1
   1513  7df4				  -	      lda	beta
   1514  7df4				  -	      sta	__bestScore
   1515  7df4				  -	      rts
   1516  7df4				  -.endif0
   1517  7df4				  -
   1518  7df4				  -			;    if( alpha < stand_pat ):
   1519  7df4				  -			;	  alpha = stand_pat
   1520  7df4				  -
   1521  7df4				  -	      clc		;!! OK
   1522  7df4				  -	      lda	alpha
   1523  7df4				  -	      sbc	Evaluation
   1524  7df4				  -	      lda	alpha+1
   1525  7df4				  -	      sbc	Evaluation+1
   1526  7df4				  -	      bvc	.lab1	; if V is 0, N eor V = N, otherwise N eor V = N eor 1
   1527  7df4				  -	      eor	#$80	; A = A eor $80, and N= N eor 1
   1528  7df4				  -.lab1      bpl	.endif1
   1529  7df4				  -
   1530  7df4				  -			;If the N flag is 1, then A (signed) < NUM (signed) and BMI will branch
   1531  7df4				  -			;If the N flag is 0, then A (signed) >= NUM (signed) and BPL will branch
   1532  7df4				  -			;One way to remember which is which is to remember that minus (BMI) is less than, and plus (BPL) is greater than or equal to.
   1533  7df4				  -
   1534  7df4				  -
   1535  7df4				  -	      lda	Evaluation
   1536  7df4				  -	      sta@RAM	alpha
   1537  7df4				  -	      lda	Evaluation+1
   1538  7df4				  -	      sta@RAM	alpha+1
   1539  7df4				  -
   1540  7df4				  -.endif1
   1541  7df4				  -
   1542  7df4				  -	      lda	currentPly
   1543  7df4				  -	      sta	savedBank
   1544  7df4				  -
   1545  7df4				  -
   1546  7df4				  -
   1547  7df4				  -	      jsr	newGen
   1548  7df4				  -
   1549  7df4				  -	      lda	moveIndex
   1550  7df4				  -	      sta@RAM	movePtr
   1551  7df4				  -
   1552  7df4				  -.loopMoves
   1553  7df4				  -
   1554  7df4				  -			;lda currentPly
   1555  7df4				  -			;sta SET_BANK_RAM
   1556  7df4				  -
   1557  7df4				  -
   1558  7df4				  -
   1559  7df4				  -	      ldx	movePtr
   1560  7df4				  -	      bpl	.cont
   1561  7df4				  -
   1562  7df4				  -			; finished looking, all moves done - return alpha
   1563  7df4				  -
   1564  7df4				  -	      lda	alpha
   1565  7df4				  -	      sta	__bestScore
   1566  7df4				  -	      lda	alpha+1
   1567  7df4				  -	      sta	__bestScore+1
   1568  7df4				  -	      rts
   1569  7df4				  -
   1570  7df4				  -.cont
   1571  7df4				  -
   1572  7df4				  -
   1573  7df4				  -
   1574  7df4				  -
   1575  7df4				  -			;	  if board.is_capture(move):
   1576  7df4				  -			;	      make_move(move)
   1577  7df4				  -
   1578  7df4				  -	      ldy	MoveTo,x
   1579  7df4				  -
   1580  7df4				  -	      lda	#RAMBANK_MOVES_RAM
   1581  7df4				  -	      sta	SET_BANK_RAM
   1582  7df4				  -	      lda	Board,y
   1583  7df4				  -	      ldx	currentPly
   1584  7df4				  -	      stx	SET_BANK_RAM
   1585  7df4				  -	      and	#PIECE_MASK
   1586  7df4				  -	      beq	.nextMove	; only process capture moves
   1587  7df4				  -
   1588  7df4				  -	      lda	currentPly
   1589  7df4				  -	      sta	SET_BANK_RAM
   1590  7df4				  -
   1591  7df4				  -	      jsr	MakeMove
   1592  7df4				  -
   1593  7df4				  -			; TODO: can't go past MAX_PLY... thing
   1594  7df4				  -
   1595  7df4				  -			; score = -quiesce( -beta, -alpha )
   1596  7df4				  -
   1597  7df4				  -	      sec
   1598  7df4				  -	      lda	#0
   1599  7df4				  -	      sbc	beta
   1600  7df4				  -	      sta	__beta
   1601  7df4				  -	      lda	#0
   1602  7df4				  -	      sbc	beta+1
   1603  7df4				  -	      sta	__beta+1	; -beta
   1604  7df4				  -
   1605  7df4				  -	      sec
   1606  7df4				  -	      lda	#0
   1607  7df4				  -	      sbc	alpha
   1608  7df4				  -	      sta	__alpha
   1609  7df4				  -	      lda	#0
   1610  7df4				  -	      sbc	alpha+1
   1611  7df4				  -	      sta	__alpha+1	; -alpha
   1612  7df4				  -
   1613  7df4				  -	      inc	currentPly
   1614  7df4				  -	      ldx	currentPly
   1615  7df4				  -	      stx	SET_BANK_RAM
   1616  7df4				  -
   1617  7df4				  -	      jsr	quiesce	; recurse
   1618  7df4				  -
   1619  7df4				  -	      dec	currentPly
   1620  7df4				  -	      lda	currentPly
   1621  7df4				  -	      sta	SET_BANK_RAM
   1622  7df4				  -
   1623  7df4				  -	      sec
   1624  7df4				  -	      lda	#0
   1625  7df4				  -	      sbc	__bestScore
   1626  7df4				  -	      sta	__bestScore
   1627  7df4				  -	      lda	#0
   1628  7df4				  -	      sbc	__bestScore+1
   1629  7df4				  -	      sta	__bestScore+1	; "-quiesce(..."
   1630  7df4				  -
   1631  7df4				  -	      jsr	unmake_move
   1632  7df4				  -
   1633  7df4				  -
   1634  7df4				  -			;def quiesce( alpha, beta ):
   1635  7df4				  -			;    stand_pat = evaluate_board()
   1636  7df4				  -			;    if( stand_pat >= beta ):
   1637  7df4				  -			;	  return beta
   1638  7df4				  -			;    if( alpha < stand_pat ):
   1639  7df4				  -			;	  alpha = stand_pat
   1640  7df4				  -			;
   1641  7df4				  -			;    for move in board.legal_moves:
   1642  7df4				  -			;	  if board.is_capture(move):
   1643  7df4				  -			;	      make_move(move)
   1644  7df4				  -			;	      score = -quiesce( -beta, -alpha )
   1645  7df4				  -			;	      unmake_move()
   1646  7df4				  -			;	      if( score >= beta ):
   1647  7df4				  -			;		  return beta
   1648  7df4				  -			;	      if( score > alpha ):
   1649  7df4				  -			;		  alpha = score
   1650  7df4				  -			;    return alpha
   1651  7df4				  -
   1652  7df4				  -
   1653  7df4				  -			;	      if( score >= beta ):
   1654  7df4				  -			;		  return beta
   1655  7df4				  -
   1656  7df4				  -	      sec
   1657  7df4				  -	      lda	__bestScore
   1658  7df4				  -	      sbc	beta
   1659  7df4				  -	      lda	__bestScore+1
   1660  7df4				  -	      sbc	beta+1
   1661  7df4				  -	      bvc	.lab2	; if V is 0, N eor V = N, otherwise N eor V = N eor 1
   1662  7df4				  -	      eor	#$80	; A = A eor $80, and N= N eor 1
   1663  7df4				  -.lab2      bmi	.endif2
   1664  7df4				  -
   1665  7df4				  -			;If the N flag is 1, then A (signed) < NUM (signed) and BMI will branch
   1666  7df4				  -			;If the N flag is 0, then A (signed) >= NUM (signed) and BPL will branch
   1667  7df4				  -			;One way to remember which is which is to remember that minus (BMI) is less than, and plus (BPL) is greater than or equal to.
   1668  7df4				  -
   1669  7df4				  -	      lda	beta
   1670  7df4				  -	      sta	__bestScore
   1671  7df4				  -	      lda	beta+1
   1672  7df4				  -	      sta	__bestScore+1
   1673  7df4				  -	      rts
   1674  7df4				  -
   1675  7df4				  -.endif2
   1676  7df4				  -
   1677  7df4				  -			;	      if( score > alpha ):
   1678  7df4				  -			;		  alpha = score
   1679  7df4				  -
   1680  7df4				  -	      clc		; !! OK
   1681  7df4				  -	      lda	alpha
   1682  7df4				  -	      sbc	__bestScore
   1683  7df4				  -	      lda	alpha+1
   1684  7df4				  -	      sbc	__bestScore+1
   1685  7df4				  -	      bvc	.lab3	; if V is 0, N eor V = N, otherwise N eor V = N eor 1
   1686  7df4				  -	      eor	#$80	; A = A eor $80, and N= N eor 1
   1687  7df4				  -.lab3      bpl	.endif3
   1688  7df4				  -
   1689  7df4				  -			;If the N flag is 1, then A (signed) < NUM (signed) and BMI will branch
   1690  7df4				  -			;If the N flag is 0, then A (signed) >= NUM (signed) and BPL will branch
   1691  7df4				  -			;One way to remember which is which is to remember that minus (BMI) is less than, and plus (BPL) is greater than or equal to.
   1692  7df4				  -
   1693  7df4				  -	      lda	__bestScore
   1694  7df4				  -	      sta@RAM	alpha
   1695  7df4				  -	      lda	__bestScore+1
   1696  7df4				  -	      sta@RAM	alpha+1
   1697  7df4				  -.endif3
   1698  7df4				  -
   1699  7df4				  -
   1700  7df4				  -			; end of move iteration/loop
   1701  7df4				  -
   1702  7df4				  -.nextMove  sec
   1703  7df4				  -	      lda	movePtr
   1704  7df4				  -	      sbc	#1
   1705  7df4				  -	      sta@RAM	movePtr
   1706  7df4				  -	      jmp	.loopMoves
   1707  7df4					      endif
   1708  7df4
   1709  7df4							;---------------------------------------------------------------------------------------------------
   1710  7df4
   1711  7df4					      SUBROUTINE
   1712  7df4
   1713  7df4				   .terminal		;jsr QuiesceStart		  ; with alpha, beta already setup
   1714  7df4							;		      rts
   1715  7df4
   1716  7df4		       a5 90		      lda	Evaluation
   1717  7df6		       85 a3		      sta	__bestScore
   1718  7df8		       a5 91		      lda	Evaluation+1
   1719  7dfa		       85 a4		      sta	__bestScore+1
   1720  7dfc
   1721  7dfc				  -	      if	0
   1722  7dfc				  -	      lda	moveIndex
   1723  7dfc				  -	      bmi	.OF
   1724  7dfc				  -
   1725  7dfc				  -	      sec
   1726  7dfc				  -	      lda	__bestScore
   1727  7dfc				  -	      sbc	moveIndex
   1728  7dfc				  -	      sta	__bestScore
   1729  7dfc				  -	      lda	__bestScore+1
   1730  7dfc				  -	      sbc	#0
   1731  7dfc				  -	      sta	__bestScore+1
   1732  7dfc				  -	      rts
   1733  7dfc				  -
   1734  7dfc				  -
   1735  7dfc				  -
   1736  7dfc				  -.OF
   1737  7dfc					      endif
   1738  7dfc		       60		      rts
   1739  7dfd
   1740  7dfd
   1741  7dfd				   .returnScore
   1742  7dfd
   1743  7dfd							; we've iterated the moves, so 'bestMove' and 'bestScore' are the result
   1744  7dfd
   1745  7dfd		       ad df f1 	      lda	bestScore
   1746  7e00		       85 a3		      sta	__bestScore
   1747  7e02		       ad e0 f1 	      lda	bestScore+1
   1748  7e05		       85 a4		      sta	__bestScore+1	; value of the best move found
   1749  7e07
   1750  7e07		       ad d9 f1 	      lda	bestMove
   1751  7e0a		       85 a2		      sta	__bestMove	; moveIndex of the best move found
   1752  7e0c		       60		      rts
   1753  7e0d
   1754  7e0d
      0  7e0d					      DEF	alphaBeta
      1  7e0d				   BANK_alphaBeta SET	_CURRENT_BANK
      2  7e0d				   alphaBeta
      3  7e0d				   TEMPORARY_VAR SET	Overlay
      4  7e0d				   TEMPORARY_OFFSET SET	0
      5  7e0d				   VAR_BOUNDARY_alphaBeta SET	TEMPORARY_OFFSET
      6  7e0d				   FUNCTION_NAME SET	alphaBeta
      7  7e0d					      SUBROUTINE
   1756  7e0d
   1757  7e0d							; Performs an alpha-beta search.
   1758  7e0d							; The current 'level' is always considered in terms of maximising the evaluation
   1759  7e0d							; To achieve minimisation for the opponent when being considered, the alpha/beta are negated
   1760  7e0d							; and which is which is swapped between each ply
   1761  7e0d
   1762  7e0d							; pass...
   1763  7e0d							; x = depthleft
   1764  7e0d							; SET_BANK_RAM      --> current ply
   1765  7e0d							; __alpha[2] = -alpha
   1766  7e0d							; __beta[2] = -beta
   1767  7e0d
   1768  7e0d
      0  7e0d					      COMMON_VARS_ALPHABETA
      1  7e0d
      0  7e0d					      VAR	__bestMove, 1
      1  7e0d		       00 a2	   __bestMove =	TEMPORARY_VAR
      2  7e0d				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7e0d
      4  7e0d				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7e0d				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7e0d				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7e0d					      ENDIF
      8  7e0d				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7e0d				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  7e0d				  -	      ERR
     11  7e0d					      ENDIF
     12  7e0d					      LIST	ON
      0  7e0d					      VAR	__bestScore, 2
      1  7e0d		       00 a3	   __bestScore =	TEMPORARY_VAR
      2  7e0d				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7e0d
      4  7e0d				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7e0d				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7e0d				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7e0d					      ENDIF
      8  7e0d				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7e0d				  -	      ECHO	"Temporary Variable", __bestScore, "overflow!"
     10  7e0d				  -	      ERR
     11  7e0d					      ENDIF
     12  7e0d					      LIST	ON
      0  7e0d					      VAR	__alpha, 2
      1  7e0d		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  7e0d				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7e0d
      4  7e0d				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7e0d				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7e0d				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7e0d					      ENDIF
      8  7e0d				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7e0d				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  7e0d				  -	      ERR
     11  7e0d					      ENDIF
     12  7e0d					      LIST	ON
      0  7e0d					      VAR	__beta, 2
      1  7e0d		       00 a7	   __beta     =	TEMPORARY_VAR
      2  7e0d				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7e0d
      4  7e0d				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7e0d				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7e0d				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7e0d					      ENDIF
      8  7e0d				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7e0d				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  7e0d				  -	      ERR
     11  7e0d					      ENDIF
     12  7e0d					      LIST	ON
      6  7e0d
      0  7e0d					      REFER	selectmove
      1  7e0d				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  7e0d				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  7e0d					      ENDIF
      0  7e0d					      VEND	alphaBeta
      1  7e0d				  -	      IFNCONST	alphaBeta
      2  7e0d				  -	      ECHO	"Incorrect VEND label", alphaBeta
      3  7e0d				  -	      ERR
      4  7e0d					      ENDIF
      5  7e0d		       00 a9	   VAREND_alphaBeta =	TEMPORARY_VAR
   1772  7e0d
   1773  7e0d
   1774  7e0d							;def alphabeta( alpha, beta, depthleft ):
   1775  7e0d							;    bestscore = -9999
   1776  7e0d							;    if( depthleft == 0 ):
   1777  7e0d							;	  return quiesce( alpha, beta )
   1778  7e0d							;    for move in board.legal_moves:
   1779  7e0d							;	  make_move(move)
   1780  7e0d							;	  score = -alphabeta( -beta, -alpha, depthleft - 1 )
   1781  7e0d							;	  unmake_move()
   1782  7e0d							;	  if( score >= beta ):
   1783  7e0d							;	      return score
   1784  7e0d							;	  if( score > bestscore ):
   1785  7e0d							;	      bestscore = score
   1786  7e0d							;	  if( score > alpha ):
   1787  7e0d							;	      alpha = score
   1788  7e0d							;    return bestscore
   1789  7e0d
      0  7e0d					      stx@RAM	depthLeft
      1  7e0d		       8e de f5 	      stx	[RAM]+depthLeft
   1791  7e10
   1792  7e10
   1793  7e10							; setup parameters
   1794  7e10							; beta = -alpha, alpha = -beta
   1795  7e10							; we want to maximise alpha
   1796  7e10							;  and if score > beta then abort (cutoff)
   1797  7e10
   1798  7e10		       a5 a7		      lda	__beta
      0  7e12					      sta@RAM	alpha
      1  7e12		       8d da f5 	      sta	[RAM]+alpha
   1800  7e15		       a5 a8		      lda	__beta+1
      0  7e17					      sta@RAM	alpha+1
      1  7e17		       8d db f5 	      sta	[RAM]+alpha+1
   1802  7e1a
   1803  7e1a		       a5 a5		      lda	__alpha
      0  7e1c					      sta@RAM	beta
      1  7e1c		       8d dc f5 	      sta	[RAM]+beta
   1805  7e1f		       a5 a6		      lda	__alpha+1
      0  7e21					      sta@RAM	beta+1
      1  7e21		       8d dd f5 	      sta	[RAM]+beta+1
   1807  7e24
   1808  7e24							; on 1st call this becomes alpha = -INF and beta = INF
   1809  7e24							; we're trying to maximise alpha
   1810  7e24
   1811  7e24		       e0 00		      cpx	#0
   1812  7e26		       f0 cc		      beq	.terminal	; --> quiesce
   1813  7e28
   1814  7e28		       a9 02		      lda	#<-(INFINITY-1)
      0  7e2a					      sta@RAM	bestScore
      1  7e2a		       8d df f5 	      sta	[RAM]+bestScore
   1816  7e2d		       a9 80		      lda	#>-(INFINITY-1)
      0  7e2f					      sta@RAM	bestScore+1
      1  7e2f		       8d e0 f5 	      sta	[RAM]+bestScore+1
   1818  7e32
   1819  7e32
   1820  7e32
   1821  7e32							; The evaluation of the current position is a signed 16-bit number
   1822  7e32							; +ve is good for the current side.
   1823  7e32							; This is used during the alpha-beta search for finding best position
   1824  7e32							; Note, this is not the same as the 'Evaluation' which is the current value at ply -- it is the
   1825  7e32							; alphabeta best/worst value of the node!!
   1826  7e32
   1827  7e32
   1828  7e32		       20 3b f2 	      jsr	NewPlyInitialise
   1829  7e35		       20 2f f9 	      jsr	GenerateAllMoves
   1830  7e38
   1831  7e38		       20 78 f3 	      jsr	Sort
   1832  7e3b
   1833  7e3b							; Now iterate the moves one-by-one
   1834  7e3b
   1835  7e3b					      if	1
   1836  7e3b		       ad d7 f1 	      lda	moveIndex
   1837  7e3e		       4a		      lsr
   1838  7e3f		       18		      clc
   1839  7e40		       6d 02 f0 	      adc	SavedEvaluation
      0  7e43					      sta@RAM	SavedEvaluation
      1  7e43		       8d 02 f4 	      sta	[RAM]+SavedEvaluation
   1841  7e46		       ad 03 f0 	      lda	SavedEvaluation+1
   1842  7e49		       69 00		      adc	#0
      0  7e4b					      sta@RAM	SavedEvaluation+1	; + mobility (kind of odd/bad - happens every level)
      1  7e4b		       8d 03 f4 	      sta	[RAM]+SavedEvaluation+1
   1844  7e4e					      endif
   1845  7e4e
   1846  7e4e		       ad d7 f1 	      lda	moveIndex
      0  7e51					      sta@RAM	movePtr
      1  7e51		       8d d8 f5 	      sta	[RAM]+movePtr
   1848  7e54
   1849  7e54
   1850  7e54		       ae d8 f1    .loopMoves ldx	movePtr
   1851  7e57		       30 a4		      bmi	.returnScore
   1852  7e59							;lda SortedMove,x
   1853  7e59							;tax
   1854  7e59
   1855  7e59		       20 40 fd 	      jsr	MakeMove
   1856  7e5c
   1857  7e5c							; "score = -alphabeta( -beta, -alpha, depthleft - 1 )"
   1858  7e5c							; set pareameters for next level --> __alpha, __beta
   1859  7e5c
   1860  7e5c		       38		      sec
   1861  7e5d		       a9 00		      lda	#0
   1862  7e5f		       ed da f1 	      sbc	alpha
   1863  7e62		       85 a5		      sta	__alpha
   1864  7e64		       a9 00		      lda	#0
   1865  7e66		       ed db f1 	      sbc	alpha+1
   1866  7e69		       85 a6		      sta	__alpha+1	; -alpha
   1867  7e6b
   1868  7e6b		       38		      sec
   1869  7e6c		       a9 00		      lda	#0
   1870  7e6e		       ed dc f1 	      sbc	beta
   1871  7e71		       85 a7		      sta	__beta
   1872  7e73		       a9 00		      lda	#0
   1873  7e75		       ed dd f1 	      sbc	beta+1
   1874  7e78		       85 a8		      sta	__beta+1	; -beta
   1875  7e7a
   1876  7e7a		       ae de f1 	      ldx	depthLeft
   1877  7e7d		       ca		      dex
   1878  7e7e
   1879  7e7e		       e6 95		      inc	currentPly
   1880  7e80		       a5 95		      lda	currentPly
   1881  7e82		       85 3e		      sta	SET_BANK_RAM	; self-switch
   1882  7e84
   1883  7e84		       20 0d fe 	      jsr	alphaBeta	; recurse!
   1884  7e87
   1885  7e87		       c6 95		      dec	currentPly
   1886  7e89		       a5 95		      lda	currentPly
   1887  7e8b		       85 3e		      sta	SET_BANK_RAM
   1888  7e8d
   1889  7e8d		       38		      sec
   1890  7e8e		       a9 00		      lda	#0
   1891  7e90		       e5 a3		      sbc	__bestScore
   1892  7e92		       85 a3		      sta	__bestScore
   1893  7e94		       a9 00		      lda	#0
   1894  7e96		       e5 a4		      sbc	__bestScore+1
   1895  7e98		       85 a4		      sta	__bestScore+1	; "-alphabeta....""
   1896  7e9a
   1897  7e9a		       20 99 fd 	      jsr	unmake_move
   1898  7e9d
   1899  7e9d		       ae d8 f1 	      ldx	movePtr
   1900  7ea0							;lda SortedMove,x
   1901  7ea0							;tax
   1902  7ea0
   1903  7ea0		       a5 a3		      lda	__bestScore
      0  7ea2					      sta@RAM	MoveScoreLO,x
      1  7ea2		       9d 00 f5 	      sta	[RAM]+MoveScoreLO,x
   1905  7ea5		       a5 a4		      lda	__bestScore+1
      0  7ea7					      sta@RAM	MoveScoreHI,x
      1  7ea7		       9d 46 f5 	      sta	[RAM]+MoveScoreHI,x
   1907  7eaa
   1908  7eaa
   1909  7eaa							;	  if( score >= beta ):
   1910  7eaa							;	      return score
   1911  7eaa
   1912  7eaa							; an alpha-beta cutoff?
   1913  7eaa							; aborts searching any more moves because the opponent score improves
   1914  7eaa
   1915  7eaa		       38		      sec		; drop for extra speed
   1916  7eab		       a5 a3		      lda	__bestScore
   1917  7ead		       ed dc f1 	      sbc	beta
   1918  7eb0		       a5 a4		      lda	__bestScore+1
   1919  7eb2		       ed dd f1 	      sbc	beta+1
   1920  7eb5		       50 02		      bvc	.lab2	; if V is 0, N eor V = N, otherwise N eor V = N eor 1
   1921  7eb7		       49 80		      eor	#$80	; A = A eor $80, and N= N eor 1
   1922  7eb9		       30 06	   .lab2      bmi	.notScoreGteBeta	; A < NUM
   1923  7ebb
   1924  7ebb		       ad d9 f1 	      lda	bestMove
   1925  7ebe		       85 a2		      sta	__bestMove	; this move!
   1926  7ec0		       60		      rts
   1927  7ec1
   1928  7ec1				   .notScoreGteBeta
   1929  7ec1
   1930  7ec1							;	  if( score > bestscore ):
   1931  7ec1							;	      bestscore = score
   1932  7ec1
   1933  7ec1		       18		      clc		; !! OK. Could be dropped for a bit of speed
   1934  7ec2		       a5 a3		      lda	__bestScore
   1935  7ec4		       ed df f1 	      sbc	bestScore
   1936  7ec7		       a5 a4		      lda	__bestScore+1
   1937  7ec9		       ed e0 f1 	      sbc	bestScore+1
   1938  7ecc		       50 02		      bvc	.lab3	; if V is 0, N eor V = N, otherwise N eor V = N eor 1
   1939  7ece		       49 80		      eor	#$80	; A = A eor $80, and N= N eor 1
   1940  7ed0		       30 10	   .lab3      bmi	.notScoreGtBestScore	; A < NUM
   1941  7ed2
   1942  7ed2		       a5 a3		      lda	__bestScore
      0  7ed4					      sta@RAM	bestScore
      1  7ed4		       8d df f5 	      sta	[RAM]+bestScore
   1944  7ed7		       a5 a4		      lda	__bestScore+1
      0  7ed9					      sta@RAM	bestScore+1
      1  7ed9		       8d e0 f5 	      sta	[RAM]+bestScore+1
   1946  7edc
   1947  7edc							;ldx movePtr
   1948  7edc							;lda SortedMove,x
   1949  7edc		       ad d8 f1 	      lda	movePtr
      0  7edf					      sta@RAM	bestMove
      1  7edf		       8d d9 f5 	      sta	[RAM]+bestMove
   1951  7ee2
   1952  7ee2				   .notScoreGtBestScore
   1953  7ee2
   1954  7ee2
   1955  7ee2							;	  if( score > alpha ):
   1956  7ee2							;	      alpha = score
   1957  7ee2
   1958  7ee2							; We've found a higher scoring move than currently known, so record it
   1959  7ee2
   1960  7ee2		       18		      clc		; !! OK. Could be dropped for a bit of speed
   1961  7ee3		       ad da f1 	      lda	alpha
   1962  7ee6		       e5 a3		      sbc	__bestScore
   1963  7ee8		       ad db f1 	      lda	alpha+1
   1964  7eeb		       e5 a4		      sbc	__bestScore+1
   1965  7eed		       50 02		      bvc	.lab	; if V is 0, N eor V = N, otherwise N eor V = N eor 1
   1966  7eef		       49 80		      eor	#$80	; A = A eor $80, and N= N eor 1
   1967  7ef1		       10 0a	   .lab       bpl	.notScoreGtAlpha	; A >= NUM
   1968  7ef3
   1969  7ef3		       a5 a3		      lda	__bestScore
      0  7ef5					      sta@RAM	alpha
      1  7ef5		       8d da f5 	      sta	[RAM]+alpha
   1971  7ef8		       a5 a4		      lda	__bestScore+1
      0  7efa					      sta@RAM	alpha+1
      1  7efa		       8d db f5 	      sta	[RAM]+alpha+1
   1973  7efd
   1974  7efd		       ae d8 f1    .notScoreGtAlpha ldx	movePtr
   1975  7f00		       ca		      dex
      0  7f01					      stx@RAM	movePtr
      1  7f01		       8e d8 f5 	      stx	[RAM]+movePtr
   1977  7f04		       4c 54 fe 	      jmp	.loopMoves
   1978  7f07
   1979  7f07
   1980  7f07							;---------------------------------------------------------------------------------------------------
   1981  7f07
 FREE BYTES IN FIXED BANK =  $f5
   1982  7f07					      ECHO	"FREE BYTES IN FIXED BANK = ", $FFFC - *
   1983  7f07
   1984  7f07							;---------------------------------------------------------------------------------------------------
   1985  7f07							; The reset vectors
   1986  7f07							; these must live in the fixed bank (last 2K of any ROM image in "3E" scheme)
   1987  7f07
   1988  8000 ????				      SEG	InterruptVectors
   1989  7ffc					      ORG	FIXED_BANK + $7FC
   1990  7ffc					      RORG	$7ffC
   1991  7ffc
   1992  7ffc		       00 f8		      .word.w	Reset	; RESET
   1993  7ffe		       00 f8		      .word.w	Reset	; IRQ	      (not used)
   1994  8000
   1995  8000							;---------------------------------------------------------------------------------------------------
   1996  8000							; EOF
------- FILE ./chess.asm
    542  8000
    543  8000							;END
