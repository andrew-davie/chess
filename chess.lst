------- FILE ./chess.asm LEVEL 1 PASS 4
      1  7800 ????						; Chess
      2  7800 ????						; Atari 2600 Chess display system
      3  7800 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  7800 ????						; andrew@taswegian.com
      5  7800 ????
      6  7800 ????
      7  7800 ????	       00 40	   TIA_BASE_ADDRESS =	$40
      8  7800 ????
      9  7800 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 4
      0  7800 ????				      include	"vcs.h"
      1  7800 ????						; VCS.H
      2  7800 ????						; Version 1.05, 13/November/2003
      3  7800 ????
      4  7800 ????	       00 69	   VERSION_VCS =	105
      5  7800 ????
      6  7800 ????						; This file defines hardware registers and memory mapping for the
      7  7800 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  7800 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  7800 ????						; available at at http://www.atari2600.org/dasm
     10  7800 ????						;
     11  7800 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  7800 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  7800 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  7800 ????						; with your views.  Please contribute, if you think you can improve this
     15  7800 ????						; file!
     16  7800 ????						;
     17  7800 ????						; Latest Revisions...
     18  7800 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  7800 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  7800 ????						;			    This will allow conditional code to verify VCS.H being
     21  7800 ????						;			    used for code assembly.
     22  7800 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  7800 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  7800 ????						;			 mirrored reading/writing differences.	This is more a
     25  7800 ????						;			 readability issue, and binary compatibility with disassembled
     26  7800 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  7800 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  7800 ????						;			 which was broken by the use of segments in this file, as
     29  7800 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  7800 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  7800 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  7800 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  7800 ????						;						   it is safe to leave it undefined, and the base address will
     34  7800 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  7800 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  7800 ????						;			  - register definitions are now generated through assignment
     37  7800 ????						;			    in uninitialised segments.	This allows a changeable base
     38  7800 ????						;			    address architecture.
     39  7800 ????						; 1.0	22/MAR/2003		Initial release
     40  7800 ????
     41  7800 ????
     42  7800 ????						;-------------------------------------------------------------------------------
     43  7800 ????
     44  7800 ????						; TIA_BASE_ADDRESS
     45  7800 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  7800 ????						; Normally 0, the base address should (externally, before including this file)
     47  7800 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  7800 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  7800 ????						; < $40 as a bankswitch.
     50  7800 ????
     51  7800 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  7800 ????			  -TIA_BASE_ADDRESS =	0
     53  7800 ????				      ENDIF
     54  7800 ????
     55  7800 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  7800 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  7800 ????						; *OR* by declaring the label before including this file, eg:
     58  7800 ????						; TIA_BASE_ADDRESS = $40
     59  7800 ????						;   include "vcs.h"
     60  7800 ????
     61  7800 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  7800 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  7800 ????						; for the mirrored ROM hardware registers.
     64  7800 ????
     65  7800 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  7800 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  7800 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  7800 ????
     69  7800 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  7800 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  7800 ????				      ENDIF
     72  7800 ????
     73  7800 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  7800 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  7800 ????				      ENDIF
     76  7800 ????
     77  7800 ????						;-------------------------------------------------------------------------------
     78  7800 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE macro.h LEVEL 2 PASS 4
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREF RED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE _ MACROS.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"_ MACROS.asm"
      1  0000 ????						; MACROS.asm
      2  0000 ????						;---------------------------------------------------------------------------------------------------
      3  0000 ????
      4  0000 ????				      MAC	def
      5  0000 ????			   SLOT_{1}   SET	_BANK_SLOT
      6  0000 ????			   BANK_{1}   SET	SLOT_{1} + _CURRENT_BANK	; bank in which this subroutine resides
      7  0000 ????			   {1}			; entry point
      8  0000 ????			   TEMPORARY_VAR SET	Overlay
      9  0000 ????			   TEMPORARY_OFFSET SET	0
     10  0000 ????			   VAR_BOUNDARY_{1} SET	TEMPORARY_OFFSET
     11  0000 ????			   FUNCTION_NAME SET	{1}
     12  0000 ????				      ENDM		; name of subroutine
     13  0000 ????
     14  0000 ????
     15  0000 ????						;---------------------------------------------------------------------------------------------------
     16  0000 ????
     17  0000 ????				      MAC	ramdef
     18  0000 ????
     19  0000 ????						; Just an alternate name for "DEF" that makes it clear the subroutine is in RAM
     20  0000 ????
     21  0000 ????				      DEF	{1}
     22  0000 ????				      ENDM		; {name of subroutine}
     23  0000 ????
     24  0000 ????
     25  0000 ????						;---------------------------------------------------------------------------------------------------
     26  0000 ????
     27  0000 ????				      MAC	slot
     28  0000 ????
     29  0000 ????				      IF	({1} < 0) || ({1} > 3)
     30  0000 ????				      ECHO	"Illegal bank address/segment location", {1}
     31  0000 ????				      ERR
     32  0000 ????				      ENDIF
     33  0000 ????
     34  0000 ????			   _BANK_ADDRESS_ORIGIN SET	$F000 + ({1} * _ROM_BANK_SIZE)
     35  0000 ????			   _BANK_SLOT SET	{1} * 64	; D7/D6 selector
     36  0000 ????
     37  0000 ????				      ENDM		; {1}
     38  0000 ????
     39  0000 ????
     40  0000 ????						;---------------------------------------------------------------------------------------------------
     41  0000 ????						; Temporary local variables
     42  0000 ????						; usage:
     43  0000 ????						;
     44  0000 ????						;   DEF fna
     45  0000 ????						;	 REF fnc
     46  0000 ????						;	 REF fnd
     47  0000 ????						;	 VAR localVar1,1
     48  0000 ????						;	 VAR ptr,2
     49  0000 ????						;	 VEND fna
     50  0000 ????						;
     51  0000 ????						; The above declares a functino named 'fna'
     52  0000 ????						; The function declares two local variables, 'localVar1' (1 byte) and 'ptr' (2 bytes)
     53  0000 ????						; These variables are given an address in the overlay area which does NOT overlap any of
     54  0000 ????						; the local variables which are declared in the referring functions 'fnc' and 'fnd'
     55  0000 ????						; Although the local variables are available to other functions (i.e., global in scope), care
     56  0000 ????						; should be taken NOT to use them in other functions unless absolutely necessary and required.
     57  0000 ????						; To share local variables between functions, they should be (re)declared in both so that they
     58  0000 ????						; have exactly the same addresses.
     59  0000 ????
     60  0000 ????
     61  0000 ????
     62  0000 ????						; The relative offset into the overlay area for the next variable declaration...
     63  0000 ????			   TEMPORARY_OFFSET SET	0
     64  0000 ????
     65  0000 ????
     66  0000 ????						;---------------------------------------------------------------------------------------------------
     67  0000 ????
     68  0000 ????						; Finalise the declaration block for local variables
     69  0000 ????						; {1} = name of the function for which this block is defined
     70  0000 ????				      MAC	vend
     71  0000 ????						; register the end of variables for this function
     72  0000 ????
     73  0000 ????			   VAREND_{1} =	TEMPORARY_VAR
     74  0000 ????						;V2_._FUNCTION_NAME = TEMPORARY_VAR
     75  0000 ????				      ENDM
     76  0000 ????
     77  0000 ????
     78  0000 ????						;---------------------------------------------------------------------------------------------------
     79  0000 ????
     80  0000 ????						; Note a reference to this function by an external function
     81  0000 ????						; The external function's VEND block is used to guarantee that variables for
     82  0000 ????						; the function we are declaring will start AFTER all other variables in all referencing blocks
     83  0000 ????
     84  0000 ????				      MAC	ref
     85  0000 ????				      IF	VAREND_{1} > TEMPORARY_VAR
     86  0000 ????			   TEMPORARY_VAR SET	VAREND_{1}
     87  0000 ????				      ENDIF
     88  0000 ????				      ENDM		; {1}
     89  0000 ????
     90  0000 ????
     91  0000 ????						;---------------------------------------------------------------------------------------------------
     92  0000 ????
     93  0000 ????						; Define a temporary variable for use in a subroutine
     94  0000 ????						; Will allocate appropriate bytes, and also check for overflow of the available overlay buffer
     95  0000 ????
     96  0000 ????				      MAC	var
     97  0000 ????						;	  ;LIST OFF
     98  0000 ????			   {1}	      =	TEMPORARY_VAR
     99  0000 ????			   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + {2}
    100  0000 ????
    101  0000 ????			   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
    102  0000 ????				      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
    103  0000 ????			   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
    104  0000 ????				      ENDIF
    105  0000 ????				      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
    106  0000 ????				      LIST	ON
    107  0000 ????			   VNAME      SETSTR	{1}
    108  0000 ????				      ECHO	"Temporary Variable", VNAME, "overflow!"
    109  0000 ????				      ERR
    110  0000 ????				      ECHO	"Temporary Variable overlow!"
    111  0000 ????				      ENDIF
    112  0000 ????				      LIST	ON
    113  0000 ????				      ENDM		; { name, size }
    114  0000 ????
    115  0000 ????
    116  0000 ????						;---------------------------------------------------------------------------------------------------
    117  0000 ????
    118  0000 ????				      MAC	rombank
    119  0000 ????				      SEG	ROM_{1}
    120  0000 ????				      ORG	_ORIGIN
    121  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    122  0000 ????			   _BANK_START SET	*
    123  0000 ????			   {1}_START  SET	*
    124  0000 ????			   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
    125  0000 ????			   ROMBANK_{1} SET	_BANK_SLOT + _CURRENT_BANK
    126  0000 ????			   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
    127  0000 ????			   _LAST_BANK SETSTR	{1}
    128  0000 ????			   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    129  0000 ????				      ENDM		; bank name
    130  0000 ????
    131  0000 ????
    132  0000 ????						;---------------------------------------------------------------------------------------------------
    133  0000 ????
    134  0000 ????				      MAC	check_bank_size
    135  0000 ????			   .TEMP      =	* - _BANK_START
    136  0000 ????				      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
    137  0000 ????				      IF	( .TEMP ) > _ROM_BANK_SIZE
    138  0000 ????				      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
    139  0000 ????				      ERR
    140  0000 ????				      ENDIF
    141  0000 ????				      ENDM
    142  0000 ????
    143  0000 ????
    144  0000 ????						;---------------------------------------------------------------------------------------------------
    145  0000 ????
    146  0000 ????				      MAC	check_ram_bank_size
    147  0000 ????			   .TEMP      =	* - _BANK_START
    148  0000 ????				      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
    149  0000 ????				      IF	( .TEMP ) > _RAM_BANK_SIZE
    150  0000 ????				      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
    151  0000 ????				      ERR
    152  0000 ????				      ENDIF
    153  0000 ????				      ENDM
    154  0000 ????
    155  0000 ????
    156  0000 ????						;---------------------------------------------------------------------------------------------------
    157  0000 ????
    158  0000 ????	       00 00	   _TYPE_RAM  =	0
    159  0000 ????	       00 01	   _TYPE_ROM  =	1
    160  0000 ????
    161  0000 ????				      MAC	end_bank
    162  0000 ????				      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
    163  0000 ????				      CHECK_RAM_BANK_SIZE
    164  0000 ????				      ELSE
    165  0000 ????				      CHECK_BANK_SIZE
    166  0000 ????				      ENDIF
    167  0000 ????				      ENDM
    168  0000 ????
    169  0000 ????
    170  0000 ????						;---------------------------------------------------------------------------------------------------
    171  0000 ????
    172  0000 ????				      MAC	rambank
    173  0000 ????
    174  0000 ????				      SEG.U	RAM_{1}
    175  0000 ????				      ORG	ORIGIN_RAM
    176  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    177  0000 ????			   _BANK_START SET	*
    178  0000 ????			   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
    179  0000 ????			   RAMBANK_{1} SET	_BANK_SLOT + _CURRENT_RAMBANK
    180  0000 ????			   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
    181  0000 ????			   _LAST_BANK SETSTR	{1}
    182  0000 ????			   _CURRENT_BANK_TYPE SET	_TYPE_RAM
    183  0000 ????				      ENDM		; {bank name}
    184  0000 ????
    185  0000 ????
    186  0000 ????						;---------------------------------------------------------------------------------------------------
    187  0000 ????
    188  0000 ????						; Failsafe call of function in another bank
    189  0000 ????						; This will check the slot #s for current, call to make sure they're not the same!
    190  0000 ????
    191  0000 ????				      MAC	call
    192  0000 ????				      IF	SLOT_{1} == _BANK_SLOT
    193  0000 ????			   FNAME      SETSTR	{1}
    194  0000 ????				      ECHO	""
    195  0000 ????				      ECHO	"ERROR: Incompatible slot for call to function", FNAME
    196  0000 ????				      ECHO	"Cannot switch bank in use for ", FNAME
    197  0000 ????				      ERR
    198  0000 ????				      ENDIF
    199  0000 ????				      lda	#BANK_{1}
    200  0000 ????				      sta	SET_BANK
    201  0000 ????				      jsr	{1}
    202  0000 ????				      ENDM		; function name
    203  0000 ????
    204  0000 ????
    205  0000 ????						;---------------------------------------------------------------------------------------------------
    206  0000 ????
    207  0000 ????				      MAC	jump
    208  0000 ????				      IF	SLOT_{1} == _BANK_SLOT
    209  0000 ????			   FNAME      SETSTR	{1}
    210  0000 ????				      ECHO	""
    211  0000 ????				      ECHO	"ERROR: Incompatible slot for jump to function", FNAME
    212  0000 ????				      ECHO	"Cannot switch bank in use for ", FNAME
    213  0000 ????				      ERR
    214  0000 ????				      ENDIF
    215  0000 ????				      lda	#BANK_{1}
    216  0000 ????				      sta	SET_BANK
    217  0000 ????				      jmp	{1}
    218  0000 ????				      ENDM		; function name
    219  0000 ????
    220  0000 ????
    221  0000 ????						;---------------------------------------------------------------------------------------------------
    222  0000 ????						; Macro inserts a page break if the object would overlap a page
    223  0000 ????
    224  0000 ????				      MAC	optional_pagebreak
    225  0000 ????
    226  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    227  0000 ????			   .EARLY_LOCATION SET	*
    228  0000 ????				      ALIGN	256
    229  0000 ????				      ECHO	"Page break for", {1}, "wasted", [* - .EARLY_LOCATION]d, "bytes"
    230  0000 ????				      ENDIF
    231  0000 ????				      ENDM		; { labelString, size }
    232  0000 ????
    233  0000 ????
    234  0000 ????						;---------------------------------------------------------------------------------------------------
    235  0000 ????
    236  0000 ????						; @author Fred Quimby
    237  0000 ????						; same as bAtari Basic rnd
    238  0000 ????
    239  0000 ????	       00 b4	   RND_EOR_VAL =	$B4
    240  0000 ????
    241  0000 ????				      MAC	next_random
    242  0000 ????
    243  0000 ????				      lda	rnd
    244  0000 ????				      lsr
    245  0000 ????				      bcc	.skipEOR
    246  0000 ????				      eor	#RND_EOR_VAL
    247  0000 ????			   .skipEOR   sta	rnd
    248  0000 ????
    249  0000 ????				      ENDM
    250  0000 ????
    251  0000 ????
    252  0000 ????						;---------------------------------------------------------------------------------------------------
    253  0000 ????						; Defines a variable of the given size, making sure it doesn't cross a page
    254  0000 ????
    255  0000 ????				      MAC	variable
    256  0000 ????
    257  0000 ????			   .NAME      SETSTR	{1}
    258  0000 ????				      OPTIONAL_PAGEBREAK	.NAME, {2}
    259  0000 ????			   {1}	      ds	{2}
    260  0000 ????
    261  0000 ????				      ENDM		; {name, size}
    262  0000 ????
    263  0000 ????
    264  0000 ????						;---------------------------------------------------------------------------------------------------
    265  0000 ????
    266  0000 ????						;TODO - check
    267  0000 ????
    268  0000 ????				      MAC	allocate
    269  0000 ????
    270  0000 ????			   .NAME      SETSTR	{1}
    271  0000 ????				      OPTIONAL_PAGEBREAK	.NAME, {2}
    272  0000 ????				      DEF	{1}
    273  0000 ????
    274  0000 ????				      ENDM		; {label}, {size}
    275  0000 ????
    276  0000 ????
    277  0000 ????						;---------------------------------------------------------------------------------------------------
    278  0000 ????
    279  0000 ????				      MAC	negeval
    280  0000 ????
    281  0000 ????				      sec
    282  0000 ????				      lda	#0
    283  0000 ????				      sbc	Evaluation
    284  0000 ????				      sta	Evaluation
    285  0000 ????				      lda	#0
    286  0000 ????				      sbc	Evaluation+1
    287  0000 ????				      sta	Evaluation+1
    288  0000 ????
    289  0000 ????				      ENDM
    290  0000 ????
    291  0000 ????
    292  0000 ????						;---------------------------------------------------------------------------------------------------
    293  0000 ????
    294  0000 ????				      MAC	swap
    295  0000 ????
    296  0000 ????				      lda	sideToMove
    297  0000 ????				      eor	#SWAP_SIDE|HUMAN
    298  0000 ????				      sta	sideToMove
    299  0000 ????
    300  0000 ????				      ENDM
    301  0000 ????
    302  0000 ????
    303  0000 ????						;---------------------------------------------------------------------------------------------------
    304  0000 ????						; RAM accessor macros
    305  0000 ????						; ALL RAM usage (reads and writes) should use these
    306  0000 ????						; They automate the write offset address addition, and make it clear what memory is being accessed
    307  0000 ????
    308  0000 ????
    309  0000 ????				      MAC	sta@ram
    310  0000 ????				      sta	[RAM]+{0}
    311  0000 ????				      ENDM		;{}
    312  0000 ????
    313  0000 ????				      MAC	stx@ram
    314  0000 ????				      stx	[RAM]+{0}
    315  0000 ????				      ENDM
    316  0000 ????
    317  0000 ????				      MAC	sty@ram
    318  0000 ????				      sty	[RAM]+{0}
    319  0000 ????				      ENDM
    320  0000 ????
    321  0000 ????				      MAC	sta@ply
    322  0000 ????				      sta	[RAM]+{0}
    323  0000 ????				      ENDM		;{}
    324  0000 ????
    325  0000 ????				      MAC	stx@ply
    326  0000 ????				      stx	[RAM]+{0}
    327  0000 ????				      ENDM
    328  0000 ????
    329  0000 ????				      MAC	sty@ply
    330  0000 ????				      sty	[RAM]+{0}
    331  0000 ????				      ENDM
    332  0000 ????
    333  0000 ????
    334  0000 ????				      MAC	lda@ram
    335  0000 ????				      lda	{0}
    336  0000 ????				      ENDM		;{}
    337  0000 ????
    338  0000 ????				      MAC	ldx@ram
    339  0000 ????				      ldx	{0}
    340  0000 ????				      ENDM		;{}
    341  0000 ????
    342  0000 ????				      MAC	ldy@ram
    343  0000 ????				      ldy	{0}
    344  0000 ????				      ENDM		;{}
    345  0000 ????
    346  0000 ????
    347  0000 ????				      MAC	lda@ply
    348  0000 ????				      lda	{0}
    349  0000 ????				      ENDM		;{}
    350  0000 ????
    351  0000 ????				      MAC	ldx@ply
    352  0000 ????				      ldx	{0}
    353  0000 ????				      ENDM		;{}
    354  0000 ????
    355  0000 ????				      MAC	ldy@ply
    356  0000 ????				      ldy	{0}
    357  0000 ????				      ENDM		;{}
    358  0000 ????
    359  0000 ????				      MAC	adc@ply
    360  0000 ????				      adc	{0}
    361  0000 ????				      ENDM		;{}
    362  0000 ????
    363  0000 ????				      MAC	sbc@ply
    364  0000 ????				      sbc	{0}
    365  0000 ????				      ENDM		;{}
    366  0000 ????
    367  0000 ????				      MAC	cmp@ply
    368  0000 ????				      cmp	{0}
    369  0000 ????				      ENDM		;{}
    370  0000 ????
    371  0000 ????				      MAC	ora@ram
    372  0000 ????				      ora	{0}
    373  0000 ????				      ENDM
    374  0000 ????
    375  0000 ????				      MAC	eor@ram
    376  0000 ????				      eor	{0}
    377  0000 ????				      ENDM
    378  0000 ????
    379  0000 ????				      MAC	and@ram
    380  0000 ????				      and	{0}
    381  0000 ????				      ENDM
    382  0000 ????
    383  0000 ????						;---------------------------------------------------------------------------------------------------
    384  0000 ????
    385  0000 ????				      MAC	set_platform
    386  0000 ????
    387  0000 ????						; 00 = NTSC
    388  0000 ????						; 01 = NTSC
    389  0000 ????						; 10 = PAL-50
    390  0000 ????						; 11 = PAL-60
    391  0000 ????				      lda	SWCHB
    392  0000 ????				      rol
    393  0000 ????				      rol
    394  0000 ????				      rol
    395  0000 ????				      and	#%11
    396  0000 ????				      eor	#PAL
    397  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    398  0000 ????
    399  0000 ????				      ENDM
    400  0000 ????
    401  0000 ????
    402  0000 ????						;---------------------------------------------------------------------------------------------------
    403  0000 ????
    404  0000 ????				      MAC	timecheck
    405  0000 ????
    406  0000 ????				      lda	INTIM
    407  0000 ????				      cmp	#SPEEDOF_{1}
    408  0000 ????				      bcc	{2}
    409  0000 ????
    410  0000 ????				      ENDM		; {ident}, {branch if out of time}
    411  0000 ????
    412  0000 ????
    413  0000 ????						;---------------------------------------------------------------------------------------------------
    414  0000 ????
    415  0000 ????				      MAC	timing
    416  0000 ????
    417  0000 ????			   SPEEDOF_{1} =	({2}/64) + 1
    418  0000 ????
    419  0000 ????				      ENDM		; {label}, {cycles}
    420  0000 ????
    421  0000 ????
    422  0000 ????						;---------------------------------------------------------------------------------------------------
    423  0000 ????						;EOF
------- FILE ./chess.asm
------- FILE piece_defines.h LEVEL 2 PASS 4
      0  0000 ????				      include	"piece_defines.h"
      1  0000 ????						; Copyright (C)2020 Andrew Davie
      2  0000 ????
      3  0000 ????	       00 80	   BLACK      =	128
      4  0000 ????	       00 00	   WHITE      =	0
      5  0000 ????
      6  0000 ????	       00 80	   FLAG_COLOUR =	128	; mask
      7  0000 ????	       00 40	   FLAG_MOVED =	64	; mark ALL pieces when moved. Used for castling
      8  0000 ????						; but maybe useful for evaluation of development
      9  0000 ????	       00 20	   FLAG_ENPASSANT =	32
     10  0000 ????	       00 10	   FLAG_CASTLE =	16
     11  0000 ????
     12  0000 ????						;---------------------------------------------------------------------------------------------------
     13  0000 ????						; DEFINE THE PIECES
     14  0000 ????						; ID lives in bits 0-2
     15  0000 ????
     16  0000 ????	       00 00	   BLANK      =	0
     17  0000 ????	       00 00	   ███  =	BLANK
     18  0000 ????
     19  0000 ????	       00 01	   WPAWN      =	1
     20  0000 ????	       00 01	   WP	      =	WPAWN
     21  0000 ????	       00 02	   BPAWN      =	2
     22  0000 ????	       00 02	   BP	      =	BPAWN
     23  0000 ????	       00 03	   KNIGHT     =	3
     24  0000 ????	       00 03	   N	      =	KNIGHT
     25  0000 ????	       00 04	   BISHOP     =	4
     26  0000 ????	       00 04	   B	      =	BISHOP
     27  0000 ????	       00 05	   ROOK       =	5
     28  0000 ????	       00 05	   R	      =	ROOK
     29  0000 ????	       00 06	   QUEEN      =	6
     30  0000 ????	       00 06	   Q	      =	QUEEN
     31  0000 ????	       00 07	   KING       =	7
     32  0000 ????	       00 07	   K	      =	KING
     33  0000 ????
     34  0000 ????	       00 0f	   PIECE_MASK =	15	; trim off the flags leaving just piece ID
     35  0000 ????
     36  0000 ????						;---------------------------------------------------------------------------------------------------
     37  0000 ????
     38  0000 ????						; Movements
     39  0000 ????
     40  0000 ????	       00 0a	   _UP	      =	10	; up
     41  0000 ????	       ff ff ff ff _LEFT      =	-1	; left
     42  0000 ????	       ff ff ff f6 _DOWN      =	-10	; down
     43  0000 ????	       00 01	   _RIGHT     =	1	; right
     44  0000 ????
     45  0000 ????						; EOF
------- FILE ./chess.asm
     14  0000 ????
     15  0000 ????	       00 00	   VERBOSE    =	0	; set to 1 for compile messages
     16  0000 ????
     17  0000 ????			   ORIGIN     SET	0
     18  0000 ????			   ORIGIN_RAM SET	0
     19  0000 ????
     20  0000 ????						;include "segtime.asm"
     21  0000 ????
     22  0000 ????
     23  0000 ????	       00 00	   _FIRST_BANK =	0	; 3E+ 1st bank holds reset vectors
     24  0000 ????
     25  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     26  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     27  0000 ????						;FIXED_BANK		 = 15 * 2048	       ; ->> 32K
     28  0000 ????						;FIXED_BANK		 = 31 * 2048	       ; ->> 64K
     29  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     30  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     31  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     32  0000 ????
     33  0000 ????	       00 01	   YES	      =	1
     34  0000 ????	       00 00	   NO	      =	0
     35  0000 ????	       00 40	   HUMAN      =	64
     36  0000 ????
     37  0000 ????	       70 00	   INFINITY   =	$7000	;32767
     38  0000 ????
     39  0000 ????
     40  0000 ????						; assemble diagnostics. Remove for release.
     41  0000 ????
     42  0000 ????	       00 00	   TEST_POSITION =	0	; 0=normal, 1 = setup test position
     43  0000 ????	       00 01	   DIAGNOSTICS =	1
     44  0000 ????	       00 01	   QUIESCENCE =	1
     45  0000 ????	       00 00	   ASSERTS    =	0
     46  0000 ????	       00 00	   PVSP       =	0	; player versus player =1
     47  0000 ????	       00 01	   ENPASSANT_ENABLED =	1
     48  0000 ????	       00 01	   CASTLING_ENABLED =	1
     49  0000 ????
     50  0000 ????
     51  0000 ????	       00 02	   SELECT_SWITCH =	2	; (SWCHB & SELECT_SWITCH)  0 == PRESSED
     52  0000 ????
     53  0000 ????
     54  0000 ????						; NOTE: SEARCH_DEPTH cannot be < 3, because the player's moves are generated from PLY+1, and use
     55  0000 ????						; PLY+2 for computer response (thus, 3). The bank allocation gets stomped!
     56  0000 ????
     57  0000 ????
     58  0000 ????	       00 03	   SEARCH_DEPTH =	3
     59  0000 ????	       00 04	   QUIESCE_EXTRA_DEPTH =	4
     60  0000 ????
     61  0000 ????
     62  0000 ????			  -	      IF	SEARCH_DEPTH < 3
     63  0000 ????			  -	      ECHO	"ERROR: Search depth must be >= 3"
     64  0000 ????			  -	      ERR
     65  0000 ????				      ENDIF
     66  0000 ????
     67  0000 ????
     68  0000 ????
     69  0000 ????	       00 07	   PLY_BANKS  =	SEARCH_DEPTH + QUIESCE_EXTRA_DEPTH
     70  0000 ????	       00 07	   MAX_PLY_DEPTH_BANK =	PLY_BANKS	;TODO -- RAMBANK_PLY + PLY_BANKS
     71  0000 ????
     72  0000 ????						;IF RAMBANK_PLY + MAX_PLY_DEPTH_BANK > 31
     73  0000 ????						;    ERR "Not enough RAM for PLY banks"
     74  0000 ????						;ENDIF
     75  0000 ????
     76  0000 ????
     77  0000 ????
     78  0000 ????
     79  0000 ????	       00 80	   SWAP_SIDE  =	128	;TODO + (RAMBANK_PLY ^ (RAMBANK_PLY+1))
     80  0000 ????
     81  0000 ????
     82  0000 ????
     83  0000 ????						; DELAYS
     84  0000 ????
     85  0000 ????	       00 0a	   READY_TO_MOVE_FLASH =	10
     86  0000 ????
     87  0000 ????						;===================================
     88  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     89  0000 ????						;===================================
     90  0000 ????
     91  0000 ????						;-------------------------------------------------------------------------------
     92  0000 ????						; The following are optional YES/NO depending on phase of the moon
     93  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     96  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     97  0000 ????			  -	      IF	FINAL_VERSION = YES
     98  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     99  0000 ????				      ENDIF
    100  0000 ????
    101  0000 ????						;-------------------------------------------------------------------------------
    102  0000 ????
    103  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
    104  0000 ????
    105  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
    106  0000 ????
    107  0000 ????						;------------------------------------------------------------------------------
    108  0000 ????
    109  0000 ????	       00 00	   PLUSCART   =	NO
    110  0000 ????
    111  0000 ????						;------------------------------------------------------------------------------
    112  0000 ????
    113  0000 ????
    114  0000 ????	       00 08	   CHESSBOARD_ROWS =	8	; number of ROWS of chessboard
    115  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    116  0000 ????	       00 48	   PIECE_SHAPE_SIZE =	72	; 3 PF bytes x 24 scanlines
    117  0000 ????
    118  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    119  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    120  0000 ????
    121  0000 ????
    122  0000 ????	       04 00	   RAM_SIZE   =	$400	; address space for write AND read
    123  0000 ????	       02 00	   RAM_WRITE  =	$200	; add this to RAM address when doing writes
    124  0000 ????	       02 00	   RAM	      =	RAM_WRITE
    125  0000 ????
    126  0000 ????	       04 00	   _ROM_BANK_SIZE =	$400
    127  0000 ????	       02 00	   _RAM_BANK_SIZE =	$200
    128  0000 ????
    129  0000 ????
    130  0000 ????						; Platform constants:
    131  0000 ????	       00 02	   PAL	      =	%10
    132  0000 ????	       00 02	   PAL_50     =	PAL|0
    133  0000 ????	       00 03	   PAL_60     =	PAL|1
    134  0000 ????
    135  0000 ????
    136  0000 ????
    137  0000 ????	       00 2e	   TIME_PART_2 =	46
    138  0000 ????	       00 2e	   TIME_PART_1 =	46
    139  0000 ????
    140  0000 ????
    141  0000 ????	       00 00	   SLOT0      =	0
    142  0000 ????	       00 40	   SLOT1      =	64
    143  0000 ????	       00 80	   SLOT2      =	128
    144  0000 ????	       00 c0	   SLOT3      =	192
    145  0000 ????
    146  0000 ????
    147  0000 ????						;---------------------------------------------------------------------------------------------------
    148  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						; Chess
      2  0000 ????						; Atari 2600 Chess display system
      3  0000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  0000 ????						; andrew@taswegian.com
      5  0000 ????
      6 U00ff ????				      SEG.U	variables
      7 U0080					      ORG	$80
      8 U0080
      9 U0080		       00	   squareToDraw ds	1
     10 U0081		       00	   rnd	      ds	1	; random
     11 U0082		       00	   drawDelay  ds	1
     12 U0083		       00	   lastSquareX12 ds	1
     13 U0084
     14 U0084		       00	   drawCount  ds	1
     15 U0085		       00	   fromX12    ds	1
     16 U0086		       00	   toX12      ds	1
     17 U0087		       00	   originX12  ds	1
     18 U0088
     19 U0088		       00	   cursorX12  ds	1
     20 U0089
     21 U0089		       00	   mdelay     ds	1
     22 U008a		       00	   ccur       ds	1
     23 U008b		       00	   aiState    ds	1	; state
     24 U008c		       00	   aiFlashDelay ds	1
     25 U008d
     26 U008d		       00	   aiMoveIndex ds	1
     27 U008e
     28 U008e		       00	   aiFlashPhase ds	1
     29 U008f
     30 U008f		       00 00	   Evaluation ds	2	; tracks value of the board position
     31 U0091
     32 U0091		       00	   currentPiece ds	1
     33 U0092		       00	   currentSquare ds	1
     34 U0093		       00	   enPassantPawn ds	1	; TODO - this belongs in PLY bank
     35 U0094		       00	   currentPly ds	1
     36 U0095
     37 U0095		       00	   sideToMove ds	1	; d7 == side, 0=white, 128 = black
     38 U0096		       00	   fromPiece  ds	1
     39 U0097		       00	   lastPiece  ds	1
     40 U0098		       00	   previousPiece ds	1
     41 U0099
     42 U0099							;Platform			  ds 1		      ; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     43 U0099		       00 00	   speech_addr ds	2
     44 U009b							;bg				  ds 1
     45 U009b
     46 U009b		       00	   capture    ds	1
     47 U009c
     48 U009c					      IF	DIAGNOSTICS
     49 U009c		       00 00 00    positionCount ds	3
     50 U009f					      ENDIF
     51 U009f
     52 U009f							;maxPly			  ds 1
     53 U009f		       00	   flagCheck  ds	1	; -1 = no, #KING = yes
     54 U00a0		       00	   protecting ds	1
     55 U00a1		       00	   randomness ds	1
     56 U00a2		       00 00	   __psb      ds	2
     57 U00a4
     58 U00a4		       00 00	   vkSquare   ds	2	; current move's king traversal squares during castling
     59 U00a6		       00	   human      ds	1	; colour of human
------- FILE ./chess.asm
------- FILE overlays.asm LEVEL 2 PASS 4
      0 U00a7					      include	"overlays.asm"
      1 U00a7							; Chess
      2 U00a7							; Atari 2600 Chess display system
      3 U00a7							; Copyright (c) 2019-2020 Andrew Davie
      4 U00a7							; andrew@taswegian.com
      5 U00a7
      6 U00a7							;---------------------------------------------------------------------------------------------------
      7 U00a7							; OVERLAYS!
      8 U00a7							; These variables are overlays, and should be managed with care
      9 U00a7							; They co-exist (each "OVERLAY" starts at the zero-page variable "Overlay"
     10 U00a7							; and thus, overlays cannot be used at the same time (that is, you cannot
     11 U00a7							; use a variable in overlay #1 while at the same time using a variable in
     12 U00a7							; overlay #2
     13 U00a7
     14 U00a7							; for clarity, prefix ALL overlay variables with double-underscore (__)
     15 U00a7
     16 U00a7							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
     17 U00a7							; ensure this by using the VALIDATE_OVERLAY macro
     18 U00a7							;---------------------------------------------------------------------------------------------------
     19 U00a7
     20 U00a7
     21 U00a7				   OVERLAY_SIZE SET	$4C	; maximum size
     22 U00a7				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	0
     23 U00a7
     24 U00a7
     25 U00a7							; This overlay variable is used for the overlay variables.  That's OK.
     26 U00a7							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
     27 U00a7							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
     28 U00a7							; (especially the latter ones) are only used in rare occasions.
     29 U00a7
     30 U00a7							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
     31 U00a7							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
     32 U00a7
      0 U00a7					      DEF	Overlay
      1 U00a7				   SLOT_Overlay SET	_BANK_SLOT
      2 U00a7				   BANK_Overlay SET	SLOT_Overlay + _CURRENT_BANK
      3 U00a7				   Overlay
      4 U00a7				   TEMPORARY_VAR SET	Overlay
      5 U00a7				   TEMPORARY_OFFSET SET	0
      6 U00a7				   VAR_BOUNDARY_Overlay SET	TEMPORARY_OFFSET
      7 U00a7				   FUNCTION_NAME SET	Overlay
     34 U00a7		       00 00 00 00*	      ds	OVERLAY_SIZE	;--> overlay (share) variables
     35 U00f3				   END_OF_OVERLAY
     36 U00f3
     37 U00f3							;---------------------------------------------------------------------------------------------------
     38 U00f3							; And now... the overlays....
     39 U00f3
 ---- OVERLAYS ( $4c bytes ) ----
     40 U00f3					      ECHO	"---- OVERLAYS (", OVERLAY_SIZE, "bytes ) ----"
     41 U00f3
     42 U00f3							;---------------------------------------------------------------------------------------------------
     43 U00f3
      0 U00f3					      DEF	Variable_PieceShapeBuffer
      1 U00f3				   SLOT_Variable_PieceShapeBuffer SET	_BANK_SLOT
      2 U00f3				   BANK_Variable_PieceShapeBuffer SET	SLOT_Variable_PieceShapeBuffer + _CURRENT_BANK
      3 U00f3				   Variable_PieceShapeBuffer
      4 U00f3				   TEMPORARY_VAR SET	Overlay
      5 U00f3				   TEMPORARY_OFFSET SET	0
      6 U00f3				   VAR_BOUNDARY_Variable_PieceShapeBuffer SET	TEMPORARY_OFFSET
      7 U00f3				   FUNCTION_NAME SET	Variable_PieceShapeBuffer
      0 U00f3					      VAR	__pieceShapeBuffer, PIECE_SHAPE_SIZE
      1 U00f3
      2 U00f3		       00 a7	   __pieceShapeBuffer =	TEMPORARY_VAR
      3 U00f3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + PIECE_SHAPE_SIZE
      4 U00f3
      5 U00f3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6 U00f3					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7 U00f3				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8 U00f3					      ENDIF
      9 U00f3				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10 U00f3				  -	      LIST	ON
     11 U00f3				  -VNAME      SETSTR	__pieceShapeBuffer
     12 U00f3				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13 U00f3				  -	      ERR
     14 U00f3				  -	      ECHO	"Temporary Variable overlow!"
     15 U00f3					      ENDIF
     16 U00f3					      LIST	ON
      0 U00f3					      VEND	Variable_PieceShapeBuffer
      1 U00f3
      2 U00f3
      3 U00f3		       00 ef	   VAREND_Variable_PieceShapeBuffer =	TEMPORARY_VAR
      4 U00f3
     47 U00f3
     48 U00f3							;---------------------------------------------------------------------------------------------------
     49 U00f3
     50 U00f3
     51 U00f3					      ORG	END_OF_OVERLAY
 ---- END OF OVERLAYS ----
     52 U00f3					      ECHO	"---- END OF OVERLAYS ----"
 MAXIMUM OVERLAY SIZE NEEDED =  $48
     53 U00f3					      ECHO	"MAXIMUM OVERLAY SIZE NEEDED = ", MAXIMUM_REQUIRED_OVERLAY_SIZE
     54 U00f3
     55 U00f3							;EOF
------- FILE ./chess.asm
------- FILE stack.asm LEVEL 2 PASS 4
      0 U00f3					      include	"stack.asm"
      1 U00f3							; Chess
      2 U00f3							; Atari 2600 Chess display system
      3 U00f3							; Copyright (c) 2019-2020 Andrew Davie
      4 U00f3							; andrew@taswegian.com
      5 U00f3
      6 U00f3
      7 U00f3		       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
      8 U00f3		       00 f3	   TOP_OF_STACK =	$FF-RESERVED_FOR_STACK
      9 U00f3
     10 U00f3		       00 00 00 00*	      ds	RESERVED_FOR_STACK
     11 U00ff
     12 U00ff							; WARNING/NOTE - the alphabeta search violates the above size constraints
     13 U00ff							; HOWEVER, the "OVERLAY" segment is beneath this, and will be stomped, depending on # plys
     14 U00ff							;  but since overlay is not generally stressed during alphabeta, we're good.
     15 U00ff
     16 U00ff							; Ensure there isn't any stomping of stack/overlay excess usage
     17 U00ff
 Overlay boundary:  $ef
     18 U00ff					      ECHO	"Overlay boundary: ", Overlay + MAXIMUM_REQUIRED_OVERLAY_SIZE
 Stack boundary:  $f1
     19 U00ff					      ECHO	"Stack boundary: ", $FF- PLY_BANKS*2
     20 U00ff
     21 U00ff				  -	      IF	($FF - PLY_BANKS*2) < (Overlay + MAXIMUM_REQUIRED_OVERLAY_SIZE)
     22 U00ff				  -	      ECHO	"ERROR: Not enough reserved space for stack with given #PLY"
     23 U00ff				  -	      ERR
     24 U00ff					      ENDIF
     25 U00ff
     26 U00ff							;IF TOP_OF_STACK <= (Overlay + MAXIMUM_REQUIRED_OVERLAY_SIZE)
     27 U00ff							;    ECHO "ERROR: Not enough reserved space for stack"
     28 U00ff							;    ERR
     29 U00ff							;ENDIF
     30 U00ff
     31 U00ff
------- FILE ./chess.asm
    152 U00ff
 FREE BYTES IN ZERO PAGE =  $0
    153 U00ff					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    154 U00ff				  -	      IF	* > $FF
    155 U00ff				  -	      ERR	"Zero Page overflow!"
    156 U00ff					      ENDIF
    157 U00ff
    158 U00ff							;------------------------------------------------------------------------------
    159 U00ff							;##############################################################################
    160 U00ff							;------------------------------------------------------------------------------
    161 U00ff
    162 U00ff							; NOW THE VERY INTERESTING '3E' RAM BANKS
    163 U00ff							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 512 bytes TOTAL ACCESSIBLE
    164 U00ff							; IN A 1K MEMORY SPACE
    165 U00ff
    166 U00ff
    167 U00ff							;---------------------------------------------------------------------------------------------------
    168 U00ff
    169 U00ff
    170 U00ff					      MAC	phase
    171 U00ff					      lda	#AI_{1}
    172 U00ff					      sta	aiState
    173 U00ff					      ENDM		;#
    174 U00ff
    175 U00ff
    176 U00ff							;--------------------------------------------------------------------------------
    177 U00ff
------- FILE _ PIECE MACROS.asm LEVEL 2 PASS 4
      0 U00ff					      include	"_ PIECE MACROS.asm"
      1 U00ff							; Copyright (C)2020 Andrew Davie
      2 U00ff							; Common macros for piece move handlers
      3 U00ff
      4 U00ff							;---------------------------------------------------------------------------------------------------
      5 U00ff							; Looks at a square offset {1} to see if piece can move to it
      6 U00ff							; Adds the square to the movelist if it can
      7 U00ff							; Keeps moving in the same direction until it's blocked/off=board
      8 U00ff
      9 U00ff					      MAC	move_towards
     10 U00ff					      SUBROUTINE
     11 U00ff
     12 U00ff							; = 76 for single square (empty/take)
     13 U00ff
     14 U00ff					      lda	#0
     15 U00ff					      sta	capture
     16 U00ff
     17 U00ff					      ldx	currentSquare	; 3
     18 U00ff					      bne	.project	; 3   unconditional
     19 U00ff
     20 U00ff				   .empty     jsr	AddMove	; 57
     21 U00ff				   .project   ldy	ValidSquare+{1},x	; 4
     22 U00ff					      bmi	.invalid	; 2/3 off board!
     23 U00ff					      lda	Board,y	; 4   piece @ destination
     24 U00ff					      beq	.empty	; 2/3
     25 U00ff					      sta	capture
     26 U00ff					      eor	currentPiece	; 3
     27 U00ff					      bpl	.invalid	; 2/3 same colour
     28 U00ff					      jsr	AddMove	; 57  and exit
     29 U00ff
     30 U00ff				   .invalid
     31 U00ff
     32 U00ff					      ENDM
     33 U00ff
     34 U00ff
     35 U00ff							;---------------------------------------------------------------------------------------------------
     36 U00ff
     37 U00ff					      MAC	move_to
     38 U00ff					      SUBROUTINE
     39 U00ff
     40 U00ff					      ldy	ValidSquare+{1},x
     41 U00ff					      bmi	.invalid	; off board!
     42 U00ff					      lda	Board,y	; piece @ destination
     43 U00ff					      sta	capture
     44 U00ff					      beq	.squareEmpty
     45 U00ff					      eor	currentPiece
     46 U00ff					      bpl	.invalid	; same colour
     47 U00ff				   .squareEmpty jsr	AddMove
     48 U00ff				   .invalid
     49 U00ff
     50 U00ff					      ENDM
     51 U00ff
     52 U00ff
     53 U00ff							;---------------------------------------------------------------------------------------------------
     54 U00ff
     55 U00ff					      MAC	move_to_x
     56 U00ff					      ldx	currentSquare
     57 U00ff					      MOVE_TO	{1}
     58 U00ff					      ENDM
     59 U00ff
     60 U00ff
     61 U00ff							;---------------------------------------------------------------------------------------------------
     62 U00ff							; EOF
------- FILE ./chess.asm
    179 U00ff
------- FILE @3 STARTBANK.asm LEVEL 2 PASS 4
      0 U00ff					      include	"@3 STARTBANK.asm"	; MUST be first ROM bank
      1 U00ff				   _ORIGIN    SET	_FIRST_BANK
      2 U00ff
      3 U00ff							; This is the first (START UP) bank for the 3E+ cartridge/scheme
      4 U00ff							; This bank is guaranteed to be mapped to SLOT 3 by the hardware implementation.
      5 U00ff							; It must contain the reset vector for the game!
      6 U00ff							; It does NOT need to be switched in for the remainder of the game!
      7 U00ff
      8 U00ff							;---------------------------------------------------------------------------------------------------
      9 U00ff
      0 U00ff					      SLOT	3
      1 U00ff
      2 U00ff				  -	      IF	(3 < 0) || (3 > 3)
      3 U00ff				  -	      ECHO	"Illegal bank address/segment location", 3
      4 U00ff				  -	      ERR
      5 U00ff					      ENDIF
      6 U00ff
      7 U00ff				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      8 U00ff				   _BANK_SLOT SET	3 * 64
      9 U00ff
      0 U00ff					      ROMBANK	STARTBANK
      1  0400 ????				      SEG	ROM_STARTBANK
      2  0000					      ORG	_ORIGIN
      3  0000					      RORG	_BANK_ADDRESS_ORIGIN
      4  0000				   _BANK_START SET	*
      5  0000				   STARTBANK_START SET	*
      6  0000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  0000				   ROMBANK_STARTBANK SET	_BANK_SLOT + _CURRENT_BANK
      8  0000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  0000				   _LAST_BANK SETSTR	STARTBANK
     10  0000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     12  0000
     13  0000
     14  0000							;---------------------------------------------------------------------------------------------------
     15  0000
      0  0000					      DEF	StartCartridge
      1  0000				   SLOT_StartCartridge SET	_BANK_SLOT
      2  0000				   BANK_StartCartridge SET	SLOT_StartCartridge + _CURRENT_BANK
      3  0000				   StartCartridge
      4  0000				   TEMPORARY_VAR SET	Overlay
      5  0000				   TEMPORARY_OFFSET SET	0
      6  0000				   VAR_BOUNDARY_StartCartridge SET	TEMPORARY_OFFSET
      7  0000				   FUNCTION_NAME SET	StartCartridge
     17  0000
      0  0000					      CLEAN_START
      1  0000		       78		      sei
      2  0001		       d8		      cld
      3  0002
      4  0002		       a2 00		      ldx	#0
      5  0004		       8a		      txa
      6  0005		       a8		      tay
      7  0006		       ca	   .CLEAR_STACK dex
      8  0007		       9a		      txs
      9  0008		       48		      pha
     10  0009		       d0 fb		      bne	.CLEAR_STACK
     11  000b
     19  000b
      0  000b					      JUMP	StartupBankReset	;@0
      1  000b				  -	      IF	SLOT_StartupBankReset == _BANK_SLOT
      2  000b				  -FNAME      SETSTR	StartupBankReset
      3  000b				  -	      ECHO	""
      4  000b				  -	      ECHO	"ERROR: Incompatible slot for jump to function", FNAME
      5  000b				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  000b				  -	      ERR
      7  000b					      ENDIF
      8  000b		       a9 01		      lda	#BANK_StartupBankReset
      9  000d		       85 3f		      sta	SET_BANK
     10  000f		       4c 00 f0 	      jmp	StartupBankReset
     21  0012
     22  0012							;---------------------------------------------------------------------------------------------------
     23  0012
     24  0012							; Lots of free space here
     25  0012
     26  0012							;---------------------------------------------------------------------------------------------------
     27  0012
 FREE BYTES IN STARTBANK =  $3ea
     28  0012					      ECHO	"FREE BYTES IN STARTBANK = ", $FFFC - *
     29  0012
     30  0012
     31  0012							;---------------------------------------------------------------------------------------------------
     32  0012
     33  0012							; The reset vectors
     34  0012							; these must live in the fixed bank (bank 0 in 3E+ format)
     35  0012
     36  03fc					      ORG	_FIRST_BANK + $3FC
     37  03fc					      RORG	$FFFC
      0  03fc					      DEF	InterruptVectors
      1  03fc				   SLOT_InterruptVectors SET	_BANK_SLOT
      2  03fc				   BANK_InterruptVectors SET	SLOT_InterruptVectors + _CURRENT_BANK
      3  03fc				   InterruptVectors
      4  03fc				   TEMPORARY_VAR SET	Overlay
      5  03fc				   TEMPORARY_OFFSET SET	0
      6  03fc				   VAR_BOUNDARY_InterruptVectors SET	TEMPORARY_OFFSET
      7  03fc				   FUNCTION_NAME SET	InterruptVectors
     39  03fc					      SUBROUTINE
     40  03fc
     41  03fc		       00 fc		      .word.w	StartCartridge	; RESET
     42  03fe		       00 fc		      .word.w	StartCartridge	; IRQ	      (not used)
     43  0400
     44  0400
     45  0400							;---------------------------------------------------------------------------------------------------
     46  0400
      0  0400					      END_BANK
      1  0400				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  0400				  -	      CHECK_RAM_BANK_SIZE
      3  0400					      ELSE
      0  0400					      CHECK_BANK_SIZE
      1  0400		       04 00	   .TEMP      =	* - _BANK_START
 ROM bank # 1 STARTBANK size = $400 free = -1
      2  0400					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  0400				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  0400				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  0400				  -	      ERR
      6  0400					      ENDIF
      5  0400					      ENDIF
     48  0400
     49  0400							;---------------------------------------------------------------------------------------------------
     50  0400							;EOF
------- FILE ./chess.asm
    181  0400
------- FILE @0 HOME.asm LEVEL 2 PASS 4
      0  0400					      include	"@0 HOME.asm"
      1  0400							;---------------------------------------------------------------------------------------------------
      2  0400							; @0 HOME.asm
      3  0400
      4  0400							; Atari 2600 Chess
      5  0400							; Copyright (c) 2019-2020 Andrew Davie
      6  0400							; andrew@taswegian.com
      7  0400
      8  0400							;---------------------------------------------------------------------------------------------------
      9  0400
      0  0400					      SLOT	0
      1  0400
      2  0400				  -	      IF	(0 < 0) || (0 > 3)
      3  0400				  -	      ECHO	"Illegal bank address/segment location", 0
      4  0400				  -	      ERR
      5  0400					      ENDIF
      6  0400
      7  0400				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      8  0400				   _BANK_SLOT SET	0 * 64
      9  0400
      0  0400					      ROMBANK	LOCKED_BANK
      1  07e0 ????				      SEG	ROM_LOCKED_BANK
      2  0400					      ORG	_ORIGIN
      3  0400					      RORG	_BANK_ADDRESS_ORIGIN
      4  0400				   _BANK_START SET	*
      5  0400				   LOCKED_BANK_START SET	*
      6  0400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  0400				   ROMBANK_LOCKED_BANK SET	_BANK_SLOT + _CURRENT_BANK
      8  0400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  0400				   _LAST_BANK SETSTR	LOCKED_BANK
     10  0400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     12  0400
     13  0400
     14  0400							;---------------------------------------------------------------------------------------------------
     15  0400
      0  0400					      DEF	StartupBankReset
      1  0400				   SLOT_StartupBankReset SET	_BANK_SLOT
      2  0400				   BANK_StartupBankReset SET	SLOT_StartupBankReset + _CURRENT_BANK
      3  0400				   StartupBankReset
      4  0400				   TEMPORARY_VAR SET	Overlay
      5  0400				   TEMPORARY_OFFSET SET	0
      6  0400				   VAR_BOUNDARY_StartupBankReset SET	TEMPORARY_OFFSET
      7  0400				   FUNCTION_NAME SET	StartupBankReset
     17  0400					      SUBROUTINE
     18  0400
      0  0400					      VEND	StartupBankReset
      1  0400
      2  0400
      3  0400		       00 a7	   VAREND_StartupBankReset =	TEMPORARY_VAR
      4  0400
     20  0400
     21  0400
     22  0400							;CALL TitleScreen
     23  0400
      0  0400					      CALL	CartInit
      1  0400				  -	      IF	SLOT_CartInit == _BANK_SLOT
      2  0400				  -FNAME      SETSTR	CartInit
      3  0400				  -	      ECHO	""
      4  0400				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0400				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0400				  -	      ERR
      7  0400					      ENDIF
      8  0400		       a9 42		      lda	#BANK_CartInit
      9  0402		       85 3f		      sta	SET_BANK
     10  0404		       20 00 f4 	      jsr	CartInit
      0  0407					      CALL	SetupBanks
      1  0407				  -	      IF	SLOT_SetupBanks == _BANK_SLOT
      2  0407				  -FNAME      SETSTR	SetupBanks
      3  0407				  -	      ECHO	""
      4  0407				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0407				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0407				  -	      ERR
      7  0407					      ENDIF
      8  0407		       a9 42		      lda	#BANK_SetupBanks
      9  0409		       85 3f		      sta	SET_BANK
     10  040b		       20 30 f4 	      jsr	SetupBanks
      0  040e					      CALL	InitialisePieceSquares
      1  040e				  -	      IF	SLOT_InitialisePieceSquares == _BANK_SLOT
      2  040e				  -FNAME      SETSTR	InitialisePieceSquares
      3  040e				  -	      ECHO	""
      4  040e				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  040e				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  040e				  -	      ERR
      7  040e					      ENDIF
      8  040e		       a9 42		      lda	#BANK_InitialisePieceSquares
      9  0410		       85 3f		      sta	SET_BANK
     10  0412		       20 8f f4 	      jsr	InitialisePieceSquares
     27  0415		       20 50 f2 	      jsr	ListPlayerMoves	;@0
     28  0418
     29  0418
     30  0418				   .StartFrame
     31  0418
     32  0418
     33  0418							; START OF FRAME
     34  0418
     35  0418		       a9 0e		      lda	#%1110	; VSYNC ON
     36  041a		       85 42	   .loopVSync3 sta	WSYNC
     37  041c		       85 40		      sta	VSYNC
     38  041e		       4a		      lsr
     39  041f		       d0 f9		      bne	.loopVSync3	; branch until VYSNC has been reset
     40  0421
     41  0421		       85 41		      sta	VBLANK
     42  0423
     43  0423		       a0 2e		      ldy	#TIME_PART_1
     44  0425		       8c 96 02 	      sty	TIM64T
     45  0428
     46  0428							; LOTS OF PROCESSING TIME - USE IT
     47  0428
     48  0428
     49  0428
     50  0428		       20 92 f1 	      jsr	AiStateMachine
     51  042b
     52  042b				  -	      IF	ASSERTS
     53  042b				  -			; Catch timer expired already
     54  042b				  -			;		      bit TIMINT
     55  042b				  -			;.whoops	      bmi .whoops
     56  042b					      ENDIF
     57  042b
     58  042b
     59  042b		       2c 85 02    .wait      bit	TIMINT
     60  042e		       10 fb		      bpl	.wait
     61  0430
     62  0430
     63  0430							; START OF VISIBLE SCANLINES
     64  0430
     65  0430
      0  0430					      CALL	longD
      1  0430				  -	      IF	SLOT_longD == _BANK_SLOT
      2  0430				  -FNAME      SETSTR	longD
      3  0430				  -	      ECHO	""
      4  0430				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0430				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0430				  -	      ERR
      7  0430					      ENDIF
      8  0430		       a9 89		      lda	#BANK_longD
      9  0432		       85 3f		      sta	SET_BANK
     10  0434		       20 16 f8 	      jsr	longD
     67  0437
     68  0437
     69  0437		       a2 80		      ldx	#SLOT_DrawRow	; + BANK_DrawRow
     70  0439		       86 3e		      stx	SET_BANK_RAM
     71  043b		       20 a3 f8 	      jsr	DrawRow	; draw the ENTIRE visible screen!
     72  043e
      0  043e					      CALL	tidySc
      1  043e				  -	      IF	SLOT_tidySc == _BANK_SLOT
      2  043e				  -FNAME      SETSTR	tidySc
      3  043e				  -	      ECHO	""
      4  043e				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  043e				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  043e				  -	      ERR
      7  043e					      ENDIF
      8  043e		       a9 89		      lda	#BANK_tidySc
      9  0440		       85 3f		      sta	SET_BANK
     10  0442		       20 04 f8 	      jsr	tidySc
     74  0445
     75  0445		       20 92 f1 	      jsr	AiStateMachine
     76  0448
     77  0448		       ad 84 02 	      lda	INTIM
     78  044b		       c9 14		      cmp	#20
     79  044d		       90 20		      bcc	.notnow
     80  044f
     81  044f							;CALL GameSpeak
      0  044f					      CALL	PositionSprites
      1  044f				  -	      IF	SLOT_PositionSprites == _BANK_SLOT
      2  044f				  -FNAME      SETSTR	PositionSprites
      3  044f				  -	      ECHO	""
      4  044f				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  044f				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  044f				  -	      ERR
      7  044f					      ENDIF
      8  044f		       a9 45		      lda	#BANK_PositionSprites
      9  0451		       85 3f		      sta	SET_BANK
     10  0453		       20 00 f5 	      jsr	PositionSprites
     83  0456
     84  0456
     85  0456					      IF	1
     86  0456							; "draw" sprite shapes into row banks
     87  0456
     88  0456		       a2 07		      ldx	#7
     89  0458		       8a	   zapem      txa
     90  0459		       18		      clc
     91  045a		       69 80		      adc	#SLOT_DrawRow
     92  045c		       85 3e		      sta	SET_BANK_RAM
      0  045e					      CALL	WriteBlank	;@3
      1  045e				  -	      IF	SLOT_WriteBlank == _BANK_SLOT
      2  045e				  -FNAME      SETSTR	WriteBlank
      3  045e				  -	      ECHO	""
      4  045e				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  045e				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  045e				  -	      ERR
      7  045e					      ENDIF
      8  045e		       a9 d9		      lda	#BANK_WriteBlank
      9  0460		       85 3f		      sta	SET_BANK
     10  0462		       20 0c fc 	      jsr	WriteBlank
     94  0465		       ca		      dex
     95  0466		       10 f0		      bpl	zapem
     96  0468
      0  0468					      CALL	WriteCursor	;@3
      1  0468				  -	      IF	SLOT_WriteCursor == _BANK_SLOT
      2  0468				  -FNAME      SETSTR	WriteCursor
      3  0468				  -	      ECHO	""
      4  0468				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0468				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0468				  -	      ERR
      7  0468					      ENDIF
      8  0468		       a9 d9		      lda	#BANK_WriteCursor
      9  046a		       85 3f		      sta	SET_BANK
     10  046c		       20 35 fc 	      jsr	WriteCursor
     98  046f					      ENDIF
     99  046f
    100  046f				   .notnow
    101  046f
    102  046f		       2c 85 02    .waitTime  bit	TIMINT
    103  0472		       10 fb		      bpl	.waitTime
    104  0474
    105  0474		       4c 18 f0 	      jmp	.StartFrame
    106  0477
    107  0477
    108  0477							;---------------------------------------------------------------------------------------------------
    109  0477
      0  0477					      DEF	COMMON_VARS
      1  0477				   SLOT_COMMON_VARS SET	_BANK_SLOT
      2  0477				   BANK_COMMON_VARS SET	SLOT_COMMON_VARS + _CURRENT_BANK
      3  0477				   COMMON_VARS
      4  0477				   TEMPORARY_VAR SET	Overlay
      5  0477				   TEMPORARY_OFFSET SET	0
      6  0477				   VAR_BOUNDARY_COMMON_VARS SET	TEMPORARY_OFFSET
      7  0477				   FUNCTION_NAME SET	COMMON_VARS
    111  0477
      0  0477					      VAR	__thinkbar, 1
      1  0477
      2  0477		       00 a7	   __thinkbar =	TEMPORARY_VAR
      3  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  0477
      5  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  0477				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  0477				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  0477					      ENDIF
      9  0477				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  0477				  -	      LIST	ON
     11  0477				  -VNAME      SETSTR	__thinkbar
     12  0477				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  0477				  -	      ERR
     14  0477				  -	      ECHO	"Temporary Variable overlow!"
     15  0477					      ENDIF
     16  0477					      LIST	ON
      0  0477					      VAR	__toggle, 1
      1  0477
      2  0477		       00 a8	   __toggle   =	TEMPORARY_VAR
      3  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  0477
      5  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  0477				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  0477				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  0477					      ENDIF
      9  0477				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  0477				  -	      LIST	ON
     11  0477				  -VNAME      SETSTR	__toggle
     12  0477				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  0477				  -	      ERR
     14  0477				  -	      ECHO	"Temporary Variable overlow!"
     15  0477					      ENDIF
     16  0477					      LIST	ON
    114  0477
      0  0477					      VAR	__bestMove, 1
      1  0477
      2  0477		       00 a9	   __bestMove =	TEMPORARY_VAR
      3  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  0477
      5  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  0477				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  0477				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  0477					      ENDIF
      9  0477				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  0477				  -	      LIST	ON
     11  0477				  -VNAME      SETSTR	__bestMove
     12  0477				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  0477				  -	      ERR
     14  0477				  -	      ECHO	"Temporary Variable overlow!"
     15  0477					      ENDIF
     16  0477					      LIST	ON
      0  0477					      VAR	__alpha, 2
      1  0477
      2  0477		       00 aa	   __alpha    =	TEMPORARY_VAR
      3  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      4  0477
      5  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  0477				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  0477				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  0477					      ENDIF
      9  0477				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  0477				  -	      LIST	ON
     11  0477				  -VNAME      SETSTR	__alpha
     12  0477				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  0477				  -	      ERR
     14  0477				  -	      ECHO	"Temporary Variable overlow!"
     15  0477					      ENDIF
     16  0477					      LIST	ON
      0  0477					      VAR	__beta, 2
      1  0477
      2  0477		       00 ac	   __beta     =	TEMPORARY_VAR
      3  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      4  0477
      5  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  0477				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  0477				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  0477					      ENDIF
      9  0477				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  0477				  -	      LIST	ON
     11  0477				  -VNAME      SETSTR	__beta
     12  0477				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  0477				  -	      ERR
     14  0477				  -	      ECHO	"Temporary Variable overlow!"
     15  0477					      ENDIF
     16  0477					      LIST	ON
      0  0477					      VAR	__negaMax, 2
      1  0477
      2  0477		       00 ae	   __negaMax  =	TEMPORARY_VAR
      3  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      4  0477
      5  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  0477				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  0477				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  0477					      ENDIF
      9  0477				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  0477				  -	      LIST	ON
     11  0477				  -VNAME      SETSTR	__negaMax
     12  0477				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  0477				  -	      ERR
     14  0477				  -	      ECHO	"Temporary Variable overlow!"
     15  0477					      ENDIF
     16  0477					      LIST	ON
      0  0477					      VAR	__value, 2
      1  0477
      2  0477		       00 b0	   __value    =	TEMPORARY_VAR
      3  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      4  0477
      5  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  0477				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  0477				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  0477					      ENDIF
      9  0477				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  0477				  -	      LIST	ON
     11  0477				  -VNAME      SETSTR	__value
     12  0477				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  0477				  -	      ERR
     14  0477				  -	      ECHO	"Temporary Variable overlow!"
     15  0477					      ENDIF
     16  0477					      LIST	ON
    120  0477
      0  0477					      VAR	__quiesceCapOnly, 1
      1  0477
      2  0477		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      3  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  0477
      5  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  0477				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  0477				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  0477					      ENDIF
      9  0477				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  0477				  -	      LIST	ON
     11  0477				  -VNAME      SETSTR	__quiesceCapOnly
     12  0477				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  0477				  -	      ERR
     14  0477				  -	      ECHO	"Temporary Variable overlow!"
     15  0477					      ENDIF
     16  0477					      LIST	ON
    122  0477
      0  0477					      VAR	__originalPiece, 1
      1  0477
      2  0477		       00 b3	   __originalPiece =	TEMPORARY_VAR
      3  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  0477
      5  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  0477				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  0477				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  0477					      ENDIF
      9  0477				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  0477				  -	      LIST	ON
     11  0477				  -VNAME      SETSTR	__originalPiece
     12  0477				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  0477				  -	      ERR
     14  0477				  -	      ECHO	"Temporary Variable overlow!"
     15  0477					      ENDIF
     16  0477					      LIST	ON
      0  0477					      VAR	__capturedPiece, 1
      1  0477
      2  0477		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      3  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  0477
      5  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  0477				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  0477				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  0477					      ENDIF
      9  0477				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  0477				  -	      LIST	ON
     11  0477				  -VNAME      SETSTR	__capturedPiece
     12  0477				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  0477				  -	      ERR
     14  0477				  -	      ECHO	"Temporary Variable overlow!"
     15  0477					      ENDIF
     16  0477					      LIST	ON
    125  0477
      0  0477					      VEND	COMMON_VARS
      1  0477
      2  0477
      3  0477		       00 b5	   VAREND_COMMON_VARS =	TEMPORARY_VAR
      4  0477
    127  0477
    128  0477
    129  0477							;---------------------------------------------------------------------------------------------------
    130  0477
      0  0477					      DEF	ThinkBar
      1  0477				   SLOT_ThinkBar SET	_BANK_SLOT
      2  0477				   BANK_ThinkBar SET	SLOT_ThinkBar + _CURRENT_BANK
      3  0477				   ThinkBar
      4  0477				   TEMPORARY_VAR SET	Overlay
      5  0477				   TEMPORARY_OFFSET SET	0
      6  0477				   VAR_BOUNDARY_ThinkBar SET	TEMPORARY_OFFSET
      7  0477				   FUNCTION_NAME SET	ThinkBar
    132  0477					      SUBROUTINE
    133  0477
      0  0477					      REF	COMMON_VARS
      1  0477					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0477				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0477					      ENDIF
      0  0477					      REF	negaMax	;✅
      1  0477				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0477				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  0477					      ENDIF
      0  0477					      REF	quiesce	;✅
      1  0477				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  0477				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  0477					      ENDIF
      0  0477					      VEND	ThinkBar
      1  0477
      2  0477
      3  0477		       00 b5	   VAREND_ThinkBar =	TEMPORARY_VAR
      4  0477
    138  0477
    139  0477					      IF	DIAGNOSTICS
    140  0477
    141  0477		       e6 9c		      inc	positionCount
    142  0479		       d0 06		      bne	.p1
    143  047b		       e6 9d		      inc	positionCount+1
    144  047d		       d0 02		      bne	.p1
    145  047f		       e6 9e		      inc	positionCount+2
    146  0481				   .p1
    147  0481					      ENDIF
    148  0481
    149  0481							; The 'thinkbar' pattern...
    150  0481
    151  0481		       a9 00		      lda	#0
    152  0483		       a4 4c		      ldy	INPT4
    153  0485		       30 13		      bmi	.doThink
    154  0487
    155  0487		       e6 a7		      inc	__thinkbar
    156  0489		       a5 a7		      lda	__thinkbar
    157  048b		       29 0f		      and	#15
    158  048d		       a8		      tay
    159  048e		       a5 81		      lda	rnd
    160  0490		       29 06		      and	#6
    161  0492		       19 a1 f0 	      ora	TBcol,y
    162  0495		       85 48		      sta	COLUPF
    163  0497
    164  0497		       b9 b1 f0 	      lda	SynapsePattern,y
    165  049a		       85 4f	   .doThink   sta	PF2
    166  049c		       85 4e		      sta	PF1
    167  049e		       85 4d		      sta	PF0
    168  04a0		       60		      rts
    169  04a1
    170  04a1
    171  04a1				   TBcol
    172  04a1				   .TBC       SET	2
    173  04a1					      REPEAT	16
    174  04a1		       02		      .byte.b	.TBC
    175  04a1				   .TBC       SET	.TBC + 16
    173  04a1					      REPEND
    174  04a2		       12		      .byte.b	.TBC
    175  04a2				   .TBC       SET	.TBC + 16
    173  04a2					      REPEND
    174  04a3		       22		      .byte.b	.TBC
    175  04a3				   .TBC       SET	.TBC + 16
    173  04a3					      REPEND
    174  04a4		       32		      .byte.b	.TBC
    175  04a4				   .TBC       SET	.TBC + 16
    173  04a4					      REPEND
    174  04a5		       42		      .byte.b	.TBC
    175  04a5				   .TBC       SET	.TBC + 16
    173  04a5					      REPEND
    174  04a6		       52		      .byte.b	.TBC
    175  04a6				   .TBC       SET	.TBC + 16
    173  04a6					      REPEND
    174  04a7		       62		      .byte.b	.TBC
    175  04a7				   .TBC       SET	.TBC + 16
    173  04a7					      REPEND
    174  04a8		       72		      .byte.b	.TBC
    175  04a8				   .TBC       SET	.TBC + 16
    173  04a8					      REPEND
    174  04a9		       82		      .byte.b	.TBC
    175  04a9				   .TBC       SET	.TBC + 16
    173  04a9					      REPEND
    174  04aa		       92		      .byte.b	.TBC
    175  04aa				   .TBC       SET	.TBC + 16
    173  04aa					      REPEND
    174  04ab		       a2		      .byte.b	.TBC
    175  04ab				   .TBC       SET	.TBC + 16
    173  04ab					      REPEND
    174  04ac		       b2		      .byte.b	.TBC
    175  04ac				   .TBC       SET	.TBC + 16
    173  04ac					      REPEND
    174  04ad		       c2		      .byte.b	.TBC
    175  04ad				   .TBC       SET	.TBC + 16
    173  04ad					      REPEND
    174  04ae		       d2		      .byte.b	.TBC
    175  04ae				   .TBC       SET	.TBC + 16
    173  04ae					      REPEND
    174  04af		       e2		      .byte.b	.TBC
    175  04af				   .TBC       SET	.TBC + 16
    173  04af					      REPEND
    174  04b0		       f2		      .byte.b	.TBC
    175  04b0				   .TBC       SET	.TBC + 16
    176  04b1					      REPEND
    177  04b1
    178  04b1				   SynapsePattern
    179  04b1
    180  04b1		       c1		      .byte.b	%11000001
    181  04b2		       60		      .byte.b	%01100000
    182  04b3		       30		      .byte.b	%00110000
    183  04b4		       18		      .byte.b	%00011000
    184  04b5		       0c		      .byte.b	%00001100
    185  04b6		       06		      .byte.b	%00000110
    186  04b7		       83		      .byte.b	%10000011
    187  04b8		       c1		      .byte.b	%11000001
    188  04b9
    189  04b9		       83		      .byte.b	%10000011
    190  04ba		       06		      .byte.b	%00000110
    191  04bb		       0c		      .byte.b	%00001100
    192  04bc		       18		      .byte.b	%00011000
    193  04bd		       30		      .byte.b	%00110000
    194  04be		       60		      .byte.b	%01100000
    195  04bf		       c1		      .byte.b	%11000001
    196  04c0		       83		      .byte.b	%10000011
    197  04c1
    198  04c1
    199  04c1							;---------------------------------------------------------------------------------------------------
    200  04c1
      0  04c1					      DEF	CopySinglePiece
      1  04c1				   SLOT_CopySinglePiece SET	_BANK_SLOT
      2  04c1				   BANK_CopySinglePiece SET	SLOT_CopySinglePiece + _CURRENT_BANK
      3  04c1				   CopySinglePiece
      4  04c1				   TEMPORARY_VAR SET	Overlay
      5  04c1				   TEMPORARY_OFFSET SET	0
      6  04c1				   VAR_BOUNDARY_CopySinglePiece SET	TEMPORARY_OFFSET
      7  04c1				   FUNCTION_NAME SET	CopySinglePiece
    202  04c1					      SUBROUTINE
    203  04c1
    204  04c1							; Common vairables...
    205  04c1							; REQUIRES calling routines to "REF Variable_PieceShapeBuffer"
    206  04c1
      0  04c1					      TIMING	CopySinglePiece, (2600)
      1  04c1
      2  04c1		       00 29	   SPEEDOF_CopySinglePiece =	((2600)/64) + 1
      3  04c1
    208  04c1
      0  04c1					      REF	Variable_PieceShapeBuffer
      1  04c1					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  04c1				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  04c1					      ENDIF
      0  04c1					      REF	showMoveCaptures	;✅
      1  04c1				  -	      IF	VAREND_showMoveCaptures > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_showMoveCaptures
      3  04c1					      ENDIF
      0  04c1					      REF	aiDrawEntireBoard	;✅
      1  04c1				  -	      IF	VAREND_aiDrawEntireBoard > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiDrawEntireBoard
      3  04c1					      ENDIF
      0  04c1					      REF	aiDrawPart2	;✅
      1  04c1				  -	      IF	VAREND_aiDrawPart2 > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiDrawPart2
      3  04c1					      ENDIF
      0  04c1					      REF	aiMarchB	;✅
      1  04c1				  -	      IF	VAREND_aiMarchB > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiMarchB
      3  04c1					      ENDIF
      0  04c1					      REF	aiFlashComputerMove	;✅
      1  04c1				  -	      IF	VAREND_aiFlashComputerMove > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiFlashComputerMove
      3  04c1					      ENDIF
      0  04c1					      REF	aiSelectDestinationSquare	;✅
      1  04c1				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  04c1					      ENDIF
      0  04c1					      REF	aiMarchA2	;✅
      1  04c1				  -	      IF	VAREND_aiMarchA2 > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiMarchA2
      3  04c1					      ENDIF
      0  04c1					      REF	aiMarchB2	;✅
      1  04c1				  -	      IF	VAREND_aiMarchB2 > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiMarchB2
      3  04c1					      ENDIF
      0  04c1					      REF	aiWriteStartPieceBlank	;✅
      1  04c1				  -	      IF	VAREND_aiWriteStartPieceBlank > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiWriteStartPieceBlank
      3  04c1					      ENDIF
      0  04c1					      REF	aiChoosePromotePiece	;✅
      1  04c1				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  04c1					      ENDIF
      0  04c1					      REF	aiMarchToTargetB	;✅
      1  04c1				  -	      IF	VAREND_aiMarchToTargetB > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetB
      3  04c1					      ENDIF
      0  04c1					      REF	aiPromotePawnStart	;✅
      1  04c1				  -	      IF	VAREND_aiPromotePawnStart > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiPromotePawnStart
      3  04c1					      ENDIF
      0  04c1					      REF	aiFinalFlash	;✅
      1  04c1				  -	      IF	VAREND_aiFinalFlash > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiFinalFlash
      3  04c1					      ENDIF
    223  04c1
    224  04c1
      0  04c1					      VEND	CopySinglePiece
      1  04c1
      2  04c1
      3  04c1		       00 ef	   VAREND_CopySinglePiece =	TEMPORARY_VAR
      4  04c1
    226  04c1
    227  04c1							; WARNING: CANNOT USE VAR/OVERLAY IN ANY ROUTINE CALLING THIS!!
    228  04c1							; ALSO CAN'T USE IN THIS ROUTINE
    229  04c1							; This routine will STOMP on those vars due to __pieceShapeBuffer occupying whole overlay
    230  04c1							; @2150 max
    231  04c1							; = 33 TIM64T
    232  04c1
      0  04c1					      CALL	CopySetup	;@2
      1  04c1				  -	      IF	SLOT_CopySetup == _BANK_SLOT
      2  04c1				  -FNAME      SETSTR	CopySetup
      3  04c1				  -	      ECHO	""
      4  04c1				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  04c1				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  04c1				  -	      ERR
      7  04c1					      ENDIF
      8  04c1		       a9 89		      lda	#BANK_CopySetup
      9  04c3		       85 3f		      sta	SET_BANK
     10  04c5		       20 98 f8 	      jsr	CopySetup
    234  04c8
    235  04c8
      0  04c8					      DEF	InterceptMarkerCopy
      1  04c8				   SLOT_InterceptMarkerCopy SET	_BANK_SLOT
      2  04c8				   BANK_InterceptMarkerCopy SET	SLOT_InterceptMarkerCopy + _CURRENT_BANK
      3  04c8				   InterceptMarkerCopy
      4  04c8				   TEMPORARY_VAR SET	Overlay
      5  04c8				   TEMPORARY_OFFSET SET	0
      6  04c8				   VAR_BOUNDARY_InterceptMarkerCopy SET	TEMPORARY_OFFSET
      7  04c8				   FUNCTION_NAME SET	InterceptMarkerCopy
    237  04c8					      SUBROUTINE
    238  04c8
      0  04c8					      REF	CopySinglePiece	;✅
      1  04c8					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  04c8				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  04c8					      ENDIF
      0  04c8					      REF	showPromoteOptions	;✅
      1  04c8				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  04c8					      ENDIF
      0  04c8					      REF	showMoveOptions	;✅
      1  04c8				  -	      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  04c8					      ENDIF
      0  04c8					      VEND	InterceptMarkerCopy
      1  04c8
      2  04c8
      3  04c8		       00 ef	   VAREND_InterceptMarkerCopy =	TEMPORARY_VAR
      4  04c8
    243  04c8
    244  04c8							; Copy a piece shape (3 PF bytes wide x 24 lines) to the RAM buffer
    245  04c8							; y = piece index
    246  04c8
    247  04c8		       a9 89		      lda	#BANK_PIECE_VECTOR_BANK
    248  04ca		       85 3f		      sta	SET_BANK	;@2
    249  04cc
    250  04cc		       b9 f1 f9 	      lda	PIECE_VECTOR_LO,y
    251  04cf		       85 a2		      sta	__psb
    252  04d1		       b9 81 fa 	      lda	PIECE_VECTOR_HI,y
    253  04d4		       85 a3		      sta	__psb+1
    254  04d6		       b9 11 fb 	      lda	PIECE_VECTOR_BANK,y
    255  04d9		       85 3f		      sta	SET_BANK	;@2
    256  04db
    257  04db		       a0 47		      ldy	#PIECE_SHAPE_SIZE-1
    258  04dd		       b1 a2	   .copy      lda	(__psb),y
    259  04df		       99 a7 00 	      sta	__pieceShapeBuffer,y
    260  04e2		       88		      dey
    261  04e3		       10 f8		      bpl	.copy
    262  04e5
    263  04e5		       a5 80		      lda	squareToDraw
    264  04e7		       38		      sec
    265  04e8		       a2 0a		      ldx	#10
    266  04ea		       e9 0a	   .sub10     sbc	#10
    267  04ec		       ca		      dex
    268  04ed		       b0 fb		      bcs	.sub10
    269  04ef
    270  04ef		       69 08		      adc	#8
    271  04f1		       c9 04		      cmp	#4	; CS = right side of screen
    272  04f3
    273  04f3		       8a		      txa
    274  04f4		       09 80		      ora	#[SLOT2]
    275  04f6		       85 3e		      sta	SET_BANK_RAM	;@2		 ; bank row
    276  04f8
    277  04f8		       20 50 f3 	      jsr	CopyPieceToRowBitmap	;@3
    278  04fb		       60		      rts
    279  04fc
    280  04fc
    281  04fc							;---------------------------------------------------------------------------------------------------
    282  04fc
    283  04fc				   P	      SET	0
    284  04fc					      MAC	ain
    285  04fc				   AI_{1}     SET	P
    286  04fc				   P	      SET	P+1
    287  04fc					      ENDM
    288  04fc
    289  04fc					      MAC	lo
    290  04fc					      .byte	<ai{1}
    291  04fc					      ENDM
    292  04fc
    293  04fc					      MAC	hi
    294  04fc					      .byte	>ai{1}
    295  04fc					      ENDM
    296  04fc
    297  04fc					      MAC	bk
    298  04fc					      .byte	BANK_ai{1}
    299  04fc					      ENDM
    300  04fc
    301  04fc
    302  04fc		       00 28	   ONCEPERFRAME =	40
    303  04fc
    304  04fc					      MAC	tabdef
    305  04fc
    306  04fc					      {1}	FlashComputerMove	; 0
    307  04fc					      {1}	BeginSelectMovePhase	; 1
    308  04fc					      {1}	SelectStartSquare	; 2
    309  04fc					      {1}	StartSquareSelected	; 3
    310  04fc					      {1}	DrawMoves	; 4
    311  04fc					      {1}	ShowMoveCaptures	; 5
    312  04fc					      {1}	SlowFlash	; 6
    313  04fc					      {1}	UnDrawTargetSquares	; 7
    314  04fc					      {1}	SelectDestinationSquare	; 8
    315  04fc					      {1}	Quiescent	; 9
    316  04fc					      {1}	ReselectDebounce	; 10
    317  04fc					      {1}	StartMoveGen	; 11
    318  04fc					      {1}	StepMoveGen	; 12
    319  04fc					      {1}	StartClearBoard	; 13
    320  04fc					      {1}	ClearEachRow	; 14
    321  04fc					      {1}	DrawEntireBoard	; 15
    322  04fc					      {1}	DrawPart2	; 16
    323  04fc					      {1}	DrawPart3	; 17
    324  04fc					      {1}	GenerateMoves	; 18
    325  04fc					      {1}	ComputerMove	; 19
    326  04fc					      {1}	MoveIsSelected	; 20
    327  04fc					      {1}	WriteStartPieceBlank	; 21
    328  04fc					      {1}	MarchToTargetA	; 22
    329  04fc					      {1}	MarchA2	; 23
    330  04fc					      {1}	MarchB	; 24
    331  04fc					      {1}	MarchToTargetB	; 25
    332  04fc					      {1}	MarchB2	; 26
    333  04fc					      {1}	FinalFlash	; 27
    334  04fc					      {1}	SpecialMoveFixup	; 28
    335  04fc					      {1}	InCheckBackup	; 29
    336  04fc					      {1}	InCheckDelay	; 30
    337  04fc					      {1}	PromotePawnStart	; 31
    338  04fc					      {1}	RollPromotionPiece	; 32
    339  04fc					      {1}	ChoosePromotePiece	; 33
    340  04fc					      {1}	ChooseDebounce	; 34
    341  04fc					      {1}	CheckMate	; 35
    342  04fc					      {1}	Draw	; 36
    343  04fc					      {1}	DelayAfterMove	; 37
    344  04fc					      {1}	DelayAfterMove2	; 38
    345  04fc					      {1}	DelayAfterPlaced	; 39
    346  04fc					      {1}	DelayAfterPlaced2	; 40
    347  04fc					      {1}	EPHandler	; 41
    348  04fc					      {1}	EPFlash	; 42
    349  04fc					      {1}	DebounceSelect	; 43
    350  04fc					      {1}	InCheckBackupStart	; 44
    351  04fc					      {1}	RestoreBitmaps	; 45
    352  04fc					      {1}	WaitBitmap	; 46
    353  04fc					      {1}	DrawBitmapBackground	; 47
    354  04fc					      {1}	DrawBitmap2	; 48
    355  04fc					      {1}	DrawBitmap3	; 49
    356  04fc
    357  04fc					      ENDM		; {1} = macro to use
    358  04fc
      0  04fc					      TABDEF	AIN
      1  04fc
      0  04fc					      AIN	FlashComputerMove
      1  04fc				   AI_FlashComputerMove SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	BeginSelectMovePhase
      1  04fc				   AI_BeginSelectMovePhase SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	SelectStartSquare
      1  04fc				   AI_SelectStartSquare SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	StartSquareSelected
      1  04fc				   AI_StartSquareSelected SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DrawMoves
      1  04fc				   AI_DrawMoves SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	ShowMoveCaptures
      1  04fc				   AI_ShowMoveCaptures SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	SlowFlash
      1  04fc				   AI_SlowFlash SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	UnDrawTargetSquares
      1  04fc				   AI_UnDrawTargetSquares SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	SelectDestinationSquare
      1  04fc				   AI_SelectDestinationSquare SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	Quiescent
      1  04fc				   AI_Quiescent SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	ReselectDebounce
      1  04fc				   AI_ReselectDebounce SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	StartMoveGen
      1  04fc				   AI_StartMoveGen SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	StepMoveGen
      1  04fc				   AI_StepMoveGen SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	StartClearBoard
      1  04fc				   AI_StartClearBoard SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	ClearEachRow
      1  04fc				   AI_ClearEachRow SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DrawEntireBoard
      1  04fc				   AI_DrawEntireBoard SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DrawPart2
      1  04fc				   AI_DrawPart2 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DrawPart3
      1  04fc				   AI_DrawPart3 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	GenerateMoves
      1  04fc				   AI_GenerateMoves SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	ComputerMove
      1  04fc				   AI_ComputerMove SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MoveIsSelected
      1  04fc				   AI_MoveIsSelected SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	WriteStartPieceBlank
      1  04fc				   AI_WriteStartPieceBlank SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MarchToTargetA
      1  04fc				   AI_MarchToTargetA SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MarchA2
      1  04fc				   AI_MarchA2 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MarchB
      1  04fc				   AI_MarchB  SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MarchToTargetB
      1  04fc				   AI_MarchToTargetB SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MarchB2
      1  04fc				   AI_MarchB2 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	FinalFlash
      1  04fc				   AI_FinalFlash SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	SpecialMoveFixup
      1  04fc				   AI_SpecialMoveFixup SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	InCheckBackup
      1  04fc				   AI_InCheckBackup SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	InCheckDelay
      1  04fc				   AI_InCheckDelay SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	PromotePawnStart
      1  04fc				   AI_PromotePawnStart SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	RollPromotionPiece
      1  04fc				   AI_RollPromotionPiece SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	ChoosePromotePiece
      1  04fc				   AI_ChoosePromotePiece SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	ChooseDebounce
      1  04fc				   AI_ChooseDebounce SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	CheckMate
      1  04fc				   AI_CheckMate SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	Draw
      1  04fc				   AI_Draw    SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DelayAfterMove
      1  04fc				   AI_DelayAfterMove SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DelayAfterMove2
      1  04fc				   AI_DelayAfterMove2 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DelayAfterPlaced
      1  04fc				   AI_DelayAfterPlaced SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DelayAfterPlaced2
      1  04fc				   AI_DelayAfterPlaced2 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	EPHandler
      1  04fc				   AI_EPHandler SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	EPFlash
      1  04fc				   AI_EPFlash SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DebounceSelect
      1  04fc				   AI_DebounceSelect SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	InCheckBackupStart
      1  04fc				   AI_InCheckBackupStart SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	RestoreBitmaps
      1  04fc				   AI_RestoreBitmaps SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	WaitBitmap
      1  04fc				   AI_WaitBitmap SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DrawBitmapBackground
      1  04fc				   AI_DrawBitmapBackground SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DrawBitmap2
      1  04fc				   AI_DrawBitmap2 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DrawBitmap3
      1  04fc				   AI_DrawBitmap3 SET	P
      2  04fc				   P	      SET	P+1
     52  04fc
    360  04fc
      0  04fc					      DEF	AiVectorLO
      1  04fc				   SLOT_AiVectorLO SET	_BANK_SLOT
      2  04fc				   BANK_AiVectorLO SET	SLOT_AiVectorLO + _CURRENT_BANK
      3  04fc				   AiVectorLO
      4  04fc				   TEMPORARY_VAR SET	Overlay
      5  04fc				   TEMPORARY_OFFSET SET	0
      6  04fc				   VAR_BOUNDARY_AiVectorLO SET	TEMPORARY_OFFSET
      7  04fc				   FUNCTION_NAME SET	AiVectorLO
      0  04fc					      TABDEF	LO
      1  04fc
      0  04fc					      LO	FlashComputerMove
      1  04fc		       7b		      .byte.b	<aiFlashComputerMove
      0  04fd					      LO	BeginSelectMovePhase
      1  04fd		       5c		      .byte.b	<aiBeginSelectMovePhase
      0  04fe					      LO	SelectStartSquare
      1  04fe		       b9		      .byte.b	<aiSelectStartSquare
      0  04ff					      LO	StartSquareSelected
      1  04ff		       b4		      .byte.b	<aiStartSquareSelected
      0  0500					      LO	DrawMoves
      1  0500		       21		      .byte.b	<aiDrawMoves
      0  0501					      LO	ShowMoveCaptures
      1  0501		       15		      .byte.b	<aiShowMoveCaptures
      0  0502					      LO	SlowFlash
      1  0502		       3b		      .byte.b	<aiSlowFlash
      0  0503					      LO	UnDrawTargetSquares
      1  0503		       eb		      .byte.b	<aiUnDrawTargetSquares
      0  0504					      LO	SelectDestinationSquare
      1  0504		       64		      .byte.b	<aiSelectDestinationSquare
      0  0505					      LO	Quiescent
      1  0505		       23		      .byte.b	<aiQuiescent
      0  0506					      LO	ReselectDebounce
      1  0506		       14		      .byte.b	<aiReselectDebounce
      0  0507					      LO	StartMoveGen
      1  0507		       00		      .byte.b	<aiStartMoveGen
      0  0508					      LO	StepMoveGen
      1  0508		       ad		      .byte.b	<aiStepMoveGen
      0  0509					      LO	StartClearBoard
      1  0509		       2a		      .byte.b	<aiStartClearBoard
      0  050a					      LO	ClearEachRow
      1  050a		       37		      .byte.b	<aiClearEachRow
      0  050b					      LO	DrawEntireBoard
      1  050b		       b8		      .byte.b	<aiDrawEntireBoard
      0  050c					      LO	DrawPart2
      1  050c		       ec		      .byte.b	<aiDrawPart2
      0  050d					      LO	DrawPart3
      1  050d		       ef		      .byte.b	<aiDrawPart3
      0  050e					      LO	GenerateMoves
      1  050e		       9a		      .byte.b	<aiGenerateMoves
      0  050f					      LO	ComputerMove
      1  050f		       00		      .byte.b	<aiComputerMove
      0  0510					      LO	MoveIsSelected
      1  0510		       52		      .byte.b	<aiMoveIsSelected
      0  0511					      LO	WriteStartPieceBlank
      1  0511		       cf		      .byte.b	<aiWriteStartPieceBlank
      0  0512					      LO	MarchToTargetA
      1  0512		       38		      .byte.b	<aiMarchToTargetA
      0  0513					      LO	MarchA2
      1  0513		       95		      .byte.b	<aiMarchA2
      0  0514					      LO	MarchB
      1  0514		       09		      .byte.b	<aiMarchB
      0  0515					      LO	MarchToTargetB
      1  0515		       54		      .byte.b	<aiMarchToTargetB
      0  0516					      LO	MarchB2
      1  0516		       c2		      .byte.b	<aiMarchB2
      0  0517					      LO	FinalFlash
      1  0517		       92		      .byte.b	<aiFinalFlash
      0  0518					      LO	SpecialMoveFixup
      1  0518		       53		      .byte.b	<aiSpecialMoveFixup
      0  0519					      LO	InCheckBackup
      1  0519		       0e		      .byte.b	<aiInCheckBackup
      0  051a					      LO	InCheckDelay
      1  051a		       4f		      .byte.b	<aiInCheckDelay
      0  051b					      LO	PromotePawnStart
      1  051b		       76		      .byte.b	<aiPromotePawnStart
      0  051c					      LO	RollPromotionPiece
      1  051c		       c5		      .byte.b	<aiRollPromotionPiece
      0  051d					      LO	ChoosePromotePiece
      1  051d		       18		      .byte.b	<aiChoosePromotePiece
      0  051e					      LO	ChooseDebounce
      1  051e		       00		      .byte.b	<aiChooseDebounce
      0  051f					      LO	CheckMate
      1  051f		       1e		      .byte.b	<aiCheckMate
      0  0520					      LO	Draw
      1  0520		       19		      .byte.b	<aiDraw
      0  0521					      LO	DelayAfterMove
      1  0521		       1d		      .byte.b	<aiDelayAfterMove
      0  0522					      LO	DelayAfterMove2
      1  0522		       26		      .byte.b	<aiDelayAfterMove2
      0  0523					      LO	DelayAfterPlaced
      1  0523		       2f		      .byte.b	<aiDelayAfterPlaced
      0  0524					      LO	DelayAfterPlaced2
      1  0524		       3f		      .byte.b	<aiDelayAfterPlaced2
      0  0525					      LO	EPHandler
      1  0525		       f4		      .byte.b	<aiEPHandler
      0  0526					      LO	EPFlash
      1  0526		       6b		      .byte.b	<aiEPFlash
      0  0527					      LO	DebounceSelect
      1  0527		       02		      .byte.b	<aiDebounceSelect
      0  0528					      LO	InCheckBackupStart
      1  0528		       05		      .byte.b	<aiInCheckBackupStart
      0  0529					      LO	RestoreBitmaps
      1  0529		       36		      .byte.b	<aiRestoreBitmaps
      0  052a					      LO	WaitBitmap
      1  052a		       25		      .byte.b	<aiWaitBitmap
      0  052b					      LO	DrawBitmapBackground
      1  052b		       85		      .byte.b	<aiDrawBitmapBackground
      0  052c					      LO	DrawBitmap2
      1  052c		       b5		      .byte.b	<aiDrawBitmap2
      0  052d					      LO	DrawBitmap3
      1  052d		       dc		      .byte.b	<aiDrawBitmap3
     52  052e
    363  052e
      0  052e					      DEF	AiVectorHI
      1  052e				   SLOT_AiVectorHI SET	_BANK_SLOT
      2  052e				   BANK_AiVectorHI SET	SLOT_AiVectorHI + _CURRENT_BANK
      3  052e				   AiVectorHI
      4  052e				   TEMPORARY_VAR SET	Overlay
      5  052e				   TEMPORARY_OFFSET SET	0
      6  052e				   VAR_BOUNDARY_AiVectorHI SET	TEMPORARY_OFFSET
      7  052e				   FUNCTION_NAME SET	AiVectorHI
      0  052e					      TABDEF	HI
      1  052e
      0  052e					      HI	FlashComputerMove
      1  052e		       f4		      .byte.b	>aiFlashComputerMove
      0  052f					      HI	BeginSelectMovePhase
      1  052f		       f4		      .byte.b	>aiBeginSelectMovePhase
      0  0530					      HI	SelectStartSquare
      1  0530		       f4		      .byte.b	>aiSelectStartSquare
      0  0531					      HI	StartSquareSelected
      1  0531		       f5		      .byte.b	>aiStartSquareSelected
      0  0532					      HI	DrawMoves
      1  0532		       f5		      .byte.b	>aiDrawMoves
      0  0533					      HI	ShowMoveCaptures
      1  0533		       f6		      .byte.b	>aiShowMoveCaptures
      0  0534					      HI	SlowFlash
      1  0534		       f6		      .byte.b	>aiSlowFlash
      0  0535					      HI	UnDrawTargetSquares
      1  0535		       f5		      .byte.b	>aiUnDrawTargetSquares
      0  0536					      HI	SelectDestinationSquare
      1  0536		       f6		      .byte.b	>aiSelectDestinationSquare
      0  0537					      HI	Quiescent
      1  0537		       f6		      .byte.b	>aiQuiescent
      0  0538					      HI	ReselectDebounce
      1  0538		       f4		      .byte.b	>aiReselectDebounce
      0  0539					      HI	StartMoveGen
      1  0539		       f4		      .byte.b	>aiStartMoveGen
      0  053a					      HI	StepMoveGen
      1  053a		       f4		      .byte.b	>aiStepMoveGen
      0  053b					      HI	StartClearBoard
      1  053b		       f8		      .byte.b	>aiStartClearBoard
      0  053c					      HI	ClearEachRow
      1  053c		       f8		      .byte.b	>aiClearEachRow
      0  053d					      HI	DrawEntireBoard
      1  053d		       f5		      .byte.b	>aiDrawEntireBoard
      0  053e					      HI	DrawPart2
      1  053e		       f5		      .byte.b	>aiDrawPart2
      0  053f					      HI	DrawPart3
      1  053f		       f5		      .byte.b	>aiDrawPart3
      0  0540					      HI	GenerateMoves
      1  0540		       f4		      .byte.b	>aiGenerateMoves
      0  0541					      HI	ComputerMove
      1  0541		       f4		      .byte.b	>aiComputerMove
      0  0542					      HI	MoveIsSelected
      1  0542		       f8		      .byte.b	>aiMoveIsSelected
      0  0543					      HI	WriteStartPieceBlank
      1  0543		       f5		      .byte.b	>aiWriteStartPieceBlank
      0  0544					      HI	MarchToTargetA
      1  0544		       f5		      .byte.b	>aiMarchToTargetA
      0  0545					      HI	MarchA2
      1  0545		       f7		      .byte.b	>aiMarchA2
      0  0546					      HI	MarchB
      1  0546		       f6		      .byte.b	>aiMarchB
      0  0547					      HI	MarchToTargetB
      1  0547		       f4		      .byte.b	>aiMarchToTargetB
      0  0548					      HI	MarchB2
      1  0548		       f7		      .byte.b	>aiMarchB2
      0  0549					      HI	FinalFlash
      1  0549		       f5		      .byte.b	>aiFinalFlash
      0  054a					      HI	SpecialMoveFixup
      1  054a		       f5		      .byte.b	>aiSpecialMoveFixup
      0  054b					      HI	InCheckBackup
      1  054b		       f4		      .byte.b	>aiInCheckBackup
      0  054c					      HI	InCheckDelay
      1  054c		       f4		      .byte.b	>aiInCheckDelay
      0  054d					      HI	PromotePawnStart
      1  054d		       f4		      .byte.b	>aiPromotePawnStart
      0  054e					      HI	RollPromotionPiece
      1  054e		       f6		      .byte.b	>aiRollPromotionPiece
      0  054f					      HI	ChoosePromotePiece
      1  054f		       f7		      .byte.b	>aiChoosePromotePiece
      0  0550					      HI	ChooseDebounce
      1  0550		       f4		      .byte.b	>aiChooseDebounce
      0  0551					      HI	CheckMate
      1  0551		       f6		      .byte.b	>aiCheckMate
      0  0552					      HI	Draw
      1  0552		       f6		      .byte.b	>aiDraw
      0  0553					      HI	DelayAfterMove
      1  0553		       f4		      .byte.b	>aiDelayAfterMove
      0  0554					      HI	DelayAfterMove2
      1  0554		       f4		      .byte.b	>aiDelayAfterMove2
      0  0555					      HI	DelayAfterPlaced
      1  0555		       f4		      .byte.b	>aiDelayAfterPlaced
      0  0556					      HI	DelayAfterPlaced2
      1  0556		       f4		      .byte.b	>aiDelayAfterPlaced2
      0  0557					      HI	EPHandler
      1  0557		       f5		      .byte.b	>aiEPHandler
      0  0558					      HI	EPFlash
      1  0558		       f5		      .byte.b	>aiEPFlash
      0  0559					      HI	DebounceSelect
      1  0559		       f5		      .byte.b	>aiDebounceSelect
      0  055a					      HI	InCheckBackupStart
      1  055a		       f4		      .byte.b	>aiInCheckBackupStart
      0  055b					      HI	RestoreBitmaps
      1  055b		       f4		      .byte.b	>aiRestoreBitmaps
      0  055c					      HI	WaitBitmap
      1  055c		       f4		      .byte.b	>aiWaitBitmap
      0  055d					      HI	DrawBitmapBackground
      1  055d		       fc		      .byte.b	>aiDrawBitmapBackground
      0  055e					      HI	DrawBitmap2
      1  055e		       fc		      .byte.b	>aiDrawBitmap2
      0  055f					      HI	DrawBitmap3
      1  055f		       fc		      .byte.b	>aiDrawBitmap3
     52  0560
    366  0560
      0  0560					      DEF	AiVectorBANK
      1  0560				   SLOT_AiVectorBANK SET	_BANK_SLOT
      2  0560				   BANK_AiVectorBANK SET	SLOT_AiVectorBANK + _CURRENT_BANK
      3  0560				   AiVectorBANK
      4  0560				   TEMPORARY_VAR SET	Overlay
      5  0560				   TEMPORARY_OFFSET SET	0
      6  0560				   VAR_BOUNDARY_AiVectorBANK SET	TEMPORARY_OFFSET
      7  0560				   FUNCTION_NAME SET	AiVectorBANK
      0  0560					      TABDEF	BK
      1  0560
      0  0560					      BK	FlashComputerMove
      1  0560		       44		      .byte.b	BANK_aiFlashComputerMove
      0  0561					      BK	BeginSelectMovePhase
      1  0561		       44		      .byte.b	BANK_aiBeginSelectMovePhase
      0  0562					      BK	SelectStartSquare
      1  0562		       44		      .byte.b	BANK_aiSelectStartSquare
      0  0563					      BK	StartSquareSelected
      1  0563		       45		      .byte.b	BANK_aiStartSquareSelected
      0  0564					      BK	DrawMoves
      1  0564		       44		      .byte.b	BANK_aiDrawMoves
      0  0565					      BK	ShowMoveCaptures
      1  0565		       44		      .byte.b	BANK_aiShowMoveCaptures
      0  0566					      BK	SlowFlash
      1  0566		       44		      .byte.b	BANK_aiSlowFlash
      0  0567					      BK	UnDrawTargetSquares
      1  0567		       44		      .byte.b	BANK_aiUnDrawTargetSquares
      0  0568					      BK	SelectDestinationSquare
      1  0568		       44		      .byte.b	BANK_aiSelectDestinationSquare
      0  0569					      BK	Quiescent
      1  0569		       42		      .byte.b	BANK_aiQuiescent
      0  056a					      BK	ReselectDebounce
      1  056a		       45		      .byte.b	BANK_aiReselectDebounce
      0  056b					      BK	StartMoveGen
      1  056b		       44		      .byte.b	BANK_aiStartMoveGen
      0  056c					      BK	StepMoveGen
      1  056c		       45		      .byte.b	BANK_aiStepMoveGen
      0  056d					      BK	StartClearBoard
      1  056d		       89		      .byte.b	BANK_aiStartClearBoard
      0  056e					      BK	ClearEachRow
      1  056e		       89		      .byte.b	BANK_aiClearEachRow
      0  056f					      BK	DrawEntireBoard
      1  056f		       42		      .byte.b	BANK_aiDrawEntireBoard
      0  0570					      BK	DrawPart2
      1  0570		       42		      .byte.b	BANK_aiDrawPart2
      0  0571					      BK	DrawPart3
      1  0571		       42		      .byte.b	BANK_aiDrawPart3
      0  0572					      BK	GenerateMoves
      1  0572		       45		      .byte.b	BANK_aiGenerateMoves
      0  0573					      BK	ComputerMove
      1  0573		       43		      .byte.b	BANK_aiComputerMove
      0  0574					      BK	MoveIsSelected
      1  0574		       89		      .byte.b	BANK_aiMoveIsSelected
      0  0575					      BK	WriteStartPieceBlank
      1  0575		       45		      .byte.b	BANK_aiWriteStartPieceBlank
      0  0576					      BK	MarchToTargetA
      1  0576		       45		      .byte.b	BANK_aiMarchToTargetA
      0  0577					      BK	MarchA2
      1  0577		       44		      .byte.b	BANK_aiMarchA2
      0  0578					      BK	MarchB
      1  0578		       42		      .byte.b	BANK_aiMarchB
      0  0579					      BK	MarchToTargetB
      1  0579		       45		      .byte.b	BANK_aiMarchToTargetB
      0  057a					      BK	MarchB2
      1  057a		       44		      .byte.b	BANK_aiMarchB2
      0  057b					      BK	FinalFlash
      1  057b		       45		      .byte.b	BANK_aiFinalFlash
      0  057c					      BK	SpecialMoveFixup
      1  057c		       42		      .byte.b	BANK_aiSpecialMoveFixup
      0  057d					      BK	InCheckBackup
      1  057d		       44		      .byte.b	BANK_aiInCheckBackup
      0  057e					      BK	InCheckDelay
      1  057e		       44		      .byte.b	BANK_aiInCheckDelay
      0  057f					      BK	PromotePawnStart
      1  057f		       45		      .byte.b	BANK_aiPromotePawnStart
      0  0580					      BK	RollPromotionPiece
      1  0580		       44		      .byte.b	BANK_aiRollPromotionPiece
      0  0581					      BK	ChoosePromotePiece
      1  0581		       44		      .byte.b	BANK_aiChoosePromotePiece
      0  0582					      BK	ChooseDebounce
      1  0582		       45		      .byte.b	BANK_aiChooseDebounce
      0  0583					      BK	CheckMate
      1  0583		       42		      .byte.b	BANK_aiCheckMate
      0  0584					      BK	Draw
      1  0584		       42		      .byte.b	BANK_aiDraw
      0  0585					      BK	DelayAfterMove
      1  0585		       45		      .byte.b	BANK_aiDelayAfterMove
      0  0586					      BK	DelayAfterMove2
      1  0586		       45		      .byte.b	BANK_aiDelayAfterMove2
      0  0587					      BK	DelayAfterPlaced
      1  0587		       45		      .byte.b	BANK_aiDelayAfterPlaced
      0  0588					      BK	DelayAfterPlaced2
      1  0588		       45		      .byte.b	BANK_aiDelayAfterPlaced2
      0  0589					      BK	EPHandler
      1  0589		       45		      .byte.b	BANK_aiEPHandler
      0  058a					      BK	EPFlash
      1  058a		       42		      .byte.b	BANK_aiEPFlash
      0  058b					      BK	DebounceSelect
      1  058b		       44		      .byte.b	BANK_aiDebounceSelect
      0  058c					      BK	InCheckBackupStart
      1  058c		       44		      .byte.b	BANK_aiInCheckBackupStart
      0  058d					      BK	RestoreBitmaps
      1  058d		       44		      .byte.b	BANK_aiRestoreBitmaps
      0  058e					      BK	WaitBitmap
      1  058e		       44		      .byte.b	BANK_aiWaitBitmap
      0  058f					      BK	DrawBitmapBackground
      1  058f		       d9		      .byte.b	BANK_aiDrawBitmapBackground
      0  0590					      BK	DrawBitmap2
      1  0590		       d9		      .byte.b	BANK_aiDrawBitmap2
      0  0591					      BK	DrawBitmap3
      1  0591		       d9		      .byte.b	BANK_aiDrawBitmap3
     52  0592
    369  0592
    370  0592
    371  0592							;---------------------------------------------------------------------------------------------------
    372  0592
      0  0592					      DEF	AiStateMachine
      1  0592				   SLOT_AiStateMachine SET	_BANK_SLOT
      2  0592				   BANK_AiStateMachine SET	SLOT_AiStateMachine + _CURRENT_BANK
      3  0592				   AiStateMachine
      4  0592				   TEMPORARY_VAR SET	Overlay
      5  0592				   TEMPORARY_OFFSET SET	0
      6  0592				   VAR_BOUNDARY_AiStateMachine SET	TEMPORARY_OFFSET
      7  0592				   FUNCTION_NAME SET	AiStateMachine
    374  0592					      SUBROUTINE
    375  0592
      0  0592					      REF	StartupBankReset	;✅
      1  0592				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0592				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0592					      ENDIF
      0  0592					      VAR	__aiVec, 2
      1  0592
      2  0592		       00 a7	   __aiVec    =	TEMPORARY_VAR
      3  0592				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      4  0592
      5  0592				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  0592				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  0592				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  0592					      ENDIF
      9  0592				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  0592				  -	      LIST	ON
     11  0592				  -VNAME      SETSTR	__aiVec
     12  0592				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  0592				  -	      ERR
     14  0592				  -	      ECHO	"Temporary Variable overlow!"
     15  0592					      ENDIF
     16  0592					      LIST	ON
      0  0592					      VEND	AiStateMachine
      1  0592
      2  0592
      3  0592		       00 a9	   VAREND_AiStateMachine =	TEMPORARY_VAR
      4  0592
    379  0592
    380  0592
    381  0592							; State machine vector setup - points to current routine to execute
    382  0592
    383  0592		       a6 8b		      ldx	aiState
    384  0594		       bd fc f0 	      lda	AiVectorLO,x
    385  0597		       85 a7		      sta	__aiVec
    386  0599		       bd 2e f1 	      lda	AiVectorHI,x
    387  059c		       85 a8		      sta	__aiVec+1
    388  059e
    389  059e		       bd 60 f1 	      lda	AiVectorBANK,x
    390  05a1		       85 3f		      sta	SET_BANK
    391  05a3		       6c a7 00 	      jmp	(__aiVec)	; NOTE: could branch back to squeeze cycles
    392  05a6
    393  05a6
    394  05a6							;---------------------------------------------------------------------------------------------------
    395  05a6
      0  05a6					      DEF	GenerateAllMoves
      1  05a6				   SLOT_GenerateAllMoves SET	_BANK_SLOT
      2  05a6				   BANK_GenerateAllMoves SET	SLOT_GenerateAllMoves + _CURRENT_BANK
      3  05a6				   GenerateAllMoves
      4  05a6				   TEMPORARY_VAR SET	Overlay
      5  05a6				   TEMPORARY_OFFSET SET	0
      6  05a6				   VAR_BOUNDARY_GenerateAllMoves SET	TEMPORARY_OFFSET
      7  05a6				   FUNCTION_NAME SET	GenerateAllMoves
    397  05a6					      SUBROUTINE
    398  05a6
      0  05a6					      REF	ListPlayerMoves	;✅
      1  05a6					      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  05a6				   TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  05a6					      ENDIF
      0  05a6					      REF	aiComputerMove	;✅
      1  05a6				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  05a6				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  05a6					      ENDIF
      0  05a6					      REF	quiesce	;✅
      1  05a6				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  05a6				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  05a6					      ENDIF
      0  05a6					      REF	negaMax	;✅
      1  05a6				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  05a6				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  05a6					      ENDIF
    403  05a6
      0  05a6					      VAR	__vector, 2
      1  05a6
      2  05a6		       00 b5	   __vector   =	TEMPORARY_VAR
      3  05a6				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      4  05a6
      5  05a6				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  05a6				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  05a6				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  05a6					      ENDIF
      9  05a6				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  05a6				  -	      LIST	ON
     11  05a6				  -VNAME      SETSTR	__vector
     12  05a6				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  05a6				  -	      ERR
     14  05a6				  -	      ECHO	"Temporary Variable overlow!"
     15  05a6					      ENDIF
     16  05a6					      LIST	ON
      0  05a6					      VAR	__pieceFilter, 1
      1  05a6
      2  05a6		       00 b7	   __pieceFilter =	TEMPORARY_VAR
      3  05a6				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  05a6
      5  05a6				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  05a6				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  05a6				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  05a6					      ENDIF
      9  05a6				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  05a6				  -	      LIST	ON
     11  05a6				  -VNAME      SETSTR	__pieceFilter
     12  05a6				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  05a6				  -	      ERR
     14  05a6				  -	      ECHO	"Temporary Variable overlow!"
     15  05a6					      ENDIF
     16  05a6					      LIST	ON
    406  05a6
      0  05a6					      VEND	GenerateAllMoves
      1  05a6
      2  05a6
      3  05a6		       00 b8	   VAREND_GenerateAllMoves =	TEMPORARY_VAR
      4  05a6
    408  05a6
    409  05a6							; Do the move generation in two passes - pawns then pieces
    410  05a6							; This is an effort to get the alphabeta pruning happening with major pieces handled first in list
    411  05a6
    412  05a6							;{
    413  05a6
    414  05a6							; This MUST be called at the start of a new ply
    415  05a6							; It initialises the movelist to empty
    416  05a6							; x must be preserved
    417  05a6
    418  05a6		       a5 94		      lda	currentPly
    419  05a8		       85 3e		      sta	SET_BANK_RAM	;@2
    420  05aa
    421  05aa							; note that 'alpha' and 'beta' are set externally!!
    422  05aa
    423  05aa		       a9 ff		      lda	#-1
      0  05ac					      sta@PLY	moveIndex	; no valid moves
      1  05ac		       8d cf fb 	      sta	[RAM]+moveIndex
      0  05af					      sta@PLY	bestMove
      1  05af		       8d d1 fb 	      sta	[RAM]+bestMove
    426  05b2
    427  05b2		       a5 93		      lda	enPassantPawn	; flag/square from last actual move made
      0  05b4					      sta@PLY	enPassantSquare	; used for backtracking, to reset the flag
      1  05b4		       8d ca fb 	      sta	[RAM]+enPassantSquare
    429  05b7
    430  05b7		       a5 a4		      lda	vkSquare
      0  05b9					      sta@PLY	virtualKingSquare
      1  05b9		       8d da fb 	      sta	[RAM]+virtualKingSquare
    432  05bc		       a5 a5		      lda	vkSquare+1
      0  05be					      sta@PLY	virtualKingSquare+1	; traversal squares of king for castling
      1  05be		       8d db fb 	      sta	[RAM]+virtualKingSquare+1
    434  05c1
    435  05c1							; The value of the material (signed, 16-bit) is restored to the saved value at the reversion
    436  05c1							; of a move. It's quicker to restore than to re-sum. So we save the current evaluation at the
    437  05c1							; start of each new ply.
    438  05c1
    439  05c1		       a5 8f		      lda	Evaluation
      0  05c3					      sta@PLY	savedEvaluation
      1  05c3		       8d c8 fb 	      sta	[RAM]+savedEvaluation
    441  05c6		       a5 90		      lda	Evaluation+1
      0  05c8					      sta@PLY	savedEvaluation+1
      1  05c8		       8d c9 fb 	      sta	[RAM]+savedEvaluation+1
    443  05cb							;}
    444  05cb
    445  05cb
    446  05cb
    447  05cb		       a9 08		      lda	#8	; pawns
    448  05cd		       85 b7		      sta	__pieceFilter
    449  05cf		       20 e0 f1 	      jsr	MoveGenX
    450  05d2							;lda #99
    451  05d2							;sta currentSquare
    452  05d2		       a9 00		      lda	#0
    453  05d4		       85 b7		      sta	__pieceFilter
    454  05d6		       20 e0 f1 	      jsr	MoveGenX
    455  05d9
    456  05d9		       a9 43		      lda	#BANK_Sort
    457  05db		       85 3f		      sta	SET_BANK
    458  05dd		       4c 32 f6 	      jmp	Sort	;@1
    459  05e0
    460  05e0
    461  05e0
      0  05e0					      DEF	MoveGenX
      1  05e0				   SLOT_MoveGenX SET	_BANK_SLOT
      2  05e0				   BANK_MoveGenX SET	SLOT_MoveGenX + _CURRENT_BANK
      3  05e0				   MoveGenX
      4  05e0				   TEMPORARY_VAR SET	Overlay
      5  05e0				   TEMPORARY_OFFSET SET	0
      6  05e0				   VAR_BOUNDARY_MoveGenX SET	TEMPORARY_OFFSET
      7  05e0				   FUNCTION_NAME SET	MoveGenX
    463  05e0					      SUBROUTINE
    464  05e0
    465  05e0		       a9 d0		      lda	#RAMBANK_BOARD
    466  05e2		       85 3e		      sta	SET_BANK_RAM	;@3		 ; should be hardwired forever, right?
    467  05e4
    468  05e4		       a2 64		      ldx	#100
    469  05e6		       d0 02		      bne	.next
    470  05e8
      0  05e8					      DEF	MoveReturn
      1  05e8				   SLOT_MoveReturn SET	_BANK_SLOT
      2  05e8				   BANK_MoveReturn SET	SLOT_MoveReturn + _CURRENT_BANK
      3  05e8				   MoveReturn
      4  05e8				   TEMPORARY_VAR SET	Overlay
      5  05e8				   TEMPORARY_OFFSET SET	0
      6  05e8				   VAR_BOUNDARY_MoveReturn SET	TEMPORARY_OFFSET
      7  05e8				   FUNCTION_NAME SET	MoveReturn
    472  05e8
    473  05e8		       a6 92		      ldx	currentSquare
    474  05ea		       ca	   .next      dex
    475  05eb		       e0 16		      cpx	#22
    476  05ed		       90 2c		      bcc	.exit
    477  05ef
    478  05ef		       bd 79 fc 	      lda	Board,x
    479  05f2		       f0 f6		      beq	.next
    480  05f4		       c9 ff		      cmp	#-1
    481  05f6		       f0 f2		      beq	.next
    482  05f8		       45 95		      eor	sideToMove
    483  05fa		       30 ee		      bmi	.next
    484  05fc
    485  05fc		       86 92		      stx	currentSquare
    486  05fe
    487  05fe		       45 95		      eor	sideToMove
    488  0600		       29 ef		      and	#~FLAG_CASTLE	; todo: better part of the move, mmh?
    489  0602		       85 91		      sta	currentPiece
    490  0604		       29 0f		      and	#PIECE_MASK
    491  0606		       05 b7		      ora	__pieceFilter
    492  0608		       a8		      tay
    493  0609
    494  0609		       b9 30 f2 	      lda	HandlerVectorHI,y
    495  060c		       85 b6		      sta	__vector+1
    496  060e		       b9 20 f2 	      lda	HandlerVectorLO,y
    497  0611		       85 b5		      sta	__vector
    498  0613
    499  0613		       b9 40 f2 	      lda	HandlerVectorBANK,y
    500  0616		       85 3f		      sta	SET_BANK	;@1
    501  0618
    502  0618		       6c b5 00 	      jmp	(__vector)
    503  061b
    504  061b
    505  061b		       a9 43	   .exit      lda	#BANK_negaMax
    506  061d		       85 3f		      sta	SET_BANK
    507  061f		       60		      rts
    508  0620
    509  0620					      MAC	handlevec
    510  0620					      DEF	HandlerVector{1}
    511  0620
    512  0620					      .byte	{2}MoveReturn
    513  0620					      .byte	{2}MoveReturn	;byte {1}Handle_WHITE_PAWN	   ; 1
    514  0620					      .byte	{2}MoveReturn	;.byte {1}Handle_BLACK_PAWN	    ; 2
    515  0620					      .byte	{2}Handle_KNIGHT	; 3
    516  0620					      .byte	{2}Handle_BISHOP	; 4
    517  0620					      .byte	{2}Handle_ROOK	; 5
    518  0620					      .byte	{2}Handle_QUEEN	; 6
    519  0620					      .byte	{2}Handle_KING	; 7
    520  0620
    521  0620					      .byte	{2}MoveReturn
    522  0620					      .byte	{2}Handle_WHITE_PAWN	; 1
    523  0620					      .byte	{2}Handle_BLACK_PAWN	; 2
    524  0620					      .byte	{2}MoveReturn	;.byte {1}Handle_KNIGHT	    ; 3
    525  0620					      .byte	{2}MoveReturn	;.byte {1}Handle_BISHOP	    ; 4
    526  0620					      .byte	{2}MoveReturn	;.byte {1}Handle_ROOK		    ; 5
    527  0620					      .byte	{2}MoveReturn	;.byte {1}Handle_QUEEN 	    ; 6
    528  0620					      .byte	{2}MoveReturn	;.byte {1}Handle_KING		    ; 7
    529  0620
    530  0620					      ENDM		; {label}, {macro}
    531  0620
    532  0620
    533  0620							;    .byte 0	  ; dummy to prevent page cross access on index 0
    534  0620
      0  0620					      HANDLEVEC	LO, <
      0  0620					      DEF	HandlerVectorLO
      1  0620				   SLOT_HandlerVectorLO SET	_BANK_SLOT
      2  0620				   BANK_HandlerVectorLO SET	SLOT_HandlerVectorLO + _CURRENT_BANK
      3  0620				   HandlerVectorLO
      4  0620				   TEMPORARY_VAR SET	Overlay
      5  0620				   TEMPORARY_OFFSET SET	0
      6  0620				   VAR_BOUNDARY_HandlerVectorLO SET	TEMPORARY_OFFSET
      7  0620				   FUNCTION_NAME SET	HandlerVectorLO
      2  0620
      3  0620		       e8		      .byte.b	<MoveReturn
      4  0621		       e8		      .byte.b	<MoveReturn
      5  0622		       e8		      .byte.b	<MoveReturn
      6  0623		       a8		      .byte.b	<Handle_KNIGHT
      7  0624		       51		      .byte.b	<Handle_BISHOP
      8  0625		       00		      .byte.b	<Handle_ROOK
      9  0626		       7b		      .byte.b	<Handle_QUEEN
     10  0627		       6e		      .byte.b	<Handle_KING
     11  0628
     12  0628		       e8		      .byte.b	<MoveReturn
     13  0629		       29		      .byte.b	<Handle_WHITE_PAWN
     14  062a		       fd		      .byte.b	<Handle_BLACK_PAWN
     15  062b		       e8		      .byte.b	<MoveReturn
     16  062c		       e8		      .byte.b	<MoveReturn
     17  062d		       e8		      .byte.b	<MoveReturn
     18  062e		       e8		      .byte.b	<MoveReturn
     19  062f		       e8		      .byte.b	<MoveReturn
     20  0630
      0  0630					      HANDLEVEC	HI, >
      0  0630					      DEF	HandlerVectorHI
      1  0630				   SLOT_HandlerVectorHI SET	_BANK_SLOT
      2  0630				   BANK_HandlerVectorHI SET	SLOT_HandlerVectorHI + _CURRENT_BANK
      3  0630				   HandlerVectorHI
      4  0630				   TEMPORARY_VAR SET	Overlay
      5  0630				   TEMPORARY_OFFSET SET	0
      6  0630				   VAR_BOUNDARY_HandlerVectorHI SET	TEMPORARY_OFFSET
      7  0630				   FUNCTION_NAME SET	HandlerVectorHI
      2  0630
      3  0630		       f1		      .byte.b	>MoveReturn
      4  0631		       f1		      .byte.b	>MoveReturn
      5  0632		       f1		      .byte.b	>MoveReturn
      6  0633		       f5		      .byte.b	>Handle_KNIGHT
      7  0634		       f6		      .byte.b	>Handle_BISHOP
      8  0635		       f4		      .byte.b	>Handle_ROOK
      9  0636		       f4		      .byte.b	>Handle_QUEEN
     10  0637		       f5		      .byte.b	>Handle_KING
     11  0638
     12  0638		       f1		      .byte.b	>MoveReturn
     13  0639		       f4		      .byte.b	>Handle_WHITE_PAWN
     14  063a		       f4		      .byte.b	>Handle_BLACK_PAWN
     15  063b		       f1		      .byte.b	>MoveReturn
     16  063c		       f1		      .byte.b	>MoveReturn
     17  063d		       f1		      .byte.b	>MoveReturn
     18  063e		       f1		      .byte.b	>MoveReturn
     19  063f		       f1		      .byte.b	>MoveReturn
     20  0640
      0  0640					      HANDLEVEC	BANK, BANK_
      0  0640					      DEF	HandlerVectorBANK
      1  0640				   SLOT_HandlerVectorBANK SET	_BANK_SLOT
      2  0640				   BANK_HandlerVectorBANK SET	SLOT_HandlerVectorBANK + _CURRENT_BANK
      3  0640				   HandlerVectorBANK
      4  0640				   TEMPORARY_VAR SET	Overlay
      5  0640				   TEMPORARY_OFFSET SET	0
      6  0640				   VAR_BOUNDARY_HandlerVectorBANK SET	TEMPORARY_OFFSET
      7  0640				   FUNCTION_NAME SET	HandlerVectorBANK
      2  0640
      3  0640		       01		      .byte.b	BANK_MoveReturn
      4  0641		       01		      .byte.b	BANK_MoveReturn
      5  0642		       01		      .byte.b	BANK_MoveReturn
      6  0643		       46		      .byte.b	BANK_Handle_KNIGHT
      7  0644		       46		      .byte.b	BANK_Handle_BISHOP
      8  0645		       47		      .byte.b	BANK_Handle_ROOK
      9  0646		       47		      .byte.b	BANK_Handle_QUEEN
     10  0647		       47		      .byte.b	BANK_Handle_KING
     11  0648
     12  0648		       01		      .byte.b	BANK_MoveReturn
     13  0649		       46		      .byte.b	BANK_Handle_WHITE_PAWN
     14  064a		       46		      .byte.b	BANK_Handle_BLACK_PAWN
     15  064b		       01		      .byte.b	BANK_MoveReturn
     16  064c		       01		      .byte.b	BANK_MoveReturn
     17  064d		       01		      .byte.b	BANK_MoveReturn
     18  064e		       01		      .byte.b	BANK_MoveReturn
     19  064f		       01		      .byte.b	BANK_MoveReturn
     20  0650
    538  0650
    539  0650
    540  0650							;---------------------------------------------------------------------------------------------------
    541  0650
      0  0650					      DEF	ListPlayerMoves
      1  0650				   SLOT_ListPlayerMoves SET	_BANK_SLOT
      2  0650				   BANK_ListPlayerMoves SET	SLOT_ListPlayerMoves + _CURRENT_BANK
      3  0650				   ListPlayerMoves
      4  0650				   TEMPORARY_VAR SET	Overlay
      5  0650				   TEMPORARY_OFFSET SET	0
      6  0650				   VAR_BOUNDARY_ListPlayerMoves SET	TEMPORARY_OFFSET
      7  0650				   FUNCTION_NAME SET	ListPlayerMoves
    543  0650					      SUBROUTINE
    544  0650
    545  0650							; Build a list of (mostly) valid player moves. The list of all moves is generated, and then
    546  0650							; these are each verified by making the move and listing all opponent moves. If the opponent
    547  0650							; can capture the king, the move is invalidated by setting its "from" square to zero.
    548  0650
    549  0650							; The movelist is built in the second ply so as not to stomp on the movelist from the computer
    550  0650							; on the previous response. This allows the player movelist to be generated BEFORE the
    551  0650							; computer's move has been visually shown on the screen.
    552  0650
    553  0650							; This in turn requires the minimum memory for PLY banks to be 3 (computer, player, response)
    554  0650
      0  0650					      REF	COMMON_VARS
      1  0650					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0650				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0650					      ENDIF
      0  0650					      REF	selectmove	;✅
      1  0650				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  0650				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  0650					      ENDIF
      0  0650					      REF	StartupBankReset	;✅
      1  0650				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0650				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0650					      ENDIF
    558  0650
      0  0650					      VEND	ListPlayerMoves
      1  0650
      2  0650
      3  0650		       00 b5	   VAREND_ListPlayerMoves =	TEMPORARY_VAR
      4  0650
    560  0650
    561  0650
    562  0650		       a9 00		      lda	#0
    563  0652		       85 b2		      sta	__quiesceCapOnly	; gen ALL moves
    564  0654
    565  0654		       a9 89		      lda	#RAMBANK_PLY+1
    566  0656		       85 94		      sta	currentPly
    567  0658
    568  0658		       20 a6 f1 	      jsr	GenerateAllMoves	;@this
    569  065b
      0  065b					      ldx@PLY	moveIndex
      1  065b		       ae cf f9 	      ldx	moveIndex
      0  065e				   .scan      stx@PLY	movePtr
      1  065e		       8e d0 fb 	      stx	[RAM]+movePtr
    572  0661
      0  0661					      CALL	MakeMove	;@1
      1  0661				  -	      IF	SLOT_MakeMove == _BANK_SLOT
      2  0661				  -FNAME      SETSTR	MakeMove
      3  0661				  -	      ECHO	""
      4  0661				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0661				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0661				  -	      ERR
      7  0661					      ENDIF
      8  0661		       a9 43		      lda	#BANK_MakeMove
      9  0663		       85 3f		      sta	SET_BANK
     10  0665		       20 8b f4 	      jsr	MakeMove
    574  0668
    575  0668		       e6 94		      inc	currentPly
    576  066a		       20 a6 f1 	      jsr	GenerateAllMoves	;@this
    577  066d
    578  066d		       c6 94		      dec	currentPly
    579  066f
    580  066f		       20 ad f2 	      jsr	unmakeMove	;@this
    581  0672
    582  0672		       a5 9f		      lda	flagCheck
    583  0674		       f0 08		      beq	.next
    584  0676
      0  0676					      ldx@PLY	movePtr
      1  0676		       ae d0 f9 	      ldx	movePtr
    586  0679		       a9 00		      lda	#0
      0  067b					      sta@PLY	MoveFrom,x	; invalidate move (still in check!)
      1  067b		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
    588  067e
      0  067e				   .next      ldx@PLY	movePtr
      1  067e		       ae d0 f9 	      ldx	movePtr
    590  0681		       ca		      dex
    591  0682		       10 da		      bpl	.scan
    592  0684
    593  0684		       60		      rts
    594  0685
    595  0685
    596  0685							;---------------------------------------------------------------------------------------------------
    597  0685
      0  0685					      DEF	AddMove
      1  0685				   SLOT_AddMove SET	_BANK_SLOT
      2  0685				   BANK_AddMove SET	SLOT_AddMove + _CURRENT_BANK
      3  0685				   AddMove
      4  0685				   TEMPORARY_VAR SET	Overlay
      5  0685				   TEMPORARY_OFFSET SET	0
      6  0685				   VAR_BOUNDARY_AddMove SET	TEMPORARY_OFFSET
      7  0685				   FUNCTION_NAME SET	AddMove
    599  0685					      SUBROUTINE
    600  0685
      0  0685					      REF	Handle_KING	;✅
      1  0685					      IF	VAREND_Handle_KING > TEMPORARY_VAR
      2  0685				   TEMPORARY_VAR SET	VAREND_Handle_KING
      3  0685					      ENDIF
      0  0685					      REF	Handle_QUEEN	;✅
      1  0685				  -	      IF	VAREND_Handle_QUEEN > TEMPORARY_VAR
      2  0685				  -TEMPORARY_VAR SET	VAREND_Handle_QUEEN
      3  0685					      ENDIF
      0  0685					      REF	Handle_ROOK	;✅
      1  0685				  -	      IF	VAREND_Handle_ROOK > TEMPORARY_VAR
      2  0685				  -TEMPORARY_VAR SET	VAREND_Handle_ROOK
      3  0685					      ENDIF
      0  0685					      REF	Handle_BISHOP	;✅
      1  0685				  -	      IF	VAREND_Handle_BISHOP > TEMPORARY_VAR
      2  0685				  -TEMPORARY_VAR SET	VAREND_Handle_BISHOP
      3  0685					      ENDIF
      0  0685					      REF	Handle_KNIGHT	;✅
      1  0685				  -	      IF	VAREND_Handle_KNIGHT > TEMPORARY_VAR
      2  0685				  -TEMPORARY_VAR SET	VAREND_Handle_KNIGHT
      3  0685					      ENDIF
      0  0685					      REF	Handle_WHITE_PAWN	;✅
      1  0685				  -	      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  0685				  -TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  0685					      ENDIF
      0  0685					      REF	Handle_BLACK_PAWN	;✅
      1  0685				  -	      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  0685				  -TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  0685					      ENDIF
    608  0685
      0  0685					      VEND	AddMove
      1  0685
      2  0685
      3  0685		       00 b8	   VAREND_AddMove =	TEMPORARY_VAR
      4  0685
    610  0685
    611  0685							; add square in y register to movelist as destination (X12 format)
    612  0685							; [y]		     to square (X12)
    613  0685							; currentSquare     from square (X12)
    614  0685							; currentPiece      piece.
    615  0685							;   ENPASSANT flag set if pawn double-moving off opening rank
    616  0685							; capture	     captured piece
    617  0685
    618  0685
    619  0685		       a5 9b		      lda	capture
    620  0687		       d0 04		      bne	.always
    621  0689		       a5 b2		      lda	__quiesceCapOnly
    622  068b		       d0 1c		      bne	.abort
    623  068d
    624  068d		       98	   .always    tya
    625  068e		       aa		      tax
    626  068f
      0  068f					      ldy@PLY	moveIndex
      1  068f		       ac cf f9 	      ldy	moveIndex
    628  0692		       c8		      iny
      0  0693					      sty@PLY	moveIndex
      1  0693		       8c cf fb 	      sty	[RAM]+moveIndex
    630  0696
      0  0696					      sta@PLY	MoveTo,y
      1  0696		       99 64 fa 	      sta	[RAM]+MoveTo,y
    632  0699		       a5 92		      lda	currentSquare
      0  069b					      sta@PLY	MoveFrom,y
      1  069b		       99 00 fa 	      sta	[RAM]+MoveFrom,y
    634  069e		       a5 91		      lda	currentPiece
      0  06a0					      sta@PLY	MovePiece,y
      1  06a0		       99 00 fb 	      sta	[RAM]+MovePiece,y
    636  06a3		       a5 9b		      lda	capture
      0  06a5					      sta@PLY	MoveCapture,y
      1  06a5		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    638  06a8		       60		      rts
    639  06a9
    640  06a9		       98	   .abort     tya
    641  06aa		       aa		      tax
    642  06ab		       60		      rts
    643  06ac
    644  06ac
    645  06ac							;---------------------------------------------------------------------------------------------------
    646  06ac
      0  06ac					      DEF	debug
      1  06ac				   SLOT_debug SET	_BANK_SLOT
      2  06ac				   BANK_debug SET	SLOT_debug + _CURRENT_BANK
      3  06ac				   debug
      4  06ac				   TEMPORARY_VAR SET	Overlay
      5  06ac				   TEMPORARY_OFFSET SET	0
      6  06ac				   VAR_BOUNDARY_debug SET	TEMPORARY_OFFSET
      7  06ac				   FUNCTION_NAME SET	debug
    648  06ac					      SUBROUTINE
    649  06ac		       60		      rts
    650  06ad
    651  06ad
    652  06ad							;---------------------------------------------------------------------------------------------------
    653  06ad
      0  06ad					      DEF	unmakeMove
      1  06ad				   SLOT_unmakeMove SET	_BANK_SLOT
      2  06ad				   BANK_unmakeMove SET	SLOT_unmakeMove + _CURRENT_BANK
      3  06ad				   unmakeMove
      4  06ad				   TEMPORARY_VAR SET	Overlay
      5  06ad				   TEMPORARY_OFFSET SET	0
      6  06ad				   VAR_BOUNDARY_unmakeMove SET	TEMPORARY_OFFSET
      7  06ad				   FUNCTION_NAME SET	unmakeMove
    655  06ad					      SUBROUTINE
    656  06ad
      0  06ad					      REF	selectmove	;✅
      1  06ad					      IF	VAREND_selectmove > TEMPORARY_VAR
      2  06ad				   TEMPORARY_VAR SET	VAREND_selectmove
      3  06ad					      ENDIF
      0  06ad					      REF	ListPlayerMoves	;✅
      1  06ad				  -	      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  06ad				  -TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  06ad					      ENDIF
      0  06ad					      REF	quiesce	;✅
      1  06ad				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  06ad				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  06ad					      ENDIF
      0  06ad					      REF	negaMax	;✅
      1  06ad				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  06ad				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  06ad					      ENDIF
      0  06ad					      VEND	unmakeMove
      1  06ad
      2  06ad
      3  06ad		       00 b5	   VAREND_unmakeMove =	TEMPORARY_VAR
      4  06ad
    662  06ad
    663  06ad							; restore the board evaluation to what it was at the start of this ply
    664  06ad							; TODO: note: moved flag seems wrong on restoration??
    665  06ad
    666  06ad		       a5 94		      lda	currentPly
    667  06af		       85 3e		      sta	SET_BANK_RAM	;@2
    668  06b1		       a2 d0		      ldx	#RAMBANK_BOARD
    669  06b3		       86 3e		      stx	SET_BANK_RAM	;@3
    670  06b5
      0  06b5					      lda@PLY	savedEvaluation
      1  06b5		       ad c8 f9 	      lda	savedEvaluation
    672  06b8		       85 8f		      sta	Evaluation
      0  06ba					      lda@PLY	savedEvaluation+1
      1  06ba		       ad c9 f9 	      lda	savedEvaluation+1
    674  06bd		       85 90		      sta	Evaluation+1
    675  06bf
      0  06bf					      lda@PLY	virtualKingSquare
      1  06bf		       ad da f9 	      lda	virtualKingSquare
    677  06c2		       85 a4		      sta	vkSquare
      0  06c4					      lda@PLY	virtualKingSquare+1
      1  06c4		       ad db f9 	      lda	virtualKingSquare+1
    679  06c7		       85 a5		      sta	vkSquare+1
    680  06c9
      0  06c9					      lda@PLY	enPassantSquare
      1  06c9		       ad ca f9 	      lda	enPassantSquare
    682  06cc		       85 93		      sta	enPassantPawn
    683  06ce
      0  06ce					      ldx@PLY	movePtr
      1  06ce		       ae d0 f9 	      ldx	movePtr
      0  06d1					      ldy@PLY	MoveFrom,x
      1  06d1		       bc 00 f8 	      ldy	MoveFrom,x
      0  06d4					      lda@PLY	restorePiece
      1  06d4		       ad d9 f9 	      lda	restorePiece
      0  06d7					      sta@RAM	Board,y
      1  06d7		       99 79 fe 	      sta	[RAM]+Board,y
    688  06da
      0  06da					      ldy@PLY	MoveTo,x
      1  06da		       bc 64 f8 	      ldy	MoveTo,x
      0  06dd					      lda@PLY	capturedPiece
      1  06dd		       ad cb f9 	      lda	capturedPiece
      0  06e0					      sta@RAM	Board,y
      1  06e0		       99 79 fe 	      sta	[RAM]+Board,y
    692  06e3
    693  06e3
    694  06e3							; See if there are any 'secondary' pieces that moved
    695  06e3							; here we're dealing with reverting a castling or enPassant move
    696  06e3
      0  06e3					      lda@PLY	secondaryPiece
      1  06e3		       ad cc f9 	      lda	secondaryPiece
    698  06e6		       f0 10		      beq	.noSecondary
      0  06e8					      ldx@PLY	secondarySquare
      1  06e8		       ae cd f9 	      ldx	secondarySquare
      0  06eb					      sta@RAM	Board,x	; put piece back
      1  06eb		       9d 79 fe 	      sta	[RAM]+Board,x
      0  06ee					      ldy@PLY	secondaryBlank
      1  06ee		       ac ce f9 	      ldy	secondaryBlank
    702  06f1		       f0 05		      beq	.noSecondary	; enpassant - no blanker square
    703  06f3		       a9 00		      lda	#0
      0  06f5					      sta@RAM	Board,y	; blank piece origin
      1  06f5		       99 79 fe 	      sta	[RAM]+Board,y
    705  06f8
      0  06f8				   .noSecondary SWAP
      1  06f8
      2  06f8		       a5 95		      lda	sideToMove
      3  06fa		       49 c0		      eor	#SWAP_SIDE|HUMAN
      4  06fc		       85 95		      sta	sideToMove
      5  06fe
    707  06fe		       60		      rts
    708  06ff
    709  06ff
    710  06ff							;---------------------------------------------------------------------------------------------------
    711  06ff
      0  06ff					      DEF	showMoveCaptures
      1  06ff				   SLOT_showMoveCaptures SET	_BANK_SLOT
      2  06ff				   BANK_showMoveCaptures SET	SLOT_showMoveCaptures + _CURRENT_BANK
      3  06ff				   showMoveCaptures
      4  06ff				   TEMPORARY_VAR SET	Overlay
      5  06ff				   TEMPORARY_OFFSET SET	0
      6  06ff				   VAR_BOUNDARY_showMoveCaptures SET	TEMPORARY_OFFSET
      7  06ff				   FUNCTION_NAME SET	showMoveCaptures
    713  06ff					      SUBROUTINE
    714  06ff
      0  06ff					      REF	aiShowMoveCaptures	;✅
      1  06ff					      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  06ff				   TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  06ff					      ENDIF
    716  06ff
      0  06ff					      VAR	__toSquareX12, 1
      1  06ff
      2  06ff		       00 a9	   __toSquareX12 =	TEMPORARY_VAR
      3  06ff				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  06ff
      5  06ff				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  06ff				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  06ff				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  06ff					      ENDIF
      9  06ff				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  06ff				  -	      LIST	ON
     11  06ff				  -VNAME      SETSTR	__toSquareX12
     12  06ff				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  06ff				  -	      ERR
     14  06ff				  -	      ECHO	"Temporary Variable overlow!"
     15  06ff					      ENDIF
     16  06ff					      LIST	ON
      0  06ff					      VAR	__fromPiece, 1
      1  06ff
      2  06ff		       00 aa	   __fromPiece =	TEMPORARY_VAR
      3  06ff				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  06ff
      5  06ff				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  06ff				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  06ff				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  06ff					      ENDIF
      9  06ff				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  06ff				  -	      LIST	ON
     11  06ff				  -VNAME      SETSTR	__fromPiece
     12  06ff				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  06ff				  -	      ERR
     14  06ff				  -	      ECHO	"Temporary Variable overlow!"
     15  06ff					      ENDIF
     16  06ff					      LIST	ON
      0  06ff					      VAR	__aiMoveIndex, 1
      1  06ff
      2  06ff		       00 ab	   __aiMoveIndex =	TEMPORARY_VAR
      3  06ff				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  06ff
      5  06ff				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  06ff				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  06ff				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  06ff					      ENDIF
      9  06ff				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  06ff				  -	      LIST	ON
     11  06ff				  -VNAME      SETSTR	__aiMoveIndex
     12  06ff				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  06ff				  -	      ERR
     14  06ff				  -	      ECHO	"Temporary Variable overlow!"
     15  06ff					      ENDIF
     16  06ff					      LIST	ON
    720  06ff
      0  06ff					      VEND	showMoveCaptures
      1  06ff
      2  06ff
      3  06ff		       00 ac	   VAREND_showMoveCaptures =	TEMPORARY_VAR
      4  06ff
    722  06ff
    723  06ff							; place a marker on the board for any square matching the piece
    724  06ff							; EXCEPT for squares which are occupied (we'll flash those later)
    725  06ff							; x = movelist item # being checked
    726  06ff
    727  06ff
    728  06ff		       a6 8d	   .next      ldx	aiMoveIndex
    729  0701		       86 ab		      stx	__aiMoveIndex
    730  0703		       30 4a		      bmi	.skip	; no moves in list
    731  0705
    732  0705		       ad 84 02 	      lda	INTIM
    733  0708		       c9 14		      cmp	#20
    734  070a		       90 43		      bcc	.skip
    735  070c
    736  070c		       c6 8d		      dec	aiMoveIndex
    737  070e
    738  070e		       a9 89		      lda	#RAMBANK_PLY+1
    739  0710		       85 3e		      sta	SET_BANK_RAM
      0  0712					      lda@PLY	MoveFrom,x
      1  0712		       bd 00 f8 	      lda	MoveFrom,x
    741  0715		       c5 85		      cmp	fromX12
    742  0717		       d0 e6		      bne	.next
    743  0719
      0  0719					      lda@PLY	MoveTo,x
      1  0719		       bd 64 f8 	      lda	MoveTo,x
    745  071c		       85 a9		      sta	__toSquareX12
    746  071e		       a8		      tay
    747  071f
    748  071f		       a9 d0		      lda	#RAMBANK_BOARD
    749  0721		       85 3e		      sta	SET_BANK_RAM	;@3
    750  0723		       b9 79 fc 	      lda	Board,y
    751  0726		       29 0f		      and	#PIECE_MASK
    752  0728		       f0 d5		      beq	.next
    753  072a
    754  072a							; There's something on the board at destination, so it's a capture
    755  072a							; Let's see if we are doing a pawn promote...
    756  072a
    757  072a		       a4 85		      ldy	fromX12
    758  072c
    759  072c		       a9 d0		      lda	#RAMBANK_BOARD
    760  072e		       85 3e		      sta	SET_BANK_RAM	;@3
    761  0730		       b9 79 fc 	      lda	Board,y
    762  0733		       85 aa		      sta	__fromPiece
    763  0735
    764  0735		       a9 89		      lda	#RAMBANK_PLY+1
    765  0737		       85 3e		      sta	SET_BANK_RAM
      0  0739					      lda@PLY	MovePiece,x
      1  0739		       bd 00 f9 	      lda	MovePiece,x
    767  073c		       45 aa		      eor	__fromPiece
    768  073e		       29 0f		      and	#PIECE_MASK
    769  0740		       f0 06		      beq	.legit	; from == to, so not a promote
    770  0742
    771  0742							; Have detected a promotion duplicate - skip all 3 of them
    772  0742							; TODO: this will need reworking once moves are sorted
    773  0742
    774  0742		       c6 8d		      dec	aiMoveIndex	; skip "KBRQ" promotes
    775  0744		       c6 8d		      dec	aiMoveIndex
    776  0746		       c6 8d		      dec	aiMoveIndex
    777  0748
    778  0748				   .legit
    779  0748
    780  0748							;TIMECHECK CopySinglePiece, restoreIndex     ; not enough time to draw
    781  0748
    782  0748		       a5 a9		      lda	__toSquareX12
    783  074a		       85 80		      sta	squareToDraw
    784  074c
    785  074c							; WARNING - local variables will not survive the following call...!
    786  074c		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    787  074f
    788  074f		       60	   .skip      rts
    789  0750
    790  0750
    791  0750							;---------------------------------------------------------------------------------------------------
    792  0750
      0  0750					      DEF	CopyPieceToRowBitmap
      1  0750				   SLOT_CopyPieceToRowBitmap SET	_BANK_SLOT
      2  0750				   BANK_CopyPieceToRowBitmap SET	SLOT_CopyPieceToRowBitmap + _CURRENT_BANK
      3  0750				   CopyPieceToRowBitmap
      4  0750				   TEMPORARY_VAR SET	Overlay
      5  0750				   TEMPORARY_OFFSET SET	0
      6  0750				   VAR_BOUNDARY_CopyPieceToRowBitmap SET	TEMPORARY_OFFSET
      7  0750				   FUNCTION_NAME SET	CopyPieceToRowBitmap
    794  0750					      SUBROUTINE
    795  0750
      0  0750					      REF	Variable_PieceShapeBuffer
      1  0750					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  0750				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  0750					      ENDIF
      0  0750					      REF	InterceptMarkerCopy	;✅
      1  0750				  -	      IF	VAREND_InterceptMarkerCopy > TEMPORARY_VAR
      2  0750				  -TEMPORARY_VAR SET	VAREND_InterceptMarkerCopy
      3  0750					      ENDIF
    798  0750
      0  0750					      VEND	CopyPieceToRowBitmap
      1  0750
      2  0750
      3  0750		       00 ef	   VAREND_CopyPieceToRowBitmap =	TEMPORARY_VAR
      4  0750
    800  0750
    801  0750		       a0 11		      ldy	#17
    802  0752		       b0 30		      bcs	.rightSide
    803  0754
    804  0754		       b9 a7 00    .copyPiece lda	__pieceShapeBuffer,y
    805  0757		       f0 06		      beq	.blank1
    806  0759		       59 00 f8 	      eor	ChessBitmap,y
      0  075c					      sta@RAM	ChessBitmap,y
      1  075c		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
    808  075f
    809  075f		       b9 b9 00    .blank1    lda	__pieceShapeBuffer+18,y
    810  0762		       f0 06		      beq	.blank2
    811  0764		       59 12 f8 	      eor	ChessBitmap+18,y
      0  0767					      sta@RAM	ChessBitmap+18,y
      1  0767		       99 12 fa 	      sta	[RAM]+ChessBitmap+18,y
    813  076a
    814  076a		       b9 cb 00    .blank2    lda	__pieceShapeBuffer+36,y
    815  076d		       f0 06		      beq	.blank3
    816  076f		       59 24 f8 	      eor	ChessBitmap+36,y
      0  0772					      sta@RAM	ChessBitmap+36,y
      1  0772		       99 24 fa 	      sta	[RAM]+ChessBitmap+36,y
    818  0775
    819  0775		       b9 dd 00    .blank3    lda	__pieceShapeBuffer+54,y
    820  0778		       f0 06		      beq	.blank4
    821  077a		       59 36 f8 	      eor	ChessBitmap+54,y
      0  077d					      sta@RAM	ChessBitmap+54,y
      1  077d		       99 36 fa 	      sta	[RAM]+ChessBitmap+54,y
    823  0780
    824  0780		       88	   .blank4    dey
    825  0781		       10 d1		      bpl	.copyPiece
    826  0783		       60		      rts
    827  0784
    828  0784				   .rightSide
    829  0784
    830  0784					      SUBROUTINE
    831  0784
    832  0784		       b9 a7 00    .copyPieceR lda	__pieceShapeBuffer,y
    833  0787		       f0 06		      beq	.blank1
    834  0789		       59 48 f8 	      eor	ChessBitmap+PIECE_SHAPE_SIZE,y
      0  078c					      sta@RAM	ChessBitmap+PIECE_SHAPE_SIZE,y
      1  078c		       99 48 fa 	      sta	[RAM]+ChessBitmap+PIECE_SHAPE_SIZE,y
    836  078f
    837  078f		       b9 b9 00    .blank1    lda	__pieceShapeBuffer+18,y
    838  0792		       f0 06		      beq	.blank2
    839  0794		       59 5a f8 	      eor	ChessBitmap+PIECE_SHAPE_SIZE+18,y
      0  0797					      sta@RAM	ChessBitmap+PIECE_SHAPE_SIZE+18,y
      1  0797		       99 5a fa 	      sta	[RAM]+ChessBitmap+PIECE_SHAPE_SIZE+18,y
    841  079a
    842  079a		       b9 cb 00    .blank2    lda	__pieceShapeBuffer+36,y
    843  079d		       f0 06		      beq	.blank3
    844  079f		       59 6c f8 	      eor	ChessBitmap+PIECE_SHAPE_SIZE+36,y
      0  07a2					      sta@RAM	ChessBitmap+PIECE_SHAPE_SIZE+36,y
      1  07a2		       99 6c fa 	      sta	[RAM]+ChessBitmap+PIECE_SHAPE_SIZE+36,y
    846  07a5
    847  07a5		       b9 dd 00    .blank3    lda	__pieceShapeBuffer+54,y
    848  07a8		       f0 06		      beq	.blank4
    849  07aa		       59 7e f8 	      eor	ChessBitmap+PIECE_SHAPE_SIZE+54,y
      0  07ad					      sta@RAM	ChessBitmap+PIECE_SHAPE_SIZE+54,y
      1  07ad		       99 7e fa 	      sta	[RAM]+ChessBitmap+PIECE_SHAPE_SIZE+54,y
    851  07b0
    852  07b0		       88	   .blank4    dey
    853  07b1		       10 d1		      bpl	.copyPieceR
    854  07b3		       60		      rts
    855  07b4
    856  07b4
    857  07b4							;---------------------------------------------------------------------------------------------------
    858  07b4
      0  07b4					      DEF	EnPassantRemoveCapturedPawn
      1  07b4				   SLOT_EnPassantRemoveCapturedPawn SET	_BANK_SLOT
      2  07b4				   BANK_EnPassantRemoveCapturedPawn SET	SLOT_EnPassantRemoveCapturedPawn + _CURRENT_BANK
      3  07b4				   EnPassantRemoveCapturedPawn
      4  07b4				   TEMPORARY_VAR SET	Overlay
      5  07b4				   TEMPORARY_OFFSET SET	0
      6  07b4				   VAR_BOUNDARY_EnPassantRemoveCapturedPawn SET	TEMPORARY_OFFSET
      7  07b4				   FUNCTION_NAME SET	EnPassantRemoveCapturedPawn
    860  07b4					      SUBROUTINE
    861  07b4
      0  07b4					      REF	aiSpecialMoveFixup
      1  07b4					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  07b4				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  07b4					      ENDIF
      0  07b4					      VEND	EnPassantRemoveCapturedPawn
      1  07b4
      2  07b4
      3  07b4		       00 b5	   VAREND_EnPassantRemoveCapturedPawn =	TEMPORARY_VAR
      4  07b4
    864  07b4
    865  07b4		       a4 93		      ldy	enPassantPawn
    866  07b6		       f0 27		      beq	.exit
    867  07b8
    868  07b8
    869  07b8		       a9 d0		      lda	#RAMBANK_BOARD
    870  07ba		       85 3e		      sta	SET_BANK_RAM	;@3
    871  07bc
    872  07bc							; Account for the opponent pawn being removed
    873  07bc							; Effectively ADD the values to our current score
    874  07bc
    875  07bc		       a5 95		      lda	sideToMove
    876  07be		       49 80		      eor	#128
    877  07c0		       29 80		      and	#128
    878  07c2		       09 01		      ora	#WP	; == BP in this usage
    879  07c4
    880  07c4		       a2 89		      ldx	#BANK_AddPiecePositionValue
    881  07c6		       86 3f		      stx	SET_BANK	;@2
    882  07c8		       20 60 f9 	      jsr	AddPiecePositionValue	; remove pos value for original position
    883  07cb
    884  07cb		       a9 01		      lda	#WP	; == BP
    885  07cd		       a2 89		      ldx	#BANK_AddPieceMaterialValue
    886  07cf		       86 3f		      stx	SET_BANK	;@2
    887  07d1		       20 3d f9 	      jsr	AddPieceMaterialValue	; remove material for original type
    888  07d4
    889  07d4		       a9 d0		      lda	#RAMBANK_BOARD
    890  07d6		       85 3e		      sta	SET_BANK_RAM	;@3
    891  07d8
    892  07d8		       a6 93		      ldx	enPassantPawn
    893  07da		       a9 00		      lda	#0
      0  07dc					      sta@RAM	Board,x
      1  07dc		       9d 79 fe 	      sta	[RAM]+Board,x
    895  07df
    896  07df
    897  07df		       60	   .exit      rts
    898  07e0
    899  07e0
    900  07e0							;---------------------------------------------------------------------------------------------------
    901  07e0
      0  07e0					      END_BANK
      1  07e0				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  07e0				  -	      CHECK_RAM_BANK_SIZE
      3  07e0					      ELSE
      0  07e0					      CHECK_BANK_SIZE
      1  07e0		       03 e0	   .TEMP      =	* - _BANK_START
 ROM bank # 2 LOCKED_BANK size = $3e0 free = 31
      2  07e0					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  07e0				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  07e0				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  07e0				  -	      ERR
      6  07e0					      ENDIF
      5  07e0					      ENDIF
    903  07e0
    904  07e0							;---------------------------------------------------------------------------------------------------
    905  07e0							; EOF
------- FILE ./chess.asm
    183  07e0
------- FILE @1 GENERIC #1.asm LEVEL 2 PASS 4
      0  07e0					      include	"@1 GENERIC #1.asm"
      1  07e0							;---------------------------------------------------------------------------------------------------
      2  07e0							; @1 GENERIC #1.asm
      3  07e0
      4  07e0							; Atari 2600 Chess
      5  07e0							; Copyright (c) 2019-2020 Andrew Davie
      6  07e0							; andrew@taswegian.com
      7  07e0
      8  07e0							;---------------------------------------------------------------------------------------------------
      9  07e0
      0  07e0					      SLOT	1	; which bank this code switches to
      1  07e0
      2  07e0				  -	      IF	(1 < 0) || (1 > 3)
      3  07e0				  -	      ECHO	"Illegal bank address/segment location", 1
      4  07e0				  -	      ERR
      5  07e0					      ENDIF
      6  07e0
      7  07e0				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  07e0				   _BANK_SLOT SET	1 * 64
      9  07e0
      0  07e0					      ROMBANK	ONE
      1  0a4b ????				      SEG	ROM_ONE
      2  0800					      ORG	_ORIGIN
      3  0800					      RORG	_BANK_ADDRESS_ORIGIN
      4  0800				   _BANK_START SET	*
      5  0800				   ONE_START  SET	*
      6  0800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  0800				   ROMBANK_ONE SET	_BANK_SLOT + _CURRENT_BANK
      8  0800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  0800				   _LAST_BANK SETSTR	ONE
     10  0800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     12  0800
     13  0800
     14  0800							;---------------------------------------------------------------------------------------------------
     15  0800
      0  0800					      DEF	CartInit
      1  0800				   SLOT_CartInit SET	_BANK_SLOT
      2  0800				   BANK_CartInit SET	SLOT_CartInit + _CURRENT_BANK
      3  0800				   CartInit
      4  0800				   TEMPORARY_VAR SET	Overlay
      5  0800				   TEMPORARY_OFFSET SET	0
      6  0800				   VAR_BOUNDARY_CartInit SET	TEMPORARY_OFFSET
      7  0800				   FUNCTION_NAME SET	CartInit
     17  0800					      SUBROUTINE
     18  0800
      0  0800					      REF	StartupBankReset	;✅
      1  0800				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0800				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0800					      ENDIF
     20  0800
      0  0800					      VEND	CartInit
      1  0800
      2  0800
      3  0800		       00 a7	   VAREND_CartInit =	TEMPORARY_VAR
      4  0800
     22  0800
     23  0800
     24  0800							; See if we can come up with something 'random' for startup
     25  0800
     26  0800		       ac 84 02 	      ldy	INTIM
     27  0803		       d0 02		      bne	.toR
     28  0805		       a0 9a		      ldy	#$9A
     29  0807		       84 81	   .toR       sty	rnd
     30  0809
     31  0809		       a9 1f		      lda	#31
     32  080b		       85 a1		      sta	randomness
     33  080d
     34  080d		       a9 00		      lda	#0
     35  080f		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     36  0812		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     37  0815		       85 6b		      sta	HMCLR
     38  0817
     39  0817		       85 5b		      sta	GRP0
     40  0819		       85 5c		      sta	GRP1
     41  081b		       85 5d		      sta	ENAM0
     42  081d		       85 5e		      sta	ENAM1
     43  081f		       85 5f		      sta	ENABL
     44  0821
     45  0821							; cleanup remains of title screen
     46  0821							;sta GRP0
     47  0821							;sta GRP1
     48  0821
     49  0821		       a9 07		      lda	#%111
     50  0823		       85 44		      sta	NUSIZ0
     51  0825		       85 45		      sta	NUSIZ1	; quad-width
     52  0827
     53  0827							;lda #%00000100
     54  0827							;sta CTRLPF
     55  0827		       a9 00		      lda	#BACKGCOL
     56  0829		       85 49		      sta	COLUBK
     57  082b
     58  082b
     59  082b		       a9 40		      lda	#WHITE|HUMAN
     60  082d		       85 95		      sta	sideToMove
     61  082f
     62  082f		       60		      rts
     63  0830
     64  0830
     65  0830							;---------------------------------------------------------------------------------------------------
     66  0830
      0  0830					      DEF	SetupBanks
      1  0830				   SLOT_SetupBanks SET	_BANK_SLOT
      2  0830				   BANK_SetupBanks SET	SLOT_SetupBanks + _CURRENT_BANK
      3  0830				   SetupBanks
      4  0830				   TEMPORARY_VAR SET	Overlay
      5  0830				   TEMPORARY_OFFSET SET	0
      6  0830				   VAR_BOUNDARY_SetupBanks SET	TEMPORARY_OFFSET
      7  0830				   FUNCTION_NAME SET	SetupBanks
     68  0830					      SUBROUTINE
     69  0830
     70  0830							; Move a copy of the row bank template to the first 8 banks of RAM
     71  0830							; and then terminate the draw subroutine by substituting in a RTS on the last one
     72  0830
      0  0830					      REF	StartupBankReset	;✅
      1  0830				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0830				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0830					      ENDIF
      0  0830					      VEND	SetupBanks
      1  0830
      2  0830
      3  0830		       00 a7	   VAREND_SetupBanks =	TEMPORARY_VAR
      4  0830
     75  0830
     76  0830							; Copy the bitmap shadow into the first 8 RAM banks via x(SLOT3)-->y(SLOT2)
     77  0830
     78  0830				   .ROWBANK   SET	0
     79  0830					      REPEAT	8
     80  0830		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     81  0832		       a0 c0		      ldy	#[SLOT3] + .ROWBANK
     82  0834		       20 79 f4 	      jsr	CopyShadowROMtoRAM
     83  0834				   .ROWBANK   SET	.ROWBANK+1
     79  0834					      REPEND
     80  0837		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     81  0839		       a0 c1		      ldy	#[SLOT3] + .ROWBANK
     82  083b		       20 79 f4 	      jsr	CopyShadowROMtoRAM
     83  083b				   .ROWBANK   SET	.ROWBANK+1
     79  083b					      REPEND
     80  083e		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     81  0840		       a0 c2		      ldy	#[SLOT3] + .ROWBANK
     82  0842		       20 79 f4 	      jsr	CopyShadowROMtoRAM
     83  0842				   .ROWBANK   SET	.ROWBANK+1
     79  0842					      REPEND
     80  0845		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     81  0847		       a0 c3		      ldy	#[SLOT3] + .ROWBANK
     82  0849		       20 79 f4 	      jsr	CopyShadowROMtoRAM
     83  0849				   .ROWBANK   SET	.ROWBANK+1
     79  0849					      REPEND
     80  084c		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     81  084e		       a0 c4		      ldy	#[SLOT3] + .ROWBANK
     82  0850		       20 79 f4 	      jsr	CopyShadowROMtoRAM
     83  0850				   .ROWBANK   SET	.ROWBANK+1
     79  0850					      REPEND
     80  0853		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     81  0855		       a0 c5		      ldy	#[SLOT3] + .ROWBANK
     82  0857		       20 79 f4 	      jsr	CopyShadowROMtoRAM
     83  0857				   .ROWBANK   SET	.ROWBANK+1
     79  0857					      REPEND
     80  085a		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     81  085c		       a0 c6		      ldy	#[SLOT3] + .ROWBANK
     82  085e		       20 79 f4 	      jsr	CopyShadowROMtoRAM
     83  085e				   .ROWBANK   SET	.ROWBANK+1
     79  085e					      REPEND
     80  0861		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     81  0863		       a0 c7		      ldy	#[SLOT3] + .ROWBANK
     82  0865		       20 79 f4 	      jsr	CopyShadowROMtoRAM
     83  0865				   .ROWBANK   SET	.ROWBANK+1
     84  0868					      REPEND
     85  0868
     86  0868
     87  0868							; Patch the final row's "loop" to a RTS
     88  0868
     89  0868		       a2 87		      ldx	#[SLOT2] + 7	; last ROW BITMAP bank
     90  086a		       86 3e		      stx	SET_BANK_RAM
     91  086c		       a9 60		      lda	#$60	; "rts"
      0  086e					      sta@RAM	SELFMOD_RTS_ON_LAST_ROW
      1  086e		       8d a0 fa 	      sta	[RAM]+SELFMOD_RTS_ON_LAST_ROW
     93  0871
     94  0871
     95  0871
     96  0871							; copy the BOARD/MOVES bank
     97  0871
     98  0871		       a2 9b		      ldx	#ROMBANK_SHADOW_BOARD
     99  0873		       a0 d0		      ldy	#RAMBANK_BOARD
    100  0875		       20 79 f4 	      jsr	CopyShadowROMtoRAM	; this auto-initialises Board too
    101  0878
    102  0878
    103  0878							; copy the PLY banks
    104  0878							; If there's no content (only variable decs) then we don't really need to do this.
    105  0878
    106  0878							;.PLY SET 0
    107  0878							;    REPEAT PLY_BANKS
    108  0878
    109  0878							;		      ldx #SHADOW_PLY
    110  0878							;		      ldy #RAMBANK_PLY + .PLY
    111  0878							;jsr CopyShadowROMtoRAM
    112  0878							;.PLY SET .PLY + 1
    113  0878							;    REPEND
    114  0878
    115  0878							; copy the evaluation code/tables
    116  0878							; 3E+ moved from RAM to ROM
    117  0878
    118  0878							;		      ldx #[SLOT2] + SHADOW_EVAL
    119  0878							;		      ldy #[SLOT3] + EVAL
    120  0878							;		      jsr CopyShadowROMtoRAM
    121  0878
    122  0878
    123  0878							;		      ldy #RAMBANK_RAM_PIECELIST
    124  0878							;		      ldx #ROM_PIECELIST
    125  0878							;		      jsr CopyShadowROMtoRAM
    126  0878
    127  0878		       60		      rts
    128  0879
    129  0879
    130  0879							;---------------------------------------------------------------------------------------------------
    131  0879
      0  0879					      DEF	CopyShadowROMtoRAM
      1  0879				   SLOT_CopyShadowROMtoRAM SET	_BANK_SLOT
      2  0879				   BANK_CopyShadowROMtoRAM SET	SLOT_CopyShadowROMtoRAM + _CURRENT_BANK
      3  0879				   CopyShadowROMtoRAM
      4  0879				   TEMPORARY_VAR SET	Overlay
      5  0879				   TEMPORARY_OFFSET SET	0
      6  0879				   VAR_BOUNDARY_CopyShadowROMtoRAM SET	TEMPORARY_OFFSET
      7  0879				   FUNCTION_NAME SET	CopyShadowROMtoRAM
    133  0879					      SUBROUTINE
    134  0879
      0  0879					      REF	SetupBanks	;✅
      1  0879				  -	      IF	VAREND_SetupBanks > TEMPORARY_VAR
      2  0879				  -TEMPORARY_VAR SET	VAREND_SetupBanks
      3  0879					      ENDIF
    136  0879
      0  0879					      VEND	CopyShadowROMtoRAM
      1  0879
      2  0879
      3  0879		       00 a7	   VAREND_CopyShadowROMtoRAM =	TEMPORARY_VAR
      4  0879
    138  0879
    139  0879							; Copy a whole ROM SHADOW into a destination RAM 512 byte bank
    140  0879							; used to setup callable RAM code from ROM templates
    141  0879
    142  0879							; x = source ROM bank
    143  0879							; y = destination RAM bank (preserved)
    144  0879
    145  0879		       86 3f		      stx	SET_BANK
    146  087b		       84 3e		      sty	SET_BANK_RAM
    147  087d
    148  087d		       a2 00		      ldx	#0
    149  087f		       bd 00 f8    .copyPage  lda	$F800,x
      0  0882					      sta@RAM	$FC00,x
      1  0882		       9d 00 fe 	      sta	[RAM]+$FC00,x
    151  0885		       bd 00 f9 	      lda	$F900,x
      0  0888					      sta@RAM	$FD00,x
      1  0888		       9d 00 ff 	      sta	[RAM]+$FD00,x
    153  088b		       ca		      dex
    154  088c		       d0 f1		      bne	.copyPage
    155  088e		       60		      rts
    156  088f
    157  088f
    158  088f							;---------------------------------------------------------------------------------------------------
    159  088f
      0  088f					      DEF	InitialisePieceSquares
      1  088f				   SLOT_InitialisePieceSquares SET	_BANK_SLOT
      2  088f				   BANK_InitialisePieceSquares SET	SLOT_InitialisePieceSquares + _CURRENT_BANK
      3  088f				   InitialisePieceSquares
      4  088f				   TEMPORARY_VAR SET	Overlay
      5  088f				   TEMPORARY_OFFSET SET	0
      6  088f				   VAR_BOUNDARY_InitialisePieceSquares SET	TEMPORARY_OFFSET
      7  088f				   FUNCTION_NAME SET	InitialisePieceSquares
    161  088f					      SUBROUTINE
    162  088f
      0  088f					      REF	COMMON_VARS
      1  088f					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  088f				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  088f					      ENDIF
      0  088f					      REF	StartupBankReset	;✅
      1  088f				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  088f				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  088f					      ENDIF
    165  088f
      0  088f					      VAR	__initPiece, 1
      1  088f
      2  088f		       00 b5	   __initPiece =	TEMPORARY_VAR
      3  088f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  088f
      5  088f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  088f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  088f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  088f					      ENDIF
      9  088f				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  088f				  -	      LIST	ON
     11  088f				  -VNAME      SETSTR	__initPiece
     12  088f				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  088f				  -	      ERR
     14  088f				  -	      ECHO	"Temporary Variable overlow!"
     15  088f					      ENDIF
     16  088f					      LIST	ON
      0  088f					      VAR	__initSquare, 1
      1  088f
      2  088f		       00 b6	   __initSquare =	TEMPORARY_VAR
      3  088f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  088f
      5  088f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  088f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  088f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  088f					      ENDIF
      9  088f				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  088f				  -	      LIST	ON
     11  088f				  -VNAME      SETSTR	__initSquare
     12  088f				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  088f				  -	      ERR
     14  088f				  -	      ECHO	"Temporary Variable overlow!"
     15  088f					      ENDIF
     16  088f					      LIST	ON
      0  088f					      VAR	__initListPtr, 1
      1  088f
      2  088f		       00 b7	   __initListPtr =	TEMPORARY_VAR
      3  088f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  088f
      5  088f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  088f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  088f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  088f					      ENDIF
      9  088f				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  088f				  -	      LIST	ON
     11  088f				  -VNAME      SETSTR	__initListPtr
     12  088f				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  088f				  -	      ERR
     14  088f				  -	      ECHO	"Temporary Variable overlow!"
     15  088f					      ENDIF
     16  088f					      LIST	ON
      0  088f					      VAR	__op, 1
      1  088f
      2  088f		       00 b8	   __op       =	TEMPORARY_VAR
      3  088f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  088f
      5  088f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  088f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  088f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  088f					      ENDIF
      9  088f				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  088f				  -	      LIST	ON
     11  088f				  -VNAME      SETSTR	__op
     12  088f				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  088f				  -	      ERR
     14  088f				  -	      ECHO	"Temporary Variable overlow!"
     15  088f					      ENDIF
     16  088f					      LIST	ON
    170  088f
      0  088f					      VEND	InitialisePieceSquares
      1  088f
      2  088f
      3  088f		       00 b9	   VAREND_InitialisePieceSquares =	TEMPORARY_VAR
      4  088f
    172  088f
    173  088f		       a9 00		      lda	#0
    174  0891		       85 8f		      sta	Evaluation
    175  0893		       85 90		      sta	Evaluation+1	; tracks CURRENT value of everything (signed 16-bit)
    176  0895		       85 93		      sta	enPassantPawn	; no en-passant
    177  0897
    178  0897
      0  0897					      PHASE	StartClearBoard
      1  0897		       a9 0d		      lda	#AI_StartClearBoard
      2  0899		       85 8b		      sta	aiState
    180  089b
    181  089b		       a2 00		      ldx	#0
    182  089d				   .fillPieceLists
    183  089d
    184  089d
    185  089d		       bd ef f4 	      lda	InitPieceList,x	; colour/-1
    186  08a0		       f0 4c		      beq	.exit
    187  08a2		       85 b8		      sta	__op	; type
    188  08a4		       bc f0 f4 	      ldy	InitPieceList+1,x	; square
    189  08a7		       84 b6		      sty	__initSquare
    190  08a9
    191  08a9		       a9 d0		      lda	#RAMBANK_BOARD
    192  08ab		       85 3e		      sta	SET_BANK_RAM
    193  08ad		       a5 b8		      lda	__op
      0  08af					      sta@RAM	Board,y
      1  08af		       99 79 fe 	      sta	[RAM]+Board,y
    195  08b2		       10 0d		      bpl	.white
    196  08b4
      0  08b4					      NEGEVAL
      1  08b4
      2  08b4		       38		      sec
      3  08b5		       a9 00		      lda	#0
      4  08b7		       e5 8f		      sbc	Evaluation
      5  08b9		       85 8f		      sta	Evaluation
      6  08bb		       a9 00		      lda	#0
      7  08bd		       e5 90		      sbc	Evaluation+1
      8  08bf		       85 90		      sta	Evaluation+1
      9  08c1
    198  08c1				   .white
    199  08c1
    200  08c1		       86 b7		      stx	__initListPtr
    201  08c3
    202  08c3							; Add the material value of the piece to the evaluation
    203  08c3
    204  08c3		       a5 b8		      lda	__op
    205  08c5		       a2 89		      ldx	#BANK_AddPieceMaterialValue
    206  08c7		       86 3f		      stx	SET_BANK	;@2
    207  08c9		       20 3d f9 	      jsr	AddPieceMaterialValue
    208  08cc
    209  08cc
    210  08cc							; add the positional value of the piece to the evaluation
    211  08cc
    212  08cc		       a4 b6		      ldy	__initSquare
    213  08ce		       a5 b8		      lda	__op
    214  08d0		       a2 89		      ldx	#BANK_AddPiecePositionValue
    215  08d2		       86 3f		      stx	SET_BANK
    216  08d4		       20 60 f9 	      jsr	AddPiecePositionValue
    217  08d7
    218  08d7		       a5 b8		      lda	__op	; type/colour
    219  08d9		       10 0d		      bpl	.white2
      0  08db					      NEGEVAL
      1  08db
      2  08db		       38		      sec
      3  08dc		       a9 00		      lda	#0
      4  08de		       e5 8f		      sbc	Evaluation
      5  08e0		       85 8f		      sta	Evaluation
      6  08e2		       a9 00		      lda	#0
      7  08e4		       e5 90		      sbc	Evaluation+1
      8  08e6		       85 90		      sta	Evaluation+1
      9  08e8
    221  08e8				   .white2
    222  08e8
    223  08e8		       a6 b7		      ldx	__initListPtr
    224  08ea		       e8		      inx
    225  08eb		       e8		      inx
    226  08ec		       10 af		      bpl	.fillPieceLists
    227  08ee
    228  08ee				   .exit
    229  08ee		       60		      rts
    230  08ef
    231  08ef
    232  08ef				   InitPieceList
    233  08ef
    234  08ef
    235  08ef					      IF	!TEST_POSITION
    236  08ef
    237  08ef		       06 19		      .byte.b	WHITE|Q, 25
    238  08f1		       04 18		      .byte.b	WHITE|B, 24
    239  08f3		       04 1b		      .byte.b	WHITE|B, 27
    240  08f5		       05 16		      .byte.b	WHITE|R, 22
    241  08f7		       05 1d		      .byte.b	WHITE|R, 29
    242  08f9		       03 17		      .byte.b	WHITE|N, 23
    243  08fb		       03 1c		      .byte.b	WHITE|N, 28
    244  08fd
    245  08fd		       01 23		      .byte.b	WHITE|WP, 35
    246  08ff		       01 24		      .byte.b	WHITE|WP, 36
    247  0901		       01 22		      .byte.b	WHITE|WP, 34
    248  0903		       01 25		      .byte.b	WHITE|WP, 37
    249  0905		       01 21		      .byte.b	WHITE|WP, 33
    250  0907		       01 26		      .byte.b	WHITE|WP, 38
    251  0909		       01 20		      .byte.b	WHITE|WP, 32
    252  090b		       01 27		      .byte.b	WHITE|WP, 39
    253  090d
    254  090d		       07 1a		      .byte.b	WHITE|K, 26
    255  090f
    256  090f		       86 5f		      .byte.b	BLACK|Q, 95
    257  0911		       84 5e		      .byte.b	BLACK|B, 94
    258  0913		       84 61		      .byte.b	BLACK|B, 97
    259  0915		       85 5c		      .byte.b	BLACK|R, 92
    260  0917		       85 63		      .byte.b	BLACK|R, 99
    261  0919		       83 5d		      .byte.b	BLACK|N, 93
    262  091b		       83 62		      .byte.b	BLACK|N, 98
    263  091d
    264  091d		       82 55		      .byte.b	BLACK|BP, 85
    265  091f		       82 56		      .byte.b	BLACK|BP, 86
    266  0921		       82 54		      .byte.b	BLACK|BP, 84
    267  0923		       82 57		      .byte.b	BLACK|BP, 87
    268  0925		       82 53		      .byte.b	BLACK|BP, 83
    269  0927		       82 58		      .byte.b	BLACK|BP, 88
    270  0929		       82 52		      .byte.b	BLACK|BP, 82
    271  092b		       82 59		      .byte.b	BLACK|BP, 89
    272  092d
    273  092d		       87 60		      .byte.b	BLACK|K, 96
    274  092f
    275  092f		       00		      .byte.b	0	;end
    276  0930
    277  0930				  -	      ELSE		; test position...
    278  0930				  -
    279  0930				  -	      IF	0
    280  0930				  -			; make sure illegal moves leaving K in check are removed
    281  0930				  -
    282  0930				  -	      .byte	WHITE|N, 28
    283  0930				  -	      .byte	WHITE|K, 26
    284  0930				  -
    285  0930				  -	      .byte	BLACK|Q, 29
    286  0930				  -
    287  0930				  -	      .byte	0	;end
    288  0930				  -
    289  0930				  -	      ENDIF
    290  0930				  -
    291  0930				  -	      IF	0
    292  0930				  -
    293  0930				  -	      .byte	WHITE|K, 28
    294  0930				  -	      .byte	WHITE|WP, 37
    295  0930				  -	      .byte	WHITE|WP, 38
    296  0930				  -	      .byte	WHITE|WP, 53
    297  0930				  -	      .byte	WHITE|WP, 49
    298  0930				  -	      .byte	WHITE|WP, 32
    299  0930				  -	      .byte	WHITE|R, 27
    300  0930				  -	      .byte	WHITE|B, 46
    301  0930				  -	      .byte	WHITE|R, 54
    302  0930				  -
    303  0930				  -	      .byte	BLACK|BP, 56
    304  0930				  -	      .byte	BLACK|BP, 87
    305  0930				  -	      .byte	BLACK|BP, 88
    306  0930				  -	      .byte	BLACK|BP, 89
    307  0930				  -	      .byte	BLACK|BP, 84
    308  0930				  -	      .byte	BLACK|B, 66
    309  0930				  -	      .byte	BLACK|R, 69
    310  0930				  -	      .byte	BLACK|K, 98
    311  0930				  -
    312  0930				  -	      .byte	BLACK|R, 92
    313  0930				  -
    314  0930				  -
    315  0930				  -
    316  0930				  -	      ENDIF
    317  0930				  -
    318  0930				  -	      IF	TEST_POSITION & 0
    319  0930				  -			; Castling across/into check
    320  0930				  -			; pawn promotion
    321  0930				  -
    322  0930				  -	      .byte	WHITE|K, 26
    323  0930				  -	      .byte	WHITE|R, 29
    324  0930				  -	      .byte	BLACK|B, 45
    325  0930				  -	      .byte	WHITE|Q, 72
    326  0930				  -	      .byte	BLACK|N, 84
    327  0930				  -	      .byte	WHITE|WP,89
    328  0930				  -
    329  0930				  -	      ENDIF
    330  0930				  -
    331  0930				  -
    332  0930				  -
    333  0930				  -	      IF	TEST_POSITION & 0
    334  0930				  -			; En passant test
    335  0930				  -
    336  0930				  -	      .byte	BLACK|BP, 88
    337  0930				  -	      .byte	BLACK|BP, 86
    338  0930				  -
    339  0930				  -	      .byte	WHITE|WP|FLAG_MOVED, 67
    340  0930				  -	      .byte	WHITE|K, 52
    341  0930				  -
    342  0930				  -
    343  0930				  -	      ENDIF
    344  0930				  -
    345  0930				  -	      IF	TEST_POSITION & 0
    346  0930				  -			; En passant test (white)
    347  0930				  -
    348  0930				  -	      .byte	BLACK|BP|FLAG_MOVED, 53
    349  0930				  -
    350  0930				  -	      .byte	WHITE|WP, 34
    351  0930				  -	      .byte	WHITE|K, 52
    352  0930				  -
    353  0930				  -
    354  0930				  -	      .byte	BLACK|BP, 88
    355  0930				  -	      .byte	WHITE|WP|FLAG_MOVED, 67
    356  0930				  -
    357  0930				  -
    358  0930				  -	      ENDIF
    359  0930				  -
    360  0930				  -
    361  0930				  -	      IF	TEST_POSITION & 1
    362  0930				  -			; castle
    363  0930				  -
    364  0930				  -	      .byte	BLACK|R, 99
    365  0930				  -	      .byte	BLACK|K, 96
    366  0930				  -	      .byte	BLACK|BP, 89
    367  0930				  -
    368  0930				  -	      .byte	WHITE|WP, 37
    369  0930				  -	      .byte	WHITE|WP, 38
    370  0930				  -	      .byte	WHITE|WP, 39
    371  0930				  -	      .byte	WHITE|R,29
    372  0930				  -	      .byte	WHITE|K, 26
    373  0930				  -
    374  0930				  -	      ENDIF
    375  0930				  -
    376  0930				  -
    377  0930				  -
    378  0930				  -
    379  0930				  -	      IF	TEST_POSITION & 0
    380  0930				  -			; promote test
    381  0930				  -
    382  0930				  -	      .byte	BLACK|K, 22
    383  0930				  -	      .byte	BLACK|N, 96
    384  0930				  -
    385  0930				  -	      .byte	WHITE|WP, 87
    386  0930				  -	      .byte	WHITE|R,95
    387  0930				  -	      .byte	WHITE|R,94
    388  0930				  -	      .byte	WHITE|K, 52
    389  0930				  -
    390  0930				  -
    391  0930				  -	      ENDIF
    392  0930				  -
    393  0930				  -
    394  0930				  -
    395  0930				  -	      IF	0
    396  0930				  -
    397  0930				  -
    398  0930				  -			;.byte BLACK|R, 97
    399  0930				  -	      .byte	BLACK|K, 98
    400  0930				  -	      .byte	BLACK|BP, 87
    401  0930				  -	      .byte	BLACK|BP, 88
    402  0930				  -	      .byte	BLACK|BP, 89
    403  0930				  -			;    .byte BLACK|B, 76
    404  0930				  -
    405  0930				  -
    406  0930				  -	      .byte	WHITE|R,28
    407  0930				  -	      .byte	WHITE|Q,58
    408  0930				  -			;   .byte WHITE|N,65
    409  0930				  -	      ENDIF
    410  0930				  -
    411  0930				  -	      IF	0
    412  0930				  -			;.byte WHITE|WP, 56
    413  0930				  -
    414  0930				  -
    415  0930				  -	      .byte	BLACK|K, 98
    416  0930				  -
    417  0930				  -
    418  0930				  -	      .byte	WHITE|R,29
    419  0930				  -	      .byte	WHITE|Q,49
    420  0930				  -	      .byte	WHITE|N,65
    421  0930				  -	      ENDIF
    422  0930				  -	      .byte	0	;end
    423  0930				  -
    424  0930					      ENDIF
    425  0930
    426  0930
    427  0930							;---------------------------------------------------------------------------------------------------
    428  0930
      0  0930					      DEF	AddMoveSimple
      1  0930				   SLOT_AddMoveSimple SET	_BANK_SLOT
      2  0930				   BANK_AddMoveSimple SET	SLOT_AddMoveSimple + _CURRENT_BANK
      3  0930				   AddMoveSimple
      4  0930				   TEMPORARY_VAR SET	Overlay
      5  0930				   TEMPORARY_OFFSET SET	0
      6  0930				   VAR_BOUNDARY_AddMoveSimple SET	TEMPORARY_OFFSET
      7  0930				   FUNCTION_NAME SET	AddMoveSimple
    430  0930					      SUBROUTINE
    431  0930
      0  0930					      VEND	AddMoveSimple
      1  0930
      2  0930
      3  0930		       00 a7	   VAREND_AddMoveSimple =	TEMPORARY_VAR
      4  0930
    433  0930
    434  0930							; add square in y register to movelist as destination (X12 format)
    435  0930							; [y]		     to square (X12)
    436  0930							; currentSquare     from square (X12)
    437  0930							; currentPiece      piece.
    438  0930							;   ENPASSANT flag set if pawn double-moving off opening rank
    439  0930							; capture	     captured piece
    440  0930
    441  0930		       a5 9b		      lda	capture
    442  0932		       d0 04		      bne	.always
    443  0934		       a5 b2		      lda	__quiesceCapOnly
    444  0936		       d0 1a		      bne	.abort
    445  0938
    446  0938		       98	   .always    tya
    447  0939
      0  0939					      ldy@PLY	moveIndex
      1  0939		       ac cf f9 	      ldy	moveIndex
    449  093c		       c8		      iny
      0  093d					      sty@PLY	moveIndex
      1  093d		       8c cf fb 	      sty	[RAM]+moveIndex
    451  0940
      0  0940					      sta@PLY	MoveTo,y
      1  0940		       99 64 fa 	      sta	[RAM]+MoveTo,y
    453  0943		       a5 92		      lda	currentSquare
      0  0945					      sta@PLY	MoveFrom,y
      1  0945		       99 00 fa 	      sta	[RAM]+MoveFrom,y
    455  0948		       a5 91		      lda	currentPiece
      0  094a					      sta@PLY	MovePiece,y
      1  094a		       99 00 fb 	      sta	[RAM]+MovePiece,y
    457  094d		       a5 9b		      lda	capture
      0  094f					      sta@PLY	MoveCapture,y
      1  094f		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    459  0952
    460  0952		       60	   .abort     rts
    461  0953
    462  0953
    463  0953							;---------------------------------------------------------------------------------------------------
    464  0953
      0  0953					      DEF	aiSpecialMoveFixup
      1  0953				   SLOT_aiSpecialMoveFixup SET	_BANK_SLOT
      2  0953				   BANK_aiSpecialMoveFixup SET	SLOT_aiSpecialMoveFixup + _CURRENT_BANK
      3  0953				   aiSpecialMoveFixup
      4  0953				   TEMPORARY_VAR SET	Overlay
      5  0953				   TEMPORARY_OFFSET SET	0
      6  0953				   VAR_BOUNDARY_aiSpecialMoveFixup SET	TEMPORARY_OFFSET
      7  0953				   FUNCTION_NAME SET	aiSpecialMoveFixup
    466  0953					      SUBROUTINE
    467  0953
      0  0953					      REF	COMMON_VARS
      1  0953					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0953				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0953					      ENDIF
      0  0953					      REF	AiStateMachine	;✅
      1  0953				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0953				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0953					      ENDIF
      0  0953					      VEND	aiSpecialMoveFixup
      1  0953
      2  0953
      3  0953		       00 b5	   VAREND_aiSpecialMoveFixup =	TEMPORARY_VAR
      4  0953
    471  0953
    472  0953		       ad 84 02 	      lda	INTIM
    473  0956		       c9 2d		      cmp	#SPEEDOF_CopySinglePiece+4
    474  0958		       b0 01		      bcs	.cont
    475  095a		       60		      rts
    476  095b
    477  095b
    478  095b				   .cont
    479  095b
      0  095b					      PHASE	DelayAfterPlaced
      1  095b		       a9 27		      lda	#AI_DelayAfterPlaced
      2  095d		       85 8b		      sta	aiState
    481  095f
    482  095f
    483  095f							; Special move fixup
    484  095f
    485  095f		       a5 94		      lda	currentPly
    486  0961		       85 3e		      sta	SET_BANK_RAM
    487  0963
    488  0963		       20 94 f5 	      jsr	CastleFixupDraw
    489  0966
    490  0966		       a5 85		      lda	fromX12
    491  0968		       85 80		      sta	squareToDraw
    492  096a
    493  096a		       60		      rts
    494  096b
    495  096b
    496  096b							;---------------------------------------------------------------------------------------------------
    497  096b
      0  096b					      DEF	aiEPFlash
      1  096b				   SLOT_aiEPFlash SET	_BANK_SLOT
      2  096b				   BANK_aiEPFlash SET	SLOT_aiEPFlash + _CURRENT_BANK
      3  096b				   aiEPFlash
      4  096b				   TEMPORARY_VAR SET	Overlay
      5  096b				   TEMPORARY_OFFSET SET	0
      6  096b				   VAR_BOUNDARY_aiEPFlash SET	TEMPORARY_OFFSET
      7  096b				   FUNCTION_NAME SET	aiEPFlash
    499  096b					      SUBROUTINE
    500  096b
      0  096b					      REF	Variable_PieceShapeBuffer
      1  096b					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  096b				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  096b					      ENDIF
      0  096b					      REF	AiStateMachine
      1  096b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  096b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  096b					      ENDIF
      0  096b					      VEND	aiEPFlash
      1  096b
      2  096b
      3  096b		       00 ef	   VAREND_aiEPFlash =	TEMPORARY_VAR
      4  096b
    504  096b
    505  096b		       a5 82		      lda	drawDelay
    506  096d		       f0 03		      beq	.deCount
    507  096f		       c6 82		      dec	drawDelay
    508  0971		       60		      rts
    509  0972
    510  0972		       a5 84	   .deCount   lda	drawCount
    511  0974		       f0 0e		      beq	.flashDone2
    512  0976		       c6 84		      dec	drawCount
    513  0978
    514  0978		       a9 0a		      lda	#10
    515  097a		       85 82		      sta	drawDelay	; "getting ready to move" flash
    516  097c
    517  097c		       a5 93		      lda	enPassantPawn
    518  097e		       85 80		      sta	squareToDraw
    519  0980
    520  0980							; WARNING - local variables will not survive the following call...!
    521  0980		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    522  0983		       60		      rts
    523  0984
    524  0984				   .flashDone2
    525  0984
    526  0984
    527  0984		       a9 00		      lda	#0	; on/off count
    528  0986		       85 84		      sta	drawCount	; flashing for piece about to move
    529  0988		       a9 00		      lda	#0
    530  098a		       85 82		      sta	drawDelay
    531  098c
    532  098c		       20 b4 f3 	      jsr	EnPassantRemoveCapturedPawn
    533  098f
    534  098f							;lda #100
    535  098f							;sta aiFlashDelay ;???
    536  098f
      0  098f					      PHASE	FinalFlash
      1  098f		       a9 1b		      lda	#AI_FinalFlash
      2  0991		       85 8b		      sta	aiState
    538  0993		       60		      rts
    539  0994
    540  0994
    541  0994							;---------------------------------------------------------------------------------------------------
    542  0994
      0  0994					      DEF	CastleFixupDraw
      1  0994				   SLOT_CastleFixupDraw SET	_BANK_SLOT
      2  0994				   BANK_CastleFixupDraw SET	SLOT_CastleFixupDraw + _CURRENT_BANK
      3  0994				   CastleFixupDraw
      4  0994				   TEMPORARY_VAR SET	Overlay
      5  0994				   TEMPORARY_OFFSET SET	0
      6  0994				   VAR_BOUNDARY_CastleFixupDraw SET	TEMPORARY_OFFSET
      7  0994				   FUNCTION_NAME SET	CastleFixupDraw
    544  0994					      SUBROUTINE
    545  0994
      0  0994					      REF	aiSpecialMoveFixup	;✅
      1  0994					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  0994				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  0994					      ENDIF
      0  0994					      VEND	CastleFixupDraw
      1  0994
      2  0994
      3  0994		       00 b5	   VAREND_CastleFixupDraw =	TEMPORARY_VAR
      4  0994
    548  0994
    549  0994							; guarantee flags for piece, post-move, are correct
    550  0994
    551  0994
    552  0994		       a9 d0		      lda	#RAMBANK_BOARD
    553  0996		       85 3e		      sta	SET_BANK_RAM	;@2
    554  0998
    555  0998		       a5 96		      lda	fromPiece
    556  099a		       29 df		      and	#~FLAG_ENPASSANT
    557  099c		       09 40		      ora	#FLAG_MOVED
    558  099e
    559  099e		       a4 85		      ldy	fromX12	; destinatino
      0  09a0					      sta@RAM	Board,y
      1  09a0		       99 79 fe 	      sta	[RAM]+Board,y
    561  09a3
    562  09a3
    563  09a3							; fixup any castling issues
    564  09a3							; at this point the king has finished his two-square march
    565  09a3							; based on the finish square, we determine which rook we're interacting with
    566  09a3							; and generate a 'move' for the rook to position on the other side of the king
    567  09a3
    568  09a3
    569  09a3					      IF	CASTLING_ENABLED
      0  09a3					      CALL	GenCastleMoveForRook	;@3
      1  09a3				  -	      IF	SLOT_GenCastleMoveForRook == _BANK_SLOT
      2  09a3				  -FNAME      SETSTR	GenCastleMoveForRook
      3  09a3				  -	      ECHO	""
      4  09a3				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  09a3				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  09a3				  -	      ERR
      7  09a3					      ENDIF
      8  09a3		       a9 d8		      lda	#BANK_GenCastleMoveForRook
      9  09a5		       85 3f		      sta	SET_BANK
     10  09a7		       20 21 fc 	      jsr	GenCastleMoveForRook
    571  09aa		       b0 07		      bcs	.phase
    572  09ac					      ENDIF
    573  09ac
      0  09ac					      SWAP
      1  09ac
      2  09ac		       a5 95		      lda	sideToMove
      3  09ae		       49 c0		      eor	#SWAP_SIDE|HUMAN
      4  09b0		       85 95		      sta	sideToMove
      5  09b2
    575  09b2		       60		      rts
    576  09b3
    577  09b3				   .phase
    578  09b3
    579  09b3							; in this siutation (castle, rook moving) we do not change sides yet!
    580  09b3
      0  09b3					      PHASE	MoveIsSelected
      1  09b3		       a9 14		      lda	#AI_MoveIsSelected
      2  09b5		       85 8b		      sta	aiState
    582  09b7		       60		      rts
    583  09b8
    584  09b8
    585  09b8							;---------------------------------------------------------------------------------------------------
    586  09b8
      0  09b8					      DEF	aiDrawEntireBoard
      1  09b8				   SLOT_aiDrawEntireBoard SET	_BANK_SLOT
      2  09b8				   BANK_aiDrawEntireBoard SET	SLOT_aiDrawEntireBoard + _CURRENT_BANK
      3  09b8				   aiDrawEntireBoard
      4  09b8				   TEMPORARY_VAR SET	Overlay
      5  09b8				   TEMPORARY_OFFSET SET	0
      6  09b8				   VAR_BOUNDARY_aiDrawEntireBoard SET	TEMPORARY_OFFSET
      7  09b8				   FUNCTION_NAME SET	aiDrawEntireBoard
    588  09b8					      SUBROUTINE
    589  09b8
      0  09b8					      REF	Variable_PieceShapeBuffer
      1  09b8					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  09b8				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  09b8					      ENDIF
      0  09b8					      REF	AiStateMachine	;✅
      1  09b8				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  09b8				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  09b8					      ENDIF
    592  09b8
      0  09b8					      VEND	aiDrawEntireBoard
      1  09b8
      2  09b8
      3  09b8		       00 ef	   VAREND_aiDrawEntireBoard =	TEMPORARY_VAR
      4  09b8
    594  09b8
    595  09b8
    596  09b8		       ad 84 02 	      lda	INTIM
    597  09bb		       c9 2d		      cmp	#SPEEDOF_CopySinglePiece+4
    598  09bd		       90 2c		      bcc	.exit
    599  09bf
    600  09bf							; We use [SLOT3] for accessing board
    601  09bf
    602  09bf		       a9 d0		      lda	#RAMBANK_BOARD
    603  09c1		       85 3e		      sta	SET_BANK_RAM
    604  09c3		       a4 80		      ldy	squareToDraw
    605  09c5		       b9 15 fc 	      lda	ValidSquare,y
    606  09c8		       30 1d		      bmi	.isablank2
    607  09ca
    608  09ca		       b9 79 fc 	      lda	Board,y
    609  09cd		       f0 13		      beq	.isablank
    610  09cf		       48		      pha
    611  09d0		       a9 00		      lda	#BLANK
      0  09d2					      sta@RAM	Board,y
      1  09d2		       99 79 fe 	      sta	[RAM]+Board,y
    613  09d5
    614  09d5							; WARNING - local variables will not survive the following call...!
    615  09d5		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    616  09d8
    617  09d8		       a9 d0		      lda	#RAMBANK_BOARD
    618  09da		       85 3e		      sta	SET_BANK_RAM
    619  09dc
    620  09dc		       a4 80		      ldy	squareToDraw
    621  09de		       68		      pla
      0  09df					      sta@RAM	Board,y
      1  09df		       99 79 fe 	      sta	[RAM]+Board,y
    623  09e2
      0  09e2				   .isablank  PHASE	DrawPart2
      1  09e2		       a9 10		      lda	#AI_DrawPart2
      2  09e4		       85 8b		      sta	aiState
    625  09e6		       60		      rts
    626  09e7
      0  09e7				   .isablank2 PHASE	DrawPart3
      1  09e7		       a9 11		      lda	#AI_DrawPart3
      2  09e9		       85 8b		      sta	aiState
    628  09eb		       60	   .exit      rts
    629  09ec
    630  09ec
    631  09ec							;---------------------------------------------------------------------------------------------------
    632  09ec
      0  09ec					      DEF	aiDrawPart2
      1  09ec				   SLOT_aiDrawPart2 SET	_BANK_SLOT
      2  09ec				   BANK_aiDrawPart2 SET	SLOT_aiDrawPart2 + _CURRENT_BANK
      3  09ec				   aiDrawPart2
      4  09ec				   TEMPORARY_VAR SET	Overlay
      5  09ec				   TEMPORARY_OFFSET SET	0
      6  09ec				   VAR_BOUNDARY_aiDrawPart2 SET	TEMPORARY_OFFSET
      7  09ec				   FUNCTION_NAME SET	aiDrawPart2
    634  09ec					      SUBROUTINE
    635  09ec
      0  09ec					      REF	Variable_PieceShapeBuffer
      1  09ec					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  09ec				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  09ec					      ENDIF
      0  09ec					      REF	AiStateMachine
      1  09ec				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  09ec				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  09ec					      ENDIF
      0  09ec					      VEND	aiDrawPart2
      1  09ec
      2  09ec
      3  09ec		       00 ef	   VAREND_aiDrawPart2 =	TEMPORARY_VAR
      4  09ec
    639  09ec
    640  09ec							; WARNING - local variables will not survive the following call...!
    641  09ec		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    642  09ef
      0  09ef					      DEF	aiDrawPart3
      1  09ef				   SLOT_aiDrawPart3 SET	_BANK_SLOT
      2  09ef				   BANK_aiDrawPart3 SET	SLOT_aiDrawPart3 + _CURRENT_BANK
      3  09ef				   aiDrawPart3
      4  09ef				   TEMPORARY_VAR SET	Overlay
      5  09ef				   TEMPORARY_OFFSET SET	0
      6  09ef				   VAR_BOUNDARY_aiDrawPart3 SET	TEMPORARY_OFFSET
      7  09ef				   FUNCTION_NAME SET	aiDrawPart3
    644  09ef					      SUBROUTINE
    645  09ef
    646  09ef		       c6 80		      dec	squareToDraw
    647  09f1		       a5 80		      lda	squareToDraw
    648  09f3		       c9 16		      cmp	#22
    649  09f5		       90 05		      bcc	.comp
    650  09f7
      0  09f7					      PHASE	DrawEntireBoard
      1  09f7		       a9 0f		      lda	#AI_DrawEntireBoard
      2  09f9		       85 8b		      sta	aiState
    652  09fb		       60		      rts
    653  09fc
    654  09fc				   .comp
    655  09fc
    656  09fc		       a9 ff		      lda	#-1
    657  09fe		       85 86		      sta	toX12	; becomes startup flash square
    658  0a00		       a9 24		      lda	#36	; becomes cursor position
    659  0a02		       85 87		      sta	originX12
    660  0a04
    661  0a04
      0  0a04					      PHASE	GenerateMoves
      1  0a04		       a9 12		      lda	#AI_GenerateMoves
      2  0a06		       85 8b		      sta	aiState
    663  0a08		       60		      rts
    664  0a09
    665  0a09
    666  0a09							;---------------------------------------------------------------------------------------------------
    667  0a09
      0  0a09					      DEF	aiMarchB
      1  0a09				   SLOT_aiMarchB SET	_BANK_SLOT
      2  0a09				   BANK_aiMarchB SET	SLOT_aiMarchB + _CURRENT_BANK
      3  0a09				   aiMarchB
      4  0a09				   TEMPORARY_VAR SET	Overlay
      5  0a09				   TEMPORARY_OFFSET SET	0
      6  0a09				   VAR_BOUNDARY_aiMarchB SET	TEMPORARY_OFFSET
      7  0a09				   FUNCTION_NAME SET	aiMarchB
    669  0a09					      SUBROUTINE
    670  0a09
      0  0a09					      REF	Variable_PieceShapeBuffer
      1  0a09					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  0a09				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  0a09					      ENDIF
      0  0a09					      REF	AiStateMachine
      1  0a09				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0a09				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0a09					      ENDIF
      0  0a09					      VEND	aiMarchB
      1  0a09
      2  0a09
      3  0a09		       00 ef	   VAREND_aiMarchB =	TEMPORARY_VAR
      4  0a09
    674  0a09
    675  0a09							; Draw the piece in the new square
    676  0a09
    677  0a09		       a5 85		      lda	fromX12
    678  0a0b		       85 80		      sta	squareToDraw
    679  0a0d
    680  0a0d							; WARNING - local variables will not survive the following call...!
    681  0a0d		       20 c1 f0 	      jsr	CopySinglePiece	;@0	      ; draw the moving piece into the new square
    682  0a10
    683  0a10		       a9 02		      lda	#2	; snail trail delay
    684  0a12		       85 82		      sta	drawDelay
    685  0a14
      0  0a14					      PHASE	MarchToTargetB
      1  0a14		       a9 19		      lda	#AI_MarchToTargetB
      2  0a16		       85 8b		      sta	aiState
    687  0a18		       60		      rts
    688  0a19
    689  0a19
    690  0a19							;---------------------------------------------------------------------------------------------------
    691  0a19
      0  0a19					      DEF	aiDraw
      1  0a19				   SLOT_aiDraw SET	_BANK_SLOT
      2  0a19				   BANK_aiDraw SET	SLOT_aiDraw + _CURRENT_BANK
      3  0a19				   aiDraw
      4  0a19				   TEMPORARY_VAR SET	Overlay
      5  0a19				   TEMPORARY_OFFSET SET	0
      6  0a19				   VAR_BOUNDARY_aiDraw SET	TEMPORARY_OFFSET
      7  0a19				   FUNCTION_NAME SET	aiDraw
    693  0a19					      SUBROUTINE
    694  0a19		       a9 c0		      lda	#$C0
    695  0a1b		       85 49		      sta	COLUBK
    696  0a1d		       60		      rts
    697  0a1e
    698  0a1e
    699  0a1e							;---------------------------------------------------------------------------------------------------
    700  0a1e
      0  0a1e					      DEF	aiCheckMate
      1  0a1e				   SLOT_aiCheckMate SET	_BANK_SLOT
      2  0a1e				   BANK_aiCheckMate SET	SLOT_aiCheckMate + _CURRENT_BANK
      3  0a1e				   aiCheckMate
      4  0a1e				   TEMPORARY_VAR SET	Overlay
      5  0a1e				   TEMPORARY_OFFSET SET	0
      6  0a1e				   VAR_BOUNDARY_aiCheckMate SET	TEMPORARY_OFFSET
      7  0a1e				   FUNCTION_NAME SET	aiCheckMate
    702  0a1e					      SUBROUTINE
    703  0a1e		       a9 44		      lda	#$44
    704  0a20		       85 49		      sta	COLUBK
    705  0a22		       60		      rts
    706  0a23
    707  0a23
    708  0a23							;---------------------------------------------------------------------------------------------------
    709  0a23
      0  0a23					      DEF	aiQuiescent
      1  0a23				   SLOT_aiQuiescent SET	_BANK_SLOT
      2  0a23				   BANK_aiQuiescent SET	SLOT_aiQuiescent + _CURRENT_BANK
      3  0a23				   aiQuiescent
      4  0a23				   TEMPORARY_VAR SET	Overlay
      5  0a23				   TEMPORARY_OFFSET SET	0
      6  0a23				   VAR_BOUNDARY_aiQuiescent SET	TEMPORARY_OFFSET
      7  0a23				   FUNCTION_NAME SET	aiQuiescent
    711  0a23					      SUBROUTINE
    712  0a23
      0  0a23					      REF	AiStateMachine
      1  0a23					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0a23				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0a23					      ENDIF
      0  0a23					      VEND	aiQuiescent
      1  0a23
      2  0a23
      3  0a23		       00 a9	   VAREND_aiQuiescent =	TEMPORARY_VAR
      4  0a23
    715  0a23
    716  0a23							; Move has been selected
    717  0a23
    718  0a23		       a9 ff		      lda	#-1
    719  0a25		       85 88		      sta	cursorX12
    720  0a27
    721  0a27		       a5 85		      lda	fromX12
    722  0a29		       85 87		      sta	originX12
      0  0a2b					      CALL	GetPiece	;@3		    ; from the movelist
      1  0a2b				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  0a2b				  -FNAME      SETSTR	GetPiece
      3  0a2b				  -	      ECHO	""
      4  0a2b				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0a2b				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0a2b				  -	      ERR
      7  0a2b					      ENDIF
      8  0a2b		       a9 d8		      lda	#BANK_GetPiece
      9  0a2d		       85 3f		      sta	SET_BANK
     10  0a2f		       20 00 fc 	      jsr	GetPiece
    724  0a32
    725  0a32		       a4 85		      ldy	fromX12
    726  0a34		       a9 d0		      lda	#RAMBANK_BOARD
    727  0a36		       85 3e		      sta	SET_BANK_RAM	;@3
    728  0a38		       b9 79 fc 	      lda	Board,y
    729  0a3b		       45 96		      eor	fromPiece
    730  0a3d		       29 0f		      and	#PIECE_MASK	; if not the same piece board/movelist...
    731  0a3f		       d0 05		      bne	.promote	; promote a pawn
    732  0a41
      0  0a41					      PHASE	MoveIsSelected
      1  0a41		       a9 14		      lda	#AI_MoveIsSelected
      2  0a43		       85 8b		      sta	aiState
    734  0a45		       60		      rts
    735  0a46
      0  0a46				   .promote   PHASE	PromotePawnStart
      1  0a46		       a9 1f		      lda	#AI_PromotePawnStart
      2  0a48		       85 8b		      sta	aiState
    737  0a4a		       60		      rts
    738  0a4b
    739  0a4b
    740  0a4b							;---------------------------------------------------------------------------------------------------
    741  0a4b
      0  0a4b					      END_BANK
      1  0a4b				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  0a4b				  -	      CHECK_RAM_BANK_SIZE
      3  0a4b					      ELSE
      0  0a4b					      CHECK_BANK_SIZE
      1  0a4b		       02 4b	   .TEMP      =	* - _BANK_START
 ROM bank # 3 ONE size = $24b free = 436
      2  0a4b					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  0a4b				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  0a4b				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  0a4b				  -	      ERR
      6  0a4b					      ENDIF
      5  0a4b					      ENDIF
    743  0a4b
    744  0a4b							;---------------------------------------------------------------------------------------------------
    745  0a4b							; EOF
------- FILE ./chess.asm
------- FILE @1 NEGAMAX.asm LEVEL 2 PASS 4
      0  0a4b					      include	"@1 NEGAMAX.asm"
      1  0a4b							;---------------------------------------------------------------------------------------------------
      2  0a4b							; @1 NEGAMAX.asm
      3  0a4b
      4  0a4b							; Atari 2600 Chess
      5  0a4b							; Copyright (c) 2019-2020 Andrew Davie
      6  0a4b							; andrew@taswegian.com
      7  0a4b
      8  0a4b							;---------------------------------------------------------------------------------------------------
      9  0a4b
      0  0a4b					      SLOT	1
      1  0a4b
      2  0a4b				  -	      IF	(1 < 0) || (1 > 3)
      3  0a4b				  -	      ECHO	"Illegal bank address/segment location", 1
      4  0a4b				  -	      ERR
      5  0a4b					      ENDIF
      6  0a4b
      7  0a4b				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  0a4b				   _BANK_SLOT SET	1 * 64
      9  0a4b
      0  0a4b					      ROMBANK	NEGAMAX
      1  0f8a ????				      SEG	ROM_NEGAMAX
      2  0c00					      ORG	_ORIGIN
      3  0c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  0c00				   _BANK_START SET	*
      5  0c00				   NEGAMAX_START SET	*
      6  0c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  0c00				   ROMBANK_NEGAMAX SET	_BANK_SLOT + _CURRENT_BANK
      8  0c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  0c00				   _LAST_BANK SETSTR	NEGAMAX
     10  0c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     12  0c00
     13  0c00
     14  0c00							;---------------------------------------------------------------------------------------------------
     15  0c00
      0  0c00					      DEF	aiComputerMove
      1  0c00				   SLOT_aiComputerMove SET	_BANK_SLOT
      2  0c00				   BANK_aiComputerMove SET	SLOT_aiComputerMove + _CURRENT_BANK
      3  0c00				   aiComputerMove
      4  0c00				   TEMPORARY_VAR SET	Overlay
      5  0c00				   TEMPORARY_OFFSET SET	0
      6  0c00				   VAR_BOUNDARY_aiComputerMove SET	TEMPORARY_OFFSET
      7  0c00				   FUNCTION_NAME SET	aiComputerMove
     17  0c00					      SUBROUTINE
     18  0c00
      0  0c00					      REF	AiStateMachine	;✅
      1  0c00					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0c00				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0c00					      ENDIF
      0  0c00					      VEND	aiComputerMove
      1  0c00
      2  0c00
      3  0c00		       00 a9	   VAREND_aiComputerMove =	TEMPORARY_VAR
      4  0c00
     21  0c00
     22  0c00							; Computer is about to select a move
     23  0c00
     24  0c00
     25  0c00		       a9 88		      lda	#RAMBANK_PLY
     26  0c02		       85 94		      sta	currentPly
     27  0c04		       85 3e		      sta	SET_BANK_RAM	;@2		 ; switch in movelist
     28  0c06
     29  0c06		       a9 01		      lda	#1
     30  0c08		       85 4a		      sta	CTRLPF	; mirroring for thinkbars
     31  0c0a
     32  0c0a		       20 3a f4 	      jsr	selectmove	;@this
     33  0c0d
     34  0c0d		       a9 00		      lda	#0
     35  0c0f		       85 4a		      sta	CTRLPF	; clear mirroring
     36  0c11		       85 4e		      sta	PF1
     37  0c13		       85 4f		      sta	PF2
     38  0c15
     39  0c15							; correct ply is already switched
     40  0c15
      0  0c15					      lda@PLY	bestMove
      1  0c15		       ad d1 f9 	      lda	bestMove
     42  0c18		       10 17		      bpl	.notComputer
     43  0c1a
     44  0c1a							; Computer could not find a valid move. It's checkmate or stalemate. Find which...
     45  0c1a
      0  0c1a					      SWAP
      1  0c1a
      2  0c1a		       a5 95		      lda	sideToMove
      3  0c1c		       49 c0		      eor	#SWAP_SIDE|HUMAN
      4  0c1e		       85 95		      sta	sideToMove
      5  0c20
     47  0c20		       20 a6 f1 	      jsr	GenerateAllMoves	;@0
     48  0c23		       a5 9f		      lda	flagCheck
     49  0c25		       f0 05		      beq	.gameDrawn
     50  0c27
      0  0c27					      PHASE	CheckMate
      1  0c27		       a9 23		      lda	#AI_CheckMate
      2  0c29		       85 8b		      sta	aiState
     52  0c2b		       60		      rts
     53  0c2c
     54  0c2c
      0  0c2c				   .gameDrawn PHASE	Draw
      1  0c2c		       a9 24		      lda	#AI_Draw
      2  0c2e		       85 8b		      sta	aiState
     56  0c30		       60		      rts
     57  0c31
     58  0c31				   .notComputer
     59  0c31
     60  0c31
     61  0c31		       a9 ff		      lda	#-1
     62  0c33		       85 88		      sta	cursorX12
     63  0c35
      0  0c35					      PHASE	DelayAfterMove
      1  0c35		       a9 25		      lda	#AI_DelayAfterMove
      2  0c37		       85 8b		      sta	aiState
     65  0c39		       60	   .halted    rts
     66  0c3a
     67  0c3a
     68  0c3a							;---------------------------------------------------------------------------------------------------
     69  0c3a
      0  0c3a					      DEF	selectmove
      1  0c3a				   SLOT_selectmove SET	_BANK_SLOT
      2  0c3a				   BANK_selectmove SET	SLOT_selectmove + _CURRENT_BANK
      3  0c3a				   selectmove
      4  0c3a				   TEMPORARY_VAR SET	Overlay
      5  0c3a				   TEMPORARY_OFFSET SET	0
      6  0c3a				   VAR_BOUNDARY_selectmove SET	TEMPORARY_OFFSET
      7  0c3a				   FUNCTION_NAME SET	selectmove
     71  0c3a					      SUBROUTINE
     72  0c3a
      0  0c3a					      REF	COMMON_VARS
      1  0c3a					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0c3a				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0c3a					      ENDIF
      0  0c3a					      REF	aiComputerMove	;✅
      1  0c3a				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  0c3a				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  0c3a					      ENDIF
      0  0c3a					      VEND	selectmove
      1  0c3a
      2  0c3a
      3  0c3a		       00 b5	   VAREND_selectmove =	TEMPORARY_VAR
      4  0c3a
     76  0c3a
     77  0c3a
     78  0c3a							; RAM bank already switched in!!!
     79  0c3a							; returns with RAM bank switched
     80  0c3a
     81  0c3a
     82  0c3a					      IF	DIAGNOSTICS
     83  0c3a
     84  0c3a		       a9 00		      lda	#0
     85  0c3c		       85 9c		      sta	positionCount
     86  0c3e		       85 9d		      sta	positionCount+1
     87  0c40		       85 9e		      sta	positionCount+2
     88  0c42							;sta maxPly
     89  0c42					      ENDIF
     90  0c42
     91  0c42		       a9 00		      lda	#<INFINITY
     92  0c44		       85 ac		      sta	__beta
     93  0c46		       a9 70		      lda	#>INFINITY
     94  0c48		       85 ad		      sta	__beta+1
     95  0c4a
     96  0c4a		       a9 00		      lda	#<-INFINITY
     97  0c4c		       85 aa		      sta	__alpha
     98  0c4e		       a9 90		      lda	#>-INFINITY
     99  0c50		       85 ab		      sta	__alpha+1	; player tries to maximise
    100  0c52
    101  0c52		       a2 03		      ldx	#SEARCH_DEPTH
    102  0c54		       a9 00		      lda	#0	; no captured piece
    103  0c56		       85 b2		      sta	__quiesceCapOnly	; ALL moves to be generated
    104  0c58
    105  0c58		       20 29 f5 	      jsr	negaMax
    106  0c5b
    107  0c5b		       a5 94		      lda	currentPly
    108  0c5d		       85 3e		      sta	SET_BANK_RAM	;tmp?
    109  0c5f
      0  0c5f					      ldx@PLY	bestMove
      1  0c5f		       ae d1 f9 	      ldx	bestMove
    111  0c62		       30 26		      bmi	.nomove
    112  0c64
    113  0c64							; Generate player's moves in reply
    114  0c64							; Make the computer move, list player moves (PLY+1), unmake computer move
    115  0c64
      0  0c64					      stx@PLY	movePtr
      1  0c64		       8e d0 fb 	      stx	[RAM]+movePtr
    117  0c67		       20 8b f4 	      jsr	MakeMove	;@this
    118  0c6a		       20 50 f2 	      jsr	ListPlayerMoves	;@0
    119  0c6d
    120  0c6d		       c6 94		      dec	currentPly
    121  0c6f		       20 ad f2 	      jsr	unmakeMove	;@0
    122  0c72
    123  0c72							; Grab the computer move details for the UI animation
    124  0c72
    125  0c72		       a9 88		      lda	#RAMBANK_PLY
    126  0c74		       85 3e		      sta	SET_BANK_RAM
    127  0c76
      0  0c76					      ldx@PLY	bestMove
      1  0c76		       ae d1 f9 	      ldx	bestMove
      0  0c79					      lda@PLY	MoveTo,x
      1  0c79		       bd 64 f8 	      lda	MoveTo,x
    130  0c7c		       85 86		      sta	toX12
      0  0c7e					      lda@PLY	MoveFrom,x
      1  0c7e		       bd 00 f8 	      lda	MoveFrom,x
    132  0c81		       85 87		      sta	originX12
    133  0c83		       85 85		      sta	fromX12
      0  0c85					      lda@PLY	MovePiece,x
      1  0c85		       bd 00 f9 	      lda	MovePiece,x
    135  0c88		       85 96		      sta	fromPiece
    136  0c8a
    137  0c8a				   .nomove
    138  0c8a		       60		      rts
    139  0c8b
    140  0c8b
    141  0c8b							;---------------------------------------------------------------------------------------------------
    142  0c8b
      0  0c8b					      DEF	MakeMove
      1  0c8b				   SLOT_MakeMove SET	_BANK_SLOT
      2  0c8b				   BANK_MakeMove SET	SLOT_MakeMove + _CURRENT_BANK
      3  0c8b				   MakeMove
      4  0c8b				   TEMPORARY_VAR SET	Overlay
      5  0c8b				   TEMPORARY_OFFSET SET	0
      6  0c8b				   VAR_BOUNDARY_MakeMove SET	TEMPORARY_OFFSET
      7  0c8b				   FUNCTION_NAME SET	MakeMove
    144  0c8b					      SUBROUTINE
    145  0c8b
      0  0c8b					      REF	COMMON_VARS
      1  0c8b					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0c8b				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0c8b					      ENDIF
      0  0c8b					      REF	selectmove	;✅
      1  0c8b				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  0c8b				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  0c8b					      ENDIF
      0  0c8b					      REF	ListPlayerMoves	;✅
      1  0c8b				  -	      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  0c8b				  -TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  0c8b					      ENDIF
      0  0c8b					      REF	quiesce	;✅
      1  0c8b				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  0c8b				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  0c8b					      ENDIF
      0  0c8b					      REF	negaMax	;✅
      1  0c8b				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0c8b				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  0c8b					      ENDIF
      0  0c8b					      VEND	MakeMove
      1  0c8b
      2  0c8b
      3  0c8b		       00 b5	   VAREND_MakeMove =	TEMPORARY_VAR
      4  0c8b
    152  0c8b
    153  0c8b							; Do a move without any GUI stuff
    154  0c8b							; This function is ALWAYS paired with "unmakeMove" - a call to both will leave board
    155  0c8b							; and all relevant flags in original state. This is NOT used for the visible move on the
    156  0c8b							; screen.
    157  0c8b
    158  0c8b
    159  0c8b							; fromPiece	 piece doing the move
    160  0c8b							; fromX12	 current square X12
    161  0c8b							; originX12	 starting square X12
    162  0c8b							; toX12	 ending square X12
    163  0c8b
    164  0c8b							; BANK:SLOT2 = currentPly
    165  0c8b
    166  0c8b
    167  0c8b							; There are potentially "two" moves, with the following
    168  0c8b							; a) Castling, moving both rook and king
    169  0c8b							; b) en-Passant, capturing pawn on "odd" square
    170  0c8b							; These both set "secondary" movers which are used for restoring during unmakeMove
    171  0c8b
    172  0c8b		       a0 d0		      ldy	#RAMBANK_BOARD
    173  0c8d		       84 3e		      sty	SET_BANK_RAM	;@3
    174  0c8f
      0  0c8f					      ldx@PLY	movePtr
      1  0c8f		       ae d0 f9 	      ldx	movePtr
      0  0c92					      ldy@PLY	MoveFrom,x
      1  0c92		       bc 00 f8 	      ldy	MoveFrom,x
    177  0c95		       84 85		      sty	fromX12
    178  0c97		       84 87		      sty	originX12
    179  0c99
      0  0c99					      lda@RAM	Board,y
      1  0c99		       b9 79 fc 	      lda	Board,y
    181  0c9c		       85 b3		      sta	__originalPiece
      0  0c9e					      sta@PLY	restorePiece
      1  0c9e		       8d d9 fb 	      sta	[RAM]+restorePiece
    183  0ca1
    184  0ca1		       a9 00		      lda	#0
      0  0ca3					      sta@RAM	Board,y
      1  0ca3		       99 79 fe 	      sta	[RAM]+Board,y
      0  0ca6					      sta@PLY	secondaryPiece
      1  0ca6		       8d cc fb 	      sta	[RAM]+secondaryPiece
    187  0ca9
    188  0ca9		       85 a4		      sta	vkSquare
    189  0cab		       85 a5		      sta	vkSquare+1
    190  0cad
      0  0cad					      ldy@PLY	MoveTo,x
      1  0cad		       bc 64 f8 	      ldy	MoveTo,x
    192  0cb0		       84 86		      sty	toX12
    193  0cb2
      0  0cb2					      lda@RAM	Board,y
      1  0cb2		       b9 79 fc 	      lda	Board,y
    195  0cb5		       85 b4		      sta	__capturedPiece
      0  0cb7					      sta@PLY	capturedPiece
      1  0cb7		       8d cb fb 	      sta	[RAM]+capturedPiece
    197  0cba
      0  0cba					      lda@PLY	MovePiece,x
      1  0cba		       bd 00 f9 	      lda	MovePiece,x
    199  0cbd		       85 96		      sta	fromPiece
    200  0cbf
    201  0cbf		       29 8f		      and	#PIECE_MASK|FLAG_COLOUR
    202  0cc1		       09 40		      ora	#FLAG_MOVED
      0  0cc3					      sta@RAM	Board,y
      1  0cc3		       99 79 fe 	      sta	[RAM]+Board,y
    204  0cc6
    205  0cc6
      0  0cc6				   .move      CALL	AdjustMaterialPositionalValue	;@2
      1  0cc6				  -	      IF	SLOT_AdjustMaterialPositionalValue == _BANK_SLOT
      2  0cc6				  -FNAME      SETSTR	AdjustMaterialPositionalValue
      3  0cc6				  -	      ECHO	""
      4  0cc6				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0cc6				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0cc6				  -	      ERR
      7  0cc6					      ENDIF
      8  0cc6		       a9 89		      lda	#BANK_AdjustMaterialPositionalValue
      9  0cc8		       85 3f		      sta	SET_BANK
     10  0cca		       20 f1 f8 	      jsr	AdjustMaterialPositionalValue
    207  0ccd
    208  0ccd
    209  0ccd					      IF	CASTLING_ENABLED
    210  0ccd
    211  0ccd							; If the FROM piece has the castle bit set (i.e., it's a king that's just moved 2 squares)
    212  0ccd							; then we find the appropriate ROOK, set the secondary piece "undo" information, and then
    213  0ccd							; redo the moving code (for the rook, this time).
    214  0ccd
    215  0ccd							; Set the squares that need to be checked for "virtual check" - preventing the king
    216  0ccd							; from castling from/across check.
    217  0ccd
    218  0ccd		       a5 96		      lda	fromPiece
    219  0ccf		       29 17		      and	#FLAG_CASTLE|KING
    220  0cd1		       c9 17		      cmp	#FLAG_CASTLE|KING
    221  0cd3		       d0 13		      bne	.exit	; NOT involved in castle!
    222  0cd5
    223  0cd5							; Must be a king, castling. Calculate the virtual squares which need to be checked for
    224  0cd5							; invalid castling. Prevents moving in/across check.
    225  0cd5
    226  0cd5		       18		      clc
    227  0cd6		       a5 87		      lda	originX12
    228  0cd8		       85 a5		      sta	vkSquare+1	; king origin
    229  0cda		       65 86		      adc	toX12
    230  0cdc		       4a		      lsr
    231  0cdd		       85 a4		      sta	vkSquare	; intermediate square
    232  0cdf
    233  0cdf
    234  0cdf							; Now generate a new move for the rook
    235  0cdf
      0  0cdf					      CALL	GenCastleMoveForRook	;@3
      1  0cdf				  -	      IF	SLOT_GenCastleMoveForRook == _BANK_SLOT
      2  0cdf				  -FNAME      SETSTR	GenCastleMoveForRook
      3  0cdf				  -	      ECHO	""
      4  0cdf				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0cdf				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0cdf				  -	      ERR
      7  0cdf					      ENDIF
      8  0cdf		       a9 d8		      lda	#BANK_GenCastleMoveForRook
      9  0ce1		       85 3f		      sta	SET_BANK
     10  0ce3		       20 21 fc 	      jsr	GenCastleMoveForRook
    237  0ce6		       b0 de		      bcs	.move	; move the rook!
    238  0ce8
    239  0ce8				   .exit
    240  0ce8					      ENDIF
    241  0ce8
    242  0ce8
    243  0ce8					      IF	ENPASSANT_ENABLED
    244  0ce8
      0  0ce8					      CALL	EnPassantFixupDraw	; generate enPassantPawn value
      1  0ce8				  -	      IF	SLOT_EnPassantFixupDraw == _BANK_SLOT
      2  0ce8				  -FNAME      SETSTR	EnPassantFixupDraw
      3  0ce8				  -	      ECHO	""
      4  0ce8				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0ce8				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0ce8				  -	      ERR
      7  0ce8					      ENDIF
      8  0ce8		       a9 89		      lda	#BANK_EnPassantFixupDraw
      9  0cea		       85 3f		      sta	SET_BANK
     10  0cec		       20 79 f8 	      jsr	EnPassantFixupDraw
    246  0cef							;CALL EnPassantRemoveCapturedPawn
    247  0cef
    248  0cef					      ENDIF
    249  0cef
    250  0cef
    251  0cef
    252  0cef							; Swap over sides
    253  0cef
      0  0cef					      NEGEVAL
      1  0cef
      2  0cef		       38		      sec
      3  0cf0		       a9 00		      lda	#0
      4  0cf2		       e5 8f		      sbc	Evaluation
      5  0cf4		       85 8f		      sta	Evaluation
      6  0cf6		       a9 00		      lda	#0
      7  0cf8		       e5 90		      sbc	Evaluation+1
      8  0cfa		       85 90		      sta	Evaluation+1
      9  0cfc
      0  0cfc					      SWAP
      1  0cfc
      2  0cfc		       a5 95		      lda	sideToMove
      3  0cfe		       49 c0		      eor	#SWAP_SIDE|HUMAN
      4  0d00		       85 95		      sta	sideToMove
      5  0d02
    256  0d02
    257  0d02		       a5 94		      lda	currentPly
    258  0d04		       85 3e		      sta	SET_BANK_RAM
    259  0d06		       60		      rts
    260  0d07
    261  0d07
    262  0d07							;---------------------------------------------------------------------------------------------------
    263  0d07
    264  0d07							;function negaMax(node, depth, α, β, color) is
    265  0d07							;    if depth = 0 or node is a terminal node then
    266  0d07							;	  return color × the heuristic value of node
    267  0d07
    268  0d07							;    childNodes := generateMoves(node)
    269  0d07							;    childNodes := orderMoves(childNodes)
    270  0d07							;    value := −∞
    271  0d07							;    foreach child in childNodes do
    272  0d07							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    273  0d07							;	  α := max(α, value)
    274  0d07							;	  if α ≥ β then
    275  0d07							;	      break (* cut-off *)
    276  0d07							;    return value
    277  0d07							;(* Initial call for Player A's root node *)
    278  0d07							;negaMax(rootNode, depth, −∞, +∞, 1)
    279  0d07
    280  0d07
    281  0d07					      SUBROUTINE
    282  0d07
    283  0d07		       a9 ff	   .doQ       lda	#-1
    284  0d09		       85 b2		      sta	__quiesceCapOnly
    285  0d0b		       20 a3 f6 	      jsr	quiesce
    286  0d0e		       e6 b2		      inc	__quiesceCapOnly
    287  0d10		       60		      rts
    288  0d11
    289  0d11
      0  0d11				   .exit      lda@PLY	value
      1  0d11		       ad d6 f9 	      lda	value
    291  0d14		       85 ae		      sta	__negaMax
      0  0d16					      lda@PLY	value+1
      1  0d16		       ad d7 f9 	      lda	value+1
    293  0d19		       85 af		      sta	__negaMax+1
    294  0d1b		       60		      rts
    295  0d1c
    296  0d1c
    297  0d1c				   .terminal
    298  0d1c
    299  0d1c					      IF	QUIESCE_EXTRA_DEPTH > 0
    300  0d1c		       c9 00		      cmp	#0	; captured piece
    301  0d1e		       d0 e7		      bne	.doQ	; last move was capture, so quiesce
    302  0d20					      ENDIF
    303  0d20
    304  0d20
    305  0d20		       a5 8f		      lda	Evaluation
    306  0d22		       85 ae		      sta	__negaMax
    307  0d24		       a5 90		      lda	Evaluation+1
    308  0d26		       85 af		      sta	__negaMax+1
    309  0d28
    310  0d28		       60	   .inCheck2  rts
    311  0d29
    312  0d29
    313  0d29							;---------------------------------------------------------------------------------------------------
    314  0d29
      0  0d29					      DEF	negaMax
      1  0d29				   SLOT_negaMax SET	_BANK_SLOT
      2  0d29				   BANK_negaMax SET	SLOT_negaMax + _CURRENT_BANK
      3  0d29				   negaMax
      4  0d29				   TEMPORARY_VAR SET	Overlay
      5  0d29				   TEMPORARY_OFFSET SET	0
      6  0d29				   VAR_BOUNDARY_negaMax SET	TEMPORARY_OFFSET
      7  0d29				   FUNCTION_NAME SET	negaMax
    316  0d29
    317  0d29							; PARAMS depth-1, -beta, -alpha
    318  0d29							; pased through temporary variables (__alpha, __beta) and X reg
    319  0d29
    320  0d29							; pass...
    321  0d29							; x = depthleft
    322  0d29							; a = captured piece
    323  0d29							; SET_BANK_RAM      --> current ply
    324  0d29							; __alpha[2] = param alpha
    325  0d29							; __beta[2] = param beta
    326  0d29
    327  0d29
      0  0d29					      REF	COMMON_VARS
      1  0d29					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0d29				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0d29					      ENDIF
      0  0d29					      REF	selectmove	;✅
      1  0d29				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  0d29				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  0d29					      ENDIF
      0  0d29					      VEND	negaMax
      1  0d29
      2  0d29
      3  0d29		       00 b5	   VAREND_negaMax =	TEMPORARY_VAR
      4  0d29
    331  0d29
    332  0d29		       48		      pha
    333  0d2a
    334  0d2a		       20 77 f0 	      jsr	ThinkBar	;@0
    335  0d2d
    336  0d2d		       a5 94		      lda	currentPly
    337  0d2f		       85 3e		      sta	SET_BANK_RAM	;@2
    338  0d31
    339  0d31		       68		      pla
    340  0d32		       ca		      dex
    341  0d33		       30 e7		      bmi	.terminal
      0  0d35					      stx@PLY	depthLeft
      1  0d35		       8e d8 fb 	      stx	[RAM]+depthLeft
    343  0d38
    344  0d38
    345  0d38							; Allow the player to force computer to select a move. Press the SELECT switch
    346  0d38
      0  0d38					      lda@PLY	bestMove
      1  0d38		       ad d1 f9 	      lda	bestMove
    348  0d3b		       30 07		      bmi	.noCheat	; can't force if no move chosen!
    349  0d3d		       ad 82 02 	      lda	SWCHB
    350  0d40		       29 02		      and	#SELECT_SWITCH
    351  0d42		       f0 cd		      beq	.exit	; SELECT abort
    352  0d44				   .noCheat
    353  0d44
    354  0d44
      0  0d44					      NEXT_RANDOM
      1  0d44
      2  0d44		       a5 81		      lda	rnd
      3  0d46		       4a		      lsr
      4  0d47		       90 02		      bcc	.skipEOR
      5  0d49		       49 b4		      eor	#RND_EOR_VAL
      6  0d4b		       85 81	   .skipEOR   sta	rnd
      7  0d4d
    356  0d4d		       25 a1		      and	randomness
    357  0d4f		       65 8f		      adc	Evaluation
    358  0d51		       85 8f		      sta	Evaluation	; since it's random we don't care about HI
    359  0d53							;bcc .evOK
    360  0d53							;inc Evaluation+1
    361  0d53				   .evOK
    362  0d53
    363  0d53
    364  0d53
    365  0d53							;lda #2
    366  0d53							;sta COLUPF			  ; grey thinkbars
    367  0d53
    368  0d53		       a5 aa		      lda	__alpha
      0  0d55					      sta@PLY	alpha
      1  0d55		       8d d2 fb 	      sta	[RAM]+alpha
    370  0d58		       a5 ab		      lda	__alpha+1
      0  0d5a					      sta@PLY	alpha+1
      1  0d5a		       8d d3 fb 	      sta	[RAM]+alpha+1
    372  0d5d
    373  0d5d		       a5 ac		      lda	__beta
      0  0d5f					      sta@PLY	beta
      1  0d5f		       8d d4 fb 	      sta	[RAM]+beta
    375  0d62		       a5 ad		      lda	__beta+1
      0  0d64					      sta@PLY	beta+1
      1  0d64		       8d d5 fb 	      sta	[RAM]+beta+1
    377  0d67
    378  0d67
    379  0d67		       20 a6 f1 	      jsr	GenerateAllMoves	;@0
    380  0d6a
    381  0d6a		       a5 9f		      lda	flagCheck
    382  0d6c		       d0 ba		      bne	.inCheck2	; OTHER guy in check
    383  0d6e
    384  0d6e		       a9 00		      lda	#<-INFINITY
      0  0d70					      sta@PLY	value
      1  0d70		       8d d6 fb 	      sta	[RAM]+value
    386  0d73		       a9 90		      lda	#>-INFINITY
      0  0d75					      sta@PLY	value+1
      1  0d75		       8d d7 fb 	      sta	[RAM]+value+1
    388  0d78
      0  0d78					      ldx@PLY	moveIndex
      1  0d78		       ae cf f9 	      ldx	moveIndex
    390  0d7b		       10 03		      bpl	.forChild
    391  0d7d		       4c 11 f5 	      jmp	.exit
    392  0d80
      0  0d80				   .forChild  stx@PLY	movePtr
      1  0d80		       8e d0 fb 	      stx	[RAM]+movePtr
    394  0d83
    395  0d83		       20 8b f4 	      jsr	MakeMove	;@this
    396  0d86
    397  0d86
    398  0d86							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    399  0d86
    400  0d86							; PARAMS depth-1, -beta, -alpha
    401  0d86							; pased through temporary variables (__alpha, __beta) and X reg
    402  0d86
    403  0d86		       38		      sec
    404  0d87		       a9 00		      lda	#0
      0  0d89					      sbc@PLY	beta
      1  0d89		       ed d4 f9 	      sbc	beta
    406  0d8c		       85 aa		      sta	__alpha
    407  0d8e		       a9 00		      lda	#0
      0  0d90					      sbc@PLY	beta+1
      1  0d90		       ed d5 f9 	      sbc	beta+1
    409  0d93		       85 ab		      sta	__alpha+1
    410  0d95
    411  0d95		       38		      sec
    412  0d96		       a9 00		      lda	#0
      0  0d98					      sbc@PLY	alpha
      1  0d98		       ed d2 f9 	      sbc	alpha
    414  0d9b		       85 ac		      sta	__beta
    415  0d9d		       a9 00		      lda	#0
      0  0d9f					      sbc@PLY	alpha+1
      1  0d9f		       ed d3 f9 	      sbc	alpha+1
    417  0da2		       85 ad		      sta	__beta+1
    418  0da4
    419  0da4
      0  0da4					      ldx@PLY	depthLeft
      1  0da4		       ae d8 f9 	      ldx	depthLeft
      0  0da7					      lda@PLY	capturedPiece
      1  0da7		       ad cb f9 	      lda	capturedPiece
    422  0daa
    423  0daa		       e6 94		      inc	currentPly
    424  0dac		       a4 94		      ldy	currentPly
    425  0dae		       84 3e		      sty	SET_BANK_RAM	; self-switch
    426  0db0
    427  0db0		       20 29 f5 	      jsr	negaMax	;@this
    428  0db3
    429  0db3		       c6 94		      dec	currentPly
    430  0db5		       a5 94		      lda	currentPly
    431  0db7		       85 3e		      sta	SET_BANK_RAM
    432  0db9
    433  0db9		       20 ad f2 	      jsr	unmakeMove	;@0
    434  0dbc
    435  0dbc		       38		      sec
    436  0dbd		       a9 00		      lda	#0
    437  0dbf		       e5 ae		      sbc	__negaMax
    438  0dc1		       85 ae		      sta	__negaMax
    439  0dc3		       a9 00		      lda	#0
    440  0dc5		       e5 af		      sbc	__negaMax+1
    441  0dc7		       85 af		      sta	__negaMax+1	; -negaMax(...)
    442  0dc9
    443  0dc9					      IF	1
    444  0dc9		       a5 9f		      lda	flagCheck
    445  0dcb		       f0 06		      beq	.notCheck
    446  0dcd
    447  0dcd							; at this point we've determined that the move was illegal, because the next ply detected
    448  0dcd							; a king capture. So, the move should be totally discounted
    449  0dcd
    450  0dcd		       a9 00		      lda	#0
    451  0dcf		       85 9f		      sta	flagCheck	; so we don't retrigger in future - it's been handled!
    452  0dd1		       f0 53		      beq	.nextMove	; unconditional - move is not considered!
    453  0dd3					      ENDIF
    454  0dd3
    455  0dd3		       38	   .notCheck  sec
      0  0dd4					      lda@PLY	value
      1  0dd4		       ad d6 f9 	      lda	value
    457  0dd7		       e5 ae		      sbc	__negaMax
      0  0dd9					      lda@PLY	value+1
      1  0dd9		       ad d7 f9 	      lda	value+1
    459  0ddc		       e5 af		      sbc	__negaMax+1
    460  0dde		       50 02		      bvc	.lab0
    461  0de0		       49 80		      eor	#$80
    462  0de2		       10 10	   .lab0      bpl	.lt0	; branch if value >= negaMax
    463  0de4
    464  0de4							; so, negaMax > value!
    465  0de4
    466  0de4		       a5 ae		      lda	__negaMax
      0  0de6					      sta@PLY	value
      1  0de6		       8d d6 fb 	      sta	[RAM]+value
    468  0de9		       a5 af		      lda	__negaMax+1
      0  0deb					      sta@PLY	value+1	; max(value, -negaMax)
      1  0deb		       8d d7 fb 	      sta	[RAM]+value+1
    470  0dee
      0  0dee					      lda@PLY	movePtr
      1  0dee		       ad d0 f9 	      lda	movePtr
      0  0df1					      sta@PLY	bestMove
      1  0df1		       8d d1 fb 	      sta	[RAM]+bestMove
    473  0df4				   .lt0
    474  0df4
    475  0df4							;	  α := max(α, value)
    476  0df4
    477  0df4		       38		      sec
      0  0df5					      lda@PLY	value
      1  0df5		       ad d6 f9 	      lda	value
      0  0df8					      sbc@PLY	alpha
      1  0df8		       ed d2 f9 	      sbc	alpha
      0  0dfb					      lda@PLY	value+1
      1  0dfb		       ad d7 f9 	      lda	value+1
      0  0dfe					      sbc@PLY	alpha+1
      1  0dfe		       ed d3 f9 	      sbc	alpha+1
    482  0e01		       50 02		      bvc	.lab1
    483  0e03		       49 80		      eor	#$80
    484  0e05		       30 0c	   .lab1      bmi	.lt1	; value < alpha
    485  0e07
      0  0e07					      lda@PLY	value
      1  0e07		       ad d6 f9 	      lda	value
      0  0e0a					      sta@PLY	alpha
      1  0e0a		       8d d2 fb 	      sta	[RAM]+alpha
      0  0e0d					      lda@PLY	value+1
      1  0e0d		       ad d7 f9 	      lda	value+1
      0  0e10					      sta@PLY	alpha+1	; alpha = max(alpha, value)
      1  0e10		       8d d3 fb 	      sta	[RAM]+alpha+1
    490  0e13
    491  0e13				   .lt1
    492  0e13
    493  0e13							;	  if α ≥ β then
    494  0e13							;	      break (* cut-off *)
    495  0e13
    496  0e13		       38		      sec
      0  0e14					      lda@PLY	alpha
      1  0e14		       ad d2 f9 	      lda	alpha
      0  0e17					      sbc@PLY	beta
      1  0e17		       ed d4 f9 	      sbc	beta
      0  0e1a					      lda@PLY	alpha+1
      1  0e1a		       ad d3 f9 	      lda	alpha+1
      0  0e1d					      sbc@PLY	beta+1
      1  0e1d		       ed d5 f9 	      sbc	beta+1
    501  0e20		       50 02		      bvc	.lab2
    502  0e22		       49 80		      eor	#$80
    503  0e24		       10 09	   .lab2      bpl	.retrn	; alpha >= beta
    504  0e26
    505  0e26
      0  0e26				   .nextMove  ldx@PLY	movePtr
      1  0e26		       ae d0 f9 	      ldx	movePtr
    507  0e29		       ca	   .nextX     dex
    508  0e2a		       30 03		      bmi	.retrn
    509  0e2c		       4c 80 f5 	      jmp	.forChild
    510  0e2f
    511  0e2f		       4c 11 f5    .retrn     jmp	.exit
    512  0e32
    513  0e32
    514  0e32							;---------------------------------------------------------------------------------------------------
    515  0e32
    516  0e32					      MAC	xchg
    517  0e32					      lda@PLY	{1},x
    518  0e32					      pha		;sta __xchg
    519  0e32					      lda@PLY	{1},y
    520  0e32					      sta@PLY	{1},x
    521  0e32					      pla		;lda __xchg
    522  0e32					      sta@PLY	{1},y
    523  0e32					      ENDM		;{name}
    524  0e32
    525  0e32
      0  0e32					      DEF	Sort
      1  0e32				   SLOT_Sort  SET	_BANK_SLOT
      2  0e32				   BANK_Sort  SET	SLOT_Sort + _CURRENT_BANK
      3  0e32				   Sort
      4  0e32				   TEMPORARY_VAR SET	Overlay
      5  0e32				   TEMPORARY_OFFSET SET	0
      6  0e32				   VAR_BOUNDARY_Sort SET	TEMPORARY_OFFSET
      7  0e32				   FUNCTION_NAME SET	Sort
    527  0e32					      SUBROUTINE
    528  0e32
      0  0e32					      REF	GenerateAllMoves
      1  0e32					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  0e32				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  0e32					      ENDIF
      0  0e32					      VAR	__xchg, 1
      1  0e32
      2  0e32		       00 b8	   __xchg     =	TEMPORARY_VAR
      3  0e32				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  0e32
      5  0e32				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  0e32				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  0e32				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  0e32					      ENDIF
      9  0e32				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  0e32				  -	      LIST	ON
     11  0e32				  -VNAME      SETSTR	__xchg
     12  0e32				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  0e32				  -	      ERR
     14  0e32				  -	      ECHO	"Temporary Variable overlow!"
     15  0e32					      ENDIF
     16  0e32					      LIST	ON
      0  0e32					      VEND	Sort
      1  0e32
      2  0e32
      3  0e32		       00 b9	   VAREND_Sort =	TEMPORARY_VAR
      4  0e32
    532  0e32
    533  0e32		       a5 b2		      lda	__quiesceCapOnly
    534  0e34		       d0 4a		      bne	.exit	; only caps present so already sorted!
    535  0e36
      0  0e36					      ldx@PLY	moveIndex
      1  0e36		       ae cf f9 	      ldx	moveIndex
      0  0e39					      ldy@PLY	moveIndex
      1  0e39		       ac cf f9 	      ldy	moveIndex
    538  0e3c		       c8		      iny		; this is OK - swaps "1st" with itself if it's a capture
    539  0e3d
    540  0e3d		       88	   .next      dey
    541  0e3e		       30 40		      bmi	.exit
    542  0e40
      0  0e40					      lda@PLY	MoveCapture,y
      1  0e40		       b9 64 f9 	      lda	MoveCapture,y
    544  0e43		       f0 f8		      beq	.next
    545  0e45
      0  0e45					      XCHG	MoveFrom
      0  0e45					      lda@PLY	MoveFrom,x
      1  0e45		       bd 00 f8 	      lda	MoveFrom,x
      2  0e48		       48		      pha
      0  0e49					      lda@PLY	MoveFrom,y
      1  0e49		       b9 00 f8 	      lda	MoveFrom,y
      0  0e4c					      sta@PLY	MoveFrom,x
      1  0e4c		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
      5  0e4f		       68		      pla
      0  0e50					      sta@PLY	MoveFrom,y
      1  0e50		       99 00 fa 	      sta	[RAM]+MoveFrom,y
      0  0e53					      XCHG	MoveTo
      0  0e53					      lda@PLY	MoveTo,x
      1  0e53		       bd 64 f8 	      lda	MoveTo,x
      2  0e56		       48		      pha
      0  0e57					      lda@PLY	MoveTo,y
      1  0e57		       b9 64 f8 	      lda	MoveTo,y
      0  0e5a					      sta@PLY	MoveTo,x
      1  0e5a		       9d 64 fa 	      sta	[RAM]+MoveTo,x
      5  0e5d		       68		      pla
      0  0e5e					      sta@PLY	MoveTo,y
      1  0e5e		       99 64 fa 	      sta	[RAM]+MoveTo,y
      0  0e61					      XCHG	MovePiece
      0  0e61					      lda@PLY	MovePiece,x
      1  0e61		       bd 00 f9 	      lda	MovePiece,x
      2  0e64		       48		      pha
      0  0e65					      lda@PLY	MovePiece,y
      1  0e65		       b9 00 f9 	      lda	MovePiece,y
      0  0e68					      sta@PLY	MovePiece,x
      1  0e68		       9d 00 fb 	      sta	[RAM]+MovePiece,x
      5  0e6b		       68		      pla
      0  0e6c					      sta@PLY	MovePiece,y
      1  0e6c		       99 00 fb 	      sta	[RAM]+MovePiece,y
      0  0e6f					      XCHG	MoveCapture
      0  0e6f					      lda@PLY	MoveCapture,x
      1  0e6f		       bd 64 f9 	      lda	MoveCapture,x
      2  0e72		       48		      pha
      0  0e73					      lda@PLY	MoveCapture,y
      1  0e73		       b9 64 f9 	      lda	MoveCapture,y
      0  0e76					      sta@PLY	MoveCapture,x
      1  0e76		       9d 64 fb 	      sta	[RAM]+MoveCapture,x
      5  0e79		       68		      pla
      0  0e7a					      sta@PLY	MoveCapture,y
      1  0e7a		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    550  0e7d
    551  0e7d		       ca		      dex
    552  0e7e		       10 bd		      bpl	.next
    553  0e80
    554  0e80				   .exit
    555  0e80
    556  0e80							; Scan for capture of king
    557  0e80							; Also scan for virtual king captures (squares involved in castling)
    558  0e80
      0  0e80					      ldx@PLY	moveIndex
      1  0e80		       ae cf f9 	      ldx	moveIndex
    560  0e83		       30 19		      bmi	.notCheck	; OK if no captures in quiesce!
    561  0e85
      0  0e85				   .scanCheck lda@PLY	MoveCapture,x
      1  0e85		       bd 64 f9 	      lda	MoveCapture,x
    563  0e88		       29 0f		      and	#PIECE_MASK
    564  0e8a		       c9 07		      cmp	#KING
    565  0e8c		       f0 12		      beq	.check
    566  0e8e
    567  0e8e							; If the squares the king is crossing for castling are capturable, then that's an illegal
    568  0e8e							; castle move and it's treated as if the king were in check.
    569  0e8e
      0  0e8e					      lda@PLY	MoveTo,x
      1  0e8e		       bd 64 f8 	      lda	MoveTo,x
      0  0e91					      cmp@PLY	virtualKingSquare
      1  0e91		       cd da f9 	      cmp	virtualKingSquare
    572  0e94		       f0 0a		      beq	.check
      0  0e96					      cmp@PLY	virtualKingSquare+1
      1  0e96		       cd db f9 	      cmp	virtualKingSquare+1
    574  0e99		       f0 05		      beq	.check
    575  0e9b
    576  0e9b		       ca	   .nextScan  dex
    577  0e9c		       10 e7		      bpl	.scanCheck
    578  0e9e
    579  0e9e		       a9 00	   .notCheck  lda	#0
    580  0ea0		       85 9f	   .check     sta	flagCheck
    581  0ea2		       60		      rts
    582  0ea3
    583  0ea3
    584  0ea3							;---------------------------------------------------------------------------------------------------
    585  0ea3							; QUIESCE!
    586  0ea3
    587  0ea3							;int Quiesce( int alpha, int beta ) {
    588  0ea3							;    int stand_pat = Evaluate();
    589  0ea3							;    if( stand_pat >= beta )
    590  0ea3							;	  return beta;
    591  0ea3							;    if( alpha < stand_pat )
    592  0ea3							;	  alpha = stand_pat;
    593  0ea3
    594  0ea3							;    until( every_capture_has_been_examined )	{
    595  0ea3							;	  MakeCapture();
    596  0ea3							;	  score = -Quiesce( -beta, -alpha );
    597  0ea3							;	  TakeBackMove();
    598  0ea3
    599  0ea3							;	  if( score >= beta )
    600  0ea3							;	      return beta;
    601  0ea3							;	  if( score > alpha )
    602  0ea3							;	     alpha = score;
    603  0ea3							;    }
    604  0ea3							;    return alpha;
    605  0ea3							;}
    606  0ea3
    607  0ea3
    608  0ea3							;---------------------------------------------------------------------------------------------------
    609  0ea3
      0  0ea3					      DEF	quiesce
      1  0ea3				   SLOT_quiesce SET	_BANK_SLOT
      2  0ea3				   BANK_quiesce SET	SLOT_quiesce + _CURRENT_BANK
      3  0ea3				   quiesce
      4  0ea3				   TEMPORARY_VAR SET	Overlay
      5  0ea3				   TEMPORARY_OFFSET SET	0
      6  0ea3				   VAR_BOUNDARY_quiesce SET	TEMPORARY_OFFSET
      7  0ea3				   FUNCTION_NAME SET	quiesce
    611  0ea3					      SUBROUTINE
    612  0ea3
    613  0ea3							; pass...
    614  0ea3							; x = depthleft
    615  0ea3							; SET_BANK_RAM      --> current ply
    616  0ea3							; __alpha[2] = param alpha
    617  0ea3							; __beta[2] = param beta
    618  0ea3
    619  0ea3
      0  0ea3					      REF	COMMON_VARS
      1  0ea3					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0ea3				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0ea3					      ENDIF
      0  0ea3					      REF	negaMax
      1  0ea3				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0ea3				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  0ea3					      ENDIF
      0  0ea3					      VEND	quiesce
      1  0ea3
      2  0ea3
      3  0ea3		       00 b5	   VAREND_quiesce =	TEMPORARY_VAR
      4  0ea3
    623  0ea3
    624  0ea3		       a5 94		      lda	currentPly
    625  0ea5		       c9 8e		      cmp	#RAMBANK_PLY + PLY_BANKS -1
    626  0ea7		       b0 28		      bcs	.retBeta
    627  0ea9							;sta SET_BANK_RAM ;tmp
    628  0ea9
    629  0ea9
    630  0ea9		       20 77 f0 	      jsr	ThinkBar	;@0
    631  0eac
    632  0eac		       a5 ac		      lda	__beta
      0  0eae					      sta@PLY	beta
      1  0eae		       8d d4 fb 	      sta	[RAM]+beta
    634  0eb1		       a5 ad		      lda	__beta+1
      0  0eb3					      sta@PLY	beta+1
      1  0eb3		       8d d5 fb 	      sta	[RAM]+beta+1
    636  0eb6
    637  0eb6		       a5 aa		      lda	__alpha
      0  0eb8					      sta@PLY	alpha
      1  0eb8		       8d d2 fb 	      sta	[RAM]+alpha
    639  0ebb		       a5 ab		      lda	__alpha+1
      0  0ebd					      sta@PLY	alpha+1
      1  0ebd		       8d d3 fb 	      sta	[RAM]+alpha+1
    641  0ec0
    642  0ec0
    643  0ec0							;    int stand_pat = Evaluate();
    644  0ec0							;    if( stand_pat >= beta )
    645  0ec0							;	  return beta;
    646  0ec0
    647  0ec0		       38		      sec
    648  0ec1		       a5 8f		      lda	Evaluation
      0  0ec3					      sbc@PLY	beta
      1  0ec3		       ed d4 f9 	      sbc	beta
    650  0ec6		       a5 90		      lda	Evaluation+1
      0  0ec8					      sbc@PLY	beta+1
      1  0ec8		       ed d5 f9 	      sbc	beta+1
    652  0ecb		       50 02		      bvc	.spat0
    653  0ecd		       49 80		      eor	#$80
    654  0ecf		       30 0b	   .spat0     bmi	.norb	;pl .retBeta			 ; branch if stand_pat >= beta
    655  0ed1
    656  0ed1		       ad d4 f9    .retBeta   lda	beta
    657  0ed4		       85 ae		      sta	__negaMax
    658  0ed6		       ad d5 f9 	      lda	beta+1
    659  0ed9		       85 af		      sta	__negaMax+1
    660  0edb
    661  0edb		       60	   .abort     rts
    662  0edc
    663  0edc				   .norb
    664  0edc
    665  0edc
    666  0edc							;    if( alpha < stand_pat )
    667  0edc							;	  alpha = stand_pat;
    668  0edc
    669  0edc		       38		      sec
    670  0edd		       ad d2 f9 	      lda	alpha
    671  0ee0		       e5 8f		      sbc	Evaluation
    672  0ee2		       ad d3 f9 	      lda	alpha+1
    673  0ee5		       e5 90		      sbc	Evaluation+1
    674  0ee7		       50 02		      bvc	.spat1
    675  0ee9		       49 80		      eor	#$80
    676  0eeb		       10 0a	   .spat1     bpl	.alpha	; branch if alpha >= stand_pat
    677  0eed
    678  0eed							; alpha < stand_pat
    679  0eed
    680  0eed		       a5 8f		      lda	Evaluation
      0  0eef					      sta@PLY	alpha
      1  0eef		       8d d2 fb 	      sta	[RAM]+alpha
    682  0ef2		       a5 90		      lda	Evaluation+1
      0  0ef4					      sta@PLY	alpha+1
      1  0ef4		       8d d3 fb 	      sta	[RAM]+alpha+1
    684  0ef7
    685  0ef7				   .alpha
    686  0ef7		       20 a6 f1 	      jsr	GenerateAllMoves
    687  0efa		       a5 9f		      lda	flagCheck
    688  0efc		       d0 dd		      bne	.abort	; pure abort
    689  0efe
      0  0efe					      ldx@PLY	moveIndex
      1  0efe		       ae cf f9 	      ldx	moveIndex
    691  0f01		       30 76		      bmi	.exit
    692  0f03
      0  0f03				   .forChild  stx@PLY	movePtr
      1  0f03		       8e d0 fb 	      stx	[RAM]+movePtr
    694  0f06
    695  0f06							; The movelist has captures ONLY (ref: __quiesceCapOnly != 0)
    696  0f06
    697  0f06		       20 8b f4 	      jsr	MakeMove	;@this
    698  0f09
    699  0f09		       38		      sec
    700  0f0a		       a9 00		      lda	#0
      0  0f0c					      sbc@PLY	beta
      1  0f0c		       ed d4 f9 	      sbc	beta
    702  0f0f		       85 aa		      sta	__alpha
    703  0f11		       a9 00		      lda	#0
      0  0f13					      sbc@PLY	beta+1
      1  0f13		       ed d5 f9 	      sbc	beta+1
    705  0f16		       85 ab		      sta	__alpha+1
    706  0f18
    707  0f18		       38		      sec
    708  0f19		       a9 00		      lda	#0
      0  0f1b					      sbc@PLY	alpha
      1  0f1b		       ed d2 f9 	      sbc	alpha
    710  0f1e		       85 ac		      sta	__beta
    711  0f20		       a9 00		      lda	#0
      0  0f22					      sbc@PLY	alpha+1
      1  0f22		       ed d3 f9 	      sbc	alpha+1
    713  0f25		       85 ad		      sta	__beta+1
    714  0f27
    715  0f27		       e6 94		      inc	currentPly
    716  0f29		       a5 94		      lda	currentPly
    717  0f2b		       85 3e		      sta	SET_BANK_RAM	; self-switch
    718  0f2d
    719  0f2d		       20 a3 f6 	      jsr	quiesce	;@this
    720  0f30
    721  0f30		       c6 94		      dec	currentPly
    722  0f32
    723  0f32		       20 ad f2 	      jsr	unmakeMove	;@0
    724  0f35
    725  0f35		       a5 9f		      lda	flagCheck	; don't consider moves which leave us in check
    726  0f37		       d0 4b		      bne	.inCheck
    727  0f39
    728  0f39		       38		      sec
    729  0f3a							;lda #0			 ; already 0
    730  0f3a		       e5 ae		      sbc	__negaMax
    731  0f3c		       85 ae		      sta	__negaMax
    732  0f3e		       a9 00		      lda	#0
    733  0f40		       e5 af		      sbc	__negaMax+1
    734  0f42		       85 af		      sta	__negaMax+1	; -negaMax(...)
    735  0f44
    736  0f44
    737  0f44
    738  0f44							;	  if( score >= beta )
    739  0f44							;	      return beta;
    740  0f44
    741  0f44
    742  0f44		       38		      sec
    743  0f45		       a5 ae		      lda	__negaMax
      0  0f47					      sbc@PLY	beta
      1  0f47		       ed d4 f9 	      sbc	beta
    745  0f4a		       a5 af		      lda	__negaMax+1
      0  0f4c					      sbc@PLY	beta+1
      1  0f4c		       ed d5 f9 	      sbc	beta+1
    747  0f4f		       50 02		      bvc	.lab0
    748  0f51		       49 80		      eor	#$80
    749  0f53		       30 03	   .lab0      bmi	.nrb2	; .retBeta		       ; branch if score >= beta
    750  0f55		       4c d1 f6 	      jmp	.retBeta
    751  0f58				   .nrb2
    752  0f58
    753  0f58							;	  if( score > alpha )
    754  0f58							;	     alpha = score;
    755  0f58							;    }
    756  0f58
    757  0f58		       38		      sec
      0  0f59					      lda@PLY	alpha
      1  0f59		       ad d2 f9 	      lda	alpha
    759  0f5c		       e5 ae		      sbc	__negaMax
      0  0f5e					      lda@PLY	alpha+1
      1  0f5e		       ad d3 f9 	      lda	alpha+1
    761  0f61		       e5 af		      sbc	__negaMax+1
    762  0f63		       50 02		      bvc	.lab2
    763  0f65		       49 80		      eor	#$80
    764  0f67		       10 0a	   .lab2      bpl	.nextMove	; alpha >= score
    765  0f69
    766  0f69							; score > alpha
    767  0f69
    768  0f69		       a5 ae		      lda	__negaMax
      0  0f6b					      sta@PLY	alpha
      1  0f6b		       8d d2 fb 	      sta	[RAM]+alpha
    770  0f6e		       a5 af		      lda	__negaMax+1
      0  0f70					      sta@PLY	alpha+1
      1  0f70		       8d d3 fb 	      sta	[RAM]+alpha+1
    772  0f73
      0  0f73				   .nextMove  ldx@PLY	movePtr
      1  0f73		       ae d0 f9 	      ldx	movePtr
    774  0f76		       ca		      dex
    775  0f77		       10 8a		      bpl	.forChild
    776  0f79
    777  0f79							;    return alpha;
    778  0f79
    779  0f79				   .exit
      0  0f79					      lda@PLY	alpha
      1  0f79		       ad d2 f9 	      lda	alpha
    781  0f7c		       85 ae		      sta	__negaMax
      0  0f7e					      lda@PLY	alpha+1
      1  0f7e		       ad d3 f9 	      lda	alpha+1
    783  0f81		       85 af		      sta	__negaMax+1
    784  0f83		       60		      rts
    785  0f84
    786  0f84		       a9 00	   .inCheck   lda	#0
    787  0f86		       85 9f		      sta	flagCheck
    788  0f88		       f0 e9		      beq	.nextMove
    789  0f8a
    790  0f8a
    791  0f8a							;---------------------------------------------------------------------------------------------------
    792  0f8a
      0  0f8a					      END_BANK
      1  0f8a				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  0f8a				  -	      CHECK_RAM_BANK_SIZE
      3  0f8a					      ELSE
      0  0f8a					      CHECK_BANK_SIZE
      1  0f8a		       03 8a	   .TEMP      =	* - _BANK_START
 ROM bank # 4 NEGAMAX size = $38a free = 117
      2  0f8a					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  0f8a				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  0f8a				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  0f8a				  -	      ERR
      6  0f8a					      ENDIF
      5  0f8a					      ENDIF
    794  0f8a
    795  0f8a							;---------------------------------------------------------------------------------------------------
    796  0f8a							; EOF
------- FILE ./chess.asm
------- FILE @1 STATE MACHINE #1.asm LEVEL 2 PASS 4
      0  0f8a					      include	"@1 STATE MACHINE #1.asm"
      1  0f8a							;---------------------------------------------------------------------------------------------------
      2  0f8a							; @1 STATE MACHINE #1.asm
      3  0f8a
      4  0f8a							; Atari 2600 Chess
      5  0f8a							; Copyright (c) 2019-2020 Andrew Davie
      6  0f8a							; andrew@taswegian.com
      7  0f8a
      8  0f8a
      9  0f8a							;---------------------------------------------------------------------------------------------------
     10  0f8a
      0  0f8a					      SLOT	1
      1  0f8a
      2  0f8a				  -	      IF	(1 < 0) || (1 > 3)
      3  0f8a				  -	      ECHO	"Illegal bank address/segment location", 1
      4  0f8a				  -	      ERR
      5  0f8a					      ENDIF
      6  0f8a
      7  0f8a				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  0f8a				   _BANK_SLOT SET	1 * 64
      9  0f8a
      0  0f8a					      ROMBANK	STATEMACHINE
      1  13e6 ????				      SEG	ROM_STATEMACHINE
      2  1000					      ORG	_ORIGIN
      3  1000					      RORG	_BANK_ADDRESS_ORIGIN
      4  1000				   _BANK_START SET	*
      5  1000				   STATEMACHINE_START SET	*
      6  1000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  1000				   ROMBANK_STATEMACHINE SET	_BANK_SLOT + _CURRENT_BANK
      8  1000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  1000				   _LAST_BANK SETSTR	STATEMACHINE
     10  1000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  1000
     14  1000
     15  1000							; Banks holding data (ply 0 doubles as WHITE, and ply 1 as BLACK)
     16  1000
     17  1000
     18  1000		       00 10	   CURSOR_MOVE_SPEED =	16
     19  1000		       00 14	   CAP_SPEED  =	20
     20  1000		       00 28	   HOLD_DELAY =	40
     21  1000
     22  1000
     23  1000							;---------------------------------------------------------------------------------------------------
     24  1000
      0  1000					      DEF	aiStartMoveGen
      1  1000				   SLOT_aiStartMoveGen SET	_BANK_SLOT
      2  1000				   BANK_aiStartMoveGen SET	SLOT_aiStartMoveGen + _CURRENT_BANK
      3  1000				   aiStartMoveGen
      4  1000				   TEMPORARY_VAR SET	Overlay
      5  1000				   TEMPORARY_OFFSET SET	0
      6  1000				   VAR_BOUNDARY_aiStartMoveGen SET	TEMPORARY_OFFSET
      7  1000				   FUNCTION_NAME SET	aiStartMoveGen
     26  1000					      SUBROUTINE
     27  1000
      0  1000					      REF	AiStateMachine
      1  1000					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1000				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1000					      ENDIF
      0  1000					      VEND	aiStartMoveGen
      1  1000
      2  1000
      3  1000		       00 a9	   VAREND_aiStartMoveGen =	TEMPORARY_VAR
      4  1000
     30  1000
     31  1000							; To assist with castling, generate the moves for the opponent, giving us effectively
     32  1000							; a list of squares that are being attacked. The castling can't happen if the king is
     33  1000							; in check or if the squares it would have to move over are in check
     34  1000
     35  1000							; we don't need to worry about this if K has moved, or relevant R has moved or if
     36  1000							; the squares between are occupied. We can tell THAT by examining the movelist to see
     37  1000							; if there are K-moves marked "FLAG_CASTLE" - and the relevant squares
     38  1000
     39  1000							;inc currentPly
     40  1000							;jsr InitialiseMoveGeneration
     41  1000
      0  1000					      PHASE	StepMoveGen
      1  1000		       a9 0c		      lda	#AI_StepMoveGen
      2  1002		       85 8b		      sta	aiState
     43  1004		       60		      rts
     44  1005
     45  1005
     46  1005							;---------------------------------------------------------------------------------------------------
     47  1005
      0  1005					      DEF	aiInCheckBackupStart
      1  1005				   SLOT_aiInCheckBackupStart SET	_BANK_SLOT
      2  1005				   BANK_aiInCheckBackupStart SET	SLOT_aiInCheckBackupStart + _CURRENT_BANK
      3  1005				   aiInCheckBackupStart
      4  1005				   TEMPORARY_VAR SET	Overlay
      5  1005				   TEMPORARY_OFFSET SET	0
      6  1005				   VAR_BOUNDARY_aiInCheckBackupStart SET	TEMPORARY_OFFSET
      7  1005				   FUNCTION_NAME SET	aiInCheckBackupStart
     49  1005					      SUBROUTINE
     50  1005
      0  1005					      REF	AiStateMachine
      1  1005					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1005				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1005					      ENDIF
      0  1005					      VEND	aiInCheckBackupStart
      1  1005
      2  1005
      3  1005		       00 a9	   VAREND_aiInCheckBackupStart =	TEMPORARY_VAR
      4  1005
     53  1005
     54  1005		       a9 08		      lda	#8
     55  1007		       85 84		      sta	drawCount	; row to draw
     56  1009
      0  1009					      PHASE	InCheckBackup
      1  1009		       a9 1d		      lda	#AI_InCheckBackup
      2  100b		       85 8b		      sta	aiState
     58  100d		       60		      rts
     59  100e
     60  100e
     61  100e							;---------------------------------------------------------------------------------------------------
     62  100e
      0  100e					      DEF	aiInCheckBackup
      1  100e				   SLOT_aiInCheckBackup SET	_BANK_SLOT
      2  100e				   BANK_aiInCheckBackup SET	SLOT_aiInCheckBackup + _CURRENT_BANK
      3  100e				   aiInCheckBackup
      4  100e				   TEMPORARY_VAR SET	Overlay
      5  100e				   TEMPORARY_OFFSET SET	0
      6  100e				   VAR_BOUNDARY_aiInCheckBackup SET	TEMPORARY_OFFSET
      7  100e				   FUNCTION_NAME SET	aiInCheckBackup
     64  100e					      SUBROUTINE
     65  100e
      0  100e					      REF	AiStateMachine
      1  100e					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  100e				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  100e					      ENDIF
      0  100e					      VEND	aiInCheckBackup
      1  100e
      2  100e
      3  100e		       00 a9	   VAREND_aiInCheckBackup =	TEMPORARY_VAR
      4  100e
     68  100e
     69  100e		       20 ac f2 	      jsr	debug
     70  1011
     71  1011							; We're about to draw some large text on the screen
     72  1011							; Make a backup copy of all of the row bitmaps, so that we can restore once text is done
     73  1011
     74  1011		       c6 84		      dec	drawCount
     75  1013		       30 07		      bmi	.exit	; done all rows
     76  1015
      0  1015					      JUMP	BackupBitmaps	;@3
      1  1015				  -	      IF	SLOT_BackupBitmaps == _BANK_SLOT
      2  1015				  -FNAME      SETSTR	BackupBitmaps
      3  1015				  -	      ECHO	""
      4  1015				  -	      ECHO	"ERROR: Incompatible slot for jump to function", FNAME
      5  1015				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  1015				  -	      ERR
      7  1015					      ENDIF
      8  1015		       a9 d9		      lda	#BANK_BackupBitmaps
      9  1017		       85 3f		      sta	SET_BANK
     10  1019		       4c 5d fc 	      jmp	BackupBitmaps
     78  101c
     79  101c				   .exit
     80  101c
     81  101c		       a9 08		      lda	#8
     82  101e		       85 84		      sta	drawCount	; ROW
     83  1020
      0  1020					      PHASE	DrawBitmapBackground
      1  1020		       a9 2f		      lda	#AI_DrawBitmapBackground
      2  1022		       85 8b		      sta	aiState
     85  1024		       60		      rts
     86  1025
     87  1025
     88  1025							;---------------------------------------------------------------------------------------------------
     89  1025
      0  1025					      DEF	aiWaitBitmap
      1  1025				   SLOT_aiWaitBitmap SET	_BANK_SLOT
      2  1025				   BANK_aiWaitBitmap SET	SLOT_aiWaitBitmap + _CURRENT_BANK
      3  1025				   aiWaitBitmap
      4  1025				   TEMPORARY_VAR SET	Overlay
      5  1025				   TEMPORARY_OFFSET SET	0
      6  1025				   VAR_BOUNDARY_aiWaitBitmap SET	TEMPORARY_OFFSET
      7  1025				   FUNCTION_NAME SET	aiWaitBitmap
     91  1025					      SUBROUTINE
     92  1025
      0  1025					      REF	AiStateMachine
      1  1025					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1025				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1025					      ENDIF
      0  1025					      VEND	aiWaitBitmap
      1  1025
      2  1025
      3  1025		       00 a9	   VAREND_aiWaitBitmap =	TEMPORARY_VAR
      4  1025
     95  1025
     96  1025							;		      lda INPT4
     97  1025							;		      bmi .noButton
     98  1025							;PHASE DrawBitmap
     99  1025							;rts
    100  1025		       c6 84		      dec	drawCount
    101  1027		       a5 84		      lda	drawCount
    102  1029		       c9 dc		      cmp	#220
    103  102b		       d0 08		      bne	.noButton
    104  102d
    105  102d
    106  102d				   .button
    107  102d		       a9 08		      lda	#8
    108  102f		       85 84		      sta	drawCount	; ROW#
    109  1031
      0  1031					      PHASE	RestoreBitmaps
      1  1031		       a9 2d		      lda	#AI_RestoreBitmaps
      2  1033		       85 8b		      sta	aiState
    111  1035		       60	   .noButton  rts
    112  1036
    113  1036
    114  1036							;---------------------------------------------------------------------------------------------------
    115  1036
      0  1036					      DEF	aiRestoreBitmaps
      1  1036				   SLOT_aiRestoreBitmaps SET	_BANK_SLOT
      2  1036				   BANK_aiRestoreBitmaps SET	SLOT_aiRestoreBitmaps + _CURRENT_BANK
      3  1036				   aiRestoreBitmaps
      4  1036				   TEMPORARY_VAR SET	Overlay
      5  1036				   TEMPORARY_OFFSET SET	0
      6  1036				   VAR_BOUNDARY_aiRestoreBitmaps SET	TEMPORARY_OFFSET
      7  1036				   FUNCTION_NAME SET	aiRestoreBitmaps
    117  1036					      SUBROUTINE
    118  1036
    119  1036		       c6 84		      dec	drawCount
    120  1038		       30 07		      bmi	.exit	; done all rows
    121  103a
      0  103a					      JUMP	RestoreBitmaps	;@3
      1  103a				  -	      IF	SLOT_RestoreBitmaps == _BANK_SLOT
      2  103a				  -FNAME      SETSTR	RestoreBitmaps
      3  103a				  -	      ECHO	""
      4  103a				  -	      ECHO	"ERROR: Incompatible slot for jump to function", FNAME
      5  103a				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  103a				  -	      ERR
      7  103a					      ENDIF
      8  103a		       a9 d9		      lda	#BANK_RestoreBitmaps
      9  103c		       85 3f		      sta	SET_BANK
     10  103e		       4c 71 fc 	      jmp	RestoreBitmaps
    123  1041
    124  1041				   .exit
    125  1041
    126  1041		       a5 4c		      lda	INPT4
    127  1043		       30 05		      bmi	.noButton
      0  1045					      PHASE	SelectStartSquare
      1  1045		       a9 02		      lda	#AI_SelectStartSquare
      2  1047		       85 8b		      sta	aiState
    129  1049		       60		      rts
    130  104a				   .noButton
    131  104a							;		      PHASE InCheckDelay
    132  104a							;PHASE SelectStartSquare
      0  104a					      PHASE	InCheckBackupStart
      1  104a		       a9 2c		      lda	#AI_InCheckBackupStart
      2  104c		       85 8b		      sta	aiState
    134  104e		       60		      rts
    135  104f
    136  104f
    137  104f
    138  104f							;---------------------------------------------------------------------------------------------------
    139  104f
      0  104f					      DEF	aiInCheckDelay
      1  104f				   SLOT_aiInCheckDelay SET	_BANK_SLOT
      2  104f				   BANK_aiInCheckDelay SET	SLOT_aiInCheckDelay + _CURRENT_BANK
      3  104f				   aiInCheckDelay
      4  104f				   TEMPORARY_VAR SET	Overlay
      5  104f				   TEMPORARY_OFFSET SET	0
      6  104f				   VAR_BOUNDARY_aiInCheckDelay SET	TEMPORARY_OFFSET
      7  104f				   FUNCTION_NAME SET	aiInCheckDelay
    141  104f					      SUBROUTINE
    142  104f
      0  104f					      REF	AiStateMachine
      1  104f					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  104f				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  104f					      ENDIF
      0  104f					      VEND	aiInCheckDelay
      1  104f
      2  104f
      3  104f		       00 a9	   VAREND_aiInCheckDelay =	TEMPORARY_VAR
      4  104f
    145  104f
    146  104f		       c6 89		      dec	mdelay
    147  1051		       d0 08		      bne	.exit
    148  1053
    149  1053		       a9 00		      lda	#0
    150  1055		       85 49		      sta	COLUBK
    151  1057
      0  1057					      PHASE	BeginSelectMovePhase
      1  1057		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  1059		       85 8b		      sta	aiState
    153  105b		       60	   .exit      rts
    154  105c
    155  105c
    156  105c							;---------------------------------------------------------------------------------------------------
    157  105c
      0  105c					      DEF	aiBeginSelectMovePhase
      1  105c				   SLOT_aiBeginSelectMovePhase SET	_BANK_SLOT
      2  105c				   BANK_aiBeginSelectMovePhase SET	SLOT_aiBeginSelectMovePhase + _CURRENT_BANK
      3  105c				   aiBeginSelectMovePhase
      4  105c				   TEMPORARY_VAR SET	Overlay
      5  105c				   TEMPORARY_OFFSET SET	0
      6  105c				   VAR_BOUNDARY_aiBeginSelectMovePhase SET	TEMPORARY_OFFSET
      7  105c				   FUNCTION_NAME SET	aiBeginSelectMovePhase
    159  105c					      SUBROUTINE
    160  105c
      0  105c					      REF	AiStateMachine
      1  105c					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  105c				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  105c					      ENDIF
      0  105c					      VEND	aiBeginSelectMovePhase
      1  105c
      2  105c
      3  105c		       00 a9	   VAREND_aiBeginSelectMovePhase =	TEMPORARY_VAR
      4  105c
    163  105c
    164  105c		       a9 04		      lda	#$4
    165  105e		       85 46		      sta	COLUP0
    166  1060		       a2 04		      ldx	#%100
    167  1062		       86 4a		      stx	CTRLPF	; under
    168  1064
    169  1064		       a9 00		      lda	#0
    170  1066		       85 89		      sta	mdelay	;?
    171  1068		       85 8e		      sta	aiFlashPhase	; odd/even for flashing pieces
    172  106a
    173  106a		       a9 28		      lda	#CAP_SPEED*2
    174  106c		       85 8c		      sta	aiFlashDelay
    175  106e
    176  106e		       a9 ff		      lda	#-1
    177  1070		       85 85		      sta	fromX12
    178  1072		       85 86		      sta	toX12
    179  1074
    180  1074		       46 a1		      lsr	randomness
    181  1076
    182  1076
      0  1076					      PHASE	FlashComputerMove
      1  1076		       a9 00		      lda	#AI_FlashComputerMove
      2  1078		       85 8b		      sta	aiState
    184  107a		       60		      rts
    185  107b
    186  107b							;---------------------------------------------------------------------------------------------------
    187  107b
      0  107b					      DEF	aiFlashComputerMove
      1  107b				   SLOT_aiFlashComputerMove SET	_BANK_SLOT
      2  107b				   BANK_aiFlashComputerMove SET	SLOT_aiFlashComputerMove + _CURRENT_BANK
      3  107b				   aiFlashComputerMove
      4  107b				   TEMPORARY_VAR SET	Overlay
      5  107b				   TEMPORARY_OFFSET SET	0
      6  107b				   VAR_BOUNDARY_aiFlashComputerMove SET	TEMPORARY_OFFSET
      7  107b				   FUNCTION_NAME SET	aiFlashComputerMove
    189  107b					      SUBROUTINE
    190  107b
      0  107b					      REF	Variable_PieceShapeBuffer
      1  107b					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  107b				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  107b					      ENDIF
      0  107b					      REF	AiStateMachine
      1  107b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  107b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  107b					      ENDIF
      0  107b					      VEND	aiFlashComputerMove
      1  107b
      2  107b
      3  107b		       00 ef	   VAREND_aiFlashComputerMove =	TEMPORARY_VAR
      4  107b
    194  107b
    195  107b		       a5 80		      lda	squareToDraw
    196  107d		       30 30		      bmi	.initial2	; startup - no computer move to show
    197  107f
    198  107f		       a5 8e		      lda	aiFlashPhase
    199  1081		       4a		      lsr
    200  1082		       b0 0c		      bcs	.noSwapside	; only check for SELECT/exit if piece is drawn
    201  1084
    202  1084		       ad 82 02 	      lda	SWCHB
    203  1087		       29 02		      and	#SELECT_SWITCH
    204  1089		       d0 05		      bne	.noSwapside
    205  108b
      0  108b					      PHASE	DebounceSelect
      1  108b		       a9 2b		      lda	#AI_DebounceSelect
      2  108d		       85 8b		      sta	aiState
    207  108f		       60		      rts
    208  1090				   .noSwapside
    209  1090
    210  1090							; "squareToDraw" is the piece that should flash while human waits
    211  1090
    212  1090		       ad 80 02 	      lda	SWCHA
    213  1093		       29 f0		      and	#$F0	; UDLR bits
    214  1095		       c9 f0		      cmp	#$F0	; all NOT pressed
    215  1097		       f0 08		      beq	.nodir
    216  1099
    217  1099							; direction has been pressed, so transition out of flashing
    218  1099
    219  1099		       a9 01		      lda	#1
    220  109b		       85 8c		      sta	aiFlashDelay
    221  109d		       25 8e		      and	aiFlashPhase
    222  109f		       f0 0e		      beq	.initial
    223  10a1
    224  10a1		       c6 8c	   .nodir     dec	aiFlashDelay
    225  10a3		       d0 13		      bne	.exit	; don't flash
    226  10a5		       a9 28		      lda	#CAP_SPEED*2
    227  10a7		       85 8c		      sta	aiFlashDelay
    228  10a9
    229  10a9		       e6 8e		      inc	aiFlashPhase
    230  10ab
    231  10ab							; WARNING - local variables will not survive the following call...!
    232  10ab		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    233  10ae		       60		      rts
    234  10af
    235  10af				   .initial
    236  10af
    237  10af							;SWAP
    238  10af				   .initial2
    239  10af
    240  10af
      0  10af					      PHASE	InCheckBackupStart	;tmp
      1  10af		       a9 2c		      lda	#AI_InCheckBackupStart
      2  10b1		       85 8b		      sta	aiState
    242  10b3		       60		      rts
    243  10b4
    244  10b4
      0  10b4					      PHASE	SelectStartSquare
      1  10b4		       a9 02		      lda	#AI_SelectStartSquare
      2  10b6		       85 8b		      sta	aiState
    246  10b8
    247  10b8		       60	   .exit      rts
    248  10b9
    249  10b9
    250  10b9							;---------------------------------------------------------------------------------------------------
    251  10b9
      0  10b9					      DEF	aiSelectStartSquare
      1  10b9				   SLOT_aiSelectStartSquare SET	_BANK_SLOT
      2  10b9				   BANK_aiSelectStartSquare SET	SLOT_aiSelectStartSquare + _CURRENT_BANK
      3  10b9				   aiSelectStartSquare
      4  10b9				   TEMPORARY_VAR SET	Overlay
      5  10b9				   TEMPORARY_OFFSET SET	0
      6  10b9				   VAR_BOUNDARY_aiSelectStartSquare SET	TEMPORARY_OFFSET
      7  10b9				   FUNCTION_NAME SET	aiSelectStartSquare
    253  10b9					      SUBROUTINE
    254  10b9
      0  10b9					      REF	AiStateMachine
      1  10b9					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  10b9				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  10b9					      ENDIF
      0  10b9					      VEND	aiSelectStartSquare
      1  10b9
      2  10b9
      3  10b9		       00 a9	   VAREND_aiSelectStartSquare =	TEMPORARY_VAR
      4  10b9
    257  10b9
      0  10b9					      NEXT_RANDOM
      1  10b9
      2  10b9		       a5 81		      lda	rnd
      3  10bb		       4a		      lsr
      4  10bc		       90 02		      bcc	.skipEOR
      5  10be		       49 b4		      eor	#RND_EOR_VAL
      6  10c0		       85 81	   .skipEOR   sta	rnd
      7  10c2
    259  10c2
    260  10c2		       ad 82 02 	      lda	SWCHB
    261  10c5		       29 02		      and	#SELECT_SWITCH
    262  10c7		       f0 34		      beq	.swapside
    263  10c9
      0  10c9					      CALL	moveCursor	;@2
      1  10c9				  -	      IF	SLOT_moveCursor == _BANK_SLOT
      2  10c9				  -FNAME      SETSTR	moveCursor
      3  10c9				  -	      ECHO	""
      4  10c9				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  10c9				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  10c9				  -	      ERR
      7  10c9					      ENDIF
      8  10c9		       a9 8a		      lda	#BANK_moveCursor
      9  10cb		       85 3f		      sta	SET_BANK
     10  10cd		       20 00 f8 	      jsr	moveCursor
    265  10d0
    266  10d0							; Search the player's movelist for the square, so we can set cursor colour
    267  10d0
    268  10d0		       a9 89		      lda	#RAMBANK_PLY+1	;currentPly
    269  10d2		       85 3e		      sta	SET_BANK_RAM	;@2
    270  10d4
    271  10d4		       a5 88		      lda	cursorX12
    272  10d6		       85 85		      sta	fromX12
    273  10d8
      0  10d8					      ldy@PLY	moveIndex
      1  10d8		       ac cf f9 	      ldy	moveIndex
    275  10db		       30 0d		      bmi	.done
    276  10dd
    277  10dd		       d9 00 f8    .scan      cmp	MoveFrom,y
    278  10e0		       f0 03		      beq	.scanned
    279  10e2		       88		      dey
    280  10e3		       10 f8		      bpl	.scan
    281  10e5
      0  10e5				   .scanned   lda@PLY	MovePiece,y
      1  10e5		       b9 00 f9 	      lda	MovePiece,y
    283  10e8		       85 96		      sta	fromPiece
    284  10ea
    285  10ea		       c6 8a	   .done      dec	ccur	; pulse colour for valid squares
      0  10ec					      CALL	setCursorColours
      1  10ec				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  10ec				  -FNAME      SETSTR	setCursorColours
      3  10ec				  -	      ECHO	""
      4  10ec				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  10ec				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  10ec				  -	      ERR
      7  10ec					      ENDIF
      8  10ec		       a9 8a		      lda	#BANK_setCursorColours
      9  10ee		       85 3f		      sta	SET_BANK
     10  10f0		       20 4a f8 	      jsr	setCursorColours
    287  10f3
    288  10f3		       98		      tya
    289  10f4		       05 4c		      ora	INPT4
    290  10f6		       30 04		      bmi	.exit	; illegal square or no button press
    291  10f8
      0  10f8					      PHASE	StartSquareSelected
      1  10f8		       a9 03		      lda	#AI_StartSquareSelected
      2  10fa		       85 8b		      sta	aiState
    293  10fc
    294  10fc		       60	   .exit      rts
    295  10fd
    296  10fd
    297  10fd
    298  10fd				   .swapside
    299  10fd
      0  10fd					      PHASE	DebounceSelect
      1  10fd		       a9 2b		      lda	#AI_DebounceSelect
      2  10ff		       85 8b		      sta	aiState
    301  1101		       60		      rts
    302  1102
    303  1102							;---------------------------------------------------------------------------------------------------
    304  1102
      0  1102					      DEF	aiDebounceSelect
      1  1102				   SLOT_aiDebounceSelect SET	_BANK_SLOT
      2  1102				   BANK_aiDebounceSelect SET	SLOT_aiDebounceSelect + _CURRENT_BANK
      3  1102				   aiDebounceSelect
      4  1102				   TEMPORARY_VAR SET	Overlay
      5  1102				   TEMPORARY_OFFSET SET	0
      6  1102				   VAR_BOUNDARY_aiDebounceSelect SET	TEMPORARY_OFFSET
      7  1102				   FUNCTION_NAME SET	aiDebounceSelect
    306  1102					      SUBROUTINE
    307  1102
    308  1102		       ad 82 02 	      lda	SWCHB
    309  1105		       29 02		      and	#SELECT_SWITCH
    310  1107		       f0 17		      beq	.exit	; SELECT still pressed
    311  1109
    312  1109		       a5 95		      lda	sideToMove
    313  110b		       49 40		      eor	#HUMAN
    314  110d		       85 95		      sta	sideToMove
    315  110f
      0  110f					      NEGEVAL
      1  110f
      2  110f		       38		      sec
      3  1110		       a9 00		      lda	#0
      4  1112		       e5 8f		      sbc	Evaluation
      5  1114		       85 8f		      sta	Evaluation
      6  1116		       a9 00		      lda	#0
      7  1118		       e5 90		      sbc	Evaluation+1
      8  111a		       85 90		      sta	Evaluation+1
      9  111c
    317  111c
      0  111c					      PHASE	ComputerMove
      1  111c		       a9 13		      lda	#AI_ComputerMove
      2  111e		       85 8b		      sta	aiState
    319  1120		       60	   .exit      rts
    320  1121
    321  1121
    322  1121							;---------------------------------------------------------------------------------------------------
    323  1121
      0  1121					      DEF	aiDrawMoves
      1  1121				   SLOT_aiDrawMoves SET	_BANK_SLOT
      2  1121				   BANK_aiDrawMoves SET	SLOT_aiDrawMoves + _CURRENT_BANK
      3  1121				   aiDrawMoves
      4  1121				   TEMPORARY_VAR SET	Overlay
      5  1121				   TEMPORARY_OFFSET SET	0
      6  1121				   VAR_BOUNDARY_aiDrawMoves SET	TEMPORARY_OFFSET
      7  1121				   FUNCTION_NAME SET	aiDrawMoves
    325  1121					      SUBROUTINE
    326  1121
      0  1121					      REF	AiStateMachine
      1  1121					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1121				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1121					      ENDIF
      0  1121					      VEND	aiDrawMoves
      1  1121
      2  1121
      3  1121		       00 a9	   VAREND_aiDrawMoves =	TEMPORARY_VAR
      4  1121
    329  1121
    330  1121		       c6 8a		      dec	ccur
      0  1123					      CALL	setCursorColours
      1  1123				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  1123				  -FNAME      SETSTR	setCursorColours
      3  1123				  -	      ECHO	""
      4  1123				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  1123				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  1123				  -	      ERR
      7  1123					      ENDIF
      8  1123		       a9 8a		      lda	#BANK_setCursorColours
      9  1125		       85 3f		      sta	SET_BANK
     10  1127		       20 4a f8 	      jsr	setCursorColours
    332  112a
    333  112a		       c6 89		      dec	mdelay
    334  112c		       d0 25		      bne	.exit
    335  112e		       a9 01		      lda	#1	; larger number will slow the draw of available moves
    336  1130		       85 89		      sta	mdelay	; once triggered, runs always
    337  1132
    338  1132		       a5 8d		      lda	aiMoveIndex
    339  1134		       10 09		      bpl	.valid
    340  1136
    341  1136		       a9 89		      lda	#RAMBANK_PLY+1
    342  1138		       85 3e		      sta	SET_BANK_RAM	;@2
      0  113a					      lda@PLY	moveIndex
      1  113a		       ad cf f9 	      lda	moveIndex
    344  113d		       85 8d		      sta	aiMoveIndex
    345  113f				   .valid
    346  113f
    347  113f		       20 60 f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    348  1142		       a5 8d		      lda	aiMoveIndex
    349  1144		       10 19		      bpl	.unsure	; still drawing in this phase
    350  1146
    351  1146		       a9 14		      lda	#CAP_SPEED
    352  1148		       85 89		      sta	mdelay
    353  114a
    354  114a		       a9 00		      lda	#0
    355  114c		       85 8e		      sta	aiFlashPhase	; controls odd/even exit of flashing
    356  114e
      0  114e					      PHASE	ShowMoveCaptures
      1  114e		       a9 05		      lda	#AI_ShowMoveCaptures
      2  1150		       85 8b		      sta	aiState
    358  1152		       60		      rts
    359  1153
    360  1153				   .exit
    361  1153
    362  1153							; Initial piece selection has happened, but the button hasn't been released yet
    363  1153							; AND we're still in the waiting phase to see if the button was held long enough for move show
    364  1153
    365  1153		       a5 4c		      lda	INPT4
    366  1155		       10 08		      bpl	.unsure	; button still pressed, so still unsure what to do
    367  1157
    368  1157							; Aha! Button released, so we know the selected piece and can start flashing it
    369  1157							; and allowing movement of the selector to a destination square...
    370  1157
    371  1157		       a9 18		      lda	#6*4
    372  1159		       85 8a		      sta	ccur	; bright green square for selection
    373  115b
      0  115b					      PHASE	SelectDestinationSquare
      1  115b		       a9 08		      lda	#AI_SelectDestinationSquare
      2  115d		       85 8b		      sta	aiState
    375  115f
    376  115f		       60	   .unsure    rts
    377  1160
    378  1160
    379  1160							;---------------------------------------------------------------------------------------------------
    380  1160
      0  1160					      DEF	showMoveOptions
      1  1160				   SLOT_showMoveOptions SET	_BANK_SLOT
      2  1160				   BANK_showMoveOptions SET	SLOT_showMoveOptions + _CURRENT_BANK
      3  1160				   showMoveOptions
      4  1160				   TEMPORARY_VAR SET	Overlay
      5  1160				   TEMPORARY_OFFSET SET	0
      6  1160				   VAR_BOUNDARY_showMoveOptions SET	TEMPORARY_OFFSET
      7  1160				   FUNCTION_NAME SET	showMoveOptions
    382  1160					      SUBROUTINE
    383  1160
      0  1160					      REF	aiDrawMoves
      1  1160					      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  1160				   TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  1160					      ENDIF
      0  1160					      REF	aiUnDrawTargetSquares
      1  1160				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  1160				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  1160					      ENDIF
    386  1160
      0  1160					      VAR	__saveIdx, 1
      1  1160
      2  1160		       00 a9	   __saveIdx  =	TEMPORARY_VAR
      3  1160				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  1160
      5  1160				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  1160				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  1160				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  1160					      ENDIF
      9  1160				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  1160				  -	      LIST	ON
     11  1160				  -VNAME      SETSTR	__saveIdx
     12  1160				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  1160				  -	      ERR
     14  1160				  -	      ECHO	"Temporary Variable overlow!"
     15  1160					      ENDIF
     16  1160					      LIST	ON
      0  1160					      VAR	__piece, 1
      1  1160
      2  1160		       00 aa	   __piece    =	TEMPORARY_VAR
      3  1160				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  1160
      5  1160				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  1160				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  1160				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  1160					      ENDIF
      9  1160				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  1160				  -	      LIST	ON
     11  1160				  -VNAME      SETSTR	__piece
     12  1160				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  1160				  -	      ERR
     14  1160				  -	      ECHO	"Temporary Variable overlow!"
     15  1160					      ENDIF
     16  1160					      LIST	ON
    389  1160
      0  1160					      VEND	showMoveOptions
      1  1160
      2  1160
      3  1160		       00 ab	   VAREND_showMoveOptions =	TEMPORARY_VAR
      4  1160
    391  1160
    392  1160							; place a marker on the board for any square matching the piece
    393  1160							; EXCEPT for squares which are occupied (we'll flash those later)
    394  1160
    395  1160		       a6 8d	   .next      ldx	aiMoveIndex
    396  1162		       86 a9		      stx	__saveIdx
    397  1164		       30 4c		      bmi	.skip
    398  1166
    399  1166		       ad 84 02 	      lda	INTIM
    400  1169		       c9 2b		      cmp	#2+SPEEDOF_CopySinglePiece
    401  116b		       90 45		      bcc	.skip
    402  116d
    403  116d		       c6 8d		      dec	aiMoveIndex
    404  116f
    405  116f		       a9 89		      lda	#RAMBANK_PLY+1
    406  1171		       85 3e		      sta	SET_BANK_RAM	;@2
    407  1173
      0  1173					      lda@PLY	MoveFrom,x
      1  1173		       bd 00 f8 	      lda	MoveFrom,x
    409  1176		       c5 85		      cmp	fromX12
    410  1178		       d0 e6		      bne	.next
    411  117a
      0  117a					      lda@PLY	MoveTo,x
      1  117a		       bd 64 f8 	      lda	MoveTo,x
    413  117d		       85 80		      sta	squareToDraw
    414  117f
      0  117f					      lda@PLY	MovePiece,x
      1  117f		       bd 00 f9 	      lda	MovePiece,x
    416  1182		       85 aa		      sta	__piece
    417  1184
    418  1184							; If it's a pawn promote (duplicate "to" AND piece different (TODO) then skip others)
    419  1184							; TODO this could/will fail on sorted lists. MMh.
    420  1184
    421  1184		       ca		      dex
    422  1185		       30 16		      bmi	.prom
    423  1187
      0  1187					      lda@PLY	MoveTo,x
      1  1187		       bd 64 f8 	      lda	MoveTo,x
    425  118a		       c5 80		      cmp	squareToDraw
    426  118c		       d0 0f		      bne	.prom
    427  118e
      0  118e					      lda@PLY	MovePiece,x
      1  118e		       bd 00 f9 	      lda	MovePiece,x
    429  1191		       45 aa		      eor	__piece
    430  1193		       29 0f		      and	#PIECE_MASK
    431  1195		       f0 06		      beq	.prom	; same piece type so not a promote
    432  1197
    433  1197		       c6 8d		      dec	aiMoveIndex
    434  1199		       c6 8d		      dec	aiMoveIndex
    435  119b		       c6 8d		      dec	aiMoveIndex
    436  119d				   .prom
    437  119d
    438  119d		       a4 80		      ldy	squareToDraw
    439  119f
    440  119f		       a9 d0		      lda	#RAMBANK_BOARD
    441  11a1		       85 3e		      sta	SET_BANK_RAM	;@3
    442  11a3		       b9 79 fc 	      lda	Board,y
    443  11a6		       29 0f		      and	#PIECE_MASK
    444  11a8		       d0 b6		      bne	.next	; don't draw dots on captures - they are flashed later
    445  11aa
    446  11aa
    447  11aa							;lda INTIM
    448  11aa							;cmp #SPEEDOF_CopySinglePiece
    449  11aa							;bcc .skip
    450  11aa
    451  11aa							;lda aiMoveIndex
    452  11aa							;sta __saveIdx
    453  11aa
    454  11aa							; Draw the marker..."?
    455  11aa							; WARNING - local variables will not survive the following call...!
    456  11aa
    457  11aa		       a0 1c		      ldy	#INDEX_WHITE_MARKER_on_WHITE_SQUARE_0
    458  11ac		       20 b7 f5 	      jsr	CopySetupForMarker	;@this
    459  11af		       4c c8 f0 	      jmp	InterceptMarkerCopy	;@0
    460  11b2
    461  11b2
    462  11b2
    463  11b2		       a5 a9	   .skip      lda	__saveIdx
    464  11b4		       85 8d		      sta	aiMoveIndex
    465  11b6		       60		      rts
    466  11b7
    467  11b7
    468  11b7							;---------------------------------------------------------------------------------------------------
    469  11b7
      0  11b7					      DEF	CopySetupForMarker
      1  11b7				   SLOT_CopySetupForMarker SET	_BANK_SLOT
      2  11b7				   BANK_CopySetupForMarker SET	SLOT_CopySetupForMarker + _CURRENT_BANK
      3  11b7				   CopySetupForMarker
      4  11b7				   TEMPORARY_VAR SET	Overlay
      5  11b7				   TEMPORARY_OFFSET SET	0
      6  11b7				   VAR_BOUNDARY_CopySetupForMarker SET	TEMPORARY_OFFSET
      7  11b7				   FUNCTION_NAME SET	CopySetupForMarker
    471  11b7					      SUBROUTINE
    472  11b7
      0  11b7					      REF	showMoveOptions
      1  11b7					      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  11b7				   TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  11b7					      ENDIF
      0  11b7					      REF	showPromoteOptions
      1  11b7					      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  11b7				   TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  11b7					      ENDIF
    475  11b7
      0  11b7					      VAR	__pieceColour2b, 1
      1  11b7
      2  11b7		       00 ef	   __pieceColour2b =	TEMPORARY_VAR
      3  11b7				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  11b7
      5  11b7				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  11b7					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  11b7				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  11b7					      ENDIF
      9  11b7				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  11b7				  -	      LIST	ON
     11  11b7				  -VNAME      SETSTR	__pieceColour2b
     12  11b7				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  11b7				  -	      ERR
     14  11b7				  -	      ECHO	"Temporary Variable overlow!"
     15  11b7					      ENDIF
     16  11b7					      LIST	ON
      0  11b7					      VAR	__tmpb, 1
      1  11b7
      2  11b7		       00 f0	   __tmpb     =	TEMPORARY_VAR
      3  11b7				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  11b7
      5  11b7				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  11b7					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  11b7				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  11b7					      ENDIF
      9  11b7				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  11b7				  -	      LIST	ON
     11  11b7				  -VNAME      SETSTR	__tmpb
     12  11b7				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  11b7				  -	      ERR
     14  11b7				  -	      ECHO	"Temporary Variable overlow!"
     15  11b7					      ENDIF
     16  11b7					      LIST	ON
      0  11b7					      VAR	__shiftxb, 1
      1  11b7
      2  11b7		       00 f1	   __shiftxb  =	TEMPORARY_VAR
      3  11b7				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  11b7
      5  11b7				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  11b7					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  11b7				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  11b7					      ENDIF
      9  11b7				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  11b7				  -	      LIST	ON
     11  11b7				  -VNAME      SETSTR	__shiftxb
     12  11b7				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  11b7				  -	      ERR
     14  11b7				  -	      ECHO	"Temporary Variable overlow!"
     15  11b7					      ENDIF
     16  11b7					      LIST	ON
    479  11b7
      0  11b7					      VEND	CopySetupForMarker
      1  11b7
      2  11b7
      3  11b7		       00 f2	   VAREND_CopySetupForMarker =	TEMPORARY_VAR
      4  11b7
    481  11b7
    482  11b7
    483  11b7							; y = base shape
    484  11b7							; figure colouration of square
    485  11b7
    486  11b7		       a5 80		      lda	squareToDraw
    487  11b9
    488  11b9		       a2 0a		      ldx	#10
    489  11bb		       38		      sec
    490  11bc		       e9 0a	   .sub10     sbc	#10
    491  11be		       ca		      dex
    492  11bf		       b0 fb		      bcs	.sub10
    493  11c1		       69 08		      adc	#8
    494  11c3		       85 f1		      sta	__shiftxb
    495  11c5		       86 f0		      stx	__tmpb
    496  11c7		       65 f0		      adc	__tmpb
    497  11c9
    498  11c9
    499  11c9		       29 01		      and	#1
    500  11cb							;eor #1
    501  11cb		       f0 02		      beq	.white
    502  11cd		       a9 24		      lda	#36
    503  11cf				   .white
    504  11cf		       85 ef		      sta	__pieceColour2b	; actually SQUARE black/white
    505  11d1
    506  11d1		       a5 95		      lda	sideToMove
    507  11d3		       0a		      asl
    508  11d4		       90 02		      bcc	.blackAdjust
    509  11d6		       09 10		      ora	#16	; switch white pieces
    510  11d8		       4a	   .blackAdjust lsr
    511  11d9		       29 0f		      and	#%1111
    512  11db		       aa		      tax
    513  11dc
    514  11dc		       a5 f1		      lda	__shiftxb
    515  11de		       29 03		      and	#3	; shift position in P
    516  11e0		       85 f1		      sta	__shiftxb
    517  11e2
    518  11e2		       98		      tya
    519  11e3		       18		      clc
    520  11e4		       65 f1		      adc	__shiftxb
    521  11e6		       18		      clc
    522  11e7		       65 ef		      adc	__pieceColour2b
    523  11e9		       a8		      tay
    524  11ea		       60		      rts
    525  11eb
    526  11eb
    527  11eb							;---------------------------------------------------------------------------------------------------
    528  11eb
      0  11eb					      DEF	aiUnDrawTargetSquares
      1  11eb				   SLOT_aiUnDrawTargetSquares SET	_BANK_SLOT
      2  11eb				   BANK_aiUnDrawTargetSquares SET	SLOT_aiUnDrawTargetSquares + _CURRENT_BANK
      3  11eb				   aiUnDrawTargetSquares
      4  11eb				   TEMPORARY_VAR SET	Overlay
      5  11eb				   TEMPORARY_OFFSET SET	0
      6  11eb				   VAR_BOUNDARY_aiUnDrawTargetSquares SET	TEMPORARY_OFFSET
      7  11eb				   FUNCTION_NAME SET	aiUnDrawTargetSquares
    530  11eb					      SUBROUTINE
    531  11eb
      0  11eb					      REF	AiStateMachine
      1  11eb					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  11eb				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  11eb					      ENDIF
      0  11eb					      VEND	aiUnDrawTargetSquares
      1  11eb
      2  11eb
      3  11eb		       00 a9	   VAREND_aiUnDrawTargetSquares =	TEMPORARY_VAR
      4  11eb
    534  11eb
    535  11eb
    536  11eb		       c6 8a		      dec	ccur
      0  11ed					      CALL	setCursorColours
      1  11ed				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  11ed				  -FNAME      SETSTR	setCursorColours
      3  11ed				  -	      ECHO	""
      4  11ed				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  11ed				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  11ed				  -	      ERR
      7  11ed					      ENDIF
      8  11ed		       a9 8a		      lda	#BANK_setCursorColours
      9  11ef		       85 3f		      sta	SET_BANK
     10  11f1		       20 4a f8 	      jsr	setCursorColours
    538  11f4
    539  11f4		       c6 89		      dec	mdelay
    540  11f6		       d0 1c		      bne	.exit
    541  11f8		       a9 01		      lda	#1
    542  11fa		       85 89		      sta	mdelay	; once triggered, runs always
    543  11fc
    544  11fc		       a5 8d		      lda	aiMoveIndex
    545  11fe		       10 09		      bpl	.valid
    546  1200
    547  1200		       a9 89		      lda	#RAMBANK_PLY+1
    548  1202		       85 3e		      sta	SET_BANK_RAM	;@2
      0  1204					      lda@PLY	moveIndex
      1  1204		       ad cf f9 	      lda	moveIndex
    550  1207		       85 8d		      sta	aiMoveIndex
    551  1209				   .valid
    552  1209
    553  1209		       20 60 f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    554  120c		       a5 8d		      lda	aiMoveIndex
    555  120e		       10 04		      bpl	.exit	; still drawing in this phase
    556  1210
      0  1210					      PHASE	SelectStartSquare
      1  1210		       a9 02		      lda	#AI_SelectStartSquare
      2  1212		       85 8b		      sta	aiState
    558  1214
    559  1214		       60	   .exit      rts
    560  1215
    561  1215
    562  1215							;---------------------------------------------------------------------------------------------------
    563  1215
    564  1215
      0  1215					      DEF	aiShowMoveCaptures
      1  1215				   SLOT_aiShowMoveCaptures SET	_BANK_SLOT
      2  1215				   BANK_aiShowMoveCaptures SET	SLOT_aiShowMoveCaptures + _CURRENT_BANK
      3  1215				   aiShowMoveCaptures
      4  1215				   TEMPORARY_VAR SET	Overlay
      5  1215				   TEMPORARY_OFFSET SET	0
      6  1215				   VAR_BOUNDARY_aiShowMoveCaptures SET	TEMPORARY_OFFSET
      7  1215				   FUNCTION_NAME SET	aiShowMoveCaptures
    566  1215					      SUBROUTINE
    567  1215
      0  1215					      REF	AiStateMachine
      1  1215					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1215				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1215					      ENDIF
      0  1215					      VEND	aiShowMoveCaptures
      1  1215
      2  1215
      3  1215		       00 a9	   VAREND_aiShowMoveCaptures =	TEMPORARY_VAR
      4  1215
    570  1215
    571  1215							; draw/undraw ALL captured pieces
    572  1215							; we should do this an even number of times so that pieces don't disappEOR
    573  1215
    574  1215		       c6 8a		      dec	ccur
      0  1217					      CALL	setCursorColours
      1  1217				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  1217				  -FNAME      SETSTR	setCursorColours
      3  1217				  -	      ECHO	""
      4  1217				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  1217				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  1217				  -	      ERR
      7  1217					      ENDIF
      8  1217		       a9 8a		      lda	#BANK_setCursorColours
      9  1219		       85 3f		      sta	SET_BANK
     10  121b		       20 4a f8 	      jsr	setCursorColours
    576  121e
    577  121e		       c6 89		      dec	mdelay	; flash speed UNVARYING despite draw happening
    578  1220
    579  1220		       a5 8d		      lda	aiMoveIndex
    580  1222		       10 09		      bpl	.valid	; guaranteed -1 on 1st call
    581  1224		       a9 89		      lda	#RAMBANK_PLY+1
    582  1226		       85 3e		      sta	SET_BANK_RAM	;@2
      0  1228					      lda@PLY	moveIndex
      1  1228		       ad cf f9 	      lda	moveIndex
    584  122b		       85 8d		      sta	aiMoveIndex
    585  122d				   .valid
    586  122d
    587  122d							;lda #BANK_showMoveCaptures
    588  122d							;sta SET_BANK;@0
    589  122d
    590  122d		       20 ff f2 	      jsr	showMoveCaptures	;@0
    591  1230		       a5 8d		      lda	aiMoveIndex
    592  1232		       10 06		      bpl	.exit
    593  1234
    594  1234		       e6 8e		      inc	aiFlashPhase
    595  1236
      0  1236					      PHASE	SlowFlash
      1  1236		       a9 06		      lda	#AI_SlowFlash
      2  1238		       85 8b		      sta	aiState
    597  123a
    598  123a		       60	   .exit      rts
    599  123b
    600  123b
    601  123b							;---------------------------------------------------------------------------------------------------
    602  123b
      0  123b					      DEF	aiSlowFlash
      1  123b				   SLOT_aiSlowFlash SET	_BANK_SLOT
      2  123b				   BANK_aiSlowFlash SET	SLOT_aiSlowFlash + _CURRENT_BANK
      3  123b				   aiSlowFlash
      4  123b				   TEMPORARY_VAR SET	Overlay
      5  123b				   TEMPORARY_OFFSET SET	0
      6  123b				   VAR_BOUNDARY_aiSlowFlash SET	TEMPORARY_OFFSET
      7  123b				   FUNCTION_NAME SET	aiSlowFlash
    604  123b					      SUBROUTINE
    605  123b
      0  123b					      REF	AiStateMachine
      1  123b					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  123b				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  123b					      ENDIF
      0  123b					      VEND	aiSlowFlash
      1  123b
      2  123b
      3  123b		       00 a9	   VAREND_aiSlowFlash =	TEMPORARY_VAR
      4  123b
    608  123b
    609  123b							; Joystick button is held down, so we're displaying the available moves
    610  123b							; They have all been drawn, so now we "slow" flash any pieces that can be captures
    611  123b
    612  123b		       c6 8a		      dec	ccur
      0  123d					      CALL	setCursorColours
      1  123d				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  123d				  -FNAME      SETSTR	setCursorColours
      3  123d				  -	      ECHO	""
      4  123d				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  123d				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  123d				  -	      ERR
      7  123d					      ENDIF
      8  123d		       a9 8a		      lda	#BANK_setCursorColours
      9  123f		       85 3f		      sta	SET_BANK
     10  1241		       20 4a f8 	      jsr	setCursorColours
    614  1244
    615  1244		       a5 8e		      lda	aiFlashPhase
    616  1246		       29 01		      and	#1
    617  1248		       d0 04		      bne	.notEven	; only exit after even # EOR-draws
    618  124a
    619  124a		       a5 4c		      lda	INPT4
    620  124c		       30 0d		      bmi	.butpress	; exit on button release
    621  124e
    622  124e				   .notEven
    623  124e
    624  124e							; Wait for delay to expire then back and flash 'em again
    625  124e
    626  124e		       c6 89		      dec	mdelay
    627  1250		       10 08		      bpl	.slowWait
    628  1252
    629  1252		       a9 14		      lda	#CAP_SPEED
    630  1254		       85 89		      sta	mdelay
    631  1256
      0  1256					      PHASE	ShowMoveCaptures	; go back and rEORdraw all captures again
      1  1256		       a9 05		      lda	#AI_ShowMoveCaptures
      2  1258		       85 8b		      sta	aiState
    633  125a
    634  125a		       60	   .slowWait  rts
    635  125b
    636  125b
    637  125b		       a9 01	   .butpress  lda	#1
    638  125d		       85 89		      sta	mdelay
    639  125f
      0  125f					      PHASE	UnDrawTargetSquares
      1  125f		       a9 07		      lda	#AI_UnDrawTargetSquares
      2  1261		       85 8b		      sta	aiState
    641  1263		       60		      rts
    642  1264
    643  1264
    644  1264							;---------------------------------------------------------------------------------------------------
    645  1264
      0  1264					      DEF	aiSelectDestinationSquare
      1  1264				   SLOT_aiSelectDestinationSquare SET	_BANK_SLOT
      2  1264				   BANK_aiSelectDestinationSquare SET	SLOT_aiSelectDestinationSquare + _CURRENT_BANK
      3  1264				   aiSelectDestinationSquare
      4  1264				   TEMPORARY_VAR SET	Overlay
      5  1264				   TEMPORARY_OFFSET SET	0
      6  1264				   VAR_BOUNDARY_aiSelectDestinationSquare SET	TEMPORARY_OFFSET
      7  1264				   FUNCTION_NAME SET	aiSelectDestinationSquare
    647  1264					      SUBROUTINE
    648  1264
      0  1264					      REF	Variable_PieceShapeBuffer
      1  1264					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  1264				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  1264					      ENDIF
      0  1264					      REF	AiStateMachine
      1  1264				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1264				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1264					      ENDIF
      0  1264					      VEND	aiSelectDestinationSquare
      1  1264
      2  1264
      3  1264		       00 ef	   VAREND_aiSelectDestinationSquare =	TEMPORARY_VAR
      4  1264
    652  1264
    653  1264							; Piece is selected and now we're looking for a button press on a destination square
    654  1264							; we flash the piece on-and-off while we're doing that
    655  1264							; Flash the selected piece
    656  1264
    657  1264		       ad 84 02 	      lda	INTIM
    658  1267		       c9 28		      cmp	#ONCEPERFRAME
    659  1269		       90 0e		      bcc	.exit
    660  126b
    661  126b
    662  126b		       c6 8c		      dec	aiFlashDelay
    663  126d		       d0 0a		      bne	.exit	; don't flash
    664  126f		       a9 14		      lda	#CAP_SPEED
    665  1271		       85 8c		      sta	aiFlashDelay
    666  1273
    667  1273		       e6 8e		      inc	aiFlashPhase
    668  1275
    669  1275							; WARNING - local variables will not survive the following call...!
    670  1275		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    671  1278		       60		      rts
    672  1279
    673  1279				   .exit
      0  1279					      CALL	moveCursor	;@2
      1  1279				  -	      IF	SLOT_moveCursor == _BANK_SLOT
      2  1279				  -FNAME      SETSTR	moveCursor
      3  1279				  -	      ECHO	""
      4  1279				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  1279				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  1279				  -	      ERR
      7  1279					      ENDIF
      8  1279		       a9 8a		      lda	#BANK_moveCursor
      9  127b		       85 3f		      sta	SET_BANK
     10  127d		       20 00 f8 	      jsr	moveCursor
    675  1280
    676  1280		       ad 84 02 	      lda	INTIM
    677  1283		       c9 14		      cmp	#20
    678  1285		       90 3d		      bcc	.noButton
    679  1287
    680  1287
    681  1287		       a4 88		      ldy	cursorX12
    682  1289		       84 86		      sty	toX12
    683  128b
      0  128b					      CALL	GetPiece	;@3
      1  128b				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  128b				  -FNAME      SETSTR	GetPiece
      3  128b				  -	      ECHO	""
      4  128b				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  128b				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  128b				  -	      ERR
      7  128b					      ENDIF
      8  128b		       a9 d8		      lda	#BANK_GetPiece
      9  128d		       85 3f		      sta	SET_BANK
     10  128f		       20 00 fc 	      jsr	GetPiece
      0  1292					      CALL	setCursorColours
      1  1292				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  1292				  -FNAME      SETSTR	setCursorColours
      3  1292				  -	      ECHO	""
      4  1292				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  1292				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  1292				  -	      ERR
      7  1292					      ENDIF
      8  1292		       a9 8a		      lda	#BANK_setCursorColours
      9  1294		       85 3f		      sta	SET_BANK
     10  1296		       20 4a f8 	      jsr	setCursorColours
    686  1299
    687  1299
    688  1299							; y = valid square
    689  1299
    690  1299		       a5 4c		      lda	INPT4
    691  129b		       30 27		      bmi	.noButton
    692  129d
    693  129d		       a5 86		      lda	toX12
    694  129f		       c5 85		      cmp	fromX12
    695  12a1		       f0 0d		      beq	.cancel
    696  12a3
    697  12a3		       c0 ff		      cpy	#-1
    698  12a5		       f0 1d		      beq	.noButton	; not a valid square
    699  12a7
    700  12a7		       a5 8e		      lda	aiFlashPhase
    701  12a9		       29 01		      and	#1
    702  12ab		       f0 13		      beq	.done
    703  12ad		       85 8c		      sta	aiFlashDelay	; EOR-phase incorrect - force quick fix to allow next-frame button detect
    704  12af		       60		      rts
    705  12b0
    706  12b0				   .cancel
    707  12b0
    708  12b0		       a5 8e		      lda	aiFlashPhase
    709  12b2		       29 01		      and	#1
    710  12b4		       f0 05		      beq	.doCancel
    711  12b6
    712  12b6							; EOR-phase incorrect - force quick fix to allow next-frame button detect
    713  12b6
    714  12b6		       a9 01		      lda	#1
    715  12b8		       85 8c		      sta	aiFlashDelay
    716  12ba		       60		      rts
    717  12bb
    718  12bb
      0  12bb				   .doCancel  PHASE	ReselectDebounce
      1  12bb		       a9 0a		      lda	#AI_ReselectDebounce
      2  12bd		       85 8b		      sta	aiState
    720  12bf		       60		      rts
    721  12c0
      0  12c0				   .done      PHASE	Quiescent	; destination selected!
      1  12c0		       a9 09		      lda	#AI_Quiescent
      2  12c2		       85 8b		      sta	aiState
    723  12c4		       60	   .noButton  rts
    724  12c5
    725  12c5
    726  12c5
    727  12c5
    728  12c5
    729  12c5							;---------------------------------------------------------------------------------------------------
    730  12c5
      0  12c5					      DEF	aiRollPromotionPiece
      1  12c5				   SLOT_aiRollPromotionPiece SET	_BANK_SLOT
      2  12c5				   BANK_aiRollPromotionPiece SET	SLOT_aiRollPromotionPiece + _CURRENT_BANK
      3  12c5				   aiRollPromotionPiece
      4  12c5				   TEMPORARY_VAR SET	Overlay
      5  12c5				   TEMPORARY_OFFSET SET	0
      6  12c5				   VAR_BOUNDARY_aiRollPromotionPiece SET	TEMPORARY_OFFSET
      7  12c5				   FUNCTION_NAME SET	aiRollPromotionPiece
    732  12c5					      SUBROUTINE
    733  12c5
      0  12c5					      REF	AiStateMachine
      1  12c5					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  12c5				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  12c5					      ENDIF
      0  12c5					      VEND	aiRollPromotionPiece
      1  12c5
      2  12c5
      3  12c5		       00 a9	   VAREND_aiRollPromotionPiece =	TEMPORARY_VAR
      4  12c5
    736  12c5
    737  12c5							; Flash the '?' and wait for an UDLR move
    738  12c5
    739  12c5		       ad 84 02 	      lda	INTIM
    740  12c8		       c9 29		      cmp	#SPEEDOF_CopySinglePiece
    741  12ca		       90 2b		      bcc	.exit
    742  12cc
    743  12cc		       ad 80 02 	      lda	SWCHA
    744  12cf		       29 f0		      and	#$F0
    745  12d1		       c9 f0		      cmp	#$F0
    746  12d3		       f0 0a		      beq	.nojoy
    747  12d5
    748  12d5		       a9 00		      lda	#0
    749  12d7		       85 8c		      sta	aiFlashDelay
    750  12d9
    751  12d9		       a5 8e		      lda	aiFlashPhase
    752  12db		       29 01		      and	#1
    753  12dd		       f0 19		      beq	.even
    754  12df
    755  12df		       a5 8c	   .nojoy     lda	aiFlashDelay
    756  12e1		       f0 03		      beq	.do
    757  12e3		       c6 8c		      dec	aiFlashDelay
    758  12e5		       60		      rts
    759  12e6
    760  12e6				   .do
    761  12e6		       a9 1e		      lda	#30
    762  12e8		       85 8c		      sta	aiFlashDelay	; speed of "?" flashing
    763  12ea
    764  12ea
    765  12ea		       a2 20		      ldx	#INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0
    766  12ec		       a5 95		      lda	sideToMove
    767  12ee		       10 02		      bpl	.wtm
    768  12f0		       a2 68		      ldx	#INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0
    769  12f2				   .wtm
    770  12f2		       20 0c f7 	      jsr	showPromoteOptions	; draw the "?"
    771  12f5
    772  12f5		       e6 8e		      inc	aiFlashPhase
    773  12f7
    774  12f7		       60	   .exit      rts
    775  12f8
    776  12f8
    777  12f8		       a9 03	   .even      lda	#3	; QUEEN
    778  12fa		       85 96		      sta	fromPiece	; cycles as index to NBRQ
    779  12fc
    780  12fc							;inc aiFlashPhase
    781  12fc
    782  12fc		       a2 14		      ldx	#INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    783  12fe		       a5 95		      lda	sideToMove
    784  1300		       10 02		      bpl	.blackStuff
    785  1302		       a2 5c		      ldx	#INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    786  1304				   .blackStuff
    787  1304
    788  1304		       20 0c f7 	      jsr	showPromoteOptions	; draw the initial Q
    789  1307
      0  1307					      PHASE	ChooseDebounce
      1  1307		       a9 22		      lda	#AI_ChooseDebounce
      2  1309		       85 8b		      sta	aiState
    791  130b		       60		      rts
    792  130c
    793  130c
    794  130c							;---------------------------------------------------------------------------------------------------
    795  130c
      0  130c					      DEF	showPromoteOptions
      1  130c				   SLOT_showPromoteOptions SET	_BANK_SLOT
      2  130c				   BANK_showPromoteOptions SET	SLOT_showPromoteOptions + _CURRENT_BANK
      3  130c				   showPromoteOptions
      4  130c				   TEMPORARY_VAR SET	Overlay
      5  130c				   TEMPORARY_OFFSET SET	0
      6  130c				   VAR_BOUNDARY_showPromoteOptions SET	TEMPORARY_OFFSET
      7  130c				   FUNCTION_NAME SET	showPromoteOptions
    797  130c					      SUBROUTINE
    798  130c
      0  130c					      REF	aiRollPromotionPiece	;✅
      1  130c					      IF	VAREND_aiRollPromotionPiece > TEMPORARY_VAR
      2  130c				   TEMPORARY_VAR SET	VAREND_aiRollPromotionPiece
      3  130c					      ENDIF
      0  130c					      REF	aiChoosePromotePiece	;✅
      1  130c					      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  130c				   TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  130c					      ENDIF
      0  130c					      VEND	showPromoteOptions
      1  130c
      2  130c
      3  130c		       00 ef	   VAREND_showPromoteOptions =	TEMPORARY_VAR
      4  130c
    802  130c
    803  130c							; X = character shape # (?/N/B/R/Q)
    804  130c
    805  130c		       a4 86		      ldy	toX12
    806  130e		       84 80		      sty	squareToDraw
    807  1310
    808  1310		       8a		      txa
    809  1311		       a8		      tay
    810  1312
    811  1312		       20 b7 f5 	      jsr	CopySetupForMarker	;@this
    812  1315		       4c c8 f0 	      jmp	InterceptMarkerCopy	;@0
    813  1318
    814  1318
    815  1318							;---------------------------------------------------------------------------------------------------
    816  1318
      0  1318					      DEF	aiChoosePromotePiece
      1  1318				   SLOT_aiChoosePromotePiece SET	_BANK_SLOT
      2  1318				   BANK_aiChoosePromotePiece SET	SLOT_aiChoosePromotePiece + _CURRENT_BANK
      3  1318				   aiChoosePromotePiece
      4  1318				   TEMPORARY_VAR SET	Overlay
      5  1318				   TEMPORARY_OFFSET SET	0
      6  1318				   VAR_BOUNDARY_aiChoosePromotePiece SET	TEMPORARY_OFFSET
      7  1318				   FUNCTION_NAME SET	aiChoosePromotePiece
    818  1318					      SUBROUTINE
    819  1318
      0  1318					      REF	Variable_PieceShapeBuffer
      1  1318					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  1318				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  1318					      ENDIF
      0  1318					      REF	AiStateMachine
      1  1318				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1318				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1318					      ENDIF
      0  1318					      VEND	aiChoosePromotePiece
      1  1318
      2  1318
      3  1318		       00 ef	   VAREND_aiChoosePromotePiece =	TEMPORARY_VAR
      4  1318
    823  1318
    824  1318							; Question-mark phase has exited via joystick direction
    825  1318							; Now we cycle through the selectable pieces
    826  1318
    827  1318		       ad 84 02 	      lda	INTIM
    828  131b		       c9 29		      cmp	#SPEEDOF_CopySinglePiece
    829  131d		       90 4e		      bcc	.exit
    830  131f
    831  131f		       a5 4c		      lda	INPT4
    832  1321		       30 0a		      bmi	.nobut	; no press
    833  1323
    834  1323							; button pressed but make sure phase is correct for exit
    835  1323
    836  1323		       a9 01		      lda	#1
    837  1325		       85 8c		      sta	aiFlashDelay	; force quick rehash to this if phase incorrect
    838  1327
    839  1327		       a5 8e		      lda	aiFlashPhase
    840  1329		       29 01		      and	#1
    841  132b		       f0 41		      beq	.chosen	; button pressed --> selection made
    842  132d				   .nobut
    843  132d
    844  132d		       ad 80 02 	      lda	SWCHA
    845  1330		       29 f0		      and	#$F0
    846  1332		       c9 f0		      cmp	#$F0
    847  1334		       f0 04		      beq	.nodir	; no direction pressed
    848  1336
    849  1336
    850  1336		       a9 01		      lda	#1
    851  1338		       85 8c		      sta	aiFlashDelay
    852  133a
    853  133a
    854  133a		       c6 8c	   .nodir     dec	aiFlashDelay
    855  133c		       d0 2f		      bne	.exit
    856  133e
    857  133e		       a9 1e		      lda	#30
    858  1340		       85 8c		      sta	aiFlashDelay
    859  1342
    860  1342		       a5 8e		      lda	aiFlashPhase
    861  1344		       4a		      lsr
    862  1345		       b0 1c		      bcs	.odd	; must wait until piece undrawn
    863  1347
    864  1347		       ad 80 02 	      lda	SWCHA
    865  134a		       29 f0		      and	#$F0
    866  134c		       c9 f0		      cmp	#$F0
    867  134e		       f0 13		      beq	.odd	; no direction pressed
    868  1350
    869  1350		       4a		      lsr
    870  1351		       4a		      lsr
    871  1352		       4a		      lsr
    872  1353		       4a		      lsr
    873  1354		       a8		      tay
    874  1355
    875  1355
    876  1355							; cycle to the next promotable piece (N/B/R/Q)
    877  1355							; TODO; use joy table for mod instead of just incrementing all the time
    878  1355
    879  1355		       18		      clc
    880  1356		       a5 96		      lda	fromPiece
    881  1358		       79 5d f8 	      adc	JoyCombined,y
    882  135b		       29 03		      and	#3
    883  135d		       85 96		      sta	fromPiece
    884  135f
      0  135f					      PHASE	ChooseDebounce	; after draw, wait for release
      1  135f		       a9 22		      lda	#AI_ChooseDebounce
      2  1361		       85 8b		      sta	aiState
    886  1363
    887  1363				   .odd
    888  1363
    889  1363				   .force
    890  1363		       e6 8e		      inc	aiFlashPhase	; on/off toggle
    891  1365
    892  1365		       a4 96		      ldy	fromPiece
    893  1367		       be 8d f7 	      ldx	promotePiece,y
    894  136a		       20 0c f7 	      jsr	showPromoteOptions	;@this
    895  136d
    896  136d		       60	   .exit      rts
    897  136e
    898  136e
    899  136e
    900  136e
    901  136e
    902  136e
    903  136e				   .chosen
    904  136e		       a5 96		      lda	fromPiece
    905  1370		       29 0f		      and	#PIECE_MASK
    906  1372		       aa		      tax
    907  1373
    908  1373		       bd 91 f7 	      lda	promoteType,x
    909  1376		       85 96		      sta	fromPiece
    910  1378
    911  1378		       a4 86		      ldy	toX12
    912  137a		       a9 d0		      lda	#RAMBANK_BOARD
    913  137c		       85 3e		      sta	SET_BANK_RAM	;@3
    914  137e		       b9 79 fc 	      lda	Board,y
    915  1381		       29 0f		      and	#PIECE_MASK
    916  1383		       f0 03		      beq	.nothing
    917  1385
    918  1385		       20 c1 f0 	      jsr	CopySinglePiece	;@0	      ; put back whatever was there to start
    919  1388
      0  1388				   .nothing   PHASE	MoveIsSelected
      1  1388		       a9 14		      lda	#AI_MoveIsSelected
      2  138a		       85 8b		      sta	aiState
    921  138c		       60		      rts
    922  138d
      0  138d					      ALLOCATE	promotePiece, 4
      1  138d
      2  138d				   .NAME      SETSTR	promotePiece
      0  138d					      OPTIONAL_PAGEBREAK	.NAME, 4
      1  138d
      2  138d				  -	      IF	(>( * + 4 -1 )) > ( >* )
      3  138d				  -.EARLY_LOCATION SET	*
      4  138d				  -	      ALIGN	256
      5  138d				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  138d					      ENDIF
      0  138d					      DEF	promotePiece
      1  138d				   SLOT_promotePiece SET	_BANK_SLOT
      2  138d				   BANK_promotePiece SET	SLOT_promotePiece + _CURRENT_BANK
      3  138d				   promotePiece
      4  138d				   TEMPORARY_VAR SET	Overlay
      5  138d				   TEMPORARY_OFFSET SET	0
      6  138d				   VAR_BOUNDARY_promotePiece SET	TEMPORARY_OFFSET
      7  138d				   FUNCTION_NAME SET	promotePiece
      5  138d
    924  138d		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    925  138e		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    926  138f		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    927  1390		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    928  1391
      0  1391					      ALLOCATE	promoteType,4
      1  1391
      2  1391				   .NAME      SETSTR	promoteType
      0  1391					      OPTIONAL_PAGEBREAK	.NAME, 4
      1  1391
      2  1391				  -	      IF	(>( * + 4 -1 )) > ( >* )
      3  1391				  -.EARLY_LOCATION SET	*
      4  1391				  -	      ALIGN	256
      5  1391				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  1391					      ENDIF
      0  1391					      DEF	promoteType
      1  1391				   SLOT_promoteType SET	_BANK_SLOT
      2  1391				   BANK_promoteType SET	SLOT_promoteType + _CURRENT_BANK
      3  1391				   promoteType
      4  1391				   TEMPORARY_VAR SET	Overlay
      5  1391				   TEMPORARY_OFFSET SET	0
      6  1391				   VAR_BOUNDARY_promoteType SET	TEMPORARY_OFFSET
      7  1391				   FUNCTION_NAME SET	promoteType
      5  1391
    930  1391		       03 04 05 06	      .byte.b	KNIGHT, BISHOP, ROOK, QUEEN
    931  1395
    932  1395
    933  1395							;---------------------------------------------------------------------------------------------------
    934  1395
      0  1395					      DEF	aiMarchA2
      1  1395				   SLOT_aiMarchA2 SET	_BANK_SLOT
      2  1395				   BANK_aiMarchA2 SET	SLOT_aiMarchA2 + _CURRENT_BANK
      3  1395				   aiMarchA2
      4  1395				   TEMPORARY_VAR SET	Overlay
      5  1395				   TEMPORARY_OFFSET SET	0
      6  1395				   VAR_BOUNDARY_aiMarchA2 SET	TEMPORARY_OFFSET
      7  1395				   FUNCTION_NAME SET	aiMarchA2
    936  1395					      SUBROUTINE
    937  1395
      0  1395					      REF	Variable_PieceShapeBuffer
      1  1395					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  1395				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  1395					      ENDIF
      0  1395					      REF	AiStateMachine
      1  1395				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1395				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1395					      ENDIF
      0  1395					      VEND	aiMarchA2
      1  1395
      2  1395
      3  1395		       00 ef	   VAREND_aiMarchA2 =	TEMPORARY_VAR
      4  1395
    941  1395
    942  1395							; erase object in new sqare --> blank
    943  1395
    944  1395		       a4 85		      ldy	fromX12
    945  1397		       84 80		      sty	squareToDraw
    946  1399
    947  1399		       a9 d0		      lda	#RAMBANK_BOARD
    948  139b		       85 3e		      sta	SET_BANK_RAM	;@3
    949  139d		       b9 79 fc 	      lda	Board,y
    950  13a0		       f0 03		      beq	.skipbl
    951  13a2
    952  13a2							; WARNING - local variables will not survive the following call...!
    953  13a2		       20 c1 f0 	      jsr	CopySinglePiece	;@0	      ; erase next square along --> blank
    954  13a5
    955  13a5				   .skipbl
    956  13a5		       a4 85		      ldy	fromX12
    957  13a7		       84 aa		      sty	__boardIndex
    958  13a9
    959  13a9		       a9 d0		      lda	#RAMBANK_BOARD
    960  13ab		       85 3e		      sta	SET_BANK_RAM	;@3
    961  13ad		       b9 79 fc 	      lda	Board,y
    962  13b0		       85 97		      sta	lastPiece	; what we are overwriting
    963  13b2		       a5 96		      lda	fromPiece
    964  13b4		       09 40		      ora	#FLAG_MOVED	; prevents usage in castling for K/R
    965  13b6		       29 df		      and	#~FLAG_ENPASSANT
    966  13b8		       a4 aa		      ldy	__boardIndex
      0  13ba					      sta@RAM	Board,y	; and what's actually moving there
      1  13ba		       99 79 fe 	      sta	[RAM]+Board,y
    968  13bd
    969  13bd
      0  13bd					      PHASE	MarchB
      1  13bd		       a9 18		      lda	#AI_MarchB
      2  13bf		       85 8b		      sta	aiState
    971  13c1		       60		      rts
    972  13c2
    973  13c2
    974  13c2							;---------------------------------------------------------------------------------------------------
    975  13c2
      0  13c2					      DEF	aiMarchB2
      1  13c2				   SLOT_aiMarchB2 SET	_BANK_SLOT
      2  13c2				   BANK_aiMarchB2 SET	SLOT_aiMarchB2 + _CURRENT_BANK
      3  13c2				   aiMarchB2
      4  13c2				   TEMPORARY_VAR SET	Overlay
      5  13c2				   TEMPORARY_OFFSET SET	0
      6  13c2				   VAR_BOUNDARY_aiMarchB2 SET	TEMPORARY_OFFSET
      7  13c2				   FUNCTION_NAME SET	aiMarchB2
    977  13c2					      SUBROUTINE
    978  13c2
      0  13c2					      REF	Variable_PieceShapeBuffer
      1  13c2					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  13c2				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  13c2					      ENDIF
      0  13c2					      REF	AiStateMachine
      1  13c2				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  13c2				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  13c2					      ENDIF
      0  13c2					      VEND	aiMarchB2
      1  13c2
      2  13c2
      3  13c2		       00 ef	   VAREND_aiMarchB2 =	TEMPORARY_VAR
      4  13c2
    982  13c2
    983  13c2		       a4 83		      ldy	lastSquareX12
    984  13c4		       84 80		      sty	squareToDraw
    985  13c6
    986  13c6		       a9 d0		      lda	#RAMBANK_BOARD
    987  13c8		       85 3e		      sta	SET_BANK_RAM	;@3
    988  13ca		       b9 79 fc 	      lda	Board,y
    989  13cd		       f0 03		      beq	.skipbl2
    990  13cf
    991  13cf							; WARNING - local variables will not survive the following call...!
    992  13cf		       20 c1 f0 	      jsr	CopySinglePiece	;@0	      ; draw previous piece back in old position
    993  13d2				   .skipbl2
    994  13d2
    995  13d2		       a5 85		      lda	fromX12
    996  13d4		       c5 86		      cmp	toX12
    997  13d6		       f0 09		      beq	xhalt
    998  13d8
    999  13d8		       a9 02		      lda	#2	;??? inter-move segment speed (can be 0)
   1000  13da		       85 82		      sta	drawDelay
      0  13dc					      PHASE	MarchToTargetA
      1  13dc		       a9 16		      lda	#AI_MarchToTargetA
      2  13de		       85 8b		      sta	aiState
   1002  13e0
   1003  13e0		       60		      rts
   1004  13e1
      0  13e1				   xhalt      PHASE	EPHandler
      1  13e1		       a9 29		      lda	#AI_EPHandler
      2  13e3		       85 8b		      sta	aiState
   1006  13e5		       60		      rts
   1007  13e6
   1008  13e6
   1009  13e6
   1010  13e6
   1011  13e6							;---------------------------------------------------------------------------------------------------
   1012  13e6
      0  13e6					      END_BANK
      1  13e6				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  13e6				  -	      CHECK_RAM_BANK_SIZE
      3  13e6					      ELSE
      0  13e6					      CHECK_BANK_SIZE
      1  13e6		       03 e6	   .TEMP      =	* - _BANK_START
 ROM bank # 5 STATEMACHINE size = $3e6 free = 25
      2  13e6					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  13e6				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  13e6				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  13e6				  -	      ERR
      6  13e6					      ENDIF
      5  13e6					      ENDIF
   1014  13e6
   1015  13e6							;---------------------------------------------------------------------------------------------------
   1016  13e6							; EOF
------- FILE ./chess.asm
------- FILE @1 STATE MACHINE #2.asm LEVEL 2 PASS 4
      0  13e6					      include	"@1 STATE MACHINE #2.asm"
      1  13e6							;---------------------------------------------------------------------------------------------------
      2  13e6							; @1 STATE MACHINE #2.asm
      3  13e6
      4  13e6							; Atari 2600 Chess
      5  13e6							; Copyright (c) 2019-2020 Andrew Davie
      6  13e6							; andrew@taswegian.com
      7  13e6
      8  13e6
      9  13e6							;---------------------------------------------------------------------------------------------------
     10  13e6
      0  13e6					      SLOT	1
      1  13e6
      2  13e6				  -	      IF	(1 < 0) || (1 > 3)
      3  13e6				  -	      ECHO	"Illegal bank address/segment location", 1
      4  13e6				  -	      ERR
      5  13e6					      ENDIF
      6  13e6
      7  13e6				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  13e6				   _BANK_SLOT SET	1 * 64
      9  13e6
      0  13e6					      ROMBANK	STATEMACHINE2
      1  1623 ????				      SEG	ROM_STATEMACHINE2
      2  1400					      ORG	_ORIGIN
      3  1400					      RORG	_BANK_ADDRESS_ORIGIN
      4  1400				   _BANK_START SET	*
      5  1400				   STATEMACHINE2_START SET	*
      6  1400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  1400				   ROMBANK_STATEMACHINE2 SET	_BANK_SLOT + _CURRENT_BANK
      8  1400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  1400				   _LAST_BANK SETSTR	STATEMACHINE2
     10  1400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  1400
     14  1400
     15  1400							;---------------------------------------------------------------------------------------------------
     16  1400
      0  1400					      DEF	aiChooseDebounce
      1  1400				   SLOT_aiChooseDebounce SET	_BANK_SLOT
      2  1400				   BANK_aiChooseDebounce SET	SLOT_aiChooseDebounce + _CURRENT_BANK
      3  1400				   aiChooseDebounce
      4  1400				   TEMPORARY_VAR SET	Overlay
      5  1400				   TEMPORARY_OFFSET SET	0
      6  1400				   VAR_BOUNDARY_aiChooseDebounce SET	TEMPORARY_OFFSET
      7  1400				   FUNCTION_NAME SET	aiChooseDebounce
     18  1400					      SUBROUTINE
     19  1400
      0  1400					      REF	AiStateMachine
      1  1400					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1400				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1400					      ENDIF
      0  1400					      VEND	aiChooseDebounce
      1  1400
      2  1400
      3  1400		       00 a9	   VAREND_aiChooseDebounce =	TEMPORARY_VAR
      4  1400
     22  1400
     23  1400							; We've changed promotion piece, and drawn it
     24  1400							; wait for joystick to be released before continuing
     25  1400
     26  1400		       ad 80 02 	      lda	SWCHA
     27  1403		       29 f0		      and	#$F0
     28  1405		       c9 f0		      cmp	#$F0
     29  1407		       d0 0a		      bne	.exit	; wait while joystick still pressed
     30  1409
     31  1409		       a9 01		      lda	#1
     32  140b		       85 8c		      sta	aiFlashDelay
     33  140d		       85 8e		      sta	aiFlashPhase
     34  140f
      0  140f					      PHASE	ChoosePromotePiece
      1  140f		       a9 21		      lda	#AI_ChoosePromotePiece
      2  1411		       85 8b		      sta	aiState
     36  1413		       60	   .exit      rts
     37  1414
     38  1414
     39  1414							;---------------------------------------------------------------------------------------------------
     40  1414
      0  1414					      DEF	aiReselectDebounce
      1  1414				   SLOT_aiReselectDebounce SET	_BANK_SLOT
      2  1414				   BANK_aiReselectDebounce SET	SLOT_aiReselectDebounce + _CURRENT_BANK
      3  1414				   aiReselectDebounce
      4  1414				   TEMPORARY_VAR SET	Overlay
      5  1414				   TEMPORARY_OFFSET SET	0
      6  1414				   VAR_BOUNDARY_aiReselectDebounce SET	TEMPORARY_OFFSET
      7  1414				   FUNCTION_NAME SET	aiReselectDebounce
     42  1414					      SUBROUTINE
     43  1414
      0  1414					      REF	AiStateMachine
      1  1414					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1414				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1414					      ENDIF
      0  1414					      VEND	aiReselectDebounce
      1  1414
      2  1414
      3  1414		       00 a9	   VAREND_aiReselectDebounce =	TEMPORARY_VAR
      4  1414
     46  1414
     47  1414							; We've just cancelled the move. Wait for the button to be released
     48  1414							; and then go back to selecting a piece to move
     49  1414
     50  1414		       a5 4c		      lda	INPT4
     51  1416		       10 04		      bpl	.exit	; button still pressed, so wait
     52  1418
      0  1418					      PHASE	SelectStartSquare
      1  1418		       a9 02		      lda	#AI_SelectStartSquare
      2  141a		       85 8b		      sta	aiState
     54  141c		       60	   .exit      rts
     55  141d
     56  141d
     57  141d							;---------------------------------------------------------------------------------------------------
     58  141d
      0  141d					      DEF	aiDelayAfterMove
      1  141d				   SLOT_aiDelayAfterMove SET	_BANK_SLOT
      2  141d				   BANK_aiDelayAfterMove SET	SLOT_aiDelayAfterMove + _CURRENT_BANK
      3  141d				   aiDelayAfterMove
      4  141d				   TEMPORARY_VAR SET	Overlay
      5  141d				   TEMPORARY_OFFSET SET	0
      6  141d				   VAR_BOUNDARY_aiDelayAfterMove SET	TEMPORARY_OFFSET
      7  141d				   FUNCTION_NAME SET	aiDelayAfterMove
     60  141d					      SUBROUTINE
     61  141d
      0  141d					      REF	AiStateMachine
      1  141d					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  141d				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  141d					      ENDIF
      0  141d					      VEND	aiDelayAfterMove
      1  141d
      2  141d
      3  141d		       00 a9	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
      4  141d
     64  141d
     65  141d		       a9 32		      lda	#50
     66  141f		       85 8c		      sta	aiFlashDelay
      0  1421					      PHASE	DelayAfterMove2
      1  1421		       a9 26		      lda	#AI_DelayAfterMove2
      2  1423		       85 8b		      sta	aiState
     68  1425		       60	   .exit      rts
     69  1426
     70  1426
     71  1426							;---------------------------------------------------------------------------------------------------
     72  1426
      0  1426					      DEF	aiDelayAfterMove2
      1  1426				   SLOT_aiDelayAfterMove2 SET	_BANK_SLOT
      2  1426				   BANK_aiDelayAfterMove2 SET	SLOT_aiDelayAfterMove2 + _CURRENT_BANK
      3  1426				   aiDelayAfterMove2
      4  1426				   TEMPORARY_VAR SET	Overlay
      5  1426				   TEMPORARY_OFFSET SET	0
      6  1426				   VAR_BOUNDARY_aiDelayAfterMove2 SET	TEMPORARY_OFFSET
      7  1426				   FUNCTION_NAME SET	aiDelayAfterMove2
     74  1426					      SUBROUTINE
     75  1426
      0  1426					      REF	AiStateMachine
      1  1426					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1426				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1426					      ENDIF
      0  1426					      VEND	aiDelayAfterMove
      1  1426
      2  1426
      3  1426		       00 a9	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
      4  1426
     78  1426
     79  1426		       c6 8c		      dec	aiFlashDelay
     80  1428		       d0 04		      bne	.exit
      0  142a					      PHASE	MoveIsSelected
      1  142a		       a9 14		      lda	#AI_MoveIsSelected
      2  142c		       85 8b		      sta	aiState
     82  142e		       60	   .exit      rts
     83  142f
     84  142f
     85  142f							;---------------------------------------------------------------------------------------------------
     86  142f
      0  142f					      DEF	aiDelayAfterPlaced
      1  142f				   SLOT_aiDelayAfterPlaced SET	_BANK_SLOT
      2  142f				   BANK_aiDelayAfterPlaced SET	SLOT_aiDelayAfterPlaced + _CURRENT_BANK
      3  142f				   aiDelayAfterPlaced
      4  142f				   TEMPORARY_VAR SET	Overlay
      5  142f				   TEMPORARY_OFFSET SET	0
      6  142f				   VAR_BOUNDARY_aiDelayAfterPlaced SET	TEMPORARY_OFFSET
      7  142f				   FUNCTION_NAME SET	aiDelayAfterPlaced
     88  142f					      SUBROUTINE
     89  142f
      0  142f					      REF	AiStateMachine
      1  142f					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  142f				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  142f					      ENDIF
      0  142f					      VEND	aiDelayAfterPlaced
      1  142f
      2  142f
      3  142f		       00 a9	   VAREND_aiDelayAfterPlaced =	TEMPORARY_VAR
      4  142f
     92  142f
     93  142f		       a2 4b		      ldx	#75	; delay after human move
     94  1431		       a5 95		      lda	sideToMove
     95  1433		       0a		      asl
     96  1434		       30 02		      bmi	.human
     97  1436		       a2 01		      ldx	#1	; delay after computer move
     98  1438		       86 8c	   .human     stx	aiFlashDelay
     99  143a
      0  143a					      PHASE	DelayAfterPlaced2
      1  143a		       a9 28		      lda	#AI_DelayAfterPlaced2
      2  143c		       85 8b		      sta	aiState
    101  143e		       60		      rts
    102  143f
    103  143f
    104  143f							;---------------------------------------------------------------------------------------------------
    105  143f
      0  143f					      DEF	aiDelayAfterPlaced2
      1  143f				   SLOT_aiDelayAfterPlaced2 SET	_BANK_SLOT
      2  143f				   BANK_aiDelayAfterPlaced2 SET	SLOT_aiDelayAfterPlaced2 + _CURRENT_BANK
      3  143f				   aiDelayAfterPlaced2
      4  143f				   TEMPORARY_VAR SET	Overlay
      5  143f				   TEMPORARY_OFFSET SET	0
      6  143f				   VAR_BOUNDARY_aiDelayAfterPlaced2 SET	TEMPORARY_OFFSET
      7  143f				   FUNCTION_NAME SET	aiDelayAfterPlaced2
    107  143f					      SUBROUTINE
    108  143f
      0  143f					      REF	AiStateMachine
      1  143f					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  143f				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  143f					      ENDIF
      0  143f					      VEND	aiDelayAfterPlaced2
      1  143f
      2  143f
      3  143f		       00 a9	   VAREND_aiDelayAfterPlaced2 =	TEMPORARY_VAR
      4  143f
    111  143f
    112  143f
    113  143f		       ad 82 02 	      lda	SWCHB
    114  1442		       29 02		      and	#SELECT_SWITCH
    115  1444		       d0 05		      bne	.noSwapside
    116  1446
      0  1446					      PHASE	DebounceSelect
      1  1446		       a9 2b		      lda	#AI_DebounceSelect
      2  1448		       85 8b		      sta	aiState
    118  144a		       60		      rts
    119  144b				   .noSwapside
    120  144b
    121  144b
    122  144b		       c6 8c		      dec	aiFlashDelay
    123  144d		       d0 04		      bne	.exit
    124  144f
    125  144f							;SWAP
    126  144f
      0  144f					      PHASE	GenerateMoves
      1  144f		       a9 12		      lda	#AI_GenerateMoves
      2  1451		       85 8b		      sta	aiState
    128  1453		       60	   .exit      rts
    129  1454
    130  1454
    131  1454							;---------------------------------------------------------------------------------------------------
    132  1454
      0  1454					      DEF	aiMarchToTargetB
      1  1454				   SLOT_aiMarchToTargetB SET	_BANK_SLOT
      2  1454				   BANK_aiMarchToTargetB SET	SLOT_aiMarchToTargetB + _CURRENT_BANK
      3  1454				   aiMarchToTargetB
      4  1454				   TEMPORARY_VAR SET	Overlay
      5  1454				   TEMPORARY_OFFSET SET	0
      6  1454				   VAR_BOUNDARY_aiMarchToTargetB SET	TEMPORARY_OFFSET
      7  1454				   FUNCTION_NAME SET	aiMarchToTargetB
    134  1454					      SUBROUTINE
    135  1454
      0  1454					      REF	Variable_PieceShapeBuffer
      1  1454					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  1454				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  1454					      ENDIF
      0  1454					      REF	AiStateMachine
      1  1454				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1454				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1454					      ENDIF
      0  1454					      VEND	aiMarchToTargetB
      1  1454
      2  1454
      3  1454		       00 ef	   VAREND_aiMarchToTargetB =	TEMPORARY_VAR
      4  1454
    139  1454
    140  1454							; now we want to undraw the piece in the old square
    141  1454
    142  1454		       a5 82		      lda	drawDelay
    143  1456		       f0 03		      beq	.stepOne
    144  1458		       c6 82		      dec	drawDelay
    145  145a		       60		      rts
    146  145b
    147  145b				   .stepOne
    148  145b		       a5 83		      lda	lastSquareX12
    149  145d		       85 80		      sta	squareToDraw
    150  145f
    151  145f							; WARNING - local variables will not survive the following call...!
    152  145f		       20 c1 f0 	      jsr	CopySinglePiece	;@0	      ; erase whatever was on the previous square (completely blank)
    153  1462
    154  1462		       a4 83		      ldy	lastSquareX12
    155  1464		       a5 98		      lda	previousPiece
    156  1466
    157  1466		       a2 d0		      ldx	#RAMBANK_BOARD
    158  1468		       86 3e		      stx	SET_BANK_RAM	;@3
      0  146a					      sta@RAM	Board,y	; and what's actually moving there
      1  146a		       99 79 fe 	      sta	[RAM]+Board,y
    160  146d
    161  146d		       a5 97		      lda	lastPiece
    162  146f		       85 98		      sta	previousPiece
    163  1471
      0  1471					      PHASE	MarchB2
      1  1471		       a9 1a		      lda	#AI_MarchB2
      2  1473		       85 8b		      sta	aiState
    165  1475		       60		      rts
    166  1476
    167  1476
    168  1476							;---------------------------------------------------------------------------------------------------
    169  1476
      0  1476					      DEF	aiPromotePawnStart
      1  1476				   SLOT_aiPromotePawnStart SET	_BANK_SLOT
      2  1476				   BANK_aiPromotePawnStart SET	SLOT_aiPromotePawnStart + _CURRENT_BANK
      3  1476				   aiPromotePawnStart
      4  1476				   TEMPORARY_VAR SET	Overlay
      5  1476				   TEMPORARY_OFFSET SET	0
      6  1476				   VAR_BOUNDARY_aiPromotePawnStart SET	TEMPORARY_OFFSET
      7  1476				   FUNCTION_NAME SET	aiPromotePawnStart
    171  1476					      SUBROUTINE
    172  1476
      0  1476					      REF	Variable_PieceShapeBuffer
      1  1476					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  1476				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  1476					      ENDIF
      0  1476					      REF	AiStateMachine
      1  1476				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1476				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1476					      ENDIF
      0  1476					      VEND	aiPromotePawnStart
      1  1476
      2  1476
      3  1476		       00 ef	   VAREND_aiPromotePawnStart =	TEMPORARY_VAR
      4  1476
    176  1476
    177  1476
    178  1476		       ad 84 02 	      lda	INTIM
    179  1479		       c9 29		      cmp	#SPEEDOF_CopySinglePiece
    180  147b		       90 1c		      bcc	.exit
    181  147d
    182  147d		       a9 00		      lda	#0
    183  147f		       85 8e		      sta	aiFlashPhase
    184  1481		       85 8c		      sta	aiFlashDelay
    185  1483
    186  1483		       a4 86		      ldy	toX12
    187  1485		       84 80		      sty	squareToDraw
    188  1487
    189  1487		       a9 d0		      lda	#RAMBANK_BOARD
    190  1489		       85 3e		      sta	SET_BANK_RAM	;@3
    191  148b		       b9 79 fc 	      lda	Board,y
    192  148e		       29 0f		      and	#PIECE_MASK
    193  1490		       f0 03		      beq	.empty
    194  1492
    195  1492							; WARNING - local variables will not survive the following call...!
    196  1492		       20 c1 f0 	      jsr	CopySinglePiece	;@0	      ; remove any capturable piece for display purposes
    197  1495
      0  1495				   .empty     PHASE	RollPromotionPiece
      1  1495		       a9 20		      lda	#AI_RollPromotionPiece
      2  1497		       85 8b		      sta	aiState
    199  1499		       60	   .exit      rts
    200  149a
    201  149a
    202  149a							;---------------------------------------------------------------------------------------------------
    203  149a
      0  149a					      DEF	aiGenerateMoves
      1  149a				   SLOT_aiGenerateMoves SET	_BANK_SLOT
      2  149a				   BANK_aiGenerateMoves SET	SLOT_aiGenerateMoves + _CURRENT_BANK
      3  149a				   aiGenerateMoves
      4  149a				   TEMPORARY_VAR SET	Overlay
      5  149a				   TEMPORARY_OFFSET SET	0
      6  149a				   VAR_BOUNDARY_aiGenerateMoves SET	TEMPORARY_OFFSET
      7  149a				   FUNCTION_NAME SET	aiGenerateMoves
    205  149a					      SUBROUTINE
    206  149a
      0  149a					      REF	AiStateMachine
      1  149a					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  149a				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  149a					      ENDIF
      0  149a					      VEND	aiGenerateMoves
      1  149a
      2  149a
      3  149a		       00 a9	   VAREND_aiGenerateMoves =	TEMPORARY_VAR
      4  149a
    209  149a
    210  149a		       a5 86		      lda	toX12
    211  149c		       85 80		      sta	squareToDraw	; for showing move (display square)
    212  149e
    213  149e		       a5 95		      lda	sideToMove
    214  14a0		       0a		      asl
    215  14a1		       30 05		      bmi	.player
    216  14a3
    217  14a3
      0  14a3				   .computer  PHASE	ComputerMove	; computer select move
      1  14a3		       a9 13		      lda	#AI_ComputerMove
      2  14a5		       85 8b		      sta	aiState
    219  14a7		       60		      rts
    220  14a8
    221  14a8
      0  14a8				   .player    PHASE	StartMoveGen
      1  14a8		       a9 0b		      lda	#AI_StartMoveGen
      2  14aa		       85 8b		      sta	aiState
    223  14ac		       60		      rts
    224  14ad
    225  14ad
    226  14ad							;---------------------------------------------------------------------------------------------------
    227  14ad
      0  14ad					      DEF	aiStepMoveGen
      1  14ad				   SLOT_aiStepMoveGen SET	_BANK_SLOT
      2  14ad				   BANK_aiStepMoveGen SET	SLOT_aiStepMoveGen + _CURRENT_BANK
      3  14ad				   aiStepMoveGen
      4  14ad				   TEMPORARY_VAR SET	Overlay
      5  14ad				   TEMPORARY_OFFSET SET	0
      6  14ad				   VAR_BOUNDARY_aiStepMoveGen SET	TEMPORARY_OFFSET
      7  14ad				   FUNCTION_NAME SET	aiStepMoveGen
    229  14ad					      SUBROUTINE
    230  14ad
      0  14ad					      REF	AiStateMachine
      1  14ad					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  14ad				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  14ad					      ENDIF
      0  14ad					      VEND	aiStepMoveGen
      1  14ad
      2  14ad
      3  14ad		       00 a9	   VAREND_aiStepMoveGen =	TEMPORARY_VAR
      4  14ad
    233  14ad
    234  14ad		       a5 87		      lda	originX12	; location of cursor (show move)
    235  14af		       85 88		      sta	cursorX12
      0  14b1					      PHASE	BeginSelectMovePhase
      1  14b1		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  14b3		       85 8b		      sta	aiState
    237  14b5		       60		      rts
    238  14b6
    239  14b6
    240  14b6							;---------------------------------------------------------------------------------------------------
    241  14b6
    242  1500		       00 00 00 00*	      align	256	; TODO?
    243  1500
    244  1500
      0  1500					      DEF	PositionSprites
      1  1500				   SLOT_PositionSprites SET	_BANK_SLOT
      2  1500				   BANK_PositionSprites SET	SLOT_PositionSprites + _CURRENT_BANK
      3  1500				   PositionSprites
      4  1500				   TEMPORARY_VAR SET	Overlay
      5  1500				   TEMPORARY_OFFSET SET	0
      6  1500				   VAR_BOUNDARY_PositionSprites SET	TEMPORARY_OFFSET
      7  1500				   FUNCTION_NAME SET	PositionSprites
    246  1500					      SUBROUTINE
    247  1500
      0  1500					      REF	StartupBankReset
      1  1500				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  1500				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  1500					      ENDIF
      0  1500					      VEND	PositionSprites
      1  1500
      2  1500
      3  1500		       00 a7	   VAREND_PositionSprites =	TEMPORARY_VAR
      4  1500
    250  1500
    251  1500
    252  1500		       a5 88		      lda	cursorX12
    253  1502		       38		      sec
    254  1503		       e9 0a	   .sub10     sbc	#10
    255  1505		       b0 fc		      bcs	.sub10
    256  1507		       69 08		      adc	#8
    257  1509		       a8		      tay
    258  150a
    259  150a		       85 42		      sta	WSYNC	; 00	  Sync to start of scanline.
    260  150c
    261  150c		       b9 30 f5 	      lda	colToPixel,y
    262  150f
    263  150f		       38		      sec		; 02	  Set the carry flag so no borrow will be applied during the division.
    264  1510		       e9 0f	   .divideby15 sbc	#15	; 04	  Waste the necessary amount of time dividing X-pos by 15!
    265  1512		       b0 fc		      bcs	.divideby15	; 06/07  11/16/21/26/31/36/41/46/51/56/61/66
    266  1514
    267  1514		       a8		      tay
    268  1515		       b9 30 f4 	      lda	fineAdjustTable,y	; 13 -> Consume 5 cycles by guaranteeing we cross a page boundary
    269  1518		       85 60		      sta	HMP0
    270  151a		       85 50		      sta	RESP0	; 21/ 26/31/36/41/46/51/56/61/66/71 - Set the rough position.
    271  151c
    272  151c		       85 42		      sta	WSYNC
    273  151e		       85 6a		      sta	HMOVE
    274  1520
    275  1520		       60		      rts
    276  1521
    277  1521							; This table converts the "remainder" of the division by 15 (-1 to -15) to the correct
    278  1521							; fine adjustment value. This table is on a page boundary to guarantee the processor
    279  1521							; will cross a page boundary and waste a cycle in order to be at the precise position
    280  1521							; for a RESP0,x write
    281  1521
    282  1521				   fineAdjustBegin
    283  1521
    284  1521		       70		      DC.B	%01110000	; Left 7
    285  1522		       60		      DC.B	%01100000	; Left 6
    286  1523		       50		      DC.B	%01010000	; Left 5
    287  1524		       40		      DC.B	%01000000	; Left 4
    288  1525		       30		      DC.B	%00110000	; Left 3
    289  1526		       20		      DC.B	%00100000	; Left 2
    290  1527		       10		      DC.B	%00010000	; Left 1
    291  1528		       00		      DC.B	%00000000	; No movement.
    292  1529		       f0		      DC.B	%11110000	; Right 1
    293  152a		       e0		      DC.B	%11100000	; Right 2
    294  152b		       d0		      DC.B	%11010000	; Right 3
    295  152c		       c0		      DC.B	%11000000	; Right 4
    296  152d		       b0		      DC.B	%10110000	; Right 5
    297  152e		       a0		      DC.B	%10100000	; Right 6
    298  152f		       90		      DC.B	%10010000	; Right 7
    299  1530
    300  1530		       f4 30	   fineAdjustTable EQU	fineAdjustBegin - %11110001	; NOTE: %11110001 = -15
    301  1530
    302  1530
      0  1530					      ALLOCATE	colToPixel, 8
      1  1530
      2  1530				   .NAME      SETSTR	colToPixel
      0  1530					      OPTIONAL_PAGEBREAK	.NAME, 8
      1  1530
      2  1530				  -	      IF	(>( * + 8 -1 )) > ( >* )
      3  1530				  -.EARLY_LOCATION SET	*
      4  1530				  -	      ALIGN	256
      5  1530				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  1530					      ENDIF
      0  1530					      DEF	colToPixel
      1  1530				   SLOT_colToPixel SET	_BANK_SLOT
      2  1530				   BANK_colToPixel SET	SLOT_colToPixel + _CURRENT_BANK
      3  1530				   colToPixel
      4  1530				   TEMPORARY_VAR SET	Overlay
      5  1530				   TEMPORARY_OFFSET SET	0
      6  1530				   VAR_BOUNDARY_colToPixel SET	TEMPORARY_OFFSET
      7  1530				   FUNCTION_NAME SET	colToPixel
      5  1530
    304  1530		       00 14 28 3c*	      .byte.b	0,20,40,60,80,100,120,140
    305  1538
    306  1538
    307  1538							;---------------------------------------------------------------------------------------------------
    308  1538
      0  1538					      DEF	aiMarchToTargetA
      1  1538				   SLOT_aiMarchToTargetA SET	_BANK_SLOT
      2  1538				   BANK_aiMarchToTargetA SET	SLOT_aiMarchToTargetA + _CURRENT_BANK
      3  1538				   aiMarchToTargetA
      4  1538				   TEMPORARY_VAR SET	Overlay
      5  1538				   TEMPORARY_OFFSET SET	0
      6  1538				   VAR_BOUNDARY_aiMarchToTargetA SET	TEMPORARY_OFFSET
      7  1538				   FUNCTION_NAME SET	aiMarchToTargetA
    310  1538					      SUBROUTINE
    311  1538
      0  1538					      REF	AiStateMachine
      1  1538					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1538				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1538					      ENDIF
    313  1538
      0  1538					      VAR	__fromRow, 1
      1  1538
      2  1538		       00 a9	   __fromRow  =	TEMPORARY_VAR
      3  1538				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  1538
      5  1538				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  1538				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  1538				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  1538					      ENDIF
      9  1538				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  1538				  -	      LIST	ON
     11  1538				  -VNAME      SETSTR	__fromRow
     12  1538				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  1538				  -	      ERR
     14  1538				  -	      ECHO	"Temporary Variable overlow!"
     15  1538					      ENDIF
     16  1538					      LIST	ON
      0  1538					      VAR	__boardIndex, 1
      1  1538
      2  1538		       00 aa	   __boardIndex =	TEMPORARY_VAR
      3  1538				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  1538
      5  1538				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  1538				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  1538				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  1538					      ENDIF
      9  1538				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  1538				  -	      LIST	ON
     11  1538				  -VNAME      SETSTR	__boardIndex
     12  1538				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  1538				  -	      ERR
     14  1538				  -	      ECHO	"Temporary Variable overlow!"
     15  1538					      ENDIF
     16  1538					      LIST	ON
      0  1538					      VAR	__fromCol, 1
      1  1538
      2  1538		       00 ab	   __fromCol  =	TEMPORARY_VAR
      3  1538				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  1538
      5  1538				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  1538				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  1538				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  1538					      ENDIF
      9  1538				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  1538				  -	      LIST	ON
     11  1538				  -VNAME      SETSTR	__fromCol
     12  1538				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  1538				  -	      ERR
     14  1538				  -	      ECHO	"Temporary Variable overlow!"
     15  1538					      ENDIF
     16  1538					      LIST	ON
      0  1538					      VAR	__toCol, 1
      1  1538
      2  1538		       00 ac	   __toCol    =	TEMPORARY_VAR
      3  1538				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  1538
      5  1538				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  1538				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  1538				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  1538					      ENDIF
      9  1538				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  1538				  -	      LIST	ON
     11  1538				  -VNAME      SETSTR	__toCol
     12  1538				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  1538				  -	      ERR
     14  1538				  -	      ECHO	"Temporary Variable overlow!"
     15  1538					      ENDIF
     16  1538					      LIST	ON
    318  1538
      0  1538					      VEND	aiMarchToTargetA
      1  1538
      2  1538
      3  1538		       00 ad	   VAREND_aiMarchToTargetA =	TEMPORARY_VAR
      4  1538
    320  1538
    321  1538
    322  1538		       a5 82		      lda	drawDelay
    323  153a		       f0 03		      beq	.nodelay
    324  153c		       c6 82		      dec	drawDelay
    325  153e		       60		      rts
    326  153f				   .nodelay
    327  153f
    328  153f							; Now we calculate move to new square
    329  153f
    330  153f		       a5 85		      lda	fromX12
    331  1541		       c5 86		      cmp	toX12
    332  1543		       f0 44		      beq	.unmovedx
    333  1545		       85 83		      sta	lastSquareX12
    334  1547
    335  1547		       38		      sec
    336  1548		       a2 fd		      ldx	#-3
    337  154a		       e9 0a	   .sub10     sbc	#10
    338  154c		       e8		      inx
    339  154d		       b0 fb		      bcs	.sub10
    340  154f		       69 08		      adc	#8
    341  1551		       85 ab		      sta	__fromCol
    342  1553		       86 a9		      stx	__fromRow
    343  1555
    344  1555		       a5 86		      lda	toX12
    345  1557		       38		      sec
    346  1558		       a2 fd		      ldx	#-3
    347  155a		       e9 0a	   .sub10b    sbc	#10
    348  155c		       e8		      inx
    349  155d		       b0 fb		      bcs	.sub10b
    350  155f		       69 08		      adc	#8
    351  1561		       85 ac		      sta	__toCol
    352  1563
    353  1563
    354  1563		       e4 a9		      cpx	__fromRow
    355  1565		       f0 13		      beq	.rowDone
    356  1567
    357  1567		       b0 0a		      bcs	.incRow
    358  1569
    359  1569		       38		      sec
    360  156a		       a5 85		      lda	fromX12
    361  156c		       e9 0a		      sbc	#10
    362  156e		       85 85		      sta	fromX12
    363  1570		       4c 7a f5 	      jmp	.rowDone
    364  1573
    365  1573		       18	   .incRow    clc
    366  1574		       a5 85		      lda	fromX12
    367  1576		       69 0a		      adc	#10
    368  1578		       85 85		      sta	fromX12
    369  157a
    370  157a				   .rowDone
    371  157a
    372  157a		       a5 ac		      lda	__toCol
    373  157c		       c5 ab		      cmp	__fromCol
    374  157e		       f0 09		      beq	.colDone
    375  1580
    376  1580		       b0 05		      bcs	.incCol
    377  1582
    378  1582		       c6 85		      dec	fromX12
    379  1584		       4c 89 f5 	      jmp	.colDone
    380  1587
    381  1587		       e6 85	   .incCol    inc	fromX12
    382  1589				   .colDone
    383  1589				   .unmovedx
    384  1589
    385  1589		       a5 87		      lda	originX12
    386  158b		       85 88		      sta	cursorX12
    387  158d
      0  158d					      PHASE	MarchA2
      1  158d		       a9 17		      lda	#AI_MarchA2
      2  158f		       85 8b		      sta	aiState
    389  1591		       60		      rts
    390  1592
    391  1592
    392  1592							;---------------------------------------------------------------------------------------------------
    393  1592
      0  1592					      DEF	aiFinalFlash
      1  1592				   SLOT_aiFinalFlash SET	_BANK_SLOT
      2  1592				   BANK_aiFinalFlash SET	SLOT_aiFinalFlash + _CURRENT_BANK
      3  1592				   aiFinalFlash
      4  1592				   TEMPORARY_VAR SET	Overlay
      5  1592				   TEMPORARY_OFFSET SET	0
      6  1592				   VAR_BOUNDARY_aiFinalFlash SET	TEMPORARY_OFFSET
      7  1592				   FUNCTION_NAME SET	aiFinalFlash
    395  1592					      SUBROUTINE
    396  1592
      0  1592					      REF	Variable_PieceShapeBuffer
      1  1592					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  1592				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  1592					      ENDIF
      0  1592					      REF	AiStateMachine
      1  1592				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1592				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1592					      ENDIF
      0  1592					      VEND	aiFinalFlash
      1  1592
      2  1592
      3  1592		       00 ef	   VAREND_aiFinalFlash =	TEMPORARY_VAR
      4  1592
    400  1592
    401  1592							; Piece has finished the animated move and is now in destination square.
    402  1592							; Flash the piece
    403  1592
    404  1592
    405  1592							; TODO: if en-passant, we can remove the piece being taken
    406  1592							; check movePiece for enPassant flag set (x)
    407  1592
    408  1592
    409  1592		       a5 82		      lda	drawDelay
    410  1594		       f0 03		      beq	.deCount
    411  1596		       c6 82		      dec	drawDelay
    412  1598		       60		      rts
    413  1599
    414  1599		       a5 84	   .deCount   lda	drawCount
    415  159b		       f0 0e		      beq	.flashDone2
    416  159d		       c6 84		      dec	drawCount
    417  159f
    418  159f		       a9 0a		      lda	#10
    419  15a1		       85 82		      sta	drawDelay	; "getting ready to move" flash
    420  15a3
    421  15a3		       a5 85		      lda	fromX12
    422  15a5		       85 80		      sta	squareToDraw
    423  15a7
    424  15a7							; WARNING - local variables will not survive the following call...!
    425  15a7		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    426  15aa		       60		      rts
    427  15ab
    428  15ab				   .flashDone2
    429  15ab
    430  15ab		       a9 64		      lda	#100
    431  15ad		       85 8c		      sta	aiFlashDelay
    432  15af
      0  15af					      PHASE	SpecialMoveFixup
      1  15af		       a9 1c		      lda	#AI_SpecialMoveFixup
      2  15b1		       85 8b		      sta	aiState
    434  15b3		       60		      rts
    435  15b4
    436  15b4
    437  15b4							;---------------------------------------------------------------------------------------------------
    438  15b4
      0  15b4					      DEF	aiStartSquareSelected
      1  15b4				   SLOT_aiStartSquareSelected SET	_BANK_SLOT
      2  15b4				   BANK_aiStartSquareSelected SET	SLOT_aiStartSquareSelected + _CURRENT_BANK
      3  15b4				   aiStartSquareSelected
      4  15b4				   TEMPORARY_VAR SET	Overlay
      5  15b4				   TEMPORARY_OFFSET SET	0
      6  15b4				   VAR_BOUNDARY_aiStartSquareSelected SET	TEMPORARY_OFFSET
      7  15b4				   FUNCTION_NAME SET	aiStartSquareSelected
    440  15b4					      SUBROUTINE
    441  15b4
      0  15b4					      REF	AiStateMachine
      1  15b4					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  15b4				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  15b4					      ENDIF
      0  15b4					      VEND	aiStartSquareSelected
      1  15b4
      2  15b4
      3  15b4		       00 a9	   VAREND_aiStartSquareSelected =	TEMPORARY_VAR
      4  15b4
    444  15b4
    445  15b4
    446  15b4							; Mark all the valid moves for the selected piece on the board
    447  15b4							; and then start pulsing the piece
    448  15b4							; AND start choosing for selection of TO square
    449  15b4
    450  15b4							; Iterate the movelist and for all from squares which = drawPieceNumber
    451  15b4							; then draw a BLANK at that square
    452  15b4							; do 1 by one, when none found then increment state
    453  15b4
    454  15b4		       a5 88		      lda	cursorX12
    455  15b6		       85 80		      sta	squareToDraw
    456  15b8
    457  15b8		       a9 0a		      lda	#10
    458  15ba		       85 8c		      sta	aiFlashDelay
    459  15bc
    460  15bc		       a9 00		      lda	#0
    461  15be		       85 86		      sta	toX12	;aiToSquareX12
    462  15c0		       85 8e		      sta	aiFlashPhase	; for debounce exit timing
    463  15c2
    464  15c2		       a9 ff		      lda	#-1
    465  15c4		       85 8d		      sta	aiMoveIndex
    466  15c6
    467  15c6		       a9 28		      lda	#HOLD_DELAY
    468  15c8		       85 89		      sta	mdelay	; hold-down delay before moves are shown
    469  15ca
      0  15ca					      PHASE	DrawMoves
      1  15ca		       a9 04		      lda	#AI_DrawMoves
      2  15cc		       85 8b		      sta	aiState
    471  15ce		       60		      rts
    472  15cf
    473  15cf
    474  15cf							;---------------------------------------------------------------------------------------------------
    475  15cf
      0  15cf					      DEF	aiWriteStartPieceBlank
      1  15cf				   SLOT_aiWriteStartPieceBlank SET	_BANK_SLOT
      2  15cf				   BANK_aiWriteStartPieceBlank SET	SLOT_aiWriteStartPieceBlank + _CURRENT_BANK
      3  15cf				   aiWriteStartPieceBlank
      4  15cf				   TEMPORARY_VAR SET	Overlay
      5  15cf				   TEMPORARY_OFFSET SET	0
      6  15cf				   VAR_BOUNDARY_aiWriteStartPieceBlank SET	TEMPORARY_OFFSET
      7  15cf				   FUNCTION_NAME SET	aiWriteStartPieceBlank
    477  15cf					      SUBROUTINE
    478  15cf
      0  15cf					      REF	Variable_PieceShapeBuffer
      1  15cf					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  15cf				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  15cf					      ENDIF
      0  15cf					      REF	AiStateMachine
      1  15cf				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  15cf				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  15cf					      ENDIF
      0  15cf					      VEND	aiWriteStartPieceBlank
      1  15cf
      2  15cf
      3  15cf		       00 ef	   VAREND_aiWriteStartPieceBlank =	TEMPORARY_VAR
      4  15cf
    482  15cf
    483  15cf							; Flash the piece in-place preparatory to moving it.
    484  15cf							; drawDelay = flash speed
    485  15cf							; drawCount = # of flashes
    486  15cf
    487  15cf
    488  15cf		       a9 04		      lda	#%100
    489  15d1		       85 4a		      sta	CTRLPF
    490  15d3		       a9 40		      lda	#$40
    491  15d5		       85 46		      sta	COLUP0
    492  15d7
    493  15d7
    494  15d7		       a5 82		      lda	drawDelay
    495  15d9		       f0 03		      beq	deCount
    496  15db		       c6 82		      dec	drawDelay
    497  15dd		       60		      rts
    498  15de				   deCount
    499  15de
    500  15de		       a5 84		      lda	drawCount
    501  15e0		       f0 0d		      beq	flashDone
    502  15e2		       c6 84		      dec	drawCount
    503  15e4
    504  15e4		       a9 0a		      lda	#READY_TO_MOVE_FLASH
    505  15e6		       85 82		      sta	drawDelay	; "getting ready to move" flash
    506  15e8
    507  15e8		       a5 85		      lda	fromX12
    508  15ea		       85 80		      sta	squareToDraw
    509  15ec
    510  15ec							; WARNING - local variables will not survive the following call...!
    511  15ec		       4c c1 f0 	      jmp	CopySinglePiece	;@0	      ; EOR-draw = flash
    512  15ef
    513  15ef				   flashDone
    514  15ef
    515  15ef							;lda #2
    516  15ef							;sta drawDelay
      0  15ef					      PHASE	MarchToTargetA
      1  15ef		       a9 16		      lda	#AI_MarchToTargetA
      2  15f1		       85 8b		      sta	aiState
    518  15f3		       60		      rts
    519  15f4
    520  15f4
    521  15f4							;---------------------------------------------------------------------------------------------------
    522  15f4
      0  15f4					      DEF	aiEPHandler
      1  15f4				   SLOT_aiEPHandler SET	_BANK_SLOT
      2  15f4				   BANK_aiEPHandler SET	SLOT_aiEPHandler + _CURRENT_BANK
      3  15f4				   aiEPHandler
      4  15f4				   TEMPORARY_VAR SET	Overlay
      5  15f4				   TEMPORARY_OFFSET SET	0
      6  15f4				   VAR_BOUNDARY_aiEPHandler SET	TEMPORARY_OFFSET
      7  15f4				   FUNCTION_NAME SET	aiEPHandler
    524  15f4					      SUBROUTINE
    525  15f4
    526  15f4							;CALL EnPassantFixupDraw	  ; set enPassantPawn
    527  15f4
    528  15f4
    529  15f4		       a5 96		      lda	fromPiece
    530  15f6		       29 60		      and	#FLAG_ENPASSANT|FLAG_MOVED
    531  15f8		       c9 60		      cmp	#FLAG_ENPASSANT|FLAG_MOVED
    532  15fa		       d0 1a		      bne	.exit
    533  15fc
    534  15fc							; we have deteced a piece DOING an en passant capture
    535  15fc							; so do the actual removal of the captured pawn...
    536  15fc							; calculate the captured pawn's square based on piece colour
    537  15fc
    538  15fc		       a9 f6		      lda	#-10
    539  15fe		       a6 96		      ldx	fromPiece
    540  1600		       10 02		      bpl	.white
    541  1602		       a9 0a		      lda	#10
    542  1604				   .white
    543  1604		       18		      clc
    544  1605		       65 85		      adc	fromX12	; attacker destination square
    545  1607		       85 93		      sta	enPassantPawn	; now this is the pawn to ERASE
    546  1609
    547  1609		       a9 05		      lda	#5	; on/off count (leave undrawn)
    548  160b		       85 84		      sta	drawCount	; flashing for piece about to move
    549  160d		       a9 00		      lda	#0
    550  160f		       85 82		      sta	drawDelay
    551  1611
      0  1611					      PHASE	EPFlash
      1  1611		       a9 2a		      lda	#AI_EPFlash
      2  1613		       85 8b		      sta	aiState
    553  1615		       60		      rts
    554  1616
    555  1616
    556  1616				   .exit
    557  1616
    558  1616		       a9 04		      lda	#4	; on/off count (leave undrawn)
    559  1618		       85 84		      sta	drawCount	; flashing for piece about to move
    560  161a		       a9 00		      lda	#0
    561  161c		       85 82		      sta	drawDelay
    562  161e
      0  161e					      PHASE	FinalFlash
      1  161e		       a9 1b		      lda	#AI_FinalFlash
      2  1620		       85 8b		      sta	aiState
    564  1622		       60		      rts
    565  1623
    566  1623
    567  1623							;---------------------------------------------------------------------------------------------------
    568  1623
      0  1623					      END_BANK
      1  1623				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  1623				  -	      CHECK_RAM_BANK_SIZE
      3  1623					      ELSE
      0  1623					      CHECK_BANK_SIZE
      1  1623		       02 23	   .TEMP      =	* - _BANK_START
 ROM bank # 6 STATEMACHINE2 size = $223 free = 476
      2  1623					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  1623				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1623				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  1623				  -	      ERR
      6  1623					      ENDIF
      5  1623					      ENDIF
    570  1623
    571  1623							;---------------------------------------------------------------------------------------------------
    572  1623							; EOF
------- FILE ./chess.asm
------- FILE @1 PIECE HANDLER #1.asm LEVEL 2 PASS 4
      0  1623					      include	"@1 PIECE HANDLER #1.asm"
      1  1623							;---------------------------------------------------------------------------------------------------
      2  1623							; @1 PIECE HANDLER #1.asm
      3  1623
      4  1623							; Atari 2600 Chess
      5  1623							; Copyright (c) 2019-2020 Andrew Davie
      6  1623							; andrew@taswegian.com
      7  1623
      8  1623
      9  1623							;---------------------------------------------------------------------------------------------------
     10  1623
      0  1623					      SLOT	1
      1  1623
      2  1623				  -	      IF	(1 < 0) || (1 > 3)
      3  1623				  -	      ECHO	"Illegal bank address/segment location", 1
      4  1623				  -	      ERR
      5  1623					      ENDIF
      6  1623
      7  1623				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  1623				   _BANK_SLOT SET	1 * 64
      9  1623
      0  1623					      ROMBANK	PIECE_HANDLER_1
      1  1acc ????				      SEG	ROM_PIECE_HANDLER_1
      2  1800					      ORG	_ORIGIN
      3  1800					      RORG	_BANK_ADDRESS_ORIGIN
      4  1800				   _BANK_START SET	*
      5  1800				   PIECE_HANDLER_1_START SET	*
      6  1800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  1800				   ROMBANK_PIECE_HANDLER_1 SET	_BANK_SLOT + _CURRENT_BANK
      8  1800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  1800				   _LAST_BANK SETSTR	PIECE_HANDLER_1
     10  1800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  1800
------- FILE PIECE_PAWN.asm LEVEL 3 PASS 4
      0  1800					      include	"PIECE_PAWN.asm"
      1  1800							; Copyright (C)2020 Andrew Davie
      2  1800							; Pawn move handlers
      3  1800
      4  1800							;---------------------------------------------------------------------------------------------------
      5  1800							; WHITE PAWN
      6  1800							;---------------------------------------------------------------------------------------------------
      7  1800
      8  1800		       00 28	   WHITE_HOME_ROW =	40	; < this, on home row
      9  1800		       00 52	   BLACK_HOME_ROW =	82	; >= this, on home row
     10  1800
     11  1800							;---------------------------------------------------------------------------------------------------
     12  1800
     13  1800					      MAC	en_passant
     14  1800					      SUBROUTINE
     15  1800							; {1} = _LEFT or _RIGHT
     16  1800
     17  1800					      ldx	currentSquare
     18  1800					      ldy	ValidSquare+{1},x
     19  1800					      cpy	enPassantPawn
     20  1800					      bne	.invalid
     21  1800					      ldy	ValidSquare+{1}+{2},x	; en-passant endpoint must be blank
     22  1800					      lda	Board,y
     23  1800					      bne	.invalid
     24  1800					      jsr	AddMove	; the MOVE will need to deal with the details of en-passant??
     25  1800				   .invalid
     26  1800					      ENDM
     27  1800
     28  1800							;---------------------------------------------------------------------------------------------------
     29  1800
     30  1800					      MAC	promote_pawn
     31  1800							;SUBROUTINE
     32  1800
     33  1800							;{1} = BLACK or WHITE
     34  1800
     35  1800
     36  1800					      sty	__temp
     37  1800					      lda	#{1}|QUEEN
     38  1800					      sta	currentPiece
     39  1800					      jsr	AddMove
     40  1800
     41  1800					      lda	#{1}|ROOK
     42  1800					      sta	currentPiece
     43  1800					      ldy	__temp
     44  1800					      jsr	AddMove
     45  1800
     46  1800					      lda	#{1}|BISHOP
     47  1800					      sta	currentPiece
     48  1800					      ldy	__temp
     49  1800					      jsr	AddMove
     50  1800
     51  1800					      lda	#{1}|KNIGHT
     52  1800					      sta	currentPiece
     53  1800					      ldy	__temp
     54  1800					      jsr	AddMove
     55  1800
     56  1800					      IF	{1} = WHITE
     57  1800					      lda	#WHITE|WP
     58  1800					      ENDIF
     59  1800					      IF	{1} = BLACK
     60  1800					      lda	#BLACK|BP
     61  1800					      ENDIF
     62  1800					      sta	currentPiece
     63  1800					      ENDM
     64  1800
     65  1800							;---------------------------------------------------------------------------------------------------
     66  1800
     67  1800					      MAC	move_or_promote_pawn
     68  1800							;SUBROUTINE
     69  1800							; {1} = BLACK or WHITE
     70  1800
     71  1800					      IF	{1} = WHITE
     72  1800					      cpy	#90	; last rank?
     73  1800					      bcc	.standard
     74  1800					      jsr	PromoteWhitePawn
     75  1800					      jmp	.pMoved
     76  1800					      ENDIF
     77  1800
     78  1800					      IF	{1} = BLACK
     79  1800					      cpy	#30	; last rank?
     80  1800					      bcs	.standard
     81  1800					      jsr	PromoteBlackPawn
     82  1800					      jmp	.pMoved
     83  1800					      ENDIF
     84  1800
     85  1800				   .standard  jsr	AddMove	; add +1UP move
     86  1800				   .pMoved
     87  1800
     88  1800					      ENDM
     89  1800
     90  1800							;---------------------------------------------------------------------------------------------------
     91  1800
     92  1800					      MAC	take
     93  1800							;SUBROUTINE
     94  1800							; {1} = capture square offset
     95  1800
     96  1800					      ldx	currentSquare
     97  1800					      ldy	ValidSquare+{1},x
     98  1800					      bmi	.invalid2
     99  1800					      lda	Board,y
    100  1800					      beq	.invalid2	; square empty
    101  1800					      sta	capture
    102  1800					      eor	currentPiece
    103  1800					      bpl	.invalid	; same colour
    104  1800
    105  1800					      MOVE_OR_PROMOTE_PAWN	{2}
    106  1800
    107  1800					      jmp	.invalid2
    108  1800				   .invalid   inc	protecting
    109  1800				   .invalid2
    110  1800					      ENDM
    111  1800
    112  1800							;---------------------------------------------------------------------------------------------------
    113  1800
      0  1800					      DEF	PromoteWhitePawn
      1  1800				   SLOT_PromoteWhitePawn SET	_BANK_SLOT
      2  1800				   BANK_PromoteWhitePawn SET	SLOT_PromoteWhitePawn + _CURRENT_BANK
      3  1800				   PromoteWhitePawn
      4  1800				   TEMPORARY_VAR SET	Overlay
      5  1800				   TEMPORARY_OFFSET SET	0
      6  1800				   VAR_BOUNDARY_PromoteWhitePawn SET	TEMPORARY_OFFSET
      7  1800				   FUNCTION_NAME SET	PromoteWhitePawn
    115  1800					      SUBROUTINE
    116  1800
      0  1800					      REF	Handle_WHITE_PAWN
      1  1800					      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  1800				   TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  1800					      ENDIF
      0  1800					      VAR	__temp, 1
      1  1800
      2  1800		       00 b8	   __temp     =	TEMPORARY_VAR
      3  1800				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  1800
      5  1800				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  1800				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  1800				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  1800					      ENDIF
      9  1800				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  1800				  -	      LIST	ON
     11  1800				  -VNAME      SETSTR	__temp
     12  1800				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  1800				  -	      ERR
     14  1800				  -	      ECHO	"Temporary Variable overlow!"
     15  1800					      ENDIF
     16  1800					      LIST	ON
      0  1800					      VEND	PromoteWhitePawn
      1  1800
      2  1800
      3  1800		       00 b9	   VAREND_PromoteWhitePawn =	TEMPORARY_VAR
      4  1800
    120  1800
      0  1800					      PROMOTE_PAWN	WHITE
      1  1800
      2  1800
      3  1800
      4  1800
      5  1800
      6  1800		       84 b8		      sty	__temp
      7  1802		       a9 06		      lda	#WHITE|QUEEN
      8  1804		       85 91		      sta	currentPiece
      9  1806		       20 85 f2 	      jsr	AddMove
     10  1809
     11  1809		       a9 05		      lda	#WHITE|ROOK
     12  180b		       85 91		      sta	currentPiece
     13  180d		       a4 b8		      ldy	__temp
     14  180f		       20 85 f2 	      jsr	AddMove
     15  1812
     16  1812		       a9 04		      lda	#WHITE|BISHOP
     17  1814		       85 91		      sta	currentPiece
     18  1816		       a4 b8		      ldy	__temp
     19  1818		       20 85 f2 	      jsr	AddMove
     20  181b
     21  181b		       a9 03		      lda	#WHITE|KNIGHT
     22  181d		       85 91		      sta	currentPiece
     23  181f		       a4 b8		      ldy	__temp
     24  1821		       20 85 f2 	      jsr	AddMove
     25  1824
     26  1824					      IF	WHITE = WHITE
     27  1824		       a9 01		      lda	#WHITE|WP
     28  1826					      ENDIF
     29  1826				  -	      IF	WHITE = BLACK
     30  1826				  -	      lda	#BLACK|BP
     31  1826					      ENDIF
     32  1826		       85 91		      sta	currentPiece
    122  1828		       60		      rts
    123  1829
    124  1829							;---------------------------------------------------------------------------------------------------
    125  1829
      0  1829					      DEF	Handle_WHITE_PAWN
      1  1829				   SLOT_Handle_WHITE_PAWN SET	_BANK_SLOT
      2  1829				   BANK_Handle_WHITE_PAWN SET	SLOT_Handle_WHITE_PAWN + _CURRENT_BANK
      3  1829				   Handle_WHITE_PAWN
      4  1829				   TEMPORARY_VAR SET	Overlay
      5  1829				   TEMPORARY_OFFSET SET	0
      6  1829				   VAR_BOUNDARY_Handle_WHITE_PAWN SET	TEMPORARY_OFFSET
      7  1829				   FUNCTION_NAME SET	Handle_WHITE_PAWN
    127  1829					      SUBROUTINE
    128  1829
      0  1829					      REF	GenerateAllMoves
      1  1829					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1829				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1829					      ENDIF
      0  1829					      VEND	Handle_WHITE_PAWN
      1  1829
      2  1829
      3  1829		       00 b8	   VAREND_Handle_WHITE_PAWN =	TEMPORARY_VAR
      4  1829
    131  1829
    132  1829		       bc 1f fc 	      ldy	ValidSquare+_UP,x	; square above must be blank (WILL NOT EVER be off-board!)
    133  182c		       b9 79 fc 	      lda	Board,y
    134  182f		       d0 26		      bne	.pMoved	; occupied
    135  1831		       85 9b		      sta	capture
    136  1833
    137  1833							; we may need to promote the pawn
    138  1833							; All possibilites (Q/R/B/N) are added as individual moves
    139  1833
      0  1833					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  1833
      2  1833
      3  1833
      4  1833					      IF	WHITE = WHITE
      5  1833		       c0 5a		      cpy	#90
      6  1835		       90 06		      bcc	.standard
      7  1837		       20 00 f4 	      jsr	PromoteWhitePawn
      8  183a		       4c 40 f4 	      jmp	.pMoved
      9  183d					      ENDIF
     10  183d
     11  183d				  -	      IF	WHITE = BLACK
     12  183d				  -	      cpy	#30
     13  183d				  -	      bcs	.standard
     14  183d				  -	      jsr	PromoteBlackPawn
     15  183d				  -	      jmp	.pMoved
     16  183d					      ENDIF
     17  183d
     18  183d		       20 85 f2    .standard  jsr	AddMove
     19  1840				   .pMoved
     20  1840
    141  1840
    142  1840							; the +2 move off the home rank...
    143  1840
    144  1840		       a6 92		      ldx	currentSquare
    145  1842		       e0 28		      cpx	#WHITE_HOME_ROW
    146  1844		       b0 11		      bcs	.pMoved	; pawn has moved so can't do +2
    147  1846		       bc 29 fc 	      ldy	ValidSquare+_UP+_UP,x	; WILL be a valid square
    148  1849		       b9 79 fc 	      lda	Board,y
    149  184c		       d0 09		      bne	.pMoved	; destination square occupied
    150  184e
    151  184e		       a5 91		      lda	currentPiece
    152  1850		       09 20		      ora	#FLAG_ENPASSANT
    153  1852		       85 91		      sta	currentPiece	; GENERATE en-passant opportunity
    154  1854
    155  1854		       20 85 f2 	      jsr	AddMove	; add the +2UP move off home row
    156  1857
    157  1857				   .pMoved
    158  1857
    159  1857							; regular captures...
    160  1857
      0  1857					      TAKE	_UP+_LEFT, WHITE
      1  1857
      2  1857
      3  1857
      4  1857		       a6 92		      ldx	currentSquare
      5  1859		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      6  185c		       30 1d		      bmi	.invalid2
      7  185e		       b9 79 fc 	      lda	Board,y
      8  1861		       f0 18		      beq	.invalid2
      9  1863		       85 9b		      sta	capture
     10  1865		       45 91		      eor	currentPiece
     11  1867		       10 10		      bpl	.invalid
     12  1869
      0  1869					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  1869
      2  1869
      3  1869
      4  1869					      IF	WHITE = WHITE
      5  1869		       c0 5a		      cpy	#90
      6  186b		       90 06		      bcc	.standard
      7  186d		       20 00 f4 	      jsr	PromoteWhitePawn
      8  1870		       4c 76 f4 	      jmp	.pMoved
      9  1873					      ENDIF
     10  1873
     11  1873				  -	      IF	WHITE = BLACK
     12  1873				  -	      cpy	#30
     13  1873				  -	      bcs	.standard
     14  1873				  -	      jsr	PromoteBlackPawn
     15  1873				  -	      jmp	.pMoved
     16  1873					      ENDIF
     17  1873
     18  1873		       20 85 f2    .standard  jsr	AddMove
     19  1876				   .pMoved
     20  1876
     14  1876
     15  1876		       4c 7b f4 	      jmp	.invalid2
     16  1879		       e6 a0	   .invalid   inc	protecting
     17  187b				   .invalid2
      0  187b					      TAKE	_UP+_RIGHT, WHITE
      1  187b
      2  187b
      3  187b
      4  187b		       a6 92		      ldx	currentSquare
      5  187d		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      6  1880		       30 1d		      bmi	.invalid2
      7  1882		       b9 79 fc 	      lda	Board,y
      8  1885		       f0 18		      beq	.invalid2
      9  1887		       85 9b		      sta	capture
     10  1889		       45 91		      eor	currentPiece
     11  188b		       10 10		      bpl	.invalid
     12  188d
      0  188d					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  188d
      2  188d
      3  188d
      4  188d					      IF	WHITE = WHITE
      5  188d		       c0 5a		      cpy	#90
      6  188f		       90 06		      bcc	.standard
      7  1891		       20 00 f4 	      jsr	PromoteWhitePawn
      8  1894		       4c 9a f4 	      jmp	.pMoved
      9  1897					      ENDIF
     10  1897
     11  1897				  -	      IF	WHITE = BLACK
     12  1897				  -	      cpy	#30
     13  1897				  -	      bcs	.standard
     14  1897				  -	      jsr	PromoteBlackPawn
     15  1897				  -	      jmp	.pMoved
     16  1897					      ENDIF
     17  1897
     18  1897		       20 85 f2    .standard  jsr	AddMove
     19  189a				   .pMoved
     20  189a
     14  189a
     15  189a		       4c 9f f4 	      jmp	.invalid2
     16  189d		       e6 a0	   .invalid   inc	protecting
     17  189f				   .invalid2
    163  189f
    164  189f
    165  189f					      IF	ENPASSANT_ENABLED
    166  189f							; en-passant captures...
    167  189f
    168  189f		       a5 93		      lda	enPassantPawn
    169  18a1		       f0 2e		      beq	.noEnPassant	; previous move (opponent) enpassant square?
    170  18a3
    171  18a3		       a5 91		      lda	currentPiece
    172  18a5		       09 20		      ora	#FLAG_ENPASSANT
    173  18a7		       85 91		      sta	currentPiece	; CONSUME en-passant opportunity
    174  18a9
      0  18a9					      EN_PASSANT	_LEFT, _UP
      1  18a9					      SUBROUTINE
      2  18a9
      3  18a9
      4  18a9		       a6 92		      ldx	currentSquare
      5  18ab		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      6  18ae		       c4 93		      cpy	enPassantPawn
      7  18b0		       d0 0b		      bne	.invalid
      8  18b2		       bc 1e fc 	      ldy	ValidSquare+_LEFT+_UP,x
      9  18b5		       b9 79 fc 	      lda	Board,y
     10  18b8		       d0 03		      bne	.invalid
     11  18ba		       20 85 f2 	      jsr	AddMove
     12  18bd				   .invalid
      0  18bd					      EN_PASSANT	_RIGHT, _UP
      1  18bd					      SUBROUTINE
      2  18bd
      3  18bd
      4  18bd		       a6 92		      ldx	currentSquare
      5  18bf		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      6  18c2		       c4 93		      cpy	enPassantPawn
      7  18c4		       d0 0b		      bne	.invalid
      8  18c6		       bc 20 fc 	      ldy	ValidSquare+_RIGHT+_UP,x
      9  18c9		       b9 79 fc 	      lda	Board,y
     10  18cc		       d0 03		      bne	.invalid
     11  18ce		       20 85 f2 	      jsr	AddMove
     12  18d1				   .invalid
    177  18d1
    178  18d1				   .noEnPassant
    179  18d1					      ENDIF
    180  18d1
    181  18d1		       4c e8 f1 	      jmp	MoveReturn
    182  18d4
    183  18d4
    184  18d4							;---------------------------------------------------------------------------------------------------
    185  18d4							; BLACK PAWN
    186  18d4							;---------------------------------------------------------------------------------------------------
    187  18d4
      0  18d4					      DEF	PromoteBlackPawn
      1  18d4				   SLOT_PromoteBlackPawn SET	_BANK_SLOT
      2  18d4				   BANK_PromoteBlackPawn SET	SLOT_PromoteBlackPawn + _CURRENT_BANK
      3  18d4				   PromoteBlackPawn
      4  18d4				   TEMPORARY_VAR SET	Overlay
      5  18d4				   TEMPORARY_OFFSET SET	0
      6  18d4				   VAR_BOUNDARY_PromoteBlackPawn SET	TEMPORARY_OFFSET
      7  18d4				   FUNCTION_NAME SET	PromoteBlackPawn
    189  18d4					      SUBROUTINE
    190  18d4
      0  18d4					      REF	Handle_BLACK_PAWN
      1  18d4					      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  18d4				   TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  18d4					      ENDIF
      0  18d4					      VAR	__temp, 1
      1  18d4
      2  18d4		       00 b8	   __temp     =	TEMPORARY_VAR
      3  18d4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  18d4
      5  18d4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  18d4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  18d4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  18d4					      ENDIF
      9  18d4				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  18d4				  -	      LIST	ON
     11  18d4				  -VNAME      SETSTR	__temp
     12  18d4				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  18d4				  -	      ERR
     14  18d4				  -	      ECHO	"Temporary Variable overlow!"
     15  18d4					      ENDIF
     16  18d4					      LIST	ON
      0  18d4					      VEND	PromoteBlackPawn
      1  18d4
      2  18d4
      3  18d4		       00 b9	   VAREND_PromoteBlackPawn =	TEMPORARY_VAR
      4  18d4
    194  18d4
      0  18d4					      PROMOTE_PAWN	BLACK
      1  18d4
      2  18d4
      3  18d4
      4  18d4
      5  18d4
      6  18d4		       84 b8		      sty	__temp
      7  18d6		       a9 86		      lda	#BLACK|QUEEN
      8  18d8		       85 91		      sta	currentPiece
      9  18da		       20 85 f2 	      jsr	AddMove
     10  18dd
     11  18dd		       a9 85		      lda	#BLACK|ROOK
     12  18df		       85 91		      sta	currentPiece
     13  18e1		       a4 b8		      ldy	__temp
     14  18e3		       20 85 f2 	      jsr	AddMove
     15  18e6
     16  18e6		       a9 84		      lda	#BLACK|BISHOP
     17  18e8		       85 91		      sta	currentPiece
     18  18ea		       a4 b8		      ldy	__temp
     19  18ec		       20 85 f2 	      jsr	AddMove
     20  18ef
     21  18ef		       a9 83		      lda	#BLACK|KNIGHT
     22  18f1		       85 91		      sta	currentPiece
     23  18f3		       a4 b8		      ldy	__temp
     24  18f5		       20 85 f2 	      jsr	AddMove
     25  18f8
     26  18f8				  -	      IF	BLACK = WHITE
     27  18f8				  -	      lda	#WHITE|WP
     28  18f8					      ENDIF
     29  18f8					      IF	BLACK = BLACK
     30  18f8		       a9 82		      lda	#BLACK|BP
     31  18fa					      ENDIF
     32  18fa		       85 91		      sta	currentPiece
    196  18fc		       60		      rts
    197  18fd
      0  18fd					      DEF	Handle_BLACK_PAWN
      1  18fd				   SLOT_Handle_BLACK_PAWN SET	_BANK_SLOT
      2  18fd				   BANK_Handle_BLACK_PAWN SET	SLOT_Handle_BLACK_PAWN + _CURRENT_BANK
      3  18fd				   Handle_BLACK_PAWN
      4  18fd				   TEMPORARY_VAR SET	Overlay
      5  18fd				   TEMPORARY_OFFSET SET	0
      6  18fd				   VAR_BOUNDARY_Handle_BLACK_PAWN SET	TEMPORARY_OFFSET
      7  18fd				   FUNCTION_NAME SET	Handle_BLACK_PAWN
    199  18fd					      SUBROUTINE
    200  18fd
      0  18fd					      REF	GenerateAllMoves
      1  18fd					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  18fd				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  18fd					      ENDIF
      0  18fd					      VEND	Handle_BLACK_PAWN
      1  18fd
      2  18fd
      3  18fd		       00 b8	   VAREND_Handle_BLACK_PAWN =	TEMPORARY_VAR
      4  18fd
    203  18fd
    204  18fd		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x	; square below must be blank (WILL NOT EVER be off-board!)
    205  1900		       b9 79 fc 	      lda	Board,y
    206  1903		       d0 26		      bne	.pMoved	; occupied
    207  1905		       85 9b		      sta	capture
    208  1907
    209  1907							; we may need to promote the pawn
    210  1907							; All possibilites (Q/R/B/N) are added as individual moves
    211  1907
      0  1907					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  1907
      2  1907
      3  1907
      4  1907				  -	      IF	BLACK = WHITE
      5  1907				  -	      cpy	#90
      6  1907				  -	      bcc	.standard
      7  1907				  -	      jsr	PromoteWhitePawn
      8  1907				  -	      jmp	.pMoved
      9  1907					      ENDIF
     10  1907
     11  1907					      IF	BLACK = BLACK
     12  1907		       c0 1e		      cpy	#30
     13  1909		       b0 06		      bcs	.standard
     14  190b		       20 d4 f4 	      jsr	PromoteBlackPawn
     15  190e		       4c 14 f5 	      jmp	.pMoved
     16  1911					      ENDIF
     17  1911
     18  1911		       20 85 f2    .standard  jsr	AddMove
     19  1914				   .pMoved
     20  1914
    213  1914
    214  1914							; the +2 move off the home rank...
    215  1914
    216  1914		       a6 92		      ldx	currentSquare
    217  1916		       e0 52		      cpx	#BLACK_HOME_ROW
    218  1918		       90 11		      bcc	.pMoved	; pawn has moved so can't do +2
    219  191a
    220  191a
    221  191a		       bc 01 fc 	      ldy	ValidSquare+_DOWN+_DOWN,x	; WILL be a valid square
    222  191d		       b9 79 fc 	      lda	Board,y
    223  1920		       d0 09		      bne	.pMoved	; destination square occupied
    224  1922
    225  1922		       a5 91		      lda	currentPiece
    226  1924		       09 20		      ora	#FLAG_ENPASSANT
    227  1926		       85 91		      sta	currentPiece	; CAN en-passant
    228  1928
    229  1928		       20 85 f2 	      jsr	AddMove	; add the +2DOWN move off home row
    230  192b
    231  192b				   .pMoved
    232  192b
    233  192b							; regular captures... (with promotion)
    234  192b
      0  192b					      TAKE	_DOWN+_LEFT, BLACK
      1  192b
      2  192b
      3  192b
      4  192b		       a6 92		      ldx	currentSquare
      5  192d		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      6  1930		       30 1d		      bmi	.invalid2
      7  1932		       b9 79 fc 	      lda	Board,y
      8  1935		       f0 18		      beq	.invalid2
      9  1937		       85 9b		      sta	capture
     10  1939		       45 91		      eor	currentPiece
     11  193b		       10 10		      bpl	.invalid
     12  193d
      0  193d					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  193d
      2  193d
      3  193d
      4  193d				  -	      IF	BLACK = WHITE
      5  193d				  -	      cpy	#90
      6  193d				  -	      bcc	.standard
      7  193d				  -	      jsr	PromoteWhitePawn
      8  193d				  -	      jmp	.pMoved
      9  193d					      ENDIF
     10  193d
     11  193d					      IF	BLACK = BLACK
     12  193d		       c0 1e		      cpy	#30
     13  193f		       b0 06		      bcs	.standard
     14  1941		       20 d4 f4 	      jsr	PromoteBlackPawn
     15  1944		       4c 4a f5 	      jmp	.pMoved
     16  1947					      ENDIF
     17  1947
     18  1947		       20 85 f2    .standard  jsr	AddMove
     19  194a				   .pMoved
     20  194a
     14  194a
     15  194a		       4c 4f f5 	      jmp	.invalid2
     16  194d		       e6 a0	   .invalid   inc	protecting
     17  194f				   .invalid2
      0  194f					      TAKE	_DOWN+_RIGHT, BLACK
      1  194f
      2  194f
      3  194f
      4  194f		       a6 92		      ldx	currentSquare
      5  1951		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      6  1954		       30 1d		      bmi	.invalid2
      7  1956		       b9 79 fc 	      lda	Board,y
      8  1959		       f0 18		      beq	.invalid2
      9  195b		       85 9b		      sta	capture
     10  195d		       45 91		      eor	currentPiece
     11  195f		       10 10		      bpl	.invalid
     12  1961
      0  1961					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  1961
      2  1961
      3  1961
      4  1961				  -	      IF	BLACK = WHITE
      5  1961				  -	      cpy	#90
      6  1961				  -	      bcc	.standard
      7  1961				  -	      jsr	PromoteWhitePawn
      8  1961				  -	      jmp	.pMoved
      9  1961					      ENDIF
     10  1961
     11  1961					      IF	BLACK = BLACK
     12  1961		       c0 1e		      cpy	#30
     13  1963		       b0 06		      bcs	.standard
     14  1965		       20 d4 f4 	      jsr	PromoteBlackPawn
     15  1968		       4c 6e f5 	      jmp	.pMoved
     16  196b					      ENDIF
     17  196b
     18  196b		       20 85 f2    .standard  jsr	AddMove
     19  196e				   .pMoved
     20  196e
     14  196e
     15  196e		       4c 73 f5 	      jmp	.invalid2
     16  1971		       e6 a0	   .invalid   inc	protecting
     17  1973				   .invalid2
    237  1973
    238  1973
    239  1973					      IF	ENPASSANT_ENABLED
    240  1973							; en-passant captures...
    241  1973
    242  1973		       a5 93		      lda	enPassantPawn
    243  1975		       f0 2e		      beq	.noEnPassant	; was last move en-passantable?
    244  1977
    245  1977		       a5 91		      lda	currentPiece
    246  1979		       09 20		      ora	#FLAG_ENPASSANT
    247  197b		       85 91		      sta	currentPiece	; any en-passant move added will have flag set
    248  197d
      0  197d					      EN_PASSANT	_LEFT, _DOWN
      1  197d					      SUBROUTINE
      2  197d
      3  197d
      4  197d		       a6 92		      ldx	currentSquare
      5  197f		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      6  1982		       c4 93		      cpy	enPassantPawn
      7  1984		       d0 0b		      bne	.invalid
      8  1986		       bc 0a fc 	      ldy	ValidSquare+_LEFT+_DOWN,x
      9  1989		       b9 79 fc 	      lda	Board,y
     10  198c		       d0 03		      bne	.invalid
     11  198e		       20 85 f2 	      jsr	AddMove
     12  1991				   .invalid
      0  1991					      EN_PASSANT	_RIGHT, _DOWN
      1  1991					      SUBROUTINE
      2  1991
      3  1991
      4  1991		       a6 92		      ldx	currentSquare
      5  1993		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      6  1996		       c4 93		      cpy	enPassantPawn
      7  1998		       d0 0b		      bne	.invalid
      8  199a		       bc 0c fc 	      ldy	ValidSquare+_RIGHT+_DOWN,x
      9  199d		       b9 79 fc 	      lda	Board,y
     10  19a0		       d0 03		      bne	.invalid
     11  19a2		       20 85 f2 	      jsr	AddMove
     12  19a5				   .invalid
    251  19a5
    252  19a5				   .noEnPassant
    253  19a5					      ENDIF
    254  19a5
    255  19a5		       4c e8 f1 	      jmp	MoveReturn
    256  19a8
    257  19a8							; EOF
------- FILE @1 PIECE HANDLER #1.asm
------- FILE PIECE_KNIGHT.asm LEVEL 3 PASS 4
      0  19a8					      include	"PIECE_KNIGHT.asm"
      1  19a8							; Copyright (C)2020 Andrew Davie
      2  19a8							; Knight move handler
      3  19a8
      4  19a8							;---------------------------------------------------------------------------------------------------
      5  19a8							; KNIGHT
      6  19a8							;---------------------------------------------------------------------------------------------------
      7  19a8
      0  19a8					      DEF	Handle_KNIGHT
      1  19a8				   SLOT_Handle_KNIGHT SET	_BANK_SLOT
      2  19a8				   BANK_Handle_KNIGHT SET	SLOT_Handle_KNIGHT + _CURRENT_BANK
      3  19a8				   Handle_KNIGHT
      4  19a8				   TEMPORARY_VAR SET	Overlay
      5  19a8				   TEMPORARY_OFFSET SET	0
      6  19a8				   VAR_BOUNDARY_Handle_KNIGHT SET	TEMPORARY_OFFSET
      7  19a8				   FUNCTION_NAME SET	Handle_KNIGHT
      9  19a8					      SUBROUTINE
     10  19a8
      0  19a8					      REF	GenerateAllMoves	;✅
      1  19a8					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  19a8				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  19a8					      ENDIF
      0  19a8					      VEND	Handle_KNIGHT
      1  19a8
      2  19a8
      3  19a8		       00 b8	   VAREND_Handle_KNIGHT =	TEMPORARY_VAR
      4  19a8
     13  19a8
     14  19a8							; x = currentSquare (square the piece is on)
     15  19a8							; currentPiece (with flags/colour attached)
     16  19a8
      0  19a8					      MOVE_TO	_DOWN+_DOWN+_LEFT
      1  19a8					      SUBROUTINE
      2  19a8
      3  19a8		       bc 00 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_LEFT,x
      4  19ab		       30 0e		      bmi	.invalid
      5  19ad		       b9 79 fc 	      lda	Board,y
      6  19b0		       85 9b		      sta	capture
      7  19b2		       f0 04		      beq	.squareEmpty
      8  19b4		       45 91		      eor	currentPiece
      9  19b6		       10 03		      bpl	.invalid
     10  19b8		       20 85 f2    .squareEmpty jsr	AddMove
     11  19bb				   .invalid
     12  19bb
      0  19bb					      MOVE_TO_X	_DOWN+_DOWN+_RIGHT
      1  19bb		       a6 92		      ldx	currentSquare
      0  19bd					      MOVE_TO	_DOWN+_DOWN+_RIGHT
      1  19bd					      SUBROUTINE
      2  19bd
      3  19bd		       bc 02 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_RIGHT,x
      4  19c0		       30 0e		      bmi	.invalid
      5  19c2		       b9 79 fc 	      lda	Board,y
      6  19c5		       85 9b		      sta	capture
      7  19c7		       f0 04		      beq	.squareEmpty
      8  19c9		       45 91		      eor	currentPiece
      9  19cb		       10 03		      bpl	.invalid
     10  19cd		       20 85 f2    .squareEmpty jsr	AddMove
     11  19d0				   .invalid
     12  19d0
      0  19d0					      MOVE_TO_X	_UP+_UP+_LEFT
      1  19d0		       a6 92		      ldx	currentSquare
      0  19d2					      MOVE_TO	_UP+_UP+_LEFT
      1  19d2					      SUBROUTINE
      2  19d2
      3  19d2		       bc 28 fc 	      ldy	ValidSquare+_UP+_UP+_LEFT,x
      4  19d5		       30 0e		      bmi	.invalid
      5  19d7		       b9 79 fc 	      lda	Board,y
      6  19da		       85 9b		      sta	capture
      7  19dc		       f0 04		      beq	.squareEmpty
      8  19de		       45 91		      eor	currentPiece
      9  19e0		       10 03		      bpl	.invalid
     10  19e2		       20 85 f2    .squareEmpty jsr	AddMove
     11  19e5				   .invalid
     12  19e5
      0  19e5					      MOVE_TO_X	_UP+_UP+_RIGHT
      1  19e5		       a6 92		      ldx	currentSquare
      0  19e7					      MOVE_TO	_UP+_UP+_RIGHT
      1  19e7					      SUBROUTINE
      2  19e7
      3  19e7		       bc 2a fc 	      ldy	ValidSquare+_UP+_UP+_RIGHT,x
      4  19ea		       30 0e		      bmi	.invalid
      5  19ec		       b9 79 fc 	      lda	Board,y
      6  19ef		       85 9b		      sta	capture
      7  19f1		       f0 04		      beq	.squareEmpty
      8  19f3		       45 91		      eor	currentPiece
      9  19f5		       10 03		      bpl	.invalid
     10  19f7		       20 85 f2    .squareEmpty jsr	AddMove
     11  19fa				   .invalid
     12  19fa
     21  19fa
      0  19fa					      MOVE_TO_X	_DOWN+_LEFT+_LEFT
      1  19fa		       a6 92		      ldx	currentSquare
      0  19fc					      MOVE_TO	_DOWN+_LEFT+_LEFT
      1  19fc					      SUBROUTINE
      2  19fc
      3  19fc		       bc 09 fc 	      ldy	ValidSquare+_DOWN+_LEFT+_LEFT,x
      4  19ff		       30 0e		      bmi	.invalid
      5  1a01		       b9 79 fc 	      lda	Board,y
      6  1a04		       85 9b		      sta	capture
      7  1a06		       f0 04		      beq	.squareEmpty
      8  1a08		       45 91		      eor	currentPiece
      9  1a0a		       10 03		      bpl	.invalid
     10  1a0c		       20 85 f2    .squareEmpty jsr	AddMove
     11  1a0f				   .invalid
     12  1a0f
      0  1a0f					      MOVE_TO_X	_DOWN+_RIGHT+_RIGHT
      1  1a0f		       a6 92		      ldx	currentSquare
      0  1a11					      MOVE_TO	_DOWN+_RIGHT+_RIGHT
      1  1a11					      SUBROUTINE
      2  1a11
      3  1a11		       bc 0d fc 	      ldy	ValidSquare+_DOWN+_RIGHT+_RIGHT,x
      4  1a14		       30 0e		      bmi	.invalid
      5  1a16		       b9 79 fc 	      lda	Board,y
      6  1a19		       85 9b		      sta	capture
      7  1a1b		       f0 04		      beq	.squareEmpty
      8  1a1d		       45 91		      eor	currentPiece
      9  1a1f		       10 03		      bpl	.invalid
     10  1a21		       20 85 f2    .squareEmpty jsr	AddMove
     11  1a24				   .invalid
     12  1a24
      0  1a24					      MOVE_TO_X	_UP+_LEFT+_LEFT
      1  1a24		       a6 92		      ldx	currentSquare
      0  1a26					      MOVE_TO	_UP+_LEFT+_LEFT
      1  1a26					      SUBROUTINE
      2  1a26
      3  1a26		       bc 1d fc 	      ldy	ValidSquare+_UP+_LEFT+_LEFT,x
      4  1a29		       30 0e		      bmi	.invalid
      5  1a2b		       b9 79 fc 	      lda	Board,y
      6  1a2e		       85 9b		      sta	capture
      7  1a30		       f0 04		      beq	.squareEmpty
      8  1a32		       45 91		      eor	currentPiece
      9  1a34		       10 03		      bpl	.invalid
     10  1a36		       20 85 f2    .squareEmpty jsr	AddMove
     11  1a39				   .invalid
     12  1a39
      0  1a39					      MOVE_TO_X	_UP+_RIGHT+_RIGHT
      1  1a39		       a6 92		      ldx	currentSquare
      0  1a3b					      MOVE_TO	_UP+_RIGHT+_RIGHT
      1  1a3b					      SUBROUTINE
      2  1a3b
      3  1a3b		       bc 21 fc 	      ldy	ValidSquare+_UP+_RIGHT+_RIGHT,x
      4  1a3e		       30 0e		      bmi	.invalid
      5  1a40		       b9 79 fc 	      lda	Board,y
      6  1a43		       85 9b		      sta	capture
      7  1a45		       f0 04		      beq	.squareEmpty
      8  1a47		       45 91		      eor	currentPiece
      9  1a49		       10 03		      bpl	.invalid
     10  1a4b		       20 85 f2    .squareEmpty jsr	AddMove
     11  1a4e				   .invalid
     12  1a4e
     26  1a4e
     27  1a4e		       4c e8 f1 	      jmp	MoveReturn
     28  1a51
     29  1a51							; EOF
------- FILE @1 PIECE HANDLER #1.asm
------- FILE PIECE_BISHOP.asm LEVEL 3 PASS 4
      0  1a51					      include	"PIECE_BISHOP.asm"
      1  1a51							; Copyright (C)2020 Andrew Davie
      2  1a51
      3  1a51							;---------------------------------------------------------------------------------------------------
      4  1a51							; BISHOP
      5  1a51							;---------------------------------------------------------------------------------------------------
      6  1a51
      0  1a51					      DEF	Handle_BISHOP
      1  1a51				   SLOT_Handle_BISHOP SET	_BANK_SLOT
      2  1a51				   BANK_Handle_BISHOP SET	SLOT_Handle_BISHOP + _CURRENT_BANK
      3  1a51				   Handle_BISHOP
      4  1a51				   TEMPORARY_VAR SET	Overlay
      5  1a51				   TEMPORARY_OFFSET SET	0
      6  1a51				   VAR_BOUNDARY_Handle_BISHOP SET	TEMPORARY_OFFSET
      7  1a51				   FUNCTION_NAME SET	Handle_BISHOP
      8  1a51					      SUBROUTINE
      9  1a51
      0  1a51					      REF	GenerateAllMoves	;✅
      1  1a51					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1a51				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1a51					      ENDIF
      0  1a51					      VEND	Handle_BISHOP
      1  1a51
      2  1a51
      3  1a51		       00 b8	   VAREND_Handle_BISHOP =	TEMPORARY_VAR
      4  1a51
     12  1a51
     13  1a51							; x = currentSquare (square the piece is on)
     14  1a51							; currentPiece (with flags/colour attached)
     15  1a51
      0  1a51					      MOVE_TOWARDS	_DOWN+_LEFT
      1  1a51					      SUBROUTINE
      2  1a51
      3  1a51
      4  1a51
      5  1a51		       a9 00		      lda	#0
      6  1a53		       85 9b		      sta	capture
      7  1a55
      8  1a55		       a6 92		      ldx	currentSquare
      9  1a57		       d0 03		      bne	.project
     10  1a59
     11  1a59		       20 85 f2    .empty     jsr	AddMove
     12  1a5c		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  1a5f		       30 0e		      bmi	.invalid
     14  1a61		       b9 79 fc 	      lda	Board,y
     15  1a64		       f0 f3		      beq	.empty
     16  1a66		       85 9b		      sta	capture
     17  1a68		       45 91		      eor	currentPiece
     18  1a6a		       10 03		      bpl	.invalid
     19  1a6c		       20 85 f2 	      jsr	AddMove
     20  1a6f
     21  1a6f				   .invalid
     22  1a6f
      0  1a6f					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  1a6f					      SUBROUTINE
      2  1a6f
      3  1a6f
      4  1a6f
      5  1a6f		       a9 00		      lda	#0
      6  1a71		       85 9b		      sta	capture
      7  1a73
      8  1a73		       a6 92		      ldx	currentSquare
      9  1a75		       d0 03		      bne	.project
     10  1a77
     11  1a77		       20 85 f2    .empty     jsr	AddMove
     12  1a7a		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  1a7d		       30 0e		      bmi	.invalid
     14  1a7f		       b9 79 fc 	      lda	Board,y
     15  1a82		       f0 f3		      beq	.empty
     16  1a84		       85 9b		      sta	capture
     17  1a86		       45 91		      eor	currentPiece
     18  1a88		       10 03		      bpl	.invalid
     19  1a8a		       20 85 f2 	      jsr	AddMove
     20  1a8d
     21  1a8d				   .invalid
     22  1a8d
      0  1a8d					      MOVE_TOWARDS	_UP+_LEFT
      1  1a8d					      SUBROUTINE
      2  1a8d
      3  1a8d
      4  1a8d
      5  1a8d		       a9 00		      lda	#0
      6  1a8f		       85 9b		      sta	capture
      7  1a91
      8  1a91		       a6 92		      ldx	currentSquare
      9  1a93		       d0 03		      bne	.project
     10  1a95
     11  1a95		       20 85 f2    .empty     jsr	AddMove
     12  1a98		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  1a9b		       30 0e		      bmi	.invalid
     14  1a9d		       b9 79 fc 	      lda	Board,y
     15  1aa0		       f0 f3		      beq	.empty
     16  1aa2		       85 9b		      sta	capture
     17  1aa4		       45 91		      eor	currentPiece
     18  1aa6		       10 03		      bpl	.invalid
     19  1aa8		       20 85 f2 	      jsr	AddMove
     20  1aab
     21  1aab				   .invalid
     22  1aab
      0  1aab					      MOVE_TOWARDS	_UP+_RIGHT
      1  1aab					      SUBROUTINE
      2  1aab
      3  1aab
      4  1aab
      5  1aab		       a9 00		      lda	#0
      6  1aad		       85 9b		      sta	capture
      7  1aaf
      8  1aaf		       a6 92		      ldx	currentSquare
      9  1ab1		       d0 03		      bne	.project
     10  1ab3
     11  1ab3		       20 85 f2    .empty     jsr	AddMove
     12  1ab6		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  1ab9		       30 0e		      bmi	.invalid
     14  1abb		       b9 79 fc 	      lda	Board,y
     15  1abe		       f0 f3		      beq	.empty
     16  1ac0		       85 9b		      sta	capture
     17  1ac2		       45 91		      eor	currentPiece
     18  1ac4		       10 03		      bpl	.invalid
     19  1ac6		       20 85 f2 	      jsr	AddMove
     20  1ac9
     21  1ac9				   .invalid
     22  1ac9
     20  1ac9
     21  1ac9		       4c e8 f1 	      jmp	MoveReturn
     22  1acc
     23  1acc							;---------------------------------------------------------------------------------------------------
     24  1acc							; EOF
------- FILE @1 PIECE HANDLER #1.asm
     17  1acc
     18  1acc							;---------------------------------------------------------------------------------------------------
     19  1acc
      0  1acc					      END_BANK
      1  1acc				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  1acc				  -	      CHECK_RAM_BANK_SIZE
      3  1acc					      ELSE
      0  1acc					      CHECK_BANK_SIZE
      1  1acc		       02 cc	   .TEMP      =	* - _BANK_START
 ROM bank # 7 PIECE_HANDLER_1 size = $2cc free = 307
      2  1acc					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  1acc				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1acc				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  1acc				  -	      ERR
      6  1acc					      ENDIF
      5  1acc					      ENDIF
     21  1acc
     22  1acc							;---------------------------------------------------------------------------------------------------
     23  1acc							; EOF
------- FILE ./chess.asm
------- FILE @1 PIECE HANDLER #2.asm LEVEL 2 PASS 4
      0  1acc					      include	"@1 PIECE HANDLER #2.asm"
      1  1acc							;---------------------------------------------------------------------------------------------------
      2  1acc							; @1 PIECE HANDLER #2.asm
      3  1acc
      4  1acc							; Atari 2600 Chess
      5  1acc							; Copyright (c) 2019-2020 Andrew Davie
      6  1acc							; andrew@taswegian.com
      7  1acc
      8  1acc
      9  1acc							;---------------------------------------------------------------------------------------------------
     10  1acc
      0  1acc					      SLOT	1
      1  1acc
      2  1acc				  -	      IF	(1 < 0) || (1 > 3)
      3  1acc				  -	      ECHO	"Illegal bank address/segment location", 1
      4  1acc				  -	      ERR
      5  1acc					      ENDIF
      6  1acc
      7  1acc				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  1acc				   _BANK_SLOT SET	1 * 64
      9  1acc
      0  1acc					      ROMBANK	PIECE_HANDLER_2
      1  1e5c ????				      SEG	ROM_PIECE_HANDLER_2
      2  1c00					      ORG	_ORIGIN
      3  1c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  1c00				   _BANK_START SET	*
      5  1c00				   PIECE_HANDLER_2_START SET	*
      6  1c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  1c00				   ROMBANK_PIECE_HANDLER_2 SET	_BANK_SLOT + _CURRENT_BANK
      8  1c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  1c00				   _LAST_BANK SETSTR	PIECE_HANDLER_2
     10  1c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  1c00
------- FILE PIECE_ROOK.asm LEVEL 3 PASS 4
      0  1c00					      include	"PIECE_ROOK.asm"
      1  1c00							; Copyright (C)2020 Andrew Davie
      2  1c00							; Rook move handler
      3  1c00
      4  1c00							;---------------------------------------------------------------------------------------------------
      5  1c00							; ROOK
      6  1c00							;---------------------------------------------------------------------------------------------------
      7  1c00
      0  1c00					      DEF	Handle_ROOK
      1  1c00				   SLOT_Handle_ROOK SET	_BANK_SLOT
      2  1c00				   BANK_Handle_ROOK SET	SLOT_Handle_ROOK + _CURRENT_BANK
      3  1c00				   Handle_ROOK
      4  1c00				   TEMPORARY_VAR SET	Overlay
      5  1c00				   TEMPORARY_OFFSET SET	0
      6  1c00				   VAR_BOUNDARY_Handle_ROOK SET	TEMPORARY_OFFSET
      7  1c00				   FUNCTION_NAME SET	Handle_ROOK
      9  1c00					      SUBROUTINE
     10  1c00
      0  1c00					      REF	GenerateAllMoves	;✅
      1  1c00					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1c00				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1c00					      ENDIF
      0  1c00					      VEND	Handle_ROOK
      1  1c00
      2  1c00
      3  1c00		       00 b8	   VAREND_Handle_ROOK =	TEMPORARY_VAR
      4  1c00
     13  1c00
     14  1c00							; Pass...
     15  1c00							; x = currentSquare (square the piece is on)
     16  1c00							; currentPiece (with flags/colour attached)
     17  1c00
     18  1c00
      0  1c00					      MOVE_TOWARDS	_DOWN
      1  1c00					      SUBROUTINE
      2  1c00
      3  1c00
      4  1c00
      5  1c00		       a9 00		      lda	#0
      6  1c02		       85 9b		      sta	capture
      7  1c04
      8  1c04		       a6 92		      ldx	currentSquare
      9  1c06		       d0 03		      bne	.project
     10  1c08
     11  1c08		       20 85 f2    .empty     jsr	AddMove
     12  1c0b		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  1c0e		       30 0e		      bmi	.invalid
     14  1c10		       b9 79 fc 	      lda	Board,y
     15  1c13		       f0 f3		      beq	.empty
     16  1c15		       85 9b		      sta	capture
     17  1c17		       45 91		      eor	currentPiece
     18  1c19		       10 03		      bpl	.invalid
     19  1c1b		       20 85 f2 	      jsr	AddMove
     20  1c1e
     21  1c1e				   .invalid
     22  1c1e
      0  1c1e					      MOVE_TOWARDS	_RIGHT
      1  1c1e					      SUBROUTINE
      2  1c1e
      3  1c1e
      4  1c1e
      5  1c1e		       a9 00		      lda	#0
      6  1c20		       85 9b		      sta	capture
      7  1c22
      8  1c22		       a6 92		      ldx	currentSquare
      9  1c24		       d0 03		      bne	.project
     10  1c26
     11  1c26		       20 85 f2    .empty     jsr	AddMove
     12  1c29		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  1c2c		       30 0e		      bmi	.invalid
     14  1c2e		       b9 79 fc 	      lda	Board,y
     15  1c31		       f0 f3		      beq	.empty
     16  1c33		       85 9b		      sta	capture
     17  1c35		       45 91		      eor	currentPiece
     18  1c37		       10 03		      bpl	.invalid
     19  1c39		       20 85 f2 	      jsr	AddMove
     20  1c3c
     21  1c3c				   .invalid
     22  1c3c
      0  1c3c					      MOVE_TOWARDS	_UP
      1  1c3c					      SUBROUTINE
      2  1c3c
      3  1c3c
      4  1c3c
      5  1c3c		       a9 00		      lda	#0
      6  1c3e		       85 9b		      sta	capture
      7  1c40
      8  1c40		       a6 92		      ldx	currentSquare
      9  1c42		       d0 03		      bne	.project
     10  1c44
     11  1c44		       20 85 f2    .empty     jsr	AddMove
     12  1c47		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  1c4a		       30 0e		      bmi	.invalid
     14  1c4c		       b9 79 fc 	      lda	Board,y
     15  1c4f		       f0 f3		      beq	.empty
     16  1c51		       85 9b		      sta	capture
     17  1c53		       45 91		      eor	currentPiece
     18  1c55		       10 03		      bpl	.invalid
     19  1c57		       20 85 f2 	      jsr	AddMove
     20  1c5a
     21  1c5a				   .invalid
     22  1c5a
      0  1c5a					      MOVE_TOWARDS	_LEFT
      1  1c5a					      SUBROUTINE
      2  1c5a
      3  1c5a
      4  1c5a
      5  1c5a		       a9 00		      lda	#0
      6  1c5c		       85 9b		      sta	capture
      7  1c5e
      8  1c5e		       a6 92		      ldx	currentSquare
      9  1c60		       d0 03		      bne	.project
     10  1c62
     11  1c62		       20 85 f2    .empty     jsr	AddMove
     12  1c65		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  1c68		       30 0e		      bmi	.invalid
     14  1c6a		       b9 79 fc 	      lda	Board,y
     15  1c6d		       f0 f3		      beq	.empty
     16  1c6f		       85 9b		      sta	capture
     17  1c71		       45 91		      eor	currentPiece
     18  1c73		       10 03		      bpl	.invalid
     19  1c75		       20 85 f2 	      jsr	AddMove
     20  1c78
     21  1c78				   .invalid
     22  1c78
     23  1c78
     24  1c78		       4c e8 f1 	      jmp	MoveReturn
     25  1c7b
     26  1c7b							;---------------------------------------------------------------------------------------------------
     27  1c7b							; EOF
------- FILE @1 PIECE HANDLER #2.asm
------- FILE PIECE_QUEEN.asm LEVEL 3 PASS 4
      0  1c7b					      include	"PIECE_QUEEN.asm"
      1  1c7b							; Copyright (C)2020 Andrew Davie
      2  1c7b
      3  1c7b							;---------------------------------------------------------------------------------------------------
      4  1c7b							; QUEEN
      5  1c7b							;---------------------------------------------------------------------------------------------------
      6  1c7b
      0  1c7b					      DEF	Handle_QUEEN
      1  1c7b				   SLOT_Handle_QUEEN SET	_BANK_SLOT
      2  1c7b				   BANK_Handle_QUEEN SET	SLOT_Handle_QUEEN + _CURRENT_BANK
      3  1c7b				   Handle_QUEEN
      4  1c7b				   TEMPORARY_VAR SET	Overlay
      5  1c7b				   TEMPORARY_OFFSET SET	0
      6  1c7b				   VAR_BOUNDARY_Handle_QUEEN SET	TEMPORARY_OFFSET
      7  1c7b				   FUNCTION_NAME SET	Handle_QUEEN
      8  1c7b					      SUBROUTINE
      9  1c7b
      0  1c7b					      REF	GenerateAllMoves	;✅
      1  1c7b					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1c7b				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1c7b					      ENDIF
      0  1c7b					      VEND	Handle_QUEEN
      1  1c7b
      2  1c7b
      3  1c7b		       00 b8	   VAREND_Handle_QUEEN =	TEMPORARY_VAR
      4  1c7b
     12  1c7b
     13  1c7b							; Pass...
     14  1c7b							; x = currentSquare (square the piece is on)
     15  1c7b							; currentPiece (with flags/colour attached)
     16  1c7b
      0  1c7b					      MOVE_TOWARDS	_DOWN+_LEFT
      1  1c7b					      SUBROUTINE
      2  1c7b
      3  1c7b
      4  1c7b
      5  1c7b		       a9 00		      lda	#0
      6  1c7d		       85 9b		      sta	capture
      7  1c7f
      8  1c7f		       a6 92		      ldx	currentSquare
      9  1c81		       d0 03		      bne	.project
     10  1c83
     11  1c83		       20 85 f2    .empty     jsr	AddMove
     12  1c86		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  1c89		       30 0e		      bmi	.invalid
     14  1c8b		       b9 79 fc 	      lda	Board,y
     15  1c8e		       f0 f3		      beq	.empty
     16  1c90		       85 9b		      sta	capture
     17  1c92		       45 91		      eor	currentPiece
     18  1c94		       10 03		      bpl	.invalid
     19  1c96		       20 85 f2 	      jsr	AddMove
     20  1c99
     21  1c99				   .invalid
     22  1c99
      0  1c99					      MOVE_TOWARDS	_DOWN
      1  1c99					      SUBROUTINE
      2  1c99
      3  1c99
      4  1c99
      5  1c99		       a9 00		      lda	#0
      6  1c9b		       85 9b		      sta	capture
      7  1c9d
      8  1c9d		       a6 92		      ldx	currentSquare
      9  1c9f		       d0 03		      bne	.project
     10  1ca1
     11  1ca1		       20 85 f2    .empty     jsr	AddMove
     12  1ca4		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  1ca7		       30 0e		      bmi	.invalid
     14  1ca9		       b9 79 fc 	      lda	Board,y
     15  1cac		       f0 f3		      beq	.empty
     16  1cae		       85 9b		      sta	capture
     17  1cb0		       45 91		      eor	currentPiece
     18  1cb2		       10 03		      bpl	.invalid
     19  1cb4		       20 85 f2 	      jsr	AddMove
     20  1cb7
     21  1cb7				   .invalid
     22  1cb7
      0  1cb7					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  1cb7					      SUBROUTINE
      2  1cb7
      3  1cb7
      4  1cb7
      5  1cb7		       a9 00		      lda	#0
      6  1cb9		       85 9b		      sta	capture
      7  1cbb
      8  1cbb		       a6 92		      ldx	currentSquare
      9  1cbd		       d0 03		      bne	.project
     10  1cbf
     11  1cbf		       20 85 f2    .empty     jsr	AddMove
     12  1cc2		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  1cc5		       30 0e		      bmi	.invalid
     14  1cc7		       b9 79 fc 	      lda	Board,y
     15  1cca		       f0 f3		      beq	.empty
     16  1ccc		       85 9b		      sta	capture
     17  1cce		       45 91		      eor	currentPiece
     18  1cd0		       10 03		      bpl	.invalid
     19  1cd2		       20 85 f2 	      jsr	AddMove
     20  1cd5
     21  1cd5				   .invalid
     22  1cd5
      0  1cd5					      MOVE_TOWARDS	_RIGHT
      1  1cd5					      SUBROUTINE
      2  1cd5
      3  1cd5
      4  1cd5
      5  1cd5		       a9 00		      lda	#0
      6  1cd7		       85 9b		      sta	capture
      7  1cd9
      8  1cd9		       a6 92		      ldx	currentSquare
      9  1cdb		       d0 03		      bne	.project
     10  1cdd
     11  1cdd		       20 85 f2    .empty     jsr	AddMove
     12  1ce0		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  1ce3		       30 0e		      bmi	.invalid
     14  1ce5		       b9 79 fc 	      lda	Board,y
     15  1ce8		       f0 f3		      beq	.empty
     16  1cea		       85 9b		      sta	capture
     17  1cec		       45 91		      eor	currentPiece
     18  1cee		       10 03		      bpl	.invalid
     19  1cf0		       20 85 f2 	      jsr	AddMove
     20  1cf3
     21  1cf3				   .invalid
     22  1cf3
      0  1cf3					      MOVE_TOWARDS	_UP+_RIGHT
      1  1cf3					      SUBROUTINE
      2  1cf3
      3  1cf3
      4  1cf3
      5  1cf3		       a9 00		      lda	#0
      6  1cf5		       85 9b		      sta	capture
      7  1cf7
      8  1cf7		       a6 92		      ldx	currentSquare
      9  1cf9		       d0 03		      bne	.project
     10  1cfb
     11  1cfb		       20 85 f2    .empty     jsr	AddMove
     12  1cfe		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  1d01		       30 0e		      bmi	.invalid
     14  1d03		       b9 79 fc 	      lda	Board,y
     15  1d06		       f0 f3		      beq	.empty
     16  1d08		       85 9b		      sta	capture
     17  1d0a		       45 91		      eor	currentPiece
     18  1d0c		       10 03		      bpl	.invalid
     19  1d0e		       20 85 f2 	      jsr	AddMove
     20  1d11
     21  1d11				   .invalid
     22  1d11
      0  1d11					      MOVE_TOWARDS	_UP
      1  1d11					      SUBROUTINE
      2  1d11
      3  1d11
      4  1d11
      5  1d11		       a9 00		      lda	#0
      6  1d13		       85 9b		      sta	capture
      7  1d15
      8  1d15		       a6 92		      ldx	currentSquare
      9  1d17		       d0 03		      bne	.project
     10  1d19
     11  1d19		       20 85 f2    .empty     jsr	AddMove
     12  1d1c		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  1d1f		       30 0e		      bmi	.invalid
     14  1d21		       b9 79 fc 	      lda	Board,y
     15  1d24		       f0 f3		      beq	.empty
     16  1d26		       85 9b		      sta	capture
     17  1d28		       45 91		      eor	currentPiece
     18  1d2a		       10 03		      bpl	.invalid
     19  1d2c		       20 85 f2 	      jsr	AddMove
     20  1d2f
     21  1d2f				   .invalid
     22  1d2f
      0  1d2f					      MOVE_TOWARDS	_UP+_LEFT
      1  1d2f					      SUBROUTINE
      2  1d2f
      3  1d2f
      4  1d2f
      5  1d2f		       a9 00		      lda	#0
      6  1d31		       85 9b		      sta	capture
      7  1d33
      8  1d33		       a6 92		      ldx	currentSquare
      9  1d35		       d0 03		      bne	.project
     10  1d37
     11  1d37		       20 85 f2    .empty     jsr	AddMove
     12  1d3a		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  1d3d		       30 0e		      bmi	.invalid
     14  1d3f		       b9 79 fc 	      lda	Board,y
     15  1d42		       f0 f3		      beq	.empty
     16  1d44		       85 9b		      sta	capture
     17  1d46		       45 91		      eor	currentPiece
     18  1d48		       10 03		      bpl	.invalid
     19  1d4a		       20 85 f2 	      jsr	AddMove
     20  1d4d
     21  1d4d				   .invalid
     22  1d4d
      0  1d4d					      MOVE_TOWARDS	_LEFT
      1  1d4d					      SUBROUTINE
      2  1d4d
      3  1d4d
      4  1d4d
      5  1d4d		       a9 00		      lda	#0
      6  1d4f		       85 9b		      sta	capture
      7  1d51
      8  1d51		       a6 92		      ldx	currentSquare
      9  1d53		       d0 03		      bne	.project
     10  1d55
     11  1d55		       20 85 f2    .empty     jsr	AddMove
     12  1d58		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  1d5b		       30 0e		      bmi	.invalid
     14  1d5d		       b9 79 fc 	      lda	Board,y
     15  1d60		       f0 f3		      beq	.empty
     16  1d62		       85 9b		      sta	capture
     17  1d64		       45 91		      eor	currentPiece
     18  1d66		       10 03		      bpl	.invalid
     19  1d68		       20 85 f2 	      jsr	AddMove
     20  1d6b
     21  1d6b				   .invalid
     22  1d6b
     25  1d6b
     26  1d6b		       4c e8 f1 	      jmp	MoveReturn
     27  1d6e
     28  1d6e							; EOF
------- FILE @1 PIECE HANDLER #2.asm
------- FILE PIECE_KING.asm LEVEL 3 PASS 4
      0  1d6e					      include	"PIECE_KING.asm"
      1  1d6e							; Copyright (C)2020 Andrew Davie
      2  1d6e
      3  1d6e							;---------------------------------------------------------------------------------------------------
      4  1d6e							; KING
      5  1d6e							; This is the move handler for a KING
      6  1d6e							; "Check" is detected in the next ply of the search.
      7  1d6e
      8  1d6e
      9  1d6e							;---------------------------------------------------------------------------------------------------
     10  1d6e
     11  1d6e							; MACRO - Castling
     12  1d6e
     13  1d6e		       00 03	   KINGSIDE   =	3
     14  1d6e		       ff ff ff fc QUEENSIDE  =	-4
     15  1d6e
     16  1d6e					      MAC	castle
     17  1d6e							; {1} = "KINGSIDE" or "QUEENSIDE"
     18  1d6e
     19  1d6e					      ldx	currentSquare
     20  1d6e					      lda	Board+{1},x	; kingside/queenside R position
     21  1d6e					      and	#PIECE_MASK|FLAG_MOVED
     22  1d6e					      cmp	#ROOK
     23  1d6e					      bne	.noCastle	; not a R that hasn't moved
     24  1d6e
     25  1d6e							; It's a R and it *HAS* to be correct colour because it hasn't moved!
     26  1d6e							; AND the K hasn't moved (earlier check), so check for vacant squares between K and R
     27  1d6e
     28  1d6e					      IF	{1} = QUEENSIDE
     29  1d6e					      lda	Board-3,x	; N pos
     30  1d6e					      ora	Board-2,x	; B pos
     31  1d6e					      ora	Board-1,x	; Q pos
     32  1d6e					      bne	.noCastle	; not vacant?
     33  1d6e
     34  1d6e					      ENDIF
     35  1d6e
     36  1d6e					      IF	{1} = KINGSIDE
     37  1d6e					      lda	Board+2,x	; N pos
     38  1d6e					      ora	Board+1,x	; B pos
     39  1d6e					      bne	.noCastle	; not vacant?
     40  1d6e					      ENDIF
     41  1d6e
     42  1d6e							; appropriate N/B/(Q) squares are vacant so we proceed...
     43  1d6e
     44  1d6e							; FINALLY -- king can castle
     45  1d6e							; note: when we actually DO the move we MUST insert "Phantom" kings onto the board over the
     46  1d6e							; squares the king traverses so that "check" (and thus illegal moves) can be detected on the
     47  1d6e							; next move. Castling will be detected by K moving > 1 square. (TODO: FIX?? not CASTLE flag??)
     48  1d6e
     49  1d6e					      lda	currentPiece
     50  1d6e					      ora	#FLAG_CASTLE	; flag it's a castling move
     51  1d6e					      sta	currentPiece
     52  1d6e
     53  1d6e					      IF	{1} = KINGSIDE
     54  1d6e					      ldy	ValidSquare+2,x
     55  1d6e					      ENDIF
     56  1d6e
     57  1d6e					      IF	{1} = QUEENSIDE
     58  1d6e					      ldy	ValidSquare-2,x
     59  1d6e					      ENDIF
     60  1d6e
     61  1d6e
     62  1d6e					      jsr	AddMove	; 57
     63  1d6e				   .noCastle
     64  1d6e					      ENDM
     65  1d6e
     66  1d6e
     67  1d6e							;---------------------------------------------------------------------------------------------------
     68  1d6e
      0  1d6e					      DEF	Handle_KING
      1  1d6e				   SLOT_Handle_KING SET	_BANK_SLOT
      2  1d6e				   BANK_Handle_KING SET	SLOT_Handle_KING + _CURRENT_BANK
      3  1d6e				   Handle_KING
      4  1d6e				   TEMPORARY_VAR SET	Overlay
      5  1d6e				   TEMPORARY_OFFSET SET	0
      6  1d6e				   VAR_BOUNDARY_Handle_KING SET	TEMPORARY_OFFSET
      7  1d6e				   FUNCTION_NAME SET	Handle_KING
     70  1d6e					      SUBROUTINE
     71  1d6e
      0  1d6e					      REF	GenerateAllMoves	;✅
      1  1d6e					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1d6e				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1d6e					      ENDIF
      0  1d6e					      VEND	Handle_KING
      1  1d6e
      2  1d6e
      3  1d6e		       00 b8	   VAREND_Handle_KING =	TEMPORARY_VAR
      4  1d6e
     74  1d6e
     75  1d6e							; x = currentSquare (square the KING is on)
     76  1d6e							; currentPiece (KING of course, but with flags/colour attached)
     77  1d6e
      0  1d6e					      MOVE_TO	_DOWN+_LEFT
      1  1d6e					      SUBROUTINE
      2  1d6e
      3  1d6e		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      4  1d71		       30 0e		      bmi	.invalid
      5  1d73		       b9 79 fc 	      lda	Board,y
      6  1d76		       85 9b		      sta	capture
      7  1d78		       f0 04		      beq	.squareEmpty
      8  1d7a		       45 91		      eor	currentPiece
      9  1d7c		       10 03		      bpl	.invalid
     10  1d7e		       20 85 f2    .squareEmpty jsr	AddMove
     11  1d81				   .invalid
     12  1d81
      0  1d81					      MOVE_TO_X	_DOWN
      1  1d81		       a6 92		      ldx	currentSquare
      0  1d83					      MOVE_TO	_DOWN
      1  1d83					      SUBROUTINE
      2  1d83
      3  1d83		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x
      4  1d86		       30 0e		      bmi	.invalid
      5  1d88		       b9 79 fc 	      lda	Board,y
      6  1d8b		       85 9b		      sta	capture
      7  1d8d		       f0 04		      beq	.squareEmpty
      8  1d8f		       45 91		      eor	currentPiece
      9  1d91		       10 03		      bpl	.invalid
     10  1d93		       20 85 f2    .squareEmpty jsr	AddMove
     11  1d96				   .invalid
     12  1d96
      0  1d96					      MOVE_TO_X	_DOWN+_RIGHT
      1  1d96		       a6 92		      ldx	currentSquare
      0  1d98					      MOVE_TO	_DOWN+_RIGHT
      1  1d98					      SUBROUTINE
      2  1d98
      3  1d98		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      4  1d9b		       30 0e		      bmi	.invalid
      5  1d9d		       b9 79 fc 	      lda	Board,y
      6  1da0		       85 9b		      sta	capture
      7  1da2		       f0 04		      beq	.squareEmpty
      8  1da4		       45 91		      eor	currentPiece
      9  1da6		       10 03		      bpl	.invalid
     10  1da8		       20 85 f2    .squareEmpty jsr	AddMove
     11  1dab				   .invalid
     12  1dab
      0  1dab					      MOVE_TO_X	_RIGHT
      1  1dab		       a6 92		      ldx	currentSquare
      0  1dad					      MOVE_TO	_RIGHT
      1  1dad					      SUBROUTINE
      2  1dad
      3  1dad		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      4  1db0		       30 0e		      bmi	.invalid
      5  1db2		       b9 79 fc 	      lda	Board,y
      6  1db5		       85 9b		      sta	capture
      7  1db7		       f0 04		      beq	.squareEmpty
      8  1db9		       45 91		      eor	currentPiece
      9  1dbb		       10 03		      bpl	.invalid
     10  1dbd		       20 85 f2    .squareEmpty jsr	AddMove
     11  1dc0				   .invalid
     12  1dc0
      0  1dc0					      MOVE_TO_X	_UP+_RIGHT
      1  1dc0		       a6 92		      ldx	currentSquare
      0  1dc2					      MOVE_TO	_UP+_RIGHT
      1  1dc2					      SUBROUTINE
      2  1dc2
      3  1dc2		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      4  1dc5		       30 0e		      bmi	.invalid
      5  1dc7		       b9 79 fc 	      lda	Board,y
      6  1dca		       85 9b		      sta	capture
      7  1dcc		       f0 04		      beq	.squareEmpty
      8  1dce		       45 91		      eor	currentPiece
      9  1dd0		       10 03		      bpl	.invalid
     10  1dd2		       20 85 f2    .squareEmpty jsr	AddMove
     11  1dd5				   .invalid
     12  1dd5
      0  1dd5					      MOVE_TO_X	_UP
      1  1dd5		       a6 92		      ldx	currentSquare
      0  1dd7					      MOVE_TO	_UP
      1  1dd7					      SUBROUTINE
      2  1dd7
      3  1dd7		       bc 1f fc 	      ldy	ValidSquare+_UP,x
      4  1dda		       30 0e		      bmi	.invalid
      5  1ddc		       b9 79 fc 	      lda	Board,y
      6  1ddf		       85 9b		      sta	capture
      7  1de1		       f0 04		      beq	.squareEmpty
      8  1de3		       45 91		      eor	currentPiece
      9  1de5		       10 03		      bpl	.invalid
     10  1de7		       20 85 f2    .squareEmpty jsr	AddMove
     11  1dea				   .invalid
     12  1dea
      0  1dea					      MOVE_TO_X	_UP+_LEFT
      1  1dea		       a6 92		      ldx	currentSquare
      0  1dec					      MOVE_TO	_UP+_LEFT
      1  1dec					      SUBROUTINE
      2  1dec
      3  1dec		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      4  1def		       30 0e		      bmi	.invalid
      5  1df1		       b9 79 fc 	      lda	Board,y
      6  1df4		       85 9b		      sta	capture
      7  1df6		       f0 04		      beq	.squareEmpty
      8  1df8		       45 91		      eor	currentPiece
      9  1dfa		       10 03		      bpl	.invalid
     10  1dfc		       20 85 f2    .squareEmpty jsr	AddMove
     11  1dff				   .invalid
     12  1dff
      0  1dff					      MOVE_TO_X	_LEFT
      1  1dff		       a6 92		      ldx	currentSquare
      0  1e01					      MOVE_TO	_LEFT
      1  1e01					      SUBROUTINE
      2  1e01
      3  1e01		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      4  1e04		       30 0e		      bmi	.invalid
      5  1e06		       b9 79 fc 	      lda	Board,y
      6  1e09		       85 9b		      sta	capture
      7  1e0b		       f0 04		      beq	.squareEmpty
      8  1e0d		       45 91		      eor	currentPiece
      9  1e0f		       10 03		      bpl	.invalid
     10  1e11		       20 85 f2    .squareEmpty jsr	AddMove
     11  1e14				   .invalid
     12  1e14
     86  1e14
     87  1e14					      IF	CASTLING_ENABLED
     88  1e14
     89  1e14		       24 91		      bit	currentPiece
     90  1e16		       70 41		      bvs	.exit	; king has moved, so no castling
     91  1e18
      0  1e18					      CASTLE	KINGSIDE
      1  1e18
      2  1e18
      3  1e18		       a6 92		      ldx	currentSquare
      4  1e1a		       bd 7c fc 	      lda	Board+KINGSIDE,x
      5  1e1d		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  1e1f		       c9 05		      cmp	#ROOK
      7  1e21		       d0 14		      bne	.noCastle
      8  1e23
      9  1e23
     10  1e23
     11  1e23
     12  1e23				  -	      IF	KINGSIDE = QUEENSIDE
     13  1e23				  -	      lda	Board-3,x
     14  1e23				  -	      ora	Board-2,x
     15  1e23				  -	      ora	Board-1,x
     16  1e23				  -	      bne	.noCastle
     17  1e23				  -
     18  1e23					      ENDIF
     19  1e23
     20  1e23					      IF	KINGSIDE = KINGSIDE
     21  1e23		       bd 7b fc 	      lda	Board+2,x
     22  1e26		       1d 7a fc 	      ora	Board+1,x
     23  1e29		       d0 0c		      bne	.noCastle
     24  1e2b					      ENDIF
     25  1e2b
     26  1e2b
     27  1e2b
     28  1e2b
     29  1e2b
     30  1e2b
     31  1e2b
     32  1e2b
     33  1e2b		       a5 91		      lda	currentPiece
     34  1e2d		       09 10		      ora	#FLAG_CASTLE
     35  1e2f		       85 91		      sta	currentPiece
     36  1e31
     37  1e31					      IF	KINGSIDE = KINGSIDE
     38  1e31		       bc 17 fc 	      ldy	ValidSquare+2,x
     39  1e34					      ENDIF
     40  1e34
     41  1e34				  -	      IF	KINGSIDE = QUEENSIDE
     42  1e34				  -	      ldy	ValidSquare-2,x
     43  1e34					      ENDIF
     44  1e34
     45  1e34
     46  1e34		       20 85 f2 	      jsr	AddMove
     47  1e37				   .noCastle
      0  1e37					      CASTLE	QUEENSIDE
      1  1e37
      2  1e37
      3  1e37		       a6 92		      ldx	currentSquare
      4  1e39		       bd 75 fc 	      lda	Board+QUEENSIDE,x
      5  1e3c		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  1e3e		       c9 05		      cmp	#ROOK
      7  1e40		       d0 17		      bne	.noCastle
      8  1e42
      9  1e42
     10  1e42
     11  1e42
     12  1e42					      IF	QUEENSIDE = QUEENSIDE
     13  1e42		       bd 76 fc 	      lda	Board-3,x
     14  1e45		       1d 77 fc 	      ora	Board-2,x
     15  1e48		       1d 78 fc 	      ora	Board-1,x
     16  1e4b		       d0 0c		      bne	.noCastle
     17  1e4d
     18  1e4d					      ENDIF
     19  1e4d
     20  1e4d				  -	      IF	QUEENSIDE = KINGSIDE
     21  1e4d				  -	      lda	Board+2,x
     22  1e4d				  -	      ora	Board+1,x
     23  1e4d				  -	      bne	.noCastle
     24  1e4d					      ENDIF
     25  1e4d
     26  1e4d
     27  1e4d
     28  1e4d
     29  1e4d
     30  1e4d
     31  1e4d
     32  1e4d
     33  1e4d		       a5 91		      lda	currentPiece
     34  1e4f		       09 10		      ora	#FLAG_CASTLE
     35  1e51		       85 91		      sta	currentPiece
     36  1e53
     37  1e53				  -	      IF	QUEENSIDE = KINGSIDE
     38  1e53				  -	      ldy	ValidSquare+2,x
     39  1e53					      ENDIF
     40  1e53
     41  1e53					      IF	QUEENSIDE = QUEENSIDE
     42  1e53		       bc 13 fc 	      ldy	ValidSquare-2,x
     43  1e56					      ENDIF
     44  1e56
     45  1e56
     46  1e56		       20 85 f2 	      jsr	AddMove
     47  1e59				   .noCastle
     94  1e59
     95  1e59					      ENDIF
     96  1e59
     97  1e59		       4c e8 f1    .exit      jmp	MoveReturn
     98  1e5c
     99  1e5c							;---------------------------------------------------------------------------------------------------
    100  1e5c							; EOF
------- FILE @1 PIECE HANDLER #2.asm
     17  1e5c
     18  1e5c							;---------------------------------------------------------------------------------------------------
     19  1e5c
      0  1e5c					      END_BANK
      1  1e5c				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  1e5c				  -	      CHECK_RAM_BANK_SIZE
      3  1e5c					      ELSE
      0  1e5c					      CHECK_BANK_SIZE
      1  1e5c		       02 5c	   .TEMP      =	* - _BANK_START
 ROM bank # 8 PIECE_HANDLER_2 size = $25c free = 419
      2  1e5c					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  1e5c				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1e5c				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  1e5c				  -	      ERR
      6  1e5c					      ENDIF
      5  1e5c					      ENDIF
     21  1e5c
     22  1e5c							;---------------------------------------------------------------------------------------------------
     23  1e5c							; EOF
------- FILE ./chess.asm
    190  1e5c
------- FILE @2 SCREEN RAM.asm LEVEL 2 PASS 4
      0  1e5c					      include	"@2 SCREEN RAM.asm"
      1  1e5c							;---------------------------------------------------------------------------------------------------
      2  1e5c							; @2 SCREEN RAM.asm
      3  1e5c
      4  1e5c							; Atari 2600 Chess
      5  1e5c							; Copyright (c) 2019-2020 Andrew Davie
      6  1e5c							; andrew@taswegian.com
      7  1e5c
      8  1e5c
      9  1e5c							;---------------------------------------------------------------------------------------------------
     10  1e5c
      0  1e5c					      SLOT	2
      1  1e5c
      2  1e5c				  -	      IF	(2 < 0) || (2 > 3)
      3  1e5c				  -	      ECHO	"Illegal bank address/segment location", 2
      4  1e5c				  -	      ERR
      5  1e5c					      ENDIF
      6  1e5c
      7  1e5c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  1e5c				   _BANK_SLOT SET	2 * 64
      9  1e5c
     12  1e5c					      REPEAT	CHESSBOARD_ROWS
      0  1e5c					      RAMBANK	CHESSBOARDROW
      1  1e5c
      2 U0e00 ????				      SEG.U	RAM_CHESSBOARDROW
      3 U0000					      ORG	ORIGIN_RAM
      4 U0000					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0000				   _BANK_START SET	*
      6 U0000				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0000				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0000				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0000				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0000				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0000					      END_BANK
      1 U0000					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0000					      CHECK_RAM_BANK_SIZE
      1 U0000		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 1 CHESSBOARDROW size =  $0 free = $1ff
      2 U0000					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0000				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0000				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0000				  -	      ERR
      6 U0000					      ENDIF
      3 U0000				  -	      ELSE
      4 U0000				  -	      CHECK_BANK_SIZE
      5 U0000					      ENDIF
     12 U0000					      REPEND
      0 U0000					      RAMBANK	CHESSBOARDROW
      1 U0000
      2 U0000					      SEG.U	RAM_CHESSBOARDROW
      3 U0200					      ORG	ORIGIN_RAM
      4 U0200					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0200				   _BANK_START SET	*
      6 U0200				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0200				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0200				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0200				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0200				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0200					      END_BANK
      1 U0200					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0200					      CHECK_RAM_BANK_SIZE
      1 U0200		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 2 CHESSBOARDROW size =  $0 free = $1ff
      2 U0200					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0200				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0200				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0200				  -	      ERR
      6 U0200					      ENDIF
      3 U0200				  -	      ELSE
      4 U0200				  -	      CHECK_BANK_SIZE
      5 U0200					      ENDIF
     12 U0200					      REPEND
      0 U0200					      RAMBANK	CHESSBOARDROW
      1 U0200
      2 U0200					      SEG.U	RAM_CHESSBOARDROW
      3 U0400					      ORG	ORIGIN_RAM
      4 U0400					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0400				   _BANK_START SET	*
      6 U0400				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0400				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0400				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0400				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0400				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0400					      END_BANK
      1 U0400					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0400					      CHECK_RAM_BANK_SIZE
      1 U0400		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 3 CHESSBOARDROW size =  $0 free = $1ff
      2 U0400					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0400				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0400				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0400				  -	      ERR
      6 U0400					      ENDIF
      3 U0400				  -	      ELSE
      4 U0400				  -	      CHECK_BANK_SIZE
      5 U0400					      ENDIF
     12 U0400					      REPEND
      0 U0400					      RAMBANK	CHESSBOARDROW
      1 U0400
      2 U0400					      SEG.U	RAM_CHESSBOARDROW
      3 U0600					      ORG	ORIGIN_RAM
      4 U0600					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0600				   _BANK_START SET	*
      6 U0600				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0600				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0600				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0600				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0600				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0600					      END_BANK
      1 U0600					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0600					      CHECK_RAM_BANK_SIZE
      1 U0600		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 4 CHESSBOARDROW size =  $0 free = $1ff
      2 U0600					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0600				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0600				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0600				  -	      ERR
      6 U0600					      ENDIF
      3 U0600				  -	      ELSE
      4 U0600				  -	      CHECK_BANK_SIZE
      5 U0600					      ENDIF
     12 U0600					      REPEND
      0 U0600					      RAMBANK	CHESSBOARDROW
      1 U0600
      2 U0600					      SEG.U	RAM_CHESSBOARDROW
      3 U0800					      ORG	ORIGIN_RAM
      4 U0800					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0800				   _BANK_START SET	*
      6 U0800				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0800				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0800				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0800				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0800				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0800					      END_BANK
      1 U0800					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0800					      CHECK_RAM_BANK_SIZE
      1 U0800		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 5 CHESSBOARDROW size =  $0 free = $1ff
      2 U0800					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0800				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0800				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0800				  -	      ERR
      6 U0800					      ENDIF
      3 U0800				  -	      ELSE
      4 U0800				  -	      CHECK_BANK_SIZE
      5 U0800					      ENDIF
     12 U0800					      REPEND
      0 U0800					      RAMBANK	CHESSBOARDROW
      1 U0800
      2 U0800					      SEG.U	RAM_CHESSBOARDROW
      3 U0a00					      ORG	ORIGIN_RAM
      4 U0a00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0a00				   _BANK_START SET	*
      6 U0a00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0a00				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0a00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0a00				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0a00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0a00					      END_BANK
      1 U0a00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0a00					      CHECK_RAM_BANK_SIZE
      1 U0a00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 6 CHESSBOARDROW size =  $0 free = $1ff
      2 U0a00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0a00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0a00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0a00				  -	      ERR
      6 U0a00					      ENDIF
      3 U0a00				  -	      ELSE
      4 U0a00				  -	      CHECK_BANK_SIZE
      5 U0a00					      ENDIF
     12 U0a00					      REPEND
      0 U0a00					      RAMBANK	CHESSBOARDROW
      1 U0a00
      2 U0a00					      SEG.U	RAM_CHESSBOARDROW
      3 U0c00					      ORG	ORIGIN_RAM
      4 U0c00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0c00				   _BANK_START SET	*
      6 U0c00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0c00				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0c00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0c00				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0c00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0c00					      END_BANK
      1 U0c00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0c00					      CHECK_RAM_BANK_SIZE
      1 U0c00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 7 CHESSBOARDROW size =  $0 free = $1ff
      2 U0c00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0c00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0c00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0c00				  -	      ERR
      6 U0c00					      ENDIF
      3 U0c00				  -	      ELSE
      4 U0c00				  -	      CHECK_BANK_SIZE
      5 U0c00					      ENDIF
     12 U0c00					      REPEND
      0 U0c00					      RAMBANK	CHESSBOARDROW
      1 U0c00
      2 U0c00					      SEG.U	RAM_CHESSBOARDROW
      3 U0e00					      ORG	ORIGIN_RAM
      4 U0e00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0e00				   _BANK_START SET	*
      6 U0e00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0e00				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0e00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0e00				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0e00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0e00					      END_BANK
      1 U0e00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0e00					      CHECK_RAM_BANK_SIZE
      1 U0e00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 8 CHESSBOARDROW size =  $0 free = $1ff
      2 U0e00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0e00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0e00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0e00				  -	      ERR
      6 U0e00					      ENDIF
      3 U0e00				  -	      ELSE
      4 U0e00				  -	      CHECK_BANK_SIZE
      5 U0e00					      ENDIF
     15 U0e00					      REPEND
     16 U0e00
     17 U0e00
     18 U0e00							;---------------------------------------------------------------------------------------------------
     19 U0e00
     20 U0e00							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
     21 U0e00							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
     22 U0e00							; The variable definitions are also in that ROM bank (even though they're RAM :)
     23 U0e00
     24 U0e00							; Now we have the actual graphics data for each of the rows.  This consists of an
     25 U0e00							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
     26 U0e00							; character shapes are masked/copied. The depth of the character shapes may be
     27 U0e00							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
     28 U0e00							; a multiple of 3, so that the RGB scanlines match at character joins.
     29 U0e00
     30 U0e00							; We have one bank for each chessboard row.  These banks are duplicates of the above,
     31 U0e00							; accessed via the above labels but with the appropriate bank switched in.
     32 U0e00
      0 U0e00					      ROMBANK	BITMAP
      1  21d6 ????				      SEG	ROM_BITMAP
      2  2000					      ORG	_ORIGIN
      3  2000					      RORG	_BANK_ADDRESS_ORIGIN
      4  2000				   _BANK_START SET	*
      5  2000				   BITMAP_START SET	*
      6  2000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  2000				   ROMBANK_BITMAP SET	_BANK_SLOT + _CURRENT_BANK
      8  2000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  2000				   _LAST_BANK SETSTR	BITMAP
     10  2000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     34  2000
     35  2000							; These equates allow revectoring (address offset) if the RAM slot is not the same as the SHADOW slot
     36  2000
     37  2000		       f8 00	   ChessBitmap =	SHADOW_ChessBitmap
     38  2000
     39  2000		       f8 00	   ChessBitmap0 =	SHADOW_ChessBitmap0
     40  2000		       f8 18	   ChessBitmap1 =	SHADOW_ChessBitmap1
     41  2000		       f8 30	   ChessBitmap2 =	SHADOW_ChessBitmap2
     42  2000		       f8 48	   ChessBitmap3 =	SHADOW_ChessBitmap3
     43  2000		       f8 60	   ChessBitmap4 =	SHADOW_ChessBitmap4
     44  2000		       f8 78	   ChessBitmap5 =	SHADOW_ChessBitmap5
     45  2000
     46  2000							; Template bank for a SINGLE ROW of the chessboard display.
     47  2000							; There are 8x of these.
     48  2000							; The bank contains the definition of the bitmap, and also the code to draw the bitmap
     49  2000							; The bank is copied from ROM into RAM at startup.
     50  2000							; The draw switches between consecutive row banks, with the last returning
     51  2000							; we effectively have 1K
     52  2000							;---------------------------------------------------------------------------------------------------
     53  2000
     54  2000		       00 86	   COLOUR_LINE_1 =	$86
     55  2000		       00 48	   COLOUR_LINE_2 =	$48
     56  2000		       00 d8	   COLOUR_LINE_3 =	$D8
     57  2000		       00 00	   BACKGCOL   =	$0
     58  2000
     59  2000		       00 90	   ROW_BITMAP_SIZE =	6 * 24	; PF0/PF1/PF2/(PF0)/(PF1)/(PF2) x 8 ICC pixels
     60  2000
     61  2000
      0  2000					      ALLOCATE	SHADOW_ChessBitmap, ROW_BITMAP_SIZE
      1  2000
      2  2000				   .NAME      SETSTR	SHADOW_ChessBitmap
      0  2000					      OPTIONAL_PAGEBREAK	.NAME, ROW_BITMAP_SIZE
      1  2000
      2  2000				  -	      IF	(>( * + ROW_BITMAP_SIZE -1 )) > ( >* )
      3  2000				  -.EARLY_LOCATION SET	*
      4  2000				  -	      ALIGN	256
      5  2000				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2000					      ENDIF
      0  2000					      DEF	SHADOW_ChessBitmap
      1  2000				   SLOT_SHADOW_ChessBitmap SET	_BANK_SLOT
      2  2000				   BANK_SHADOW_ChessBitmap SET	SLOT_SHADOW_ChessBitmap + _CURRENT_BANK
      3  2000				   SHADOW_ChessBitmap
      4  2000				   TEMPORARY_VAR SET	Overlay
      5  2000				   TEMPORARY_OFFSET SET	0
      6  2000				   VAR_BOUNDARY_SHADOW_ChessBitmap SET	TEMPORARY_OFFSET
      7  2000				   FUNCTION_NAME SET	SHADOW_ChessBitmap
      5  2000
     63  2000		       00 00 00 00*SHADOW_ChessBitmap0 ds	24
     64  2018		       00 00 00 00*SHADOW_ChessBitmap1 ds	24
     65  2030		       00 00 00 00*SHADOW_ChessBitmap2 ds	24
     66  2048		       00 00 00 00*SHADOW_ChessBitmap3 ds	24
     67  2060		       00 00 00 00*SHADOW_ChessBitmap4 ds	24
     68  2078		       00 00 00 00*SHADOW_ChessBitmap5 ds	24
     69  2090
      0  2090					      ALLOCATE	BlankSprite, 8
      1  2090
      2  2090				   .NAME      SETSTR	BlankSprite
      0  2090					      OPTIONAL_PAGEBREAK	.NAME, 8
      1  2090
      2  2090				  -	      IF	(>( * + 8 -1 )) > ( >* )
      3  2090				  -.EARLY_LOCATION SET	*
      4  2090				  -	      ALIGN	256
      5  2090				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2090					      ENDIF
      0  2090					      DEF	BlankSprite
      1  2090				   SLOT_BlankSprite SET	_BANK_SLOT
      2  2090				   BANK_BlankSprite SET	SLOT_BlankSprite + _CURRENT_BANK
      3  2090				   BlankSprite
      4  2090				   TEMPORARY_VAR SET	Overlay
      5  2090				   TEMPORARY_OFFSET SET	0
      6  2090				   VAR_BOUNDARY_BlankSprite SET	TEMPORARY_OFFSET
      7  2090				   FUNCTION_NAME SET	BlankSprite
      5  2090
     71  2090		       00 00 00 00*	      ds	8, 0
     72  2098
      0  2098					      ALLOCATE	SpriteBuffer, 8
      1  2098
      2  2098				   .NAME      SETSTR	SpriteBuffer
      0  2098					      OPTIONAL_PAGEBREAK	.NAME, 8
      1  2098
      2  2098				  -	      IF	(>( * + 8 -1 )) > ( >* )
      3  2098				  -.EARLY_LOCATION SET	*
      4  2098				  -	      ALIGN	256
      5  2098				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2098					      ENDIF
      0  2098					      DEF	SpriteBuffer
      1  2098				   SLOT_SpriteBuffer SET	_BANK_SLOT
      2  2098				   BANK_SpriteBuffer SET	SLOT_SpriteBuffer + _CURRENT_BANK
      3  2098				   SpriteBuffer
      4  2098				   TEMPORARY_VAR SET	Overlay
      5  2098				   TEMPORARY_OFFSET SET	0
      6  2098				   VAR_BOUNDARY_SpriteBuffer SET	TEMPORARY_OFFSET
      7  2098				   FUNCTION_NAME SET	SpriteBuffer
      5  2098
     74  2098				   SpriteBuffer2
     75  2098		       f8		      .byte.b	%11111000
     76  2099		       f8		      .byte.b	%11111000
     77  209a		       f8		      .byte.b	%11111000
     78  209b		       f8		      .byte.b	%11111000
     79  209c		       f8		      .byte.b	%11111000
     80  209d		       f8		      .byte.b	%11111000
     81  209e		       f8		      .byte.b	%11111000
     82  209f		       f8		      .byte.b	%11111000
     83  20a0
     84  20a0							;---------------------------------------------------------------------------------------------------
     85  20a0
     86  20a0							;ALIGN 256
     87  20a0					      SUBROUTINE
     88  20a0
      0  20a0					      REF	StartupBankReset
      1  20a0				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  20a0				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  20a0					      ENDIF
     90  20a0							;__dummy
     91  20a0							;    VEND __dummy
     92  20a0
     93  20a0							; x = row # (and bank#)
     94  20a0
     95  20a0				   .endline
     96  20a0
     97  20a0							;@59
     98  20a0
     99  20a0							; The following 'inx' is replaced in the LAST row bank with a 'RTS', thus ending the draw loop
    100  20a0							; Note that the other 7 row banks are unmodified (keeping the 'inx')
    101  20a0				   SELFMOD_RTS_ON_LAST_ROW
    102  20a0
    103  20a0		       e8		      inx		; 2
    104  20a1		       86 3e		      stx	SET_BANK_RAM	; 3 @64     BANK switch to next row
    105  20a3
      0  20a3					      DEF	DrawRow
      1  20a3				   SLOT_DrawRow SET	_BANK_SLOT
      2  20a3				   BANK_DrawRow SET	SLOT_DrawRow + _CURRENT_BANK
      3  20a3				   DrawRow
      4  20a3				   TEMPORARY_VAR SET	Overlay
      5  20a3				   TEMPORARY_OFFSET SET	0
      6  20a3				   VAR_BOUNDARY_DrawRow SET	TEMPORARY_OFFSET
      7  20a3				   FUNCTION_NAME SET	DrawRow
    107  20a3
    108  20a3							;@64
    109  20a3		       a0 07		      ldy	#7	; 2
    110  20a5		       10 3b		      bpl	.dl2	; 3   (must be 69 here)
    111  20a7
    112  20a7							;@58...
    113  20a7
    114  20a7				   .l3
    115  20a7
    116  20a7		       b9 a8 f8    SMSPRITE16_0 lda	SpriteBuffer+16,y	; 4
    117  20aa		       85 5b		      sta	GRP0	; 3
    118  20ac		       b9 a8 f8    SMSPRITE16_1 lda	SpriteBuffer2+16,y	; 4
    119  20af		       85 5c		      sta	GRP1	; 3
    120  20b1
    121  20b1							;@-4
    122  20b1
    123  20b1		       a9 86		      lda	#COLOUR_LINE_1	;#$94			  ; 2
    124  20b3		       85 48		      sta	COLUPF	; 3 @1
    125  20b5
    126  20b5		       b9 10 f8 	      lda	ChessBitmap0+16,y	; 4
    127  20b8		       85 4d		      sta	PF0	; 3
    128  20ba		       b9 28 f8 	      lda	ChessBitmap1+16,y	; 4
    129  20bd		       85 4e		      sta	PF1	; 3
    130  20bf		       b9 40 f8 	      lda	ChessBitmap2+16,y	; 4
    131  20c2		       85 4f		      sta	PF2	; 3 @22
    132  20c4
      0  20c4					      SLEEP	6	; 6 @28
      1  20c4				   .CYCLES    SET	6
      2  20c4
      3  20c4				  -	      IF	.CYCLES < 2
      4  20c4				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  20c4				  -	      ERR
      6  20c4					      ENDIF
      7  20c4
      8  20c4				  -	      IF	.CYCLES & 1
      9  20c4				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  20c4				  -	      nop	0
     11  20c4				  -	      ELSE
     12  20c4				  -	      bit	VSYNC
     13  20c4				  -	      ENDIF
     14  20c4				  -.CYCLES    SET	.CYCLES - 3
     15  20c4					      ENDIF
     16  20c4
     17  20c4					      REPEAT	.CYCLES / 2
     18  20c4		       ea		      nop
     17  20c4					      REPEND
     18  20c5		       ea		      nop
     17  20c5					      REPEND
     18  20c6		       ea		      nop
     19  20c7					      REPEND
    134  20c7
    135  20c7		       b9 58 f8 	      lda	ChessBitmap3+16,y	; 4
    136  20ca		       85 4d		      sta	PF0	; 3
    137  20cc		       b9 70 f8 	      lda	ChessBitmap4+16,y	; 4
    138  20cf		       85 4e		      sta	PF1	; 3
    139  20d1		       b9 88 f8 	      lda	ChessBitmap5+16,y	; 4
    140  20d4		       8d 4f 00 	      sta.w	PF2	; 4 @50
    141  20d7
      0  20d7					      SLEEP	4	; 4
      1  20d7				   .CYCLES    SET	4
      2  20d7
      3  20d7				  -	      IF	.CYCLES < 2
      4  20d7				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  20d7				  -	      ERR
      6  20d7					      ENDIF
      7  20d7
      8  20d7				  -	      IF	.CYCLES & 1
      9  20d7				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  20d7				  -	      nop	0
     11  20d7				  -	      ELSE
     12  20d7				  -	      bit	VSYNC
     13  20d7				  -	      ENDIF
     14  20d7				  -.CYCLES    SET	.CYCLES - 3
     15  20d7					      ENDIF
     16  20d7
     17  20d7					      REPEAT	.CYCLES / 2
     18  20d7		       ea		      nop
     17  20d7					      REPEND
     18  20d8		       ea		      nop
     19  20d9					      REPEND
    143  20d9
    144  20d9		       88		      dey		; 2
    145  20da		       30 c4		      bmi	.endline	; 2 (3)
    146  20dc
    147  20dc							;@57
    148  20dc				   .drawLine
    149  20dc
      0  20dc					      SLEEP	11
      1  20dc				   .CYCLES    SET	11
      2  20dc
      3  20dc				  -	      IF	.CYCLES < 2
      4  20dc				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  20dc				  -	      ERR
      6  20dc					      ENDIF
      7  20dc
      8  20dc					      IF	.CYCLES & 1
      9  20dc					      IFNCONST	NO_ILLEGAL_OPCODES
     10  20dc		       04 00		      nop	0
     11  20de				  -	      ELSE
     12  20de				  -	      bit	VSYNC
     13  20de					      ENDIF
     14  20de				   .CYCLES    SET	.CYCLES - 3
     15  20de					      ENDIF
     16  20de
     17  20de					      REPEAT	.CYCLES / 2
     18  20de		       ea		      nop
     17  20de					      REPEND
     18  20df		       ea		      nop
     17  20df					      REPEND
     18  20e0		       ea		      nop
     17  20e0					      REPEND
     18  20e1		       ea		      nop
     19  20e2					      REPEND
    151  20e2
    152  20e2				   .dl2
    153  20e2		       b9 98 f8    SMSPRITE0_0 lda	SpriteBuffer,y	; 4
    154  20e5		       85 5b		      sta	GRP0	; 3
    155  20e7		       b9 98 f8    SMSPRITE0_1 lda	SpriteBuffer2,y	; 4
    156  20ea		       85 5c		      sta	GRP1	; 3
    157  20ec
    158  20ec							;@7
    159  20ec
    160  20ec		       a9 48		      lda	#COLOUR_LINE_2	;#$4A			  ; 2
    161  20ee		       85 48		      sta	COLUPF	; 3 @12
    162  20f0
    163  20f0		       b9 00 f8 	      lda	ChessBitmap0,y	; 4
    164  20f3		       85 4d		      sta	PF0	; 3
    165  20f5		       b9 18 f8 	      lda	ChessBitmap1,y	; 4
    166  20f8		       85 4e		      sta	PF1	; 3
    167  20fa		       b9 30 f8 	      lda	ChessBitmap2,y	; 4
    168  20fd		       85 4f		      sta	PF2	; 3 @33
    169  20ff
      0  20ff					      SLEEP	3	; 3 @36
      1  20ff				   .CYCLES    SET	3
      2  20ff
      3  20ff				  -	      IF	.CYCLES < 2
      4  20ff				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  20ff				  -	      ERR
      6  20ff					      ENDIF
      7  20ff
      8  20ff					      IF	.CYCLES & 1
      9  20ff					      IFNCONST	NO_ILLEGAL_OPCODES
     10  20ff		       04 00		      nop	0
     11  2101				  -	      ELSE
     12  2101				  -	      bit	VSYNC
     13  2101					      ENDIF
     14  2101				   .CYCLES    SET	.CYCLES - 3
     15  2101					      ENDIF
     16  2101
     17  2101				  -	      REPEAT	.CYCLES / 2
     18  2101				  -	      nop
     19  2101					      REPEND
    171  2101
    172  2101		       b9 48 f8 	      lda	ChessBitmap3,y	; 4
    173  2104		       85 4d		      sta	PF0	; 3
    174  2106		       b9 60 f8 	      lda	ChessBitmap4,y	; 4
    175  2109		       85 4e		      sta	PF1	; 3
    176  210b		       b9 78 f8 	      lda	ChessBitmap5,y	; 4
    177  210e		       85 4f		      sta	PF2	; 3 @57
    178  2110
      0  2110					      SLEEP	5
      1  2110				   .CYCLES    SET	5
      2  2110
      3  2110				  -	      IF	.CYCLES < 2
      4  2110				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2110				  -	      ERR
      6  2110					      ENDIF
      7  2110
      8  2110					      IF	.CYCLES & 1
      9  2110					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2110		       04 00		      nop	0
     11  2112				  -	      ELSE
     12  2112				  -	      bit	VSYNC
     13  2112					      ENDIF
     14  2112				   .CYCLES    SET	.CYCLES - 3
     15  2112					      ENDIF
     16  2112
     17  2112					      REPEAT	.CYCLES / 2
     18  2112		       ea		      nop
     19  2113					      REPEND
    180  2113
    181  2113		       b9 a0 f8    SMSPRITE8_0 lda	SpriteBuffer+8,y	; 4
    182  2116		       85 5b		      sta	GRP0	; 3
    183  2118		       b9 a0 f8    SMSPRITE8_1 lda	SpriteBuffer2+8,y	; 4
    184  211b		       85 5c		      sta	GRP1	; 3
    185  211d
    186  211d							;@0
    187  211d		       a9 d8		      lda	#COLOUR_LINE_3	;#$28			  ; 2
    188  211f		       85 48		      sta	COLUPF	; 3 @5
    189  2121
    190  2121		       b9 08 f8 	      lda	ChessBitmap0+8,y	; 4
    191  2124		       85 4d		      sta	PF0	; 3
    192  2126		       b9 20 f8 	      lda	ChessBitmap1+8,y	; 4
    193  2129		       85 4e		      sta	PF1	; 3
    194  212b		       b9 38 f8 	      lda	ChessBitmap2+8,y	; 4
    195  212e		       85 4f		      sta	PF2	; 3 @26
    196  2130
      0  2130					      SLEEP	8	; 6 @34
      1  2130				   .CYCLES    SET	8
      2  2130
      3  2130				  -	      IF	.CYCLES < 2
      4  2130				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2130				  -	      ERR
      6  2130					      ENDIF
      7  2130
      8  2130				  -	      IF	.CYCLES & 1
      9  2130				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2130				  -	      nop	0
     11  2130				  -	      ELSE
     12  2130				  -	      bit	VSYNC
     13  2130				  -	      ENDIF
     14  2130				  -.CYCLES    SET	.CYCLES - 3
     15  2130					      ENDIF
     16  2130
     17  2130					      REPEAT	.CYCLES / 2
     18  2130		       ea		      nop
     17  2130					      REPEND
     18  2131		       ea		      nop
     17  2131					      REPEND
     18  2132		       ea		      nop
     17  2132					      REPEND
     18  2133		       ea		      nop
     19  2134					      REPEND
    198  2134
    199  2134		       b9 50 f8 	      lda	ChessBitmap3+8,y	; 4
    200  2137		       85 4d		      sta	PF0	; 3
    201  2139		       b9 68 f8 	      lda	ChessBitmap4+8,y	; 4
    202  213c		       85 4e		      sta	PF1	; 3
    203  213e		       b9 80 f8 	      lda	ChessBitmap5+8,y	; 4
    204  2141		       85 4f		      sta	PF2	; 3 @55
    205  2143
    206  2143		       4c a7 f8 	      jmp	.l3	; 3 @58
    207  2146
    208  2146
    209  2146							;---------------------------------------------------------------------------------------------------
    210  2146
      0  2146					      DEF	BackupBitmap
      1  2146				   SLOT_BackupBitmap SET	_BANK_SLOT
      2  2146				   BANK_BackupBitmap SET	SLOT_BackupBitmap + _CURRENT_BANK
      3  2146				   BackupBitmap
      4  2146				   TEMPORARY_VAR SET	Overlay
      5  2146				   TEMPORARY_OFFSET SET	0
      6  2146				   VAR_BOUNDARY_BackupBitmap SET	TEMPORARY_OFFSET
      7  2146				   FUNCTION_NAME SET	BackupBitmap
    212  2146		       00 00 00 00*	      ds	ROW_BITMAP_SIZE, 0
    213  21d6
    214  21d6
    215  21d6							;---------------------------------------------------------------------------------------------------
    216  21d6
      0  21d6					      CHECK_RAM_BANK_SIZE
      1  21d6		       01 d6	   .TEMP      =	* - _BANK_START
 RAM bank # 8 BITMAP size =  $1d6 free = $29
      2  21d6					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3  21d6				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  21d6				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5  21d6				  -	      ERR
      6  21d6					      ENDIF
    218  21d6
    219  21d6							;---------------------------------------------------------------------------------------------------
    220  21d6							;EOF
------- FILE ./chess.asm
------- FILE @2 PLY.asm LEVEL 2 PASS 4
      0  21d6					      include	"@2 PLY.asm"
      1  21d6							;---------------------------------------------------------------------------------------------------
      2  21d6							; @2 PLY.asm
      3  21d6
      4  21d6							; Atari 2600 Chess
      5  21d6							; Copyright (c) 2019-2020 Andrew Davie
      6  21d6							; andrew@taswegian.com
      7  21d6
      8  21d6
      9  21d6							;---------------------------------------------------------------------------------------------------
     10  21d6							; Define the RAM banks
     11  21d6							; A "PLY" bank represents all the data required on any single ply of the search tree.
     12  21d6							; The banks are organised sequentially, PLY_BANKS of them starting at RAMBANK_PLY
     13  21d6							; The startup code copies the ROM shadow into each of these PLY banks, and from then on
     14  21d6							; they act as independant switchable banks usable for data on each ply during the search.
     15  21d6							; A ply will hold the move list for that position
     16  21d6
     17  21d6
      0  21d6					      SLOT	2
      1  21d6
      2  21d6				  -	      IF	(2 < 0) || (2 > 3)
      3  21d6				  -	      ECHO	"Illegal bank address/segment location", 2
      4  21d6				  -	      ERR
      5  21d6					      ENDIF
      6  21d6
      7  21d6				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  21d6				   _BANK_SLOT SET	2 * 64
      9  21d6
      0  21d6					      RAMBANK	PLY	; RAM bank for holding the following ROM shadow
      1  21d6
      2 U11dc ????				      SEG.U	RAM_PLY
      3 U1000					      ORG	ORIGIN_RAM
      4 U1000					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1000				   _BANK_START SET	*
      6 U1000				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1000				   RAMBANK_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1000				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1000				   _LAST_BANK SETSTR	PLY
     10 U1000				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
     20 U1000
     21 U1000							;---------------------------------------------------------------------------------------------------
     22 U1000
     23 U1000		       00 64	   MAX_MOVES  =	100	; big is good
     24 U1000
      0 U1000					      VARIABLE	MoveFrom, MAX_MOVES
      1 U1000
      2 U1000				   .NAME      SETSTR	MoveFrom
      0 U1000					      OPTIONAL_PAGEBREAK	.NAME, MAX_MOVES
      1 U1000
      2 U1000				  -	      IF	(>( * + MAX_MOVES -1 )) > ( >* )
      3 U1000				  -.EARLY_LOCATION SET	*
      4 U1000				  -	      ALIGN	256
      5 U1000				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U1000					      ENDIF
      4 U1000		       00 00 00 00*MoveFrom   ds	MAX_MOVES
      5 U1064
      0 U1064					      VARIABLE	MoveTo, MAX_MOVES
      1 U1064
      2 U1064				   .NAME      SETSTR	MoveTo
      0 U1064					      OPTIONAL_PAGEBREAK	.NAME, MAX_MOVES
      1 U1064
      2 U1064				  -	      IF	(>( * + MAX_MOVES -1 )) > ( >* )
      3 U1064				  -.EARLY_LOCATION SET	*
      4 U1064				  -	      ALIGN	256
      5 U1064				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U1064					      ENDIF
      4 U1064		       00 00 00 00*MoveTo     ds	MAX_MOVES
      5 U10c8
      0 U10c8					      VARIABLE	MovePiece, MAX_MOVES
      1 U10c8
      2 U10c8				   .NAME      SETSTR	MovePiece
      0 U10c8					      OPTIONAL_PAGEBREAK	.NAME, MAX_MOVES
      1 U10c8
      2 U10c8					      IF	(>( * + MAX_MOVES -1 )) > ( >* )
      3 U10c8				   .EARLY_LOCATION SET	*
      4 U1100		       00 00 00 00*	      ALIGN	256
 Page break for wasted 56 bytes
      5 U1100					      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U1100					      ENDIF
      4 U1100		       00 00 00 00*MovePiece  ds	MAX_MOVES
      5 U1164
      0 U1164					      VARIABLE	MoveCapture, MAX_MOVES
      1 U1164
      2 U1164				   .NAME      SETSTR	MoveCapture
      0 U1164					      OPTIONAL_PAGEBREAK	.NAME, MAX_MOVES
      1 U1164
      2 U1164				  -	      IF	(>( * + MAX_MOVES -1 )) > ( >* )
      3 U1164				  -.EARLY_LOCATION SET	*
      4 U1164				  -	      ALIGN	256
      5 U1164				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U1164					      ENDIF
      4 U1164		       00 00 00 00*MoveCapture ds	MAX_MOVES
      5 U11c8
     29 U11c8
     30 U11c8
     31 U11c8							;---------------------------------------------------------------------------------------------------
     32 U11c8
     33 U11c8							; The X12 square at which a pawn CAN be taken en-passant. Normally 0.
     34 U11c8							; This is set/cleared whenever a move is made. The flag is indicated in the move description.
     35 U11c8
      0 U11c8					      VARIABLE	savedEvaluation, 2	; THIS node's evaluation - used for reverting moves!
      1 U11c8
      2 U11c8				   .NAME      SETSTR	savedEvaluation
      0 U11c8					      OPTIONAL_PAGEBREAK	.NAME, 2
      1 U11c8
      2 U11c8				  -	      IF	(>( * + 2 -1 )) > ( >* )
      3 U11c8				  -.EARLY_LOCATION SET	*
      4 U11c8				  -	      ALIGN	256
      5 U11c8				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11c8					      ENDIF
      4 U11c8		       00 00	   savedEvaluation ds	2
      5 U11ca
      0 U11ca					      VARIABLE	enPassantSquare, 1
      1 U11ca
      2 U11ca				   .NAME      SETSTR	enPassantSquare
      0 U11ca					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11ca
      2 U11ca				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11ca				  -.EARLY_LOCATION SET	*
      4 U11ca				  -	      ALIGN	256
      5 U11ca				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11ca					      ENDIF
      4 U11ca		       00	   enPassantSquare ds	1
      5 U11cb
      0 U11cb					      VARIABLE	capturedPiece, 1
      1 U11cb
      2 U11cb				   .NAME      SETSTR	capturedPiece
      0 U11cb					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11cb
      2 U11cb				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11cb				  -.EARLY_LOCATION SET	*
      4 U11cb				  -	      ALIGN	256
      5 U11cb				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11cb					      ENDIF
      4 U11cb		       00	   capturedPiece ds	1
      5 U11cc
     39 U11cc							;VARIABLE originalPiece, 1
      0 U11cc					      VARIABLE	secondaryPiece, 1	; original piece on secondary (castle, enpassant)
      1 U11cc
      2 U11cc				   .NAME      SETSTR	secondaryPiece
      0 U11cc					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11cc
      2 U11cc				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11cc				  -.EARLY_LOCATION SET	*
      4 U11cc				  -	      ALIGN	256
      5 U11cc				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11cc					      ENDIF
      4 U11cc		       00	   secondaryPiece ds	1
      5 U11cd
      0 U11cd					      VARIABLE	secondarySquare, 1	; original square of secondary piece
      1 U11cd
      2 U11cd				   .NAME      SETSTR	secondarySquare
      0 U11cd					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11cd
      2 U11cd				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11cd				  -.EARLY_LOCATION SET	*
      4 U11cd				  -	      ALIGN	256
      5 U11cd				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11cd					      ENDIF
      4 U11cd		       00	   secondarySquare ds	1
      5 U11ce
      0 U11ce					      VARIABLE	secondaryBlank, 1	; square to blank on secondary
      1 U11ce
      2 U11ce				   .NAME      SETSTR	secondaryBlank
      0 U11ce					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11ce
      2 U11ce				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11ce				  -.EARLY_LOCATION SET	*
      4 U11ce				  -	      ALIGN	256
      5 U11ce				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11ce					      ENDIF
      4 U11ce		       00	   secondaryBlank ds	1
      5 U11cf
      0 U11cf					      VARIABLE	moveIndex, 1	; points to first available 'slot' for move storage
      1 U11cf
      2 U11cf				   .NAME      SETSTR	moveIndex
      0 U11cf					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11cf
      2 U11cf				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11cf				  -.EARLY_LOCATION SET	*
      4 U11cf				  -	      ALIGN	256
      5 U11cf				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11cf					      ENDIF
      4 U11cf		       00	   moveIndex  ds	1
      5 U11d0
      0 U11d0					      VARIABLE	movePtr, 1
      1 U11d0
      2 U11d0				   .NAME      SETSTR	movePtr
      0 U11d0					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11d0
      2 U11d0				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11d0				  -.EARLY_LOCATION SET	*
      4 U11d0				  -	      ALIGN	256
      5 U11d0				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d0					      ENDIF
      4 U11d0		       00	   movePtr    ds	1
      5 U11d1
      0 U11d1					      VARIABLE	bestMove, 1
      1 U11d1
      2 U11d1				   .NAME      SETSTR	bestMove
      0 U11d1					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11d1
      2 U11d1				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11d1				  -.EARLY_LOCATION SET	*
      4 U11d1				  -	      ALIGN	256
      5 U11d1				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d1					      ENDIF
      4 U11d1		       00	   bestMove   ds	1
      5 U11d2
      0 U11d2					      VARIABLE	alpha, 2
      1 U11d2
      2 U11d2				   .NAME      SETSTR	alpha
      0 U11d2					      OPTIONAL_PAGEBREAK	.NAME, 2
      1 U11d2
      2 U11d2				  -	      IF	(>( * + 2 -1 )) > ( >* )
      3 U11d2				  -.EARLY_LOCATION SET	*
      4 U11d2				  -	      ALIGN	256
      5 U11d2				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d2					      ENDIF
      4 U11d2		       00 00	   alpha      ds	2
      5 U11d4
      0 U11d4					      VARIABLE	beta, 2
      1 U11d4
      2 U11d4				   .NAME      SETSTR	beta
      0 U11d4					      OPTIONAL_PAGEBREAK	.NAME, 2
      1 U11d4
      2 U11d4				  -	      IF	(>( * + 2 -1 )) > ( >* )
      3 U11d4				  -.EARLY_LOCATION SET	*
      4 U11d4				  -	      ALIGN	256
      5 U11d4				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d4					      ENDIF
      4 U11d4		       00 00	   beta       ds	2
      5 U11d6
      0 U11d6					      VARIABLE	value, 2
      1 U11d6
      2 U11d6				   .NAME      SETSTR	value
      0 U11d6					      OPTIONAL_PAGEBREAK	.NAME, 2
      1 U11d6
      2 U11d6				  -	      IF	(>( * + 2 -1 )) > ( >* )
      3 U11d6				  -.EARLY_LOCATION SET	*
      4 U11d6				  -	      ALIGN	256
      5 U11d6				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d6					      ENDIF
      4 U11d6		       00 00	   value      ds	2
      5 U11d8
      0 U11d8					      VARIABLE	depthLeft, 1
      1 U11d8
      2 U11d8				   .NAME      SETSTR	depthLeft
      0 U11d8					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11d8
      2 U11d8				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11d8				  -.EARLY_LOCATION SET	*
      4 U11d8				  -	      ALIGN	256
      5 U11d8				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d8					      ENDIF
      4 U11d8		       00	   depthLeft  ds	1
      5 U11d9
      0 U11d9					      VARIABLE	restorePiece, 1
      1 U11d9
      2 U11d9				   .NAME      SETSTR	restorePiece
      0 U11d9					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11d9
      2 U11d9				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11d9				  -.EARLY_LOCATION SET	*
      4 U11d9				  -	      ALIGN	256
      5 U11d9				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d9					      ENDIF
      4 U11d9		       00	   restorePiece ds	1
      5 U11da
      0 U11da					      VARIABLE	virtualKingSquare, 2	; traversing squares for castle/check
      1 U11da
      2 U11da				   .NAME      SETSTR	virtualKingSquare
      0 U11da					      OPTIONAL_PAGEBREAK	.NAME, 2
      1 U11da
      2 U11da				  -	      IF	(>( * + 2 -1 )) > ( >* )
      3 U11da				  -.EARLY_LOCATION SET	*
      4 U11da				  -	      ALIGN	256
      5 U11da				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11da					      ENDIF
      4 U11da		       00 00	   virtualKingSquare ds	2
      5 U11dc
     52 U11dc
      0 U11dc					      END_BANK
      1 U11dc					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U11dc					      CHECK_RAM_BANK_SIZE
      1 U11dc		       01 dc	   .TEMP      =	* - _BANK_START
 RAM bank # 9 PLY size =  $1dc free = $23
      2 U11dc					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U11dc				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U11dc				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U11dc				  -	      ERR
      6 U11dc					      ENDIF
      3 U11dc				  -	      ELSE
      4 U11dc				  -	      CHECK_BANK_SIZE
      5 U11dc					      ENDIF
     54 U11dc
     55 U11dc
     56 U11dc					      REPEAT	PLY_BANKS-1
      0 U11dc					      RAMBANK	.DUMMY_PLY
      1 U11dc
      2 U1c00 ????				      SEG.U	RAM_.DUMMY_PLY
      3 U1200					      ORG	ORIGIN_RAM
      4 U1200					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1200				   _BANK_START SET	*
      6 U1200				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1200				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1200				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1200				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1200				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1200					      END_BANK
      1 U1200					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1200					      CHECK_RAM_BANK_SIZE
      1 U1200		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 10 .DUMMY_PLY size =  $0 free = $1ff
      2 U1200					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1200				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1200				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1200				  -	      ERR
      6 U1200					      ENDIF
      3 U1200				  -	      ELSE
      4 U1200				  -	      CHECK_BANK_SIZE
      5 U1200					      ENDIF
     56 U1200					      REPEND
      0 U1200					      RAMBANK	.DUMMY_PLY
      1 U1200
      2 U1200					      SEG.U	RAM_.DUMMY_PLY
      3 U1400					      ORG	ORIGIN_RAM
      4 U1400					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1400				   _BANK_START SET	*
      6 U1400				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1400				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1400				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1400				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1400					      END_BANK
      1 U1400					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1400					      CHECK_RAM_BANK_SIZE
      1 U1400		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 11 .DUMMY_PLY size =  $0 free = $1ff
      2 U1400					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1400				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1400				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1400				  -	      ERR
      6 U1400					      ENDIF
      3 U1400				  -	      ELSE
      4 U1400				  -	      CHECK_BANK_SIZE
      5 U1400					      ENDIF
     56 U1400					      REPEND
      0 U1400					      RAMBANK	.DUMMY_PLY
      1 U1400
      2 U1400					      SEG.U	RAM_.DUMMY_PLY
      3 U1600					      ORG	ORIGIN_RAM
      4 U1600					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1600				   _BANK_START SET	*
      6 U1600				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1600				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1600				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1600				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1600				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1600					      END_BANK
      1 U1600					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1600					      CHECK_RAM_BANK_SIZE
      1 U1600		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 12 .DUMMY_PLY size =  $0 free = $1ff
      2 U1600					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1600				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1600				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1600				  -	      ERR
      6 U1600					      ENDIF
      3 U1600				  -	      ELSE
      4 U1600				  -	      CHECK_BANK_SIZE
      5 U1600					      ENDIF
     56 U1600					      REPEND
      0 U1600					      RAMBANK	.DUMMY_PLY
      1 U1600
      2 U1600					      SEG.U	RAM_.DUMMY_PLY
      3 U1800					      ORG	ORIGIN_RAM
      4 U1800					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1800				   _BANK_START SET	*
      6 U1800				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1800				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1800				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1800				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1800					      END_BANK
      1 U1800					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1800					      CHECK_RAM_BANK_SIZE
      1 U1800		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 13 .DUMMY_PLY size =  $0 free = $1ff
      2 U1800					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1800				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1800				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1800				  -	      ERR
      6 U1800					      ENDIF
      3 U1800				  -	      ELSE
      4 U1800				  -	      CHECK_BANK_SIZE
      5 U1800					      ENDIF
     56 U1800					      REPEND
      0 U1800					      RAMBANK	.DUMMY_PLY
      1 U1800
      2 U1800					      SEG.U	RAM_.DUMMY_PLY
      3 U1a00					      ORG	ORIGIN_RAM
      4 U1a00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1a00				   _BANK_START SET	*
      6 U1a00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1a00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1a00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1a00				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1a00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1a00					      END_BANK
      1 U1a00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1a00					      CHECK_RAM_BANK_SIZE
      1 U1a00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 14 .DUMMY_PLY size =  $0 free = $1ff
      2 U1a00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1a00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1a00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1a00				  -	      ERR
      6 U1a00					      ENDIF
      3 U1a00				  -	      ELSE
      4 U1a00				  -	      CHECK_BANK_SIZE
      5 U1a00					      ENDIF
     56 U1a00					      REPEND
      0 U1a00					      RAMBANK	.DUMMY_PLY
      1 U1a00
      2 U1a00					      SEG.U	RAM_.DUMMY_PLY
      3 U1c00					      ORG	ORIGIN_RAM
      4 U1c00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1c00				   _BANK_START SET	*
      6 U1c00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1c00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1c00				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1c00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1c00					      END_BANK
      1 U1c00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1c00					      CHECK_RAM_BANK_SIZE
      1 U1c00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 15 .DUMMY_PLY size =  $0 free = $1ff
      2 U1c00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1c00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1c00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1c00				  -	      ERR
      6 U1c00					      ENDIF
      3 U1c00				  -	      ELSE
      4 U1c00				  -	      CHECK_BANK_SIZE
      5 U1c00					      ENDIF
     59 U1c00					      REPEND
     60 U1c00
     61 U1c00
     62 U1c00							;---------------------------------------------------------------------------------------------------
     63 U1c00							; EOF
------- FILE ./chess.asm
------- FILE @2 GENERIC #3.asm LEVEL 2 PASS 4
      0 U1c00					      include	"@2 GENERIC #3.asm"
      1 U1c00							;---------------------------------------------------------------------------------------------------
      2 U1c00							; @2 GENERIC #3.asm
      3 U1c00
      4 U1c00							; Atari 2600 Chess
      5 U1c00							; Copyright (c) 2019-2020 Andrew Davie
      6 U1c00							; andrew@taswegian.com
      7 U1c00
      8 U1c00
      9 U1c00							;---------------------------------------------------------------------------------------------------
     10 U1c00
      0 U1c00					      SLOT	2
      1 U1c00
      2 U1c00				  -	      IF	(2 < 0) || (2 > 3)
      3 U1c00				  -	      ECHO	"Illegal bank address/segment location", 2
      4 U1c00				  -	      ERR
      5 U1c00					      ENDIF
      6 U1c00
      7 U1c00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8 U1c00				   _BANK_SLOT SET	2 * 64
      9 U1c00
      0 U1c00					      ROMBANK	GENERIC_BANK@2#1
      1  27a1 ????				      SEG	ROM_GENERIC_BANK@2#1
      2  2400					      ORG	_ORIGIN
      3  2400					      RORG	_BANK_ADDRESS_ORIGIN
      4  2400				   _BANK_START SET	*
      5  2400				   GENERIC_BANK@2#1_START SET	*
      6  2400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  2400				   ROMBANK_GENERIC_BANK@2#1 SET	_BANK_SLOT + _CURRENT_BANK
      8  2400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  2400				   _LAST_BANK SETSTR	GENERIC_BANK@2#1
     10  2400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  2400
     14  2400							;    DEFINE_1K_SEGMENT DECODE_LEVEL_SHADOW
     15  2400
     16  2400				  -	      IF	PLUSCART = YES
     17  2400				  -	      .byte	"ChessAPI.php", #0 //TODO: change!
     18  2400				  -	      .byte	"pluscart.firmaplus.de", #0
     19  2400					      ENDIF
     20  2400
     21  2400		       54 4a 33 45 STELLA_AUTODETECT dc	"TJ3E"	; 3E+ autodetect
     22  2404
     23  2404
     24  2404							;---------------------------------------------------------------------------------------------------
     25  2404
      0  2404					      DEF	tidySc
      1  2404				   SLOT_tidySc SET	_BANK_SLOT
      2  2404				   BANK_tidySc SET	SLOT_tidySc + _CURRENT_BANK
      3  2404				   tidySc
      4  2404				   TEMPORARY_VAR SET	Overlay
      5  2404				   TEMPORARY_OFFSET SET	0
      6  2404				   VAR_BOUNDARY_tidySc SET	TEMPORARY_OFFSET
      7  2404				   FUNCTION_NAME SET	tidySc
     27  2404					      SUBROUTINE
     28  2404
      0  2404					      REF	StartupBankReset	;✅
      1  2404				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  2404				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  2404					      ENDIF
      0  2404					      VEND	tidySc
      1  2404
      2  2404
      3  2404		       00 a7	   VAREND_tidySc =	TEMPORARY_VAR
      4  2404
     31  2404
     32  2404		       a9 00		      lda	#0
     33  2406		       85 4d		      sta	PF0
     34  2408		       85 4e		      sta	PF1
     35  240a		       85 4f		      sta	PF2
     36  240c		       85 5b		      sta	GRP0
     37  240e
     38  240e		       a9 42		      lda	#%01000010	; bit6 is not required
     39  2410							;sta VBLANK			  ; end of screen - enter blanking
     40  2410
     41  2410
     42  2410							; END OF VISIBLE SCREEN
     43  2410							; HERE'S SOME TIME TO DO STUFF
     44  2410
     45  2410		       a9 2e		      lda	#TIME_PART_2
     46  2412		       8d 96 02 	      sta	TIM64T
     47  2415		       60		      rts
     48  2416
     49  2416
     50  2416							;---------------------------------------------------------------------------------------------------
     51  2416
      0  2416					      DEF	longD
      1  2416				   SLOT_longD SET	_BANK_SLOT
      2  2416				   BANK_longD SET	SLOT_longD + _CURRENT_BANK
      3  2416				   longD
      4  2416				   TEMPORARY_VAR SET	Overlay
      5  2416				   TEMPORARY_OFFSET SET	0
      6  2416				   VAR_BOUNDARY_longD SET	TEMPORARY_OFFSET
      7  2416				   FUNCTION_NAME SET	longD
     53  2416					      SUBROUTINE
     54  2416
      0  2416					      REF	StartupBankReset	;✅
      1  2416				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  2416				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  2416					      ENDIF
      0  2416					      VEND	longD
      1  2416
      2  2416
      3  2416		       00 a7	   VAREND_longD =	TEMPORARY_VAR
      4  2416
     57  2416
     58  2416		       85 42		      sta	WSYNC
     59  2418
     60  2418		       20 29 f8 	      jsr	_rts
     61  241b		       20 29 f8 	      jsr	_rts
     62  241e		       20 29 f8 	      jsr	_rts
      0  2421					      SLEEP	7
      1  2421				   .CYCLES    SET	7
      2  2421
      3  2421				  -	      IF	.CYCLES < 2
      4  2421				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2421				  -	      ERR
      6  2421					      ENDIF
      7  2421
      8  2421					      IF	.CYCLES & 1
      9  2421					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2421		       04 00		      nop	0
     11  2423				  -	      ELSE
     12  2423				  -	      bit	VSYNC
     13  2423					      ENDIF
     14  2423				   .CYCLES    SET	.CYCLES - 3
     15  2423					      ENDIF
     16  2423
     17  2423					      REPEAT	.CYCLES / 2
     18  2423		       ea		      nop
     17  2423					      REPEND
     18  2424		       ea		      nop
     19  2425					      REPEND
     64  2425
     65  2425		       a2 00		      ldx	#0
     66  2427		       86 41		      stx	VBLANK
     67  2429		       60	   _rts       rts
     68  242a
     69  242a
     70  242a							;---------------------------------------------------------------------------------------------------
     71  242a
      0  242a					      DEF	aiStartClearBoard
      1  242a				   SLOT_aiStartClearBoard SET	_BANK_SLOT
      2  242a				   BANK_aiStartClearBoard SET	SLOT_aiStartClearBoard + _CURRENT_BANK
      3  242a				   aiStartClearBoard
      4  242a				   TEMPORARY_VAR SET	Overlay
      5  242a				   TEMPORARY_OFFSET SET	0
      6  242a				   VAR_BOUNDARY_aiStartClearBoard SET	TEMPORARY_OFFSET
      7  242a				   FUNCTION_NAME SET	aiStartClearBoard
     73  242a					      SUBROUTINE
     74  242a
      0  242a					      REF	AiStateMachine	;✅
      1  242a					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  242a				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  242a					      ENDIF
      0  242a					      VEND	aiStartClearBoard
      1  242a
      2  242a
      3  242a		       00 a9	   VAREND_aiStartClearBoard =	TEMPORARY_VAR
      4  242a
     77  242a
     78  242a		       a2 08		      ldx	#8
     79  242c		       86 84		      stx	drawCount	; = bank
     80  242e
     81  242e		       a9 ff		      lda	#-1
     82  2430		       85 88		      sta	cursorX12
     83  2432
      0  2432					      PHASE	ClearEachRow
      1  2432		       a9 0e		      lda	#AI_ClearEachRow
      2  2434		       85 8b		      sta	aiState
     85  2436		       60		      rts
     86  2437
     87  2437
     88  2437							;---------------------------------------------------------------------------------------------------
     89  2437
      0  2437					      DEF	aiClearEachRow
      1  2437				   SLOT_aiClearEachRow SET	_BANK_SLOT
      2  2437				   BANK_aiClearEachRow SET	SLOT_aiClearEachRow + _CURRENT_BANK
      3  2437				   aiClearEachRow
      4  2437				   TEMPORARY_VAR SET	Overlay
      5  2437				   TEMPORARY_OFFSET SET	0
      6  2437				   VAR_BOUNDARY_aiClearEachRow SET	TEMPORARY_OFFSET
      7  2437				   FUNCTION_NAME SET	aiClearEachRow
     91  2437					      SUBROUTINE
     92  2437
      0  2437					      REF	AiStateMachine	;✅
      1  2437					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2437				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2437					      ENDIF
      0  2437					      VEND	aiClearEachRow
      1  2437
      2  2437
      3  2437		       00 a9	   VAREND_aiClearEachRow =	TEMPORARY_VAR
      4  2437
     95  2437
     96  2437		       c6 84		      dec	drawCount
     97  2439		       30 0e		      bmi	.bitmapCleared
     98  243b
     99  243b							; switch in RAM bank for ROW
    100  243b
    101  243b		       a5 84		      lda	drawCount
    102  243d		       09 40		      ora	#SLOT1
    103  243f		       85 3e		      sta	SET_BANK_RAM	;@1
    104  2441
      0  2441					      CALL	ClearRowBitmap	;@3
      1  2441				  -	      IF	SLOT_ClearRowBitmap == _BANK_SLOT
      2  2441				  -FNAME      SETSTR	ClearRowBitmap
      3  2441				  -	      ECHO	""
      4  2441				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  2441				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  2441				  -	      ERR
      7  2441					      ENDIF
      8  2441		       a9 d9		      lda	#BANK_ClearRowBitmap
      9  2443		       85 3f		      sta	SET_BANK
     10  2445		       20 00 fc 	      jsr	ClearRowBitmap
    106  2448		       60		      rts
    107  2449
    108  2449				   .bitmapCleared
    109  2449
    110  2449		       a9 63		      lda	#99
    111  244b		       85 80		      sta	squareToDraw
    112  244d
      0  244d					      PHASE	DrawEntireBoard
      1  244d		       a9 0f		      lda	#AI_DrawEntireBoard
      2  244f		       85 8b		      sta	aiState
    114  2451		       60		      rts
    115  2452
    116  2452
    117  2452							;---------------------------------------------------------------------------------------------------
    118  2452
      0  2452					      DEF	aiMoveIsSelected
      1  2452				   SLOT_aiMoveIsSelected SET	_BANK_SLOT
      2  2452				   BANK_aiMoveIsSelected SET	SLOT_aiMoveIsSelected + _CURRENT_BANK
      3  2452				   aiMoveIsSelected
      4  2452				   TEMPORARY_VAR SET	Overlay
      5  2452				   TEMPORARY_OFFSET SET	0
      6  2452				   VAR_BOUNDARY_aiMoveIsSelected SET	TEMPORARY_OFFSET
      7  2452				   FUNCTION_NAME SET	aiMoveIsSelected
    120  2452					      SUBROUTINE
    121  2452
      0  2452					      REF	COMMON_VARS
      1  2452					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  2452				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  2452					      ENDIF
      0  2452					      REF	AiStateMachine	;✅
      1  2452				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2452				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2452					      ENDIF
      0  2452					      VEND	aiMoveIsSelected
      1  2452
      2  2452
      3  2452		       00 b5	   VAREND_aiMoveIsSelected =	TEMPORARY_VAR
      4  2452
    125  2452
    126  2452							; Both computer and human have now seleted a move, and converge here
    127  2452
    128  2452
    129  2452							; fromPiece	 piece doing the move
    130  2452							; fromX12	 current square X12
    131  2452							; originX12	 starting square X12
    132  2452							; toX12	 ending square X12
    133  2452
    134  2452		       20 79 f8 	      jsr	EnPassantFixupDraw
    135  2455
    136  2455							; get the piece types from the board
    137  2455
    138  2455		       a9 d0		      lda	#RAMBANK_BOARD
    139  2457		       85 3e		      sta	SET_BANK_RAM	;@3
    140  2459		       a4 87		      ldy	originX12
    141  245b		       b9 79 fc 	      lda	Board,y
    142  245e		       85 b3		      sta	__originalPiece
    143  2460		       a4 86		      ldy	toX12
    144  2462		       b9 79 fc 	      lda	Board,y
    145  2465		       85 b4		      sta	__capturedPiece
    146  2467
    147  2467
    148  2467		       20 f1 f8 	      jsr	AdjustMaterialPositionalValue	;@this
    149  246a
    150  246a		       a9 00		      lda	#0
    151  246c		       85 98		      sta	previousPiece
    152  246e		       85 82		      sta	drawDelay
    153  2470
    154  2470		       a9 0a		      lda	#10	; on/off count
    155  2472		       85 84		      sta	drawCount	; flashing for piece about to move
    156  2474
      0  2474					      PHASE	WriteStartPieceBlank
      1  2474		       a9 15		      lda	#AI_WriteStartPieceBlank
      2  2476		       85 8b		      sta	aiState
    158  2478		       60	   .idleErase rts
    159  2479
    160  2479
    161  2479							;---------------------------------------------------------------------------------------------------
    162  2479
      0  2479					      DEF	EnPassantFixupDraw
      1  2479				   SLOT_EnPassantFixupDraw SET	_BANK_SLOT
      2  2479				   BANK_EnPassantFixupDraw SET	SLOT_EnPassantFixupDraw + _CURRENT_BANK
      3  2479				   EnPassantFixupDraw
      4  2479				   TEMPORARY_VAR SET	Overlay
      5  2479				   TEMPORARY_OFFSET SET	0
      6  2479				   VAR_BOUNDARY_EnPassantFixupDraw SET	TEMPORARY_OFFSET
      7  2479				   FUNCTION_NAME SET	EnPassantFixupDraw
    164  2479					      SUBROUTINE
    165  2479
    166  2479							; {
    167  2479							; With en-passant flag, it is essentially dual-use.
    168  2479							; First, it marks if the move is *involved* somehow in an en-passant
    169  2479							; if the piece has MOVED already, then it's an en-passant capture
    170  2479							; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
    171  2479
    172  2479		       a2 00		      ldx	#0	; (probably) NO en-passant this time
    173  247b		       a5 96		      lda	fromPiece
    174  247d		       a8		      tay
    175  247e
    176  247e		       29 60		      and	#FLAG_ENPASSANT|FLAG_MOVED
    177  2480		       c9 20		      cmp	#FLAG_ENPASSANT
    178  2482		       d0 13		      bne	.noep	; HAS moved, or not en-passant
    179  2484
    180  2484		       45 96		      eor	fromPiece	; clear FLAG_ENPASSANT
    181  2486		       85 96		      sta	fromPiece
    182  2488
    183  2488		       a6 86		      ldx	toX12	; this IS an en-passantable opening, so record the square
    184  248a		       86 93		      stx	enPassantPawn	; capturable square for en-passant move (or none)
    185  248c
    186  248c							; set the secondary piece movement info - this allows move/unmakemove to work for enpassant
    187  248c
    188  248c		       a9 00		      lda	#0
      0  248e					      sta@PLY	secondaryBlank
      1  248e		       8d ce fb 	      sta	[RAM]+secondaryBlank
      0  2491					      stx@PLY	secondarySquare
      1  2491		       8e cd fb 	      stx	[RAM]+secondarySquare
      0  2494					      sty@PLY	secondaryPiece
      1  2494		       8c cc fb 	      sty	[RAM]+secondaryPiece
    192  2497
    193  2497				   .noep
    194  2497							; }
    195  2497
    196  2497		       60		      rts
    197  2498
    198  2498							;---------------------------------------------------------------------------------------------------
    199  2498
      0  2498					      DEF	CopySetup
      1  2498				   SLOT_CopySetup SET	_BANK_SLOT
      2  2498				   BANK_CopySetup SET	SLOT_CopySetup + _CURRENT_BANK
      3  2498				   CopySetup
      4  2498				   TEMPORARY_VAR SET	Overlay
      5  2498				   TEMPORARY_OFFSET SET	0
      6  2498				   VAR_BOUNDARY_CopySetup SET	TEMPORARY_OFFSET
      7  2498				   FUNCTION_NAME SET	CopySetup
    201  2498					      SUBROUTINE
    202  2498
      0  2498					      REF	CopySinglePiece	;✅
      1  2498					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  2498				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  2498					      ENDIF
    204  2498
      0  2498					      VAR	__tmp, 1
      1  2498
      2  2498		       00 ef	   __tmp      =	TEMPORARY_VAR
      3  2498				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  2498
      5  2498				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  2498				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  2498				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  2498					      ENDIF
      9  2498				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  2498				  -	      LIST	ON
     11  2498				  -VNAME      SETSTR	__tmp
     12  2498				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  2498				  -	      ERR
     14  2498				  -	      ECHO	"Temporary Variable overlow!"
     15  2498					      ENDIF
     16  2498					      LIST	ON
      0  2498					      VAR	__shiftx, 1
      1  2498
      2  2498		       00 f0	   __shiftx   =	TEMPORARY_VAR
      3  2498				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  2498
      5  2498				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  2498				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  2498				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  2498					      ENDIF
      9  2498				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  2498				  -	      LIST	ON
     11  2498				  -VNAME      SETSTR	__shiftx
     12  2498				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  2498				  -	      ERR
     14  2498				  -	      ECHO	"Temporary Variable overlow!"
     15  2498					      ENDIF
     16  2498					      LIST	ON
      0  2498					      VAR	__pieceColour2, 1
      1  2498
      2  2498		       00 f1	   __pieceColour2 =	TEMPORARY_VAR
      3  2498				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  2498
      5  2498				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  2498				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  2498				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  2498					      ENDIF
      9  2498				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  2498				  -	      LIST	ON
     11  2498				  -VNAME      SETSTR	__pieceColour2
     12  2498				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  2498				  -	      ERR
     14  2498				  -	      ECHO	"Temporary Variable overlow!"
     15  2498					      ENDIF
     16  2498					      LIST	ON
    208  2498
      0  2498					      VEND	CopySetup
      1  2498
      2  2498
      3  2498		       00 f2	   VAREND_CopySetup =	TEMPORARY_VAR
      4  2498
    210  2498
    211  2498							; figure colouration of square
    212  2498
    213  2498		       a5 80		      lda	squareToDraw
    214  249a
    215  249a					      IF	DIAGNOSTICS
    216  249a							; Catch out-of-range piece square
    217  249a							; will not catch off left/right edge
    218  249a
    219  249a		       c9 64	   .fail      cmp	#100
    220  249c		       b0 fc		      bcs	.fail
    221  249e		       c9 16		      cmp	#22
    222  24a0		       90 f8		      bcc	.fail
    223  24a2					      ENDIF
    224  24a2
    225  24a2
    226  24a2		       a2 0a		      ldx	#10
    227  24a4		       38		      sec
    228  24a5		       e9 0a	   .sub10     sbc	#10
    229  24a7		       ca		      dex
    230  24a8		       b0 fb		      bcs	.sub10
    231  24aa		       69 08		      adc	#8
    232  24ac		       85 f0		      sta	__shiftx
    233  24ae					      IF	DIAGNOSTICS
    234  24ae		       c9 08	   .fail2     cmp	#8
    235  24b0		       b0 fc		      bcs	.fail2
    236  24b2		       e0 08		      cpx	#8
    237  24b4		       b0 f8		      bcs	.fail2
    238  24b6					      ENDIF
    239  24b6		       86 ef		      stx	__tmp
    240  24b8		       65 ef		      adc	__tmp
    241  24ba
    242  24ba
    243  24ba		       29 01		      and	#1
    244  24bc							;eor #1
    245  24bc		       f0 02		      beq	.white
    246  24be		       a9 24		      lda	#36
    247  24c0				   .white
    248  24c0		       85 f1		      sta	__pieceColour2	; actually SQUARE black/white
    249  24c2
    250  24c2							; PieceColour = 0 for white square, 36 for black square
    251  24c2
    252  24c2		       a9 d0		      lda	#RAMBANK_BOARD
    253  24c4		       85 3e		      sta	SET_BANK_RAM	;@3
    254  24c6
    255  24c6		       a4 80		      ldy	squareToDraw
    256  24c8		       b9 79 fc 	      lda	Board,y
    257  24cb							;and #$87
    258  24cb		       0a		      asl
    259  24cc		       90 02		      bcc	.blackAdjust
    260  24ce		       09 10		      ora	#16	; switch white pieces
    261  24d0		       4a	   .blackAdjust lsr
    262  24d1		       29 0f		      and	#%1111
    263  24d3		       aa		      tax
    264  24d4
    265  24d4		       a5 f0		      lda	__shiftx
    266  24d6		       29 03		      and	#3	; shift position in P
    267  24d8
    268  24d8		       18		      clc
    269  24d9		       7d e1 f8 	      adc	PieceToShape,x
    270  24dc		       18		      clc
    271  24dd		       65 f1		      adc	__pieceColour2
    272  24df		       a8		      tay
    273  24e0		       60		      rts
    274  24e1
    275  24e1				   PieceToShape
    276  24e1
    277  24e1		       00		      .byte.b	INDEX_WHITE_BLANK_on_WHITE_SQUARE_0
    278  24e2		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    279  24e3		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (black P)
    280  24e4		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    281  24e5		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    282  24e6		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    283  24e7		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    284  24e8		       18		      .byte.b	INDEX_WHITE_KING_on_WHITE_SQUARE_0
    285  24e9
    286  24e9		       48		      .byte.b	INDEX_BLACK_BLANK_on_WHITE_SQUARE_0
    287  24ea		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (white P)
    288  24eb		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    289  24ec		       50		      .byte.b	INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0
    290  24ed		       54		      .byte.b	INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0
    291  24ee		       58		      .byte.b	INDEX_BLACK_ROOK_on_WHITE_SQUARE_0
    292  24ef		       5c		      .byte.b	INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    293  24f0		       60		      .byte.b	INDEX_BLACK_KING_on_WHITE_SQUARE_0
    294  24f1
    295  24f1
    296  24f1							;---------------------------------------------------------------------------------------------------
    297  24f1
      0  24f1					      DEF	AdjustMaterialPositionalValue
      1  24f1				   SLOT_AdjustMaterialPositionalValue SET	_BANK_SLOT
      2  24f1				   BANK_AdjustMaterialPositionalValue SET	SLOT_AdjustMaterialPositionalValue + _CURRENT_BANK
      3  24f1				   AdjustMaterialPositionalValue
      4  24f1				   TEMPORARY_VAR SET	Overlay
      5  24f1				   TEMPORARY_OFFSET SET	0
      6  24f1				   VAR_BOUNDARY_AdjustMaterialPositionalValue SET	TEMPORARY_OFFSET
      7  24f1				   FUNCTION_NAME SET	AdjustMaterialPositionalValue
    299  24f1					      SUBROUTINE
    300  24f1
    301  24f1							; A move is about to be made, so  adjust material and positional values based on from/to and
    302  24f1							; capture.
    303  24f1
    304  24f1							; First, nominate referencing subroutines so that local variables can be adjusted properly
    305  24f1
      0  24f1					      REF	COMMON_VARS
      1  24f1					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  24f1				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  24f1					      ENDIF
      0  24f1					      REF	MakeMove	;✅
      1  24f1				  -	      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  24f1				  -TEMPORARY_VAR SET	VAREND_MakeMove
      3  24f1					      ENDIF
      0  24f1					      REF	aiMoveIsSelected	;✅
      1  24f1				  -	      IF	VAREND_aiMoveIsSelected > TEMPORARY_VAR
      2  24f1				  -TEMPORARY_VAR SET	VAREND_aiMoveIsSelected
      3  24f1					      ENDIF
      0  24f1					      VEND	AdjustMaterialPositionalValue
      1  24f1
      2  24f1
      3  24f1		       00 b5	   VAREND_AdjustMaterialPositionalValue =	TEMPORARY_VAR
      4  24f1
    310  24f1
    311  24f1							; fromPiece	 piece doing the move (promoted type)
    312  24f1							; fromX12	 current square
    313  24f1							; originX12	 starting square
    314  24f1							; toX12	 ending square
    315  24f1
    316  24f1
    317  24f1							; {
    318  24f1							;   adjust the positional value  (originX12 --> fromX12)
    319  24f1
    320  24f1		       a4 86		      ldy	toX12	; already loaded
    321  24f3		       a5 96		      lda	fromPiece
    322  24f5		       20 60 f9 	      jsr	AddPiecePositionValue	; add pos value for new position
    323  24f8
    324  24f8
    325  24f8		       a5 b3		      lda	__originalPiece
    326  24fa		       45 96		      eor	fromPiece	; the new piece
    327  24fc		       29 0f		      and	#PIECE_MASK
    328  24fe		       f0 05		      beq	.same1	; unchanged, so skip
    329  2500
    330  2500		       a5 96		      lda	fromPiece	; new piece
    331  2502		       20 3d f9 	      jsr	AddPieceMaterialValue
    332  2505
    333  2505				   .same1
    334  2505
    335  2505							; and now the 'subtracts'
    336  2505
      0  2505					      NEGEVAL
      1  2505
      2  2505		       38		      sec
      3  2506		       a9 00		      lda	#0
      4  2508		       e5 8f		      sbc	Evaluation
      5  250a		       85 8f		      sta	Evaluation
      6  250c		       a9 00		      lda	#0
      7  250e		       e5 90		      sbc	Evaluation+1
      8  2510		       85 90		      sta	Evaluation+1
      9  2512
    338  2512
    339  2512		       a4 87		      ldy	originX12
    340  2514		       a5 b3		      lda	__originalPiece
    341  2516		       20 60 f9 	      jsr	AddPiecePositionValue	; remove pos value for original position
    342  2519
    343  2519
    344  2519		       a5 b3		      lda	__originalPiece
    345  251b		       45 96		      eor	fromPiece	; the new piece
    346  251d		       29 0f		      and	#PIECE_MASK
    347  251f		       f0 05		      beq	.same2	; unchanged, so skip
    348  2521
    349  2521		       a5 b3		      lda	__originalPiece
    350  2523		       20 3d f9 	      jsr	AddPieceMaterialValue	; remove material for original type
    351  2526				   .same2
    352  2526
      0  2526					      NEGEVAL
      1  2526
      2  2526		       38		      sec
      3  2527		       a9 00		      lda	#0
      4  2529		       e5 8f		      sbc	Evaluation
      5  252b		       85 8f		      sta	Evaluation
      6  252d		       a9 00		      lda	#0
      7  252f		       e5 90		      sbc	Evaluation+1
      8  2531		       85 90		      sta	Evaluation+1
      9  2533
    354  2533
    355  2533							; If there's a capture, we adjust the material value
    356  2533
    357  2533							;		      lda __capturedPiece
    358  2533							;		      eor __originalPiece
    359  2533							;		      bpl .noCapture		      ; special-case capture rook castling onto king
    360  2533
    361  2533
    362  2533		       a5 b4		      lda	__capturedPiece
    363  2535		       29 0f		      and	#PIECE_MASK
    364  2537		       f0 03		      beq	.noCapture
    365  2539		       20 3d f9 	      jsr	AddPieceMaterialValue	; -other colour = + my colour!
    366  253c				   .noCapture
    367  253c
    368  253c							; }
    369  253c		       60		      rts
    370  253d
    371  253d
    372  253d							;---------------------------------------------------------------------------------------------------
    373  253d
      0  253d					      DEF	AddPieceMaterialValue
      1  253d				   SLOT_AddPieceMaterialValue SET	_BANK_SLOT
      2  253d				   BANK_AddPieceMaterialValue SET	SLOT_AddPieceMaterialValue + _CURRENT_BANK
      3  253d				   AddPieceMaterialValue
      4  253d				   TEMPORARY_VAR SET	Overlay
      5  253d				   TEMPORARY_OFFSET SET	0
      6  253d				   VAR_BOUNDARY_AddPieceMaterialValue SET	TEMPORARY_OFFSET
      7  253d				   FUNCTION_NAME SET	AddPieceMaterialValue
    375  253d					      SUBROUTINE
    376  253d
      0  253d					      REF	COMMON_VARS
      1  253d					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  253d				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  253d					      ENDIF
      0  253d					      REF	InitialisePieceSquares	;✅
      1  253d					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  253d				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  253d					      ENDIF
      0  253d					      REF	AdjustMaterialPositionalValue	;✅
      1  253d				  -	      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  253d				  -TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  253d					      ENDIF
    380  253d							;REF EnPassantRemovePiece ;✅
      0  253d					      VEND	AddPieceMaterialValue
      1  253d
      2  253d
      3  253d		       00 b9	   VAREND_AddPieceMaterialValue =	TEMPORARY_VAR
      4  253d
    382  253d
    383  253d							; Adjust the material score based on the piece
    384  253d							; a = piece type + flags
    385  253d
    386  253d		       29 0f		      and	#PIECE_MASK
    387  253f		       a8		      tay
    388  2540
    389  2540		       18		      clc
    390  2541		       b9 50 f9 	      lda	PieceValueLO,y
    391  2544		       65 8f		      adc	Evaluation
    392  2546		       85 8f		      sta	Evaluation
    393  2548		       b9 58 f9 	      lda	PieceValueHI,y
    394  254b		       65 90		      adc	Evaluation+1
    395  254d		       85 90		      sta	Evaluation+1
    396  254f		       60		      rts
    397  2550
    398  2550
    399  2550					      MAC	valuetable
    400  2550					      .byte	{1}0	; blank
    401  2550					      .byte	{1}100	; white P
    402  2550					      .byte	{1}100	; black P
    403  2550					      .byte	{1}320	; N
    404  2550					      .byte	{1}375	; B
    405  2550					      .byte	{1}575	; R
    406  2550					      .byte	{1}900	; Q
    407  2550					      .byte	{1}10000	; K
    408  2550					      ENDM
    409  2550
    410  2550				   PieceValueLO
      0  2550					      VALUETABLE	<
      1  2550		       00		      .byte.b	<0
      2  2551		       64		      .byte.b	<100
      3  2552		       64		      .byte.b	<100
      4  2553		       40		      .byte.b	<320
      5  2554		       77		      .byte.b	<375
      6  2555		       3f		      .byte.b	<575
      7  2556		       84		      .byte.b	<900
      8  2557		       10		      .byte.b	<10000
    412  2558
    413  2558				   PieceValueHI
      0  2558					      VALUETABLE	>
      1  2558		       00		      .byte.b	>0
      2  2559		       00		      .byte.b	>100
      3  255a		       00		      .byte.b	>100
      4  255b		       01		      .byte.b	>320
      5  255c		       01		      .byte.b	>375
      6  255d		       02		      .byte.b	>575
      7  255e		       03		      .byte.b	>900
      8  255f		       27		      .byte.b	>10000
    415  2560
    416  2560
    417  2560							;---------------------------------------------------------------------------------------------------
    418  2560
      0  2560					      DEF	AddPiecePositionValue
      1  2560				   SLOT_AddPiecePositionValue SET	_BANK_SLOT
      2  2560				   BANK_AddPiecePositionValue SET	SLOT_AddPiecePositionValue + _CURRENT_BANK
      3  2560				   AddPiecePositionValue
      4  2560				   TEMPORARY_VAR SET	Overlay
      5  2560				   TEMPORARY_OFFSET SET	0
      6  2560				   VAR_BOUNDARY_AddPiecePositionValue SET	TEMPORARY_OFFSET
      7  2560				   FUNCTION_NAME SET	AddPiecePositionValue
    420  2560					      SUBROUTINE
    421  2560
      0  2560					      REF	InitialisePieceSquares	;✅
      1  2560					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  2560				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  2560					      ENDIF
      0  2560					      REF	AdjustMaterialPositionalValue	;✅
      1  2560				  -	      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  2560				  -TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  2560					      ENDIF
    424  2560							;REF EnPassantRemovePiece ;✅
      0  2560					      VAR	__valPtr, 2
      1  2560
      2  2560		       00 b9	   __valPtr   =	TEMPORARY_VAR
      3  2560				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      4  2560
      5  2560				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  2560				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  2560				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  2560					      ENDIF
      9  2560				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  2560				  -	      LIST	ON
     11  2560				  -VNAME      SETSTR	__valPtr
     12  2560				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  2560				  -	      ERR
     14  2560				  -	      ECHO	"Temporary Variable overlow!"
     15  2560					      ENDIF
     16  2560					      LIST	ON
      0  2560					      VEND	AddPiecePositionValue
      1  2560
      2  2560
      3  2560		       00 bb	   VAREND_AddPiecePositionValue =	TEMPORARY_VAR
      4  2560
    427  2560
    428  2560
    429  2560							; adds value of square piece is on to the evaluation
    430  2560							; note to do the subtraction as -( -x + val) == x - val
    431  2560
    432  2560							; y = square
    433  2560							; a = piece type (+flags)
    434  2560
    435  2560
    436  2560
    437  2560		       c9 80		      cmp	#128	; black = CS
    438  2562		       29 0f		      and	#PIECE_MASK
    439  2564		       aa		      tax
    440  2565
    441  2565		       a9 da		      lda	#ROMBANK_EVALUATE
    442  2567		       85 3f		      sta	SET_BANK	;@3
    443  2569
    444  2569							; black pieces flip rows so we can use the same eval tables
    445  2569
    446  2569		       98		      tya
    447  256a		       90 03		      bcc	.white
    448  256c		       b9 8d f9 	      lda	FlipSquareIndex,y
    449  256f							;clc
    450  256f				   .white
    451  256f		       7d 00 fc 	      adc	PosValVecLO,x
    452  2572		       85 b9		      sta	__valPtr
    453  2574		       bd 08 fc 	      lda	PosValVecHI,x
    454  2577		       69 00		      adc	#0
    455  2579		       85 ba		      sta	__valPtr+1
    456  257b
    457  257b		       a0 00		      ldy	#0
    458  257d		       b1 b9		      lda	(__valPtr),y
    459  257f		       10 01		      bpl	.sum
    460  2581		       88		      dey
    461  2582
    462  2582		       18	   .sum       clc
    463  2583		       65 8f		      adc	Evaluation
    464  2585		       85 8f		      sta	Evaluation
    465  2587		       98		      tya
    466  2588		       65 90		      adc	Evaluation+1
    467  258a		       85 90		      sta	Evaluation+1
    468  258c		       60		      rts
    469  258d
    470  258d
    471  258d				   FlipSquareIndex
    472  258d
    473  258d		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    474  2597		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    475  25a1
    476  25a1				   .SQBASE    SET	90-1
    477  25a1					      REPEAT	8
    478  25a1		       00 00		      .byte.b	0,0
    479  25a1				   .SQX       SET	2
    480  25a3					      REPEAT	8
    481  25a3		       5b		      .byte.b	(.SQBASE+.SQX)
    482  25a3				   .SQX       SET	.SQX + 1
    480  25a3					      REPEND
    481  25a4		       5c		      .byte.b	(.SQBASE+.SQX)
    482  25a4				   .SQX       SET	.SQX + 1
    480  25a4					      REPEND
    481  25a5		       5d		      .byte.b	(.SQBASE+.SQX)
    482  25a5				   .SQX       SET	.SQX + 1
    480  25a5					      REPEND
    481  25a6		       5e		      .byte.b	(.SQBASE+.SQX)
    482  25a6				   .SQX       SET	.SQX + 1
    480  25a6					      REPEND
    481  25a7		       5f		      .byte.b	(.SQBASE+.SQX)
    482  25a7				   .SQX       SET	.SQX + 1
    480  25a7					      REPEND
    481  25a8		       60		      .byte.b	(.SQBASE+.SQX)
    482  25a8				   .SQX       SET	.SQX + 1
    480  25a8					      REPEND
    481  25a9		       61		      .byte.b	(.SQBASE+.SQX)
    482  25a9				   .SQX       SET	.SQX + 1
    480  25a9					      REPEND
    481  25aa		       62		      .byte.b	(.SQBASE+.SQX)
    482  25aa				   .SQX       SET	.SQX + 1
    483  25ab					      REPEND
    484  25ab				   .SQBASE    SET	.SQBASE - 10
    477  25ab					      REPEND
    478  25ab		       00 00		      .byte.b	0,0
    479  25ab				   .SQX       SET	2
    480  25ad					      REPEAT	8
    481  25ad		       51		      .byte.b	(.SQBASE+.SQX)
    482  25ad				   .SQX       SET	.SQX + 1
    480  25ad					      REPEND
    481  25ae		       52		      .byte.b	(.SQBASE+.SQX)
    482  25ae				   .SQX       SET	.SQX + 1
    480  25ae					      REPEND
    481  25af		       53		      .byte.b	(.SQBASE+.SQX)
    482  25af				   .SQX       SET	.SQX + 1
    480  25af					      REPEND
    481  25b0		       54		      .byte.b	(.SQBASE+.SQX)
    482  25b0				   .SQX       SET	.SQX + 1
    480  25b0					      REPEND
    481  25b1		       55		      .byte.b	(.SQBASE+.SQX)
    482  25b1				   .SQX       SET	.SQX + 1
    480  25b1					      REPEND
    481  25b2		       56		      .byte.b	(.SQBASE+.SQX)
    482  25b2				   .SQX       SET	.SQX + 1
    480  25b2					      REPEND
    481  25b3		       57		      .byte.b	(.SQBASE+.SQX)
    482  25b3				   .SQX       SET	.SQX + 1
    480  25b3					      REPEND
    481  25b4		       58		      .byte.b	(.SQBASE+.SQX)
    482  25b4				   .SQX       SET	.SQX + 1
    483  25b5					      REPEND
    484  25b5				   .SQBASE    SET	.SQBASE - 10
    477  25b5					      REPEND
    478  25b5		       00 00		      .byte.b	0,0
    479  25b5				   .SQX       SET	2
    480  25b7					      REPEAT	8
    481  25b7		       47		      .byte.b	(.SQBASE+.SQX)
    482  25b7				   .SQX       SET	.SQX + 1
    480  25b7					      REPEND
    481  25b8		       48		      .byte.b	(.SQBASE+.SQX)
    482  25b8				   .SQX       SET	.SQX + 1
    480  25b8					      REPEND
    481  25b9		       49		      .byte.b	(.SQBASE+.SQX)
    482  25b9				   .SQX       SET	.SQX + 1
    480  25b9					      REPEND
    481  25ba		       4a		      .byte.b	(.SQBASE+.SQX)
    482  25ba				   .SQX       SET	.SQX + 1
    480  25ba					      REPEND
    481  25bb		       4b		      .byte.b	(.SQBASE+.SQX)
    482  25bb				   .SQX       SET	.SQX + 1
    480  25bb					      REPEND
    481  25bc		       4c		      .byte.b	(.SQBASE+.SQX)
    482  25bc				   .SQX       SET	.SQX + 1
    480  25bc					      REPEND
    481  25bd		       4d		      .byte.b	(.SQBASE+.SQX)
    482  25bd				   .SQX       SET	.SQX + 1
    480  25bd					      REPEND
    481  25be		       4e		      .byte.b	(.SQBASE+.SQX)
    482  25be				   .SQX       SET	.SQX + 1
    483  25bf					      REPEND
    484  25bf				   .SQBASE    SET	.SQBASE - 10
    477  25bf					      REPEND
    478  25bf		       00 00		      .byte.b	0,0
    479  25bf				   .SQX       SET	2
    480  25c1					      REPEAT	8
    481  25c1		       3d		      .byte.b	(.SQBASE+.SQX)
    482  25c1				   .SQX       SET	.SQX + 1
    480  25c1					      REPEND
    481  25c2		       3e		      .byte.b	(.SQBASE+.SQX)
    482  25c2				   .SQX       SET	.SQX + 1
    480  25c2					      REPEND
    481  25c3		       3f		      .byte.b	(.SQBASE+.SQX)
    482  25c3				   .SQX       SET	.SQX + 1
    480  25c3					      REPEND
    481  25c4		       40		      .byte.b	(.SQBASE+.SQX)
    482  25c4				   .SQX       SET	.SQX + 1
    480  25c4					      REPEND
    481  25c5		       41		      .byte.b	(.SQBASE+.SQX)
    482  25c5				   .SQX       SET	.SQX + 1
    480  25c5					      REPEND
    481  25c6		       42		      .byte.b	(.SQBASE+.SQX)
    482  25c6				   .SQX       SET	.SQX + 1
    480  25c6					      REPEND
    481  25c7		       43		      .byte.b	(.SQBASE+.SQX)
    482  25c7				   .SQX       SET	.SQX + 1
    480  25c7					      REPEND
    481  25c8		       44		      .byte.b	(.SQBASE+.SQX)
    482  25c8				   .SQX       SET	.SQX + 1
    483  25c9					      REPEND
    484  25c9				   .SQBASE    SET	.SQBASE - 10
    477  25c9					      REPEND
    478  25c9		       00 00		      .byte.b	0,0
    479  25c9				   .SQX       SET	2
    480  25cb					      REPEAT	8
    481  25cb		       33		      .byte.b	(.SQBASE+.SQX)
    482  25cb				   .SQX       SET	.SQX + 1
    480  25cb					      REPEND
    481  25cc		       34		      .byte.b	(.SQBASE+.SQX)
    482  25cc				   .SQX       SET	.SQX + 1
    480  25cc					      REPEND
    481  25cd		       35		      .byte.b	(.SQBASE+.SQX)
    482  25cd				   .SQX       SET	.SQX + 1
    480  25cd					      REPEND
    481  25ce		       36		      .byte.b	(.SQBASE+.SQX)
    482  25ce				   .SQX       SET	.SQX + 1
    480  25ce					      REPEND
    481  25cf		       37		      .byte.b	(.SQBASE+.SQX)
    482  25cf				   .SQX       SET	.SQX + 1
    480  25cf					      REPEND
    481  25d0		       38		      .byte.b	(.SQBASE+.SQX)
    482  25d0				   .SQX       SET	.SQX + 1
    480  25d0					      REPEND
    481  25d1		       39		      .byte.b	(.SQBASE+.SQX)
    482  25d1				   .SQX       SET	.SQX + 1
    480  25d1					      REPEND
    481  25d2		       3a		      .byte.b	(.SQBASE+.SQX)
    482  25d2				   .SQX       SET	.SQX + 1
    483  25d3					      REPEND
    484  25d3				   .SQBASE    SET	.SQBASE - 10
    477  25d3					      REPEND
    478  25d3		       00 00		      .byte.b	0,0
    479  25d3				   .SQX       SET	2
    480  25d5					      REPEAT	8
    481  25d5		       29		      .byte.b	(.SQBASE+.SQX)
    482  25d5				   .SQX       SET	.SQX + 1
    480  25d5					      REPEND
    481  25d6		       2a		      .byte.b	(.SQBASE+.SQX)
    482  25d6				   .SQX       SET	.SQX + 1
    480  25d6					      REPEND
    481  25d7		       2b		      .byte.b	(.SQBASE+.SQX)
    482  25d7				   .SQX       SET	.SQX + 1
    480  25d7					      REPEND
    481  25d8		       2c		      .byte.b	(.SQBASE+.SQX)
    482  25d8				   .SQX       SET	.SQX + 1
    480  25d8					      REPEND
    481  25d9		       2d		      .byte.b	(.SQBASE+.SQX)
    482  25d9				   .SQX       SET	.SQX + 1
    480  25d9					      REPEND
    481  25da		       2e		      .byte.b	(.SQBASE+.SQX)
    482  25da				   .SQX       SET	.SQX + 1
    480  25da					      REPEND
    481  25db		       2f		      .byte.b	(.SQBASE+.SQX)
    482  25db				   .SQX       SET	.SQX + 1
    480  25db					      REPEND
    481  25dc		       30		      .byte.b	(.SQBASE+.SQX)
    482  25dc				   .SQX       SET	.SQX + 1
    483  25dd					      REPEND
    484  25dd				   .SQBASE    SET	.SQBASE - 10
    477  25dd					      REPEND
    478  25dd		       00 00		      .byte.b	0,0
    479  25dd				   .SQX       SET	2
    480  25df					      REPEAT	8
    481  25df		       1f		      .byte.b	(.SQBASE+.SQX)
    482  25df				   .SQX       SET	.SQX + 1
    480  25df					      REPEND
    481  25e0		       20		      .byte.b	(.SQBASE+.SQX)
    482  25e0				   .SQX       SET	.SQX + 1
    480  25e0					      REPEND
    481  25e1		       21		      .byte.b	(.SQBASE+.SQX)
    482  25e1				   .SQX       SET	.SQX + 1
    480  25e1					      REPEND
    481  25e2		       22		      .byte.b	(.SQBASE+.SQX)
    482  25e2				   .SQX       SET	.SQX + 1
    480  25e2					      REPEND
    481  25e3		       23		      .byte.b	(.SQBASE+.SQX)
    482  25e3				   .SQX       SET	.SQX + 1
    480  25e3					      REPEND
    481  25e4		       24		      .byte.b	(.SQBASE+.SQX)
    482  25e4				   .SQX       SET	.SQX + 1
    480  25e4					      REPEND
    481  25e5		       25		      .byte.b	(.SQBASE+.SQX)
    482  25e5				   .SQX       SET	.SQX + 1
    480  25e5					      REPEND
    481  25e6		       26		      .byte.b	(.SQBASE+.SQX)
    482  25e6				   .SQX       SET	.SQX + 1
    483  25e7					      REPEND
    484  25e7				   .SQBASE    SET	.SQBASE - 10
    477  25e7					      REPEND
    478  25e7		       00 00		      .byte.b	0,0
    479  25e7				   .SQX       SET	2
    480  25e9					      REPEAT	8
    481  25e9		       15		      .byte.b	(.SQBASE+.SQX)
    482  25e9				   .SQX       SET	.SQX + 1
    480  25e9					      REPEND
    481  25ea		       16		      .byte.b	(.SQBASE+.SQX)
    482  25ea				   .SQX       SET	.SQX + 1
    480  25ea					      REPEND
    481  25eb		       17		      .byte.b	(.SQBASE+.SQX)
    482  25eb				   .SQX       SET	.SQX + 1
    480  25eb					      REPEND
    481  25ec		       18		      .byte.b	(.SQBASE+.SQX)
    482  25ec				   .SQX       SET	.SQX + 1
    480  25ec					      REPEND
    481  25ed		       19		      .byte.b	(.SQBASE+.SQX)
    482  25ed				   .SQX       SET	.SQX + 1
    480  25ed					      REPEND
    481  25ee		       1a		      .byte.b	(.SQBASE+.SQX)
    482  25ee				   .SQX       SET	.SQX + 1
    480  25ee					      REPEND
    481  25ef		       1b		      .byte.b	(.SQBASE+.SQX)
    482  25ef				   .SQX       SET	.SQX + 1
    480  25ef					      REPEND
    481  25f0		       1c		      .byte.b	(.SQBASE+.SQX)
    482  25f0				   .SQX       SET	.SQX + 1
    483  25f1					      REPEND
    484  25f1				   .SQBASE    SET	.SQBASE - 10
    485  25f1					      REPEND
    486  25f1
    487  25f1
    488  25f1							;---------------------------------------------------------------------------------------------------
    489  25f1
------- FILE piece_vectors.asm LEVEL 3 PASS 4
      0  25f1					      include	"piece_vectors.asm"
      1  25f1							; Created by ConvertChessPieces.py
      0  25f1					      DEF	PIECE_VECTOR_LO
      1  25f1				   SLOT_PIECE_VECTOR_LO SET	_BANK_SLOT
      2  25f1				   BANK_PIECE_VECTOR_LO SET	SLOT_PIECE_VECTOR_LO + _CURRENT_BANK
      3  25f1				   PIECE_VECTOR_LO
      4  25f1				   TEMPORARY_VAR SET	Overlay
      5  25f1				   TEMPORARY_OFFSET SET	0
      6  25f1				   VAR_BOUNDARY_PIECE_VECTOR_LO SET	TEMPORARY_OFFSET
      7  25f1				   FUNCTION_NAME SET	PIECE_VECTOR_LO
      3  25f1		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_0
      4  25f2		       48		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_1
      5  25f3		       90		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_2
      6  25f4		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_3
      7  25f5		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_0
      8  25f6		       90		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_1
      9  25f7		       00		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_2
     10  25f8		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_3
     11  25f9		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_0
     12  25fa		       00		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_1
     13  25fb		       48		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_2
     14  25fc		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_3
     15  25fd		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_0
     16  25fe		       48		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_1
     17  25ff		       90		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_2
     18  2600		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_3
     19  2601		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_0
     20  2602		       90		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_1
     21  2603		       00		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_2
     22  2604		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_3
     23  2605		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_0
     24  2606		       00		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_1
     25  2607		       48		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_2
     26  2608		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_3
     27  2609		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_0
     28  260a		       48		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_1
     29  260b		       90		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_2
     30  260c		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_3
     31  260d		       00		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_0
     32  260e		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_1
     33  260f		       90		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_2
     34  2610		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_3
     35  2611		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_0
     36  2612		       00		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_1
     37  2613		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_2
     38  2614		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_3
     39  2615		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_0
     40  2616		       90		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_1
     41  2617		       00		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_2
     42  2618		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_3
     43  2619		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_0
     44  261a		       00		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_1
     45  261b		       48		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_2
     46  261c		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_3
     47  261d		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_0
     48  261e		       48		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_1
     49  261f		       90		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_2
     50  2620		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_3
     51  2621		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_0
     52  2622		       90		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_1
     53  2623		       00		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_2
     54  2624		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_3
     55  2625		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_0
     56  2626		       00		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_1
     57  2627		       48		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_2
     58  2628		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_3
     59  2629		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_0
     60  262a		       48		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_1
     61  262b		       90		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_2
     62  262c		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_3
     63  262d		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_0
     64  262e		       90		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_1
     65  262f		       00		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_2
     66  2630		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_3
     67  2631		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_0
     68  2632		       00		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_1
     69  2633		       48		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_2
     70  2634		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_3
     71  2635		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_0
     72  2636		       90		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_1
     73  2637		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_2
     74  2638		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_3
     75  2639		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_0
     76  263a		       00		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_1
     77  263b		       48		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_2
     78  263c		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_3
     79  263d		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_0
     80  263e		       48		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_1
     81  263f		       90		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_2
     82  2640		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_3
     83  2641		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_0
     84  2642		       90		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_1
     85  2643		       00		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_2
     86  2644		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_3
     87  2645		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_0
     88  2646		       00		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_1
     89  2647		       48		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_2
     90  2648		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_3
     91  2649		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_0
     92  264a		       48		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_1
     93  264b		       90		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_2
     94  264c		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_3
     95  264d		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_0
     96  264e		       90		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_1
     97  264f		       00		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_2
     98  2650		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_3
     99  2651		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_0
    100  2652		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_1
    101  2653		       48		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_2
    102  2654		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_3
    103  2655		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_0
    104  2656		       48		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_1
    105  2657		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_2
    106  2658		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_3
    107  2659		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_0
    108  265a		       90		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_1
    109  265b		       00		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_2
    110  265c		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_3
    111  265d		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_0
    112  265e		       90		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_1
    113  265f		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_2
    114  2660		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_3
    115  2661		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_0
    116  2662		       00		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_1
    117  2663		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_2
    118  2664		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_3
    119  2665		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_0
    120  2666		       48		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_1
    121  2667		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_2
    122  2668		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_3
    123  2669		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_0
    124  266a		       48		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_1
    125  266b		       90		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_2
    126  266c		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_3
    127  266d		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_0
    128  266e		       90		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_1
    129  266f		       00		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_2
    130  2670		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_3
    131  2671		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_0
    132  2672		       00		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_1
    133  2673		       48		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_2
    134  2674		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_3
    135  2675		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_0
    136  2676		       48		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_1
    137  2677		       90		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_2
    138  2678		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_3
    139  2679		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_0
    140  267a		       00		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_1
    141  267b		       48		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_2
    142  267c		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_3
    143  267d		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_0
    144  267e		       48		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_1
    145  267f		       90		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_2
    146  2680		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  2681					      DEF	PIECE_VECTOR_HI
      1  2681				   SLOT_PIECE_VECTOR_HI SET	_BANK_SLOT
      2  2681				   BANK_PIECE_VECTOR_HI SET	SLOT_PIECE_VECTOR_HI + _CURRENT_BANK
      3  2681				   PIECE_VECTOR_HI
      4  2681				   TEMPORARY_VAR SET	Overlay
      5  2681				   TEMPORARY_OFFSET SET	0
      6  2681				   VAR_BOUNDARY_PIECE_VECTOR_HI SET	TEMPORARY_OFFSET
      7  2681				   FUNCTION_NAME SET	PIECE_VECTOR_HI
    148  2681		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_0
    149  2682		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_1
    150  2683		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_2
    151  2684		       f9		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_3
    152  2685		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_0
    153  2686		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_1
    154  2687		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_2
    155  2688		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_3
    156  2689		       fa		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_0
    157  268a		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_1
    158  268b		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_2
    159  268c		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_3
    160  268d		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_0
    161  268e		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_1
    162  268f		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_2
    163  2690		       f9		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_3
    164  2691		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_0
    165  2692		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_1
    166  2693		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_2
    167  2694		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_3
    168  2695		       fa		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_0
    169  2696		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_1
    170  2697		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_2
    171  2698		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_3
    172  2699		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_0
    173  269a		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_1
    174  269b		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_2
    175  269c		       f9		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_3
    176  269d		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_0
    177  269e		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_1
    178  269f		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_2
    179  26a0		       fa		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_3
    180  26a1		       fa		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_0
    181  26a2		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_1
    182  26a3		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_2
    183  26a4		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_3
    184  26a5		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_0
    185  26a6		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_1
    186  26a7		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_2
    187  26a8		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_3
    188  26a9		       fa		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_0
    189  26aa		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_1
    190  26ab		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_2
    191  26ac		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_3
    192  26ad		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_0
    193  26ae		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_1
    194  26af		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_2
    195  26b0		       f9		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_3
    196  26b1		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_0
    197  26b2		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_1
    198  26b3		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_2
    199  26b4		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_3
    200  26b5		       fa		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_0
    201  26b6		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_1
    202  26b7		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_2
    203  26b8		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_3
    204  26b9		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_0
    205  26ba		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_1
    206  26bb		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_2
    207  26bc		       f9		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_3
    208  26bd		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_0
    209  26be		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_1
    210  26bf		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_2
    211  26c0		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_3
    212  26c1		       fa		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_0
    213  26c2		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_1
    214  26c3		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_2
    215  26c4		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_3
    216  26c5		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_0
    217  26c6		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_1
    218  26c7		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_2
    219  26c8		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_3
    220  26c9		       fa		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_0
    221  26ca		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_1
    222  26cb		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_2
    223  26cc		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_3
    224  26cd		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_0
    225  26ce		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_1
    226  26cf		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_2
    227  26d0		       f9		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_3
    228  26d1		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_0
    229  26d2		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_1
    230  26d3		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_2
    231  26d4		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_3
    232  26d5		       fa		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_0
    233  26d6		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_1
    234  26d7		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_2
    235  26d8		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_3
    236  26d9		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_0
    237  26da		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_1
    238  26db		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_2
    239  26dc		       f9		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_3
    240  26dd		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_0
    241  26de		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_1
    242  26df		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_2
    243  26e0		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_3
    244  26e1		       fa		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_0
    245  26e2		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_1
    246  26e3		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_2
    247  26e4		       f8		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_3
    248  26e5		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_0
    249  26e6		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_1
    250  26e7		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_2
    251  26e8		       f9		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_3
    252  26e9		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_0
    253  26ea		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_1
    254  26eb		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_2
    255  26ec		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_3
    256  26ed		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_0
    257  26ee		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_1
    258  26ef		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_2
    259  26f0		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_3
    260  26f1		       f9		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_0
    261  26f2		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_1
    262  26f3		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_2
    263  26f4		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_3
    264  26f5		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_0
    265  26f6		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_1
    266  26f7		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_2
    267  26f8		       f8		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_3
    268  26f9		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_0
    269  26fa		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_1
    270  26fb		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_2
    271  26fc		       fa		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_3
    272  26fd		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_0
    273  26fe		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_1
    274  26ff		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_2
    275  2700		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_3
    276  2701		       fb		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_0
    277  2702		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_1
    278  2703		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_2
    279  2704		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_3
    280  2705		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_0
    281  2706		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_1
    282  2707		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_2
    283  2708		       fa		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_3
    284  2709		       fa		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_0
    285  270a		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_1
    286  270b		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_2
    287  270c		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_3
    288  270d		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_0
    289  270e		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_1
    290  270f		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_2
    291  2710		       f9		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  2711					      DEF	PIECE_VECTOR_BANK
      1  2711				   SLOT_PIECE_VECTOR_BANK SET	_BANK_SLOT
      2  2711				   BANK_PIECE_VECTOR_BANK SET	SLOT_PIECE_VECTOR_BANK + _CURRENT_BANK
      3  2711				   PIECE_VECTOR_BANK
      4  2711				   TEMPORARY_VAR SET	Overlay
      5  2711				   TEMPORARY_OFFSET SET	0
      6  2711				   VAR_BOUNDARY_PIECE_VECTOR_BANK SET	TEMPORARY_OFFSET
      7  2711				   FUNCTION_NAME SET	PIECE_VECTOR_BANK
    293  2711		       8f		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_0
    294  2712		       8f		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_1
    295  2713		       8f		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_2
    296  2714		       8f		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_3
    297  2715		       8f		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_0
    298  2716		       8f		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_1
    299  2717		       8f		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_2
    300  2718		       8f		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_3
    301  2719		       8f		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0
    302  271a		       8f		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1
    303  271b		       8f		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2
    304  271c		       8f		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3
    305  271d		       90		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_0
    306  271e		       90		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_1
    307  271f		       90		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_2
    308  2720		       90		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_3
    309  2721		       90		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_0
    310  2722		       90		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_1
    311  2723		       90		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_2
    312  2724		       90		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_3
    313  2725		       90		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_0
    314  2726		       90		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_1
    315  2727		       90		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_2
    316  2728		       90		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_3
    317  2729		       91		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_0
    318  272a		       91		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_1
    319  272b		       91		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_2
    320  272c		       91		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_3
    321  272d		       8c		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_0
    322  272e		       8c		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_1
    323  272f		       8c		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_2
    324  2730		       8d		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_3
    325  2731		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0
    326  2732		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1
    327  2733		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2
    328  2734		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3
    329  2735		       91		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_0
    330  2736		       91		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_1
    331  2737		       91		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_2
    332  2738		       91		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_3
    333  2739		       91		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_0
    334  273a		       91		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_1
    335  273b		       91		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_2
    336  273c		       91		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_3
    337  273d		       92		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0
    338  273e		       92		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1
    339  273f		       92		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2
    340  2740		       92		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3
    341  2741		       92		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_0
    342  2742		       92		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_1
    343  2743		       92		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_2
    344  2744		       92		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_3
    345  2745		       92		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_0
    346  2746		       92		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_1
    347  2747		       92		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_2
    348  2748		       92		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_3
    349  2749		       93		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_0
    350  274a		       93		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_1
    351  274b		       93		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_2
    352  274c		       93		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_3
    353  274d		       93		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_0
    354  274e		       93		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_1
    355  274f		       93		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_2
    356  2750		       93		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_3
    357  2751		       8b		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_0
    358  2752		       8b		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_1
    359  2753		       8b		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_2
    360  2754		       8b		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_3
    361  2755		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0
    362  2756		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1
    363  2757		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2
    364  2758		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3
    365  2759		       93		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_0
    366  275a		       93		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_1
    367  275b		       93		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_2
    368  275c		       93		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_3
    369  275d		       94		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_0
    370  275e		       94		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_1
    371  275f		       94		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_2
    372  2760		       94		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_3
    373  2761		       94		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0
    374  2762		       94		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1
    375  2763		       94		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2
    376  2764		       94		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3
    377  2765		       94		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_0
    378  2766		       94		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_1
    379  2767		       94		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_2
    380  2768		       94		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_3
    381  2769		       95		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_0
    382  276a		       95		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_1
    383  276b		       95		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_2
    384  276c		       95		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_3
    385  276d		       95		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_0
    386  276e		       95		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_1
    387  276f		       95		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_2
    388  2770		       95		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_3
    389  2771		       95		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_0
    390  2772		       95		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_1
    391  2773		       95		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_2
    392  2774		       96		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_3
    393  2775		       8e		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_0
    394  2776		       8e		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_1
    395  2777		       8e		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_2
    396  2778		       8e		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_3
    397  2779		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0
    398  277a		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1
    399  277b		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2
    400  277c		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3
    401  277d		       96		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_0
    402  277e		       96		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_1
    403  277f		       96		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_2
    404  2780		       96		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_3
    405  2781		       96		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_0
    406  2782		       96		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_1
    407  2783		       96		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_2
    408  2784		       96		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_3
    409  2785		       96		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0
    410  2786		       96		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1
    411  2787		       96		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2
    412  2788		       97		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3
    413  2789		       8c		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_0
    414  278a		       8c		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_1
    415  278b		       8c		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_2
    416  278c		       8c		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_3
    417  278d		       8c		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_0
    418  278e		       8c		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_1
    419  278f		       8c		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_2
    420  2790		       8c		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_3
    421  2791		       8c		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_0
    422  2792		       8d		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_1
    423  2793		       8d		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_2
    424  2794		       8d		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_3
    425  2795		       8d		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_0
    426  2796		       8d		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_1
    427  2797		       8d		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_2
    428  2798		       8d		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_3
    429  2799		       8d		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_0
    430  279a		       8d		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_1
    431  279b		       8d		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_2
    432  279c		       8d		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_3
    433  279d		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0
    434  279e		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1
    435  279f		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2
    436  27a0		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3
    437  27a1
    438  27a1							; piece index equates...
    439  27a1		       00 00	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_0 =	0
    440  27a1		       00 01	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_1 =	1
    441  27a1		       00 02	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_2 =	2
    442  27a1		       00 03	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_3 =	3
    443  27a1		       00 04	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_0 =	4
    444  27a1		       00 05	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_1 =	5
    445  27a1		       00 06	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_2 =	6
    446  27a1		       00 07	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_3 =	7
    447  27a1		       00 08	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0 =	8
    448  27a1		       00 09	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_1 =	9
    449  27a1		       00 0a	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_2 =	10
    450  27a1		       00 0b	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_3 =	11
    451  27a1		       00 0c	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0 =	12
    452  27a1		       00 0d	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_1 =	13
    453  27a1		       00 0e	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_2 =	14
    454  27a1		       00 0f	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_3 =	15
    455  27a1		       00 10	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_0 =	16
    456  27a1		       00 11	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_1 =	17
    457  27a1		       00 12	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_2 =	18
    458  27a1		       00 13	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_3 =	19
    459  27a1		       00 14	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0 =	20
    460  27a1		       00 15	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_1 =	21
    461  27a1		       00 16	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_2 =	22
    462  27a1		       00 17	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_3 =	23
    463  27a1		       00 18	   INDEX_WHITE_KING_on_WHITE_SQUARE_0 =	24
    464  27a1		       00 19	   INDEX_WHITE_KING_on_WHITE_SQUARE_1 =	25
    465  27a1		       00 1a	   INDEX_WHITE_KING_on_WHITE_SQUARE_2 =	26
    466  27a1		       00 1b	   INDEX_WHITE_KING_on_WHITE_SQUARE_3 =	27
    467  27a1		       00 1c	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_0 =	28
    468  27a1		       00 1d	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_1 =	29
    469  27a1		       00 1e	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_2 =	30
    470  27a1		       00 1f	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_3 =	31
    471  27a1		       00 20	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0 =	32
    472  27a1		       00 21	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_1 =	33
    473  27a1		       00 22	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_2 =	34
    474  27a1		       00 23	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_3 =	35
    475  27a1		       00 24	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_0 =	36
    476  27a1		       00 25	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_1 =	37
    477  27a1		       00 26	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_2 =	38
    478  27a1		       00 27	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_3 =	39
    479  27a1		       00 28	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_0 =	40
    480  27a1		       00 29	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_1 =	41
    481  27a1		       00 2a	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_2 =	42
    482  27a1		       00 2b	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_3 =	43
    483  27a1		       00 2c	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_0 =	44
    484  27a1		       00 2d	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_1 =	45
    485  27a1		       00 2e	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_2 =	46
    486  27a1		       00 2f	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_3 =	47
    487  27a1		       00 30	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_0 =	48
    488  27a1		       00 31	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_1 =	49
    489  27a1		       00 32	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_2 =	50
    490  27a1		       00 33	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_3 =	51
    491  27a1		       00 34	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_0 =	52
    492  27a1		       00 35	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_1 =	53
    493  27a1		       00 36	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_2 =	54
    494  27a1		       00 37	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_3 =	55
    495  27a1		       00 38	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_0 =	56
    496  27a1		       00 39	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_1 =	57
    497  27a1		       00 3a	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_2 =	58
    498  27a1		       00 3b	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_3 =	59
    499  27a1		       00 3c	   INDEX_WHITE_KING_on_BLACK_SQUARE_0 =	60
    500  27a1		       00 3d	   INDEX_WHITE_KING_on_BLACK_SQUARE_1 =	61
    501  27a1		       00 3e	   INDEX_WHITE_KING_on_BLACK_SQUARE_2 =	62
    502  27a1		       00 3f	   INDEX_WHITE_KING_on_BLACK_SQUARE_3 =	63
    503  27a1		       00 40	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_0 =	64
    504  27a1		       00 41	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_1 =	65
    505  27a1		       00 42	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_2 =	66
    506  27a1		       00 43	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_3 =	67
    507  27a1		       00 44	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_0 =	68
    508  27a1		       00 45	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_1 =	69
    509  27a1		       00 46	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_2 =	70
    510  27a1		       00 47	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_3 =	71
    511  27a1		       00 48	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_0 =	72
    512  27a1		       00 49	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_1 =	73
    513  27a1		       00 4a	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_2 =	74
    514  27a1		       00 4b	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_3 =	75
    515  27a1		       00 4c	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_0 =	76
    516  27a1		       00 4d	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_1 =	77
    517  27a1		       00 4e	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_2 =	78
    518  27a1		       00 4f	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_3 =	79
    519  27a1		       00 50	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0 =	80
    520  27a1		       00 51	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_1 =	81
    521  27a1		       00 52	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_2 =	82
    522  27a1		       00 53	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_3 =	83
    523  27a1		       00 54	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0 =	84
    524  27a1		       00 55	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_1 =	85
    525  27a1		       00 56	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_2 =	86
    526  27a1		       00 57	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_3 =	87
    527  27a1		       00 58	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_0 =	88
    528  27a1		       00 59	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_1 =	89
    529  27a1		       00 5a	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_2 =	90
    530  27a1		       00 5b	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_3 =	91
    531  27a1		       00 5c	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0 =	92
    532  27a1		       00 5d	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_1 =	93
    533  27a1		       00 5e	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_2 =	94
    534  27a1		       00 5f	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_3 =	95
    535  27a1		       00 60	   INDEX_BLACK_KING_on_WHITE_SQUARE_0 =	96
    536  27a1		       00 61	   INDEX_BLACK_KING_on_WHITE_SQUARE_1 =	97
    537  27a1		       00 62	   INDEX_BLACK_KING_on_WHITE_SQUARE_2 =	98
    538  27a1		       00 63	   INDEX_BLACK_KING_on_WHITE_SQUARE_3 =	99
    539  27a1		       00 64	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_0 =	100
    540  27a1		       00 65	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_1 =	101
    541  27a1		       00 66	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_2 =	102
    542  27a1		       00 67	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_3 =	103
    543  27a1		       00 68	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0 =	104
    544  27a1		       00 69	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_1 =	105
    545  27a1		       00 6a	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_2 =	106
    546  27a1		       00 6b	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_3 =	107
    547  27a1		       00 6c	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_0 =	108
    548  27a1		       00 6d	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_1 =	109
    549  27a1		       00 6e	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_2 =	110
    550  27a1		       00 6f	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_3 =	111
    551  27a1		       00 70	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_0 =	112
    552  27a1		       00 71	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_1 =	113
    553  27a1		       00 72	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_2 =	114
    554  27a1		       00 73	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_3 =	115
    555  27a1		       00 74	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_0 =	116
    556  27a1		       00 75	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_1 =	117
    557  27a1		       00 76	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_2 =	118
    558  27a1		       00 77	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_3 =	119
    559  27a1		       00 78	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_0 =	120
    560  27a1		       00 79	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_1 =	121
    561  27a1		       00 7a	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_2 =	122
    562  27a1		       00 7b	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_3 =	123
    563  27a1		       00 7c	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_0 =	124
    564  27a1		       00 7d	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_1 =	125
    565  27a1		       00 7e	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_2 =	126
    566  27a1		       00 7f	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_3 =	127
    567  27a1		       00 80	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_0 =	128
    568  27a1		       00 81	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_1 =	129
    569  27a1		       00 82	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_2 =	130
    570  27a1		       00 83	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_3 =	131
    571  27a1		       00 84	   INDEX_BLACK_KING_on_BLACK_SQUARE_0 =	132
    572  27a1		       00 85	   INDEX_BLACK_KING_on_BLACK_SQUARE_1 =	133
    573  27a1		       00 86	   INDEX_BLACK_KING_on_BLACK_SQUARE_2 =	134
    574  27a1		       00 87	   INDEX_BLACK_KING_on_BLACK_SQUARE_3 =	135
    575  27a1		       00 88	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_0 =	136
    576  27a1		       00 89	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_1 =	137
    577  27a1		       00 8a	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_2 =	138
    578  27a1		       00 8b	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_3 =	139
    579  27a1		       00 8c	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_0 =	140
    580  27a1		       00 8d	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_1 =	141
    581  27a1		       00 8e	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_2 =	142
    582  27a1		       00 8f	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_3 =	143
------- FILE @2 GENERIC #3.asm
    491  27a1
    492  27a1
    493  27a1							;---------------------------------------------------------------------------------------------------
    494  27a1
      0  27a1					      END_BANK
      1  27a1				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  27a1				  -	      CHECK_RAM_BANK_SIZE
      3  27a1					      ELSE
      0  27a1					      CHECK_BANK_SIZE
      1  27a1		       03 a1	   .TEMP      =	* - _BANK_START
 ROM bank # 10 GENERIC_BANK@2#1 size = $3a1 free = 94
      2  27a1					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  27a1				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  27a1				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  27a1				  -	      ERR
      6  27a1					      ENDIF
      5  27a1					      ENDIF
    496  27a1
    497  27a1							;---------------------------------------------------------------------------------------------------
    498  27a1							;EOF
------- FILE ./chess.asm
------- FILE @2 GENERIC #4.asm LEVEL 2 PASS 4
      0  27a1					      include	"@2 GENERIC #4.asm"
      1  27a1							;---------------------------------------------------------------------------------------------------
      2  27a1							; @2 GENERIC #4.asm
      3  27a1
      4  27a1							; Atari 2600 Chess
      5  27a1							; Copyright (c) 2019-2020 Andrew Davie
      6  27a1							; andrew@taswegian.com
      7  27a1
      8  27a1
      9  27a1							;---------------------------------------------------------------------------------------------------
     10  27a1
      0  27a1					      SLOT	2
      1  27a1
      2  27a1				  -	      IF	(2 < 0) || (2 > 3)
      3  27a1				  -	      ECHO	"Illegal bank address/segment location", 2
      4  27a1				  -	      ERR
      5  27a1					      ENDIF
      6  27a1
      7  27a1				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  27a1				   _BANK_SLOT SET	2 * 64
      9  27a1
      0  27a1					      ROMBANK	GENERIC_BANK@2#2
      1  287d ????				      SEG	ROM_GENERIC_BANK@2#2
      2  2800					      ORG	_ORIGIN
      3  2800					      RORG	_BANK_ADDRESS_ORIGIN
      4  2800				   _BANK_START SET	*
      5  2800				   GENERIC_BANK@2#2_START SET	*
      6  2800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  2800				   ROMBANK_GENERIC_BANK@2#2 SET	_BANK_SLOT + _CURRENT_BANK
      8  2800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  2800				   _LAST_BANK SETSTR	GENERIC_BANK@2#2
     10  2800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  2800
     14  2800
     15  2800							;---------------------------------------------------------------------------------------------------
     16  2800
      0  2800					      DEF	moveCursor
      1  2800				   SLOT_moveCursor SET	_BANK_SLOT
      2  2800				   BANK_moveCursor SET	SLOT_moveCursor + _CURRENT_BANK
      3  2800				   moveCursor
      4  2800				   TEMPORARY_VAR SET	Overlay
      5  2800				   TEMPORARY_OFFSET SET	0
      6  2800				   VAR_BOUNDARY_moveCursor SET	TEMPORARY_OFFSET
      7  2800				   FUNCTION_NAME SET	moveCursor
     18  2800					      SUBROUTINE
     19  2800
      0  2800					      REF	aiSelectStartSquare
      1  2800					      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  2800				   TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  2800					      ENDIF
      0  2800					      REF	aiSelectDestinationSquare
      1  2800					      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  2800				   TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  2800					      ENDIF
     22  2800
      0  2800					      VAR	__newCursor, 1
      1  2800
      2  2800		       00 ef	   __newCursor =	TEMPORARY_VAR
      3  2800				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  2800
      5  2800				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  2800				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  2800				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  2800					      ENDIF
      9  2800				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  2800				  -	      LIST	ON
     11  2800				  -VNAME      SETSTR	__newCursor
     12  2800				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  2800				  -	      ERR
     14  2800				  -	      ECHO	"Temporary Variable overlow!"
     15  2800					      ENDIF
     16  2800					      LIST	ON
     24  2800
      0  2800					      VEND	moveCursor
      1  2800
      2  2800
      3  2800		       00 f0	   VAREND_moveCursor =	TEMPORARY_VAR
      4  2800
     26  2800
     27  2800							; Part (a) move cursor around the board waiting for joystick press
     28  2800
     29  2800		       a2 00		      ldx	#0	; delay
     30  2802
     31  2802		       ad 80 02 	      lda	SWCHA
     32  2805		       4a		      lsr
     33  2806		       4a		      lsr
     34  2807		       4a		      lsr
     35  2808		       4a		      lsr
     36  2809		       a8		      tay
     37  280a
     38  280a		       c9 0f		      cmp	#15
     39  280c		       f0 1e		      beq	.cursor	; nothing pressed - skip delays
     40  280e
     41  280e		       c6 89		      dec	mdelay
     42  2810		       10 1f		      bpl	.delaym
     43  2812
     44  2812		       18		      clc
     45  2813		       a5 88		      lda	cursorX12
     46  2815		       79 6d f8 	      adc	JoyMoveCursor,y
     47  2818		       85 ef		      sta	__newCursor
     48  281a		       a8		      tay
     49  281b
     50  281b		       a9 d0		      lda	#RAMBANK_BOARD
     51  281d		       85 3e		      sta	SET_BANK_RAM	;@3
     52  281f		       b9 15 fc 	      lda	ValidSquare,y
     53  2822		       c9 ff		      cmp	#-1
     54  2824		       f0 04		      beq	.invalid
     55  2826		       a5 ef		      lda	__newCursor
     56  2828		       85 88		      sta	cursorX12
     57  282a				   .invalid
     58  282a
     59  282a		       a2 10		      ldx	#CURSOR_MOVE_SPEED
     60  282c		       86 89	   .cursor    stx	mdelay
     61  282e		       20 32 f8 	      jsr	setCursorPriority
     62  2831		       60	   .delaym    rts
     63  2832
     64  2832
     65  2832							;---------------------------------------------------------------------------------------------------
     66  2832
      0  2832					      DEF	setCursorPriority
      1  2832				   SLOT_setCursorPriority SET	_BANK_SLOT
      2  2832				   BANK_setCursorPriority SET	SLOT_setCursorPriority + _CURRENT_BANK
      3  2832				   setCursorPriority
      4  2832				   TEMPORARY_VAR SET	Overlay
      5  2832				   TEMPORARY_OFFSET SET	0
      6  2832				   VAR_BOUNDARY_setCursorPriority SET	TEMPORARY_OFFSET
      7  2832				   FUNCTION_NAME SET	setCursorPriority
     68  2832					      SUBROUTINE
     69  2832
      0  2832					      REF	moveCursor
      1  2832					      IF	VAREND_moveCursor > TEMPORARY_VAR
      2  2832				   TEMPORARY_VAR SET	VAREND_moveCursor
      3  2832					      ENDIF
      0  2832					      VEND	setCursorPriority
      1  2832
      2  2832
      3  2832		       00 f0	   VAREND_setCursorPriority =	TEMPORARY_VAR
      4  2832
     72  2832
     73  2832		       98		      tya
     74  2833		       48		      pha
     75  2834
     76  2834		       a2 04		      ldx	#%100
     77  2836
     78  2836		       a4 88		      ldy	cursorX12
     79  2838		       30 0b		      bmi	.under
     80  283a
     81  283a		       a9 d0		      lda	#RAMBANK_BOARD
     82  283c		       85 3e		      sta	SET_BANK_RAM	;@3
     83  283e		       b9 79 fc 	      lda	Board,y
     84  2841		       d0 02		      bne	.under
     85  2843		       a2 00		      ldx	#0
     86  2845		       86 4a	   .under     stx	CTRLPF	; UNDER
     87  2847
     88  2847		       68		      pla
     89  2848		       a8		      tay
     90  2849		       60		      rts
     91  284a
     92  284a
     93  284a							;---------------------------------------------------------------------------------------------------
     94  284a
      0  284a					      DEF	setCursorColours
      1  284a				   SLOT_setCursorColours SET	_BANK_SLOT
      2  284a				   BANK_setCursorColours SET	SLOT_setCursorColours + _CURRENT_BANK
      3  284a				   setCursorColours
      4  284a				   TEMPORARY_VAR SET	Overlay
      5  284a				   TEMPORARY_OFFSET SET	0
      6  284a				   VAR_BOUNDARY_setCursorColours SET	TEMPORARY_OFFSET
      7  284a				   FUNCTION_NAME SET	setCursorColours
     96  284a					      SUBROUTINE
     97  284a
      0  284a					      REF	aiSelectStartSquare
      1  284a					      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  284a				   TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  284a					      ENDIF
      0  284a					      REF	aiDrawMoves
      1  284a				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  284a				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  284a					      ENDIF
      0  284a					      REF	aiUnDrawTargetSquares
      1  284a				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  284a				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  284a					      ENDIF
      0  284a					      REF	aiShowMoveCaptures
      1  284a				  -	      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  284a				  -TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  284a					      ENDIF
      0  284a					      REF	aiSlowFlash
      1  284a				  -	      IF	VAREND_aiSlowFlash > TEMPORARY_VAR
      2  284a				  -TEMPORARY_VAR SET	VAREND_aiSlowFlash
      3  284a					      ENDIF
      0  284a					      REF	aiSelectDestinationSquare
      1  284a					      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  284a				   TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  284a					      ENDIF
      0  284a					      VEND	setCursorColours
      1  284a
      2  284a
      3  284a		       00 ef	   VAREND_setCursorColours =	TEMPORARY_VAR
      4  284a
    105  284a
    106  284a							; pass y=-1 if move is NOT in the movelist
    107  284a							; preserve y
    108  284a
    109  284a		       a9 42		      lda	#$42	; red
    110  284c
    111  284c		       c0 ff		      cpy	#-1
    112  284e		       f0 0a		      beq	.writeCursorCol	; NOT in the movelist
    113  2850
    114  2850		       a5 8a		      lda	ccur
    115  2852		       4a		      lsr
    116  2853		       4a		      lsr
    117  2854		       4a		      lsr
    118  2855		       29 06		      and	#6
    119  2857		       18		      clc
    120  2858		       69 d0		      adc	#$D0	;COLOUR_LINE_1 	; pulsing green
    121  285a
    122  285a		       85 46	   .writeCursorCol sta	COLUP0
    123  285c		       60		      rts
    124  285d
    125  285d
    126  285d							;---------------------------------------------------------------------------------------------------
    127  285d
    128  285d							;	    RLDU RLD  RL U RL	R DU R D  R  U R     LDU  LD   L U  L	  DU   D     U
    129  285d							;	    0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    130  285d
      0  285d					      ALLOCATE	JoyCombined, 16
      1  285d
      2  285d				   .NAME      SETSTR	JoyCombined
      0  285d					      OPTIONAL_PAGEBREAK	.NAME, 16
      1  285d
      2  285d				  -	      IF	(>( * + 16 -1 )) > ( >* )
      3  285d				  -.EARLY_LOCATION SET	*
      4  285d				  -	      ALIGN	256
      5  285d				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  285d					      ENDIF
      0  285d					      DEF	JoyCombined
      1  285d				   SLOT_JoyCombined SET	_BANK_SLOT
      2  285d				   BANK_JoyCombined SET	SLOT_JoyCombined + _CURRENT_BANK
      3  285d				   JoyCombined
      4  285d				   TEMPORARY_VAR SET	Overlay
      5  285d				   TEMPORARY_OFFSET SET	0
      6  285d				   VAR_BOUNDARY_JoyCombined SET	TEMPORARY_OFFSET
      7  285d				   FUNCTION_NAME SET	JoyCombined
      5  285d
    132  285d		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, -1, 0
    133  286d
      0  286d					      ALLOCATE	JoyMoveCursor, 16
      1  286d
      2  286d				   .NAME      SETSTR	JoyMoveCursor
      0  286d					      OPTIONAL_PAGEBREAK	.NAME, 16
      1  286d
      2  286d				  -	      IF	(>( * + 16 -1 )) > ( >* )
      3  286d				  -.EARLY_LOCATION SET	*
      4  286d				  -	      ALIGN	256
      5  286d				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  286d					      ENDIF
      0  286d					      DEF	JoyMoveCursor
      1  286d				   SLOT_JoyMoveCursor SET	_BANK_SLOT
      2  286d				   BANK_JoyMoveCursor SET	SLOT_JoyMoveCursor + _CURRENT_BANK
      3  286d				   JoyMoveCursor
      4  286d				   TEMPORARY_VAR SET	Overlay
      5  286d				   TEMPORARY_OFFSET SET	0
      6  286d				   VAR_BOUNDARY_JoyMoveCursor SET	TEMPORARY_OFFSET
      7  286d				   FUNCTION_NAME SET	JoyMoveCursor
      5  286d
    135  286d		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, -9, 11, 1, 0, -11, 9, -1, 0, -10, 10, 0
    136  287d
    137  287d
    138  287d							;---------------------------------------------------------------------------------------------------
    139  287d
      0  287d					      END_BANK
      1  287d				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  287d				  -	      CHECK_RAM_BANK_SIZE
      3  287d					      ELSE
      0  287d					      CHECK_BANK_SIZE
      1  287d		       00 7d	   .TEMP      =	* - _BANK_START
 ROM bank # 11 GENERIC_BANK@2#2 size = $7d free = 898
      2  287d					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  287d				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  287d				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  287d				  -	      ERR
      6  287d					      ENDIF
      5  287d					      ENDIF
    141  287d
    142  287d							;---------------------------------------------------------------------------------------------------
    143  287d							;EOF
------- FILE ./chess.asm
------- FILE @2 GRAPHICS DATA.asm LEVEL 2 PASS 4
      0  287d					      include	"@2 GRAPHICS DATA.asm"
      1  287d							;---------------------------------------------------------------------------------------------------
      2  287d							; @2 GRAPHICS DATA.asm
      3  287d
      4  287d							; Atari 2600 Chess
      5  287d							; Copyright (c) 2019-2020 Andrew Davie
      6  287d							; andrew@taswegian.com
      7  287d
      8  287d
      9  287d							;---------------------------------------------------------------------------------------------------
     10  287d
      0  287d					      SLOT	2
      1  287d
      2  287d				  -	      IF	(2 < 0) || (2 > 3)
      3  287d				  -	      ECHO	"Illegal bank address/segment location", 2
      4  287d				  -	      ERR
      5  287d					      ENDIF
      6  287d
      7  287d				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  287d				   _BANK_SLOT SET	2 * 64
      9  287d
     12  287d
     13  287d
     14  287d							;---------------------------------------------------------------------------------------------------
     15  287d
      0  287d					      ROMBANK	GFX1
      1  2fd8 ????				      SEG	ROM_GFX1
      2  2c00					      ORG	_ORIGIN
      3  2c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  2c00				   _BANK_START SET	*
      5  2c00				   GFX1_START SET	*
      6  2c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  2c00				   ROMBANK_GFX1 SET	_BANK_SLOT + _CURRENT_BANK
      8  2c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  2c00				   _LAST_BANK SETSTR	GFX1
     10  2c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     17  2c00
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2c00					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  2c00					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_0", 72
      1  2c00
      2  2c00				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2c00				  -.EARLY_LOCATION SET	*
      4  2c00				  -	      ALIGN	256
      5  2c00				  -	      ECHO	"Page break for", "BLACK_PROMOTE_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2c00					      ENDIF
      0  2c00					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_0
      1  2c00				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2c00				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2c00				   BLACK_PROMOTE_on_BLACK_SQUARE_0
      4  2c00				   TEMPORARY_VAR SET	Overlay
      5  2c00				   TEMPORARY_OFFSET SET	0
      6  2c00				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2c00				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_0
      3  2c00		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2c48					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  2c48					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_1", 72
      1  2c48
      2  2c48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2c48				  -.EARLY_LOCATION SET	*
      4  2c48				  -	      ALIGN	256
      5  2c48				  -	      ECHO	"Page break for", "BLACK_PROMOTE_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2c48					      ENDIF
      0  2c48					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_1
      1  2c48				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2c48				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2c48				   BLACK_PROMOTE_on_BLACK_SQUARE_1
      4  2c48				   TEMPORARY_VAR SET	Overlay
      5  2c48				   TEMPORARY_OFFSET SET	0
      6  2c48				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2c48				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_1
      3  2c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c60		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2c90					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  2c90					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_2", 72
      1  2c90
      2  2c90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2c90				  -.EARLY_LOCATION SET	*
      4  2c90				  -	      ALIGN	256
      5  2c90				  -	      ECHO	"Page break for", "BLACK_PROMOTE_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2c90					      ENDIF
      0  2c90					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_2
      1  2c90				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2c90				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2c90				   BLACK_PROMOTE_on_BLACK_SQUARE_2
      4  2c90				   TEMPORARY_VAR SET	Overlay
      5  2c90				   TEMPORARY_OFFSET SET	0
      6  2c90				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2c90				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_2
      3  2c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2cc0		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2cd8					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  2cd8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_3", 72
      1  2cd8
      2  2cd8					      IF	(>( * + 72 -1 )) > ( >* )
      3  2cd8				   .EARLY_LOCATION SET	*
      4  2d00		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_PROMOTE_on_BLACK_SQUARE_3 wasted 40 bytes
      5  2d00					      ECHO	"Page break for", "BLACK_PROMOTE_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2d00					      ENDIF
      0  2d00					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_3
      1  2d00				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2d00				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2d00				   BLACK_PROMOTE_on_BLACK_SQUARE_3
      4  2d00				   TEMPORARY_VAR SET	Overlay
      5  2d00				   TEMPORARY_OFFSET SET	0
      6  2d00				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2d00				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_3
      3  2d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d30		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2d48					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  2d48					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_0", 72
      1  2d48
      2  2d48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2d48				  -.EARLY_LOCATION SET	*
      4  2d48				  -	      ALIGN	256
      5  2d48				  -	      ECHO	"Page break for", "BLACK_PROMOTE_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2d48					      ENDIF
      0  2d48					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_0
      1  2d48				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2d48				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2d48				   BLACK_PROMOTE_on_WHITE_SQUARE_0
      4  2d48				   TEMPORARY_VAR SET	Overlay
      5  2d48				   TEMPORARY_OFFSET SET	0
      6  2d48				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2d48				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_0
      3  2d48		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  2d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2d90					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  2d90					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_1", 72
      1  2d90
      2  2d90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2d90				  -.EARLY_LOCATION SET	*
      4  2d90				  -	      ALIGN	256
      5  2d90				  -	      ECHO	"Page break for", "BLACK_PROMOTE_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2d90					      ENDIF
      0  2d90					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_1
      1  2d90				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2d90				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2d90				   BLACK_PROMOTE_on_WHITE_SQUARE_1
      4  2d90				   TEMPORARY_VAR SET	Overlay
      5  2d90				   TEMPORARY_OFFSET SET	0
      6  2d90				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2d90				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_1
      3  2d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2da8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  2dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2dd8					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  2dd8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_2", 72
      1  2dd8
      2  2dd8					      IF	(>( * + 72 -1 )) > ( >* )
      3  2dd8				   .EARLY_LOCATION SET	*
      4  2e00		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_PROMOTE_on_WHITE_SQUARE_2 wasted 40 bytes
      5  2e00					      ECHO	"Page break for", "BLACK_PROMOTE_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2e00					      ENDIF
      0  2e00					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_2
      1  2e00				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2e00				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2e00				   BLACK_PROMOTE_on_WHITE_SQUARE_2
      4  2e00				   TEMPORARY_VAR SET	Overlay
      5  2e00				   TEMPORARY_OFFSET SET	0
      6  2e00				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2e00				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_2
      3  2e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  2e30		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2e48					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  2e48					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_3", 72
      1  2e48
      2  2e48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2e48				  -.EARLY_LOCATION SET	*
      4  2e48				  -	      ALIGN	256
      5  2e48				  -	      ECHO	"Page break for", "BLACK_PROMOTE_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2e48					      ENDIF
      0  2e48					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_3
      1  2e48				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2e48				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2e48				   BLACK_PROMOTE_on_WHITE_SQUARE_3
      4  2e48				   TEMPORARY_VAR SET	Overlay
      5  2e48				   TEMPORARY_OFFSET SET	0
      6  2e48				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2e48				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_3
      3  2e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e78		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2e90					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm"
      0  2e90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_0", 72
      1  2e90
      2  2e90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2e90				  -.EARLY_LOCATION SET	*
      4  2e90				  -	      ALIGN	256
      5  2e90				  -	      ECHO	"Page break for", "WHITE_MARKER_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2e90					      ENDIF
      0  2e90					      DEF	WHITE_MARKER_on_BLACK_SQUARE_0
      1  2e90				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2e90				   BANK_WHITE_MARKER_on_BLACK_SQUARE_0 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2e90				   WHITE_MARKER_on_BLACK_SQUARE_0
      4  2e90				   TEMPORARY_VAR SET	Overlay
      5  2e90				   TEMPORARY_OFFSET SET	0
      6  2e90				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2e90				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_0
      3  2e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00	;PF0
      4  2ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2ed8					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm"
      0  2ed8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_1", 72
      1  2ed8
      2  2ed8					      IF	(>( * + 72 -1 )) > ( >* )
      3  2ed8				   .EARLY_LOCATION SET	*
      4  2f00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_MARKER_on_BLACK_SQUARE_1 wasted 40 bytes
      5  2f00					      ECHO	"Page break for", "WHITE_MARKER_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2f00					      ENDIF
      0  2f00					      DEF	WHITE_MARKER_on_BLACK_SQUARE_1
      1  2f00				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2f00				   BANK_WHITE_MARKER_on_BLACK_SQUARE_1 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2f00				   WHITE_MARKER_on_BLACK_SQUARE_1
      4  2f00				   TEMPORARY_VAR SET	Overlay
      5  2f00				   TEMPORARY_OFFSET SET	0
      6  2f00				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2f00				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_1
      3  2f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00	;PF1
      5  2f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2f48					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm"
      0  2f48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_2", 72
      1  2f48
      2  2f48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2f48				  -.EARLY_LOCATION SET	*
      4  2f48				  -	      ALIGN	256
      5  2f48				  -	      ECHO	"Page break for", "WHITE_MARKER_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2f48					      ENDIF
      0  2f48					      DEF	WHITE_MARKER_on_BLACK_SQUARE_2
      1  2f48				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2f48				   BANK_WHITE_MARKER_on_BLACK_SQUARE_2 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2f48				   WHITE_MARKER_on_BLACK_SQUARE_2
      4  2f48				   TEMPORARY_VAR SET	Overlay
      5  2f48				   TEMPORARY_OFFSET SET	0
      6  2f48				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2f48				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_2
      3  2f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00	;PF1
      5  2f78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2f90					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm"
      0  2f90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_3", 72
      1  2f90
      2  2f90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2f90				  -.EARLY_LOCATION SET	*
      4  2f90				  -	      ALIGN	256
      5  2f90				  -	      ECHO	"Page break for", "WHITE_MARKER_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2f90					      ENDIF
      0  2f90					      DEF	WHITE_MARKER_on_BLACK_SQUARE_3
      1  2f90				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2f90				   BANK_WHITE_MARKER_on_BLACK_SQUARE_3 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2f90				   WHITE_MARKER_on_BLACK_SQUARE_3
      4  2f90				   TEMPORARY_VAR SET	Overlay
      5  2f90				   TEMPORARY_OFFSET SET	0
      6  2f90				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2f90				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_3
      3  2f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2fc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
     30  2fd8
      0  2fd8					      END_BANK
      1  2fd8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  2fd8				  -	      CHECK_RAM_BANK_SIZE
      3  2fd8					      ELSE
      0  2fd8					      CHECK_BANK_SIZE
      1  2fd8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 12 GFX1 size = $3d8 free = 39
      2  2fd8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  2fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2fd8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  2fd8				  -	      ERR
      6  2fd8					      ENDIF
      5  2fd8					      ENDIF
     32  2fd8
     33  2fd8
     34  2fd8							;---------------------------------------------------------------------------------------------------
     35  2fd8
      0  2fd8					      ROMBANK	GFX2
      1  33d8 ????				      SEG	ROM_GFX2
      2  3000					      ORG	_ORIGIN
      3  3000					      RORG	_BANK_ADDRESS_ORIGIN
      4  3000				   _BANK_START SET	*
      5  3000				   GFX2_START SET	*
      6  3000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  3000				   ROMBANK_GFX2 SET	_BANK_SLOT + _CURRENT_BANK
      8  3000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  3000				   _LAST_BANK SETSTR	GFX2
     10  3000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     37  3000
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3000					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm"
      0  3000					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_0", 72
      1  3000
      2  3000				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3000				  -.EARLY_LOCATION SET	*
      4  3000				  -	      ALIGN	256
      5  3000				  -	      ECHO	"Page break for", "WHITE_MARKER_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3000					      ENDIF
      0  3000					      DEF	WHITE_MARKER_on_WHITE_SQUARE_0
      1  3000				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3000				   BANK_WHITE_MARKER_on_WHITE_SQUARE_0 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3000				   WHITE_MARKER_on_WHITE_SQUARE_0
      4  3000				   TEMPORARY_VAR SET	Overlay
      5  3000				   TEMPORARY_OFFSET SET	0
      6  3000				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3000				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_0
      3  3000		       00 40 e0 e0*	      .byte.b	$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3048					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm"
      0  3048					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_1", 72
      1  3048
      2  3048				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3048				  -.EARLY_LOCATION SET	*
      4  3048				  -	      ALIGN	256
      5  3048				  -	      ECHO	"Page break for", "WHITE_MARKER_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3048					      ENDIF
      0  3048					      DEF	WHITE_MARKER_on_WHITE_SQUARE_1
      1  3048				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3048				   BANK_WHITE_MARKER_on_WHITE_SQUARE_1 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3048				   WHITE_MARKER_on_WHITE_SQUARE_1
      4  3048				   TEMPORARY_VAR SET	Overlay
      5  3048				   TEMPORARY_OFFSET SET	0
      6  3048				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3048				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_1
      3  3048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3060		       00 10 38 38*	      .byte.b	$00,$10,$38,$38,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3090					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm"
      0  3090					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_2", 72
      1  3090
      2  3090				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3090				  -.EARLY_LOCATION SET	*
      4  3090				  -	      ALIGN	256
      5  3090				  -	      ECHO	"Page break for", "WHITE_MARKER_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3090					      ENDIF
      0  3090					      DEF	WHITE_MARKER_on_WHITE_SQUARE_2
      1  3090				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3090				   BANK_WHITE_MARKER_on_WHITE_SQUARE_2 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3090				   WHITE_MARKER_on_WHITE_SQUARE_2
      4  3090				   TEMPORARY_VAR SET	Overlay
      5  3090				   TEMPORARY_OFFSET SET	0
      6  3090				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3090				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_2
      3  3090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  30a8		       00 00 01 01*	      .byte.b	$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  30c0		       00 01 03 03*	      .byte.b	$00,$01,$03,$03,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  30d8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm"
      0  30d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_0", 72
      1  30d8
      2  30d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  30d8				   .EARLY_LOCATION SET	*
      4  3100		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_BISHOP_on_BLACK_SQUARE_0 wasted 40 bytes
      5  3100					      ECHO	"Page break for", "BLACK_BISHOP_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3100					      ENDIF
      0  3100					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_0
      1  3100				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3100				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3100				   BLACK_BISHOP_on_BLACK_SQUARE_0
      4  3100				   TEMPORARY_VAR SET	Overlay
      5  3100				   TEMPORARY_OFFSET SET	0
      6  3100				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3100				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_0
      3  3100		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$40,$00	;PF0
      4  3118		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3130		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3148					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm"
      0  3148					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_1", 72
      1  3148
      2  3148				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3148				  -.EARLY_LOCATION SET	*
      4  3148				  -	      ALIGN	256
      5  3148				  -	      ECHO	"Page break for", "BLACK_BISHOP_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3148					      ENDIF
      0  3148					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_1
      1  3148				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3148				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3148				   BLACK_BISHOP_on_BLACK_SQUARE_1
      4  3148				   TEMPORARY_VAR SET	Overlay
      5  3148				   TEMPORARY_OFFSET SET	0
      6  3148				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3148				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_1
      3  3148		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3160		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$00,$00,$00,$10,$00	;PF1
      5  3178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3190					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm"
      0  3190					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_2", 72
      1  3190
      2  3190				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3190				  -.EARLY_LOCATION SET	*
      4  3190				  -	      ALIGN	256
      5  3190				  -	      ECHO	"Page break for", "BLACK_BISHOP_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3190					      ENDIF
      0  3190					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_2
      1  3190				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3190				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3190				   BLACK_BISHOP_on_BLACK_SQUARE_2
      4  3190				   TEMPORARY_VAR SET	Overlay
      5  3190				   TEMPORARY_OFFSET SET	0
      6  3190				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3190				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_2
      3  3190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  31a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  31c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$00,$00,$00,$01,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  31d8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm"
      0  31d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_3", 72
      1  31d8
      2  31d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  31d8				   .EARLY_LOCATION SET	*
      4  3200		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_BISHOP_on_BLACK_SQUARE_3 wasted 40 bytes
      5  3200					      ECHO	"Page break for", "BLACK_BISHOP_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3200					      ENDIF
      0  3200					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_3
      1  3200				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3200				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3200				   BLACK_BISHOP_on_BLACK_SQUARE_3
      4  3200				   TEMPORARY_VAR SET	Overlay
      5  3200				   TEMPORARY_OFFSET SET	0
      6  3200				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3200				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_3
      3  3200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3218		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3230		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$00,$00,$00,$20,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3248					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm"
      0  3248					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_0", 72
      1  3248
      2  3248				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3248				  -.EARLY_LOCATION SET	*
      4  3248				  -	      ALIGN	256
      5  3248				  -	      ECHO	"Page break for", "BLACK_ROOK_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3248					      ENDIF
      0  3248					      DEF	BLACK_ROOK_on_BLACK_SQUARE_0
      1  3248				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3248				   BANK_BLACK_ROOK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3248				   BLACK_ROOK_on_BLACK_SQUARE_0
      4  3248				   TEMPORARY_VAR SET	Overlay
      5  3248				   TEMPORARY_OFFSET SET	0
      6  3248				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3248				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_0
      3  3248		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$a0,$00,$00	;PF0
      4  3260		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3278		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3290					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm"
      0  3290					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_1", 72
      1  3290
      2  3290				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3290				  -.EARLY_LOCATION SET	*
      4  3290				  -	      ALIGN	256
      5  3290				  -	      ECHO	"Page break for", "BLACK_ROOK_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3290					      ENDIF
      0  3290					      DEF	BLACK_ROOK_on_BLACK_SQUARE_1
      1  3290				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3290				   BANK_BLACK_ROOK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3290				   BLACK_ROOK_on_BLACK_SQUARE_1
      4  3290				   TEMPORARY_VAR SET	Overlay
      5  3290				   TEMPORARY_OFFSET SET	0
      6  3290				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3290				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_1
      3  3290		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  32a8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$28,$00,$00	;PF1
      5  32c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  32d8					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm"
      0  32d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_2", 72
      1  32d8
      2  32d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  32d8				   .EARLY_LOCATION SET	*
      4  3300		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_ROOK_on_BLACK_SQUARE_2 wasted 40 bytes
      5  3300					      ECHO	"Page break for", "BLACK_ROOK_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3300					      ENDIF
      0  3300					      DEF	BLACK_ROOK_on_BLACK_SQUARE_2
      1  3300				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3300				   BANK_BLACK_ROOK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3300				   BLACK_ROOK_on_BLACK_SQUARE_2
      4  3300				   TEMPORARY_VAR SET	Overlay
      5  3300				   TEMPORARY_OFFSET SET	0
      6  3300				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3300				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_2
      3  3300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3318		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF1
      5  3330		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$02,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3348					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm"
      0  3348					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_3", 72
      1  3348
      2  3348				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3348				  -.EARLY_LOCATION SET	*
      4  3348				  -	      ALIGN	256
      5  3348				  -	      ECHO	"Page break for", "BLACK_ROOK_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3348					      ENDIF
      0  3348					      DEF	BLACK_ROOK_on_BLACK_SQUARE_3
      1  3348				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3348				   BANK_BLACK_ROOK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3348				   BLACK_ROOK_on_BLACK_SQUARE_3
      4  3348				   TEMPORARY_VAR SET	Overlay
      5  3348				   TEMPORARY_OFFSET SET	0
      6  3348				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3348				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_3
      3  3348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3378		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3390					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm"
      0  3390					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_0", 72
      1  3390
      2  3390				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3390				  -.EARLY_LOCATION SET	*
      4  3390				  -	      ALIGN	256
      5  3390				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3390					      ENDIF
      0  3390					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_0
      1  3390				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3390				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3390				   BLACK_QUEEN_on_BLACK_SQUARE_0
      4  3390				   TEMPORARY_VAR SET	Overlay
      5  3390				   TEMPORARY_OFFSET SET	0
      6  3390				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3390				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_0
      3  3390		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  33a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  33c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
     50  33d8
      0  33d8					      END_BANK
      1  33d8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  33d8				  -	      CHECK_RAM_BANK_SIZE
      3  33d8					      ELSE
      0  33d8					      CHECK_BANK_SIZE
      1  33d8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 13 GFX2 size = $3d8 free = 39
      2  33d8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  33d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  33d8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  33d8				  -	      ERR
      6  33d8					      ENDIF
      5  33d8					      ENDIF
     52  33d8
     53  33d8
     54  33d8							;---------------------------------------------------------------------------------------------------
     55  33d8
      0  33d8					      ROMBANK	GFX3
      1  37d8 ????				      SEG	ROM_GFX3
      2  3400					      ORG	_ORIGIN
      3  3400					      RORG	_BANK_ADDRESS_ORIGIN
      4  3400				   _BANK_START SET	*
      5  3400				   GFX3_START SET	*
      6  3400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  3400				   ROMBANK_GFX3 SET	_BANK_SLOT + _CURRENT_BANK
      8  3400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  3400				   _LAST_BANK SETSTR	GFX3
     10  3400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     57  3400
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3400					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm"
      0  3400					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_1", 72
      1  3400
      2  3400				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3400				  -.EARLY_LOCATION SET	*
      4  3400				  -	      ALIGN	256
      5  3400				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3400					      ENDIF
      0  3400					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_1
      1  3400				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3400				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3400				   BLACK_QUEEN_on_BLACK_SQUARE_1
      4  3400				   TEMPORARY_VAR SET	Overlay
      5  3400				   TEMPORARY_OFFSET SET	0
      6  3400				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3400				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_1
      3  3400		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3418		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3448					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm"
      0  3448					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_2", 72
      1  3448
      2  3448				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3448				  -.EARLY_LOCATION SET	*
      4  3448				  -	      ALIGN	256
      5  3448				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3448					      ENDIF
      0  3448					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_2
      1  3448				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3448				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3448				   BLACK_QUEEN_on_BLACK_SQUARE_2
      4  3448				   TEMPORARY_VAR SET	Overlay
      5  3448				   TEMPORARY_OFFSET SET	0
      6  3448				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3448				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_2
      3  3448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3460		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3478		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3490					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm"
      0  3490					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_3", 72
      1  3490
      2  3490				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3490				  -.EARLY_LOCATION SET	*
      4  3490				  -	      ALIGN	256
      5  3490				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3490					      ENDIF
      0  3490					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_3
      1  3490				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3490				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3490				   BLACK_QUEEN_on_BLACK_SQUARE_3
      4  3490				   TEMPORARY_VAR SET	Overlay
      5  3490				   TEMPORARY_OFFSET SET	0
      6  3490				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3490				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_3
      3  3490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  34a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  34c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  34d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_0.asm"
      0  34d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_0", 72
      1  34d8
      2  34d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  34d8				   .EARLY_LOCATION SET	*
      4  3500		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_KING_on_BLACK_SQUARE_0 wasted 40 bytes
      5  3500					      ECHO	"Page break for", "BLACK_KING_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3500					      ENDIF
      0  3500					      DEF	BLACK_KING_on_BLACK_SQUARE_0
      1  3500				   SLOT_BLACK_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3500				   BANK_BLACK_KING_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3500				   BLACK_KING_on_BLACK_SQUARE_0
      4  3500				   TEMPORARY_VAR SET	Overlay
      5  3500				   TEMPORARY_OFFSET SET	0
      6  3500				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3500				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_0
      3  3500		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3518		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3530		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3548					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_1.asm"
      0  3548					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_1", 72
      1  3548
      2  3548				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3548				  -.EARLY_LOCATION SET	*
      4  3548				  -	      ALIGN	256
      5  3548				  -	      ECHO	"Page break for", "BLACK_KING_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3548					      ENDIF
      0  3548					      DEF	BLACK_KING_on_BLACK_SQUARE_1
      1  3548				   SLOT_BLACK_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3548				   BANK_BLACK_KING_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3548				   BLACK_KING_on_BLACK_SQUARE_1
      4  3548				   TEMPORARY_VAR SET	Overlay
      5  3548				   TEMPORARY_OFFSET SET	0
      6  3548				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3548				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_1
      3  3548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3560		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3590					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_2.asm"
      0  3590					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_2", 72
      1  3590
      2  3590				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3590				  -.EARLY_LOCATION SET	*
      4  3590				  -	      ALIGN	256
      5  3590				  -	      ECHO	"Page break for", "BLACK_KING_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3590					      ENDIF
      0  3590					      DEF	BLACK_KING_on_BLACK_SQUARE_2
      1  3590				   SLOT_BLACK_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3590				   BANK_BLACK_KING_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3590				   BLACK_KING_on_BLACK_SQUARE_2
      4  3590				   TEMPORARY_VAR SET	Overlay
      5  3590				   TEMPORARY_OFFSET SET	0
      6  3590				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3590				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_2
      3  3590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  35a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  35c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  35d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_3.asm"
      0  35d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_3", 72
      1  35d8
      2  35d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  35d8				   .EARLY_LOCATION SET	*
      4  3600		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_KING_on_BLACK_SQUARE_3 wasted 40 bytes
      5  3600					      ECHO	"Page break for", "BLACK_KING_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3600					      ENDIF
      0  3600					      DEF	BLACK_KING_on_BLACK_SQUARE_3
      1  3600				   SLOT_BLACK_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3600				   BANK_BLACK_KING_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3600				   BLACK_KING_on_BLACK_SQUARE_3
      4  3600				   TEMPORARY_VAR SET	Overlay
      5  3600				   TEMPORARY_OFFSET SET	0
      6  3600				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3600				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_3
      3  3600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3630		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3648					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm"
      0  3648					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_3", 72
      1  3648
      2  3648				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3648				  -.EARLY_LOCATION SET	*
      4  3648				  -	      ALIGN	256
      5  3648				  -	      ECHO	"Page break for", "WHITE_MARKER_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3648					      ENDIF
      0  3648					      DEF	WHITE_MARKER_on_WHITE_SQUARE_3
      1  3648				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3648				   BANK_WHITE_MARKER_on_WHITE_SQUARE_3 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3648				   WHITE_MARKER_on_WHITE_SQUARE_3
      4  3648				   TEMPORARY_VAR SET	Overlay
      5  3648				   TEMPORARY_OFFSET SET	0
      6  3648				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3648				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_3
      3  3648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3678		       00 20 70 70*	      .byte.b	$00,$20,$70,$70,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3690					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
      0  3690					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_0", 72
      1  3690
      2  3690				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3690				  -.EARLY_LOCATION SET	*
      4  3690				  -	      ALIGN	256
      5  3690				  -	      ECHO	"Page break for", "BLACK_MARKER_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3690					      ENDIF
      0  3690					      DEF	BLACK_MARKER_on_BLACK_SQUARE_0
      1  3690				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3690				   BANK_BLACK_MARKER_on_BLACK_SQUARE_0 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3690				   BLACK_MARKER_on_BLACK_SQUARE_0
      4  3690				   TEMPORARY_VAR SET	Overlay
      5  3690				   TEMPORARY_OFFSET SET	0
      6  3690				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3690				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_0
      3  3690		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  36a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  36c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  36d8					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
      0  36d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_1", 72
      1  36d8
      2  36d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  36d8				   .EARLY_LOCATION SET	*
      4  3700		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_MARKER_on_BLACK_SQUARE_1 wasted 40 bytes
      5  3700					      ECHO	"Page break for", "BLACK_MARKER_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3700					      ENDIF
      0  3700					      DEF	BLACK_MARKER_on_BLACK_SQUARE_1
      1  3700				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3700				   BANK_BLACK_MARKER_on_BLACK_SQUARE_1 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3700				   BLACK_MARKER_on_BLACK_SQUARE_1
      4  3700				   TEMPORARY_VAR SET	Overlay
      5  3700				   TEMPORARY_OFFSET SET	0
      6  3700				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3700				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_1
      3  3700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3718		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3748					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
      0  3748					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_2", 72
      1  3748
      2  3748				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3748				  -.EARLY_LOCATION SET	*
      4  3748				  -	      ALIGN	256
      5  3748				  -	      ECHO	"Page break for", "BLACK_MARKER_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3748					      ENDIF
      0  3748					      DEF	BLACK_MARKER_on_BLACK_SQUARE_2
      1  3748				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3748				   BANK_BLACK_MARKER_on_BLACK_SQUARE_2 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3748				   BLACK_MARKER_on_BLACK_SQUARE_2
      4  3748				   TEMPORARY_VAR SET	Overlay
      5  3748				   TEMPORARY_OFFSET SET	0
      6  3748				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3748				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_2
      3  3748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3760		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3778		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3790					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
      0  3790					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_3", 72
      1  3790
      2  3790				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3790				  -.EARLY_LOCATION SET	*
      4  3790				  -	      ALIGN	256
      5  3790				  -	      ECHO	"Page break for", "BLACK_MARKER_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3790					      ENDIF
      0  3790					      DEF	BLACK_MARKER_on_BLACK_SQUARE_3
      1  3790				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3790				   BANK_BLACK_MARKER_on_BLACK_SQUARE_3 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3790				   BLACK_MARKER_on_BLACK_SQUARE_3
      4  3790				   TEMPORARY_VAR SET	Overlay
      5  3790				   TEMPORARY_OFFSET SET	0
      6  3790				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3790				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_3
      3  3790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  37a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  37c0		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
     70  37d8
      0  37d8					      END_BANK
      1  37d8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  37d8				  -	      CHECK_RAM_BANK_SIZE
      3  37d8					      ELSE
      0  37d8					      CHECK_BANK_SIZE
      1  37d8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 14 GFX3 size = $3d8 free = 39
      2  37d8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  37d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  37d8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  37d8				  -	      ERR
      6  37d8					      ENDIF
      5  37d8					      ENDIF
     72  37d8
     73  37d8
     74  37d8							;---------------------------------------------------------------------------------------------------
     75  37d8
      0  37d8					      ROMBANK	GFX4
      1  3bd8 ????				      SEG	ROM_GFX4
      2  3800					      ORG	_ORIGIN
      3  3800					      RORG	_BANK_ADDRESS_ORIGIN
      4  3800				   _BANK_START SET	*
      5  3800				   GFX4_START SET	*
      6  3800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  3800				   ROMBANK_GFX4 SET	_BANK_SLOT + _CURRENT_BANK
      8  3800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  3800				   _LAST_BANK SETSTR	GFX4
     10  3800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     77  3800
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3800					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
      0  3800					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_0", 72
      1  3800
      2  3800				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3800				  -.EARLY_LOCATION SET	*
      4  3800				  -	      ALIGN	256
      5  3800				  -	      ECHO	"Page break for", "BLACK_MARKER_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3800					      ENDIF
      0  3800					      DEF	BLACK_MARKER_on_WHITE_SQUARE_0
      1  3800				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3800				   BANK_BLACK_MARKER_on_WHITE_SQUARE_0 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3800				   BLACK_MARKER_on_WHITE_SQUARE_0
      4  3800				   TEMPORARY_VAR SET	Overlay
      5  3800				   TEMPORARY_OFFSET SET	0
      6  3800				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3800				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_0
      3  3800		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00	;PF0
      4  3818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3848					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
      0  3848					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_1", 72
      1  3848
      2  3848				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3848				  -.EARLY_LOCATION SET	*
      4  3848				  -	      ALIGN	256
      5  3848				  -	      ECHO	"Page break for", "BLACK_MARKER_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3848					      ENDIF
      0  3848					      DEF	BLACK_MARKER_on_WHITE_SQUARE_1
      1  3848				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3848				   BANK_BLACK_MARKER_on_WHITE_SQUARE_1 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3848				   BLACK_MARKER_on_WHITE_SQUARE_1
      4  3848				   TEMPORARY_VAR SET	Overlay
      5  3848				   TEMPORARY_OFFSET SET	0
      6  3848				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3848				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_1
      3  3848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3860		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00	;PF1
      5  3878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3890					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
      0  3890					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_2", 72
      1  3890
      2  3890				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3890				  -.EARLY_LOCATION SET	*
      4  3890				  -	      ALIGN	256
      5  3890				  -	      ECHO	"Page break for", "BLACK_MARKER_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3890					      ENDIF
      0  3890					      DEF	BLACK_MARKER_on_WHITE_SQUARE_2
      1  3890				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3890				   BANK_BLACK_MARKER_on_WHITE_SQUARE_2 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3890				   BLACK_MARKER_on_WHITE_SQUARE_2
      4  3890				   TEMPORARY_VAR SET	Overlay
      5  3890				   TEMPORARY_OFFSET SET	0
      6  3890				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3890				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_2
      3  3890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  38a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  38c0		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  38d8					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
      0  38d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_3", 72
      1  38d8
      2  38d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  38d8				   .EARLY_LOCATION SET	*
      4  3900		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_MARKER_on_WHITE_SQUARE_3 wasted 40 bytes
      5  3900					      ECHO	"Page break for", "BLACK_MARKER_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3900					      ENDIF
      0  3900					      DEF	BLACK_MARKER_on_WHITE_SQUARE_3
      1  3900				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3900				   BANK_BLACK_MARKER_on_WHITE_SQUARE_3 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3900				   BLACK_MARKER_on_WHITE_SQUARE_3
      4  3900				   TEMPORARY_VAR SET	Overlay
      5  3900				   TEMPORARY_OFFSET SET	0
      6  3900				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3900				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_3
      3  3900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3930		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3948					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  3948					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_0", 72
      1  3948
      2  3948				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3948				  -.EARLY_LOCATION SET	*
      4  3948				  -	      ALIGN	256
      5  3948				  -	      ECHO	"Page break for", "WHITE_PROMOTE_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3948					      ENDIF
      0  3948					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_0
      1  3948				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3948				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3948				   WHITE_PROMOTE_on_BLACK_SQUARE_0
      4  3948				   TEMPORARY_VAR SET	Overlay
      5  3948				   TEMPORARY_OFFSET SET	0
      6  3948				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3948				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_0
      3  3948		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  3960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3990					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  3990					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_1", 72
      1  3990
      2  3990				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3990				  -.EARLY_LOCATION SET	*
      4  3990				  -	      ALIGN	256
      5  3990				  -	      ECHO	"Page break for", "WHITE_PROMOTE_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3990					      ENDIF
      0  3990					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_1
      1  3990				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3990				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3990				   WHITE_PROMOTE_on_BLACK_SQUARE_1
      4  3990				   TEMPORARY_VAR SET	Overlay
      5  3990				   TEMPORARY_OFFSET SET	0
      6  3990				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3990				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_1
      3  3990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  39a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  39c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  39d8					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  39d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_2", 72
      1  39d8
      2  39d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  39d8				   .EARLY_LOCATION SET	*
      4  3a00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_PROMOTE_on_BLACK_SQUARE_2 wasted 40 bytes
      5  3a00					      ECHO	"Page break for", "WHITE_PROMOTE_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3a00					      ENDIF
      0  3a00					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_2
      1  3a00				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3a00				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3a00				   WHITE_PROMOTE_on_BLACK_SQUARE_2
      4  3a00				   TEMPORARY_VAR SET	Overlay
      5  3a00				   TEMPORARY_OFFSET SET	0
      6  3a00				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3a00				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_2
      3  3a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  3a30		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3a48					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  3a48					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_3", 72
      1  3a48
      2  3a48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3a48				  -.EARLY_LOCATION SET	*
      4  3a48				  -	      ALIGN	256
      5  3a48				  -	      ECHO	"Page break for", "WHITE_PROMOTE_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3a48					      ENDIF
      0  3a48					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_3
      1  3a48				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3a48				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3a48				   WHITE_PROMOTE_on_BLACK_SQUARE_3
      4  3a48				   TEMPORARY_VAR SET	Overlay
      5  3a48				   TEMPORARY_OFFSET SET	0
      6  3a48				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3a48				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_3
      3  3a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3a78		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3a90					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  3a90					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_0", 72
      1  3a90
      2  3a90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3a90				  -.EARLY_LOCATION SET	*
      4  3a90				  -	      ALIGN	256
      5  3a90				  -	      ECHO	"Page break for", "WHITE_PROMOTE_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3a90					      ENDIF
      0  3a90					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_0
      1  3a90				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3a90				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3a90				   WHITE_PROMOTE_on_WHITE_SQUARE_0
      4  3a90				   TEMPORARY_VAR SET	Overlay
      5  3a90				   TEMPORARY_OFFSET SET	0
      6  3a90				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3a90				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_0
      3  3a90		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ad8					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  3ad8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_1", 72
      1  3ad8
      2  3ad8					      IF	(>( * + 72 -1 )) > ( >* )
      3  3ad8				   .EARLY_LOCATION SET	*
      4  3b00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_PROMOTE_on_WHITE_SQUARE_1 wasted 40 bytes
      5  3b00					      ECHO	"Page break for", "WHITE_PROMOTE_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3b00					      ENDIF
      0  3b00					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_1
      1  3b00				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3b00				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3b00				   WHITE_PROMOTE_on_WHITE_SQUARE_1
      4  3b00				   TEMPORARY_VAR SET	Overlay
      5  3b00				   TEMPORARY_OFFSET SET	0
      6  3b00				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3b00				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_1
      3  3b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b18		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3b48					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  3b48					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_2", 72
      1  3b48
      2  3b48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3b48				  -.EARLY_LOCATION SET	*
      4  3b48				  -	      ALIGN	256
      5  3b48				  -	      ECHO	"Page break for", "WHITE_PROMOTE_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3b48					      ENDIF
      0  3b48					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_2
      1  3b48				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3b48				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3b48				   WHITE_PROMOTE_on_WHITE_SQUARE_2
      4  3b48				   TEMPORARY_VAR SET	Overlay
      5  3b48				   TEMPORARY_OFFSET SET	0
      6  3b48				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3b48				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_2
      3  3b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3b78		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3b90					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  3b90					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_3", 72
      1  3b90
      2  3b90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3b90				  -.EARLY_LOCATION SET	*
      4  3b90				  -	      ALIGN	256
      5  3b90				  -	      ECHO	"Page break for", "WHITE_PROMOTE_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3b90					      ENDIF
      0  3b90					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_3
      1  3b90				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3b90				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3b90				   WHITE_PROMOTE_on_WHITE_SQUARE_3
      4  3b90				   TEMPORARY_VAR SET	Overlay
      5  3b90				   TEMPORARY_OFFSET SET	0
      6  3b90				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3b90				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_3
      3  3b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3bc0		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
     90  3bd8
      0  3bd8					      END_BANK
      1  3bd8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  3bd8				  -	      CHECK_RAM_BANK_SIZE
      3  3bd8					      ELSE
      0  3bd8					      CHECK_BANK_SIZE
      1  3bd8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 15 GFX4 size = $3d8 free = 39
      2  3bd8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  3bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3bd8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  3bd8				  -	      ERR
      6  3bd8					      ENDIF
      5  3bd8					      ENDIF
     92  3bd8
     93  3bd8
     94  3bd8							;---------------------------------------------------------------------------------------------------
     95  3bd8
      0  3bd8					      ROMBANK	PIECES_0
      1  3fd8 ????				      SEG	ROM_PIECES_0
      2  3c00					      ORG	_ORIGIN
      3  3c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  3c00				   _BANK_START SET	*
      5  3c00				   PIECES_0_START SET	*
      6  3c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  3c00				   ROMBANK_PIECES_0 SET	_BANK_SLOT + _CURRENT_BANK
      8  3c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  3c00				   _LAST_BANK SETSTR	PIECES_0
     10  3c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     97  3c00
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3c00					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm"
      0  3c00					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_0", 72
      1  3c00
      2  3c00				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3c00				  -.EARLY_LOCATION SET	*
      4  3c00				  -	      ALIGN	256
      5  3c00				  -	      ECHO	"Page break for", "WHITE_BLANK_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3c00					      ENDIF
      0  3c00					      DEF	WHITE_BLANK_on_WHITE_SQUARE_0
      1  3c00				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3c00				   BANK_WHITE_BLANK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3c00				   WHITE_BLANK_on_WHITE_SQUARE_0
      4  3c00				   TEMPORARY_VAR SET	Overlay
      5  3c00				   TEMPORARY_OFFSET SET	0
      6  3c00				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3c00				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_0
      3  3c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  3c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  3c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3c48					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm"
      0  3c48					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_1", 72
      1  3c48
      2  3c48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3c48				  -.EARLY_LOCATION SET	*
      4  3c48				  -	      ALIGN	256
      5  3c48				  -	      ECHO	"Page break for", "WHITE_BLANK_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3c48					      ENDIF
      0  3c48					      DEF	WHITE_BLANK_on_WHITE_SQUARE_1
      1  3c48				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3c48				   BANK_WHITE_BLANK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3c48				   WHITE_BLANK_on_WHITE_SQUARE_1
      4  3c48				   TEMPORARY_VAR SET	Overlay
      5  3c48				   TEMPORARY_OFFSET SET	0
      6  3c48				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3c48				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_1
      3  3c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3c60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  3c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3c90					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm"
      0  3c90					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_2", 72
      1  3c90
      2  3c90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3c90				  -.EARLY_LOCATION SET	*
      4  3c90				  -	      ALIGN	256
      5  3c90				  -	      ECHO	"Page break for", "WHITE_BLANK_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3c90					      ENDIF
      0  3c90					      DEF	WHITE_BLANK_on_WHITE_SQUARE_2
      1  3c90				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3c90				   BANK_WHITE_BLANK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3c90				   WHITE_BLANK_on_WHITE_SQUARE_2
      4  3c90				   TEMPORARY_VAR SET	Overlay
      5  3c90				   TEMPORARY_OFFSET SET	0
      6  3c90				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3c90				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_2
      3  3c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  3cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3cd8					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm"
      0  3cd8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_3", 72
      1  3cd8
      2  3cd8					      IF	(>( * + 72 -1 )) > ( >* )
      3  3cd8				   .EARLY_LOCATION SET	*
      4  3d00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_BLANK_on_WHITE_SQUARE_3 wasted 40 bytes
      5  3d00					      ECHO	"Page break for", "WHITE_BLANK_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3d00					      ENDIF
      0  3d00					      DEF	WHITE_BLANK_on_WHITE_SQUARE_3
      1  3d00				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3d00				   BANK_WHITE_BLANK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3d00				   WHITE_BLANK_on_WHITE_SQUARE_3
      4  3d00				   TEMPORARY_VAR SET	Overlay
      5  3d00				   TEMPORARY_OFFSET SET	0
      6  3d00				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3d00				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_3
      3  3d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3d48					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm"
      0  3d48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_0", 72
      1  3d48
      2  3d48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3d48				  -.EARLY_LOCATION SET	*
      4  3d48				  -	      ALIGN	256
      5  3d48				  -	      ECHO	"Page break for", "WHITE_PAWN_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3d48					      ENDIF
      0  3d48					      DEF	WHITE_PAWN_on_WHITE_SQUARE_0
      1  3d48				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3d48				   BANK_WHITE_PAWN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3d48				   WHITE_PAWN_on_WHITE_SQUARE_0
      4  3d48				   TEMPORARY_VAR SET	Overlay
      5  3d48				   TEMPORARY_OFFSET SET	0
      6  3d48				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3d48				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_0
      3  3d48		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3d90					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm"
      0  3d90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_1", 72
      1  3d90
      2  3d90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3d90				  -.EARLY_LOCATION SET	*
      4  3d90				  -	      ALIGN	256
      5  3d90				  -	      ECHO	"Page break for", "WHITE_PAWN_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3d90					      ENDIF
      0  3d90					      DEF	WHITE_PAWN_on_WHITE_SQUARE_1
      1  3d90				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3d90				   BANK_WHITE_PAWN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3d90				   WHITE_PAWN_on_WHITE_SQUARE_1
      4  3d90				   TEMPORARY_VAR SET	Overlay
      5  3d90				   TEMPORARY_OFFSET SET	0
      6  3d90				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3d90				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_1
      3  3d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3da8		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3dd8					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm"
      0  3dd8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_2", 72
      1  3dd8
      2  3dd8					      IF	(>( * + 72 -1 )) > ( >* )
      3  3dd8				   .EARLY_LOCATION SET	*
      4  3e00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_PAWN_on_WHITE_SQUARE_2 wasted 40 bytes
      5  3e00					      ECHO	"Page break for", "WHITE_PAWN_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3e00					      ENDIF
      0  3e00					      DEF	WHITE_PAWN_on_WHITE_SQUARE_2
      1  3e00				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3e00				   BANK_WHITE_PAWN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3e00				   WHITE_PAWN_on_WHITE_SQUARE_2
      4  3e00				   TEMPORARY_VAR SET	Overlay
      5  3e00				   TEMPORARY_OFFSET SET	0
      6  3e00				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3e00				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_2
      3  3e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e18		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e30		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3e48					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm"
      0  3e48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_3", 72
      1  3e48
      2  3e48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3e48				  -.EARLY_LOCATION SET	*
      4  3e48				  -	      ALIGN	256
      5  3e48				  -	      ECHO	"Page break for", "WHITE_PAWN_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3e48					      ENDIF
      0  3e48					      DEF	WHITE_PAWN_on_WHITE_SQUARE_3
      1  3e48				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3e48				   BANK_WHITE_PAWN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3e48				   WHITE_PAWN_on_WHITE_SQUARE_3
      4  3e48				   TEMPORARY_VAR SET	Overlay
      5  3e48				   TEMPORARY_OFFSET SET	0
      6  3e48				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3e48				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_3
      3  3e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e78		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3e90					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  3e90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_0", 72
      1  3e90
      2  3e90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3e90				  -.EARLY_LOCATION SET	*
      4  3e90				  -	      ALIGN	256
      5  3e90				  -	      ECHO	"Page break for", "WHITE_KNIGHT_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3e90					      ENDIF
      0  3e90					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_0
      1  3e90				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3e90				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3e90				   WHITE_KNIGHT_on_WHITE_SQUARE_0
      4  3e90				   TEMPORARY_VAR SET	Overlay
      5  3e90				   TEMPORARY_OFFSET SET	0
      6  3e90				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3e90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_0
      3  3e90		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ea8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ed8					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  3ed8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_1", 72
      1  3ed8
      2  3ed8					      IF	(>( * + 72 -1 )) > ( >* )
      3  3ed8				   .EARLY_LOCATION SET	*
      4  3f00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_KNIGHT_on_WHITE_SQUARE_1 wasted 40 bytes
      5  3f00					      ECHO	"Page break for", "WHITE_KNIGHT_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3f00					      ENDIF
      0  3f00					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_1
      1  3f00				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3f00				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3f00				   WHITE_KNIGHT_on_WHITE_SQUARE_1
      4  3f00				   TEMPORARY_VAR SET	Overlay
      5  3f00				   TEMPORARY_OFFSET SET	0
      6  3f00				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3f00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_1
      3  3f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f18		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3f48					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  3f48					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_2", 72
      1  3f48
      2  3f48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3f48				  -.EARLY_LOCATION SET	*
      4  3f48				  -	      ALIGN	256
      5  3f48				  -	      ECHO	"Page break for", "WHITE_KNIGHT_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3f48					      ENDIF
      0  3f48					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_2
      1  3f48				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3f48				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3f48				   WHITE_KNIGHT_on_WHITE_SQUARE_2
      4  3f48				   TEMPORARY_VAR SET	Overlay
      5  3f48				   TEMPORARY_OFFSET SET	0
      6  3f48				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3f48				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_2
      3  3f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f60		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3f78		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3f90					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  3f90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_3", 72
      1  3f90
      2  3f90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3f90				  -.EARLY_LOCATION SET	*
      4  3f90				  -	      ALIGN	256
      5  3f90				  -	      ECHO	"Page break for", "WHITE_KNIGHT_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3f90					      ENDIF
      0  3f90					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_3
      1  3f90				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3f90				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3f90				   WHITE_KNIGHT_on_WHITE_SQUARE_3
      4  3f90				   TEMPORARY_VAR SET	Overlay
      5  3f90				   TEMPORARY_OFFSET SET	0
      6  3f90				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3f90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_3
      3  3f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3fc0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
    110  3fd8
      0  3fd8					      END_BANK
      1  3fd8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  3fd8				  -	      CHECK_RAM_BANK_SIZE
      3  3fd8					      ELSE
      0  3fd8					      CHECK_BANK_SIZE
      1  3fd8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 16 PIECES_0 size = $3d8 free = 39
      2  3fd8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  3fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3fd8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  3fd8				  -	      ERR
      6  3fd8					      ENDIF
      5  3fd8					      ENDIF
    112  3fd8
    113  3fd8
    114  3fd8							;---------------------------------------------------------------------------------------------------
    115  3fd8
      0  3fd8					      ROMBANK	PIECES_1
      1  43d8 ????				      SEG	ROM_PIECES_1
      2  4000					      ORG	_ORIGIN
      3  4000					      RORG	_BANK_ADDRESS_ORIGIN
      4  4000				   _BANK_START SET	*
      5  4000				   PIECES_1_START SET	*
      6  4000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  4000				   ROMBANK_PIECES_1 SET	_BANK_SLOT + _CURRENT_BANK
      8  4000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  4000				   _LAST_BANK SETSTR	PIECES_1
     10  4000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    117  4000
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4000					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm"
      0  4000					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_0", 72
      1  4000
      2  4000				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4000				  -.EARLY_LOCATION SET	*
      4  4000				  -	      ALIGN	256
      5  4000				  -	      ECHO	"Page break for", "WHITE_BISHOP_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4000					      ENDIF
      0  4000					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_0
      1  4000				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4000				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4000				   WHITE_BISHOP_on_WHITE_SQUARE_0
      4  4000				   TEMPORARY_VAR SET	Overlay
      5  4000				   TEMPORARY_OFFSET SET	0
      6  4000				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4000				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_0
      3  4000		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$40,$20,$00,$00,$00	;PF0
      4  4018		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4048					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm"
      0  4048					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_1", 72
      1  4048
      2  4048				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4048				  -.EARLY_LOCATION SET	*
      4  4048				  -	      ALIGN	256
      5  4048				  -	      ECHO	"Page break for", "WHITE_BISHOP_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4048					      ENDIF
      0  4048					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_1
      1  4048				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4048				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4048				   WHITE_BISHOP_on_WHITE_SQUARE_1
      4  4048				   TEMPORARY_VAR SET	Overlay
      5  4048				   TEMPORARY_OFFSET SET	0
      6  4048				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4048				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_1
      3  4048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4060		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$10,$20,$00,$00,$00	;PF1
      5  4078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4090					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm"
      0  4090					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_2", 72
      1  4090
      2  4090				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4090				  -.EARLY_LOCATION SET	*
      4  4090				  -	      ALIGN	256
      5  4090				  -	      ECHO	"Page break for", "WHITE_BISHOP_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4090					      ENDIF
      0  4090					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_2
      1  4090				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4090				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4090				   WHITE_BISHOP_on_WHITE_SQUARE_2
      4  4090				   TEMPORARY_VAR SET	Overlay
      5  4090				   TEMPORARY_OFFSET SET	0
      6  4090				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4090				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_2
      3  4090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  40a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$01,$00,$00,$00	;PF1
      5  40c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$01,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  40d8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm"
      0  40d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_3", 72
      1  40d8
      2  40d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  40d8				   .EARLY_LOCATION SET	*
      4  4100		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_BISHOP_on_WHITE_SQUARE_3 wasted 40 bytes
      5  4100					      ECHO	"Page break for", "WHITE_BISHOP_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4100					      ENDIF
      0  4100					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_3
      1  4100				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4100				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4100				   WHITE_BISHOP_on_WHITE_SQUARE_3
      4  4100				   TEMPORARY_VAR SET	Overlay
      5  4100				   TEMPORARY_OFFSET SET	0
      6  4100				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4100				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_3
      3  4100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4130		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$20,$10,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4148					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm"
      0  4148					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_0", 72
      1  4148
      2  4148				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4148				  -.EARLY_LOCATION SET	*
      4  4148				  -	      ALIGN	256
      5  4148				  -	      ECHO	"Page break for", "WHITE_ROOK_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4148					      ENDIF
      0  4148					      DEF	WHITE_ROOK_on_WHITE_SQUARE_0
      1  4148				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4148				   BANK_WHITE_ROOK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4148				   WHITE_ROOK_on_WHITE_SQUARE_0
      4  4148				   TEMPORARY_VAR SET	Overlay
      5  4148				   TEMPORARY_OFFSET SET	0
      6  4148				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4148				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_0
      3  4148		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4160		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4190					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm"
      0  4190					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_1", 72
      1  4190
      2  4190				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4190				  -.EARLY_LOCATION SET	*
      4  4190				  -	      ALIGN	256
      5  4190				  -	      ECHO	"Page break for", "WHITE_ROOK_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4190					      ENDIF
      0  4190					      DEF	WHITE_ROOK_on_WHITE_SQUARE_1
      1  4190				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4190				   BANK_WHITE_ROOK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4190				   WHITE_ROOK_on_WHITE_SQUARE_1
      4  4190				   TEMPORARY_VAR SET	Overlay
      5  4190				   TEMPORARY_OFFSET SET	0
      6  4190				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4190				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_1
      3  4190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  41a8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  41c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  41d8					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm"
      0  41d8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_2", 72
      1  41d8
      2  41d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  41d8				   .EARLY_LOCATION SET	*
      4  4200		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_ROOK_on_WHITE_SQUARE_2 wasted 40 bytes
      5  4200					      ECHO	"Page break for", "WHITE_ROOK_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4200					      ENDIF
      0  4200					      DEF	WHITE_ROOK_on_WHITE_SQUARE_2
      1  4200				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4200				   BANK_WHITE_ROOK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4200				   WHITE_ROOK_on_WHITE_SQUARE_2
      4  4200				   TEMPORARY_VAR SET	Overlay
      5  4200				   TEMPORARY_OFFSET SET	0
      6  4200				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4200				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_2
      3  4200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4218		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4230		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4248					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm"
      0  4248					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_3", 72
      1  4248
      2  4248				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4248				  -.EARLY_LOCATION SET	*
      4  4248				  -	      ALIGN	256
      5  4248				  -	      ECHO	"Page break for", "WHITE_ROOK_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4248					      ENDIF
      0  4248					      DEF	WHITE_ROOK_on_WHITE_SQUARE_3
      1  4248				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4248				   BANK_WHITE_ROOK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4248				   WHITE_ROOK_on_WHITE_SQUARE_3
      4  4248				   TEMPORARY_VAR SET	Overlay
      5  4248				   TEMPORARY_OFFSET SET	0
      6  4248				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4248				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_3
      3  4248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4278		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4290					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm"
      0  4290					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_0", 72
      1  4290
      2  4290				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4290				  -.EARLY_LOCATION SET	*
      4  4290				  -	      ALIGN	256
      5  4290				  -	      ECHO	"Page break for", "WHITE_QUEEN_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4290					      ENDIF
      0  4290					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_0
      1  4290				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4290				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4290				   WHITE_QUEEN_on_WHITE_SQUARE_0
      4  4290				   TEMPORARY_VAR SET	Overlay
      5  4290				   TEMPORARY_OFFSET SET	0
      6  4290				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4290				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_0
      3  4290		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  42a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  42c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  42d8					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm"
      0  42d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_1", 72
      1  42d8
      2  42d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  42d8				   .EARLY_LOCATION SET	*
      4  4300		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_QUEEN_on_WHITE_SQUARE_1 wasted 40 bytes
      5  4300					      ECHO	"Page break for", "WHITE_QUEEN_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4300					      ENDIF
      0  4300					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_1
      1  4300				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4300				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4300				   WHITE_QUEEN_on_WHITE_SQUARE_1
      4  4300				   TEMPORARY_VAR SET	Overlay
      5  4300				   TEMPORARY_OFFSET SET	0
      6  4300				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4300				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_1
      3  4300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4318		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4348					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm"
      0  4348					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_2", 72
      1  4348
      2  4348				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4348				  -.EARLY_LOCATION SET	*
      4  4348				  -	      ALIGN	256
      5  4348				  -	      ECHO	"Page break for", "WHITE_QUEEN_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4348					      ENDIF
      0  4348					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_2
      1  4348				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4348				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4348				   WHITE_QUEEN_on_WHITE_SQUARE_2
      4  4348				   TEMPORARY_VAR SET	Overlay
      5  4348				   TEMPORARY_OFFSET SET	0
      6  4348				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4348				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_2
      3  4348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4360		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4378		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4390					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm"
      0  4390					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_3", 72
      1  4390
      2  4390				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4390				  -.EARLY_LOCATION SET	*
      4  4390				  -	      ALIGN	256
      5  4390				  -	      ECHO	"Page break for", "WHITE_QUEEN_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4390					      ENDIF
      0  4390					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_3
      1  4390				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4390				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4390				   WHITE_QUEEN_on_WHITE_SQUARE_3
      4  4390				   TEMPORARY_VAR SET	Overlay
      5  4390				   TEMPORARY_OFFSET SET	0
      6  4390				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4390				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_3
      3  4390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  43a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  43c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
    130  43d8
      0  43d8					      END_BANK
      1  43d8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  43d8				  -	      CHECK_RAM_BANK_SIZE
      3  43d8					      ELSE
      0  43d8					      CHECK_BANK_SIZE
      1  43d8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 17 PIECES_1 size = $3d8 free = 39
      2  43d8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  43d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  43d8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  43d8				  -	      ERR
      6  43d8					      ENDIF
      5  43d8					      ENDIF
    132  43d8
    133  43d8
    134  43d8							;---------------------------------------------------------------------------------------------------
    135  43d8
      0  43d8					      ROMBANK	PIECES_2
      1  47d8 ????				      SEG	ROM_PIECES_2
      2  4400					      ORG	_ORIGIN
      3  4400					      RORG	_BANK_ADDRESS_ORIGIN
      4  4400				   _BANK_START SET	*
      5  4400				   PIECES_2_START SET	*
      6  4400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  4400				   ROMBANK_PIECES_2 SET	_BANK_SLOT + _CURRENT_BANK
      8  4400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  4400				   _LAST_BANK SETSTR	PIECES_2
     10  4400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    137  4400
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4400					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_0.asm"
      0  4400					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_0", 72
      1  4400
      2  4400				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4400				  -.EARLY_LOCATION SET	*
      4  4400				  -	      ALIGN	256
      5  4400				  -	      ECHO	"Page break for", "WHITE_KING_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4400					      ENDIF
      0  4400					      DEF	WHITE_KING_on_WHITE_SQUARE_0
      1  4400				   SLOT_WHITE_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4400				   BANK_WHITE_KING_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4400				   WHITE_KING_on_WHITE_SQUARE_0
      4  4400				   TEMPORARY_VAR SET	Overlay
      5  4400				   TEMPORARY_OFFSET SET	0
      6  4400				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4400				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_0
      3  4400		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$80,$40,$00,$00	;PF0
      4  4418		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4448					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_1.asm"
      0  4448					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_1", 72
      1  4448
      2  4448				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4448				  -.EARLY_LOCATION SET	*
      4  4448				  -	      ALIGN	256
      5  4448				  -	      ECHO	"Page break for", "WHITE_KING_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4448					      ENDIF
      0  4448					      DEF	WHITE_KING_on_WHITE_SQUARE_1
      1  4448				   SLOT_WHITE_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4448				   BANK_WHITE_KING_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4448				   WHITE_KING_on_WHITE_SQUARE_1
      4  4448				   TEMPORARY_VAR SET	Overlay
      5  4448				   TEMPORARY_OFFSET SET	0
      6  4448				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4448				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_1
      3  4448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4460		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$08,$10,$00,$00	;PF1
      5  4478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4490					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_2.asm"
      0  4490					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_2", 72
      1  4490
      2  4490				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4490				  -.EARLY_LOCATION SET	*
      4  4490				  -	      ALIGN	256
      5  4490				  -	      ECHO	"Page break for", "WHITE_KING_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4490					      ENDIF
      0  4490					      DEF	WHITE_KING_on_WHITE_SQUARE_2
      1  4490				   SLOT_WHITE_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4490				   BANK_WHITE_KING_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4490				   WHITE_KING_on_WHITE_SQUARE_2
      4  4490				   TEMPORARY_VAR SET	Overlay
      5  4490				   TEMPORARY_OFFSET SET	0
      6  4490				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4490				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_2
      3  4490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  44a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  44c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$02,$01,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  44d8					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_3.asm"
      0  44d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_3", 72
      1  44d8
      2  44d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  44d8				   .EARLY_LOCATION SET	*
      4  4500		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_KING_on_WHITE_SQUARE_3 wasted 40 bytes
      5  4500					      ECHO	"Page break for", "WHITE_KING_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4500					      ENDIF
      0  4500					      DEF	WHITE_KING_on_WHITE_SQUARE_3
      1  4500				   SLOT_WHITE_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4500				   BANK_WHITE_KING_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4500				   WHITE_KING_on_WHITE_SQUARE_3
      4  4500				   TEMPORARY_VAR SET	Overlay
      5  4500				   TEMPORARY_OFFSET SET	0
      6  4500				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4500				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_3
      3  4500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4530		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$40,$20,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4548					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm"
      0  4548					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_0", 72
      1  4548
      2  4548				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4548				  -.EARLY_LOCATION SET	*
      4  4548				  -	      ALIGN	256
      5  4548				  -	      ECHO	"Page break for", "WHITE_BLANK_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4548					      ENDIF
      0  4548					      DEF	WHITE_BLANK_on_BLACK_SQUARE_0
      1  4548				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4548				   BANK_WHITE_BLANK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4548				   WHITE_BLANK_on_BLACK_SQUARE_0
      4  4548				   TEMPORARY_VAR SET	Overlay
      5  4548				   TEMPORARY_OFFSET SET	0
      6  4548				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4548				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_0
      3  4548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4590					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm"
      0  4590					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_1", 72
      1  4590
      2  4590				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4590				  -.EARLY_LOCATION SET	*
      4  4590				  -	      ALIGN	256
      5  4590				  -	      ECHO	"Page break for", "WHITE_BLANK_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4590					      ENDIF
      0  4590					      DEF	WHITE_BLANK_on_BLACK_SQUARE_1
      1  4590				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4590				   BANK_WHITE_BLANK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4590				   WHITE_BLANK_on_BLACK_SQUARE_1
      4  4590				   TEMPORARY_VAR SET	Overlay
      5  4590				   TEMPORARY_OFFSET SET	0
      6  4590				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4590				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_1
      3  4590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  45a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  45c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  45d8					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm"
      0  45d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_2", 72
      1  45d8
      2  45d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  45d8				   .EARLY_LOCATION SET	*
      4  4600		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_BLANK_on_BLACK_SQUARE_2 wasted 40 bytes
      5  4600					      ECHO	"Page break for", "WHITE_BLANK_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4600					      ENDIF
      0  4600					      DEF	WHITE_BLANK_on_BLACK_SQUARE_2
      1  4600				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4600				   BANK_WHITE_BLANK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4600				   WHITE_BLANK_on_BLACK_SQUARE_2
      4  4600				   TEMPORARY_VAR SET	Overlay
      5  4600				   TEMPORARY_OFFSET SET	0
      6  4600				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4600				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_2
      3  4600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4630		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4648					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm"
      0  4648					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_3", 72
      1  4648
      2  4648				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4648				  -.EARLY_LOCATION SET	*
      4  4648				  -	      ALIGN	256
      5  4648				  -	      ECHO	"Page break for", "WHITE_BLANK_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4648					      ENDIF
      0  4648					      DEF	WHITE_BLANK_on_BLACK_SQUARE_3
      1  4648				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4648				   BANK_WHITE_BLANK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4648				   WHITE_BLANK_on_BLACK_SQUARE_3
      4  4648				   TEMPORARY_VAR SET	Overlay
      5  4648				   TEMPORARY_OFFSET SET	0
      6  4648				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4648				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_3
      3  4648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4678		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4690					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm"
      0  4690					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_0", 72
      1  4690
      2  4690				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4690				  -.EARLY_LOCATION SET	*
      4  4690				  -	      ALIGN	256
      5  4690				  -	      ECHO	"Page break for", "WHITE_PAWN_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4690					      ENDIF
      0  4690					      DEF	WHITE_PAWN_on_BLACK_SQUARE_0
      1  4690				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4690				   BANK_WHITE_PAWN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4690				   WHITE_PAWN_on_BLACK_SQUARE_0
      4  4690				   TEMPORARY_VAR SET	Overlay
      5  4690				   TEMPORARY_OFFSET SET	0
      6  4690				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4690				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_0
      3  4690		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  46a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  46c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  46d8					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm"
      0  46d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_1", 72
      1  46d8
      2  46d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  46d8				   .EARLY_LOCATION SET	*
      4  4700		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_PAWN_on_BLACK_SQUARE_1 wasted 40 bytes
      5  4700					      ECHO	"Page break for", "WHITE_PAWN_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4700					      ENDIF
      0  4700					      DEF	WHITE_PAWN_on_BLACK_SQUARE_1
      1  4700				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4700				   BANK_WHITE_PAWN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4700				   WHITE_PAWN_on_BLACK_SQUARE_1
      4  4700				   TEMPORARY_VAR SET	Overlay
      5  4700				   TEMPORARY_OFFSET SET	0
      6  4700				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4700				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_1
      3  4700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4718		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  4730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4748					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm"
      0  4748					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_2", 72
      1  4748
      2  4748				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4748				  -.EARLY_LOCATION SET	*
      4  4748				  -	      ALIGN	256
      5  4748				  -	      ECHO	"Page break for", "WHITE_PAWN_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4748					      ENDIF
      0  4748					      DEF	WHITE_PAWN_on_BLACK_SQUARE_2
      1  4748				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4748				   BANK_WHITE_PAWN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4748				   WHITE_PAWN_on_BLACK_SQUARE_2
      4  4748				   TEMPORARY_VAR SET	Overlay
      5  4748				   TEMPORARY_OFFSET SET	0
      6  4748				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4748				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_2
      3  4748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4760		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  4778		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4790					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm"
      0  4790					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_3", 72
      1  4790
      2  4790				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4790				  -.EARLY_LOCATION SET	*
      4  4790				  -	      ALIGN	256
      5  4790				  -	      ECHO	"Page break for", "WHITE_PAWN_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4790					      ENDIF
      0  4790					      DEF	WHITE_PAWN_on_BLACK_SQUARE_3
      1  4790				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4790				   BANK_WHITE_PAWN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4790				   WHITE_PAWN_on_BLACK_SQUARE_3
      4  4790				   TEMPORARY_VAR SET	Overlay
      5  4790				   TEMPORARY_OFFSET SET	0
      6  4790				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4790				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_3
      3  4790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  47a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  47c0		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
    150  47d8
      0  47d8					      END_BANK
      1  47d8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  47d8				  -	      CHECK_RAM_BANK_SIZE
      3  47d8					      ELSE
      0  47d8					      CHECK_BANK_SIZE
      1  47d8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 18 PIECES_2 size = $3d8 free = 39
      2  47d8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  47d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  47d8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  47d8				  -	      ERR
      6  47d8					      ENDIF
      5  47d8					      ENDIF
    152  47d8
    153  47d8
    154  47d8							;---------------------------------------------------------------------------------------------------
    155  47d8
      0  47d8					      ROMBANK	PIECES_3
      1  4bd8 ????				      SEG	ROM_PIECES_3
      2  4800					      ORG	_ORIGIN
      3  4800					      RORG	_BANK_ADDRESS_ORIGIN
      4  4800				   _BANK_START SET	*
      5  4800				   PIECES_3_START SET	*
      6  4800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  4800				   ROMBANK_PIECES_3 SET	_BANK_SLOT + _CURRENT_BANK
      8  4800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  4800				   _LAST_BANK SETSTR	PIECES_3
     10  4800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    157  4800
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4800					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  4800					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_0", 72
      1  4800
      2  4800				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4800				  -.EARLY_LOCATION SET	*
      4  4800				  -	      ALIGN	256
      5  4800				  -	      ECHO	"Page break for", "WHITE_KNIGHT_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4800					      ENDIF
      0  4800					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_0
      1  4800				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4800				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4800				   WHITE_KNIGHT_on_BLACK_SQUARE_0
      4  4800				   TEMPORARY_VAR SET	Overlay
      5  4800				   TEMPORARY_OFFSET SET	0
      6  4800				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4800				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_0
      3  4800		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$f0,$e0,$e0,$f0,$f0,$40,$00	;PF0
      4  4818		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  4830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4848					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  4848					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_1", 72
      1  4848
      2  4848				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4848				  -.EARLY_LOCATION SET	*
      4  4848				  -	      ALIGN	256
      5  4848				  -	      ECHO	"Page break for", "WHITE_KNIGHT_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4848					      ENDIF
      0  4848					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_1
      1  4848				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4848				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4848				   WHITE_KNIGHT_on_BLACK_SQUARE_1
      4  4848				   TEMPORARY_VAR SET	Overlay
      5  4848				   TEMPORARY_OFFSET SET	0
      6  4848				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4848				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_1
      3  4848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4860		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$78,$38,$3c,$7c,$7c,$14,$00	;PF1
      5  4878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4890					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  4890					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_2", 72
      1  4890
      2  4890				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4890				  -.EARLY_LOCATION SET	*
      4  4890				  -	      ALIGN	256
      5  4890				  -	      ECHO	"Page break for", "WHITE_KNIGHT_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4890					      ENDIF
      0  4890					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_2
      1  4890				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4890				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4890				   WHITE_KNIGHT_on_BLACK_SQUARE_2
      4  4890				   TEMPORARY_VAR SET	Overlay
      5  4890				   TEMPORARY_OFFSET SET	0
      6  4890				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4890				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_2
      3  4890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  48a8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$01,$03,$03,$00,$00	;PF1
      5  48c0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$03,$03,$07,$07,$07,$05,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  48d8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  48d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_3", 72
      1  48d8
      2  48d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  48d8				   .EARLY_LOCATION SET	*
      4  4900		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_KNIGHT_on_BLACK_SQUARE_3 wasted 40 bytes
      5  4900					      ECHO	"Page break for", "WHITE_KNIGHT_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4900					      ENDIF
      0  4900					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_3
      1  4900				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4900				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4900				   WHITE_KNIGHT_on_BLACK_SQUARE_3
      4  4900				   TEMPORARY_VAR SET	Overlay
      5  4900				   TEMPORARY_OFFSET SET	0
      6  4900				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4900				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_3
      3  4900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4930		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$78,$70,$f0,$f8,$f8,$a0,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4948					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm"
      0  4948					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_0", 72
      1  4948
      2  4948				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4948				  -.EARLY_LOCATION SET	*
      4  4948				  -	      ALIGN	256
      5  4948				  -	      ECHO	"Page break for", "WHITE_BISHOP_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4948					      ENDIF
      0  4948					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_0
      1  4948				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4948				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4948				   WHITE_BISHOP_on_BLACK_SQUARE_0
      4  4948				   TEMPORARY_VAR SET	Overlay
      5  4948				   TEMPORARY_OFFSET SET	0
      6  4948				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4948				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_0
      3  4948		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$b0,$d0,$e0,$40,$40	;PF0
      4  4960		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  4978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4990					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm"
      0  4990					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_1", 72
      1  4990
      2  4990				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4990				  -.EARLY_LOCATION SET	*
      4  4990				  -	      ALIGN	256
      5  4990				  -	      ECHO	"Page break for", "WHITE_BISHOP_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4990					      ENDIF
      0  4990					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_1
      1  4990				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4990				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4990				   WHITE_BISHOP_on_BLACK_SQUARE_1
      4  4990				   TEMPORARY_VAR SET	Overlay
      5  4990				   TEMPORARY_OFFSET SET	0
      6  4990				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4990				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_1
      3  4990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  49a8		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$6c,$5c,$38,$10,$10	;PF1
      5  49c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  49d8					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm"
      0  49d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_2", 72
      1  49d8
      2  49d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  49d8				   .EARLY_LOCATION SET	*
      4  4a00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_BISHOP_on_BLACK_SQUARE_2 wasted 40 bytes
      5  4a00					      ECHO	"Page break for", "WHITE_BISHOP_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4a00					      ENDIF
      0  4a00					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_2
      1  4a00				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4a00				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4a00				   WHITE_BISHOP_on_BLACK_SQUARE_2
      4  4a00				   TEMPORARY_VAR SET	Overlay
      5  4a00				   TEMPORARY_OFFSET SET	0
      6  4a00				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4a00				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_2
      3  4a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a18		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  4a30		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$06,$07,$03,$01,$01	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4a48					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm"
      0  4a48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_3", 72
      1  4a48
      2  4a48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4a48				  -.EARLY_LOCATION SET	*
      4  4a48				  -	      ALIGN	256
      5  4a48				  -	      ECHO	"Page break for", "WHITE_BISHOP_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4a48					      ENDIF
      0  4a48					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_3
      1  4a48				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4a48				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4a48				   WHITE_BISHOP_on_BLACK_SQUARE_3
      4  4a48				   TEMPORARY_VAR SET	Overlay
      5  4a48				   TEMPORARY_OFFSET SET	0
      6  4a48				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4a48				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_3
      3  4a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4a78		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$d8,$e8,$70,$20,$20	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4a90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm"
      0  4a90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_0", 72
      1  4a90
      2  4a90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4a90				  -.EARLY_LOCATION SET	*
      4  4a90				  -	      ALIGN	256
      5  4a90				  -	      ECHO	"Page break for", "WHITE_ROOK_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4a90					      ENDIF
      0  4a90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_0
      1  4a90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4a90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4a90				   WHITE_ROOK_on_BLACK_SQUARE_0
      4  4a90				   TEMPORARY_VAR SET	Overlay
      5  4a90				   TEMPORARY_OFFSET SET	0
      6  4a90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4a90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_0
      3  4a90		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$f0,$50,$00	;PF0
      4  4aa8		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  4ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4ad8					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm"
      0  4ad8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_1", 72
      1  4ad8
      2  4ad8					      IF	(>( * + 72 -1 )) > ( >* )
      3  4ad8				   .EARLY_LOCATION SET	*
      4  4b00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_ROOK_on_BLACK_SQUARE_1 wasted 40 bytes
      5  4b00					      ECHO	"Page break for", "WHITE_ROOK_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4b00					      ENDIF
      0  4b00					      DEF	WHITE_ROOK_on_BLACK_SQUARE_1
      1  4b00				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4b00				   BANK_WHITE_ROOK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4b00				   WHITE_ROOK_on_BLACK_SQUARE_1
      4  4b00				   TEMPORARY_VAR SET	Overlay
      5  4b00				   TEMPORARY_OFFSET SET	0
      6  4b00				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4b00				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_1
      3  4b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4b18		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$7c,$54,$00	;PF1
      5  4b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4b48					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm"
      0  4b48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_2", 72
      1  4b48
      2  4b48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4b48				  -.EARLY_LOCATION SET	*
      4  4b48				  -	      ALIGN	256
      5  4b48				  -	      ECHO	"Page break for", "WHITE_ROOK_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4b48					      ENDIF
      0  4b48					      DEF	WHITE_ROOK_on_BLACK_SQUARE_2
      1  4b48				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4b48				   BANK_WHITE_ROOK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4b48				   WHITE_ROOK_on_BLACK_SQUARE_2
      4  4b48				   TEMPORARY_VAR SET	Overlay
      5  4b48				   TEMPORARY_OFFSET SET	0
      6  4b48				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4b48				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_2
      3  4b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4b60		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$03,$02,$00	;PF1
      5  4b78		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$07,$05,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4b90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm"
      0  4b90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_3", 72
      1  4b90
      2  4b90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4b90				  -.EARLY_LOCATION SET	*
      4  4b90				  -	      ALIGN	256
      5  4b90				  -	      ECHO	"Page break for", "WHITE_ROOK_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4b90					      ENDIF
      0  4b90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_3
      1  4b90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4b90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4b90				   WHITE_ROOK_on_BLACK_SQUARE_3
      4  4b90				   TEMPORARY_VAR SET	Overlay
      5  4b90				   TEMPORARY_OFFSET SET	0
      6  4b90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4b90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_3
      3  4b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4bc0		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$f8,$a8,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
    170  4bd8
      0  4bd8					      END_BANK
      1  4bd8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  4bd8				  -	      CHECK_RAM_BANK_SIZE
      3  4bd8					      ELSE
      0  4bd8					      CHECK_BANK_SIZE
      1  4bd8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 19 PIECES_3 size = $3d8 free = 39
      2  4bd8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  4bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4bd8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  4bd8				  -	      ERR
      6  4bd8					      ENDIF
      5  4bd8					      ENDIF
    172  4bd8
    173  4bd8
    174  4bd8							;---------------------------------------------------------------------------------------------------
    175  4bd8
      0  4bd8					      ROMBANK	PIECE_4
      1  4fd8 ????				      SEG	ROM_PIECE_4
      2  4c00					      ORG	_ORIGIN
      3  4c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  4c00				   _BANK_START SET	*
      5  4c00				   PIECE_4_START SET	*
      6  4c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  4c00				   ROMBANK_PIECE_4 SET	_BANK_SLOT + _CURRENT_BANK
      8  4c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  4c00				   _LAST_BANK SETSTR	PIECE_4
     10  4c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    177  4c00
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4c00					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm"
      0  4c00					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_0", 72
      1  4c00
      2  4c00				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4c00				  -.EARLY_LOCATION SET	*
      4  4c00				  -	      ALIGN	256
      5  4c00				  -	      ECHO	"Page break for", "WHITE_QUEEN_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4c00					      ENDIF
      0  4c00					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_0
      1  4c00				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4c00				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4c00				   WHITE_QUEEN_on_BLACK_SQUARE_0
      4  4c00				   TEMPORARY_VAR SET	Overlay
      5  4c00				   TEMPORARY_OFFSET SET	0
      6  4c00				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4c00				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_0
      3  4c00		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  4c18		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00,$80,$00	;PF1
      5  4c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4c48					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm"
      0  4c48					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_1", 72
      1  4c48
      2  4c48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4c48				  -.EARLY_LOCATION SET	*
      4  4c48				  -	      ALIGN	256
      5  4c48				  -	      ECHO	"Page break for", "WHITE_QUEEN_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4c48					      ENDIF
      0  4c48					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_1
      1  4c48				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4c48				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4c48				   WHITE_QUEEN_on_BLACK_SQUARE_1
      4  4c48				   TEMPORARY_VAR SET	Overlay
      5  4c48				   TEMPORARY_OFFSET SET	0
      6  4c48				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4c48				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_1
      3  4c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4c60		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$7c,$7c,$54,$00,$54,$00	;PF1
      5  4c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4c90					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm"
      0  4c90					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_2", 72
      1  4c90
      2  4c90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4c90				  -.EARLY_LOCATION SET	*
      4  4c90				  -	      ALIGN	256
      5  4c90				  -	      ECHO	"Page break for", "WHITE_QUEEN_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4c90					      ENDIF
      0  4c90					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_2
      1  4c90				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4c90				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4c90				   WHITE_QUEEN_on_BLACK_SQUARE_2
      4  4c90				   TEMPORARY_VAR SET	Overlay
      5  4c90				   TEMPORARY_OFFSET SET	0
      6  4c90				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4c90				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_2
      3  4c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ca8		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  4cc0		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$07,$07,$05,$00,$05,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4cd8					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm"
      0  4cd8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_3", 72
      1  4cd8
      2  4cd8					      IF	(>( * + 72 -1 )) > ( >* )
      3  4cd8				   .EARLY_LOCATION SET	*
      4  4d00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_QUEEN_on_BLACK_SQUARE_3 wasted 40 bytes
      5  4d00					      ECHO	"Page break for", "WHITE_QUEEN_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4d00					      ENDIF
      0  4d00					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_3
      1  4d00				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4d00				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4d00				   WHITE_QUEEN_on_BLACK_SQUARE_3
      4  4d00				   TEMPORARY_VAR SET	Overlay
      5  4d00				   TEMPORARY_OFFSET SET	0
      6  4d00				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4d00				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_3
      3  4d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4d30		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$f8,$f8,$a8,$00,$a8,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4d48					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_0.asm"
      0  4d48					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_0", 72
      1  4d48
      2  4d48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4d48				  -.EARLY_LOCATION SET	*
      4  4d48				  -	      ALIGN	256
      5  4d48				  -	      ECHO	"Page break for", "WHITE_KING_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4d48					      ENDIF
      0  4d48					      DEF	WHITE_KING_on_BLACK_SQUARE_0
      1  4d48				   SLOT_WHITE_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4d48				   BANK_WHITE_KING_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4d48				   WHITE_KING_on_BLACK_SQUARE_0
      4  4d48				   TEMPORARY_VAR SET	Overlay
      5  4d48				   TEMPORARY_OFFSET SET	0
      6  4d48				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4d48				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_0
      3  4d48		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$70,$00,$e0,$40	;PF0
      4  4d60		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  4d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4d90					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_1.asm"
      0  4d90					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_1", 72
      1  4d90
      2  4d90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4d90				  -.EARLY_LOCATION SET	*
      4  4d90				  -	      ALIGN	256
      5  4d90				  -	      ECHO	"Page break for", "WHITE_KING_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4d90					      ENDIF
      0  4d90					      DEF	WHITE_KING_on_BLACK_SQUARE_1
      1  4d90				   SLOT_WHITE_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4d90				   BANK_WHITE_KING_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4d90				   WHITE_KING_on_BLACK_SQUARE_1
      4  4d90				   TEMPORARY_VAR SET	Overlay
      5  4d90				   TEMPORARY_OFFSET SET	0
      6  4d90				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4d90				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_1
      3  4d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4da8		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$74,$00,$38,$10	;PF1
      5  4dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4dd8					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_2.asm"
      0  4dd8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_2", 72
      1  4dd8
      2  4dd8					      IF	(>( * + 72 -1 )) > ( >* )
      3  4dd8				   .EARLY_LOCATION SET	*
      4  4e00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_KING_on_BLACK_SQUARE_2 wasted 40 bytes
      5  4e00					      ECHO	"Page break for", "WHITE_KING_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4e00					      ENDIF
      0  4e00					      DEF	WHITE_KING_on_BLACK_SQUARE_2
      1  4e00				   SLOT_WHITE_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4e00				   BANK_WHITE_KING_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4e00				   WHITE_KING_on_BLACK_SQUARE_2
      4  4e00				   TEMPORARY_VAR SET	Overlay
      5  4e00				   TEMPORARY_OFFSET SET	0
      6  4e00				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4e00				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_2
      3  4e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4e18		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  4e30		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$05,$00,$03,$01	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4e48					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_3.asm"
      0  4e48					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_3", 72
      1  4e48
      2  4e48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4e48				  -.EARLY_LOCATION SET	*
      4  4e48				  -	      ALIGN	256
      5  4e48				  -	      ECHO	"Page break for", "WHITE_KING_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4e48					      ENDIF
      0  4e48					      DEF	WHITE_KING_on_BLACK_SQUARE_3
      1  4e48				   SLOT_WHITE_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4e48				   BANK_WHITE_KING_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4e48				   WHITE_KING_on_BLACK_SQUARE_3
      4  4e48				   TEMPORARY_VAR SET	Overlay
      5  4e48				   TEMPORARY_OFFSET SET	0
      6  4e48				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4e48				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_3
      3  4e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4e78		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$b8,$00,$70,$20	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4e90					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm"
      0  4e90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_0", 72
      1  4e90
      2  4e90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4e90				  -.EARLY_LOCATION SET	*
      4  4e90				  -	      ALIGN	256
      5  4e90				  -	      ECHO	"Page break for", "BLACK_BLANK_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4e90					      ENDIF
      0  4e90					      DEF	BLACK_BLANK_on_WHITE_SQUARE_0
      1  4e90				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4e90				   BANK_BLACK_BLANK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4e90				   BLACK_BLANK_on_WHITE_SQUARE_0
      4  4e90				   TEMPORARY_VAR SET	Overlay
      5  4e90				   TEMPORARY_OFFSET SET	0
      6  4e90				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4e90				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_0
      3  4e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  4ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  4ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4ed8					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm"
      0  4ed8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_1", 72
      1  4ed8
      2  4ed8					      IF	(>( * + 72 -1 )) > ( >* )
      3  4ed8				   .EARLY_LOCATION SET	*
      4  4f00		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_BLANK_on_WHITE_SQUARE_1 wasted 40 bytes
      5  4f00					      ECHO	"Page break for", "BLACK_BLANK_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4f00					      ENDIF
      0  4f00					      DEF	BLACK_BLANK_on_WHITE_SQUARE_1
      1  4f00				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4f00				   BANK_BLACK_BLANK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4f00				   BLACK_BLANK_on_WHITE_SQUARE_1
      4  4f00				   TEMPORARY_VAR SET	Overlay
      5  4f00				   TEMPORARY_OFFSET SET	0
      6  4f00				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4f00				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_1
      3  4f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4f18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  4f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4f48					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm"
      0  4f48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_2", 72
      1  4f48
      2  4f48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4f48				  -.EARLY_LOCATION SET	*
      4  4f48				  -	      ALIGN	256
      5  4f48				  -	      ECHO	"Page break for", "BLACK_BLANK_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4f48					      ENDIF
      0  4f48					      DEF	BLACK_BLANK_on_WHITE_SQUARE_2
      1  4f48				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4f48				   BANK_BLACK_BLANK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4f48				   BLACK_BLANK_on_WHITE_SQUARE_2
      4  4f48				   TEMPORARY_VAR SET	Overlay
      5  4f48				   TEMPORARY_OFFSET SET	0
      6  4f48				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4f48				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_2
      3  4f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  4f78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4f90					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm"
      0  4f90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_3", 72
      1  4f90
      2  4f90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4f90				  -.EARLY_LOCATION SET	*
      4  4f90				  -	      ALIGN	256
      5  4f90				  -	      ECHO	"Page break for", "BLACK_BLANK_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4f90					      ENDIF
      0  4f90					      DEF	BLACK_BLANK_on_WHITE_SQUARE_3
      1  4f90				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4f90				   BANK_BLACK_BLANK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4f90				   BLACK_BLANK_on_WHITE_SQUARE_3
      4  4f90				   TEMPORARY_VAR SET	Overlay
      5  4f90				   TEMPORARY_OFFSET SET	0
      6  4f90				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4f90				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_3
      3  4f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4fc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE @2 GRAPHICS DATA.asm
    190  4fd8
      0  4fd8					      END_BANK
      1  4fd8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  4fd8				  -	      CHECK_RAM_BANK_SIZE
      3  4fd8					      ELSE
      0  4fd8					      CHECK_BANK_SIZE
      1  4fd8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 20 PIECE_4 size = $3d8 free = 39
      2  4fd8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  4fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4fd8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  4fd8				  -	      ERR
      6  4fd8					      ENDIF
      5  4fd8					      ENDIF
    192  4fd8
    193  4fd8
    194  4fd8							;---------------------------------------------------------------------------------------------------
    195  4fd8
      0  4fd8					      ROMBANK	PIECE_5
      1  53d8 ????				      SEG	ROM_PIECE_5
      2  5000					      ORG	_ORIGIN
      3  5000					      RORG	_BANK_ADDRESS_ORIGIN
      4  5000				   _BANK_START SET	*
      5  5000				   PIECE_5_START SET	*
      6  5000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  5000				   ROMBANK_PIECE_5 SET	_BANK_SLOT + _CURRENT_BANK
      8  5000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  5000				   _LAST_BANK SETSTR	PIECE_5
     10  5000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    197  5000
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5000					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm"
      0  5000					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_0", 72
      1  5000
      2  5000				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5000				  -.EARLY_LOCATION SET	*
      4  5000				  -	      ALIGN	256
      5  5000				  -	      ECHO	"Page break for", "BLACK_PAWN_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5000					      ENDIF
      0  5000					      DEF	BLACK_PAWN_on_WHITE_SQUARE_0
      1  5000				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5000				   BANK_BLACK_PAWN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5000				   BLACK_PAWN_on_WHITE_SQUARE_0
      4  5000				   TEMPORARY_VAR SET	Overlay
      5  5000				   TEMPORARY_OFFSET SET	0
      6  5000				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5000				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_0
      3  5000		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  5018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5048					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm"
      0  5048					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_1", 72
      1  5048
      2  5048				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5048				  -.EARLY_LOCATION SET	*
      4  5048				  -	      ALIGN	256
      5  5048				  -	      ECHO	"Page break for", "BLACK_PAWN_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5048					      ENDIF
      0  5048					      DEF	BLACK_PAWN_on_WHITE_SQUARE_1
      1  5048				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5048				   BANK_BLACK_PAWN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5048				   BLACK_PAWN_on_WHITE_SQUARE_1
      4  5048				   TEMPORARY_VAR SET	Overlay
      5  5048				   TEMPORARY_OFFSET SET	0
      6  5048				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5048				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_1
      3  5048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5060		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  5078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5090					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm"
      0  5090					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_2", 72
      1  5090
      2  5090				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5090				  -.EARLY_LOCATION SET	*
      4  5090				  -	      ALIGN	256
      5  5090				  -	      ECHO	"Page break for", "BLACK_PAWN_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5090					      ENDIF
      0  5090					      DEF	BLACK_PAWN_on_WHITE_SQUARE_2
      1  5090				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5090				   BANK_BLACK_PAWN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5090				   BLACK_PAWN_on_WHITE_SQUARE_2
      4  5090				   TEMPORARY_VAR SET	Overlay
      5  5090				   TEMPORARY_OFFSET SET	0
      6  5090				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5090				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_2
      3  5090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  50a8		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  50c0		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  50d8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm"
      0  50d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_3", 72
      1  50d8
      2  50d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  50d8				   .EARLY_LOCATION SET	*
      4  5100		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_PAWN_on_WHITE_SQUARE_3 wasted 40 bytes
      5  5100					      ECHO	"Page break for", "BLACK_PAWN_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5100					      ENDIF
      0  5100					      DEF	BLACK_PAWN_on_WHITE_SQUARE_3
      1  5100				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5100				   BANK_BLACK_PAWN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5100				   BLACK_PAWN_on_WHITE_SQUARE_3
      4  5100				   TEMPORARY_VAR SET	Overlay
      5  5100				   TEMPORARY_OFFSET SET	0
      6  5100				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5100				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_3
      3  5100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5130		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5148					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  5148					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_0", 72
      1  5148
      2  5148				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5148				  -.EARLY_LOCATION SET	*
      4  5148				  -	      ALIGN	256
      5  5148				  -	      ECHO	"Page break for", "BLACK_KNIGHT_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5148					      ENDIF
      0  5148					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_0
      1  5148				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5148				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5148				   BLACK_KNIGHT_on_WHITE_SQUARE_0
      4  5148				   TEMPORARY_VAR SET	Overlay
      5  5148				   TEMPORARY_OFFSET SET	0
      6  5148				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5148				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_0
      3  5148		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00	;PF0
      4  5160		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  5178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5190					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  5190					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_1", 72
      1  5190
      2  5190				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5190				  -.EARLY_LOCATION SET	*
      4  5190				  -	      ALIGN	256
      5  5190				  -	      ECHO	"Page break for", "BLACK_KNIGHT_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5190					      ENDIF
      0  5190					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_1
      1  5190				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5190				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5190				   BLACK_KNIGHT_on_WHITE_SQUARE_1
      4  5190				   TEMPORARY_VAR SET	Overlay
      5  5190				   TEMPORARY_OFFSET SET	0
      6  5190				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5190				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_1
      3  5190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  51a8		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$70,$38,$1c,$7c,$6c,$14,$00	;PF1
      5  51c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  51d8					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  51d8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_2", 72
      1  51d8
      2  51d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  51d8				   .EARLY_LOCATION SET	*
      4  5200		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_KNIGHT_on_WHITE_SQUARE_2 wasted 40 bytes
      5  5200					      ECHO	"Page break for", "BLACK_KNIGHT_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5200					      ENDIF
      0  5200					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_2
      1  5200				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5200				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5200				   BLACK_KNIGHT_on_WHITE_SQUARE_2
      4  5200				   TEMPORARY_VAR SET	Overlay
      5  5200				   TEMPORARY_OFFSET SET	0
      6  5200				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5200				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_2
      3  5200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5218		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00	;PF1
      5  5230		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$01,$03,$07,$07,$06,$05,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5248					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  5248					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_3", 72
      1  5248
      2  5248				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5248				  -.EARLY_LOCATION SET	*
      4  5248				  -	      ALIGN	256
      5  5248				  -	      ECHO	"Page break for", "BLACK_KNIGHT_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5248					      ENDIF
      0  5248					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_3
      1  5248				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5248				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5248				   BLACK_KNIGHT_on_WHITE_SQUARE_3
      4  5248				   TEMPORARY_VAR SET	Overlay
      5  5248				   TEMPORARY_OFFSET SET	0
      6  5248				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5248				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_3
      3  5248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5278		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$38,$70,$e0,$f8,$d8,$a0,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5290					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm"
      0  5290					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_0", 72
      1  5290
      2  5290				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5290				  -.EARLY_LOCATION SET	*
      4  5290				  -	      ALIGN	256
      5  5290				  -	      ECHO	"Page break for", "BLACK_BISHOP_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5290					      ENDIF
      0  5290					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_0
      1  5290				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5290				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5290				   BLACK_BISHOP_on_WHITE_SQUARE_0
      4  5290				   TEMPORARY_VAR SET	Overlay
      5  5290				   TEMPORARY_OFFSET SET	0
      6  5290				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5290				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_0
      3  5290		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$f0,$f0,$e0,$00,$40	;PF0
      4  52a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  52c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  52d8					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm"
      0  52d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_1", 72
      1  52d8
      2  52d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  52d8				   .EARLY_LOCATION SET	*
      4  5300		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_BISHOP_on_WHITE_SQUARE_1 wasted 40 bytes
      5  5300					      ECHO	"Page break for", "BLACK_BISHOP_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5300					      ENDIF
      0  5300					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_1
      1  5300				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5300				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5300				   BLACK_BISHOP_on_WHITE_SQUARE_1
      4  5300				   TEMPORARY_VAR SET	Overlay
      5  5300				   TEMPORARY_OFFSET SET	0
      6  5300				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5300				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_1
      3  5300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5318		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$7c,$7c,$38,$00,$10	;PF1
      5  5330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5348					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm"
      0  5348					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_2", 72
      1  5348
      2  5348				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5348				  -.EARLY_LOCATION SET	*
      4  5348				  -	      ALIGN	256
      5  5348				  -	      ECHO	"Page break for", "BLACK_BISHOP_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5348					      ENDIF
      0  5348					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_2
      1  5348				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5348				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5348				   BLACK_BISHOP_on_WHITE_SQUARE_2
      4  5348				   TEMPORARY_VAR SET	Overlay
      5  5348				   TEMPORARY_OFFSET SET	0
      6  5348				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5348				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_2
      3  5348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5360		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$03,$01,$00,$00	;PF1
      5  5378		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$07,$07,$03,$00,$01	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5390					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm"
      0  5390					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_3", 72
      1  5390
      2  5390				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5390				  -.EARLY_LOCATION SET	*
      4  5390				  -	      ALIGN	256
      5  5390				  -	      ECHO	"Page break for", "BLACK_BISHOP_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5390					      ENDIF
      0  5390					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_3
      1  5390				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5390				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5390				   BLACK_BISHOP_on_WHITE_SQUARE_3
      4  5390				   TEMPORARY_VAR SET	Overlay
      5  5390				   TEMPORARY_OFFSET SET	0
      6  5390				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5390				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_3
      3  5390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  53a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  53c0		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$f8,$f8,$70,$00,$20	;PF2
------- FILE @2 GRAPHICS DATA.asm
    210  53d8
      0  53d8					      END_BANK
      1  53d8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  53d8				  -	      CHECK_RAM_BANK_SIZE
      3  53d8					      ELSE
      0  53d8					      CHECK_BANK_SIZE
      1  53d8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 21 PIECE_5 size = $3d8 free = 39
      2  53d8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  53d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  53d8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  53d8				  -	      ERR
      6  53d8					      ENDIF
      5  53d8					      ENDIF
    212  53d8
    213  53d8
    214  53d8							;---------------------------------------------------------------------------------------------------
    215  53d8
      0  53d8					      ROMBANK	PIECE_6
      1  5790 ????				      SEG	ROM_PIECE_6
      2  5400					      ORG	_ORIGIN
      3  5400					      RORG	_BANK_ADDRESS_ORIGIN
      4  5400				   _BANK_START SET	*
      5  5400				   PIECE_6_START SET	*
      6  5400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  5400				   ROMBANK_PIECE_6 SET	_BANK_SLOT + _CURRENT_BANK
      8  5400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  5400				   _LAST_BANK SETSTR	PIECE_6
     10  5400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    217  5400
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5400					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm"
      0  5400					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_0", 72
      1  5400
      2  5400				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5400				  -.EARLY_LOCATION SET	*
      4  5400				  -	      ALIGN	256
      5  5400				  -	      ECHO	"Page break for", "BLACK_ROOK_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5400					      ENDIF
      0  5400					      DEF	BLACK_ROOK_on_WHITE_SQUARE_0
      1  5400				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5400				   BANK_BLACK_ROOK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5400				   BLACK_ROOK_on_WHITE_SQUARE_0
      4  5400				   TEMPORARY_VAR SET	Overlay
      5  5400				   TEMPORARY_OFFSET SET	0
      6  5400				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5400				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_0
      3  5400		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$50,$50,$00	;PF0
      4  5418		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  5430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5448					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm"
      0  5448					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_1", 72
      1  5448
      2  5448				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5448				  -.EARLY_LOCATION SET	*
      4  5448				  -	      ALIGN	256
      5  5448				  -	      ECHO	"Page break for", "BLACK_ROOK_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5448					      ENDIF
      0  5448					      DEF	BLACK_ROOK_on_WHITE_SQUARE_1
      1  5448				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5448				   BANK_BLACK_ROOK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5448				   BLACK_ROOK_on_WHITE_SQUARE_1
      4  5448				   TEMPORARY_VAR SET	Overlay
      5  5448				   TEMPORARY_OFFSET SET	0
      6  5448				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5448				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_1
      3  5448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5460		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$54,$54,$00	;PF1
      5  5478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5490					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm"
      0  5490					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_2", 72
      1  5490
      2  5490				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5490				  -.EARLY_LOCATION SET	*
      4  5490				  -	      ALIGN	256
      5  5490				  -	      ECHO	"Page break for", "BLACK_ROOK_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5490					      ENDIF
      0  5490					      DEF	BLACK_ROOK_on_WHITE_SQUARE_2
      1  5490				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5490				   BANK_BLACK_ROOK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5490				   BLACK_ROOK_on_WHITE_SQUARE_2
      4  5490				   TEMPORARY_VAR SET	Overlay
      5  5490				   TEMPORARY_OFFSET SET	0
      6  5490				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5490				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_2
      3  5490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  54a8		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$02,$02,$00	;PF1
      5  54c0		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$05,$05,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  54d8					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm"
      0  54d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_3", 72
      1  54d8
      2  54d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  54d8				   .EARLY_LOCATION SET	*
      4  5500		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_ROOK_on_WHITE_SQUARE_3 wasted 40 bytes
      5  5500					      ECHO	"Page break for", "BLACK_ROOK_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5500					      ENDIF
      0  5500					      DEF	BLACK_ROOK_on_WHITE_SQUARE_3
      1  5500				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5500				   BANK_BLACK_ROOK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5500				   BLACK_ROOK_on_WHITE_SQUARE_3
      4  5500				   TEMPORARY_VAR SET	Overlay
      5  5500				   TEMPORARY_OFFSET SET	0
      6  5500				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5500				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_3
      3  5500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5530		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$a8,$a8,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5548					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm"
      0  5548					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_0", 72
      1  5548
      2  5548				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5548				  -.EARLY_LOCATION SET	*
      4  5548				  -	      ALIGN	256
      5  5548				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5548					      ENDIF
      0  5548					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_0
      1  5548				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5548				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5548				   BLACK_QUEEN_on_WHITE_SQUARE_0
      4  5548				   TEMPORARY_VAR SET	Overlay
      5  5548				   TEMPORARY_OFFSET SET	0
      6  5548				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5548				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_0
      3  5548		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  5560		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$80,$80,$00,$80,$00	;PF1
      5  5578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5590					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm"
      0  5590					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_1", 72
      1  5590
      2  5590				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5590				  -.EARLY_LOCATION SET	*
      4  5590				  -	      ALIGN	256
      5  5590				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5590					      ENDIF
      0  5590					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_1
      1  5590				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5590				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5590				   BLACK_QUEEN_on_WHITE_SQUARE_1
      4  5590				   TEMPORARY_VAR SET	Overlay
      5  5590				   TEMPORARY_OFFSET SET	0
      6  5590				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5590				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_1
      3  5590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  55a8		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$78,$7c,$54,$00,$54,$00	;PF1
      5  55c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  55d8					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm"
      0  55d8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_2", 72
      1  55d8
      2  55d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  55d8				   .EARLY_LOCATION SET	*
      4  5600		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_QUEEN_on_WHITE_SQUARE_2 wasted 40 bytes
      5  5600					      ECHO	"Page break for", "BLACK_QUEEN_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5600					      ENDIF
      0  5600					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_2
      1  5600				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5600				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5600				   BLACK_QUEEN_on_WHITE_SQUARE_2
      4  5600				   TEMPORARY_VAR SET	Overlay
      5  5600				   TEMPORARY_OFFSET SET	0
      6  5600				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5600				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_2
      3  5600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5618		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  5630		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$03,$07,$05,$00,$05,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5648					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm"
      0  5648					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_3", 72
      1  5648
      2  5648				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5648				  -.EARLY_LOCATION SET	*
      4  5648				  -	      ALIGN	256
      5  5648				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5648					      ENDIF
      0  5648					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_3
      1  5648				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5648				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5648				   BLACK_QUEEN_on_WHITE_SQUARE_3
      4  5648				   TEMPORARY_VAR SET	Overlay
      5  5648				   TEMPORARY_OFFSET SET	0
      6  5648				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5648				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_3
      3  5648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5678		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$78,$f8,$a8,$00,$a8,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5690					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_0.asm"
      0  5690					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_0", 72
      1  5690
      2  5690				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5690				  -.EARLY_LOCATION SET	*
      4  5690				  -	      ALIGN	256
      5  5690				  -	      ECHO	"Page break for", "BLACK_KING_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5690					      ENDIF
      0  5690					      DEF	BLACK_KING_on_WHITE_SQUARE_0
      1  5690				   SLOT_BLACK_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5690				   BANK_BLACK_KING_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5690				   BLACK_KING_on_WHITE_SQUARE_0
      4  5690				   TEMPORARY_VAR SET	Overlay
      5  5690				   TEMPORARY_OFFSET SET	0
      6  5690				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5690				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_0
      3  5690		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$f0,$40,$e0,$40	;PF0
      4  56a8		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  56c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  56d8					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_1.asm"
      0  56d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_1", 72
      1  56d8
      2  56d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  56d8				   .EARLY_LOCATION SET	*
      4  5700		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_KING_on_WHITE_SQUARE_1 wasted 40 bytes
      5  5700					      ECHO	"Page break for", "BLACK_KING_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5700					      ENDIF
      0  5700					      DEF	BLACK_KING_on_WHITE_SQUARE_1
      1  5700				   SLOT_BLACK_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5700				   BANK_BLACK_KING_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5700				   BLACK_KING_on_WHITE_SQUARE_1
      4  5700				   TEMPORARY_VAR SET	Overlay
      5  5700				   TEMPORARY_OFFSET SET	0
      6  5700				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5700				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_1
      3  5700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5718		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$7c,$10,$38,$10	;PF1
      5  5730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5748					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_2.asm"
      0  5748					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_2", 72
      1  5748
      2  5748				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5748				  -.EARLY_LOCATION SET	*
      4  5748				  -	      ALIGN	256
      5  5748				  -	      ECHO	"Page break for", "BLACK_KING_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5748					      ENDIF
      0  5748					      DEF	BLACK_KING_on_WHITE_SQUARE_2
      1  5748				   SLOT_BLACK_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5748				   BANK_BLACK_KING_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5748				   BLACK_KING_on_WHITE_SQUARE_2
      4  5748				   TEMPORARY_VAR SET	Overlay
      5  5748				   TEMPORARY_OFFSET SET	0
      6  5748				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5748				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_2
      3  5748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5760		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  5778		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$07,$01,$03,$01	;PF2
------- FILE @2 GRAPHICS DATA.asm
    229  5790
      0  5790					      END_BANK
      1  5790				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  5790				  -	      CHECK_RAM_BANK_SIZE
      3  5790					      ELSE
      0  5790					      CHECK_BANK_SIZE
      1  5790		       03 90	   .TEMP      =	* - _BANK_START
 ROM bank # 22 PIECE_6 size = $390 free = 111
      2  5790					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  5790				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5790				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  5790				  -	      ERR
      6  5790					      ENDIF
      5  5790					      ENDIF
    231  5790
    232  5790
    233  5790							;---------------------------------------------------------------------------------------------------
    234  5790
      0  5790					      ROMBANK	PIECE_7
      1  5bd8 ????				      SEG	ROM_PIECE_7
      2  5800					      ORG	_ORIGIN
      3  5800					      RORG	_BANK_ADDRESS_ORIGIN
      4  5800				   _BANK_START SET	*
      5  5800				   PIECE_7_START SET	*
      6  5800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  5800				   ROMBANK_PIECE_7 SET	_BANK_SLOT + _CURRENT_BANK
      8  5800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  5800				   _LAST_BANK SETSTR	PIECE_7
     10  5800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    236  5800
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5800					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_3.asm"
      0  5800					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_3", 72
      1  5800
      2  5800				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5800				  -.EARLY_LOCATION SET	*
      4  5800				  -	      ALIGN	256
      5  5800				  -	      ECHO	"Page break for", "BLACK_KING_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5800					      ENDIF
      0  5800					      DEF	BLACK_KING_on_WHITE_SQUARE_3
      1  5800				   SLOT_BLACK_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5800				   BANK_BLACK_KING_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5800				   BLACK_KING_on_WHITE_SQUARE_3
      4  5800				   TEMPORARY_VAR SET	Overlay
      5  5800				   TEMPORARY_OFFSET SET	0
      6  5800				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5800				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_3
      3  5800		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5830		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$f8,$20,$70,$20	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5848					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm"
      0  5848					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_0", 72
      1  5848
      2  5848				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5848				  -.EARLY_LOCATION SET	*
      4  5848				  -	      ALIGN	256
      5  5848				  -	      ECHO	"Page break for", "BLACK_BLANK_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5848					      ENDIF
      0  5848					      DEF	BLACK_BLANK_on_BLACK_SQUARE_0
      1  5848				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5848				   BANK_BLACK_BLANK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5848				   BLACK_BLANK_on_BLACK_SQUARE_0
      4  5848				   TEMPORARY_VAR SET	Overlay
      5  5848				   TEMPORARY_OFFSET SET	0
      6  5848				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5848				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_0
      3  5848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5860		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5890					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm"
      0  5890					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_1", 72
      1  5890
      2  5890				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5890				  -.EARLY_LOCATION SET	*
      4  5890				  -	      ALIGN	256
      5  5890				  -	      ECHO	"Page break for", "BLACK_BLANK_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5890					      ENDIF
      0  5890					      DEF	BLACK_BLANK_on_BLACK_SQUARE_1
      1  5890				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5890				   BANK_BLACK_BLANK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5890				   BLACK_BLANK_on_BLACK_SQUARE_1
      4  5890				   TEMPORARY_VAR SET	Overlay
      5  5890				   TEMPORARY_OFFSET SET	0
      6  5890				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5890				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_1
      3  5890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  58a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  58c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  58d8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm"
      0  58d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_2", 72
      1  58d8
      2  58d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  58d8				   .EARLY_LOCATION SET	*
      4  5900		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_BLANK_on_BLACK_SQUARE_2 wasted 40 bytes
      5  5900					      ECHO	"Page break for", "BLACK_BLANK_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5900					      ENDIF
      0  5900					      DEF	BLACK_BLANK_on_BLACK_SQUARE_2
      1  5900				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5900				   BANK_BLACK_BLANK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5900				   BLACK_BLANK_on_BLACK_SQUARE_2
      4  5900				   TEMPORARY_VAR SET	Overlay
      5  5900				   TEMPORARY_OFFSET SET	0
      6  5900				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5900				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_2
      3  5900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5930		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5948					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm"
      0  5948					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_3", 72
      1  5948
      2  5948				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5948				  -.EARLY_LOCATION SET	*
      4  5948				  -	      ALIGN	256
      5  5948				  -	      ECHO	"Page break for", "BLACK_BLANK_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5948					      ENDIF
      0  5948					      DEF	BLACK_BLANK_on_BLACK_SQUARE_3
      1  5948				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5948				   BANK_BLACK_BLANK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5948				   BLACK_BLANK_on_BLACK_SQUARE_3
      4  5948				   TEMPORARY_VAR SET	Overlay
      5  5948				   TEMPORARY_OFFSET SET	0
      6  5948				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5948				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_3
      3  5948		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5990					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm"
      0  5990					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_0", 72
      1  5990
      2  5990				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5990				  -.EARLY_LOCATION SET	*
      4  5990				  -	      ALIGN	256
      5  5990				  -	      ECHO	"Page break for", "BLACK_PAWN_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5990					      ENDIF
      0  5990					      DEF	BLACK_PAWN_on_BLACK_SQUARE_0
      1  5990				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5990				   BANK_BLACK_PAWN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5990				   BLACK_PAWN_on_BLACK_SQUARE_0
      4  5990				   TEMPORARY_VAR SET	Overlay
      5  5990				   TEMPORARY_OFFSET SET	0
      6  5990				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5990				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_0
      3  5990		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  59a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  59c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  59d8					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm"
      0  59d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_1", 72
      1  59d8
      2  59d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  59d8				   .EARLY_LOCATION SET	*
      4  5a00		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_PAWN_on_BLACK_SQUARE_1 wasted 40 bytes
      5  5a00					      ECHO	"Page break for", "BLACK_PAWN_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5a00					      ENDIF
      0  5a00					      DEF	BLACK_PAWN_on_BLACK_SQUARE_1
      1  5a00				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5a00				   BANK_BLACK_PAWN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5a00				   BLACK_PAWN_on_BLACK_SQUARE_1
      4  5a00				   TEMPORARY_VAR SET	Overlay
      5  5a00				   TEMPORARY_OFFSET SET	0
      6  5a00				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5a00				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_1
      3  5a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a18		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5a30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5a48					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm"
      0  5a48					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_2", 72
      1  5a48
      2  5a48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5a48				  -.EARLY_LOCATION SET	*
      4  5a48				  -	      ALIGN	256
      5  5a48				  -	      ECHO	"Page break for", "BLACK_PAWN_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5a48					      ENDIF
      0  5a48					      DEF	BLACK_PAWN_on_BLACK_SQUARE_2
      1  5a48				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5a48				   BANK_BLACK_PAWN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5a48				   BLACK_PAWN_on_BLACK_SQUARE_2
      4  5a48				   TEMPORARY_VAR SET	Overlay
      5  5a48				   TEMPORARY_OFFSET SET	0
      6  5a48				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5a48				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_2
      3  5a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a60		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5a78		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5a90					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm"
      0  5a90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_3", 72
      1  5a90
      2  5a90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5a90				  -.EARLY_LOCATION SET	*
      4  5a90				  -	      ALIGN	256
      5  5a90				  -	      ECHO	"Page break for", "BLACK_PAWN_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5a90					      ENDIF
      0  5a90					      DEF	BLACK_PAWN_on_BLACK_SQUARE_3
      1  5a90				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5a90				   BANK_BLACK_PAWN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5a90				   BLACK_PAWN_on_BLACK_SQUARE_3
      4  5a90				   TEMPORARY_VAR SET	Overlay
      5  5a90				   TEMPORARY_OFFSET SET	0
      6  5a90				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5a90				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_3
      3  5a90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5ac0		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5ad8					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  5ad8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_0", 72
      1  5ad8
      2  5ad8					      IF	(>( * + 72 -1 )) > ( >* )
      3  5ad8				   .EARLY_LOCATION SET	*
      4  5b00		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_KNIGHT_on_BLACK_SQUARE_0 wasted 40 bytes
      5  5b00					      ECHO	"Page break for", "BLACK_KNIGHT_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5b00					      ENDIF
      0  5b00					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_0
      1  5b00				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5b00				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5b00				   BLACK_KNIGHT_on_BLACK_SQUARE_0
      4  5b00				   TEMPORARY_VAR SET	Overlay
      5  5b00				   TEMPORARY_OFFSET SET	0
      6  5b00				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5b00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_0
      3  5b00		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$40,$00,$00	;PF0
      4  5b18		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5b48					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  5b48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_1", 72
      1  5b48
      2  5b48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5b48				  -.EARLY_LOCATION SET	*
      4  5b48				  -	      ALIGN	256
      5  5b48				  -	      ECHO	"Page break for", "BLACK_KNIGHT_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5b48					      ENDIF
      0  5b48					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_1
      1  5b48				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5b48				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5b48				   BLACK_KNIGHT_on_BLACK_SQUARE_1
      4  5b48				   TEMPORARY_VAR SET	Overlay
      5  5b48				   TEMPORARY_OFFSET SET	0
      6  5b48				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5b48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_1
      3  5b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5b60		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$10,$00,$00	;PF1
      5  5b78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5b90					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  5b90					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_2", 72
      1  5b90
      2  5b90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5b90				  -.EARLY_LOCATION SET	*
      4  5b90				  -	      ALIGN	256
      5  5b90				  -	      ECHO	"Page break for", "BLACK_KNIGHT_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5b90					      ENDIF
      0  5b90					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_2
      1  5b90				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5b90				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5b90				   BLACK_KNIGHT_on_BLACK_SQUARE_2
      4  5b90				   TEMPORARY_VAR SET	Overlay
      5  5b90				   TEMPORARY_OFFSET SET	0
      6  5b90				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5b90				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_2
      3  5b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ba8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5bc0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
    249  5bd8
      0  5bd8					      END_BANK
      1  5bd8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  5bd8				  -	      CHECK_RAM_BANK_SIZE
      3  5bd8					      ELSE
      0  5bd8					      CHECK_BANK_SIZE
      1  5bd8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 23 PIECE_7 size = $3d8 free = 39
      2  5bd8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  5bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5bd8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  5bd8				  -	      ERR
      6  5bd8					      ENDIF
      5  5bd8					      ENDIF
    251  5bd8
    252  5bd8
    253  5bd8							;---------------------------------------------------------------------------------------------------
    254  5bd8
      0  5bd8					      ROMBANK	PIECE_8
      1  5c48 ????				      SEG	ROM_PIECE_8
      2  5c00					      ORG	_ORIGIN
      3  5c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  5c00				   _BANK_START SET	*
      5  5c00				   PIECE_8_START SET	*
      6  5c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  5c00				   ROMBANK_PIECE_8 SET	_BANK_SLOT + _CURRENT_BANK
      8  5c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  5c00				   _LAST_BANK SETSTR	PIECE_8
     10  5c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    256  5c00
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5c00					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  5c00					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_3", 72
      1  5c00
      2  5c00				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5c00				  -.EARLY_LOCATION SET	*
      4  5c00				  -	      ALIGN	256
      5  5c00				  -	      ECHO	"Page break for", "BLACK_KNIGHT_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5c00					      ENDIF
      0  5c00					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_3
      1  5c00				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5c00				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5c00				   BLACK_KNIGHT_on_BLACK_SQUARE_3
      4  5c00				   TEMPORARY_VAR SET	Overlay
      5  5c00				   TEMPORARY_OFFSET SET	0
      6  5c00				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5c00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_3
      3  5c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5c30		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$20,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
    258  5c48
      0  5c48					      END_BANK
      1  5c48				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  5c48				  -	      CHECK_RAM_BANK_SIZE
      3  5c48					      ELSE
      0  5c48					      CHECK_BANK_SIZE
      1  5c48		       00 48	   .TEMP      =	* - _BANK_START
 ROM bank # 24 PIECE_8 size = $48 free = 951
      2  5c48					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  5c48				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5c48				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  5c48				  -	      ERR
      6  5c48					      ENDIF
      5  5c48					      ENDIF
    260  5c48
    261  5c48
    262  5c48							;---------------------------------------------------------------------------------------------------
    263  5c48							;EOF
------- FILE ./chess.asm
    196  5c48
    197  5c48
------- FILE @3 GENERIC #2.asm LEVEL 2 PASS 4
      0  5c48					      include	"@3 GENERIC #2.asm"
      1  5c48							;---------------------------------------------------------------------------------------------------
      2  5c48							; @3 GENERIC #2.asm
      3  5c48
      4  5c48							; Atari 2600 Chess
      5  5c48							; Copyright (c) 2019-2020 Andrew Davie
      6  5c48							; andrew@taswegian.com
      7  5c48
      8  5c48
      9  5c48							;---------------------------------------------------------------------------------------------------
     10  5c48
      0  5c48					      SLOT	3
      1  5c48
      2  5c48				  -	      IF	(3 < 0) || (3 > 3)
      3  5c48				  -	      ECHO	"Illegal bank address/segment location", 3
      4  5c48				  -	      ERR
      5  5c48					      ENDIF
      6  5c48
      7  5c48				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      8  5c48				   _BANK_SLOT SET	3 * 64
      9  5c48
      0  5c48					      ROMBANK	THREE
      1  6064 ????				      SEG	ROM_THREE
      2  6000					      ORG	_ORIGIN
      3  6000					      RORG	_BANK_ADDRESS_ORIGIN
      4  6000				   _BANK_START SET	*
      5  6000				   THREE_START SET	*
      6  6000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  6000				   ROMBANK_THREE SET	_BANK_SLOT + _CURRENT_BANK
      8  6000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  6000				   _LAST_BANK SETSTR	THREE
     10  6000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  6000
     14  6000							;---------------------------------------------------------------------------------------------------
     15  6000
      0  6000					      DEF	GetPiece
      1  6000				   SLOT_GetPiece SET	_BANK_SLOT
      2  6000				   BANK_GetPiece SET	SLOT_GetPiece + _CURRENT_BANK
      3  6000				   GetPiece
      4  6000				   TEMPORARY_VAR SET	Overlay
      5  6000				   TEMPORARY_OFFSET SET	0
      6  6000				   VAR_BOUNDARY_GetPiece SET	TEMPORARY_OFFSET
      7  6000				   FUNCTION_NAME SET	GetPiece
     17  6000					      SUBROUTINE
     18  6000
      0  6000					      REF	aiSelectDestinationSquare	;✅
      1  6000					      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  6000				   TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  6000					      ENDIF
      0  6000					      REF	aiQuiescent	;✅
      1  6000				  -	      IF	VAREND_aiQuiescent > TEMPORARY_VAR
      2  6000				  -TEMPORARY_VAR SET	VAREND_aiQuiescent
      3  6000					      ENDIF
      0  6000					      VEND	GetPiece
      1  6000
      2  6000
      3  6000		       00 ef	   VAREND_GetPiece =	TEMPORARY_VAR
      4  6000
     22  6000
     23  6000							; Retrieve the piece+flags from the movelist, given from/to squares
     24  6000							; Required as moves have different flags but same origin squares (e.g., castling)
     25  6000
     26  6000		       a9 89		      lda	#RAMBANK_PLY+1	;currentPly
     27  6002							;lda currentPly
     28  6002		       85 3e		      sta	SET_BANK_RAM	;@2
     29  6004
     30  6004							; returns piece in A+fromPiece
     31  6004							; or Y=-1 if not found
     32  6004
     33  6004							; We need to get the piece from the movelist because it contains flags (e.g., castling) about
     34  6004							; the move. We need to do from/to checks because moves can have multiple origin/desinations.
     35  6004							; This fixes the move with/without castle flag
     36  6004
     37  6004
      0  6004					      ldy@PLY	moveIndex
      1  6004		       ac cf f9 	      ldy	moveIndex
     39  6007		       30 11		      bmi	.fail	; shouldn't happen
     40  6009
     41  6009		       a5 85	   .scan      lda	fromX12
      0  600b					      cmp@PLY	MoveFrom,y
      1  600b		       d9 00 f8 	      cmp	MoveFrom,y
     43  600e		       d0 07		      bne	.next
     44  6010		       a5 86		      lda	toX12
      0  6012					      cmp@PLY	MoveTo,y
      1  6012		       d9 64 f8 	      cmp	MoveTo,y
     46  6015		       f0 04		      beq	.found
     47  6017		       88	   .next      dey
     48  6018		       10 ef		      bpl	.scan
     49  601a		       60	   .fail      rts
     50  601b
      0  601b				   .found     lda@PLY	MovePiece,y
      1  601b		       b9 00 f9 	      lda	MovePiece,y
     52  601e		       85 96		      sta	fromPiece
     53  6020
     54  6020		       60		      rts
     55  6021
     56  6021
     57  6021							;---------------------------------------------------------------------------------------------------
     58  6021
     59  6021							;     DEF GenCastleMoveForRook_ENPASSANT
     60  6021							;     SUBROUTINE
     61  6021
     62  6021							;	   REF MakeMove ;✅
     63  6021							;	   REF CastleFixupDraw_ENPASSANT ;✅
     64  6021							;	   VEND GenCastleMoveForRook_ENPASSANT
     65  6021
     66  6021							;	   rts ;tmp
     67  6021							;	   jsr debug ;tmp
     68  6021
     69  6021							;     ; Like castling, this generates the acutal extra-move for the en-passant
     70  6021
     71  6021
     72  6021							;     ; Check to see if we are doing an actual en-passant capture...
     73  6021
     74  6021							;     ; NOTE: If using test boards for debugging, the FLAG_MOVED flag is IMPORTANT
     75  6021							;     ;  as the en-passant will fail if the taking piece does not have this flag set correctly
     76  6021
     77  6021
     78  6021
     79  6021							;     ; {
     80  6021							;     ; With en-passant flag, it is essentially dual-use.
     81  6021							;     ; First, it marks if the move is *involved* somehow in an en-passant
     82  6021							;     ; if the piece has MOVED already, then it's an en-passant capture
     83  6021							;     ; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
     84  6021
     85  6021							;		       ldy enPassantPawn	       ; save from previous side move
     86  6021
     87  6021							;		       ldx #0			       ; (probably) NO en-passant this time
     88  6021							;		       lda fromPiece
     89  6021							;		       and #FLAG_ENPASSANT|FLAG_MOVED
     90  6021							;		       cmp #FLAG_ENPASSANT
     91  6021							;		       bne .noep		       ; HAS moved, or not en-passant
     92  6021
     93  6021							;		       eor fromPiece		       ; clear FLAG_ENPASSANT
     94  6021							;		       sta fromPiece
     95  6021
     96  6021							;		       ldx toX12		       ; this IS an en-passantable opening, so record the square
     97  6021							; .noep	       stx enPassantPawn	       ; capturable square for en-passant move (or none)
     98  6021
     99  6021							;     ; }
    100  6021
    101  6021							;		       clc
    102  6021
    103  6021							;		       lda fromPiece
    104  6021							;		       and #FLAG_ENPASSANT
    105  6021							;		       beq .notEnPassant	       ; not an en-passant, or it's enpassant by a MOVED piece
    106  6021
    107  6021
    108  6021							;     ; at this point the attacking pawn has finished moving to the "take" square
    109  6021							;     ; the loser-pawn is marked with enPassantPawn
    110  6021							;     ; we want to generate a 'blank' move to take the pawn
    111  6021
    112  6021							;		       lda originX12		       ; we need a blank square to move FROM
    113  6021							;		       sta fromX12		       ; use the square the attacker pawn just left
    114  6021
    115  6021							;     ; calculate the captured pawn's square based on move colour
    116  6021
    117  6021							;		       lda #-10
    118  6021							;		       ldx fromPiece
    119  6021							;		       bpl .white
    120  6021							;		       lda #10
    121  6021							; .white
    122  6021							;		       clc
    123  6021							;		       adc fromX12		       ; attacker destination square
    124  6021							;		       sta toX12		       ; now we have the captured pawn square!
    125  6021							;		       sta@PLY secondarySquare	       ; square to which we RESTORE the captured pawn on unmakemove
    126  6021
    127  6021							;		       sta@PLY secondaryBlank
    128  6021							;		       lda fromPiece
    129  6021							;		       eor #$80 		       ; opponent pawn
    130  6021							;		       sta@PLY secondaryPiece	       ; a capture!
    131  6021
    132  6021
    133  6021							;		       sec			       ; double-move, so don't change sides
    134  6021							; .notEnPassant       rts
    135  6021
    136  6021
    137  6021							;---------------------------------------------------------------------------------------------------
    138  6021
      0  6021					      DEF	GenCastleMoveForRook
      1  6021				   SLOT_GenCastleMoveForRook SET	_BANK_SLOT
      2  6021				   BANK_GenCastleMoveForRook SET	SLOT_GenCastleMoveForRook + _CURRENT_BANK
      3  6021				   GenCastleMoveForRook
      4  6021				   TEMPORARY_VAR SET	Overlay
      5  6021				   TEMPORARY_OFFSET SET	0
      6  6021				   VAR_BOUNDARY_GenCastleMoveForRook SET	TEMPORARY_OFFSET
      7  6021				   FUNCTION_NAME SET	GenCastleMoveForRook
    140  6021					      SUBROUTINE
    141  6021
      0  6021					      REF	MakeMove	;✅
      1  6021					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  6021				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  6021					      ENDIF
      0  6021					      REF	CastleFixupDraw	;✅
      1  6021				  -	      IF	VAREND_CastleFixupDraw > TEMPORARY_VAR
      2  6021				  -TEMPORARY_VAR SET	VAREND_CastleFixupDraw
      3  6021					      ENDIF
      0  6021					      VEND	GenCastleMoveForRook
      1  6021
      2  6021
      3  6021		       00 b5	   VAREND_GenCastleMoveForRook =	TEMPORARY_VAR
      4  6021
    145  6021
    146  6021							; Generate secondary move for the rook, involved in a castling move
    147  6021							; Returns:
    148  6021							;   CC --> not a castle/secondary
    149  6021							;   CS --> secondary move valid
    150  6021
    151  6021
    152  6021		       18		      clc
    153  6022
    154  6022		       a5 96		      lda	fromPiece
    155  6024		       29 10		      and	#FLAG_CASTLE
    156  6026		       f0 2b		      beq	.exit	; NOT involved in castle!
    157  6028
    158  6028		       a2 04		      ldx	#4
    159  602a		       a5 86		      lda	toX12	; *destination*
    160  602c		       18	   .findCast  clc
    161  602d		       ca		      dex
    162  602e		       30 23		      bmi	.exit
    163  6030		       dd 54 fc 	      cmp	KSquare,x
    164  6033		       d0 f7		      bne	.findCast
    165  6035
    166  6035		       bd 5c fc 	      lda	RSquareEnd,x
    167  6038		       85 86		      sta	toX12
      0  603a					      sta@PLY	secondaryBlank
      1  603a		       8d ce fb 	      sta	[RAM]+secondaryBlank
    169  603d		       bc 58 fc 	      ldy	RSquareStart,x
    170  6040		       84 85		      sty	fromX12
    171  6042		       84 87		      sty	originX12
      0  6044					      sty@PLY	secondarySquare
      1  6044		       8c cd fb 	      sty	[RAM]+secondarySquare
    173  6047
    174  6047		       a5 96		      lda	fromPiece
    175  6049		       29 80		      and	#128	; colour bit
    176  604b		       09 05		      ora	#ROOK	; preserve colour
    177  604d		       85 96		      sta	fromPiece
      0  604f					      sta@PLY	secondaryPiece
      1  604f		       8d cc fb 	      sta	[RAM]+secondaryPiece
    179  6052
    180  6052		       38		      sec
    181  6053		       60	   .exit      rts
    182  6054
    183  6054
    184  6054		       18 1c 5e 62 KSquare    .byte.b	24,28,94,98
    185  6058		       16 1d 5c 63 RSquareStart .byte.b	22,29,92,99
    186  605c		       19 1b 5f 61 RSquareEnd .byte.b	25,27,95,97
    187  6060		       19 1b 5f 61 virtualSquare1 .byte.b	25,27,95,97
    188  6064							;virtualSquare2      .byte 26,26,96,96
    189  6064
    190  6064							;---------------------------------------------------------------------------------------------------
    191  6064
    192  6064							; DEF GenEnPassantMove
    193  6064							; SUBROUTINE
    194  6064
    195  6064							;     REF EnPassantCheck
    196  6064							;     REF MakeMove
    197  6064							;     VEND GenEnPassantMove
    198  6064
    199  6064
    200  6064							;		   rts
    201  6064
    202  6064
    203  6064
    204  6064							;---------------------------------------------------------------------------------------------------
    205  6064
      0  6064					      END_BANK
      1  6064				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  6064				  -	      CHECK_RAM_BANK_SIZE
      3  6064					      ELSE
      0  6064					      CHECK_BANK_SIZE
      1  6064		       00 64	   .TEMP      =	* - _BANK_START
 ROM bank # 25 THREE size = $64 free = 923
      2  6064					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  6064				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6064				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  6064				  -	      ERR
      6  6064					      ENDIF
      5  6064					      ENDIF
    207  6064
    208  6064							;---------------------------------------------------------------------------------------------------
    209  6064							; EOF
------- FILE ./chess.asm
------- FILE @3 SCREEN ROM.asm LEVEL 2 PASS 4
      0  6064					      include	"@3 SCREEN ROM.asm"
      1  6064
      0  6064					      SLOT	3
      1  6064
      2  6064				  -	      IF	(3 < 0) || (3 > 3)
      3  6064				  -	      ECHO	"Illegal bank address/segment location", 3
      4  6064				  -	      ERR
      5  6064					      ENDIF
      6  6064
      7  6064				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      8  6064				   _BANK_SLOT SET	3 * 64
      9  6064
      0  6064					      ROMBANK	ROM_SCREEN
      1  66b0 ????				      SEG	ROM_ROM_SCREEN
      2  6400					      ORG	_ORIGIN
      3  6400					      RORG	_BANK_ADDRESS_ORIGIN
      4  6400				   _BANK_START SET	*
      5  6400				   ROM_SCREEN_START SET	*
      6  6400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  6400				   ROMBANK_ROM_SCREEN SET	_BANK_SLOT + _CURRENT_BANK
      8  6400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  6400				   _LAST_BANK SETSTR	ROM_SCREEN
     10  6400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
      4  6400
      5  6400							;---------------------------------------------------------------------------------------------------
      6  6400
      0  6400					      DEF	ClearRowBitmap
      1  6400				   SLOT_ClearRowBitmap SET	_BANK_SLOT
      2  6400				   BANK_ClearRowBitmap SET	SLOT_ClearRowBitmap + _CURRENT_BANK
      3  6400				   ClearRowBitmap
      4  6400				   TEMPORARY_VAR SET	Overlay
      5  6400				   TEMPORARY_OFFSET SET	0
      6  6400				   VAR_BOUNDARY_ClearRowBitmap SET	TEMPORARY_OFFSET
      7  6400				   FUNCTION_NAME SET	ClearRowBitmap
      8  6400					      SUBROUTINE
      9  6400
      0  6400					      REF	aiClearEachRow
      1  6400					      IF	VAREND_aiClearEachRow > TEMPORARY_VAR
      2  6400				   TEMPORARY_VAR SET	VAREND_aiClearEachRow
      3  6400					      ENDIF
      0  6400					      VEND	ClearRowBitmap
      1  6400
      2  6400
      3  6400		       00 a9	   VAREND_ClearRowBitmap =	TEMPORARY_VAR
      4  6400
     12  6400
     13  6400							; No transient variable dependencies/calls
     14  6400
     15  6400		       a9 00		      lda	#0
     16  6402		       a8		      tay
      0  6403				   .clearRow  sta@RAM	ChessBitmap,y
      1  6403		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
     18  6406		       c8		      iny
     19  6407		       c0 90		      cpy	#ROW_BITMAP_SIZE
     20  6409		       d0 f8		      bne	.clearRow
     21  640b		       60		      rts
     22  640c
     23  640c
     24  640c							;---------------------------------------------------------------------------------------------------
     25  640c
      0  640c					      DEF	WriteBlank
      1  640c				   SLOT_WriteBlank SET	_BANK_SLOT
      2  640c				   BANK_WriteBlank SET	SLOT_WriteBlank + _CURRENT_BANK
      3  640c				   WriteBlank
      4  640c				   TEMPORARY_VAR SET	Overlay
      5  640c				   TEMPORARY_OFFSET SET	0
      6  640c				   VAR_BOUNDARY_WriteBlank SET	TEMPORARY_OFFSET
      7  640c				   FUNCTION_NAME SET	WriteBlank
     27  640c					      SUBROUTINE
     28  640c
      0  640c					      REF	StartupBankReset	;✅
      1  640c				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  640c				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  640c					      ENDIF
      0  640c					      VEND	WriteBlank
      1  640c
      2  640c
      3  640c		       00 a7	   VAREND_WriteBlank =	TEMPORARY_VAR
      4  640c
     31  640c
     32  640c		       a9 90		      lda	#<BlankSprite
      0  640e					      sta@RAM	SMSPRITE0_0+1
      1  640e		       8d e3 fa 	      sta	[RAM]+SMSPRITE0_0+1
      0  6411					      sta@RAM	SMSPRITE8_0+1
      1  6411		       8d 14 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  6414					      sta@RAM	SMSPRITE16_0+1
      1  6414		       8d a8 fa 	      sta	[RAM]+SMSPRITE16_0+1
      0  6417					      sta@RAM	SMSPRITE0_1+1
      1  6417		       8d e8 fa 	      sta	[RAM]+SMSPRITE0_1+1
      0  641a					      sta@RAM	SMSPRITE8_1+1
      1  641a		       8d 19 fb 	      sta	[RAM]+SMSPRITE8_1+1
      0  641d					      sta@RAM	SMSPRITE16_1+1
      1  641d		       8d ad fa 	      sta	[RAM]+SMSPRITE16_1+1
     39  6420
     40  6420		       a9 f8		      lda	#>BlankSprite
      0  6422					      sta@RAM	SMSPRITE0_0+2
      1  6422		       8d e4 fa 	      sta	[RAM]+SMSPRITE0_0+2
      0  6425					      sta@RAM	SMSPRITE8_0+2
      1  6425		       8d 15 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  6428					      sta@RAM	SMSPRITE16_0+2
      1  6428		       8d a9 fa 	      sta	[RAM]+SMSPRITE16_0+2
      0  642b					      sta@RAM	SMSPRITE0_1+2
      1  642b		       8d e9 fa 	      sta	[RAM]+SMSPRITE0_1+2
      0  642e					      sta@RAM	SMSPRITE8_1+2
      1  642e		       8d 1a fb 	      sta	[RAM]+SMSPRITE8_1+2
      0  6431					      sta@RAM	SMSPRITE16_1+2
      1  6431		       8d ae fa 	      sta	[RAM]+SMSPRITE16_1+2
     47  6434
     48  6434		       60		      rts
     49  6435
     50  6435
     51  6435							;---------------------------------------------------------------------------------------------------
     52  6435
      0  6435					      DEF	WriteCursor
      1  6435				   SLOT_WriteCursor SET	_BANK_SLOT
      2  6435				   BANK_WriteCursor SET	SLOT_WriteCursor + _CURRENT_BANK
      3  6435				   WriteCursor
      4  6435				   TEMPORARY_VAR SET	Overlay
      5  6435				   TEMPORARY_OFFSET SET	0
      6  6435				   VAR_BOUNDARY_WriteCursor SET	TEMPORARY_OFFSET
      7  6435				   FUNCTION_NAME SET	WriteCursor
     54  6435					      SUBROUTINE
     55  6435
      0  6435					      REF	StartupBankReset	;✅
      1  6435				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  6435				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  6435					      ENDIF
      0  6435					      VEND	WriteCursor
      1  6435
      2  6435
      3  6435		       00 a7	   VAREND_WriteCursor =	TEMPORARY_VAR
      4  6435
     58  6435
     59  6435		       38		      sec
     60  6436		       a5 88		      lda	cursorX12
     61  6438		       30 22		      bmi	.exit
     62  643a		       a2 0a		      ldx	#10
     63  643c		       e9 0a	   .sub10     sbc	#10
     64  643e		       ca		      dex
     65  643f		       b0 fb		      bcs	.sub10
     66  6441
     67  6441		       8a		      txa
     68  6442		       69 80		      adc	#SLOT_DrawRow	;cc implied
     69  6444		       85 3e		      sta	SET_BANK_RAM
     70  6446
     71  6446		       a9 98		      lda	#<SpriteBuffer
      0  6448					      sta@RAM	SMSPRITE0_0+1
      1  6448		       8d e3 fa 	      sta	[RAM]+SMSPRITE0_0+1
      0  644b					      sta@RAM	SMSPRITE8_0+1
      1  644b		       8d 14 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  644e					      sta@RAM	SMSPRITE16_0+1
      1  644e		       8d a8 fa 	      sta	[RAM]+SMSPRITE16_0+1
     75  6451		       a9 f8		      lda	#>SpriteBuffer
      0  6453					      sta@RAM	SMSPRITE0_0+2
      1  6453		       8d e4 fa 	      sta	[RAM]+SMSPRITE0_0+2
      0  6456					      sta@RAM	SMSPRITE8_0+2
      1  6456		       8d 15 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  6459					      sta@RAM	SMSPRITE16_0+2
      1  6459		       8d a9 fa 	      sta	[RAM]+SMSPRITE16_0+2
     79  645c
     80  645c		       60	   .exit      rts
     81  645d
     82  645d
     83  645d							;---------------------------------------------------------------------------------------------------
     84  645d
      0  645d					      DEF	BackupBitmaps
      1  645d				   SLOT_BackupBitmaps SET	_BANK_SLOT
      2  645d				   BANK_BackupBitmaps SET	SLOT_BackupBitmaps + _CURRENT_BANK
      3  645d				   BackupBitmaps
      4  645d				   TEMPORARY_VAR SET	Overlay
      5  645d				   TEMPORARY_OFFSET SET	0
      6  645d				   VAR_BOUNDARY_BackupBitmaps SET	TEMPORARY_OFFSET
      7  645d				   FUNCTION_NAME SET	BackupBitmaps
     86  645d					      SUBROUTINE
     87  645d
     88  645d							; drawCount = ROW# (0-7)
     89  645d
      0  645d					      REF	aiInCheckBackup
      1  645d					      IF	VAREND_aiInCheckBackup > TEMPORARY_VAR
      2  645d				   TEMPORARY_VAR SET	VAREND_aiInCheckBackup
      3  645d					      ENDIF
      0  645d					      VEND	BackupBitmaps
      1  645d
      2  645d
      3  645d		       00 a9	   VAREND_BackupBitmaps =	TEMPORARY_VAR
      4  645d
     92  645d
     93  645d							; switch in in ROW bitmap to RAM
     94  645d
     95  645d		       a5 84		      lda	drawCount
     96  645f		       09 80		      ora	#SLOT2
     97  6461		       85 3e		      sta	SET_BANK_RAM	;@2
     98  6463
     99  6463							; save bitmap data to backup
    100  6463
    101  6463		       a0 00		      ldy	#0
      0  6465				   .fromTo    lda@RAM	ChessBitmap,y
      1  6465		       b9 00 f8 	      lda	ChessBitmap,y
      0  6468					      sta@RAM	BackupBitmap,y
      1  6468		       99 46 fb 	      sta	[RAM]+BackupBitmap,y
    104  646b
    105  646b							;lda #255
    106  646b							;sta@RAM ChessBitmap,y
    107  646b
    108  646b		       c8		      iny
    109  646c		       c0 90		      cpy	#ROW_BITMAP_SIZE
    110  646e		       d0 f5		      bne	.fromTo
    111  6470		       60		      rts
    112  6471
    113  6471
    114  6471							;---------------------------------------------------------------------------------------------------
    115  6471
      0  6471					      DEF	RestoreBitmaps
      1  6471				   SLOT_RestoreBitmaps SET	_BANK_SLOT
      2  6471				   BANK_RestoreBitmaps SET	SLOT_RestoreBitmaps + _CURRENT_BANK
      3  6471				   RestoreBitmaps
      4  6471				   TEMPORARY_VAR SET	Overlay
      5  6471				   TEMPORARY_OFFSET SET	0
      6  6471				   VAR_BOUNDARY_RestoreBitmaps SET	TEMPORARY_OFFSET
      7  6471				   FUNCTION_NAME SET	RestoreBitmaps
    117  6471					      SUBROUTINE
    118  6471
      0  6471					      VEND	RestoreBitmaps
      1  6471
      2  6471
      3  6471		       00 a7	   VAREND_RestoreBitmaps =	TEMPORARY_VAR
      4  6471
    120  6471
    121  6471							; switch in in ROW bitmap to RAM
    122  6471
    123  6471		       a5 84		      lda	drawCount
    124  6473		       09 80		      ora	#SLOT2
    125  6475		       85 3e		      sta	SET_BANK_RAM	;@2
    126  6477
    127  6477							; copy backup bitmap back to origin
    128  6477
    129  6477		       a0 00		      ldy	#0
      0  6479				   .fromTo    lda@RAM	BackupBitmap,y
      1  6479		       b9 46 f9 	      lda	BackupBitmap,y
      0  647c					      sta@RAM	ChessBitmap,y
      1  647c		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
    132  647f		       c8		      iny
    133  6480		       c0 90		      cpy	#ROW_BITMAP_SIZE
    134  6482		       d0 f5		      bne	.fromTo
    135  6484
    136  6484		       60		      rts
    137  6485
    138  6485
    139  6485							;---------------------------------------------------------------------------------------------------
    140  6485
    141  6485				  -	      IF	0
    142  6485				  -
    143  6485				  -	      DEF	CopyTextToRowBitmap
    144  6485				  -	      SUBROUTINE
    145  6485				  -
    146  6485				  -	      VEND	CopyTextToRowBitmap
    147  6485				  -
    148  6485				  -			; An OR-draw, used for placing matricies/text onscreen
    149  6485				  -			; Similar to the EOR - first copy data into __pieceShapeBuffer, then call this function
    150  6485				  -			; The draw can be bracketed by "SaveBitmap" and "RestoreBitmap" to leave screen
    151  6485				  -			; in original state once text disappears
    152  6485				  -
    153  6485				  -	      ldy	#PIECE_SHAPE_SIZE-1
    154  6485				  -	      bcs	.rightSide
    155  6485				  -
    156  6485				  -.copy      lda	__pieceShapeBuffer,y
    157  6485				  -	      ora	ChessBitmap,y
    158  6485				  -	      sta@RAM	ChessBitmap,y
    159  6485				  -	      dey
    160  6485				  -	      bpl	.copy
    161  6485				  -
    162  6485				  -	      rts
    163  6485				  -
    164  6485				  -.rightSide
    165  6485				  -
    166  6485				  -	      SUBROUTINE
    167  6485				  -
    168  6485				  -.copy      lda	__pieceShapeBuffer,y
    169  6485				  -	      ora	ChessBitmap+PIECE_SHAPE_SIZE,y
    170  6485				  -	      sta@RAM	ChessBitmap+PIECE_SHAPE_SIZE,y
    171  6485				  -	      dey
    172  6485				  -	      bpl	.copy
    173  6485				  -
    174  6485				  -	      rts
    175  6485				  -
    176  6485					      ENDIF
    177  6485
    178  6485							;---------------------------------------------------------------------------------------------------
    179  6485
      0  6485					      DEF	aiDrawBitmapBackground
      1  6485				   SLOT_aiDrawBitmapBackground SET	_BANK_SLOT
      2  6485				   BANK_aiDrawBitmapBackground SET	SLOT_aiDrawBitmapBackground + _CURRENT_BANK
      3  6485				   aiDrawBitmapBackground
      4  6485				   TEMPORARY_VAR SET	Overlay
      5  6485				   TEMPORARY_OFFSET SET	0
      6  6485				   VAR_BOUNDARY_aiDrawBitmapBackground SET	TEMPORARY_OFFSET
      7  6485				   FUNCTION_NAME SET	aiDrawBitmapBackground
    181  6485					      SUBROUTINE
    182  6485
      0  6485					      REF	AiStateMachine
      1  6485					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  6485				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  6485					      ENDIF
      0  6485					      VAR	_tt,1
      1  6485
      2  6485		       00 a9	   _tt	      =	TEMPORARY_VAR
      3  6485				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      4  6485
      5  6485				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  6485				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  6485				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  6485					      ENDIF
      9  6485				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  6485				  -	      LIST	ON
     11  6485				  -VNAME      SETSTR	_tt
     12  6485				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  6485				  -	      ERR
     14  6485				  -	      ECHO	"Temporary Variable overlow!"
     15  6485					      ENDIF
     16  6485					      LIST	ON
      0  6485					      VEND	aiDrawBitmapBackground
      1  6485
      2  6485
      3  6485		       00 aa	   VAREND_aiDrawBitmapBackground =	TEMPORARY_VAR
      4  6485
    186  6485
    187  6485		       c6 84		      dec	drawCount
    188  6487		       30 1e		      bmi	.next
    189  6489
    190  6489
    191  6489		       a5 84		      lda	drawCount
    192  648b		       09 80		      ora	#SLOT2
    193  648d		       85 3e		      sta	SET_BANK_RAM
    194  648f
    195  648f
    196  648f		       a2 47		      ldx	#ROW_BITMAP_SIZE/2-1
    197  6491
    198  6491		       bd 00 fd    .draw      lda	SampleBitmap,x
      0  6494					      and@RAM	ChessBitmap,x
      1  6494		       3d 00 f8 	      and	ChessBitmap,x
      0  6497					      sta@RAM	ChessBitmap,x
      1  6497		       9d 00 fa 	      sta	[RAM]+ChessBitmap,x
    201  649a
    202  649a		       bd 48 fd 	      lda	SampleBitmap+ROW_BITMAP_SIZE/2,x
      0  649d					      and@RAM	ChessBitmap+ROW_BITMAP_SIZE/2,x
      1  649d		       3d 48 f8 	      and	ChessBitmap+ROW_BITMAP_SIZE/2,x
      0  64a0					      sta@RAM	ChessBitmap+ROW_BITMAP_SIZE/2,x
      1  64a0		       9d 48 fa 	      sta	[RAM]+ChessBitmap+ROW_BITMAP_SIZE/2,x
    205  64a3
    206  64a3		       ca		      dex
    207  64a4		       10 eb		      bpl	.draw
    208  64a6		       60		      rts
    209  64a7
    210  64a7
    211  64a7				   .next
    212  64a7		       a9 08		      lda	#8
    213  64a9		       85 84		      sta	drawCount	; ROW
    214  64ab
      0  64ab				   .noButton  PHASE	DrawBitmap2
      1  64ab		       a9 30		      lda	#AI_DrawBitmap2
      2  64ad		       85 8b		      sta	aiState
    216  64af		       60		      rts
    217  64b0
      0  64b0				   pwb	      PHASE	WaitBitmap
      1  64b0		       a9 2e		      lda	#AI_WaitBitmap
      2  64b2		       85 8b		      sta	aiState
    219  64b4		       60		      rts
    220  64b5
    221  64b5
      0  64b5					      DEF	aiDrawBitmap2
      1  64b5				   SLOT_aiDrawBitmap2 SET	_BANK_SLOT
      2  64b5				   BANK_aiDrawBitmap2 SET	SLOT_aiDrawBitmap2 + _CURRENT_BANK
      3  64b5				   aiDrawBitmap2
      4  64b5				   TEMPORARY_VAR SET	Overlay
      5  64b5				   TEMPORARY_OFFSET SET	0
      6  64b5				   VAR_BOUNDARY_aiDrawBitmap2 SET	TEMPORARY_OFFSET
      7  64b5				   FUNCTION_NAME SET	aiDrawBitmap2
    223  64b5					      SUBROUTINE
    224  64b5
      0  64b5					      REF	AiStateMachine
      1  64b5					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  64b5				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  64b5					      ENDIF
      0  64b5					      VEND	aiDrawBitmap2
      1  64b5
      2  64b5
      3  64b5		       00 a9	   VAREND_aiDrawBitmap2 =	TEMPORARY_VAR
      4  64b5
    227  64b5
    228  64b5		       c6 84		      dec	drawCount
    229  64b7		       30 1e		      bmi	.next
    230  64b9
    231  64b9		       a5 84		      lda	drawCount
    232  64bb		       09 80		      ora	#SLOT2
    233  64bd		       85 3e		      sta	SET_BANK_RAM
    234  64bf
    235  64bf
    236  64bf		       a2 47		      ldx	#ROW_BITMAP_SIZE/2-1
    237  64c1
    238  64c1		       bd 90 fd    .draw      lda	SampleBitmap2,x
      0  64c4					      ora@RAM	ChessBitmap,x
      1  64c4		       1d 00 f8 	      ora	ChessBitmap,x
      0  64c7					      sta@RAM	ChessBitmap,x
      1  64c7		       9d 00 fa 	      sta	[RAM]+ChessBitmap,x
    241  64ca
    242  64ca		       bd d8 fd 	      lda	SampleBitmap2+ROW_BITMAP_SIZE/2,x
      0  64cd					      ora@RAM	ChessBitmap+ROW_BITMAP_SIZE/2,x
      1  64cd		       1d 48 f8 	      ora	ChessBitmap+ROW_BITMAP_SIZE/2,x
      0  64d0					      sta@RAM	ChessBitmap+ROW_BITMAP_SIZE/2,x
      1  64d0		       9d 48 fa 	      sta	[RAM]+ChessBitmap+ROW_BITMAP_SIZE/2,x
    245  64d3
    246  64d3		       ca		      dex
    247  64d4		       10 eb		      bpl	.draw
    248  64d6		       60		      rts
    249  64d7
      0  64d7				   .next      PHASE	WaitBitmap
      1  64d7		       a9 2e		      lda	#AI_WaitBitmap
      2  64d9		       85 8b		      sta	aiState
    251  64db		       60		      rts
    252  64dc
      0  64dc					      DEF	aiDrawBitmap3
      1  64dc				   SLOT_aiDrawBitmap3 SET	_BANK_SLOT
      2  64dc				   BANK_aiDrawBitmap3 SET	SLOT_aiDrawBitmap3 + _CURRENT_BANK
      3  64dc				   aiDrawBitmap3
      4  64dc				   TEMPORARY_VAR SET	Overlay
      5  64dc				   TEMPORARY_OFFSET SET	0
      6  64dc				   VAR_BOUNDARY_aiDrawBitmap3 SET	TEMPORARY_OFFSET
      7  64dc				   FUNCTION_NAME SET	aiDrawBitmap3
    254  64dc					      SUBROUTINE
    255  64dc
      0  64dc					      REF	AiStateMachine
      1  64dc					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  64dc				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  64dc					      ENDIF
      0  64dc					      VEND	aiDrawBitmap3
      1  64dc
      2  64dc
      3  64dc		       00 a9	   VAREND_aiDrawBitmap3 =	TEMPORARY_VAR
      4  64dc
    258  64dc
    259  64dc
    260  64dc		       a9 84		      lda	#SLOT2|4
    261  64de		       85 3e		      sta	SET_BANK_RAM
    262  64e0
    263  64e0
    264  64e0		       a2 47		      ldx	#ROW_BITMAP_SIZE/2-1
    265  64e2
    266  64e2		       bd 90 fd    .draw      lda	SampleBitmap3,x
      0  64e5					      ora@RAM	ChessBitmap,x
      1  64e5		       1d 00 f8 	      ora	ChessBitmap,x
      0  64e8					      sta@RAM	ChessBitmap,x
      1  64e8		       9d 00 fa 	      sta	[RAM]+ChessBitmap,x
    269  64eb
    270  64eb		       bd d8 fd 	      lda	SampleBitmap3+ROW_BITMAP_SIZE/2,x
      0  64ee					      ora@RAM	ChessBitmap+ROW_BITMAP_SIZE/2,x
      1  64ee		       1d 48 f8 	      ora	ChessBitmap+ROW_BITMAP_SIZE/2,x
      0  64f1					      sta@RAM	ChessBitmap+ROW_BITMAP_SIZE/2,x
      1  64f1		       9d 48 fa 	      sta	[RAM]+ChessBitmap+ROW_BITMAP_SIZE/2,x
    273  64f4
    274  64f4							;		      lda SampleBitmap,y
    275  64f4							;		      ora@RAM ChessBitmap+6,x
    276  64f4							;		      sta@RAM ChessBitmap+6,x
    277  64f4
    278  64f4							;		      lda SampleBitmap,y
    279  64f4							;		      ora@RAM ChessBitmap+12,x
    280  64f4							;		      sta@RAM ChessBitmap+12,x
    281  64f4
    282  64f4							;		      iny
    283  64f4
    284  64f4		       ca		      dex
    285  64f5		       10 eb		      bpl	.draw
    286  64f7
    287  64f7
    288  64f7
      0  64f7					      PHASE	WaitBitmap
      1  64f7		       a9 2e		      lda	#AI_WaitBitmap
      2  64f9		       85 8b		      sta	aiState
    290  64fb							;PHASE DrawBitmap
    291  64fb		       60		      rts
    292  64fc
    293  64fc
      0  64fc					      DEF	Phaser
      1  64fc				   SLOT_Phaser SET	_BANK_SLOT
      2  64fc				   BANK_Phaser SET	SLOT_Phaser + _CURRENT_BANK
      3  64fc				   Phaser
      4  64fc				   TEMPORARY_VAR SET	Overlay
      5  64fc				   TEMPORARY_OFFSET SET	0
      6  64fc				   VAR_BOUNDARY_Phaser SET	TEMPORARY_OFFSET
      7  64fc				   FUNCTION_NAME SET	Phaser
    295  64fc		       00 01 02 03	      .byte.b	0, 1, 2, 3
    296  6500
    297  6500
      0  6500					      DEF	SampleBitmap
      1  6500				   SLOT_SampleBitmap SET	_BANK_SLOT
      2  6500				   BANK_SampleBitmap SET	SLOT_SampleBitmap + _CURRENT_BANK
      3  6500				   SampleBitmap
      4  6500				   TEMPORARY_VAR SET	Overlay
      5  6500				   TEMPORARY_OFFSET SET	0
      6  6500				   VAR_BOUNDARY_SampleBitmap SET	TEMPORARY_OFFSET
      7  6500				   FUNCTION_NAME SET	SampleBitmap
    299  6500
    300  6500
    301  6500							; line 7,6,5,4,3,2,1,0
    302  6500							; R/G/B on successive lines
    303  6500							; PF0/PF1/PF2/PF0/PF1/PF2
    304  6500							; x axis goes downwards
    305  6500
    306  6500		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    307  6506		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    308  650c		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    309  6512		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    310  6518		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    311  651e		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    312  6524		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    313  652a		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    314  6530		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    315  6536		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    316  653c		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    317  6542		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    318  6548		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    319  654e		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    320  6554		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    321  655a		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    322  6560		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    323  6566		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    324  656c		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    325  6572		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    326  6578		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    327  657e		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    328  6584		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    329  658a		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    330  6590
    331  6590
    332  6590
    333  6590
      0  6590					      DEF	SampleBitmap2
      1  6590				   SLOT_SampleBitmap2 SET	_BANK_SLOT
      2  6590				   BANK_SampleBitmap2 SET	SLOT_SampleBitmap2 + _CURRENT_BANK
      3  6590				   SampleBitmap2
      4  6590				   TEMPORARY_VAR SET	Overlay
      5  6590				   TEMPORARY_OFFSET SET	0
      6  6590				   VAR_BOUNDARY_SampleBitmap2 SET	TEMPORARY_OFFSET
      7  6590				   FUNCTION_NAME SET	SampleBitmap2
      0  6590					      DEF	SampleBitmap3
      1  6590				   SLOT_SampleBitmap3 SET	_BANK_SLOT
      2  6590				   BANK_SampleBitmap3 SET	SLOT_SampleBitmap3 + _CURRENT_BANK
      3  6590				   SampleBitmap3
      4  6590				   TEMPORARY_VAR SET	Overlay
      5  6590				   TEMPORARY_OFFSET SET	0
      6  6590				   VAR_BOUNDARY_SampleBitmap3 SET	TEMPORARY_OFFSET
      7  6590				   FUNCTION_NAME SET	SampleBitmap3
    336  6590
    337  6590							; line 7,6,5,4,3,2,1,0
    338  6590							; R/G/B on successive lines
    339  6590							; PF0/PF1/PF2/PF0/PF1/PF2
    340  6590							; x axis goes downwards
    341  6590
    342  6590							;     7	 6	   5	     4	       3	 2	   1	     0
    343  6590		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R PF0 left
    344  6598		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    345  65a0		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;B
    346  65a8
    347  65a8		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;PF1
    348  65b0		       64 94 84 84*	      .byte.b	%01100100,%10010100,%10000100,%10000100,%10000111,%10000100,%10010100,%01100100	;B
    349  65b8		       64 94 84 84*	      .byte.b	%01100100,%10010100,%10000100,%10000100,%10000111,%10000100,%10010100,%01100100	;B
    350  65c0
    351  65c0		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;PF1
    352  65c8		       3d 85 85 85*	      .byte.b	%00111101,%10000101,%10000101,%10000101,%10011101,%10000101,%10000101,%00111101
    353  65d0		       3d 85 85 85*	      .byte.b	%00111101,%10000101,%10000101,%10000101,%10011101,%10000101,%10000101,%00111101
    354  65d8
    355  65d8		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;PF1
    356  65e0		       30 01 81 01*	      .byte.b	%00110000,%00000001,%10000001,%00000001,%00000001,%00000001,%00001111,%00110000
    357  65e8		       30 01 81 01*	      .byte.b	%00110000,%00000001,%10000001,%00000001,%00000001,%00000001,%00001111,%00110000
    358  65f0
    359  65f0		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;PF1
    360  65f8		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
    361  6600		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
    362  6608
    363  6608		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    364  6610		       81 00 81 01*	      .byte.b	%10000001,%00000000,%10000001,%00000001,%00000001,%00000001,%00000001,%00000001
    365  6618		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    366  6620
    367  6620
    368  6620
    369  6620							; line 7,6,5,4,3,2,1,0
    370  6620							; R/G/B on successive lines
    371  6620							; PF0/PF1/PF2/PF0/PF1/PF2
    372  6620							; x axis goes downwards
    373  6620
    374  6620							;     7	 6	   5	     4	       3	 2	   1	     0
    375  6620		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R PF0 left
    376  6628		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    377  6630		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;B
    378  6638
    379  6638		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    380  6640		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    381  6648		       64 94 84 84*	      .byte.b	%01100100,%10010100,%10000100,%10000100,%10000111,%10000100,%10010100,%01100100	;B
    382  6650
    383  6650		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    384  6658		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    385  6660		       3d 85 85 85*	      .byte.b	%00111101,%10000101,%10000101,%10000101,%10011101,%10000101,%10000101,%00111101
    386  6668
    387  6668		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    388  6670		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    389  6678		       30 01 81 01*	      .byte.b	%00110000,%00000001,%10000001,%00000001,%00000001,%00000001,%00001111,%00110000
    390  6680
    391  6680		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;PF1
    392  6688		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
    393  6690		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
    394  6698
    395  6698		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    396  66a0		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    397  66a8		       81 00 81 01*	      .byte.b	%10000001,%00000000,%10000001,%00000001,%00000001,%00000001,%00000001,%00000001
    398  66b0
    399  66b0
    400  66b0
    401  66b0							;---------------------------------------------------------------------------------------------------
    402  66b0
      0  66b0					      END_BANK
      1  66b0				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  66b0				  -	      CHECK_RAM_BANK_SIZE
      3  66b0					      ELSE
      0  66b0					      CHECK_BANK_SIZE
      1  66b0		       02 b0	   .TEMP      =	* - _BANK_START
 ROM bank # 26 ROM_SCREEN size = $2b0 free = 335
      2  66b0					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  66b0				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  66b0				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  66b0				  -	      ERR
      6  66b0					      ENDIF
      5  66b0					      ENDIF
    404  66b0
    405  66b0							;---------------------------------------------------------------------------------------------------
    406  66b0							;EOF
------- FILE ./chess.asm
------- FILE @3 EVALUATE.asm LEVEL 2 PASS 4
      0  66b0					      include	"@3 EVALUATE.asm"
      1  66b0							;---------------------------------------------------------------------------------------------------
      2  66b0							; @3 EVALUATE.asm
      3  66b0
      4  66b0							; Atari 2600 Chess
      5  66b0							; Copyright (c) 2019-2020 Andrew Davie
      6  66b0							; andrew@taswegian.com
      7  66b0
      8  66b0
      9  66b0							;---------------------------------------------------------------------------------------------------
     10  66b0
      0  66b0					      SLOT	3
      1  66b0
      2  66b0				  -	      IF	(3 < 0) || (3 > 3)
      3  66b0				  -	      ECHO	"Illegal bank address/segment location", 3
      4  66b0				  -	      ERR
      5  66b0					      ENDIF
      6  66b0
      7  66b0				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      8  66b0				   _BANK_SLOT SET	3 * 64
      9  66b0
      0  66b0					      RAMBANK	EVALUATE
      1  66b0
      2 U1e00 ????				      SEG.U	RAM_EVALUATE
      3 U1e00					      ORG	ORIGIN_RAM
      4 U1e00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1e00				   _BANK_START SET	*
      6 U1e00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1e00				   RAMBANK_EVALUATE SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1e00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1e00				   _LAST_BANK SETSTR	EVALUATE
     10 U1e00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1e00					      END_BANK
      1 U1e00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1e00					      CHECK_RAM_BANK_SIZE
      1 U1e00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 16 EVALUATE size =  $0 free = $1ff
      2 U1e00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1e00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1e00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1e00				  -	      ERR
      6 U1e00					      ENDIF
      3 U1e00				  -	      ELSE
      4 U1e00				  -	      CHECK_BANK_SIZE
      5 U1e00					      ENDIF
     14 U1e00
     15 U1e00
     16 U1e00							;---------------------------------------------------------------------------------------------------
     17 U1e00
      0 U1e00					      ROMBANK	EVALUATE
      1  6a40 ????				      SEG	ROM_EVALUATE
      2  6800					      ORG	_ORIGIN
      3  6800					      RORG	_BANK_ADDRESS_ORIGIN
      4  6800				   _BANK_START SET	*
      5  6800				   EVALUATE_START SET	*
      6  6800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  6800				   ROMBANK_EVALUATE SET	_BANK_SLOT + _CURRENT_BANK
      8  6800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  6800				   _LAST_BANK SETSTR	EVALUATE
     10  6800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     19  6800
     20  6800
     21  6800							; see https://www.chessprogramming.org/Simplified_Evaluation_Function
     22  6800
     23  6800
     24  6800							;ds 22
     25  6800
     26  6800							;---------------------------------------------------------------------------------------------------
     27  6800							; Vectors to the position value tables for each piece
     28  6800
     29  6800							;---------------------------------------------------------------------------------------------------
     30  6800							; Vectors to the position value tables for each piece
     31  6800
     32  6800					      MAC	posval
     33  6800					      .byte	0
     34  6800					      .byte	{1}(PositionalValue_PAWN - 22)
     35  6800					      .byte	{1}(PositionalValue_PAWN - 22)
     36  6800					      .byte	{1}(PositionalValue_KNIGHT - 22)
     37  6800					      .byte	{1}(PositionalValue_BISHOP - 22)
     38  6800					      .byte	{1}(PositionalValue_ROOK - 22)
     39  6800					      .byte	{1}(PositionalValue_QUEEN - 22)
     40  6800					      .byte	{1}(PositionalValue_KING_MIDGAME - 22)
     41  6800					      ENDM
     42  6800
      0  6800					      ALLOCATE	PosValVecLO, 8
      1  6800
      2  6800				   .NAME      SETSTR	PosValVecLO
      0  6800					      OPTIONAL_PAGEBREAK	.NAME, 8
      1  6800
      2  6800				  -	      IF	(>( * + 8 -1 )) > ( >* )
      3  6800				  -.EARLY_LOCATION SET	*
      4  6800				  -	      ALIGN	256
      5  6800				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  6800					      ENDIF
      0  6800					      DEF	PosValVecLO
      1  6800				   SLOT_PosValVecLO SET	_BANK_SLOT
      2  6800				   BANK_PosValVecLO SET	SLOT_PosValVecLO + _CURRENT_BANK
      3  6800				   PosValVecLO
      4  6800				   TEMPORARY_VAR SET	Overlay
      5  6800				   TEMPORARY_OFFSET SET	0
      6  6800				   VAR_BOUNDARY_PosValVecLO SET	TEMPORARY_OFFSET
      7  6800				   FUNCTION_NAME SET	PosValVecLO
      5  6800
      0  6800					      POSVAL	<
      1  6800		       00		      .byte.b	0
      2  6801		       fa		      .byte.b	<(PositionalValue_PAWN - 22)
      3  6802		       fa		      .byte.b	<(PositionalValue_PAWN - 22)
      4  6803		       4a		      .byte.b	<(PositionalValue_KNIGHT - 22)
      5  6804		       9a		      .byte.b	<(PositionalValue_BISHOP - 22)
      6  6805		       ea		      .byte.b	<(PositionalValue_ROOK - 22)
      7  6806		       3a		      .byte.b	<(PositionalValue_QUEEN - 22)
      8  6807		       8a		      .byte.b	<(PositionalValue_KING_MIDGAME - 22)
      0  6808					      ALLOCATE	PosValVecHI, 8
      1  6808
      2  6808				   .NAME      SETSTR	PosValVecHI
      0  6808					      OPTIONAL_PAGEBREAK	.NAME, 8
      1  6808
      2  6808				  -	      IF	(>( * + 8 -1 )) > ( >* )
      3  6808				  -.EARLY_LOCATION SET	*
      4  6808				  -	      ALIGN	256
      5  6808				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  6808					      ENDIF
      0  6808					      DEF	PosValVecHI
      1  6808				   SLOT_PosValVecHI SET	_BANK_SLOT
      2  6808				   BANK_PosValVecHI SET	SLOT_PosValVecHI + _CURRENT_BANK
      3  6808				   PosValVecHI
      4  6808				   TEMPORARY_VAR SET	Overlay
      5  6808				   TEMPORARY_OFFSET SET	0
      6  6808				   VAR_BOUNDARY_PosValVecHI SET	TEMPORARY_OFFSET
      7  6808				   FUNCTION_NAME SET	PosValVecHI
      5  6808
      0  6808					      POSVAL	>
      1  6808		       00		      .byte.b	0
      2  6809		       fb		      .byte.b	>(PositionalValue_PAWN - 22)
      3  680a		       fb		      .byte.b	>(PositionalValue_PAWN - 22)
      4  680b		       fc		      .byte.b	>(PositionalValue_KNIGHT - 22)
      5  680c		       fc		      .byte.b	>(PositionalValue_BISHOP - 22)
      6  680d		       fc		      .byte.b	>(PositionalValue_ROOK - 22)
      7  680e		       fd		      .byte.b	>(PositionalValue_QUEEN - 22)
      8  680f		       fd		      .byte.b	>(PositionalValue_KING_MIDGAME - 22)
     47  6810
     48  6810
     49  6810					      MAC	eval8
     50  6810					      IF	({1} > 127) || ({1} < -128)
     51  6810					      ECHO	"Erroneous position value", {1}
     52  6810					      ERR
     53  6810					      ENDIF
     54  6810					      .byte	{1}
     55  6810					      ENDM
     56  6810
     57  6810
     58  6810					      MAC	pval
     59  6810					      EVAL8	{1}
     60  6810					      EVAL8	{2}
     61  6810					      EVAL8	{3}
     62  6810					      EVAL8	{4}
     63  6810					      EVAL8	{5}
     64  6810					      EVAL8	{6}
     65  6810					      EVAL8	{7}
     66  6810					      EVAL8	{8}
     67  6810					      EVAL8	0
     68  6810					      EVAL8	0
     69  6810					      ENDM		;{ 10 entries }
     70  6810
     71  6810
     72  6810							;---------------------------------------------------------------------------------------------------
     73  6810
     74  6810				   PositionalValue_PAWN
     75  6810
      0  6810					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  6810					      EVAL8	0
      1  6810				  -	      IF	(0 > 127) || (0 < -128)
      2  6810				  -	      ECHO	"Erroneous position value", 0
      3  6810				  -	      ERR
      4  6810					      ENDIF
      5  6810		       00		      .byte.b	0
      0  6811					      EVAL8	0
      1  6811				  -	      IF	(0 > 127) || (0 < -128)
      2  6811				  -	      ECHO	"Erroneous position value", 0
      3  6811				  -	      ERR
      4  6811					      ENDIF
      5  6811		       00		      .byte.b	0
      0  6812					      EVAL8	0
      1  6812				  -	      IF	(0 > 127) || (0 < -128)
      2  6812				  -	      ECHO	"Erroneous position value", 0
      3  6812				  -	      ERR
      4  6812					      ENDIF
      5  6812		       00		      .byte.b	0
      0  6813					      EVAL8	0
      1  6813				  -	      IF	(0 > 127) || (0 < -128)
      2  6813				  -	      ECHO	"Erroneous position value", 0
      3  6813				  -	      ERR
      4  6813					      ENDIF
      5  6813		       00		      .byte.b	0
      0  6814					      EVAL8	0
      1  6814				  -	      IF	(0 > 127) || (0 < -128)
      2  6814				  -	      ECHO	"Erroneous position value", 0
      3  6814				  -	      ERR
      4  6814					      ENDIF
      5  6814		       00		      .byte.b	0
      0  6815					      EVAL8	0
      1  6815				  -	      IF	(0 > 127) || (0 < -128)
      2  6815				  -	      ECHO	"Erroneous position value", 0
      3  6815				  -	      ERR
      4  6815					      ENDIF
      5  6815		       00		      .byte.b	0
      0  6816					      EVAL8	0
      1  6816				  -	      IF	(0 > 127) || (0 < -128)
      2  6816				  -	      ECHO	"Erroneous position value", 0
      3  6816				  -	      ERR
      4  6816					      ENDIF
      5  6816		       00		      .byte.b	0
      0  6817					      EVAL8	0
      1  6817				  -	      IF	(0 > 127) || (0 < -128)
      2  6817				  -	      ECHO	"Erroneous position value", 0
      3  6817				  -	      ERR
      4  6817					      ENDIF
      5  6817		       00		      .byte.b	0
      0  6818					      EVAL8	0
      1  6818				  -	      IF	(0 > 127) || (0 < -128)
      2  6818				  -	      ECHO	"Erroneous position value", 0
      3  6818				  -	      ERR
      4  6818					      ENDIF
      5  6818		       00		      .byte.b	0
      0  6819					      EVAL8	0
      1  6819				  -	      IF	(0 > 127) || (0 < -128)
      2  6819				  -	      ECHO	"Erroneous position value", 0
      3  6819				  -	      ERR
      4  6819					      ENDIF
      5  6819		       00		      .byte.b	0
      0  681a					      PVAL	15, 20, 0, -10, -10, 0, 20, 15
      0  681a					      EVAL8	15
      1  681a				  -	      IF	(15 > 127) || (15 < -128)
      2  681a				  -	      ECHO	"Erroneous position value", 15
      3  681a				  -	      ERR
      4  681a					      ENDIF
      5  681a		       0f		      .byte.b	15
      0  681b					      EVAL8	20
      1  681b				  -	      IF	(20 > 127) || (20 < -128)
      2  681b				  -	      ECHO	"Erroneous position value", 20
      3  681b				  -	      ERR
      4  681b					      ENDIF
      5  681b		       14		      .byte.b	20
      0  681c					      EVAL8	0
      1  681c				  -	      IF	(0 > 127) || (0 < -128)
      2  681c				  -	      ECHO	"Erroneous position value", 0
      3  681c				  -	      ERR
      4  681c					      ENDIF
      5  681c		       00		      .byte.b	0
      0  681d					      EVAL8	-10
      1  681d				  -	      IF	(-10 > 127) || (-10 < -128)
      2  681d				  -	      ECHO	"Erroneous position value", -10
      3  681d				  -	      ERR
      4  681d					      ENDIF
      5  681d		       f6		      .byte.b	-10
      0  681e					      EVAL8	-10
      1  681e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  681e				  -	      ECHO	"Erroneous position value", -10
      3  681e				  -	      ERR
      4  681e					      ENDIF
      5  681e		       f6		      .byte.b	-10
      0  681f					      EVAL8	0
      1  681f				  -	      IF	(0 > 127) || (0 < -128)
      2  681f				  -	      ECHO	"Erroneous position value", 0
      3  681f				  -	      ERR
      4  681f					      ENDIF
      5  681f		       00		      .byte.b	0
      0  6820					      EVAL8	20
      1  6820				  -	      IF	(20 > 127) || (20 < -128)
      2  6820				  -	      ECHO	"Erroneous position value", 20
      3  6820				  -	      ERR
      4  6820					      ENDIF
      5  6820		       14		      .byte.b	20
      0  6821					      EVAL8	15
      1  6821				  -	      IF	(15 > 127) || (15 < -128)
      2  6821				  -	      ECHO	"Erroneous position value", 15
      3  6821				  -	      ERR
      4  6821					      ENDIF
      5  6821		       0f		      .byte.b	15
      0  6822					      EVAL8	0
      1  6822				  -	      IF	(0 > 127) || (0 < -128)
      2  6822				  -	      ECHO	"Erroneous position value", 0
      3  6822				  -	      ERR
      4  6822					      ENDIF
      5  6822		       00		      .byte.b	0
      0  6823					      EVAL8	0
      1  6823				  -	      IF	(0 > 127) || (0 < -128)
      2  6823				  -	      ECHO	"Erroneous position value", 0
      3  6823				  -	      ERR
      4  6823					      ENDIF
      5  6823		       00		      .byte.b	0
      0  6824					      PVAL	5, -5, 20, 0, 0, 20, -5, 5
      0  6824					      EVAL8	5
      1  6824				  -	      IF	(5 > 127) || (5 < -128)
      2  6824				  -	      ECHO	"Erroneous position value", 5
      3  6824				  -	      ERR
      4  6824					      ENDIF
      5  6824		       05		      .byte.b	5
      0  6825					      EVAL8	-5
      1  6825				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6825				  -	      ECHO	"Erroneous position value", -5
      3  6825				  -	      ERR
      4  6825					      ENDIF
      5  6825		       fb		      .byte.b	-5
      0  6826					      EVAL8	20
      1  6826				  -	      IF	(20 > 127) || (20 < -128)
      2  6826				  -	      ECHO	"Erroneous position value", 20
      3  6826				  -	      ERR
      4  6826					      ENDIF
      5  6826		       14		      .byte.b	20
      0  6827					      EVAL8	0
      1  6827				  -	      IF	(0 > 127) || (0 < -128)
      2  6827				  -	      ECHO	"Erroneous position value", 0
      3  6827				  -	      ERR
      4  6827					      ENDIF
      5  6827		       00		      .byte.b	0
      0  6828					      EVAL8	0
      1  6828				  -	      IF	(0 > 127) || (0 < -128)
      2  6828				  -	      ECHO	"Erroneous position value", 0
      3  6828				  -	      ERR
      4  6828					      ENDIF
      5  6828		       00		      .byte.b	0
      0  6829					      EVAL8	20
      1  6829				  -	      IF	(20 > 127) || (20 < -128)
      2  6829				  -	      ECHO	"Erroneous position value", 20
      3  6829				  -	      ERR
      4  6829					      ENDIF
      5  6829		       14		      .byte.b	20
      0  682a					      EVAL8	-5
      1  682a				  -	      IF	(-5 > 127) || (-5 < -128)
      2  682a				  -	      ECHO	"Erroneous position value", -5
      3  682a				  -	      ERR
      4  682a					      ENDIF
      5  682a		       fb		      .byte.b	-5
      0  682b					      EVAL8	5
      1  682b				  -	      IF	(5 > 127) || (5 < -128)
      2  682b				  -	      ECHO	"Erroneous position value", 5
      3  682b				  -	      ERR
      4  682b					      ENDIF
      5  682b		       05		      .byte.b	5
      0  682c					      EVAL8	0
      1  682c				  -	      IF	(0 > 127) || (0 < -128)
      2  682c				  -	      ECHO	"Erroneous position value", 0
      3  682c				  -	      ERR
      4  682c					      ENDIF
      5  682c		       00		      .byte.b	0
      0  682d					      EVAL8	0
      1  682d				  -	      IF	(0 > 127) || (0 < -128)
      2  682d				  -	      ECHO	"Erroneous position value", 0
      3  682d				  -	      ERR
      4  682d					      ENDIF
      5  682d		       00		      .byte.b	0
      0  682e					      PVAL	5, 5, 10, 20, 40, 20, 5, 5
      0  682e					      EVAL8	5
      1  682e				  -	      IF	(5 > 127) || (5 < -128)
      2  682e				  -	      ECHO	"Erroneous position value", 5
      3  682e				  -	      ERR
      4  682e					      ENDIF
      5  682e		       05		      .byte.b	5
      0  682f					      EVAL8	5
      1  682f				  -	      IF	(5 > 127) || (5 < -128)
      2  682f				  -	      ECHO	"Erroneous position value", 5
      3  682f				  -	      ERR
      4  682f					      ENDIF
      5  682f		       05		      .byte.b	5
      0  6830					      EVAL8	10
      1  6830				  -	      IF	(10 > 127) || (10 < -128)
      2  6830				  -	      ECHO	"Erroneous position value", 10
      3  6830				  -	      ERR
      4  6830					      ENDIF
      5  6830		       0a		      .byte.b	10
      0  6831					      EVAL8	20
      1  6831				  -	      IF	(20 > 127) || (20 < -128)
      2  6831				  -	      ECHO	"Erroneous position value", 20
      3  6831				  -	      ERR
      4  6831					      ENDIF
      5  6831		       14		      .byte.b	20
      0  6832					      EVAL8	40
      1  6832				  -	      IF	(40 > 127) || (40 < -128)
      2  6832				  -	      ECHO	"Erroneous position value", 40
      3  6832				  -	      ERR
      4  6832					      ENDIF
      5  6832		       28		      .byte.b	40
      0  6833					      EVAL8	20
      1  6833				  -	      IF	(20 > 127) || (20 < -128)
      2  6833				  -	      ECHO	"Erroneous position value", 20
      3  6833				  -	      ERR
      4  6833					      ENDIF
      5  6833		       14		      .byte.b	20
      0  6834					      EVAL8	5
      1  6834				  -	      IF	(5 > 127) || (5 < -128)
      2  6834				  -	      ECHO	"Erroneous position value", 5
      3  6834				  -	      ERR
      4  6834					      ENDIF
      5  6834		       05		      .byte.b	5
      0  6835					      EVAL8	5
      1  6835				  -	      IF	(5 > 127) || (5 < -128)
      2  6835				  -	      ECHO	"Erroneous position value", 5
      3  6835				  -	      ERR
      4  6835					      ENDIF
      5  6835		       05		      .byte.b	5
      0  6836					      EVAL8	0
      1  6836				  -	      IF	(0 > 127) || (0 < -128)
      2  6836				  -	      ECHO	"Erroneous position value", 0
      3  6836				  -	      ERR
      4  6836					      ENDIF
      5  6836		       00		      .byte.b	0
      0  6837					      EVAL8	0
      1  6837				  -	      IF	(0 > 127) || (0 < -128)
      2  6837				  -	      ECHO	"Erroneous position value", 0
      3  6837				  -	      ERR
      4  6837					      ENDIF
      5  6837		       00		      .byte.b	0
      0  6838					      PVAL	15, 15, 20, 40, 50, 20, 15, 15
      0  6838					      EVAL8	15
      1  6838				  -	      IF	(15 > 127) || (15 < -128)
      2  6838				  -	      ECHO	"Erroneous position value", 15
      3  6838				  -	      ERR
      4  6838					      ENDIF
      5  6838		       0f		      .byte.b	15
      0  6839					      EVAL8	15
      1  6839				  -	      IF	(15 > 127) || (15 < -128)
      2  6839				  -	      ECHO	"Erroneous position value", 15
      3  6839				  -	      ERR
      4  6839					      ENDIF
      5  6839		       0f		      .byte.b	15
      0  683a					      EVAL8	20
      1  683a				  -	      IF	(20 > 127) || (20 < -128)
      2  683a				  -	      ECHO	"Erroneous position value", 20
      3  683a				  -	      ERR
      4  683a					      ENDIF
      5  683a		       14		      .byte.b	20
      0  683b					      EVAL8	40
      1  683b				  -	      IF	(40 > 127) || (40 < -128)
      2  683b				  -	      ECHO	"Erroneous position value", 40
      3  683b				  -	      ERR
      4  683b					      ENDIF
      5  683b		       28		      .byte.b	40
      0  683c					      EVAL8	50
      1  683c				  -	      IF	(50 > 127) || (50 < -128)
      2  683c				  -	      ECHO	"Erroneous position value", 50
      3  683c				  -	      ERR
      4  683c					      ENDIF
      5  683c		       32		      .byte.b	50
      0  683d					      EVAL8	20
      1  683d				  -	      IF	(20 > 127) || (20 < -128)
      2  683d				  -	      ECHO	"Erroneous position value", 20
      3  683d				  -	      ERR
      4  683d					      ENDIF
      5  683d		       14		      .byte.b	20
      0  683e					      EVAL8	15
      1  683e				  -	      IF	(15 > 127) || (15 < -128)
      2  683e				  -	      ECHO	"Erroneous position value", 15
      3  683e				  -	      ERR
      4  683e					      ENDIF
      5  683e		       0f		      .byte.b	15
      0  683f					      EVAL8	15
      1  683f				  -	      IF	(15 > 127) || (15 < -128)
      2  683f				  -	      ECHO	"Erroneous position value", 15
      3  683f				  -	      ERR
      4  683f					      ENDIF
      5  683f		       0f		      .byte.b	15
      0  6840					      EVAL8	0
      1  6840				  -	      IF	(0 > 127) || (0 < -128)
      2  6840				  -	      ECHO	"Erroneous position value", 0
      3  6840				  -	      ERR
      4  6840					      ENDIF
      5  6840		       00		      .byte.b	0
      0  6841					      EVAL8	0
      1  6841				  -	      IF	(0 > 127) || (0 < -128)
      2  6841				  -	      ECHO	"Erroneous position value", 0
      3  6841				  -	      ERR
      4  6841					      ENDIF
      5  6841		       00		      .byte.b	0
      0  6842					      PVAL	60, 60, 80, 80, 80, 80, 60, 60
      0  6842					      EVAL8	60
      1  6842				  -	      IF	(60 > 127) || (60 < -128)
      2  6842				  -	      ECHO	"Erroneous position value", 60
      3  6842				  -	      ERR
      4  6842					      ENDIF
      5  6842		       3c		      .byte.b	60
      0  6843					      EVAL8	60
      1  6843				  -	      IF	(60 > 127) || (60 < -128)
      2  6843				  -	      ECHO	"Erroneous position value", 60
      3  6843				  -	      ERR
      4  6843					      ENDIF
      5  6843		       3c		      .byte.b	60
      0  6844					      EVAL8	80
      1  6844				  -	      IF	(80 > 127) || (80 < -128)
      2  6844				  -	      ECHO	"Erroneous position value", 80
      3  6844				  -	      ERR
      4  6844					      ENDIF
      5  6844		       50		      .byte.b	80
      0  6845					      EVAL8	80
      1  6845				  -	      IF	(80 > 127) || (80 < -128)
      2  6845				  -	      ECHO	"Erroneous position value", 80
      3  6845				  -	      ERR
      4  6845					      ENDIF
      5  6845		       50		      .byte.b	80
      0  6846					      EVAL8	80
      1  6846				  -	      IF	(80 > 127) || (80 < -128)
      2  6846				  -	      ECHO	"Erroneous position value", 80
      3  6846				  -	      ERR
      4  6846					      ENDIF
      5  6846		       50		      .byte.b	80
      0  6847					      EVAL8	80
      1  6847				  -	      IF	(80 > 127) || (80 < -128)
      2  6847				  -	      ECHO	"Erroneous position value", 80
      3  6847				  -	      ERR
      4  6847					      ENDIF
      5  6847		       50		      .byte.b	80
      0  6848					      EVAL8	60
      1  6848				  -	      IF	(60 > 127) || (60 < -128)
      2  6848				  -	      ECHO	"Erroneous position value", 60
      3  6848				  -	      ERR
      4  6848					      ENDIF
      5  6848		       3c		      .byte.b	60
      0  6849					      EVAL8	60
      1  6849				  -	      IF	(60 > 127) || (60 < -128)
      2  6849				  -	      ECHO	"Erroneous position value", 60
      3  6849				  -	      ERR
      4  6849					      ENDIF
      5  6849		       3c		      .byte.b	60
      0  684a					      EVAL8	0
      1  684a				  -	      IF	(0 > 127) || (0 < -128)
      2  684a				  -	      ECHO	"Erroneous position value", 0
      3  684a				  -	      ERR
      4  684a					      ENDIF
      5  684a		       00		      .byte.b	0
      0  684b					      EVAL8	0
      1  684b				  -	      IF	(0 > 127) || (0 < -128)
      2  684b				  -	      ECHO	"Erroneous position value", 0
      3  684b				  -	      ERR
      4  684b					      ENDIF
      5  684b		       00		      .byte.b	0
      0  684c					      PVAL	100, 100, 120, 120, 120, 120, 100, 100
      0  684c					      EVAL8	100
      1  684c				  -	      IF	(100 > 127) || (100 < -128)
      2  684c				  -	      ECHO	"Erroneous position value", 100
      3  684c				  -	      ERR
      4  684c					      ENDIF
      5  684c		       64		      .byte.b	100
      0  684d					      EVAL8	100
      1  684d				  -	      IF	(100 > 127) || (100 < -128)
      2  684d				  -	      ECHO	"Erroneous position value", 100
      3  684d				  -	      ERR
      4  684d					      ENDIF
      5  684d		       64		      .byte.b	100
      0  684e					      EVAL8	120
      1  684e				  -	      IF	(120 > 127) || (120 < -128)
      2  684e				  -	      ECHO	"Erroneous position value", 120
      3  684e				  -	      ERR
      4  684e					      ENDIF
      5  684e		       78		      .byte.b	120
      0  684f					      EVAL8	120
      1  684f				  -	      IF	(120 > 127) || (120 < -128)
      2  684f				  -	      ECHO	"Erroneous position value", 120
      3  684f				  -	      ERR
      4  684f					      ENDIF
      5  684f		       78		      .byte.b	120
      0  6850					      EVAL8	120
      1  6850				  -	      IF	(120 > 127) || (120 < -128)
      2  6850				  -	      ECHO	"Erroneous position value", 120
      3  6850				  -	      ERR
      4  6850					      ENDIF
      5  6850		       78		      .byte.b	120
      0  6851					      EVAL8	120
      1  6851				  -	      IF	(120 > 127) || (120 < -128)
      2  6851				  -	      ECHO	"Erroneous position value", 120
      3  6851				  -	      ERR
      4  6851					      ENDIF
      5  6851		       78		      .byte.b	120
      0  6852					      EVAL8	100
      1  6852				  -	      IF	(100 > 127) || (100 < -128)
      2  6852				  -	      ECHO	"Erroneous position value", 100
      3  6852				  -	      ERR
      4  6852					      ENDIF
      5  6852		       64		      .byte.b	100
      0  6853					      EVAL8	100
      1  6853				  -	      IF	(100 > 127) || (100 < -128)
      2  6853				  -	      ECHO	"Erroneous position value", 100
      3  6853				  -	      ERR
      4  6853					      ENDIF
      5  6853		       64		      .byte.b	100
      0  6854					      EVAL8	0
      1  6854				  -	      IF	(0 > 127) || (0 < -128)
      2  6854				  -	      ECHO	"Erroneous position value", 0
      3  6854				  -	      ERR
      4  6854					      ENDIF
      5  6854		       00		      .byte.b	0
      0  6855					      EVAL8	0
      1  6855				  -	      IF	(0 > 127) || (0 < -128)
      2  6855				  -	      ECHO	"Erroneous position value", 0
      3  6855				  -	      ERR
      4  6855					      ENDIF
      5  6855		       00		      .byte.b	0
      0  6856					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  6856					      EVAL8	0
      1  6856				  -	      IF	(0 > 127) || (0 < -128)
      2  6856				  -	      ECHO	"Erroneous position value", 0
      3  6856				  -	      ERR
      4  6856					      ENDIF
      5  6856		       00		      .byte.b	0
      0  6857					      EVAL8	0
      1  6857				  -	      IF	(0 > 127) || (0 < -128)
      2  6857				  -	      ECHO	"Erroneous position value", 0
      3  6857				  -	      ERR
      4  6857					      ENDIF
      5  6857		       00		      .byte.b	0
      0  6858					      EVAL8	0
      1  6858				  -	      IF	(0 > 127) || (0 < -128)
      2  6858				  -	      ECHO	"Erroneous position value", 0
      3  6858				  -	      ERR
      4  6858					      ENDIF
      5  6858		       00		      .byte.b	0
      0  6859					      EVAL8	0
      1  6859				  -	      IF	(0 > 127) || (0 < -128)
      2  6859				  -	      ECHO	"Erroneous position value", 0
      3  6859				  -	      ERR
      4  6859					      ENDIF
      5  6859		       00		      .byte.b	0
      0  685a					      EVAL8	0
      1  685a				  -	      IF	(0 > 127) || (0 < -128)
      2  685a				  -	      ECHO	"Erroneous position value", 0
      3  685a				  -	      ERR
      4  685a					      ENDIF
      5  685a		       00		      .byte.b	0
      0  685b					      EVAL8	0
      1  685b				  -	      IF	(0 > 127) || (0 < -128)
      2  685b				  -	      ECHO	"Erroneous position value", 0
      3  685b				  -	      ERR
      4  685b					      ENDIF
      5  685b		       00		      .byte.b	0
      0  685c					      EVAL8	0
      1  685c				  -	      IF	(0 > 127) || (0 < -128)
      2  685c				  -	      ECHO	"Erroneous position value", 0
      3  685c				  -	      ERR
      4  685c					      ENDIF
      5  685c		       00		      .byte.b	0
      0  685d					      EVAL8	0
      1  685d				  -	      IF	(0 > 127) || (0 < -128)
      2  685d				  -	      ECHO	"Erroneous position value", 0
      3  685d				  -	      ERR
      4  685d					      ENDIF
      5  685d		       00		      .byte.b	0
      0  685e					      EVAL8	0
      1  685e				  -	      IF	(0 > 127) || (0 < -128)
      2  685e				  -	      ECHO	"Erroneous position value", 0
      3  685e				  -	      ERR
      4  685e					      ENDIF
      5  685e		       00		      .byte.b	0
      0  685f					      EVAL8	0
      1  685f				  -	      IF	(0 > 127) || (0 < -128)
      2  685f				  -	      ECHO	"Erroneous position value", 0
      3  685f				  -	      ERR
      4  685f					      ENDIF
      5  685f		       00		      .byte.b	0
     84  6860
     85  6860							;---------------------------------------------------------------------------------------------------
     86  6860
     87  6860				   PositionalValue_KNIGHT
     88  6860
      0  6860					      PVAL	-50, -30, -30, -30, -30, -30, -22, -50
      0  6860					      EVAL8	-50
      1  6860				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6860				  -	      ECHO	"Erroneous position value", -50
      3  6860				  -	      ERR
      4  6860					      ENDIF
      5  6860		       ce		      .byte.b	-50
      0  6861					      EVAL8	-30
      1  6861				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6861				  -	      ECHO	"Erroneous position value", -30
      3  6861				  -	      ERR
      4  6861					      ENDIF
      5  6861		       e2		      .byte.b	-30
      0  6862					      EVAL8	-30
      1  6862				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6862				  -	      ECHO	"Erroneous position value", -30
      3  6862				  -	      ERR
      4  6862					      ENDIF
      5  6862		       e2		      .byte.b	-30
      0  6863					      EVAL8	-30
      1  6863				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6863				  -	      ECHO	"Erroneous position value", -30
      3  6863				  -	      ERR
      4  6863					      ENDIF
      5  6863		       e2		      .byte.b	-30
      0  6864					      EVAL8	-30
      1  6864				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6864				  -	      ECHO	"Erroneous position value", -30
      3  6864				  -	      ERR
      4  6864					      ENDIF
      5  6864		       e2		      .byte.b	-30
      0  6865					      EVAL8	-30
      1  6865				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6865				  -	      ECHO	"Erroneous position value", -30
      3  6865				  -	      ERR
      4  6865					      ENDIF
      5  6865		       e2		      .byte.b	-30
      0  6866					      EVAL8	-22
      1  6866				  -	      IF	(-22 > 127) || (-22 < -128)
      2  6866				  -	      ECHO	"Erroneous position value", -22
      3  6866				  -	      ERR
      4  6866					      ENDIF
      5  6866		       ea		      .byte.b	-22
      0  6867					      EVAL8	-50
      1  6867				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6867				  -	      ECHO	"Erroneous position value", -50
      3  6867				  -	      ERR
      4  6867					      ENDIF
      5  6867		       ce		      .byte.b	-50
      0  6868					      EVAL8	0
      1  6868				  -	      IF	(0 > 127) || (0 < -128)
      2  6868				  -	      ECHO	"Erroneous position value", 0
      3  6868				  -	      ERR
      4  6868					      ENDIF
      5  6868		       00		      .byte.b	0
      0  6869					      EVAL8	0
      1  6869				  -	      IF	(0 > 127) || (0 < -128)
      2  6869				  -	      ECHO	"Erroneous position value", 0
      3  6869				  -	      ERR
      4  6869					      ENDIF
      5  6869		       00		      .byte.b	0
      0  686a					      PVAL	-40, -20, 0, -5, -25, 0, -20, -40
      0  686a					      EVAL8	-40
      1  686a				  -	      IF	(-40 > 127) || (-40 < -128)
      2  686a				  -	      ECHO	"Erroneous position value", -40
      3  686a				  -	      ERR
      4  686a					      ENDIF
      5  686a		       d8		      .byte.b	-40
      0  686b					      EVAL8	-20
      1  686b				  -	      IF	(-20 > 127) || (-20 < -128)
      2  686b				  -	      ECHO	"Erroneous position value", -20
      3  686b				  -	      ERR
      4  686b					      ENDIF
      5  686b		       ec		      .byte.b	-20
      0  686c					      EVAL8	0
      1  686c				  -	      IF	(0 > 127) || (0 < -128)
      2  686c				  -	      ECHO	"Erroneous position value", 0
      3  686c				  -	      ERR
      4  686c					      ENDIF
      5  686c		       00		      .byte.b	0
      0  686d					      EVAL8	-5
      1  686d				  -	      IF	(-5 > 127) || (-5 < -128)
      2  686d				  -	      ECHO	"Erroneous position value", -5
      3  686d				  -	      ERR
      4  686d					      ENDIF
      5  686d		       fb		      .byte.b	-5
      0  686e					      EVAL8	-25
      1  686e				  -	      IF	(-25 > 127) || (-25 < -128)
      2  686e				  -	      ECHO	"Erroneous position value", -25
      3  686e				  -	      ERR
      4  686e					      ENDIF
      5  686e		       e7		      .byte.b	-25
      0  686f					      EVAL8	0
      1  686f				  -	      IF	(0 > 127) || (0 < -128)
      2  686f				  -	      ECHO	"Erroneous position value", 0
      3  686f				  -	      ERR
      4  686f					      ENDIF
      5  686f		       00		      .byte.b	0
      0  6870					      EVAL8	-20
      1  6870				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6870				  -	      ECHO	"Erroneous position value", -20
      3  6870				  -	      ERR
      4  6870					      ENDIF
      5  6870		       ec		      .byte.b	-20
      0  6871					      EVAL8	-40
      1  6871				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6871				  -	      ECHO	"Erroneous position value", -40
      3  6871				  -	      ERR
      4  6871					      ENDIF
      5  6871		       d8		      .byte.b	-40
      0  6872					      EVAL8	0
      1  6872				  -	      IF	(0 > 127) || (0 < -128)
      2  6872				  -	      ECHO	"Erroneous position value", 0
      3  6872				  -	      ERR
      4  6872					      ENDIF
      5  6872		       00		      .byte.b	0
      0  6873					      EVAL8	0
      1  6873				  -	      IF	(0 > 127) || (0 < -128)
      2  6873				  -	      ECHO	"Erroneous position value", 0
      3  6873				  -	      ERR
      4  6873					      ENDIF
      5  6873		       00		      .byte.b	0
      0  6874					      PVAL	-30, 0, 18, 15, 15, 18, 0, -30
      0  6874					      EVAL8	-30
      1  6874				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6874				  -	      ECHO	"Erroneous position value", -30
      3  6874				  -	      ERR
      4  6874					      ENDIF
      5  6874		       e2		      .byte.b	-30
      0  6875					      EVAL8	0
      1  6875				  -	      IF	(0 > 127) || (0 < -128)
      2  6875				  -	      ECHO	"Erroneous position value", 0
      3  6875				  -	      ERR
      4  6875					      ENDIF
      5  6875		       00		      .byte.b	0
      0  6876					      EVAL8	18
      1  6876				  -	      IF	(18 > 127) || (18 < -128)
      2  6876				  -	      ECHO	"Erroneous position value", 18
      3  6876				  -	      ERR
      4  6876					      ENDIF
      5  6876		       12		      .byte.b	18
      0  6877					      EVAL8	15
      1  6877				  -	      IF	(15 > 127) || (15 < -128)
      2  6877				  -	      ECHO	"Erroneous position value", 15
      3  6877				  -	      ERR
      4  6877					      ENDIF
      5  6877		       0f		      .byte.b	15
      0  6878					      EVAL8	15
      1  6878				  -	      IF	(15 > 127) || (15 < -128)
      2  6878				  -	      ECHO	"Erroneous position value", 15
      3  6878				  -	      ERR
      4  6878					      ENDIF
      5  6878		       0f		      .byte.b	15
      0  6879					      EVAL8	18
      1  6879				  -	      IF	(18 > 127) || (18 < -128)
      2  6879				  -	      ECHO	"Erroneous position value", 18
      3  6879				  -	      ERR
      4  6879					      ENDIF
      5  6879		       12		      .byte.b	18
      0  687a					      EVAL8	0
      1  687a				  -	      IF	(0 > 127) || (0 < -128)
      2  687a				  -	      ECHO	"Erroneous position value", 0
      3  687a				  -	      ERR
      4  687a					      ENDIF
      5  687a		       00		      .byte.b	0
      0  687b					      EVAL8	-30
      1  687b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  687b				  -	      ECHO	"Erroneous position value", -30
      3  687b				  -	      ERR
      4  687b					      ENDIF
      5  687b		       e2		      .byte.b	-30
      0  687c					      EVAL8	0
      1  687c				  -	      IF	(0 > 127) || (0 < -128)
      2  687c				  -	      ECHO	"Erroneous position value", 0
      3  687c				  -	      ERR
      4  687c					      ENDIF
      5  687c		       00		      .byte.b	0
      0  687d					      EVAL8	0
      1  687d				  -	      IF	(0 > 127) || (0 < -128)
      2  687d				  -	      ECHO	"Erroneous position value", 0
      3  687d				  -	      ERR
      4  687d					      ENDIF
      5  687d		       00		      .byte.b	0
      0  687e					      PVAL	-40, 0, 15, 30, 30, 15, 0, -40
      0  687e					      EVAL8	-40
      1  687e				  -	      IF	(-40 > 127) || (-40 < -128)
      2  687e				  -	      ECHO	"Erroneous position value", -40
      3  687e				  -	      ERR
      4  687e					      ENDIF
      5  687e		       d8		      .byte.b	-40
      0  687f					      EVAL8	0
      1  687f				  -	      IF	(0 > 127) || (0 < -128)
      2  687f				  -	      ECHO	"Erroneous position value", 0
      3  687f				  -	      ERR
      4  687f					      ENDIF
      5  687f		       00		      .byte.b	0
      0  6880					      EVAL8	15
      1  6880				  -	      IF	(15 > 127) || (15 < -128)
      2  6880				  -	      ECHO	"Erroneous position value", 15
      3  6880				  -	      ERR
      4  6880					      ENDIF
      5  6880		       0f		      .byte.b	15
      0  6881					      EVAL8	30
      1  6881				  -	      IF	(30 > 127) || (30 < -128)
      2  6881				  -	      ECHO	"Erroneous position value", 30
      3  6881				  -	      ERR
      4  6881					      ENDIF
      5  6881		       1e		      .byte.b	30
      0  6882					      EVAL8	30
      1  6882				  -	      IF	(30 > 127) || (30 < -128)
      2  6882				  -	      ECHO	"Erroneous position value", 30
      3  6882				  -	      ERR
      4  6882					      ENDIF
      5  6882		       1e		      .byte.b	30
      0  6883					      EVAL8	15
      1  6883				  -	      IF	(15 > 127) || (15 < -128)
      2  6883				  -	      ECHO	"Erroneous position value", 15
      3  6883				  -	      ERR
      4  6883					      ENDIF
      5  6883		       0f		      .byte.b	15
      0  6884					      EVAL8	0
      1  6884				  -	      IF	(0 > 127) || (0 < -128)
      2  6884				  -	      ECHO	"Erroneous position value", 0
      3  6884				  -	      ERR
      4  6884					      ENDIF
      5  6884		       00		      .byte.b	0
      0  6885					      EVAL8	-40
      1  6885				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6885				  -	      ECHO	"Erroneous position value", -40
      3  6885				  -	      ERR
      4  6885					      ENDIF
      5  6885		       d8		      .byte.b	-40
      0  6886					      EVAL8	0
      1  6886				  -	      IF	(0 > 127) || (0 < -128)
      2  6886				  -	      ECHO	"Erroneous position value", 0
      3  6886				  -	      ERR
      4  6886					      ENDIF
      5  6886		       00		      .byte.b	0
      0  6887					      EVAL8	0
      1  6887				  -	      IF	(0 > 127) || (0 < -128)
      2  6887				  -	      ECHO	"Erroneous position value", 0
      3  6887				  -	      ERR
      4  6887					      ENDIF
      5  6887		       00		      .byte.b	0
      0  6888					      PVAL	-40, 5, 15, 30, 30, 15, 5, -40
      0  6888					      EVAL8	-40
      1  6888				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6888				  -	      ECHO	"Erroneous position value", -40
      3  6888				  -	      ERR
      4  6888					      ENDIF
      5  6888		       d8		      .byte.b	-40
      0  6889					      EVAL8	5
      1  6889				  -	      IF	(5 > 127) || (5 < -128)
      2  6889				  -	      ECHO	"Erroneous position value", 5
      3  6889				  -	      ERR
      4  6889					      ENDIF
      5  6889		       05		      .byte.b	5
      0  688a					      EVAL8	15
      1  688a				  -	      IF	(15 > 127) || (15 < -128)
      2  688a				  -	      ECHO	"Erroneous position value", 15
      3  688a				  -	      ERR
      4  688a					      ENDIF
      5  688a		       0f		      .byte.b	15
      0  688b					      EVAL8	30
      1  688b				  -	      IF	(30 > 127) || (30 < -128)
      2  688b				  -	      ECHO	"Erroneous position value", 30
      3  688b				  -	      ERR
      4  688b					      ENDIF
      5  688b		       1e		      .byte.b	30
      0  688c					      EVAL8	30
      1  688c				  -	      IF	(30 > 127) || (30 < -128)
      2  688c				  -	      ECHO	"Erroneous position value", 30
      3  688c				  -	      ERR
      4  688c					      ENDIF
      5  688c		       1e		      .byte.b	30
      0  688d					      EVAL8	15
      1  688d				  -	      IF	(15 > 127) || (15 < -128)
      2  688d				  -	      ECHO	"Erroneous position value", 15
      3  688d				  -	      ERR
      4  688d					      ENDIF
      5  688d		       0f		      .byte.b	15
      0  688e					      EVAL8	5
      1  688e				  -	      IF	(5 > 127) || (5 < -128)
      2  688e				  -	      ECHO	"Erroneous position value", 5
      3  688e				  -	      ERR
      4  688e					      ENDIF
      5  688e		       05		      .byte.b	5
      0  688f					      EVAL8	-40
      1  688f				  -	      IF	(-40 > 127) || (-40 < -128)
      2  688f				  -	      ECHO	"Erroneous position value", -40
      3  688f				  -	      ERR
      4  688f					      ENDIF
      5  688f		       d8		      .byte.b	-40
      0  6890					      EVAL8	0
      1  6890				  -	      IF	(0 > 127) || (0 < -128)
      2  6890				  -	      ECHO	"Erroneous position value", 0
      3  6890				  -	      ERR
      4  6890					      ENDIF
      5  6890		       00		      .byte.b	0
      0  6891					      EVAL8	0
      1  6891				  -	      IF	(0 > 127) || (0 < -128)
      2  6891				  -	      ECHO	"Erroneous position value", 0
      3  6891				  -	      ERR
      4  6891					      ENDIF
      5  6891		       00		      .byte.b	0
      0  6892					      PVAL	-30, 0, 10, 15, 15, 10, 0, -30
      0  6892					      EVAL8	-30
      1  6892				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6892				  -	      ECHO	"Erroneous position value", -30
      3  6892				  -	      ERR
      4  6892					      ENDIF
      5  6892		       e2		      .byte.b	-30
      0  6893					      EVAL8	0
      1  6893				  -	      IF	(0 > 127) || (0 < -128)
      2  6893				  -	      ECHO	"Erroneous position value", 0
      3  6893				  -	      ERR
      4  6893					      ENDIF
      5  6893		       00		      .byte.b	0
      0  6894					      EVAL8	10
      1  6894				  -	      IF	(10 > 127) || (10 < -128)
      2  6894				  -	      ECHO	"Erroneous position value", 10
      3  6894				  -	      ERR
      4  6894					      ENDIF
      5  6894		       0a		      .byte.b	10
      0  6895					      EVAL8	15
      1  6895				  -	      IF	(15 > 127) || (15 < -128)
      2  6895				  -	      ECHO	"Erroneous position value", 15
      3  6895				  -	      ERR
      4  6895					      ENDIF
      5  6895		       0f		      .byte.b	15
      0  6896					      EVAL8	15
      1  6896				  -	      IF	(15 > 127) || (15 < -128)
      2  6896				  -	      ECHO	"Erroneous position value", 15
      3  6896				  -	      ERR
      4  6896					      ENDIF
      5  6896		       0f		      .byte.b	15
      0  6897					      EVAL8	10
      1  6897				  -	      IF	(10 > 127) || (10 < -128)
      2  6897				  -	      ECHO	"Erroneous position value", 10
      3  6897				  -	      ERR
      4  6897					      ENDIF
      5  6897		       0a		      .byte.b	10
      0  6898					      EVAL8	0
      1  6898				  -	      IF	(0 > 127) || (0 < -128)
      2  6898				  -	      ECHO	"Erroneous position value", 0
      3  6898				  -	      ERR
      4  6898					      ENDIF
      5  6898		       00		      .byte.b	0
      0  6899					      EVAL8	-30
      1  6899				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6899				  -	      ECHO	"Erroneous position value", -30
      3  6899				  -	      ERR
      4  6899					      ENDIF
      5  6899		       e2		      .byte.b	-30
      0  689a					      EVAL8	0
      1  689a				  -	      IF	(0 > 127) || (0 < -128)
      2  689a				  -	      ECHO	"Erroneous position value", 0
      3  689a				  -	      ERR
      4  689a					      ENDIF
      5  689a		       00		      .byte.b	0
      0  689b					      EVAL8	0
      1  689b				  -	      IF	(0 > 127) || (0 < -128)
      2  689b				  -	      ECHO	"Erroneous position value", 0
      3  689b				  -	      ERR
      4  689b					      ENDIF
      5  689b		       00		      .byte.b	0
      0  689c					      PVAL	-40, -20, 30, 0, 0, 30, -20, -40
      0  689c					      EVAL8	-40
      1  689c				  -	      IF	(-40 > 127) || (-40 < -128)
      2  689c				  -	      ECHO	"Erroneous position value", -40
      3  689c				  -	      ERR
      4  689c					      ENDIF
      5  689c		       d8		      .byte.b	-40
      0  689d					      EVAL8	-20
      1  689d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  689d				  -	      ECHO	"Erroneous position value", -20
      3  689d				  -	      ERR
      4  689d					      ENDIF
      5  689d		       ec		      .byte.b	-20
      0  689e					      EVAL8	30
      1  689e				  -	      IF	(30 > 127) || (30 < -128)
      2  689e				  -	      ECHO	"Erroneous position value", 30
      3  689e				  -	      ERR
      4  689e					      ENDIF
      5  689e		       1e		      .byte.b	30
      0  689f					      EVAL8	0
      1  689f				  -	      IF	(0 > 127) || (0 < -128)
      2  689f				  -	      ECHO	"Erroneous position value", 0
      3  689f				  -	      ERR
      4  689f					      ENDIF
      5  689f		       00		      .byte.b	0
      0  68a0					      EVAL8	0
      1  68a0				  -	      IF	(0 > 127) || (0 < -128)
      2  68a0				  -	      ECHO	"Erroneous position value", 0
      3  68a0				  -	      ERR
      4  68a0					      ENDIF
      5  68a0		       00		      .byte.b	0
      0  68a1					      EVAL8	30
      1  68a1				  -	      IF	(30 > 127) || (30 < -128)
      2  68a1				  -	      ECHO	"Erroneous position value", 30
      3  68a1				  -	      ERR
      4  68a1					      ENDIF
      5  68a1		       1e		      .byte.b	30
      0  68a2					      EVAL8	-20
      1  68a2				  -	      IF	(-20 > 127) || (-20 < -128)
      2  68a2				  -	      ECHO	"Erroneous position value", -20
      3  68a2				  -	      ERR
      4  68a2					      ENDIF
      5  68a2		       ec		      .byte.b	-20
      0  68a3					      EVAL8	-40
      1  68a3				  -	      IF	(-40 > 127) || (-40 < -128)
      2  68a3				  -	      ECHO	"Erroneous position value", -40
      3  68a3				  -	      ERR
      4  68a3					      ENDIF
      5  68a3		       d8		      .byte.b	-40
      0  68a4					      EVAL8	0
      1  68a4				  -	      IF	(0 > 127) || (0 < -128)
      2  68a4				  -	      ECHO	"Erroneous position value", 0
      3  68a4				  -	      ERR
      4  68a4					      ENDIF
      5  68a4		       00		      .byte.b	0
      0  68a5					      EVAL8	0
      1  68a5				  -	      IF	(0 > 127) || (0 < -128)
      2  68a5				  -	      ECHO	"Erroneous position value", 0
      3  68a5				  -	      ERR
      4  68a5					      ENDIF
      5  68a5		       00		      .byte.b	0
      0  68a6					      PVAL	-50, -20, -30, -30, -30, -30, -20, -50
      0  68a6					      EVAL8	-50
      1  68a6				  -	      IF	(-50 > 127) || (-50 < -128)
      2  68a6				  -	      ECHO	"Erroneous position value", -50
      3  68a6				  -	      ERR
      4  68a6					      ENDIF
      5  68a6		       ce		      .byte.b	-50
      0  68a7					      EVAL8	-20
      1  68a7				  -	      IF	(-20 > 127) || (-20 < -128)
      2  68a7				  -	      ECHO	"Erroneous position value", -20
      3  68a7				  -	      ERR
      4  68a7					      ENDIF
      5  68a7		       ec		      .byte.b	-20
      0  68a8					      EVAL8	-30
      1  68a8				  -	      IF	(-30 > 127) || (-30 < -128)
      2  68a8				  -	      ECHO	"Erroneous position value", -30
      3  68a8				  -	      ERR
      4  68a8					      ENDIF
      5  68a8		       e2		      .byte.b	-30
      0  68a9					      EVAL8	-30
      1  68a9				  -	      IF	(-30 > 127) || (-30 < -128)
      2  68a9				  -	      ECHO	"Erroneous position value", -30
      3  68a9				  -	      ERR
      4  68a9					      ENDIF
      5  68a9		       e2		      .byte.b	-30
      0  68aa					      EVAL8	-30
      1  68aa				  -	      IF	(-30 > 127) || (-30 < -128)
      2  68aa				  -	      ECHO	"Erroneous position value", -30
      3  68aa				  -	      ERR
      4  68aa					      ENDIF
      5  68aa		       e2		      .byte.b	-30
      0  68ab					      EVAL8	-30
      1  68ab				  -	      IF	(-30 > 127) || (-30 < -128)
      2  68ab				  -	      ECHO	"Erroneous position value", -30
      3  68ab				  -	      ERR
      4  68ab					      ENDIF
      5  68ab		       e2		      .byte.b	-30
      0  68ac					      EVAL8	-20
      1  68ac				  -	      IF	(-20 > 127) || (-20 < -128)
      2  68ac				  -	      ECHO	"Erroneous position value", -20
      3  68ac				  -	      ERR
      4  68ac					      ENDIF
      5  68ac		       ec		      .byte.b	-20
      0  68ad					      EVAL8	-50
      1  68ad				  -	      IF	(-50 > 127) || (-50 < -128)
      2  68ad				  -	      ECHO	"Erroneous position value", -50
      3  68ad				  -	      ERR
      4  68ad					      ENDIF
      5  68ad		       ce		      .byte.b	-50
      0  68ae					      EVAL8	0
      1  68ae				  -	      IF	(0 > 127) || (0 < -128)
      2  68ae				  -	      ECHO	"Erroneous position value", 0
      3  68ae				  -	      ERR
      4  68ae					      ENDIF
      5  68ae		       00		      .byte.b	0
      0  68af					      EVAL8	0
      1  68af				  -	      IF	(0 > 127) || (0 < -128)
      2  68af				  -	      ECHO	"Erroneous position value", 0
      3  68af				  -	      ERR
      4  68af					      ENDIF
      5  68af		       00		      .byte.b	0
     97  68b0
     98  68b0
     99  68b0							;---------------------------------------------------------------------------------------------------
    100  68b0
    101  68b0				   PositionalValue_BISHOP
    102  68b0
      0  68b0					      PVAL	-20, -10, -50, -10, -10, -50, -10, -20
      0  68b0					      EVAL8	-20
      1  68b0				  -	      IF	(-20 > 127) || (-20 < -128)
      2  68b0				  -	      ECHO	"Erroneous position value", -20
      3  68b0				  -	      ERR
      4  68b0					      ENDIF
      5  68b0		       ec		      .byte.b	-20
      0  68b1					      EVAL8	-10
      1  68b1				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68b1				  -	      ECHO	"Erroneous position value", -10
      3  68b1				  -	      ERR
      4  68b1					      ENDIF
      5  68b1		       f6		      .byte.b	-10
      0  68b2					      EVAL8	-50
      1  68b2				  -	      IF	(-50 > 127) || (-50 < -128)
      2  68b2				  -	      ECHO	"Erroneous position value", -50
      3  68b2				  -	      ERR
      4  68b2					      ENDIF
      5  68b2		       ce		      .byte.b	-50
      0  68b3					      EVAL8	-10
      1  68b3				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68b3				  -	      ECHO	"Erroneous position value", -10
      3  68b3				  -	      ERR
      4  68b3					      ENDIF
      5  68b3		       f6		      .byte.b	-10
      0  68b4					      EVAL8	-10
      1  68b4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68b4				  -	      ECHO	"Erroneous position value", -10
      3  68b4				  -	      ERR
      4  68b4					      ENDIF
      5  68b4		       f6		      .byte.b	-10
      0  68b5					      EVAL8	-50
      1  68b5				  -	      IF	(-50 > 127) || (-50 < -128)
      2  68b5				  -	      ECHO	"Erroneous position value", -50
      3  68b5				  -	      ERR
      4  68b5					      ENDIF
      5  68b5		       ce		      .byte.b	-50
      0  68b6					      EVAL8	-10
      1  68b6				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68b6				  -	      ECHO	"Erroneous position value", -10
      3  68b6				  -	      ERR
      4  68b6					      ENDIF
      5  68b6		       f6		      .byte.b	-10
      0  68b7					      EVAL8	-20
      1  68b7				  -	      IF	(-20 > 127) || (-20 < -128)
      2  68b7				  -	      ECHO	"Erroneous position value", -20
      3  68b7				  -	      ERR
      4  68b7					      ENDIF
      5  68b7		       ec		      .byte.b	-20
      0  68b8					      EVAL8	0
      1  68b8				  -	      IF	(0 > 127) || (0 < -128)
      2  68b8				  -	      ECHO	"Erroneous position value", 0
      3  68b8				  -	      ERR
      4  68b8					      ENDIF
      5  68b8		       00		      .byte.b	0
      0  68b9					      EVAL8	0
      1  68b9				  -	      IF	(0 > 127) || (0 < -128)
      2  68b9				  -	      ECHO	"Erroneous position value", 0
      3  68b9				  -	      ERR
      4  68b9					      ENDIF
      5  68b9		       00		      .byte.b	0
      0  68ba					      PVAL	-10, 5, 0, 0, 0, 0, 5, -10
      0  68ba					      EVAL8	-10
      1  68ba				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68ba				  -	      ECHO	"Erroneous position value", -10
      3  68ba				  -	      ERR
      4  68ba					      ENDIF
      5  68ba		       f6		      .byte.b	-10
      0  68bb					      EVAL8	5
      1  68bb				  -	      IF	(5 > 127) || (5 < -128)
      2  68bb				  -	      ECHO	"Erroneous position value", 5
      3  68bb				  -	      ERR
      4  68bb					      ENDIF
      5  68bb		       05		      .byte.b	5
      0  68bc					      EVAL8	0
      1  68bc				  -	      IF	(0 > 127) || (0 < -128)
      2  68bc				  -	      ECHO	"Erroneous position value", 0
      3  68bc				  -	      ERR
      4  68bc					      ENDIF
      5  68bc		       00		      .byte.b	0
      0  68bd					      EVAL8	0
      1  68bd				  -	      IF	(0 > 127) || (0 < -128)
      2  68bd				  -	      ECHO	"Erroneous position value", 0
      3  68bd				  -	      ERR
      4  68bd					      ENDIF
      5  68bd		       00		      .byte.b	0
      0  68be					      EVAL8	0
      1  68be				  -	      IF	(0 > 127) || (0 < -128)
      2  68be				  -	      ECHO	"Erroneous position value", 0
      3  68be				  -	      ERR
      4  68be					      ENDIF
      5  68be		       00		      .byte.b	0
      0  68bf					      EVAL8	0
      1  68bf				  -	      IF	(0 > 127) || (0 < -128)
      2  68bf				  -	      ECHO	"Erroneous position value", 0
      3  68bf				  -	      ERR
      4  68bf					      ENDIF
      5  68bf		       00		      .byte.b	0
      0  68c0					      EVAL8	5
      1  68c0				  -	      IF	(5 > 127) || (5 < -128)
      2  68c0				  -	      ECHO	"Erroneous position value", 5
      3  68c0				  -	      ERR
      4  68c0					      ENDIF
      5  68c0		       05		      .byte.b	5
      0  68c1					      EVAL8	-10
      1  68c1				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68c1				  -	      ECHO	"Erroneous position value", -10
      3  68c1				  -	      ERR
      4  68c1					      ENDIF
      5  68c1		       f6		      .byte.b	-10
      0  68c2					      EVAL8	0
      1  68c2				  -	      IF	(0 > 127) || (0 < -128)
      2  68c2				  -	      ECHO	"Erroneous position value", 0
      3  68c2				  -	      ERR
      4  68c2					      ENDIF
      5  68c2		       00		      .byte.b	0
      0  68c3					      EVAL8	0
      1  68c3				  -	      IF	(0 > 127) || (0 < -128)
      2  68c3				  -	      ECHO	"Erroneous position value", 0
      3  68c3				  -	      ERR
      4  68c3					      ENDIF
      5  68c3		       00		      .byte.b	0
      0  68c4					      PVAL	-10, 10, 10, 10, 10, 10, 10, -10
      0  68c4					      EVAL8	-10
      1  68c4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68c4				  -	      ECHO	"Erroneous position value", -10
      3  68c4				  -	      ERR
      4  68c4					      ENDIF
      5  68c4		       f6		      .byte.b	-10
      0  68c5					      EVAL8	10
      1  68c5				  -	      IF	(10 > 127) || (10 < -128)
      2  68c5				  -	      ECHO	"Erroneous position value", 10
      3  68c5				  -	      ERR
      4  68c5					      ENDIF
      5  68c5		       0a		      .byte.b	10
      0  68c6					      EVAL8	10
      1  68c6				  -	      IF	(10 > 127) || (10 < -128)
      2  68c6				  -	      ECHO	"Erroneous position value", 10
      3  68c6				  -	      ERR
      4  68c6					      ENDIF
      5  68c6		       0a		      .byte.b	10
      0  68c7					      EVAL8	10
      1  68c7				  -	      IF	(10 > 127) || (10 < -128)
      2  68c7				  -	      ECHO	"Erroneous position value", 10
      3  68c7				  -	      ERR
      4  68c7					      ENDIF
      5  68c7		       0a		      .byte.b	10
      0  68c8					      EVAL8	10
      1  68c8				  -	      IF	(10 > 127) || (10 < -128)
      2  68c8				  -	      ECHO	"Erroneous position value", 10
      3  68c8				  -	      ERR
      4  68c8					      ENDIF
      5  68c8		       0a		      .byte.b	10
      0  68c9					      EVAL8	10
      1  68c9				  -	      IF	(10 > 127) || (10 < -128)
      2  68c9				  -	      ECHO	"Erroneous position value", 10
      3  68c9				  -	      ERR
      4  68c9					      ENDIF
      5  68c9		       0a		      .byte.b	10
      0  68ca					      EVAL8	10
      1  68ca				  -	      IF	(10 > 127) || (10 < -128)
      2  68ca				  -	      ECHO	"Erroneous position value", 10
      3  68ca				  -	      ERR
      4  68ca					      ENDIF
      5  68ca		       0a		      .byte.b	10
      0  68cb					      EVAL8	-10
      1  68cb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68cb				  -	      ECHO	"Erroneous position value", -10
      3  68cb				  -	      ERR
      4  68cb					      ENDIF
      5  68cb		       f6		      .byte.b	-10
      0  68cc					      EVAL8	0
      1  68cc				  -	      IF	(0 > 127) || (0 < -128)
      2  68cc				  -	      ECHO	"Erroneous position value", 0
      3  68cc				  -	      ERR
      4  68cc					      ENDIF
      5  68cc		       00		      .byte.b	0
      0  68cd					      EVAL8	0
      1  68cd				  -	      IF	(0 > 127) || (0 < -128)
      2  68cd				  -	      ECHO	"Erroneous position value", 0
      3  68cd				  -	      ERR
      4  68cd					      ENDIF
      5  68cd		       00		      .byte.b	0
      0  68ce					      PVAL	-10, 0, 10, 20, 20, 10, 0, -10
      0  68ce					      EVAL8	-10
      1  68ce				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68ce				  -	      ECHO	"Erroneous position value", -10
      3  68ce				  -	      ERR
      4  68ce					      ENDIF
      5  68ce		       f6		      .byte.b	-10
      0  68cf					      EVAL8	0
      1  68cf				  -	      IF	(0 > 127) || (0 < -128)
      2  68cf				  -	      ECHO	"Erroneous position value", 0
      3  68cf				  -	      ERR
      4  68cf					      ENDIF
      5  68cf		       00		      .byte.b	0
      0  68d0					      EVAL8	10
      1  68d0				  -	      IF	(10 > 127) || (10 < -128)
      2  68d0				  -	      ECHO	"Erroneous position value", 10
      3  68d0				  -	      ERR
      4  68d0					      ENDIF
      5  68d0		       0a		      .byte.b	10
      0  68d1					      EVAL8	20
      1  68d1				  -	      IF	(20 > 127) || (20 < -128)
      2  68d1				  -	      ECHO	"Erroneous position value", 20
      3  68d1				  -	      ERR
      4  68d1					      ENDIF
      5  68d1		       14		      .byte.b	20
      0  68d2					      EVAL8	20
      1  68d2				  -	      IF	(20 > 127) || (20 < -128)
      2  68d2				  -	      ECHO	"Erroneous position value", 20
      3  68d2				  -	      ERR
      4  68d2					      ENDIF
      5  68d2		       14		      .byte.b	20
      0  68d3					      EVAL8	10
      1  68d3				  -	      IF	(10 > 127) || (10 < -128)
      2  68d3				  -	      ECHO	"Erroneous position value", 10
      3  68d3				  -	      ERR
      4  68d3					      ENDIF
      5  68d3		       0a		      .byte.b	10
      0  68d4					      EVAL8	0
      1  68d4				  -	      IF	(0 > 127) || (0 < -128)
      2  68d4				  -	      ECHO	"Erroneous position value", 0
      3  68d4				  -	      ERR
      4  68d4					      ENDIF
      5  68d4		       00		      .byte.b	0
      0  68d5					      EVAL8	-10
      1  68d5				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68d5				  -	      ECHO	"Erroneous position value", -10
      3  68d5				  -	      ERR
      4  68d5					      ENDIF
      5  68d5		       f6		      .byte.b	-10
      0  68d6					      EVAL8	0
      1  68d6				  -	      IF	(0 > 127) || (0 < -128)
      2  68d6				  -	      ECHO	"Erroneous position value", 0
      3  68d6				  -	      ERR
      4  68d6					      ENDIF
      5  68d6		       00		      .byte.b	0
      0  68d7					      EVAL8	0
      1  68d7				  -	      IF	(0 > 127) || (0 < -128)
      2  68d7				  -	      ECHO	"Erroneous position value", 0
      3  68d7				  -	      ERR
      4  68d7					      ENDIF
      5  68d7		       00		      .byte.b	0
      0  68d8					      PVAL	-10, 5, 5, 20, 20, 5, 5, -10
      0  68d8					      EVAL8	-10
      1  68d8				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68d8				  -	      ECHO	"Erroneous position value", -10
      3  68d8				  -	      ERR
      4  68d8					      ENDIF
      5  68d8		       f6		      .byte.b	-10
      0  68d9					      EVAL8	5
      1  68d9				  -	      IF	(5 > 127) || (5 < -128)
      2  68d9				  -	      ECHO	"Erroneous position value", 5
      3  68d9				  -	      ERR
      4  68d9					      ENDIF
      5  68d9		       05		      .byte.b	5
      0  68da					      EVAL8	5
      1  68da				  -	      IF	(5 > 127) || (5 < -128)
      2  68da				  -	      ECHO	"Erroneous position value", 5
      3  68da				  -	      ERR
      4  68da					      ENDIF
      5  68da		       05		      .byte.b	5
      0  68db					      EVAL8	20
      1  68db				  -	      IF	(20 > 127) || (20 < -128)
      2  68db				  -	      ECHO	"Erroneous position value", 20
      3  68db				  -	      ERR
      4  68db					      ENDIF
      5  68db		       14		      .byte.b	20
      0  68dc					      EVAL8	20
      1  68dc				  -	      IF	(20 > 127) || (20 < -128)
      2  68dc				  -	      ECHO	"Erroneous position value", 20
      3  68dc				  -	      ERR
      4  68dc					      ENDIF
      5  68dc		       14		      .byte.b	20
      0  68dd					      EVAL8	5
      1  68dd				  -	      IF	(5 > 127) || (5 < -128)
      2  68dd				  -	      ECHO	"Erroneous position value", 5
      3  68dd				  -	      ERR
      4  68dd					      ENDIF
      5  68dd		       05		      .byte.b	5
      0  68de					      EVAL8	5
      1  68de				  -	      IF	(5 > 127) || (5 < -128)
      2  68de				  -	      ECHO	"Erroneous position value", 5
      3  68de				  -	      ERR
      4  68de					      ENDIF
      5  68de		       05		      .byte.b	5
      0  68df					      EVAL8	-10
      1  68df				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68df				  -	      ECHO	"Erroneous position value", -10
      3  68df				  -	      ERR
      4  68df					      ENDIF
      5  68df		       f6		      .byte.b	-10
      0  68e0					      EVAL8	0
      1  68e0				  -	      IF	(0 > 127) || (0 < -128)
      2  68e0				  -	      ECHO	"Erroneous position value", 0
      3  68e0				  -	      ERR
      4  68e0					      ENDIF
      5  68e0		       00		      .byte.b	0
      0  68e1					      EVAL8	0
      1  68e1				  -	      IF	(0 > 127) || (0 < -128)
      2  68e1				  -	      ECHO	"Erroneous position value", 0
      3  68e1				  -	      ERR
      4  68e1					      ENDIF
      5  68e1		       00		      .byte.b	0
      0  68e2					      PVAL	-10, 0, 5, 10, 10, 5, 0, -10
      0  68e2					      EVAL8	-10
      1  68e2				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68e2				  -	      ECHO	"Erroneous position value", -10
      3  68e2				  -	      ERR
      4  68e2					      ENDIF
      5  68e2		       f6		      .byte.b	-10
      0  68e3					      EVAL8	0
      1  68e3				  -	      IF	(0 > 127) || (0 < -128)
      2  68e3				  -	      ECHO	"Erroneous position value", 0
      3  68e3				  -	      ERR
      4  68e3					      ENDIF
      5  68e3		       00		      .byte.b	0
      0  68e4					      EVAL8	5
      1  68e4				  -	      IF	(5 > 127) || (5 < -128)
      2  68e4				  -	      ECHO	"Erroneous position value", 5
      3  68e4				  -	      ERR
      4  68e4					      ENDIF
      5  68e4		       05		      .byte.b	5
      0  68e5					      EVAL8	10
      1  68e5				  -	      IF	(10 > 127) || (10 < -128)
      2  68e5				  -	      ECHO	"Erroneous position value", 10
      3  68e5				  -	      ERR
      4  68e5					      ENDIF
      5  68e5		       0a		      .byte.b	10
      0  68e6					      EVAL8	10
      1  68e6				  -	      IF	(10 > 127) || (10 < -128)
      2  68e6				  -	      ECHO	"Erroneous position value", 10
      3  68e6				  -	      ERR
      4  68e6					      ENDIF
      5  68e6		       0a		      .byte.b	10
      0  68e7					      EVAL8	5
      1  68e7				  -	      IF	(5 > 127) || (5 < -128)
      2  68e7				  -	      ECHO	"Erroneous position value", 5
      3  68e7				  -	      ERR
      4  68e7					      ENDIF
      5  68e7		       05		      .byte.b	5
      0  68e8					      EVAL8	0
      1  68e8				  -	      IF	(0 > 127) || (0 < -128)
      2  68e8				  -	      ECHO	"Erroneous position value", 0
      3  68e8				  -	      ERR
      4  68e8					      ENDIF
      5  68e8		       00		      .byte.b	0
      0  68e9					      EVAL8	-10
      1  68e9				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68e9				  -	      ECHO	"Erroneous position value", -10
      3  68e9				  -	      ERR
      4  68e9					      ENDIF
      5  68e9		       f6		      .byte.b	-10
      0  68ea					      EVAL8	0
      1  68ea				  -	      IF	(0 > 127) || (0 < -128)
      2  68ea				  -	      ECHO	"Erroneous position value", 0
      3  68ea				  -	      ERR
      4  68ea					      ENDIF
      5  68ea		       00		      .byte.b	0
      0  68eb					      EVAL8	0
      1  68eb				  -	      IF	(0 > 127) || (0 < -128)
      2  68eb				  -	      ECHO	"Erroneous position value", 0
      3  68eb				  -	      ERR
      4  68eb					      ENDIF
      5  68eb		       00		      .byte.b	0
      0  68ec					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      0  68ec					      EVAL8	-10
      1  68ec				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68ec				  -	      ECHO	"Erroneous position value", -10
      3  68ec				  -	      ERR
      4  68ec					      ENDIF
      5  68ec		       f6		      .byte.b	-10
      0  68ed					      EVAL8	0
      1  68ed				  -	      IF	(0 > 127) || (0 < -128)
      2  68ed				  -	      ECHO	"Erroneous position value", 0
      3  68ed				  -	      ERR
      4  68ed					      ENDIF
      5  68ed		       00		      .byte.b	0
      0  68ee					      EVAL8	0
      1  68ee				  -	      IF	(0 > 127) || (0 < -128)
      2  68ee				  -	      ECHO	"Erroneous position value", 0
      3  68ee				  -	      ERR
      4  68ee					      ENDIF
      5  68ee		       00		      .byte.b	0
      0  68ef					      EVAL8	0
      1  68ef				  -	      IF	(0 > 127) || (0 < -128)
      2  68ef				  -	      ECHO	"Erroneous position value", 0
      3  68ef				  -	      ERR
      4  68ef					      ENDIF
      5  68ef		       00		      .byte.b	0
      0  68f0					      EVAL8	0
      1  68f0				  -	      IF	(0 > 127) || (0 < -128)
      2  68f0				  -	      ECHO	"Erroneous position value", 0
      3  68f0				  -	      ERR
      4  68f0					      ENDIF
      5  68f0		       00		      .byte.b	0
      0  68f1					      EVAL8	0
      1  68f1				  -	      IF	(0 > 127) || (0 < -128)
      2  68f1				  -	      ECHO	"Erroneous position value", 0
      3  68f1				  -	      ERR
      4  68f1					      ENDIF
      5  68f1		       00		      .byte.b	0
      0  68f2					      EVAL8	0
      1  68f2				  -	      IF	(0 > 127) || (0 < -128)
      2  68f2				  -	      ECHO	"Erroneous position value", 0
      3  68f2				  -	      ERR
      4  68f2					      ENDIF
      5  68f2		       00		      .byte.b	0
      0  68f3					      EVAL8	-10
      1  68f3				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68f3				  -	      ECHO	"Erroneous position value", -10
      3  68f3				  -	      ERR
      4  68f3					      ENDIF
      5  68f3		       f6		      .byte.b	-10
      0  68f4					      EVAL8	0
      1  68f4				  -	      IF	(0 > 127) || (0 < -128)
      2  68f4				  -	      ECHO	"Erroneous position value", 0
      3  68f4				  -	      ERR
      4  68f4					      ENDIF
      5  68f4		       00		      .byte.b	0
      0  68f5					      EVAL8	0
      1  68f5				  -	      IF	(0 > 127) || (0 < -128)
      2  68f5				  -	      ECHO	"Erroneous position value", 0
      3  68f5				  -	      ERR
      4  68f5					      ENDIF
      5  68f5		       00		      .byte.b	0
      0  68f6					      PVAL	-20, -10, -10, -10, -10, -10, -10, -20
      0  68f6					      EVAL8	-20
      1  68f6				  -	      IF	(-20 > 127) || (-20 < -128)
      2  68f6				  -	      ECHO	"Erroneous position value", -20
      3  68f6				  -	      ERR
      4  68f6					      ENDIF
      5  68f6		       ec		      .byte.b	-20
      0  68f7					      EVAL8	-10
      1  68f7				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68f7				  -	      ECHO	"Erroneous position value", -10
      3  68f7				  -	      ERR
      4  68f7					      ENDIF
      5  68f7		       f6		      .byte.b	-10
      0  68f8					      EVAL8	-10
      1  68f8				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68f8				  -	      ECHO	"Erroneous position value", -10
      3  68f8				  -	      ERR
      4  68f8					      ENDIF
      5  68f8		       f6		      .byte.b	-10
      0  68f9					      EVAL8	-10
      1  68f9				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68f9				  -	      ECHO	"Erroneous position value", -10
      3  68f9				  -	      ERR
      4  68f9					      ENDIF
      5  68f9		       f6		      .byte.b	-10
      0  68fa					      EVAL8	-10
      1  68fa				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68fa				  -	      ECHO	"Erroneous position value", -10
      3  68fa				  -	      ERR
      4  68fa					      ENDIF
      5  68fa		       f6		      .byte.b	-10
      0  68fb					      EVAL8	-10
      1  68fb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68fb				  -	      ECHO	"Erroneous position value", -10
      3  68fb				  -	      ERR
      4  68fb					      ENDIF
      5  68fb		       f6		      .byte.b	-10
      0  68fc					      EVAL8	-10
      1  68fc				  -	      IF	(-10 > 127) || (-10 < -128)
      2  68fc				  -	      ECHO	"Erroneous position value", -10
      3  68fc				  -	      ERR
      4  68fc					      ENDIF
      5  68fc		       f6		      .byte.b	-10
      0  68fd					      EVAL8	-20
      1  68fd				  -	      IF	(-20 > 127) || (-20 < -128)
      2  68fd				  -	      ECHO	"Erroneous position value", -20
      3  68fd				  -	      ERR
      4  68fd					      ENDIF
      5  68fd		       ec		      .byte.b	-20
      0  68fe					      EVAL8	0
      1  68fe				  -	      IF	(0 > 127) || (0 < -128)
      2  68fe				  -	      ECHO	"Erroneous position value", 0
      3  68fe				  -	      ERR
      4  68fe					      ENDIF
      5  68fe		       00		      .byte.b	0
      0  68ff					      EVAL8	0
      1  68ff				  -	      IF	(0 > 127) || (0 < -128)
      2  68ff				  -	      ECHO	"Erroneous position value", 0
      3  68ff				  -	      ERR
      4  68ff					      ENDIF
      5  68ff		       00		      .byte.b	0
    111  6900
    112  6900
    113  6900							;---------------------------------------------------------------------------------------------------
    114  6900
    115  6900				   PositionalValue_ROOK
    116  6900
      0  6900					      PVAL	-25, -20, 10, 0, 55, 0, -20, -25
      0  6900					      EVAL8	-25
      1  6900				  -	      IF	(-25 > 127) || (-25 < -128)
      2  6900				  -	      ECHO	"Erroneous position value", -25
      3  6900				  -	      ERR
      4  6900					      ENDIF
      5  6900		       e7		      .byte.b	-25
      0  6901					      EVAL8	-20
      1  6901				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6901				  -	      ECHO	"Erroneous position value", -20
      3  6901				  -	      ERR
      4  6901					      ENDIF
      5  6901		       ec		      .byte.b	-20
      0  6902					      EVAL8	10
      1  6902				  -	      IF	(10 > 127) || (10 < -128)
      2  6902				  -	      ECHO	"Erroneous position value", 10
      3  6902				  -	      ERR
      4  6902					      ENDIF
      5  6902		       0a		      .byte.b	10
      0  6903					      EVAL8	0
      1  6903				  -	      IF	(0 > 127) || (0 < -128)
      2  6903				  -	      ECHO	"Erroneous position value", 0
      3  6903				  -	      ERR
      4  6903					      ENDIF
      5  6903		       00		      .byte.b	0
      0  6904					      EVAL8	55
      1  6904				  -	      IF	(55 > 127) || (55 < -128)
      2  6904				  -	      ECHO	"Erroneous position value", 55
      3  6904				  -	      ERR
      4  6904					      ENDIF
      5  6904		       37		      .byte.b	55
      0  6905					      EVAL8	0
      1  6905				  -	      IF	(0 > 127) || (0 < -128)
      2  6905				  -	      ECHO	"Erroneous position value", 0
      3  6905				  -	      ERR
      4  6905					      ENDIF
      5  6905		       00		      .byte.b	0
      0  6906					      EVAL8	-20
      1  6906				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6906				  -	      ECHO	"Erroneous position value", -20
      3  6906				  -	      ERR
      4  6906					      ENDIF
      5  6906		       ec		      .byte.b	-20
      0  6907					      EVAL8	-25
      1  6907				  -	      IF	(-25 > 127) || (-25 < -128)
      2  6907				  -	      ECHO	"Erroneous position value", -25
      3  6907				  -	      ERR
      4  6907					      ENDIF
      5  6907		       e7		      .byte.b	-25
      0  6908					      EVAL8	0
      1  6908				  -	      IF	(0 > 127) || (0 < -128)
      2  6908				  -	      ECHO	"Erroneous position value", 0
      3  6908				  -	      ERR
      4  6908					      ENDIF
      5  6908		       00		      .byte.b	0
      0  6909					      EVAL8	0
      1  6909				  -	      IF	(0 > 127) || (0 < -128)
      2  6909				  -	      ECHO	"Erroneous position value", 0
      3  6909				  -	      ERR
      4  6909					      ENDIF
      5  6909		       00		      .byte.b	0
      0  690a					      PVAL	-120, 0, 0, 0, 0, 0, 0, -128
      0  690a					      EVAL8	-120
      1  690a				  -	      IF	(-120 > 127) || (-120 < -128)
      2  690a				  -	      ECHO	"Erroneous position value", -120
      3  690a				  -	      ERR
      4  690a					      ENDIF
      5  690a		       88		      .byte.b	-120
      0  690b					      EVAL8	0
      1  690b				  -	      IF	(0 > 127) || (0 < -128)
      2  690b				  -	      ECHO	"Erroneous position value", 0
      3  690b				  -	      ERR
      4  690b					      ENDIF
      5  690b		       00		      .byte.b	0
      0  690c					      EVAL8	0
      1  690c				  -	      IF	(0 > 127) || (0 < -128)
      2  690c				  -	      ECHO	"Erroneous position value", 0
      3  690c				  -	      ERR
      4  690c					      ENDIF
      5  690c		       00		      .byte.b	0
      0  690d					      EVAL8	0
      1  690d				  -	      IF	(0 > 127) || (0 < -128)
      2  690d				  -	      ECHO	"Erroneous position value", 0
      3  690d				  -	      ERR
      4  690d					      ENDIF
      5  690d		       00		      .byte.b	0
      0  690e					      EVAL8	0
      1  690e				  -	      IF	(0 > 127) || (0 < -128)
      2  690e				  -	      ECHO	"Erroneous position value", 0
      3  690e				  -	      ERR
      4  690e					      ENDIF
      5  690e		       00		      .byte.b	0
      0  690f					      EVAL8	0
      1  690f				  -	      IF	(0 > 127) || (0 < -128)
      2  690f				  -	      ECHO	"Erroneous position value", 0
      3  690f				  -	      ERR
      4  690f					      ENDIF
      5  690f		       00		      .byte.b	0
      0  6910					      EVAL8	0
      1  6910				  -	      IF	(0 > 127) || (0 < -128)
      2  6910				  -	      ECHO	"Erroneous position value", 0
      3  6910				  -	      ERR
      4  6910					      ENDIF
      5  6910		       00		      .byte.b	0
      0  6911					      EVAL8	-128
      1  6911				  -	      IF	(-128 > 127) || (-128 < -128)
      2  6911				  -	      ECHO	"Erroneous position value", -128
      3  6911				  -	      ERR
      4  6911					      ENDIF
      5  6911		       80		      .byte.b	-128
      0  6912					      EVAL8	0
      1  6912				  -	      IF	(0 > 127) || (0 < -128)
      2  6912				  -	      ECHO	"Erroneous position value", 0
      3  6912				  -	      ERR
      4  6912					      ENDIF
      5  6912		       00		      .byte.b	0
      0  6913					      EVAL8	0
      1  6913				  -	      IF	(0 > 127) || (0 < -128)
      2  6913				  -	      ECHO	"Erroneous position value", 0
      3  6913				  -	      ERR
      4  6913					      ENDIF
      5  6913		       00		      .byte.b	0
      0  6914					      PVAL	-128, 0, 0, 0, 0, 0, 0, -100
      0  6914					      EVAL8	-128
      1  6914				  -	      IF	(-128 > 127) || (-128 < -128)
      2  6914				  -	      ECHO	"Erroneous position value", -128
      3  6914				  -	      ERR
      4  6914					      ENDIF
      5  6914		       80		      .byte.b	-128
      0  6915					      EVAL8	0
      1  6915				  -	      IF	(0 > 127) || (0 < -128)
      2  6915				  -	      ECHO	"Erroneous position value", 0
      3  6915				  -	      ERR
      4  6915					      ENDIF
      5  6915		       00		      .byte.b	0
      0  6916					      EVAL8	0
      1  6916				  -	      IF	(0 > 127) || (0 < -128)
      2  6916				  -	      ECHO	"Erroneous position value", 0
      3  6916				  -	      ERR
      4  6916					      ENDIF
      5  6916		       00		      .byte.b	0
      0  6917					      EVAL8	0
      1  6917				  -	      IF	(0 > 127) || (0 < -128)
      2  6917				  -	      ECHO	"Erroneous position value", 0
      3  6917				  -	      ERR
      4  6917					      ENDIF
      5  6917		       00		      .byte.b	0
      0  6918					      EVAL8	0
      1  6918				  -	      IF	(0 > 127) || (0 < -128)
      2  6918				  -	      ECHO	"Erroneous position value", 0
      3  6918				  -	      ERR
      4  6918					      ENDIF
      5  6918		       00		      .byte.b	0
      0  6919					      EVAL8	0
      1  6919				  -	      IF	(0 > 127) || (0 < -128)
      2  6919				  -	      ECHO	"Erroneous position value", 0
      3  6919				  -	      ERR
      4  6919					      ENDIF
      5  6919		       00		      .byte.b	0
      0  691a					      EVAL8	0
      1  691a				  -	      IF	(0 > 127) || (0 < -128)
      2  691a				  -	      ECHO	"Erroneous position value", 0
      3  691a				  -	      ERR
      4  691a					      ENDIF
      5  691a		       00		      .byte.b	0
      0  691b					      EVAL8	-100
      1  691b				  -	      IF	(-100 > 127) || (-100 < -128)
      2  691b				  -	      ECHO	"Erroneous position value", -100
      3  691b				  -	      ERR
      4  691b					      ENDIF
      5  691b		       9c		      .byte.b	-100
      0  691c					      EVAL8	0
      1  691c				  -	      IF	(0 > 127) || (0 < -128)
      2  691c				  -	      ECHO	"Erroneous position value", 0
      3  691c				  -	      ERR
      4  691c					      ENDIF
      5  691c		       00		      .byte.b	0
      0  691d					      EVAL8	0
      1  691d				  -	      IF	(0 > 127) || (0 < -128)
      2  691d				  -	      ECHO	"Erroneous position value", 0
      3  691d				  -	      ERR
      4  691d					      ENDIF
      5  691d		       00		      .byte.b	0
      0  691e					      PVAL	-100, 0, 0, 0, 0, 0, 0, -100
      0  691e					      EVAL8	-100
      1  691e				  -	      IF	(-100 > 127) || (-100 < -128)
      2  691e				  -	      ECHO	"Erroneous position value", -100
      3  691e				  -	      ERR
      4  691e					      ENDIF
      5  691e		       9c		      .byte.b	-100
      0  691f					      EVAL8	0
      1  691f				  -	      IF	(0 > 127) || (0 < -128)
      2  691f				  -	      ECHO	"Erroneous position value", 0
      3  691f				  -	      ERR
      4  691f					      ENDIF
      5  691f		       00		      .byte.b	0
      0  6920					      EVAL8	0
      1  6920				  -	      IF	(0 > 127) || (0 < -128)
      2  6920				  -	      ECHO	"Erroneous position value", 0
      3  6920				  -	      ERR
      4  6920					      ENDIF
      5  6920		       00		      .byte.b	0
      0  6921					      EVAL8	0
      1  6921				  -	      IF	(0 > 127) || (0 < -128)
      2  6921				  -	      ECHO	"Erroneous position value", 0
      3  6921				  -	      ERR
      4  6921					      ENDIF
      5  6921		       00		      .byte.b	0
      0  6922					      EVAL8	0
      1  6922				  -	      IF	(0 > 127) || (0 < -128)
      2  6922				  -	      ECHO	"Erroneous position value", 0
      3  6922				  -	      ERR
      4  6922					      ENDIF
      5  6922		       00		      .byte.b	0
      0  6923					      EVAL8	0
      1  6923				  -	      IF	(0 > 127) || (0 < -128)
      2  6923				  -	      ECHO	"Erroneous position value", 0
      3  6923				  -	      ERR
      4  6923					      ENDIF
      5  6923		       00		      .byte.b	0
      0  6924					      EVAL8	0
      1  6924				  -	      IF	(0 > 127) || (0 < -128)
      2  6924				  -	      ECHO	"Erroneous position value", 0
      3  6924				  -	      ERR
      4  6924					      ENDIF
      5  6924		       00		      .byte.b	0
      0  6925					      EVAL8	-100
      1  6925				  -	      IF	(-100 > 127) || (-100 < -128)
      2  6925				  -	      ECHO	"Erroneous position value", -100
      3  6925				  -	      ERR
      4  6925					      ENDIF
      5  6925		       9c		      .byte.b	-100
      0  6926					      EVAL8	0
      1  6926				  -	      IF	(0 > 127) || (0 < -128)
      2  6926				  -	      ECHO	"Erroneous position value", 0
      3  6926				  -	      ERR
      4  6926					      ENDIF
      5  6926		       00		      .byte.b	0
      0  6927					      EVAL8	0
      1  6927				  -	      IF	(0 > 127) || (0 < -128)
      2  6927				  -	      ECHO	"Erroneous position value", 0
      3  6927				  -	      ERR
      4  6927					      ENDIF
      5  6927		       00		      .byte.b	0
      0  6928					      PVAL	-50, 0, 0, 0, 0, 0, 0, -50
      0  6928					      EVAL8	-50
      1  6928				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6928				  -	      ECHO	"Erroneous position value", -50
      3  6928				  -	      ERR
      4  6928					      ENDIF
      5  6928		       ce		      .byte.b	-50
      0  6929					      EVAL8	0
      1  6929				  -	      IF	(0 > 127) || (0 < -128)
      2  6929				  -	      ECHO	"Erroneous position value", 0
      3  6929				  -	      ERR
      4  6929					      ENDIF
      5  6929		       00		      .byte.b	0
      0  692a					      EVAL8	0
      1  692a				  -	      IF	(0 > 127) || (0 < -128)
      2  692a				  -	      ECHO	"Erroneous position value", 0
      3  692a				  -	      ERR
      4  692a					      ENDIF
      5  692a		       00		      .byte.b	0
      0  692b					      EVAL8	0
      1  692b				  -	      IF	(0 > 127) || (0 < -128)
      2  692b				  -	      ECHO	"Erroneous position value", 0
      3  692b				  -	      ERR
      4  692b					      ENDIF
      5  692b		       00		      .byte.b	0
      0  692c					      EVAL8	0
      1  692c				  -	      IF	(0 > 127) || (0 < -128)
      2  692c				  -	      ECHO	"Erroneous position value", 0
      3  692c				  -	      ERR
      4  692c					      ENDIF
      5  692c		       00		      .byte.b	0
      0  692d					      EVAL8	0
      1  692d				  -	      IF	(0 > 127) || (0 < -128)
      2  692d				  -	      ECHO	"Erroneous position value", 0
      3  692d				  -	      ERR
      4  692d					      ENDIF
      5  692d		       00		      .byte.b	0
      0  692e					      EVAL8	0
      1  692e				  -	      IF	(0 > 127) || (0 < -128)
      2  692e				  -	      ECHO	"Erroneous position value", 0
      3  692e				  -	      ERR
      4  692e					      ENDIF
      5  692e		       00		      .byte.b	0
      0  692f					      EVAL8	-50
      1  692f				  -	      IF	(-50 > 127) || (-50 < -128)
      2  692f				  -	      ECHO	"Erroneous position value", -50
      3  692f				  -	      ERR
      4  692f					      ENDIF
      5  692f		       ce		      .byte.b	-50
      0  6930					      EVAL8	0
      1  6930				  -	      IF	(0 > 127) || (0 < -128)
      2  6930				  -	      ECHO	"Erroneous position value", 0
      3  6930				  -	      ERR
      4  6930					      ENDIF
      5  6930		       00		      .byte.b	0
      0  6931					      EVAL8	0
      1  6931				  -	      IF	(0 > 127) || (0 < -128)
      2  6931				  -	      ECHO	"Erroneous position value", 0
      3  6931				  -	      ERR
      4  6931					      ENDIF
      5  6931		       00		      .byte.b	0
      0  6932					      PVAL	-5, 0, 30, 30, 30, 30, 0, -5
      0  6932					      EVAL8	-5
      1  6932				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6932				  -	      ECHO	"Erroneous position value", -5
      3  6932				  -	      ERR
      4  6932					      ENDIF
      5  6932		       fb		      .byte.b	-5
      0  6933					      EVAL8	0
      1  6933				  -	      IF	(0 > 127) || (0 < -128)
      2  6933				  -	      ECHO	"Erroneous position value", 0
      3  6933				  -	      ERR
      4  6933					      ENDIF
      5  6933		       00		      .byte.b	0
      0  6934					      EVAL8	30
      1  6934				  -	      IF	(30 > 127) || (30 < -128)
      2  6934				  -	      ECHO	"Erroneous position value", 30
      3  6934				  -	      ERR
      4  6934					      ENDIF
      5  6934		       1e		      .byte.b	30
      0  6935					      EVAL8	30
      1  6935				  -	      IF	(30 > 127) || (30 < -128)
      2  6935				  -	      ECHO	"Erroneous position value", 30
      3  6935				  -	      ERR
      4  6935					      ENDIF
      5  6935		       1e		      .byte.b	30
      0  6936					      EVAL8	30
      1  6936				  -	      IF	(30 > 127) || (30 < -128)
      2  6936				  -	      ECHO	"Erroneous position value", 30
      3  6936				  -	      ERR
      4  6936					      ENDIF
      5  6936		       1e		      .byte.b	30
      0  6937					      EVAL8	30
      1  6937				  -	      IF	(30 > 127) || (30 < -128)
      2  6937				  -	      ECHO	"Erroneous position value", 30
      3  6937				  -	      ERR
      4  6937					      ENDIF
      5  6937		       1e		      .byte.b	30
      0  6938					      EVAL8	0
      1  6938				  -	      IF	(0 > 127) || (0 < -128)
      2  6938				  -	      ECHO	"Erroneous position value", 0
      3  6938				  -	      ERR
      4  6938					      ENDIF
      5  6938		       00		      .byte.b	0
      0  6939					      EVAL8	-5
      1  6939				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6939				  -	      ECHO	"Erroneous position value", -5
      3  6939				  -	      ERR
      4  6939					      ENDIF
      5  6939		       fb		      .byte.b	-5
      0  693a					      EVAL8	0
      1  693a				  -	      IF	(0 > 127) || (0 < -128)
      2  693a				  -	      ECHO	"Erroneous position value", 0
      3  693a				  -	      ERR
      4  693a					      ENDIF
      5  693a		       00		      .byte.b	0
      0  693b					      EVAL8	0
      1  693b				  -	      IF	(0 > 127) || (0 < -128)
      2  693b				  -	      ECHO	"Erroneous position value", 0
      3  693b				  -	      ERR
      4  693b					      ENDIF
      5  693b		       00		      .byte.b	0
      0  693c					      PVAL	55, 80, 90, 90, 90, 90, 80, 55
      0  693c					      EVAL8	55
      1  693c				  -	      IF	(55 > 127) || (55 < -128)
      2  693c				  -	      ECHO	"Erroneous position value", 55
      3  693c				  -	      ERR
      4  693c					      ENDIF
      5  693c		       37		      .byte.b	55
      0  693d					      EVAL8	80
      1  693d				  -	      IF	(80 > 127) || (80 < -128)
      2  693d				  -	      ECHO	"Erroneous position value", 80
      3  693d				  -	      ERR
      4  693d					      ENDIF
      5  693d		       50		      .byte.b	80
      0  693e					      EVAL8	90
      1  693e				  -	      IF	(90 > 127) || (90 < -128)
      2  693e				  -	      ECHO	"Erroneous position value", 90
      3  693e				  -	      ERR
      4  693e					      ENDIF
      5  693e		       5a		      .byte.b	90
      0  693f					      EVAL8	90
      1  693f				  -	      IF	(90 > 127) || (90 < -128)
      2  693f				  -	      ECHO	"Erroneous position value", 90
      3  693f				  -	      ERR
      4  693f					      ENDIF
      5  693f		       5a		      .byte.b	90
      0  6940					      EVAL8	90
      1  6940				  -	      IF	(90 > 127) || (90 < -128)
      2  6940				  -	      ECHO	"Erroneous position value", 90
      3  6940				  -	      ERR
      4  6940					      ENDIF
      5  6940		       5a		      .byte.b	90
      0  6941					      EVAL8	90
      1  6941				  -	      IF	(90 > 127) || (90 < -128)
      2  6941				  -	      ECHO	"Erroneous position value", 90
      3  6941				  -	      ERR
      4  6941					      ENDIF
      5  6941		       5a		      .byte.b	90
      0  6942					      EVAL8	80
      1  6942				  -	      IF	(80 > 127) || (80 < -128)
      2  6942				  -	      ECHO	"Erroneous position value", 80
      3  6942				  -	      ERR
      4  6942					      ENDIF
      5  6942		       50		      .byte.b	80
      0  6943					      EVAL8	55
      1  6943				  -	      IF	(55 > 127) || (55 < -128)
      2  6943				  -	      ECHO	"Erroneous position value", 55
      3  6943				  -	      ERR
      4  6943					      ENDIF
      5  6943		       37		      .byte.b	55
      0  6944					      EVAL8	0
      1  6944				  -	      IF	(0 > 127) || (0 < -128)
      2  6944				  -	      ECHO	"Erroneous position value", 0
      3  6944				  -	      ERR
      4  6944					      ENDIF
      5  6944		       00		      .byte.b	0
      0  6945					      EVAL8	0
      1  6945				  -	      IF	(0 > 127) || (0 < -128)
      2  6945				  -	      ECHO	"Erroneous position value", 0
      3  6945				  -	      ERR
      4  6945					      ENDIF
      5  6945		       00		      .byte.b	0
      0  6946					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  6946					      EVAL8	0
      1  6946				  -	      IF	(0 > 127) || (0 < -128)
      2  6946				  -	      ECHO	"Erroneous position value", 0
      3  6946				  -	      ERR
      4  6946					      ENDIF
      5  6946		       00		      .byte.b	0
      0  6947					      EVAL8	0
      1  6947				  -	      IF	(0 > 127) || (0 < -128)
      2  6947				  -	      ECHO	"Erroneous position value", 0
      3  6947				  -	      ERR
      4  6947					      ENDIF
      5  6947		       00		      .byte.b	0
      0  6948					      EVAL8	0
      1  6948				  -	      IF	(0 > 127) || (0 < -128)
      2  6948				  -	      ECHO	"Erroneous position value", 0
      3  6948				  -	      ERR
      4  6948					      ENDIF
      5  6948		       00		      .byte.b	0
      0  6949					      EVAL8	0
      1  6949				  -	      IF	(0 > 127) || (0 < -128)
      2  6949				  -	      ECHO	"Erroneous position value", 0
      3  6949				  -	      ERR
      4  6949					      ENDIF
      5  6949		       00		      .byte.b	0
      0  694a					      EVAL8	0
      1  694a				  -	      IF	(0 > 127) || (0 < -128)
      2  694a				  -	      ECHO	"Erroneous position value", 0
      3  694a				  -	      ERR
      4  694a					      ENDIF
      5  694a		       00		      .byte.b	0
      0  694b					      EVAL8	0
      1  694b				  -	      IF	(0 > 127) || (0 < -128)
      2  694b				  -	      ECHO	"Erroneous position value", 0
      3  694b				  -	      ERR
      4  694b					      ENDIF
      5  694b		       00		      .byte.b	0
      0  694c					      EVAL8	0
      1  694c				  -	      IF	(0 > 127) || (0 < -128)
      2  694c				  -	      ECHO	"Erroneous position value", 0
      3  694c				  -	      ERR
      4  694c					      ENDIF
      5  694c		       00		      .byte.b	0
      0  694d					      EVAL8	0
      1  694d				  -	      IF	(0 > 127) || (0 < -128)
      2  694d				  -	      ECHO	"Erroneous position value", 0
      3  694d				  -	      ERR
      4  694d					      ENDIF
      5  694d		       00		      .byte.b	0
      0  694e					      EVAL8	0
      1  694e				  -	      IF	(0 > 127) || (0 < -128)
      2  694e				  -	      ECHO	"Erroneous position value", 0
      3  694e				  -	      ERR
      4  694e					      ENDIF
      5  694e		       00		      .byte.b	0
      0  694f					      EVAL8	0
      1  694f				  -	      IF	(0 > 127) || (0 < -128)
      2  694f				  -	      ECHO	"Erroneous position value", 0
      3  694f				  -	      ERR
      4  694f					      ENDIF
      5  694f		       00		      .byte.b	0
    125  6950
    126  6950
    127  6950							;---------------------------------------------------------------------------------------------------
    128  6950
    129  6950				   PositionalValue_QUEEN
    130  6950
      0  6950					      PVAL	-20, -10, -5, -5, -5, -10, -10, -20
      0  6950					      EVAL8	-20
      1  6950				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6950				  -	      ECHO	"Erroneous position value", -20
      3  6950				  -	      ERR
      4  6950					      ENDIF
      5  6950		       ec		      .byte.b	-20
      0  6951					      EVAL8	-10
      1  6951				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6951				  -	      ECHO	"Erroneous position value", -10
      3  6951				  -	      ERR
      4  6951					      ENDIF
      5  6951		       f6		      .byte.b	-10
      0  6952					      EVAL8	-5
      1  6952				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6952				  -	      ECHO	"Erroneous position value", -5
      3  6952				  -	      ERR
      4  6952					      ENDIF
      5  6952		       fb		      .byte.b	-5
      0  6953					      EVAL8	-5
      1  6953				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6953				  -	      ECHO	"Erroneous position value", -5
      3  6953				  -	      ERR
      4  6953					      ENDIF
      5  6953		       fb		      .byte.b	-5
      0  6954					      EVAL8	-5
      1  6954				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6954				  -	      ECHO	"Erroneous position value", -5
      3  6954				  -	      ERR
      4  6954					      ENDIF
      5  6954		       fb		      .byte.b	-5
      0  6955					      EVAL8	-10
      1  6955				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6955				  -	      ECHO	"Erroneous position value", -10
      3  6955				  -	      ERR
      4  6955					      ENDIF
      5  6955		       f6		      .byte.b	-10
      0  6956					      EVAL8	-10
      1  6956				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6956				  -	      ECHO	"Erroneous position value", -10
      3  6956				  -	      ERR
      4  6956					      ENDIF
      5  6956		       f6		      .byte.b	-10
      0  6957					      EVAL8	-20
      1  6957				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6957				  -	      ECHO	"Erroneous position value", -20
      3  6957				  -	      ERR
      4  6957					      ENDIF
      5  6957		       ec		      .byte.b	-20
      0  6958					      EVAL8	0
      1  6958				  -	      IF	(0 > 127) || (0 < -128)
      2  6958				  -	      ECHO	"Erroneous position value", 0
      3  6958				  -	      ERR
      4  6958					      ENDIF
      5  6958		       00		      .byte.b	0
      0  6959					      EVAL8	0
      1  6959				  -	      IF	(0 > 127) || (0 < -128)
      2  6959				  -	      ECHO	"Erroneous position value", 0
      3  6959				  -	      ERR
      4  6959					      ENDIF
      5  6959		       00		      .byte.b	0
      0  695a					      PVAL	-10, 0, 5, 0, 0, 0, 0, -10
      0  695a					      EVAL8	-10
      1  695a				  -	      IF	(-10 > 127) || (-10 < -128)
      2  695a				  -	      ECHO	"Erroneous position value", -10
      3  695a				  -	      ERR
      4  695a					      ENDIF
      5  695a		       f6		      .byte.b	-10
      0  695b					      EVAL8	0
      1  695b				  -	      IF	(0 > 127) || (0 < -128)
      2  695b				  -	      ECHO	"Erroneous position value", 0
      3  695b				  -	      ERR
      4  695b					      ENDIF
      5  695b		       00		      .byte.b	0
      0  695c					      EVAL8	5
      1  695c				  -	      IF	(5 > 127) || (5 < -128)
      2  695c				  -	      ECHO	"Erroneous position value", 5
      3  695c				  -	      ERR
      4  695c					      ENDIF
      5  695c		       05		      .byte.b	5
      0  695d					      EVAL8	0
      1  695d				  -	      IF	(0 > 127) || (0 < -128)
      2  695d				  -	      ECHO	"Erroneous position value", 0
      3  695d				  -	      ERR
      4  695d					      ENDIF
      5  695d		       00		      .byte.b	0
      0  695e					      EVAL8	0
      1  695e				  -	      IF	(0 > 127) || (0 < -128)
      2  695e				  -	      ECHO	"Erroneous position value", 0
      3  695e				  -	      ERR
      4  695e					      ENDIF
      5  695e		       00		      .byte.b	0
      0  695f					      EVAL8	0
      1  695f				  -	      IF	(0 > 127) || (0 < -128)
      2  695f				  -	      ECHO	"Erroneous position value", 0
      3  695f				  -	      ERR
      4  695f					      ENDIF
      5  695f		       00		      .byte.b	0
      0  6960					      EVAL8	0
      1  6960				  -	      IF	(0 > 127) || (0 < -128)
      2  6960				  -	      ECHO	"Erroneous position value", 0
      3  6960				  -	      ERR
      4  6960					      ENDIF
      5  6960		       00		      .byte.b	0
      0  6961					      EVAL8	-10
      1  6961				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6961				  -	      ECHO	"Erroneous position value", -10
      3  6961				  -	      ERR
      4  6961					      ENDIF
      5  6961		       f6		      .byte.b	-10
      0  6962					      EVAL8	0
      1  6962				  -	      IF	(0 > 127) || (0 < -128)
      2  6962				  -	      ECHO	"Erroneous position value", 0
      3  6962				  -	      ERR
      4  6962					      ENDIF
      5  6962		       00		      .byte.b	0
      0  6963					      EVAL8	0
      1  6963				  -	      IF	(0 > 127) || (0 < -128)
      2  6963				  -	      ECHO	"Erroneous position value", 0
      3  6963				  -	      ERR
      4  6963					      ENDIF
      5  6963		       00		      .byte.b	0
      0  6964					      PVAL	-10, 5, 5, 5, 5, 25, 0, -10
      0  6964					      EVAL8	-10
      1  6964				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6964				  -	      ECHO	"Erroneous position value", -10
      3  6964				  -	      ERR
      4  6964					      ENDIF
      5  6964		       f6		      .byte.b	-10
      0  6965					      EVAL8	5
      1  6965				  -	      IF	(5 > 127) || (5 < -128)
      2  6965				  -	      ECHO	"Erroneous position value", 5
      3  6965				  -	      ERR
      4  6965					      ENDIF
      5  6965		       05		      .byte.b	5
      0  6966					      EVAL8	5
      1  6966				  -	      IF	(5 > 127) || (5 < -128)
      2  6966				  -	      ECHO	"Erroneous position value", 5
      3  6966				  -	      ERR
      4  6966					      ENDIF
      5  6966		       05		      .byte.b	5
      0  6967					      EVAL8	5
      1  6967				  -	      IF	(5 > 127) || (5 < -128)
      2  6967				  -	      ECHO	"Erroneous position value", 5
      3  6967				  -	      ERR
      4  6967					      ENDIF
      5  6967		       05		      .byte.b	5
      0  6968					      EVAL8	5
      1  6968				  -	      IF	(5 > 127) || (5 < -128)
      2  6968				  -	      ECHO	"Erroneous position value", 5
      3  6968				  -	      ERR
      4  6968					      ENDIF
      5  6968		       05		      .byte.b	5
      0  6969					      EVAL8	25
      1  6969				  -	      IF	(25 > 127) || (25 < -128)
      2  6969				  -	      ECHO	"Erroneous position value", 25
      3  6969				  -	      ERR
      4  6969					      ENDIF
      5  6969		       19		      .byte.b	25
      0  696a					      EVAL8	0
      1  696a				  -	      IF	(0 > 127) || (0 < -128)
      2  696a				  -	      ECHO	"Erroneous position value", 0
      3  696a				  -	      ERR
      4  696a					      ENDIF
      5  696a		       00		      .byte.b	0
      0  696b					      EVAL8	-10
      1  696b				  -	      IF	(-10 > 127) || (-10 < -128)
      2  696b				  -	      ECHO	"Erroneous position value", -10
      3  696b				  -	      ERR
      4  696b					      ENDIF
      5  696b		       f6		      .byte.b	-10
      0  696c					      EVAL8	0
      1  696c				  -	      IF	(0 > 127) || (0 < -128)
      2  696c				  -	      ECHO	"Erroneous position value", 0
      3  696c				  -	      ERR
      4  696c					      ENDIF
      5  696c		       00		      .byte.b	0
      0  696d					      EVAL8	0
      1  696d				  -	      IF	(0 > 127) || (0 < -128)
      2  696d				  -	      ECHO	"Erroneous position value", 0
      3  696d				  -	      ERR
      4  696d					      ENDIF
      5  696d		       00		      .byte.b	0
      0  696e					      PVAL	-10, 0, 5, 25, 25, 25, 0, -10
      0  696e					      EVAL8	-10
      1  696e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  696e				  -	      ECHO	"Erroneous position value", -10
      3  696e				  -	      ERR
      4  696e					      ENDIF
      5  696e		       f6		      .byte.b	-10
      0  696f					      EVAL8	0
      1  696f				  -	      IF	(0 > 127) || (0 < -128)
      2  696f				  -	      ECHO	"Erroneous position value", 0
      3  696f				  -	      ERR
      4  696f					      ENDIF
      5  696f		       00		      .byte.b	0
      0  6970					      EVAL8	5
      1  6970				  -	      IF	(5 > 127) || (5 < -128)
      2  6970				  -	      ECHO	"Erroneous position value", 5
      3  6970				  -	      ERR
      4  6970					      ENDIF
      5  6970		       05		      .byte.b	5
      0  6971					      EVAL8	25
      1  6971				  -	      IF	(25 > 127) || (25 < -128)
      2  6971				  -	      ECHO	"Erroneous position value", 25
      3  6971				  -	      ERR
      4  6971					      ENDIF
      5  6971		       19		      .byte.b	25
      0  6972					      EVAL8	25
      1  6972				  -	      IF	(25 > 127) || (25 < -128)
      2  6972				  -	      ECHO	"Erroneous position value", 25
      3  6972				  -	      ERR
      4  6972					      ENDIF
      5  6972		       19		      .byte.b	25
      0  6973					      EVAL8	25
      1  6973				  -	      IF	(25 > 127) || (25 < -128)
      2  6973				  -	      ECHO	"Erroneous position value", 25
      3  6973				  -	      ERR
      4  6973					      ENDIF
      5  6973		       19		      .byte.b	25
      0  6974					      EVAL8	0
      1  6974				  -	      IF	(0 > 127) || (0 < -128)
      2  6974				  -	      ECHO	"Erroneous position value", 0
      3  6974				  -	      ERR
      4  6974					      ENDIF
      5  6974		       00		      .byte.b	0
      0  6975					      EVAL8	-10
      1  6975				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6975				  -	      ECHO	"Erroneous position value", -10
      3  6975				  -	      ERR
      4  6975					      ENDIF
      5  6975		       f6		      .byte.b	-10
      0  6976					      EVAL8	0
      1  6976				  -	      IF	(0 > 127) || (0 < -128)
      2  6976				  -	      ECHO	"Erroneous position value", 0
      3  6976				  -	      ERR
      4  6976					      ENDIF
      5  6976		       00		      .byte.b	0
      0  6977					      EVAL8	0
      1  6977				  -	      IF	(0 > 127) || (0 < -128)
      2  6977				  -	      ECHO	"Erroneous position value", 0
      3  6977				  -	      ERR
      4  6977					      ENDIF
      5  6977		       00		      .byte.b	0
      0  6978					      PVAL	-5, 0, 15, 55, 55, 55, 0, -5
      0  6978					      EVAL8	-5
      1  6978				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6978				  -	      ECHO	"Erroneous position value", -5
      3  6978				  -	      ERR
      4  6978					      ENDIF
      5  6978		       fb		      .byte.b	-5
      0  6979					      EVAL8	0
      1  6979				  -	      IF	(0 > 127) || (0 < -128)
      2  6979				  -	      ECHO	"Erroneous position value", 0
      3  6979				  -	      ERR
      4  6979					      ENDIF
      5  6979		       00		      .byte.b	0
      0  697a					      EVAL8	15
      1  697a				  -	      IF	(15 > 127) || (15 < -128)
      2  697a				  -	      ECHO	"Erroneous position value", 15
      3  697a				  -	      ERR
      4  697a					      ENDIF
      5  697a		       0f		      .byte.b	15
      0  697b					      EVAL8	55
      1  697b				  -	      IF	(55 > 127) || (55 < -128)
      2  697b				  -	      ECHO	"Erroneous position value", 55
      3  697b				  -	      ERR
      4  697b					      ENDIF
      5  697b		       37		      .byte.b	55
      0  697c					      EVAL8	55
      1  697c				  -	      IF	(55 > 127) || (55 < -128)
      2  697c				  -	      ECHO	"Erroneous position value", 55
      3  697c				  -	      ERR
      4  697c					      ENDIF
      5  697c		       37		      .byte.b	55
      0  697d					      EVAL8	55
      1  697d				  -	      IF	(55 > 127) || (55 < -128)
      2  697d				  -	      ECHO	"Erroneous position value", 55
      3  697d				  -	      ERR
      4  697d					      ENDIF
      5  697d		       37		      .byte.b	55
      0  697e					      EVAL8	0
      1  697e				  -	      IF	(0 > 127) || (0 < -128)
      2  697e				  -	      ECHO	"Erroneous position value", 0
      3  697e				  -	      ERR
      4  697e					      ENDIF
      5  697e		       00		      .byte.b	0
      0  697f					      EVAL8	-5
      1  697f				  -	      IF	(-5 > 127) || (-5 < -128)
      2  697f				  -	      ECHO	"Erroneous position value", -5
      3  697f				  -	      ERR
      4  697f					      ENDIF
      5  697f		       fb		      .byte.b	-5
      0  6980					      EVAL8	0
      1  6980				  -	      IF	(0 > 127) || (0 < -128)
      2  6980				  -	      ECHO	"Erroneous position value", 0
      3  6980				  -	      ERR
      4  6980					      ENDIF
      5  6980		       00		      .byte.b	0
      0  6981					      EVAL8	0
      1  6981				  -	      IF	(0 > 127) || (0 < -128)
      2  6981				  -	      ECHO	"Erroneous position value", 0
      3  6981				  -	      ERR
      4  6981					      ENDIF
      5  6981		       00		      .byte.b	0
      0  6982					      PVAL	-10, 0, 25, 75, 75, 75, 0, -10
      0  6982					      EVAL8	-10
      1  6982				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6982				  -	      ECHO	"Erroneous position value", -10
      3  6982				  -	      ERR
      4  6982					      ENDIF
      5  6982		       f6		      .byte.b	-10
      0  6983					      EVAL8	0
      1  6983				  -	      IF	(0 > 127) || (0 < -128)
      2  6983				  -	      ECHO	"Erroneous position value", 0
      3  6983				  -	      ERR
      4  6983					      ENDIF
      5  6983		       00		      .byte.b	0
      0  6984					      EVAL8	25
      1  6984				  -	      IF	(25 > 127) || (25 < -128)
      2  6984				  -	      ECHO	"Erroneous position value", 25
      3  6984				  -	      ERR
      4  6984					      ENDIF
      5  6984		       19		      .byte.b	25
      0  6985					      EVAL8	75
      1  6985				  -	      IF	(75 > 127) || (75 < -128)
      2  6985				  -	      ECHO	"Erroneous position value", 75
      3  6985				  -	      ERR
      4  6985					      ENDIF
      5  6985		       4b		      .byte.b	75
      0  6986					      EVAL8	75
      1  6986				  -	      IF	(75 > 127) || (75 < -128)
      2  6986				  -	      ECHO	"Erroneous position value", 75
      3  6986				  -	      ERR
      4  6986					      ENDIF
      5  6986		       4b		      .byte.b	75
      0  6987					      EVAL8	75
      1  6987				  -	      IF	(75 > 127) || (75 < -128)
      2  6987				  -	      ECHO	"Erroneous position value", 75
      3  6987				  -	      ERR
      4  6987					      ENDIF
      5  6987		       4b		      .byte.b	75
      0  6988					      EVAL8	0
      1  6988				  -	      IF	(0 > 127) || (0 < -128)
      2  6988				  -	      ECHO	"Erroneous position value", 0
      3  6988				  -	      ERR
      4  6988					      ENDIF
      5  6988		       00		      .byte.b	0
      0  6989					      EVAL8	-10
      1  6989				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6989				  -	      ECHO	"Erroneous position value", -10
      3  6989				  -	      ERR
      4  6989					      ENDIF
      5  6989		       f6		      .byte.b	-10
      0  698a					      EVAL8	0
      1  698a				  -	      IF	(0 > 127) || (0 < -128)
      2  698a				  -	      ECHO	"Erroneous position value", 0
      3  698a				  -	      ERR
      4  698a					      ENDIF
      5  698a		       00		      .byte.b	0
      0  698b					      EVAL8	0
      1  698b				  -	      IF	(0 > 127) || (0 < -128)
      2  698b				  -	      ECHO	"Erroneous position value", 0
      3  698b				  -	      ERR
      4  698b					      ENDIF
      5  698b		       00		      .byte.b	0
      0  698c					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      0  698c					      EVAL8	-10
      1  698c				  -	      IF	(-10 > 127) || (-10 < -128)
      2  698c				  -	      ECHO	"Erroneous position value", -10
      3  698c				  -	      ERR
      4  698c					      ENDIF
      5  698c		       f6		      .byte.b	-10
      0  698d					      EVAL8	0
      1  698d				  -	      IF	(0 > 127) || (0 < -128)
      2  698d				  -	      ECHO	"Erroneous position value", 0
      3  698d				  -	      ERR
      4  698d					      ENDIF
      5  698d		       00		      .byte.b	0
      0  698e					      EVAL8	0
      1  698e				  -	      IF	(0 > 127) || (0 < -128)
      2  698e				  -	      ECHO	"Erroneous position value", 0
      3  698e				  -	      ERR
      4  698e					      ENDIF
      5  698e		       00		      .byte.b	0
      0  698f					      EVAL8	0
      1  698f				  -	      IF	(0 > 127) || (0 < -128)
      2  698f				  -	      ECHO	"Erroneous position value", 0
      3  698f				  -	      ERR
      4  698f					      ENDIF
      5  698f		       00		      .byte.b	0
      0  6990					      EVAL8	0
      1  6990				  -	      IF	(0 > 127) || (0 < -128)
      2  6990				  -	      ECHO	"Erroneous position value", 0
      3  6990				  -	      ERR
      4  6990					      ENDIF
      5  6990		       00		      .byte.b	0
      0  6991					      EVAL8	0
      1  6991				  -	      IF	(0 > 127) || (0 < -128)
      2  6991				  -	      ECHO	"Erroneous position value", 0
      3  6991				  -	      ERR
      4  6991					      ENDIF
      5  6991		       00		      .byte.b	0
      0  6992					      EVAL8	0
      1  6992				  -	      IF	(0 > 127) || (0 < -128)
      2  6992				  -	      ECHO	"Erroneous position value", 0
      3  6992				  -	      ERR
      4  6992					      ENDIF
      5  6992		       00		      .byte.b	0
      0  6993					      EVAL8	-10
      1  6993				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6993				  -	      ECHO	"Erroneous position value", -10
      3  6993				  -	      ERR
      4  6993					      ENDIF
      5  6993		       f6		      .byte.b	-10
      0  6994					      EVAL8	0
      1  6994				  -	      IF	(0 > 127) || (0 < -128)
      2  6994				  -	      ECHO	"Erroneous position value", 0
      3  6994				  -	      ERR
      4  6994					      ENDIF
      5  6994		       00		      .byte.b	0
      0  6995					      EVAL8	0
      1  6995				  -	      IF	(0 > 127) || (0 < -128)
      2  6995				  -	      ECHO	"Erroneous position value", 0
      3  6995				  -	      ERR
      4  6995					      ENDIF
      5  6995		       00		      .byte.b	0
      0  6996					      PVAL	-20, -10, -10, -5, -5, -10, -10, -20
      0  6996					      EVAL8	-20
      1  6996				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6996				  -	      ECHO	"Erroneous position value", -20
      3  6996				  -	      ERR
      4  6996					      ENDIF
      5  6996		       ec		      .byte.b	-20
      0  6997					      EVAL8	-10
      1  6997				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6997				  -	      ECHO	"Erroneous position value", -10
      3  6997				  -	      ERR
      4  6997					      ENDIF
      5  6997		       f6		      .byte.b	-10
      0  6998					      EVAL8	-10
      1  6998				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6998				  -	      ECHO	"Erroneous position value", -10
      3  6998				  -	      ERR
      4  6998					      ENDIF
      5  6998		       f6		      .byte.b	-10
      0  6999					      EVAL8	-5
      1  6999				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6999				  -	      ECHO	"Erroneous position value", -5
      3  6999				  -	      ERR
      4  6999					      ENDIF
      5  6999		       fb		      .byte.b	-5
      0  699a					      EVAL8	-5
      1  699a				  -	      IF	(-5 > 127) || (-5 < -128)
      2  699a				  -	      ECHO	"Erroneous position value", -5
      3  699a				  -	      ERR
      4  699a					      ENDIF
      5  699a		       fb		      .byte.b	-5
      0  699b					      EVAL8	-10
      1  699b				  -	      IF	(-10 > 127) || (-10 < -128)
      2  699b				  -	      ECHO	"Erroneous position value", -10
      3  699b				  -	      ERR
      4  699b					      ENDIF
      5  699b		       f6		      .byte.b	-10
      0  699c					      EVAL8	-10
      1  699c				  -	      IF	(-10 > 127) || (-10 < -128)
      2  699c				  -	      ECHO	"Erroneous position value", -10
      3  699c				  -	      ERR
      4  699c					      ENDIF
      5  699c		       f6		      .byte.b	-10
      0  699d					      EVAL8	-20
      1  699d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  699d				  -	      ECHO	"Erroneous position value", -20
      3  699d				  -	      ERR
      4  699d					      ENDIF
      5  699d		       ec		      .byte.b	-20
      0  699e					      EVAL8	0
      1  699e				  -	      IF	(0 > 127) || (0 < -128)
      2  699e				  -	      ECHO	"Erroneous position value", 0
      3  699e				  -	      ERR
      4  699e					      ENDIF
      5  699e		       00		      .byte.b	0
      0  699f					      EVAL8	0
      1  699f				  -	      IF	(0 > 127) || (0 < -128)
      2  699f				  -	      ECHO	"Erroneous position value", 0
      3  699f				  -	      ERR
      4  699f					      ENDIF
      5  699f		       00		      .byte.b	0
    139  69a0
    140  69a0
    141  69a0							;---------------------------------------------------------------------------------------------------
    142  69a0
    143  69a0				   PositionalValue_KING_MIDGAME
    144  69a0
      0  69a0					      PVAL	0, 0, 40, -120, -60, -120, 70, 0
      0  69a0					      EVAL8	0
      1  69a0				  -	      IF	(0 > 127) || (0 < -128)
      2  69a0				  -	      ECHO	"Erroneous position value", 0
      3  69a0				  -	      ERR
      4  69a0					      ENDIF
      5  69a0		       00		      .byte.b	0
      0  69a1					      EVAL8	0
      1  69a1				  -	      IF	(0 > 127) || (0 < -128)
      2  69a1				  -	      ECHO	"Erroneous position value", 0
      3  69a1				  -	      ERR
      4  69a1					      ENDIF
      5  69a1		       00		      .byte.b	0
      0  69a2					      EVAL8	40
      1  69a2				  -	      IF	(40 > 127) || (40 < -128)
      2  69a2				  -	      ECHO	"Erroneous position value", 40
      3  69a2				  -	      ERR
      4  69a2					      ENDIF
      5  69a2		       28		      .byte.b	40
      0  69a3					      EVAL8	-120
      1  69a3				  -	      IF	(-120 > 127) || (-120 < -128)
      2  69a3				  -	      ECHO	"Erroneous position value", -120
      3  69a3				  -	      ERR
      4  69a3					      ENDIF
      5  69a3		       88		      .byte.b	-120
      0  69a4					      EVAL8	-60
      1  69a4				  -	      IF	(-60 > 127) || (-60 < -128)
      2  69a4				  -	      ECHO	"Erroneous position value", -60
      3  69a4				  -	      ERR
      4  69a4					      ENDIF
      5  69a4		       c4		      .byte.b	-60
      0  69a5					      EVAL8	-120
      1  69a5				  -	      IF	(-120 > 127) || (-120 < -128)
      2  69a5				  -	      ECHO	"Erroneous position value", -120
      3  69a5				  -	      ERR
      4  69a5					      ENDIF
      5  69a5		       88		      .byte.b	-120
      0  69a6					      EVAL8	70
      1  69a6				  -	      IF	(70 > 127) || (70 < -128)
      2  69a6				  -	      ECHO	"Erroneous position value", 70
      3  69a6				  -	      ERR
      4  69a6					      ENDIF
      5  69a6		       46		      .byte.b	70
      0  69a7					      EVAL8	0
      1  69a7				  -	      IF	(0 > 127) || (0 < -128)
      2  69a7				  -	      ECHO	"Erroneous position value", 0
      3  69a7				  -	      ERR
      4  69a7					      ENDIF
      5  69a7		       00		      .byte.b	0
      0  69a8					      EVAL8	0
      1  69a8				  -	      IF	(0 > 127) || (0 < -128)
      2  69a8				  -	      ECHO	"Erroneous position value", 0
      3  69a8				  -	      ERR
      4  69a8					      ENDIF
      5  69a8		       00		      .byte.b	0
      0  69a9					      EVAL8	0
      1  69a9				  -	      IF	(0 > 127) || (0 < -128)
      2  69a9				  -	      ECHO	"Erroneous position value", 0
      3  69a9				  -	      ERR
      4  69a9					      ENDIF
      5  69a9		       00		      .byte.b	0
      0  69aa					      PVAL	0, 0, -80, -80, -70, -70, 0, 0
      0  69aa					      EVAL8	0
      1  69aa				  -	      IF	(0 > 127) || (0 < -128)
      2  69aa				  -	      ECHO	"Erroneous position value", 0
      3  69aa				  -	      ERR
      4  69aa					      ENDIF
      5  69aa		       00		      .byte.b	0
      0  69ab					      EVAL8	0
      1  69ab				  -	      IF	(0 > 127) || (0 < -128)
      2  69ab				  -	      ECHO	"Erroneous position value", 0
      3  69ab				  -	      ERR
      4  69ab					      ENDIF
      5  69ab		       00		      .byte.b	0
      0  69ac					      EVAL8	-80
      1  69ac				  -	      IF	(-80 > 127) || (-80 < -128)
      2  69ac				  -	      ECHO	"Erroneous position value", -80
      3  69ac				  -	      ERR
      4  69ac					      ENDIF
      5  69ac		       b0		      .byte.b	-80
      0  69ad					      EVAL8	-80
      1  69ad				  -	      IF	(-80 > 127) || (-80 < -128)
      2  69ad				  -	      ECHO	"Erroneous position value", -80
      3  69ad				  -	      ERR
      4  69ad					      ENDIF
      5  69ad		       b0		      .byte.b	-80
      0  69ae					      EVAL8	-70
      1  69ae				  -	      IF	(-70 > 127) || (-70 < -128)
      2  69ae				  -	      ECHO	"Erroneous position value", -70
      3  69ae				  -	      ERR
      4  69ae					      ENDIF
      5  69ae		       ba		      .byte.b	-70
      0  69af					      EVAL8	-70
      1  69af				  -	      IF	(-70 > 127) || (-70 < -128)
      2  69af				  -	      ECHO	"Erroneous position value", -70
      3  69af				  -	      ERR
      4  69af					      ENDIF
      5  69af		       ba		      .byte.b	-70
      0  69b0					      EVAL8	0
      1  69b0				  -	      IF	(0 > 127) || (0 < -128)
      2  69b0				  -	      ECHO	"Erroneous position value", 0
      3  69b0				  -	      ERR
      4  69b0					      ENDIF
      5  69b0		       00		      .byte.b	0
      0  69b1					      EVAL8	0
      1  69b1				  -	      IF	(0 > 127) || (0 < -128)
      2  69b1				  -	      ECHO	"Erroneous position value", 0
      3  69b1				  -	      ERR
      4  69b1					      ENDIF
      5  69b1		       00		      .byte.b	0
      0  69b2					      EVAL8	0
      1  69b2				  -	      IF	(0 > 127) || (0 < -128)
      2  69b2				  -	      ECHO	"Erroneous position value", 0
      3  69b2				  -	      ERR
      4  69b2					      ENDIF
      5  69b2		       00		      .byte.b	0
      0  69b3					      EVAL8	0
      1  69b3				  -	      IF	(0 > 127) || (0 < -128)
      2  69b3				  -	      ECHO	"Erroneous position value", 0
      3  69b3				  -	      ERR
      4  69b3					      ENDIF
      5  69b3		       00		      .byte.b	0
      0  69b4					      PVAL	-10, -20, -20, -50, -60, -60, -20, -10
      0  69b4					      EVAL8	-10
      1  69b4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  69b4				  -	      ECHO	"Erroneous position value", -10
      3  69b4				  -	      ERR
      4  69b4					      ENDIF
      5  69b4		       f6		      .byte.b	-10
      0  69b5					      EVAL8	-20
      1  69b5				  -	      IF	(-20 > 127) || (-20 < -128)
      2  69b5				  -	      ECHO	"Erroneous position value", -20
      3  69b5				  -	      ERR
      4  69b5					      ENDIF
      5  69b5		       ec		      .byte.b	-20
      0  69b6					      EVAL8	-20
      1  69b6				  -	      IF	(-20 > 127) || (-20 < -128)
      2  69b6				  -	      ECHO	"Erroneous position value", -20
      3  69b6				  -	      ERR
      4  69b6					      ENDIF
      5  69b6		       ec		      .byte.b	-20
      0  69b7					      EVAL8	-50
      1  69b7				  -	      IF	(-50 > 127) || (-50 < -128)
      2  69b7				  -	      ECHO	"Erroneous position value", -50
      3  69b7				  -	      ERR
      4  69b7					      ENDIF
      5  69b7		       ce		      .byte.b	-50
      0  69b8					      EVAL8	-60
      1  69b8				  -	      IF	(-60 > 127) || (-60 < -128)
      2  69b8				  -	      ECHO	"Erroneous position value", -60
      3  69b8				  -	      ERR
      4  69b8					      ENDIF
      5  69b8		       c4		      .byte.b	-60
      0  69b9					      EVAL8	-60
      1  69b9				  -	      IF	(-60 > 127) || (-60 < -128)
      2  69b9				  -	      ECHO	"Erroneous position value", -60
      3  69b9				  -	      ERR
      4  69b9					      ENDIF
      5  69b9		       c4		      .byte.b	-60
      0  69ba					      EVAL8	-20
      1  69ba				  -	      IF	(-20 > 127) || (-20 < -128)
      2  69ba				  -	      ECHO	"Erroneous position value", -20
      3  69ba				  -	      ERR
      4  69ba					      ENDIF
      5  69ba		       ec		      .byte.b	-20
      0  69bb					      EVAL8	-10
      1  69bb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  69bb				  -	      ECHO	"Erroneous position value", -10
      3  69bb				  -	      ERR
      4  69bb					      ENDIF
      5  69bb		       f6		      .byte.b	-10
      0  69bc					      EVAL8	0
      1  69bc				  -	      IF	(0 > 127) || (0 < -128)
      2  69bc				  -	      ECHO	"Erroneous position value", 0
      3  69bc				  -	      ERR
      4  69bc					      ENDIF
      5  69bc		       00		      .byte.b	0
      0  69bd					      EVAL8	0
      1  69bd				  -	      IF	(0 > 127) || (0 < -128)
      2  69bd				  -	      ECHO	"Erroneous position value", 0
      3  69bd				  -	      ERR
      4  69bd					      ENDIF
      5  69bd		       00		      .byte.b	0
      0  69be					      PVAL	-20, -30, -30, -40, -40, -30, -30, -20
      0  69be					      EVAL8	-20
      1  69be				  -	      IF	(-20 > 127) || (-20 < -128)
      2  69be				  -	      ECHO	"Erroneous position value", -20
      3  69be				  -	      ERR
      4  69be					      ENDIF
      5  69be		       ec		      .byte.b	-20
      0  69bf					      EVAL8	-30
      1  69bf				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69bf				  -	      ECHO	"Erroneous position value", -30
      3  69bf				  -	      ERR
      4  69bf					      ENDIF
      5  69bf		       e2		      .byte.b	-30
      0  69c0					      EVAL8	-30
      1  69c0				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69c0				  -	      ECHO	"Erroneous position value", -30
      3  69c0				  -	      ERR
      4  69c0					      ENDIF
      5  69c0		       e2		      .byte.b	-30
      0  69c1					      EVAL8	-40
      1  69c1				  -	      IF	(-40 > 127) || (-40 < -128)
      2  69c1				  -	      ECHO	"Erroneous position value", -40
      3  69c1				  -	      ERR
      4  69c1					      ENDIF
      5  69c1		       d8		      .byte.b	-40
      0  69c2					      EVAL8	-40
      1  69c2				  -	      IF	(-40 > 127) || (-40 < -128)
      2  69c2				  -	      ECHO	"Erroneous position value", -40
      3  69c2				  -	      ERR
      4  69c2					      ENDIF
      5  69c2		       d8		      .byte.b	-40
      0  69c3					      EVAL8	-30
      1  69c3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69c3				  -	      ECHO	"Erroneous position value", -30
      3  69c3				  -	      ERR
      4  69c3					      ENDIF
      5  69c3		       e2		      .byte.b	-30
      0  69c4					      EVAL8	-30
      1  69c4				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69c4				  -	      ECHO	"Erroneous position value", -30
      3  69c4				  -	      ERR
      4  69c4					      ENDIF
      5  69c4		       e2		      .byte.b	-30
      0  69c5					      EVAL8	-20
      1  69c5				  -	      IF	(-20 > 127) || (-20 < -128)
      2  69c5				  -	      ECHO	"Erroneous position value", -20
      3  69c5				  -	      ERR
      4  69c5					      ENDIF
      5  69c5		       ec		      .byte.b	-20
      0  69c6					      EVAL8	0
      1  69c6				  -	      IF	(0 > 127) || (0 < -128)
      2  69c6				  -	      ECHO	"Erroneous position value", 0
      3  69c6				  -	      ERR
      4  69c6					      ENDIF
      5  69c6		       00		      .byte.b	0
      0  69c7					      EVAL8	0
      1  69c7				  -	      IF	(0 > 127) || (0 < -128)
      2  69c7				  -	      ECHO	"Erroneous position value", 0
      3  69c7				  -	      ERR
      4  69c7					      ENDIF
      5  69c7		       00		      .byte.b	0
      0  69c8					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  69c8					      EVAL8	-30
      1  69c8				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69c8				  -	      ECHO	"Erroneous position value", -30
      3  69c8				  -	      ERR
      4  69c8					      ENDIF
      5  69c8		       e2		      .byte.b	-30
      0  69c9					      EVAL8	-40
      1  69c9				  -	      IF	(-40 > 127) || (-40 < -128)
      2  69c9				  -	      ECHO	"Erroneous position value", -40
      3  69c9				  -	      ERR
      4  69c9					      ENDIF
      5  69c9		       d8		      .byte.b	-40
      0  69ca					      EVAL8	-40
      1  69ca				  -	      IF	(-40 > 127) || (-40 < -128)
      2  69ca				  -	      ECHO	"Erroneous position value", -40
      3  69ca				  -	      ERR
      4  69ca					      ENDIF
      5  69ca		       d8		      .byte.b	-40
      0  69cb					      EVAL8	-50
      1  69cb				  -	      IF	(-50 > 127) || (-50 < -128)
      2  69cb				  -	      ECHO	"Erroneous position value", -50
      3  69cb				  -	      ERR
      4  69cb					      ENDIF
      5  69cb		       ce		      .byte.b	-50
      0  69cc					      EVAL8	-50
      1  69cc				  -	      IF	(-50 > 127) || (-50 < -128)
      2  69cc				  -	      ECHO	"Erroneous position value", -50
      3  69cc				  -	      ERR
      4  69cc					      ENDIF
      5  69cc		       ce		      .byte.b	-50
      0  69cd					      EVAL8	-40
      1  69cd				  -	      IF	(-40 > 127) || (-40 < -128)
      2  69cd				  -	      ECHO	"Erroneous position value", -40
      3  69cd				  -	      ERR
      4  69cd					      ENDIF
      5  69cd		       d8		      .byte.b	-40
      0  69ce					      EVAL8	-40
      1  69ce				  -	      IF	(-40 > 127) || (-40 < -128)
      2  69ce				  -	      ECHO	"Erroneous position value", -40
      3  69ce				  -	      ERR
      4  69ce					      ENDIF
      5  69ce		       d8		      .byte.b	-40
      0  69cf					      EVAL8	-30
      1  69cf				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69cf				  -	      ECHO	"Erroneous position value", -30
      3  69cf				  -	      ERR
      4  69cf					      ENDIF
      5  69cf		       e2		      .byte.b	-30
      0  69d0					      EVAL8	0
      1  69d0				  -	      IF	(0 > 127) || (0 < -128)
      2  69d0				  -	      ECHO	"Erroneous position value", 0
      3  69d0				  -	      ERR
      4  69d0					      ENDIF
      5  69d0		       00		      .byte.b	0
      0  69d1					      EVAL8	0
      1  69d1				  -	      IF	(0 > 127) || (0 < -128)
      2  69d1				  -	      ECHO	"Erroneous position value", 0
      3  69d1				  -	      ERR
      4  69d1					      ENDIF
      5  69d1		       00		      .byte.b	0
      0  69d2					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  69d2					      EVAL8	-30
      1  69d2				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69d2				  -	      ECHO	"Erroneous position value", -30
      3  69d2				  -	      ERR
      4  69d2					      ENDIF
      5  69d2		       e2		      .byte.b	-30
      0  69d3					      EVAL8	-40
      1  69d3				  -	      IF	(-40 > 127) || (-40 < -128)
      2  69d3				  -	      ECHO	"Erroneous position value", -40
      3  69d3				  -	      ERR
      4  69d3					      ENDIF
      5  69d3		       d8		      .byte.b	-40
      0  69d4					      EVAL8	-40
      1  69d4				  -	      IF	(-40 > 127) || (-40 < -128)
      2  69d4				  -	      ECHO	"Erroneous position value", -40
      3  69d4				  -	      ERR
      4  69d4					      ENDIF
      5  69d4		       d8		      .byte.b	-40
      0  69d5					      EVAL8	-50
      1  69d5				  -	      IF	(-50 > 127) || (-50 < -128)
      2  69d5				  -	      ECHO	"Erroneous position value", -50
      3  69d5				  -	      ERR
      4  69d5					      ENDIF
      5  69d5		       ce		      .byte.b	-50
      0  69d6					      EVAL8	-50
      1  69d6				  -	      IF	(-50 > 127) || (-50 < -128)
      2  69d6				  -	      ECHO	"Erroneous position value", -50
      3  69d6				  -	      ERR
      4  69d6					      ENDIF
      5  69d6		       ce		      .byte.b	-50
      0  69d7					      EVAL8	-40
      1  69d7				  -	      IF	(-40 > 127) || (-40 < -128)
      2  69d7				  -	      ECHO	"Erroneous position value", -40
      3  69d7				  -	      ERR
      4  69d7					      ENDIF
      5  69d7		       d8		      .byte.b	-40
      0  69d8					      EVAL8	-40
      1  69d8				  -	      IF	(-40 > 127) || (-40 < -128)
      2  69d8				  -	      ECHO	"Erroneous position value", -40
      3  69d8				  -	      ERR
      4  69d8					      ENDIF
      5  69d8		       d8		      .byte.b	-40
      0  69d9					      EVAL8	-30
      1  69d9				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69d9				  -	      ECHO	"Erroneous position value", -30
      3  69d9				  -	      ERR
      4  69d9					      ENDIF
      5  69d9		       e2		      .byte.b	-30
      0  69da					      EVAL8	0
      1  69da				  -	      IF	(0 > 127) || (0 < -128)
      2  69da				  -	      ECHO	"Erroneous position value", 0
      3  69da				  -	      ERR
      4  69da					      ENDIF
      5  69da		       00		      .byte.b	0
      0  69db					      EVAL8	0
      1  69db				  -	      IF	(0 > 127) || (0 < -128)
      2  69db				  -	      ECHO	"Erroneous position value", 0
      3  69db				  -	      ERR
      4  69db					      ENDIF
      5  69db		       00		      .byte.b	0
      0  69dc					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  69dc					      EVAL8	-30
      1  69dc				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69dc				  -	      ECHO	"Erroneous position value", -30
      3  69dc				  -	      ERR
      4  69dc					      ENDIF
      5  69dc		       e2		      .byte.b	-30
      0  69dd					      EVAL8	-40
      1  69dd				  -	      IF	(-40 > 127) || (-40 < -128)
      2  69dd				  -	      ECHO	"Erroneous position value", -40
      3  69dd				  -	      ERR
      4  69dd					      ENDIF
      5  69dd		       d8		      .byte.b	-40
      0  69de					      EVAL8	-40
      1  69de				  -	      IF	(-40 > 127) || (-40 < -128)
      2  69de				  -	      ECHO	"Erroneous position value", -40
      3  69de				  -	      ERR
      4  69de					      ENDIF
      5  69de		       d8		      .byte.b	-40
      0  69df					      EVAL8	-50
      1  69df				  -	      IF	(-50 > 127) || (-50 < -128)
      2  69df				  -	      ECHO	"Erroneous position value", -50
      3  69df				  -	      ERR
      4  69df					      ENDIF
      5  69df		       ce		      .byte.b	-50
      0  69e0					      EVAL8	-50
      1  69e0				  -	      IF	(-50 > 127) || (-50 < -128)
      2  69e0				  -	      ECHO	"Erroneous position value", -50
      3  69e0				  -	      ERR
      4  69e0					      ENDIF
      5  69e0		       ce		      .byte.b	-50
      0  69e1					      EVAL8	-40
      1  69e1				  -	      IF	(-40 > 127) || (-40 < -128)
      2  69e1				  -	      ECHO	"Erroneous position value", -40
      3  69e1				  -	      ERR
      4  69e1					      ENDIF
      5  69e1		       d8		      .byte.b	-40
      0  69e2					      EVAL8	-40
      1  69e2				  -	      IF	(-40 > 127) || (-40 < -128)
      2  69e2				  -	      ECHO	"Erroneous position value", -40
      3  69e2				  -	      ERR
      4  69e2					      ENDIF
      5  69e2		       d8		      .byte.b	-40
      0  69e3					      EVAL8	-30
      1  69e3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69e3				  -	      ECHO	"Erroneous position value", -30
      3  69e3				  -	      ERR
      4  69e3					      ENDIF
      5  69e3		       e2		      .byte.b	-30
      0  69e4					      EVAL8	0
      1  69e4				  -	      IF	(0 > 127) || (0 < -128)
      2  69e4				  -	      ECHO	"Erroneous position value", 0
      3  69e4				  -	      ERR
      4  69e4					      ENDIF
      5  69e4		       00		      .byte.b	0
      0  69e5					      EVAL8	0
      1  69e5				  -	      IF	(0 > 127) || (0 < -128)
      2  69e5				  -	      ECHO	"Erroneous position value", 0
      3  69e5				  -	      ERR
      4  69e5					      ENDIF
      5  69e5		       00		      .byte.b	0
      0  69e6					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  69e6					      EVAL8	-30
      1  69e6				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69e6				  -	      ECHO	"Erroneous position value", -30
      3  69e6				  -	      ERR
      4  69e6					      ENDIF
      5  69e6		       e2		      .byte.b	-30
      0  69e7					      EVAL8	-40
      1  69e7				  -	      IF	(-40 > 127) || (-40 < -128)
      2  69e7				  -	      ECHO	"Erroneous position value", -40
      3  69e7				  -	      ERR
      4  69e7					      ENDIF
      5  69e7		       d8		      .byte.b	-40
      0  69e8					      EVAL8	-40
      1  69e8				  -	      IF	(-40 > 127) || (-40 < -128)
      2  69e8				  -	      ECHO	"Erroneous position value", -40
      3  69e8				  -	      ERR
      4  69e8					      ENDIF
      5  69e8		       d8		      .byte.b	-40
      0  69e9					      EVAL8	-50
      1  69e9				  -	      IF	(-50 > 127) || (-50 < -128)
      2  69e9				  -	      ECHO	"Erroneous position value", -50
      3  69e9				  -	      ERR
      4  69e9					      ENDIF
      5  69e9		       ce		      .byte.b	-50
      0  69ea					      EVAL8	-50
      1  69ea				  -	      IF	(-50 > 127) || (-50 < -128)
      2  69ea				  -	      ECHO	"Erroneous position value", -50
      3  69ea				  -	      ERR
      4  69ea					      ENDIF
      5  69ea		       ce		      .byte.b	-50
      0  69eb					      EVAL8	-40
      1  69eb				  -	      IF	(-40 > 127) || (-40 < -128)
      2  69eb				  -	      ECHO	"Erroneous position value", -40
      3  69eb				  -	      ERR
      4  69eb					      ENDIF
      5  69eb		       d8		      .byte.b	-40
      0  69ec					      EVAL8	-40
      1  69ec				  -	      IF	(-40 > 127) || (-40 < -128)
      2  69ec				  -	      ECHO	"Erroneous position value", -40
      3  69ec				  -	      ERR
      4  69ec					      ENDIF
      5  69ec		       d8		      .byte.b	-40
      0  69ed					      EVAL8	-30
      1  69ed				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69ed				  -	      ECHO	"Erroneous position value", -30
      3  69ed				  -	      ERR
      4  69ed					      ENDIF
      5  69ed		       e2		      .byte.b	-30
      0  69ee					      EVAL8	0
      1  69ee				  -	      IF	(0 > 127) || (0 < -128)
      2  69ee				  -	      ECHO	"Erroneous position value", 0
      3  69ee				  -	      ERR
      4  69ee					      ENDIF
      5  69ee		       00		      .byte.b	0
      0  69ef					      EVAL8	0
      1  69ef				  -	      IF	(0 > 127) || (0 < -128)
      2  69ef				  -	      ECHO	"Erroneous position value", 0
      3  69ef				  -	      ERR
      4  69ef					      ENDIF
      5  69ef		       00		      .byte.b	0
    153  69f0
    154  69f0
    155  69f0							;---------------------------------------------------------------------------------------------------
    156  69f0
    157  69f0				   PositionalValue_KING_ENDGAME
    158  69f0
      0  69f0					      PVAL	-50, -30, -30, -30, -30, -30, -30, -50
      0  69f0					      EVAL8	-50
      1  69f0				  -	      IF	(-50 > 127) || (-50 < -128)
      2  69f0				  -	      ECHO	"Erroneous position value", -50
      3  69f0				  -	      ERR
      4  69f0					      ENDIF
      5  69f0		       ce		      .byte.b	-50
      0  69f1					      EVAL8	-30
      1  69f1				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69f1				  -	      ECHO	"Erroneous position value", -30
      3  69f1				  -	      ERR
      4  69f1					      ENDIF
      5  69f1		       e2		      .byte.b	-30
      0  69f2					      EVAL8	-30
      1  69f2				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69f2				  -	      ECHO	"Erroneous position value", -30
      3  69f2				  -	      ERR
      4  69f2					      ENDIF
      5  69f2		       e2		      .byte.b	-30
      0  69f3					      EVAL8	-30
      1  69f3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69f3				  -	      ECHO	"Erroneous position value", -30
      3  69f3				  -	      ERR
      4  69f3					      ENDIF
      5  69f3		       e2		      .byte.b	-30
      0  69f4					      EVAL8	-30
      1  69f4				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69f4				  -	      ECHO	"Erroneous position value", -30
      3  69f4				  -	      ERR
      4  69f4					      ENDIF
      5  69f4		       e2		      .byte.b	-30
      0  69f5					      EVAL8	-30
      1  69f5				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69f5				  -	      ECHO	"Erroneous position value", -30
      3  69f5				  -	      ERR
      4  69f5					      ENDIF
      5  69f5		       e2		      .byte.b	-30
      0  69f6					      EVAL8	-30
      1  69f6				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69f6				  -	      ECHO	"Erroneous position value", -30
      3  69f6				  -	      ERR
      4  69f6					      ENDIF
      5  69f6		       e2		      .byte.b	-30
      0  69f7					      EVAL8	-50
      1  69f7				  -	      IF	(-50 > 127) || (-50 < -128)
      2  69f7				  -	      ECHO	"Erroneous position value", -50
      3  69f7				  -	      ERR
      4  69f7					      ENDIF
      5  69f7		       ce		      .byte.b	-50
      0  69f8					      EVAL8	0
      1  69f8				  -	      IF	(0 > 127) || (0 < -128)
      2  69f8				  -	      ECHO	"Erroneous position value", 0
      3  69f8				  -	      ERR
      4  69f8					      ENDIF
      5  69f8		       00		      .byte.b	0
      0  69f9					      EVAL8	0
      1  69f9				  -	      IF	(0 > 127) || (0 < -128)
      2  69f9				  -	      ECHO	"Erroneous position value", 0
      3  69f9				  -	      ERR
      4  69f9					      ENDIF
      5  69f9		       00		      .byte.b	0
      0  69fa					      PVAL	-30, -30, 0, 0, 0, 0, -30, -30
      0  69fa					      EVAL8	-30
      1  69fa				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69fa				  -	      ECHO	"Erroneous position value", -30
      3  69fa				  -	      ERR
      4  69fa					      ENDIF
      5  69fa		       e2		      .byte.b	-30
      0  69fb					      EVAL8	-30
      1  69fb				  -	      IF	(-30 > 127) || (-30 < -128)
      2  69fb				  -	      ECHO	"Erroneous position value", -30
      3  69fb				  -	      ERR
      4  69fb					      ENDIF
      5  69fb		       e2		      .byte.b	-30
      0  69fc					      EVAL8	0
      1  69fc				  -	      IF	(0 > 127) || (0 < -128)
      2  69fc				  -	      ECHO	"Erroneous position value", 0
      3  69fc				  -	      ERR
      4  69fc					      ENDIF
      5  69fc		       00		      .byte.b	0
      0  69fd					      EVAL8	0
      1  69fd				  -	      IF	(0 > 127) || (0 < -128)
      2  69fd				  -	      ECHO	"Erroneous position value", 0
      3  69fd				  -	      ERR
      4  69fd					      ENDIF
      5  69fd		       00		      .byte.b	0
      0  69fe					      EVAL8	0
      1  69fe				  -	      IF	(0 > 127) || (0 < -128)
      2  69fe				  -	      ECHO	"Erroneous position value", 0
      3  69fe				  -	      ERR
      4  69fe					      ENDIF
      5  69fe		       00		      .byte.b	0
      0  69ff					      EVAL8	0
      1  69ff				  -	      IF	(0 > 127) || (0 < -128)
      2  69ff				  -	      ECHO	"Erroneous position value", 0
      3  69ff				  -	      ERR
      4  69ff					      ENDIF
      5  69ff		       00		      .byte.b	0
      0  6a00					      EVAL8	-30
      1  6a00				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6a00				  -	      ECHO	"Erroneous position value", -30
      3  6a00				  -	      ERR
      4  6a00					      ENDIF
      5  6a00		       e2		      .byte.b	-30
      0  6a01					      EVAL8	-30
      1  6a01				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6a01				  -	      ECHO	"Erroneous position value", -30
      3  6a01				  -	      ERR
      4  6a01					      ENDIF
      5  6a01		       e2		      .byte.b	-30
      0  6a02					      EVAL8	0
      1  6a02				  -	      IF	(0 > 127) || (0 < -128)
      2  6a02				  -	      ECHO	"Erroneous position value", 0
      3  6a02				  -	      ERR
      4  6a02					      ENDIF
      5  6a02		       00		      .byte.b	0
      0  6a03					      EVAL8	0
      1  6a03				  -	      IF	(0 > 127) || (0 < -128)
      2  6a03				  -	      ECHO	"Erroneous position value", 0
      3  6a03				  -	      ERR
      4  6a03					      ENDIF
      5  6a03		       00		      .byte.b	0
      0  6a04					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      0  6a04					      EVAL8	-30
      1  6a04				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6a04				  -	      ECHO	"Erroneous position value", -30
      3  6a04				  -	      ERR
      4  6a04					      ENDIF
      5  6a04		       e2		      .byte.b	-30
      0  6a05					      EVAL8	-10
      1  6a05				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6a05				  -	      ECHO	"Erroneous position value", -10
      3  6a05				  -	      ERR
      4  6a05					      ENDIF
      5  6a05		       f6		      .byte.b	-10
      0  6a06					      EVAL8	20
      1  6a06				  -	      IF	(20 > 127) || (20 < -128)
      2  6a06				  -	      ECHO	"Erroneous position value", 20
      3  6a06				  -	      ERR
      4  6a06					      ENDIF
      5  6a06		       14		      .byte.b	20
      0  6a07					      EVAL8	30
      1  6a07				  -	      IF	(30 > 127) || (30 < -128)
      2  6a07				  -	      ECHO	"Erroneous position value", 30
      3  6a07				  -	      ERR
      4  6a07					      ENDIF
      5  6a07		       1e		      .byte.b	30
      0  6a08					      EVAL8	30
      1  6a08				  -	      IF	(30 > 127) || (30 < -128)
      2  6a08				  -	      ECHO	"Erroneous position value", 30
      3  6a08				  -	      ERR
      4  6a08					      ENDIF
      5  6a08		       1e		      .byte.b	30
      0  6a09					      EVAL8	20
      1  6a09				  -	      IF	(20 > 127) || (20 < -128)
      2  6a09				  -	      ECHO	"Erroneous position value", 20
      3  6a09				  -	      ERR
      4  6a09					      ENDIF
      5  6a09		       14		      .byte.b	20
      0  6a0a					      EVAL8	-10
      1  6a0a				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6a0a				  -	      ECHO	"Erroneous position value", -10
      3  6a0a				  -	      ERR
      4  6a0a					      ENDIF
      5  6a0a		       f6		      .byte.b	-10
      0  6a0b					      EVAL8	-30
      1  6a0b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6a0b				  -	      ECHO	"Erroneous position value", -30
      3  6a0b				  -	      ERR
      4  6a0b					      ENDIF
      5  6a0b		       e2		      .byte.b	-30
      0  6a0c					      EVAL8	0
      1  6a0c				  -	      IF	(0 > 127) || (0 < -128)
      2  6a0c				  -	      ECHO	"Erroneous position value", 0
      3  6a0c				  -	      ERR
      4  6a0c					      ENDIF
      5  6a0c		       00		      .byte.b	0
      0  6a0d					      EVAL8	0
      1  6a0d				  -	      IF	(0 > 127) || (0 < -128)
      2  6a0d				  -	      ECHO	"Erroneous position value", 0
      3  6a0d				  -	      ERR
      4  6a0d					      ENDIF
      5  6a0d		       00		      .byte.b	0
      0  6a0e					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      0  6a0e					      EVAL8	-30
      1  6a0e				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6a0e				  -	      ECHO	"Erroneous position value", -30
      3  6a0e				  -	      ERR
      4  6a0e					      ENDIF
      5  6a0e		       e2		      .byte.b	-30
      0  6a0f					      EVAL8	-10
      1  6a0f				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6a0f				  -	      ECHO	"Erroneous position value", -10
      3  6a0f				  -	      ERR
      4  6a0f					      ENDIF
      5  6a0f		       f6		      .byte.b	-10
      0  6a10					      EVAL8	30
      1  6a10				  -	      IF	(30 > 127) || (30 < -128)
      2  6a10				  -	      ECHO	"Erroneous position value", 30
      3  6a10				  -	      ERR
      4  6a10					      ENDIF
      5  6a10		       1e		      .byte.b	30
      0  6a11					      EVAL8	40
      1  6a11				  -	      IF	(40 > 127) || (40 < -128)
      2  6a11				  -	      ECHO	"Erroneous position value", 40
      3  6a11				  -	      ERR
      4  6a11					      ENDIF
      5  6a11		       28		      .byte.b	40
      0  6a12					      EVAL8	40
      1  6a12				  -	      IF	(40 > 127) || (40 < -128)
      2  6a12				  -	      ECHO	"Erroneous position value", 40
      3  6a12				  -	      ERR
      4  6a12					      ENDIF
      5  6a12		       28		      .byte.b	40
      0  6a13					      EVAL8	30
      1  6a13				  -	      IF	(30 > 127) || (30 < -128)
      2  6a13				  -	      ECHO	"Erroneous position value", 30
      3  6a13				  -	      ERR
      4  6a13					      ENDIF
      5  6a13		       1e		      .byte.b	30
      0  6a14					      EVAL8	-10
      1  6a14				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6a14				  -	      ECHO	"Erroneous position value", -10
      3  6a14				  -	      ERR
      4  6a14					      ENDIF
      5  6a14		       f6		      .byte.b	-10
      0  6a15					      EVAL8	-30
      1  6a15				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6a15				  -	      ECHO	"Erroneous position value", -30
      3  6a15				  -	      ERR
      4  6a15					      ENDIF
      5  6a15		       e2		      .byte.b	-30
      0  6a16					      EVAL8	0
      1  6a16				  -	      IF	(0 > 127) || (0 < -128)
      2  6a16				  -	      ECHO	"Erroneous position value", 0
      3  6a16				  -	      ERR
      4  6a16					      ENDIF
      5  6a16		       00		      .byte.b	0
      0  6a17					      EVAL8	0
      1  6a17				  -	      IF	(0 > 127) || (0 < -128)
      2  6a17				  -	      ECHO	"Erroneous position value", 0
      3  6a17				  -	      ERR
      4  6a17					      ENDIF
      5  6a17		       00		      .byte.b	0
      0  6a18					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      0  6a18					      EVAL8	-30
      1  6a18				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6a18				  -	      ECHO	"Erroneous position value", -30
      3  6a18				  -	      ERR
      4  6a18					      ENDIF
      5  6a18		       e2		      .byte.b	-30
      0  6a19					      EVAL8	-10
      1  6a19				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6a19				  -	      ECHO	"Erroneous position value", -10
      3  6a19				  -	      ERR
      4  6a19					      ENDIF
      5  6a19		       f6		      .byte.b	-10
      0  6a1a					      EVAL8	30
      1  6a1a				  -	      IF	(30 > 127) || (30 < -128)
      2  6a1a				  -	      ECHO	"Erroneous position value", 30
      3  6a1a				  -	      ERR
      4  6a1a					      ENDIF
      5  6a1a		       1e		      .byte.b	30
      0  6a1b					      EVAL8	40
      1  6a1b				  -	      IF	(40 > 127) || (40 < -128)
      2  6a1b				  -	      ECHO	"Erroneous position value", 40
      3  6a1b				  -	      ERR
      4  6a1b					      ENDIF
      5  6a1b		       28		      .byte.b	40
      0  6a1c					      EVAL8	40
      1  6a1c				  -	      IF	(40 > 127) || (40 < -128)
      2  6a1c				  -	      ECHO	"Erroneous position value", 40
      3  6a1c				  -	      ERR
      4  6a1c					      ENDIF
      5  6a1c		       28		      .byte.b	40
      0  6a1d					      EVAL8	30
      1  6a1d				  -	      IF	(30 > 127) || (30 < -128)
      2  6a1d				  -	      ECHO	"Erroneous position value", 30
      3  6a1d				  -	      ERR
      4  6a1d					      ENDIF
      5  6a1d		       1e		      .byte.b	30
      0  6a1e					      EVAL8	-10
      1  6a1e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6a1e				  -	      ECHO	"Erroneous position value", -10
      3  6a1e				  -	      ERR
      4  6a1e					      ENDIF
      5  6a1e		       f6		      .byte.b	-10
      0  6a1f					      EVAL8	-30
      1  6a1f				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6a1f				  -	      ECHO	"Erroneous position value", -30
      3  6a1f				  -	      ERR
      4  6a1f					      ENDIF
      5  6a1f		       e2		      .byte.b	-30
      0  6a20					      EVAL8	0
      1  6a20				  -	      IF	(0 > 127) || (0 < -128)
      2  6a20				  -	      ECHO	"Erroneous position value", 0
      3  6a20				  -	      ERR
      4  6a20					      ENDIF
      5  6a20		       00		      .byte.b	0
      0  6a21					      EVAL8	0
      1  6a21				  -	      IF	(0 > 127) || (0 < -128)
      2  6a21				  -	      ECHO	"Erroneous position value", 0
      3  6a21				  -	      ERR
      4  6a21					      ENDIF
      5  6a21		       00		      .byte.b	0
      0  6a22					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      0  6a22					      EVAL8	-30
      1  6a22				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6a22				  -	      ECHO	"Erroneous position value", -30
      3  6a22				  -	      ERR
      4  6a22					      ENDIF
      5  6a22		       e2		      .byte.b	-30
      0  6a23					      EVAL8	-10
      1  6a23				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6a23				  -	      ECHO	"Erroneous position value", -10
      3  6a23				  -	      ERR
      4  6a23					      ENDIF
      5  6a23		       f6		      .byte.b	-10
      0  6a24					      EVAL8	20
      1  6a24				  -	      IF	(20 > 127) || (20 < -128)
      2  6a24				  -	      ECHO	"Erroneous position value", 20
      3  6a24				  -	      ERR
      4  6a24					      ENDIF
      5  6a24		       14		      .byte.b	20
      0  6a25					      EVAL8	30
      1  6a25				  -	      IF	(30 > 127) || (30 < -128)
      2  6a25				  -	      ECHO	"Erroneous position value", 30
      3  6a25				  -	      ERR
      4  6a25					      ENDIF
      5  6a25		       1e		      .byte.b	30
      0  6a26					      EVAL8	30
      1  6a26				  -	      IF	(30 > 127) || (30 < -128)
      2  6a26				  -	      ECHO	"Erroneous position value", 30
      3  6a26				  -	      ERR
      4  6a26					      ENDIF
      5  6a26		       1e		      .byte.b	30
      0  6a27					      EVAL8	20
      1  6a27				  -	      IF	(20 > 127) || (20 < -128)
      2  6a27				  -	      ECHO	"Erroneous position value", 20
      3  6a27				  -	      ERR
      4  6a27					      ENDIF
      5  6a27		       14		      .byte.b	20
      0  6a28					      EVAL8	-10
      1  6a28				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6a28				  -	      ECHO	"Erroneous position value", -10
      3  6a28				  -	      ERR
      4  6a28					      ENDIF
      5  6a28		       f6		      .byte.b	-10
      0  6a29					      EVAL8	-30
      1  6a29				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6a29				  -	      ECHO	"Erroneous position value", -30
      3  6a29				  -	      ERR
      4  6a29					      ENDIF
      5  6a29		       e2		      .byte.b	-30
      0  6a2a					      EVAL8	0
      1  6a2a				  -	      IF	(0 > 127) || (0 < -128)
      2  6a2a				  -	      ECHO	"Erroneous position value", 0
      3  6a2a				  -	      ERR
      4  6a2a					      ENDIF
      5  6a2a		       00		      .byte.b	0
      0  6a2b					      EVAL8	0
      1  6a2b				  -	      IF	(0 > 127) || (0 < -128)
      2  6a2b				  -	      ECHO	"Erroneous position value", 0
      3  6a2b				  -	      ERR
      4  6a2b					      ENDIF
      5  6a2b		       00		      .byte.b	0
      0  6a2c					      PVAL	-30, -20, -10, 0, 0, -10, -20, -30
      0  6a2c					      EVAL8	-30
      1  6a2c				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6a2c				  -	      ECHO	"Erroneous position value", -30
      3  6a2c				  -	      ERR
      4  6a2c					      ENDIF
      5  6a2c		       e2		      .byte.b	-30
      0  6a2d					      EVAL8	-20
      1  6a2d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6a2d				  -	      ECHO	"Erroneous position value", -20
      3  6a2d				  -	      ERR
      4  6a2d					      ENDIF
      5  6a2d		       ec		      .byte.b	-20
      0  6a2e					      EVAL8	-10
      1  6a2e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6a2e				  -	      ECHO	"Erroneous position value", -10
      3  6a2e				  -	      ERR
      4  6a2e					      ENDIF
      5  6a2e		       f6		      .byte.b	-10
      0  6a2f					      EVAL8	0
      1  6a2f				  -	      IF	(0 > 127) || (0 < -128)
      2  6a2f				  -	      ECHO	"Erroneous position value", 0
      3  6a2f				  -	      ERR
      4  6a2f					      ENDIF
      5  6a2f		       00		      .byte.b	0
      0  6a30					      EVAL8	0
      1  6a30				  -	      IF	(0 > 127) || (0 < -128)
      2  6a30				  -	      ECHO	"Erroneous position value", 0
      3  6a30				  -	      ERR
      4  6a30					      ENDIF
      5  6a30		       00		      .byte.b	0
      0  6a31					      EVAL8	-10
      1  6a31				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6a31				  -	      ECHO	"Erroneous position value", -10
      3  6a31				  -	      ERR
      4  6a31					      ENDIF
      5  6a31		       f6		      .byte.b	-10
      0  6a32					      EVAL8	-20
      1  6a32				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6a32				  -	      ECHO	"Erroneous position value", -20
      3  6a32				  -	      ERR
      4  6a32					      ENDIF
      5  6a32		       ec		      .byte.b	-20
      0  6a33					      EVAL8	-30
      1  6a33				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6a33				  -	      ECHO	"Erroneous position value", -30
      3  6a33				  -	      ERR
      4  6a33					      ENDIF
      5  6a33		       e2		      .byte.b	-30
      0  6a34					      EVAL8	0
      1  6a34				  -	      IF	(0 > 127) || (0 < -128)
      2  6a34				  -	      ECHO	"Erroneous position value", 0
      3  6a34				  -	      ERR
      4  6a34					      ENDIF
      5  6a34		       00		      .byte.b	0
      0  6a35					      EVAL8	0
      1  6a35				  -	      IF	(0 > 127) || (0 < -128)
      2  6a35				  -	      ECHO	"Erroneous position value", 0
      3  6a35				  -	      ERR
      4  6a35					      ENDIF
      5  6a35		       00		      .byte.b	0
      0  6a36					      PVAL	-50, -40, -30, -20,- 20, -30, -40, -50
      0  6a36					      EVAL8	-50
      1  6a36				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6a36				  -	      ECHO	"Erroneous position value", -50
      3  6a36				  -	      ERR
      4  6a36					      ENDIF
      5  6a36		       ce		      .byte.b	-50
      0  6a37					      EVAL8	-40
      1  6a37				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6a37				  -	      ECHO	"Erroneous position value", -40
      3  6a37				  -	      ERR
      4  6a37					      ENDIF
      5  6a37		       d8		      .byte.b	-40
      0  6a38					      EVAL8	-30
      1  6a38				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6a38				  -	      ECHO	"Erroneous position value", -30
      3  6a38				  -	      ERR
      4  6a38					      ENDIF
      5  6a38		       e2		      .byte.b	-30
      0  6a39					      EVAL8	-20
      1  6a39				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6a39				  -	      ECHO	"Erroneous position value", -20
      3  6a39				  -	      ERR
      4  6a39					      ENDIF
      5  6a39		       ec		      .byte.b	-20
      0  6a3a					      EVAL8	- 20
      1  6a3a				  -	      IF	(- 20 > 127) || (- 20 < -128)
      2  6a3a				  -	      ECHO	"Erroneous position value", - 20
      3  6a3a				  -	      ERR
      4  6a3a					      ENDIF
      5  6a3a		       ec		      .byte.b	- 20
      0  6a3b					      EVAL8	-30
      1  6a3b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6a3b				  -	      ECHO	"Erroneous position value", -30
      3  6a3b				  -	      ERR
      4  6a3b					      ENDIF
      5  6a3b		       e2		      .byte.b	-30
      0  6a3c					      EVAL8	-40
      1  6a3c				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6a3c				  -	      ECHO	"Erroneous position value", -40
      3  6a3c				  -	      ERR
      4  6a3c					      ENDIF
      5  6a3c		       d8		      .byte.b	-40
      0  6a3d					      EVAL8	-50
      1  6a3d				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6a3d				  -	      ECHO	"Erroneous position value", -50
      3  6a3d				  -	      ERR
      4  6a3d					      ENDIF
      5  6a3d		       ce		      .byte.b	-50
      0  6a3e					      EVAL8	0
      1  6a3e				  -	      IF	(0 > 127) || (0 < -128)
      2  6a3e				  -	      ECHO	"Erroneous position value", 0
      3  6a3e				  -	      ERR
      4  6a3e					      ENDIF
      5  6a3e		       00		      .byte.b	0
      0  6a3f					      EVAL8	0
      1  6a3f				  -	      IF	(0 > 127) || (0 < -128)
      2  6a3f				  -	      ECHO	"Erroneous position value", 0
      3  6a3f				  -	      ERR
      4  6a3f					      ENDIF
      5  6a3f		       00		      .byte.b	0
    167  6a40
    168  6a40
    169  6a40							;---------------------------------------------------------------------------------------------------
    170  6a40
      0  6a40					      END_BANK
      1  6a40				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  6a40				  -	      CHECK_RAM_BANK_SIZE
      3  6a40					      ELSE
      0  6a40					      CHECK_BANK_SIZE
      1  6a40		       02 40	   .TEMP      =	* - _BANK_START
 ROM bank # 27 EVALUATE size = $240 free = 447
      2  6a40					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  6a40				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6a40				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  6a40				  -	      ERR
      6  6a40					      ENDIF
      5  6a40					      ENDIF
    172  6a40
    173  6a40							;---------------------------------------------------------------------------------------------------
    174  6a40							; EOF
------- FILE ./chess.asm
    201  6a40
------- FILE SHADOW_BOARD.asm LEVEL 2 PASS 4
      0  6a40					      include	"SHADOW_BOARD.asm"
      1  6a40							; Copyright (C)2020 Andrew Davie
      2  6a40
      3  6a40
      4  6a40							;---------------------------------------------------------------------------------------------------
      5  6a40
      0  6a40					      SLOT	3
      1  6a40
      2  6a40				  -	      IF	(3 < 0) || (3 > 3)
      3  6a40				  -	      ECHO	"Illegal bank address/segment location", 3
      4  6a40				  -	      ERR
      5  6a40					      ENDIF
      6  6a40
      7  6a40				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      8  6a40				   _BANK_SLOT SET	3 * 64
      9  6a40
      0  6a40					      RAMBANK	BOARD	; RAM bank for holding the following ROM shadow
      1  6a40
      2 U2000 ????				      SEG.U	RAM_BOARD
      3 U2000					      ORG	ORIGIN_RAM
      4 U2000					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2000				   _BANK_START SET	*
      6 U2000				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2000				   RAMBANK_BOARD SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2000				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2000				   _LAST_BANK SETSTR	BOARD
     10 U2000				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      8 U2000
      9 U2000		       fc 15	   ValidSquare =	ShadowValidSquare + $400
     10 U2000		       fc 79	   Board      =	ShadowBoard + $400
     11 U2000
      0 U2000					      END_BANK
      1 U2000					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U2000					      CHECK_RAM_BANK_SIZE
      1 U2000		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 17 BOARD size =  $0 free = $1ff
      2 U2000					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U2000				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U2000				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U2000				  -	      ERR
      6 U2000					      ENDIF
      3 U2000				  -	      ELSE
      4 U2000				  -	      CHECK_BANK_SIZE
      5 U2000					      ENDIF
     13 U2000
     14 U2000
     15 U2000							;---------------------------------------------------------------------------------------------------
     16 U2000
      0 U2000					      SLOT	2
      1 U2000
      2 U2000				  -	      IF	(2 < 0) || (2 > 3)
      3 U2000				  -	      ECHO	"Illegal bank address/segment location", 2
      4 U2000				  -	      ERR
      5 U2000					      ENDIF
      6 U2000
      7 U2000				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8 U2000				   _BANK_SLOT SET	2 * 64
      9 U2000
      0 U2000					      ROMBANK	SHADOW_BOARD	; copy the following bank to RAMBANK_BOARD
      1  6cdd ????				      SEG	ROM_SHADOW_BOARD
      2  6c00					      ORG	_ORIGIN
      3  6c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  6c00				   _BANK_START SET	*
      5  6c00				   SHADOW_BOARD_START SET	*
      6  6c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  6c00				   ROMBANK_SHADOW_BOARD SET	_BANK_SLOT + _CURRENT_BANK
      8  6c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  6c00				   _LAST_BANK SETSTR	SHADOW_BOARD
     10  6c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     19  6c00
     20  6c00							; Board is a 10 x 12 object which simplifies the generation of moves
     21  6c00							; The squares marked '░░░' are illegal. The ("X12") index of each square is the left
     22  6c00							; number + the bottom number. Bottom left legal square (AS VISIBLE ON SCREEN) is #22
     23  6c00
     24  6c00							;     X12 numbering
     25  6c00							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     26  6c00							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     27  6c00							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     28  6c00							; 90 ┃░░░┊░░░┊ 92┊ 93┊ 94┊ 95┊ 96┊ 97┊ 98┊ 99┃ 8 BLACK
     29  6c00							; 80 ┃░░░┊░░░┊ 82┊ 83┊ 84┊ 85┊ 86┊ 87┊ 88┊ 89┃ 7 BLACK
     30  6c00							; 70 ┃░░░┊░░░┊ 72┊ 73┊ 74┊ 75┊ 76┊ 77┊ 78┊ 79┃ 6
     31  6c00							; 60 ┃░░░┊░░░┊ 62┊ 63┊ 64┊ 65┊ 66┊ 67┊ 68┊ 69┃ 5
     32  6c00							; 50 ┃░░░┊░░░┊ 52┊ 53┊ 54┊ 55┊ 56┊ 57┊ 58┊ 59┃ 4
     33  6c00							; 40 ┃░░░┊░░░┊ 42┊ 43┊ 44┊ 45┊ 46┊ 47┊ 48┊ 49┃ 3
     34  6c00							; 30 ┃░░░┊░░░┊ 32┊ 33┊ 34┊ 35┊ 36┊ 37┊ 38┊ 39┃ 2 WHITE
     35  6c00							; 20 ┃░░░┊░░░┊ 22┊ 23┊ 24┊ 25┊ 26┊ 27┊ 28┊ 29┃ 1 WHITE
     36  6c00							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     37  6c00							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     38  6c00							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     39  6c00							;	0   1	2   3	4   5	6   7	8   9
     40  6c00							;		A   B	C   D	E   F	G   H
     41  6c00
     42  6c00							;     HEX X12
     43  6c00							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     44  6c00							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     45  6c00							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     46  6c00							; 90 ┃░░░┊░░░┊$5C┊$5D┊$5E┊$5F┊$60┊$61┊$62┊$63┃ 8
     47  6c00							; 80 ┃░░░┊░░░┊$52┊$53┊$54┊$55┊$56┊$57┊$58┊$59┃ 7
     48  6c00							; 70 ┃░░░┊░░░┊$48┊$49┊$4A┊$4B┊$4C┊$4D┊$4E┊$4F┃ 6
     49  6c00							; 60 ┃░░░┊░░░┊$3E┊$3F┊$40┊$41┊$42┊$43┊$44┊$45┃ 5
     50  6c00							; 50 ┃░░░┊░░░┊$34┊$35┊$36┊$37┊$38┊$39┊$3A┊$3B┃ 4
     51  6c00							; 40 ┃░░░┊░░░┊$2A┊$2B┊$2C┊$2D┊$2E┊$2F┊$30┊$31┃ 3
     52  6c00							; 30 ┃░░░┊░░░┊$20┊$21┊$22┊$23┊$24┊$25┊$26|$27┃ 2
     53  6c00							; 20 ┃░░░┊░░░┊$16┊$17┊$18┊$19┊$1A┊$1B┊$1C┊$1D┃ 1
     54  6c00							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     55  6c00							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     56  6c00							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     57  6c00							;	0   1	2   3	4   5	6   7	8   9
     58  6c00							;		A   B	C   D	E   F	G   H
     59  6c00
     60  6c00
     61  6c00							; We put a short buffer before 'ValidSquare' when it is at the start of the bank, so that
     62  6c00							; the move indexing (ie., "ValidSquare+{1},x" won't drop off the beginning of the bank
     63  6c00							; and sause "segfaults". 21 is the max offset (a knight move). These spare bytes can
     64  6c00							; be re-used for something else - we just need to guarantee there are 21 of them there
     65  6c00
      0  6c00					      ALLOCATE	Valid, 120 + 80 + 21
      1  6c00
      2  6c00				   .NAME      SETSTR	Valid
      0  6c00					      OPTIONAL_PAGEBREAK	.NAME, 120 + 80 + 21
      1  6c00
      2  6c00				  -	      IF	(>( * + 120 + 80 + 21 -1 )) > ( >* )
      3  6c00				  -.EARLY_LOCATION SET	*
      4  6c00				  -	      ALIGN	256
      5  6c00				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  6c00					      ENDIF
      0  6c00					      DEF	Valid
      1  6c00				   SLOT_Valid SET	_BANK_SLOT
      2  6c00				   BANK_Valid SET	SLOT_Valid + _CURRENT_BANK
      3  6c00				   Valid
      4  6c00				   TEMPORARY_VAR SET	Overlay
      5  6c00				   TEMPORARY_OFFSET SET	0
      6  6c00				   VAR_BOUNDARY_Valid SET	TEMPORARY_OFFSET
      7  6c00				   FUNCTION_NAME SET	Valid
      5  6c00
     67  6c00		       00 00 00 00*	      ds	21	; so indexing of "ValidSquare-21,x" won't fail
     68  6c15							; Note, we will never index INTO the above bytes - x will always be >= 21
     69  6c15							; We just need to make sure that the actual indexing will not have an address before
     70  6c15							; the index of outside the page.
     71  6c15
      0  6c15					      DEF	ShadowValidSquare
      1  6c15				   SLOT_ShadowValidSquare SET	_BANK_SLOT
      2  6c15				   BANK_ShadowValidSquare SET	SLOT_ShadowValidSquare + _CURRENT_BANK
      3  6c15				   ShadowValidSquare
      4  6c15				   TEMPORARY_VAR SET	Overlay
      5  6c15				   TEMPORARY_OFFSET SET	0
      6  6c15				   VAR_BOUNDARY_ShadowValidSquare SET	TEMPORARY_OFFSET
      7  6c15				   FUNCTION_NAME SET	ShadowValidSquare
     73  6c15
     74  6c15
     75  6c15							; Use this table to
     76  6c15							;   a) Determine if a square is valid (-1 = NO)
     77  6c15							;   b) Move pieces without addition.  e.g., "lda ValidSquareTable+10,x" will let you know
     78  6c15							;	if a white pawn on square "x" can move "up" the board.
     79  6c15
     80  6c15		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     81  6c1f		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     82  6c29		       ff ff 16 17*	      .byte.b	-1, -1, 22, 23, 24, 25, 26, 27, 28, 29
     83  6c33		       ff ff 20 21*	      .byte.b	-1, -1, 32, 33, 34, 35, 36, 37, 38, 39
     84  6c3d		       ff ff 2a 2b*	      .byte.b	-1, -1, 42, 43, 44, 45, 46, 47, 48, 49
     85  6c47		       ff ff 34 35*	      .byte.b	-1, -1, 52, 53, 54, 55, 56, 57, 58, 59
     86  6c51		       ff ff 3e 3f*	      .byte.b	-1, -1, 62, 63, 64, 65, 66, 67, 68, 69
     87  6c5b		       ff ff 48 49*	      .byte.b	-1, -1, 72, 73, 74, 75, 76, 77, 78, 79
     88  6c65		       ff ff 52 53*	      .byte.b	-1, -1, 82, 83, 84, 85, 86, 87, 88, 89
     89  6c6f		       ff ff 5c 5d*	      .byte.b	-1, -1, 92, 93, 94, 95, 96, 97, 98, 99	; CONTINUES...
     90  6c79
      0  6c79					      DEF	ShadowBoard
      1  6c79				   SLOT_ShadowBoard SET	_BANK_SLOT
      2  6c79				   BANK_ShadowBoard SET	SLOT_ShadowBoard + _CURRENT_BANK
      3  6c79				   ShadowBoard
      4  6c79				   TEMPORARY_VAR SET	Overlay
      5  6c79				   TEMPORARY_OFFSET SET	0
      6  6c79				   VAR_BOUNDARY_ShadowBoard SET	TEMPORARY_OFFSET
      7  6c79				   FUNCTION_NAME SET	ShadowBoard
     92  6c79
     93  6c79							; A 10X10... we should never write using invalid square
     94  6c79							; ON COPY TO RAM BANK, 'BOARD' SELF-INITIALISES TO THE FOLLOWING VALUES
     95  6c79							; FROM THEN ON IT'S WRITEABLE (REMEMBER TO +RAM_WRITE) FOR MODIFICATIONS
     96  6c79
     97  6c79		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     98  6c83		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     99  6c8d
    100  6c8d					      REPEAT	8
    101  6c8d		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  6c8d					      REPEND
    101  6c97		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  6c97					      REPEND
    101  6ca1		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  6ca1					      REPEND
    101  6cab		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  6cab					      REPEND
    101  6cb5		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  6cb5					      REPEND
    101  6cbf		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  6cbf					      REPEND
    101  6cc9		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  6cc9					      REPEND
    101  6cd3		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    102  6cdd					      REPEND
    103  6cdd
    104  6cdd							; DON'T OVERSTEP BOUNDS WHEN WRITING BOARD - MAXIMUM INDEX = 99
    105  6cdd
    106  6cdd
    107  6cdd							;---------------------------------------------------------------------------------------------------
    108  6cdd							; EOF
------- FILE ./chess.asm
    203  6cdd
    204  6cdd
    205  6cdd
------- FILE TitleScreen.asm LEVEL 2 PASS 4
      0  6cdd					      include	"TitleScreen.asm"
      0  6cdd					      SLOT	1
      1  6cdd
      2  6cdd				  -	      IF	(1 < 0) || (1 > 3)
      3  6cdd				  -	      ECHO	"Illegal bank address/segment location", 1
      4  6cdd				  -	      ERR
      5  6cdd					      ENDIF
      6  6cdd
      7  6cdd				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  6cdd				   _BANK_SLOT SET	1 * 64
      9  6cdd
      0  6cdd					      ROMBANK	TITLESCREEN
      1  72b0 ????				      SEG	ROM_TITLESCREEN
      2  7000					      ORG	_ORIGIN
      3  7000					      RORG	_BANK_ADDRESS_ORIGIN
      4  7000				   _BANK_START SET	*
      5  7000				   TITLESCREEN_START SET	*
      6  7000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  7000				   ROMBANK_TITLESCREEN SET	_BANK_SLOT + _CURRENT_BANK
      8  7000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  7000				   _LAST_BANK SETSTR	TITLESCREEN
     10  7000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
      3  7000
      4  7000
      5  7000							;---------------------------------------------------------------------------------------------------
      6  7000
      7  7000				   OverscanTime2
      8  7000		       27 1a		      .byte.b	39, 26
      9  7002		       10 20		      .byte.b	16, 32
     10  7004
     11  7004							;colvec
     12  7004							;    .word colr_ntsc2, colr_pal
     13  7004
     14  7004
     15  7004		       2a 32	   VBlankTime .byte.b	42,50
     16  7006
      0  7006					      DEF	TitleScreen
      1  7006				   SLOT_TitleScreen SET	_BANK_SLOT
      2  7006				   BANK_TitleScreen SET	SLOT_TitleScreen + _CURRENT_BANK
      3  7006				   TitleScreen
      4  7006				   TEMPORARY_VAR SET	Overlay
      5  7006				   TEMPORARY_OFFSET SET	0
      6  7006				   VAR_BOUNDARY_TitleScreen SET	TEMPORARY_OFFSET
      7  7006				   FUNCTION_NAME SET	TitleScreen
     18  7006					      SUBROUTINE
     19  7006
      0  7006					      VAR	__colour_table, 2
      1  7006
      2  7006		       00 a7	   __colour_table =	TEMPORARY_VAR
      3  7006				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      4  7006
      5  7006				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      6  7006				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      7  7006				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      8  7006					      ENDIF
      9  7006				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
     10  7006				  -	      LIST	ON
     11  7006				  -VNAME      SETSTR	__colour_table
     12  7006				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     13  7006				  -	      ERR
     14  7006				  -	      ECHO	"Temporary Variable overlow!"
     15  7006					      ENDIF
     16  7006					      LIST	ON
     21  7006
     22  7006							; Start of new frame
     23  7006
     24  7006							; Start of vertical blank processing
     25  7006
     26  7006				   TitleSequence
     27  7006
     28  7006
     29  7006		       a9 9d		      lda	#BANK_TitleData
     30  7008		       85 3f		      sta	SET_BANK
     31  700a
     32  700a
     33  700a		       a9 00		      lda	#%00000000
     34  700c		       85 4a		      sta	CTRLPF
     35  700e
     36  700e		       a9 c0		      lda	#$C0
     37  7010		       85 49		      sta	COLUBK
     38  7012
     39  7012		       a2 00		      ldx	#0	;Platform
     40  7014		       a9 00		      lda	#<colr_ntsc2	;colvec,x
     41  7016		       85 a7		      sta	__colour_table
     42  7018		       a9 f5		      lda	#>colr_ntsc2	;colvec+1,x
     43  701a		       85 a8		      sta	__colour_table+1
     44  701c
     45  701c							;		  sta rndHi
     46  701c							;		  sta rnd
     47  701c
     48  701c
     49  701c				  -	      IF	0
     50  701c				  -	      lda	#0
     51  701c				  -	      sta	digit
     52  701c				  -	      lda	#$10
     53  701c				  -	      sta	digit+1
     54  701c				  -	      lda	#$20
     55  701c				  -	      sta	digit+2
     56  701c					      ENDIF
     57  701c
     58  701c
     59  701c
     60  701c
     61  701c							;RESYNC
     62  701c
     63  701c				   RestartFrame0
     64  701c
     65  701c				  -	      IF	0
     66  701c				  -	      ldx	#2
     67  701c				  -rollcols   clc
     68  701c				  -	      lda	digit+2
     69  701c				  -	      adc	#$10
     70  701c				  -	      sta	digit+2
     71  701c				  -	      bcc	finxc
     72  701c				  -	      dex
     73  701c				  -	      bpl	rollcols
     74  701c				  -finxc
     75  701c					      ENDIF
     76  701c
      0  701c					      DEF	RestartFrame
      1  701c				   SLOT_RestartFrame SET	_BANK_SLOT
      2  701c				   BANK_RestartFrame SET	SLOT_RestartFrame + _CURRENT_BANK
      3  701c				   RestartFrame
      4  701c				   TEMPORARY_VAR SET	Overlay
      5  701c				   TEMPORARY_OFFSET SET	0
      6  701c				   VAR_BOUNDARY_RestartFrame SET	TEMPORARY_OFFSET
      7  701c				   FUNCTION_NAME SET	RestartFrame
     78  701c		       a9 00		      LDA	#0
     79  701e		       a9 0e		      lda	#%1110	; VSYNC ON
     80  7020		       85 42	   .loopVSync2 sta	WSYNC
     81  7022		       85 40		      sta	VSYNC
     82  7024		       4a		      lsr
     83  7025		       d0 f9		      bne	.loopVSync2	; branch until VYSNC has been reset
     84  7027
     85  7027							;------------------------------------------------------------------
     86  7027
     87  7027		       a2 00		      ldx	#0	;Platform
     88  7029		       bc 04 f4 	      ldy	VBlankTime,x
     89  702c		       8c 96 02 	      sty	TIM64T
     90  702f
     91  702f
     92  702f				  -	      IF	0
     93  702f				  -	      lda	SWCHB
     94  702f				  -	      rol
     95  702f				  -	      rol
     96  702f				  -	      rol
     97  702f				  -	      and	#%11
     98  702f				  -	      eor	#PAL
     99  702f				  -	      cmp	#0	;Platform
    100  702f				  -	      beq	platOK
    101  702f				  -			;sta Platform
    102  702f				  -	      jmp	TitleSequence
    103  702f				  -platOK
    104  702f					      ENDIF
    105  702f
    106  702f		       e6 81	   k2	      inc	rnd
    107  7031		       f0 fc		      beq	k2
    108  7033
    109  7033
    110  7033		       85 42	   VerticalBlank sta	WSYNC
    111  7035		       ad 84 02 	      lda	INTIM
    112  7038		       d0 f9		      bne	VerticalBlank
    113  703a		       85 41		      sta	VBLANK
    114  703c
    115  703c		       a9 00		      lda	#$0
    116  703e		       85 49		      sta	COLUBK
    117  7040
    118  7040							;------------------------------------------------------------------
    119  7040
    120  7040							; Do X scanlines of color-changing (our picture)
    121  7040
    122  7040		       a0 c9		      ldy	#67*3	; this counts our scanline number
    123  7042				   SokoLogo
    124  7042
    125  7042
    126  7042		       a9 24		      lda	#$24
    127  7044
    128  7044		       85 42		      sta	WSYNC
    129  7046		       85 48		      sta	COLUPF	; 3
    130  7048
    131  7048		       b9 00 f8 	      lda	COL_0,y	; 5
    132  704b		       85 4d		      sta	PF0	; 3   @11
    133  704d		       b9 cc f8 	      lda	COL_1,y	; 5
    134  7050		       85 4e		      sta	PF1	; 3   @19
    135  7052		       b9 98 f9 	      lda	COL_2,y	; 5
    136  7055		       85 4f		      sta	PF2	; 3   @27
    137  7057
    138  7057		       b9 00 f8 	      lda	COL_0,y	; 5
    139  705a		       0a		      asl
    140  705b		       0a		      asl
    141  705c		       0a		      asl
    142  705d		       0a		      asl
    143  705e		       85 4d		      sta	PF0	; 3   @35
    144  7060							;		  SLEEP 2      ; @37
    145  7060		       b9 64 fa 	      lda	COL_3,y	; 5
    146  7063		       85 4e		      sta	PF1	; 3   @45
    147  7065							;		  SLEEP 3      ; @45
    148  7065		       b9 30 fb 	      lda	COL_4,y	; 5
    149  7068		       85 4f		      sta	PF2	; 3
    150  706a
    151  706a		       88		      dey
    152  706b
    153  706b		       a9 68		      lda	#$68
    154  706d
    155  706d		       85 42		      sta	WSYNC
    156  706f		       85 48		      sta	COLUPF	; 3
    157  7071
    158  7071		       b9 00 f8 	      lda	COL_0,y	; 5
    159  7074		       85 4d		      sta	PF0	; 3   @11
    160  7076		       b9 cc f8 	      lda	COL_1,y	; 5
    161  7079		       85 4e		      sta	PF1	; 3   @19
    162  707b		       b9 98 f9 	      lda	COL_2,y	; 5
    163  707e		       85 4f		      sta	PF2	; 3   @27
    164  7080
    165  7080		       b9 00 f8 	      lda	COL_0,y	; 5
    166  7083		       0a		      asl
    167  7084		       0a		      asl
    168  7085		       0a		      asl
    169  7086		       0a		      asl
    170  7087		       85 4d		      sta	PF0	; 3   @35
    171  7089							;		  SLEEP 2      ; @37
    172  7089		       b9 64 fa 	      lda	COL_3,y	; 5
    173  708c		       85 4e		      sta	PF1	; 3   @45
    174  708e							;		  SLEEP 3      ; @45
    175  708e		       b9 30 fb 	      lda	COL_4,y	; 5
    176  7091		       85 4f		      sta	PF2	; 3
    177  7093
    178  7093		       88		      dey
    179  7094
    180  7094
    181  7094		       a9 d6		      lda	#$D6
    182  7096
    183  7096		       85 42		      sta	WSYNC
    184  7098		       85 48		      sta	COLUPF	; 3
    185  709a
    186  709a		       b9 00 f8 	      lda	COL_0,y	; 5
    187  709d		       85 4d		      sta	PF0	; 3   @11
    188  709f		       b9 cc f8 	      lda	COL_1,y	; 5
    189  70a2		       85 4e		      sta	PF1	; 3   @19
    190  70a4		       b9 98 f9 	      lda	COL_2,y	; 5
    191  70a7		       85 4f		      sta	PF2	; 3   @27
    192  70a9
    193  70a9		       b9 00 f8 	      lda	COL_0,y	; 5
    194  70ac		       0a		      asl
    195  70ad		       0a		      asl
    196  70ae		       0a		      asl
    197  70af		       0a		      asl
    198  70b0		       85 4d		      sta	PF0	; 3   @35
    199  70b2							;		  SLEEP 2      ; @37
    200  70b2		       b9 64 fa 	      lda	COL_3,y	; 5
    201  70b5		       85 4e		      sta	PF1	; 3   @45
    202  70b7							;		  SLEEP 3      ; @45
    203  70b7		       b9 30 fb 	      lda	COL_4,y	; 5
    204  70ba		       85 4f		      sta	PF2	; 3
    205  70bc
    206  70bc
    207  70bc
    208  70bc		       88		      dey		; 2
    209  70bd		       d0 83		      bne	SokoLogo	; 2(3)
    210  70bf
    211  70bf							;lda #0
    212  70bf							;sta PF0
    213  70bf							;sta PF1
    214  70bf							;sta PF2
    215  70bf
    216  70bf		       a2 00		      ldx	#0	;Platform
    217  70c1		       86 4d		      stx	PF0
    218  70c3		       86 4e		      stx	PF1
    219  70c5		       86 4f		      stx	PF2
    220  70c7
    221  70c7		       85 42		      sta	WSYNC
    222  70c9		       85 42		      sta	WSYNC
    223  70cb		       85 42		      sta	WSYNC
    224  70cd		       85 42		      sta	WSYNC
    225  70cf
    226  70cf		       86 49		      stx	COLUBK
    227  70d1		       bd 00 f4 	      lda	OverscanTime2,x
    228  70d4		       8d 96 02 	      sta	TIM64T
    229  70d7
    230  70d7				  -	      IF	0
    231  70d7				  -	      sta	WSYNC
    232  70d7				  -	      sta	WSYNC
    233  70d7				  -	      sta	WSYNC
    234  70d7				  -	      sta	WSYNC
    235  70d7				  -	      sta	WSYNC
    236  70d7				  -	      SLEEP	8
    237  70d7				  -	      jsr	SokoScreen
    238  70d7				  -
    239  70d7				  -	      lda	#0
    240  70d7				  -	      sta	BoardScrollX
    241  70d7				  -	      sta	BoardScrollY
    242  70d7					      ENDIF
    243  70d7
    244  70d7							;		ldy #63
    245  70d7							;bot2		 sta WSYNC
    246  70d7							;		dey
    247  70d7							;		bpl bot2
    248  70d7
    249  70d7							;--------------------------------------------------------------------------
    250  70d7
    251  70d7		       a9 00		      lda	#0
    252  70d9		       85 4d		      sta	PF0
    253  70db		       85 4e		      sta	PF1
    254  70dd		       85 4f		      sta	PF2
    255  70df
    256  70df
      0  70df					      NEXT_RANDOM
      1  70df
      2  70df		       a5 81		      lda	rnd
      3  70e1		       4a		      lsr
      4  70e2		       90 02		      bcc	.skipEOR
      5  70e4		       49 b4		      eor	#RND_EOR_VAL
      6  70e6		       85 81	   .skipEOR   sta	rnd
      7  70e8
    258  70e8
    259  70e8							; D1 VBLANK turns off beam
    260  70e8							; It needs to be turned on 37 scanlines later
    261  70e8
    262  70e8				   oscan
    263  70e8		       ad 84 02 	      lda	INTIM
    264  70eb		       d0 fb		      bne	oscan
    265  70ed
    266  70ed		       a9 42		      lda	#%01000010	; bit6 is not required
    267  70ef		       85 41		      sta	VBLANK	; end of screen - enter blanking
    268  70f1
    269  70f1				  -	      IF	0
    270  70f1				  -	      inc	rnd
    271  70f1				  -	      bne	rdd
    272  70f1				  -	      inc	rndHi
    273  70f1				  -rdd
    274  70f1				  -
    275  70f1				  -	      dec	digitick
    276  70f1				  -	      bpl	ret2
    277  70f1				  -	      lda	#40
    278  70f1				  -	      sta	digitick
    279  70f1				  -
    280  70f1				  -	      jsr	Random
    281  70f1				  -	      and	#3
    282  70f1				  -	      beq	ret2
    283  70f1				  -	      tax
    284  70f1				  -	      jsr	Random
    285  70f1				  -	      and	#$F0
    286  70f1				  -	      sta	digit-1,x
    287  70f1				  -	      jmp	RestartFrame0
    288  70f1				  -
    289  70f1				  -ret2
    290  70f1					      ENDIF
    291  70f1
    292  70f1
    293  70f1		       a5 4c		      lda	INPT4
    294  70f3		       10 03		      bpl	ret
    295  70f5
    296  70f5		       4c 1c f4 	      jmp	RestartFrame
    297  70f8
    298  70f8				   ret
    299  70f8		       60		      rts
    300  70f9
    301  70f9
    302  70f9
    303  70f9					      MAC	lumtable
    304  70f9							; {4} MIN LUM 1
    305  70f9							; {5} MIN LUM 2
    306  70f9							; {6} MIN LUM 3
    307  70f9
    308  70f9				   .LUM1      SET	{4}*256
    309  70f9				   .LUM2      SET	{5}*256
    310  70f9				   .LUM3      SET	{6}*256
    311  70f9
    312  70f9				   .STEP1     =	(256*({7}-{4}))/72
    313  70f9				   .STEP2     =	(256*({8}-{5}))/72
    314  70f9				   .STEP3     =	(256*({9}-{6}))/72
    315  70f9
    316  70f9					      REPEAT	72
    317  70f9					      .byte	{1}+(.LUM1/256)
    318  70f9					      .byte	{2}+(.LUM2/256)
    319  70f9					      .byte	{3}+(.LUM3/256)
    320  70f9
    321  70f9							;    ECHO {1}+(.LUM1/256)
    322  70f9							;    ECHO {2}+(.LUM1/256)
    323  70f9							;    ECHO {3}+(.LUM1/256)
    324  70f9
    325  70f9				   .LUM1      SET	.LUM1 + .STEP1
    326  70f9				   .LUM2      SET	.LUM2 + .STEP2
    327  70f9				   .LUM3      SET	.LUM3 + .STEP3
    328  70f9					      REPEND
    329  70f9					      ENDM		;{1}{2}{3} base colours
    330  70f9
    331  70f9							;colr_pal    LUMTABLE $B0,$30,$A0,0,8,4 ;2,4,6
    332  70f9							;    OPTIONAL_PAGEBREAK "colr_ntsc", 72*3
    333  70f9
    334  7100		       00 00 00 00*	      align	256
    335  7100							;    ECHO "NTSC LUMS"
    336  7100				   colr_ntsc2
      0  7100					      LUMTABLE	$90,$10,$20,$4,$6,$8,$4,$6,$8
      1  7100
      2  7100
      3  7100
      4  7100
      5  7100				   .LUM1      SET	$4*256
      6  7100				   .LUM2      SET	$6*256
      7  7100				   .LUM3      SET	$8*256
      8  7100
      9  7100		       00 00	   .STEP1     =	(256*($4-$4))/72
     10  7100		       00 00	   .STEP2     =	(256*($6-$6))/72
     11  7100		       00 00	   .STEP3     =	(256*($8-$8))/72
     12  7100
     13  7100					      REPEAT	72
     14  7100		       94		      .byte.b	$90+(.LUM1/256)
     15  7101		       16		      .byte.b	$10+(.LUM2/256)
     16  7102		       28		      .byte.b	$20+(.LUM3/256)
     17  7103
     18  7103
     19  7103
     20  7103
     21  7103
     22  7103				   .LUM1      SET	.LUM1 + .STEP1
     23  7103				   .LUM2      SET	.LUM2 + .STEP2
     24  7103				   .LUM3      SET	.LUM3 + .STEP3
     13  7103					      REPEND
     14  7103		       94		      .byte.b	$90+(.LUM1/256)
     15  7104		       16		      .byte.b	$10+(.LUM2/256)
     16  7105		       28		      .byte.b	$20+(.LUM3/256)
     17  7106
     18  7106
     19  7106
     20  7106
     21  7106
     22  7106				   .LUM1      SET	.LUM1 + .STEP1
     23  7106				   .LUM2      SET	.LUM2 + .STEP2
     24  7106				   .LUM3      SET	.LUM3 + .STEP3
     13  7106					      REPEND
     14  7106		       94		      .byte.b	$90+(.LUM1/256)
     15  7107		       16		      .byte.b	$10+(.LUM2/256)
     16  7108		       28		      .byte.b	$20+(.LUM3/256)
     17  7109
     18  7109
     19  7109
     20  7109
     21  7109
     22  7109				   .LUM1      SET	.LUM1 + .STEP1
     23  7109				   .LUM2      SET	.LUM2 + .STEP2
     24  7109				   .LUM3      SET	.LUM3 + .STEP3
     13  7109					      REPEND
     14  7109		       94		      .byte.b	$90+(.LUM1/256)
     15  710a		       16		      .byte.b	$10+(.LUM2/256)
     16  710b		       28		      .byte.b	$20+(.LUM3/256)
     17  710c
     18  710c
     19  710c
     20  710c
     21  710c
     22  710c				   .LUM1      SET	.LUM1 + .STEP1
     23  710c				   .LUM2      SET	.LUM2 + .STEP2
     24  710c				   .LUM3      SET	.LUM3 + .STEP3
     13  710c					      REPEND
     14  710c		       94		      .byte.b	$90+(.LUM1/256)
     15  710d		       16		      .byte.b	$10+(.LUM2/256)
     16  710e		       28		      .byte.b	$20+(.LUM3/256)
     17  710f
     18  710f
     19  710f
     20  710f
     21  710f
     22  710f				   .LUM1      SET	.LUM1 + .STEP1
     23  710f				   .LUM2      SET	.LUM2 + .STEP2
     24  710f				   .LUM3      SET	.LUM3 + .STEP3
     13  710f					      REPEND
     14  710f		       94		      .byte.b	$90+(.LUM1/256)
     15  7110		       16		      .byte.b	$10+(.LUM2/256)
     16  7111		       28		      .byte.b	$20+(.LUM3/256)
     17  7112
     18  7112
     19  7112
     20  7112
     21  7112
     22  7112				   .LUM1      SET	.LUM1 + .STEP1
     23  7112				   .LUM2      SET	.LUM2 + .STEP2
     24  7112				   .LUM3      SET	.LUM3 + .STEP3
     13  7112					      REPEND
     14  7112		       94		      .byte.b	$90+(.LUM1/256)
     15  7113		       16		      .byte.b	$10+(.LUM2/256)
     16  7114		       28		      .byte.b	$20+(.LUM3/256)
     17  7115
     18  7115
     19  7115
     20  7115
     21  7115
     22  7115				   .LUM1      SET	.LUM1 + .STEP1
     23  7115				   .LUM2      SET	.LUM2 + .STEP2
     24  7115				   .LUM3      SET	.LUM3 + .STEP3
     13  7115					      REPEND
     14  7115		       94		      .byte.b	$90+(.LUM1/256)
     15  7116		       16		      .byte.b	$10+(.LUM2/256)
     16  7117		       28		      .byte.b	$20+(.LUM3/256)
     17  7118
     18  7118
     19  7118
     20  7118
     21  7118
     22  7118				   .LUM1      SET	.LUM1 + .STEP1
     23  7118				   .LUM2      SET	.LUM2 + .STEP2
     24  7118				   .LUM3      SET	.LUM3 + .STEP3
     13  7118					      REPEND
     14  7118		       94		      .byte.b	$90+(.LUM1/256)
     15  7119		       16		      .byte.b	$10+(.LUM2/256)
     16  711a		       28		      .byte.b	$20+(.LUM3/256)
     17  711b
     18  711b
     19  711b
     20  711b
     21  711b
     22  711b				   .LUM1      SET	.LUM1 + .STEP1
     23  711b				   .LUM2      SET	.LUM2 + .STEP2
     24  711b				   .LUM3      SET	.LUM3 + .STEP3
     13  711b					      REPEND
     14  711b		       94		      .byte.b	$90+(.LUM1/256)
     15  711c		       16		      .byte.b	$10+(.LUM2/256)
     16  711d		       28		      .byte.b	$20+(.LUM3/256)
     17  711e
     18  711e
     19  711e
     20  711e
     21  711e
     22  711e				   .LUM1      SET	.LUM1 + .STEP1
     23  711e				   .LUM2      SET	.LUM2 + .STEP2
     24  711e				   .LUM3      SET	.LUM3 + .STEP3
     13  711e					      REPEND
     14  711e		       94		      .byte.b	$90+(.LUM1/256)
     15  711f		       16		      .byte.b	$10+(.LUM2/256)
     16  7120		       28		      .byte.b	$20+(.LUM3/256)
     17  7121
     18  7121
     19  7121
     20  7121
     21  7121
     22  7121				   .LUM1      SET	.LUM1 + .STEP1
     23  7121				   .LUM2      SET	.LUM2 + .STEP2
     24  7121				   .LUM3      SET	.LUM3 + .STEP3
     13  7121					      REPEND
     14  7121		       94		      .byte.b	$90+(.LUM1/256)
     15  7122		       16		      .byte.b	$10+(.LUM2/256)
     16  7123		       28		      .byte.b	$20+(.LUM3/256)
     17  7124
     18  7124
     19  7124
     20  7124
     21  7124
     22  7124				   .LUM1      SET	.LUM1 + .STEP1
     23  7124				   .LUM2      SET	.LUM2 + .STEP2
     24  7124				   .LUM3      SET	.LUM3 + .STEP3
     13  7124					      REPEND
     14  7124		       94		      .byte.b	$90+(.LUM1/256)
     15  7125		       16		      .byte.b	$10+(.LUM2/256)
     16  7126		       28		      .byte.b	$20+(.LUM3/256)
     17  7127
     18  7127
     19  7127
     20  7127
     21  7127
     22  7127				   .LUM1      SET	.LUM1 + .STEP1
     23  7127				   .LUM2      SET	.LUM2 + .STEP2
     24  7127				   .LUM3      SET	.LUM3 + .STEP3
     13  7127					      REPEND
     14  7127		       94		      .byte.b	$90+(.LUM1/256)
     15  7128		       16		      .byte.b	$10+(.LUM2/256)
     16  7129		       28		      .byte.b	$20+(.LUM3/256)
     17  712a
     18  712a
     19  712a
     20  712a
     21  712a
     22  712a				   .LUM1      SET	.LUM1 + .STEP1
     23  712a				   .LUM2      SET	.LUM2 + .STEP2
     24  712a				   .LUM3      SET	.LUM3 + .STEP3
     13  712a					      REPEND
     14  712a		       94		      .byte.b	$90+(.LUM1/256)
     15  712b		       16		      .byte.b	$10+(.LUM2/256)
     16  712c		       28		      .byte.b	$20+(.LUM3/256)
     17  712d
     18  712d
     19  712d
     20  712d
     21  712d
     22  712d				   .LUM1      SET	.LUM1 + .STEP1
     23  712d				   .LUM2      SET	.LUM2 + .STEP2
     24  712d				   .LUM3      SET	.LUM3 + .STEP3
     13  712d					      REPEND
     14  712d		       94		      .byte.b	$90+(.LUM1/256)
     15  712e		       16		      .byte.b	$10+(.LUM2/256)
     16  712f		       28		      .byte.b	$20+(.LUM3/256)
     17  7130
     18  7130
     19  7130
     20  7130
     21  7130
     22  7130				   .LUM1      SET	.LUM1 + .STEP1
     23  7130				   .LUM2      SET	.LUM2 + .STEP2
     24  7130				   .LUM3      SET	.LUM3 + .STEP3
     13  7130					      REPEND
     14  7130		       94		      .byte.b	$90+(.LUM1/256)
     15  7131		       16		      .byte.b	$10+(.LUM2/256)
     16  7132		       28		      .byte.b	$20+(.LUM3/256)
     17  7133
     18  7133
     19  7133
     20  7133
     21  7133
     22  7133				   .LUM1      SET	.LUM1 + .STEP1
     23  7133				   .LUM2      SET	.LUM2 + .STEP2
     24  7133				   .LUM3      SET	.LUM3 + .STEP3
     13  7133					      REPEND
     14  7133		       94		      .byte.b	$90+(.LUM1/256)
     15  7134		       16		      .byte.b	$10+(.LUM2/256)
     16  7135		       28		      .byte.b	$20+(.LUM3/256)
     17  7136
     18  7136
     19  7136
     20  7136
     21  7136
     22  7136				   .LUM1      SET	.LUM1 + .STEP1
     23  7136				   .LUM2      SET	.LUM2 + .STEP2
     24  7136				   .LUM3      SET	.LUM3 + .STEP3
     13  7136					      REPEND
     14  7136		       94		      .byte.b	$90+(.LUM1/256)
     15  7137		       16		      .byte.b	$10+(.LUM2/256)
     16  7138		       28		      .byte.b	$20+(.LUM3/256)
     17  7139
     18  7139
     19  7139
     20  7139
     21  7139
     22  7139				   .LUM1      SET	.LUM1 + .STEP1
     23  7139				   .LUM2      SET	.LUM2 + .STEP2
     24  7139				   .LUM3      SET	.LUM3 + .STEP3
     13  7139					      REPEND
     14  7139		       94		      .byte.b	$90+(.LUM1/256)
     15  713a		       16		      .byte.b	$10+(.LUM2/256)
     16  713b		       28		      .byte.b	$20+(.LUM3/256)
     17  713c
     18  713c
     19  713c
     20  713c
     21  713c
     22  713c				   .LUM1      SET	.LUM1 + .STEP1
     23  713c				   .LUM2      SET	.LUM2 + .STEP2
     24  713c				   .LUM3      SET	.LUM3 + .STEP3
     13  713c					      REPEND
     14  713c		       94		      .byte.b	$90+(.LUM1/256)
     15  713d		       16		      .byte.b	$10+(.LUM2/256)
     16  713e		       28		      .byte.b	$20+(.LUM3/256)
     17  713f
     18  713f
     19  713f
     20  713f
     21  713f
     22  713f				   .LUM1      SET	.LUM1 + .STEP1
     23  713f				   .LUM2      SET	.LUM2 + .STEP2
     24  713f				   .LUM3      SET	.LUM3 + .STEP3
     13  713f					      REPEND
     14  713f		       94		      .byte.b	$90+(.LUM1/256)
     15  7140		       16		      .byte.b	$10+(.LUM2/256)
     16  7141		       28		      .byte.b	$20+(.LUM3/256)
     17  7142
     18  7142
     19  7142
     20  7142
     21  7142
     22  7142				   .LUM1      SET	.LUM1 + .STEP1
     23  7142				   .LUM2      SET	.LUM2 + .STEP2
     24  7142				   .LUM3      SET	.LUM3 + .STEP3
     13  7142					      REPEND
     14  7142		       94		      .byte.b	$90+(.LUM1/256)
     15  7143		       16		      .byte.b	$10+(.LUM2/256)
     16  7144		       28		      .byte.b	$20+(.LUM3/256)
     17  7145
     18  7145
     19  7145
     20  7145
     21  7145
     22  7145				   .LUM1      SET	.LUM1 + .STEP1
     23  7145				   .LUM2      SET	.LUM2 + .STEP2
     24  7145				   .LUM3      SET	.LUM3 + .STEP3
     13  7145					      REPEND
     14  7145		       94		      .byte.b	$90+(.LUM1/256)
     15  7146		       16		      .byte.b	$10+(.LUM2/256)
     16  7147		       28		      .byte.b	$20+(.LUM3/256)
     17  7148
     18  7148
     19  7148
     20  7148
     21  7148
     22  7148				   .LUM1      SET	.LUM1 + .STEP1
     23  7148				   .LUM2      SET	.LUM2 + .STEP2
     24  7148				   .LUM3      SET	.LUM3 + .STEP3
     13  7148					      REPEND
     14  7148		       94		      .byte.b	$90+(.LUM1/256)
     15  7149		       16		      .byte.b	$10+(.LUM2/256)
     16  714a		       28		      .byte.b	$20+(.LUM3/256)
     17  714b
     18  714b
     19  714b
     20  714b
     21  714b
     22  714b				   .LUM1      SET	.LUM1 + .STEP1
     23  714b				   .LUM2      SET	.LUM2 + .STEP2
     24  714b				   .LUM3      SET	.LUM3 + .STEP3
     13  714b					      REPEND
     14  714b		       94		      .byte.b	$90+(.LUM1/256)
     15  714c		       16		      .byte.b	$10+(.LUM2/256)
     16  714d		       28		      .byte.b	$20+(.LUM3/256)
     17  714e
     18  714e
     19  714e
     20  714e
     21  714e
     22  714e				   .LUM1      SET	.LUM1 + .STEP1
     23  714e				   .LUM2      SET	.LUM2 + .STEP2
     24  714e				   .LUM3      SET	.LUM3 + .STEP3
     13  714e					      REPEND
     14  714e		       94		      .byte.b	$90+(.LUM1/256)
     15  714f		       16		      .byte.b	$10+(.LUM2/256)
     16  7150		       28		      .byte.b	$20+(.LUM3/256)
     17  7151
     18  7151
     19  7151
     20  7151
     21  7151
     22  7151				   .LUM1      SET	.LUM1 + .STEP1
     23  7151				   .LUM2      SET	.LUM2 + .STEP2
     24  7151				   .LUM3      SET	.LUM3 + .STEP3
     13  7151					      REPEND
     14  7151		       94		      .byte.b	$90+(.LUM1/256)
     15  7152		       16		      .byte.b	$10+(.LUM2/256)
     16  7153		       28		      .byte.b	$20+(.LUM3/256)
     17  7154
     18  7154
     19  7154
     20  7154
     21  7154
     22  7154				   .LUM1      SET	.LUM1 + .STEP1
     23  7154				   .LUM2      SET	.LUM2 + .STEP2
     24  7154				   .LUM3      SET	.LUM3 + .STEP3
     13  7154					      REPEND
     14  7154		       94		      .byte.b	$90+(.LUM1/256)
     15  7155		       16		      .byte.b	$10+(.LUM2/256)
     16  7156		       28		      .byte.b	$20+(.LUM3/256)
     17  7157
     18  7157
     19  7157
     20  7157
     21  7157
     22  7157				   .LUM1      SET	.LUM1 + .STEP1
     23  7157				   .LUM2      SET	.LUM2 + .STEP2
     24  7157				   .LUM3      SET	.LUM3 + .STEP3
     13  7157					      REPEND
     14  7157		       94		      .byte.b	$90+(.LUM1/256)
     15  7158		       16		      .byte.b	$10+(.LUM2/256)
     16  7159		       28		      .byte.b	$20+(.LUM3/256)
     17  715a
     18  715a
     19  715a
     20  715a
     21  715a
     22  715a				   .LUM1      SET	.LUM1 + .STEP1
     23  715a				   .LUM2      SET	.LUM2 + .STEP2
     24  715a				   .LUM3      SET	.LUM3 + .STEP3
     13  715a					      REPEND
     14  715a		       94		      .byte.b	$90+(.LUM1/256)
     15  715b		       16		      .byte.b	$10+(.LUM2/256)
     16  715c		       28		      .byte.b	$20+(.LUM3/256)
     17  715d
     18  715d
     19  715d
     20  715d
     21  715d
     22  715d				   .LUM1      SET	.LUM1 + .STEP1
     23  715d				   .LUM2      SET	.LUM2 + .STEP2
     24  715d				   .LUM3      SET	.LUM3 + .STEP3
     13  715d					      REPEND
     14  715d		       94		      .byte.b	$90+(.LUM1/256)
     15  715e		       16		      .byte.b	$10+(.LUM2/256)
     16  715f		       28		      .byte.b	$20+(.LUM3/256)
     17  7160
     18  7160
     19  7160
     20  7160
     21  7160
     22  7160				   .LUM1      SET	.LUM1 + .STEP1
     23  7160				   .LUM2      SET	.LUM2 + .STEP2
     24  7160				   .LUM3      SET	.LUM3 + .STEP3
     13  7160					      REPEND
     14  7160		       94		      .byte.b	$90+(.LUM1/256)
     15  7161		       16		      .byte.b	$10+(.LUM2/256)
     16  7162		       28		      .byte.b	$20+(.LUM3/256)
     17  7163
     18  7163
     19  7163
     20  7163
     21  7163
     22  7163				   .LUM1      SET	.LUM1 + .STEP1
     23  7163				   .LUM2      SET	.LUM2 + .STEP2
     24  7163				   .LUM3      SET	.LUM3 + .STEP3
     13  7163					      REPEND
     14  7163		       94		      .byte.b	$90+(.LUM1/256)
     15  7164		       16		      .byte.b	$10+(.LUM2/256)
     16  7165		       28		      .byte.b	$20+(.LUM3/256)
     17  7166
     18  7166
     19  7166
     20  7166
     21  7166
     22  7166				   .LUM1      SET	.LUM1 + .STEP1
     23  7166				   .LUM2      SET	.LUM2 + .STEP2
     24  7166				   .LUM3      SET	.LUM3 + .STEP3
     13  7166					      REPEND
     14  7166		       94		      .byte.b	$90+(.LUM1/256)
     15  7167		       16		      .byte.b	$10+(.LUM2/256)
     16  7168		       28		      .byte.b	$20+(.LUM3/256)
     17  7169
     18  7169
     19  7169
     20  7169
     21  7169
     22  7169				   .LUM1      SET	.LUM1 + .STEP1
     23  7169				   .LUM2      SET	.LUM2 + .STEP2
     24  7169				   .LUM3      SET	.LUM3 + .STEP3
     13  7169					      REPEND
     14  7169		       94		      .byte.b	$90+(.LUM1/256)
     15  716a		       16		      .byte.b	$10+(.LUM2/256)
     16  716b		       28		      .byte.b	$20+(.LUM3/256)
     17  716c
     18  716c
     19  716c
     20  716c
     21  716c
     22  716c				   .LUM1      SET	.LUM1 + .STEP1
     23  716c				   .LUM2      SET	.LUM2 + .STEP2
     24  716c				   .LUM3      SET	.LUM3 + .STEP3
     13  716c					      REPEND
     14  716c		       94		      .byte.b	$90+(.LUM1/256)
     15  716d		       16		      .byte.b	$10+(.LUM2/256)
     16  716e		       28		      .byte.b	$20+(.LUM3/256)
     17  716f
     18  716f
     19  716f
     20  716f
     21  716f
     22  716f				   .LUM1      SET	.LUM1 + .STEP1
     23  716f				   .LUM2      SET	.LUM2 + .STEP2
     24  716f				   .LUM3      SET	.LUM3 + .STEP3
     13  716f					      REPEND
     14  716f		       94		      .byte.b	$90+(.LUM1/256)
     15  7170		       16		      .byte.b	$10+(.LUM2/256)
     16  7171		       28		      .byte.b	$20+(.LUM3/256)
     17  7172
     18  7172
     19  7172
     20  7172
     21  7172
     22  7172				   .LUM1      SET	.LUM1 + .STEP1
     23  7172				   .LUM2      SET	.LUM2 + .STEP2
     24  7172				   .LUM3      SET	.LUM3 + .STEP3
     13  7172					      REPEND
     14  7172		       94		      .byte.b	$90+(.LUM1/256)
     15  7173		       16		      .byte.b	$10+(.LUM2/256)
     16  7174		       28		      .byte.b	$20+(.LUM3/256)
     17  7175
     18  7175
     19  7175
     20  7175
     21  7175
     22  7175				   .LUM1      SET	.LUM1 + .STEP1
     23  7175				   .LUM2      SET	.LUM2 + .STEP2
     24  7175				   .LUM3      SET	.LUM3 + .STEP3
     13  7175					      REPEND
     14  7175		       94		      .byte.b	$90+(.LUM1/256)
     15  7176		       16		      .byte.b	$10+(.LUM2/256)
     16  7177		       28		      .byte.b	$20+(.LUM3/256)
     17  7178
     18  7178
     19  7178
     20  7178
     21  7178
     22  7178				   .LUM1      SET	.LUM1 + .STEP1
     23  7178				   .LUM2      SET	.LUM2 + .STEP2
     24  7178				   .LUM3      SET	.LUM3 + .STEP3
     13  7178					      REPEND
     14  7178		       94		      .byte.b	$90+(.LUM1/256)
     15  7179		       16		      .byte.b	$10+(.LUM2/256)
     16  717a		       28		      .byte.b	$20+(.LUM3/256)
     17  717b
     18  717b
     19  717b
     20  717b
     21  717b
     22  717b				   .LUM1      SET	.LUM1 + .STEP1
     23  717b				   .LUM2      SET	.LUM2 + .STEP2
     24  717b				   .LUM3      SET	.LUM3 + .STEP3
     13  717b					      REPEND
     14  717b		       94		      .byte.b	$90+(.LUM1/256)
     15  717c		       16		      .byte.b	$10+(.LUM2/256)
     16  717d		       28		      .byte.b	$20+(.LUM3/256)
     17  717e
     18  717e
     19  717e
     20  717e
     21  717e
     22  717e				   .LUM1      SET	.LUM1 + .STEP1
     23  717e				   .LUM2      SET	.LUM2 + .STEP2
     24  717e				   .LUM3      SET	.LUM3 + .STEP3
     13  717e					      REPEND
     14  717e		       94		      .byte.b	$90+(.LUM1/256)
     15  717f		       16		      .byte.b	$10+(.LUM2/256)
     16  7180		       28		      .byte.b	$20+(.LUM3/256)
     17  7181
     18  7181
     19  7181
     20  7181
     21  7181
     22  7181				   .LUM1      SET	.LUM1 + .STEP1
     23  7181				   .LUM2      SET	.LUM2 + .STEP2
     24  7181				   .LUM3      SET	.LUM3 + .STEP3
     13  7181					      REPEND
     14  7181		       94		      .byte.b	$90+(.LUM1/256)
     15  7182		       16		      .byte.b	$10+(.LUM2/256)
     16  7183		       28		      .byte.b	$20+(.LUM3/256)
     17  7184
     18  7184
     19  7184
     20  7184
     21  7184
     22  7184				   .LUM1      SET	.LUM1 + .STEP1
     23  7184				   .LUM2      SET	.LUM2 + .STEP2
     24  7184				   .LUM3      SET	.LUM3 + .STEP3
     13  7184					      REPEND
     14  7184		       94		      .byte.b	$90+(.LUM1/256)
     15  7185		       16		      .byte.b	$10+(.LUM2/256)
     16  7186		       28		      .byte.b	$20+(.LUM3/256)
     17  7187
     18  7187
     19  7187
     20  7187
     21  7187
     22  7187				   .LUM1      SET	.LUM1 + .STEP1
     23  7187				   .LUM2      SET	.LUM2 + .STEP2
     24  7187				   .LUM3      SET	.LUM3 + .STEP3
     13  7187					      REPEND
     14  7187		       94		      .byte.b	$90+(.LUM1/256)
     15  7188		       16		      .byte.b	$10+(.LUM2/256)
     16  7189		       28		      .byte.b	$20+(.LUM3/256)
     17  718a
     18  718a
     19  718a
     20  718a
     21  718a
     22  718a				   .LUM1      SET	.LUM1 + .STEP1
     23  718a				   .LUM2      SET	.LUM2 + .STEP2
     24  718a				   .LUM3      SET	.LUM3 + .STEP3
     13  718a					      REPEND
     14  718a		       94		      .byte.b	$90+(.LUM1/256)
     15  718b		       16		      .byte.b	$10+(.LUM2/256)
     16  718c		       28		      .byte.b	$20+(.LUM3/256)
     17  718d
     18  718d
     19  718d
     20  718d
     21  718d
     22  718d				   .LUM1      SET	.LUM1 + .STEP1
     23  718d				   .LUM2      SET	.LUM2 + .STEP2
     24  718d				   .LUM3      SET	.LUM3 + .STEP3
     13  718d					      REPEND
     14  718d		       94		      .byte.b	$90+(.LUM1/256)
     15  718e		       16		      .byte.b	$10+(.LUM2/256)
     16  718f		       28		      .byte.b	$20+(.LUM3/256)
     17  7190
     18  7190
     19  7190
     20  7190
     21  7190
     22  7190				   .LUM1      SET	.LUM1 + .STEP1
     23  7190				   .LUM2      SET	.LUM2 + .STEP2
     24  7190				   .LUM3      SET	.LUM3 + .STEP3
     13  7190					      REPEND
     14  7190		       94		      .byte.b	$90+(.LUM1/256)
     15  7191		       16		      .byte.b	$10+(.LUM2/256)
     16  7192		       28		      .byte.b	$20+(.LUM3/256)
     17  7193
     18  7193
     19  7193
     20  7193
     21  7193
     22  7193				   .LUM1      SET	.LUM1 + .STEP1
     23  7193				   .LUM2      SET	.LUM2 + .STEP2
     24  7193				   .LUM3      SET	.LUM3 + .STEP3
     13  7193					      REPEND
     14  7193		       94		      .byte.b	$90+(.LUM1/256)
     15  7194		       16		      .byte.b	$10+(.LUM2/256)
     16  7195		       28		      .byte.b	$20+(.LUM3/256)
     17  7196
     18  7196
     19  7196
     20  7196
     21  7196
     22  7196				   .LUM1      SET	.LUM1 + .STEP1
     23  7196				   .LUM2      SET	.LUM2 + .STEP2
     24  7196				   .LUM3      SET	.LUM3 + .STEP3
     13  7196					      REPEND
     14  7196		       94		      .byte.b	$90+(.LUM1/256)
     15  7197		       16		      .byte.b	$10+(.LUM2/256)
     16  7198		       28		      .byte.b	$20+(.LUM3/256)
     17  7199
     18  7199
     19  7199
     20  7199
     21  7199
     22  7199				   .LUM1      SET	.LUM1 + .STEP1
     23  7199				   .LUM2      SET	.LUM2 + .STEP2
     24  7199				   .LUM3      SET	.LUM3 + .STEP3
     13  7199					      REPEND
     14  7199		       94		      .byte.b	$90+(.LUM1/256)
     15  719a		       16		      .byte.b	$10+(.LUM2/256)
     16  719b		       28		      .byte.b	$20+(.LUM3/256)
     17  719c
     18  719c
     19  719c
     20  719c
     21  719c
     22  719c				   .LUM1      SET	.LUM1 + .STEP1
     23  719c				   .LUM2      SET	.LUM2 + .STEP2
     24  719c				   .LUM3      SET	.LUM3 + .STEP3
     13  719c					      REPEND
     14  719c		       94		      .byte.b	$90+(.LUM1/256)
     15  719d		       16		      .byte.b	$10+(.LUM2/256)
     16  719e		       28		      .byte.b	$20+(.LUM3/256)
     17  719f
     18  719f
     19  719f
     20  719f
     21  719f
     22  719f				   .LUM1      SET	.LUM1 + .STEP1
     23  719f				   .LUM2      SET	.LUM2 + .STEP2
     24  719f				   .LUM3      SET	.LUM3 + .STEP3
     13  719f					      REPEND
     14  719f		       94		      .byte.b	$90+(.LUM1/256)
     15  71a0		       16		      .byte.b	$10+(.LUM2/256)
     16  71a1		       28		      .byte.b	$20+(.LUM3/256)
     17  71a2
     18  71a2
     19  71a2
     20  71a2
     21  71a2
     22  71a2				   .LUM1      SET	.LUM1 + .STEP1
     23  71a2				   .LUM2      SET	.LUM2 + .STEP2
     24  71a2				   .LUM3      SET	.LUM3 + .STEP3
     13  71a2					      REPEND
     14  71a2		       94		      .byte.b	$90+(.LUM1/256)
     15  71a3		       16		      .byte.b	$10+(.LUM2/256)
     16  71a4		       28		      .byte.b	$20+(.LUM3/256)
     17  71a5
     18  71a5
     19  71a5
     20  71a5
     21  71a5
     22  71a5				   .LUM1      SET	.LUM1 + .STEP1
     23  71a5				   .LUM2      SET	.LUM2 + .STEP2
     24  71a5				   .LUM3      SET	.LUM3 + .STEP3
     13  71a5					      REPEND
     14  71a5		       94		      .byte.b	$90+(.LUM1/256)
     15  71a6		       16		      .byte.b	$10+(.LUM2/256)
     16  71a7		       28		      .byte.b	$20+(.LUM3/256)
     17  71a8
     18  71a8
     19  71a8
     20  71a8
     21  71a8
     22  71a8				   .LUM1      SET	.LUM1 + .STEP1
     23  71a8				   .LUM2      SET	.LUM2 + .STEP2
     24  71a8				   .LUM3      SET	.LUM3 + .STEP3
     13  71a8					      REPEND
     14  71a8		       94		      .byte.b	$90+(.LUM1/256)
     15  71a9		       16		      .byte.b	$10+(.LUM2/256)
     16  71aa		       28		      .byte.b	$20+(.LUM3/256)
     17  71ab
     18  71ab
     19  71ab
     20  71ab
     21  71ab
     22  71ab				   .LUM1      SET	.LUM1 + .STEP1
     23  71ab				   .LUM2      SET	.LUM2 + .STEP2
     24  71ab				   .LUM3      SET	.LUM3 + .STEP3
     13  71ab					      REPEND
     14  71ab		       94		      .byte.b	$90+(.LUM1/256)
     15  71ac		       16		      .byte.b	$10+(.LUM2/256)
     16  71ad		       28		      .byte.b	$20+(.LUM3/256)
     17  71ae
     18  71ae
     19  71ae
     20  71ae
     21  71ae
     22  71ae				   .LUM1      SET	.LUM1 + .STEP1
     23  71ae				   .LUM2      SET	.LUM2 + .STEP2
     24  71ae				   .LUM3      SET	.LUM3 + .STEP3
     13  71ae					      REPEND
     14  71ae		       94		      .byte.b	$90+(.LUM1/256)
     15  71af		       16		      .byte.b	$10+(.LUM2/256)
     16  71b0		       28		      .byte.b	$20+(.LUM3/256)
     17  71b1
     18  71b1
     19  71b1
     20  71b1
     21  71b1
     22  71b1				   .LUM1      SET	.LUM1 + .STEP1
     23  71b1				   .LUM2      SET	.LUM2 + .STEP2
     24  71b1				   .LUM3      SET	.LUM3 + .STEP3
     13  71b1					      REPEND
     14  71b1		       94		      .byte.b	$90+(.LUM1/256)
     15  71b2		       16		      .byte.b	$10+(.LUM2/256)
     16  71b3		       28		      .byte.b	$20+(.LUM3/256)
     17  71b4
     18  71b4
     19  71b4
     20  71b4
     21  71b4
     22  71b4				   .LUM1      SET	.LUM1 + .STEP1
     23  71b4				   .LUM2      SET	.LUM2 + .STEP2
     24  71b4				   .LUM3      SET	.LUM3 + .STEP3
     13  71b4					      REPEND
     14  71b4		       94		      .byte.b	$90+(.LUM1/256)
     15  71b5		       16		      .byte.b	$10+(.LUM2/256)
     16  71b6		       28		      .byte.b	$20+(.LUM3/256)
     17  71b7
     18  71b7
     19  71b7
     20  71b7
     21  71b7
     22  71b7				   .LUM1      SET	.LUM1 + .STEP1
     23  71b7				   .LUM2      SET	.LUM2 + .STEP2
     24  71b7				   .LUM3      SET	.LUM3 + .STEP3
     13  71b7					      REPEND
     14  71b7		       94		      .byte.b	$90+(.LUM1/256)
     15  71b8		       16		      .byte.b	$10+(.LUM2/256)
     16  71b9		       28		      .byte.b	$20+(.LUM3/256)
     17  71ba
     18  71ba
     19  71ba
     20  71ba
     21  71ba
     22  71ba				   .LUM1      SET	.LUM1 + .STEP1
     23  71ba				   .LUM2      SET	.LUM2 + .STEP2
     24  71ba				   .LUM3      SET	.LUM3 + .STEP3
     13  71ba					      REPEND
     14  71ba		       94		      .byte.b	$90+(.LUM1/256)
     15  71bb		       16		      .byte.b	$10+(.LUM2/256)
     16  71bc		       28		      .byte.b	$20+(.LUM3/256)
     17  71bd
     18  71bd
     19  71bd
     20  71bd
     21  71bd
     22  71bd				   .LUM1      SET	.LUM1 + .STEP1
     23  71bd				   .LUM2      SET	.LUM2 + .STEP2
     24  71bd				   .LUM3      SET	.LUM3 + .STEP3
     13  71bd					      REPEND
     14  71bd		       94		      .byte.b	$90+(.LUM1/256)
     15  71be		       16		      .byte.b	$10+(.LUM2/256)
     16  71bf		       28		      .byte.b	$20+(.LUM3/256)
     17  71c0
     18  71c0
     19  71c0
     20  71c0
     21  71c0
     22  71c0				   .LUM1      SET	.LUM1 + .STEP1
     23  71c0				   .LUM2      SET	.LUM2 + .STEP2
     24  71c0				   .LUM3      SET	.LUM3 + .STEP3
     13  71c0					      REPEND
     14  71c0		       94		      .byte.b	$90+(.LUM1/256)
     15  71c1		       16		      .byte.b	$10+(.LUM2/256)
     16  71c2		       28		      .byte.b	$20+(.LUM3/256)
     17  71c3
     18  71c3
     19  71c3
     20  71c3
     21  71c3
     22  71c3				   .LUM1      SET	.LUM1 + .STEP1
     23  71c3				   .LUM2      SET	.LUM2 + .STEP2
     24  71c3				   .LUM3      SET	.LUM3 + .STEP3
     13  71c3					      REPEND
     14  71c3		       94		      .byte.b	$90+(.LUM1/256)
     15  71c4		       16		      .byte.b	$10+(.LUM2/256)
     16  71c5		       28		      .byte.b	$20+(.LUM3/256)
     17  71c6
     18  71c6
     19  71c6
     20  71c6
     21  71c6
     22  71c6				   .LUM1      SET	.LUM1 + .STEP1
     23  71c6				   .LUM2      SET	.LUM2 + .STEP2
     24  71c6				   .LUM3      SET	.LUM3 + .STEP3
     13  71c6					      REPEND
     14  71c6		       94		      .byte.b	$90+(.LUM1/256)
     15  71c7		       16		      .byte.b	$10+(.LUM2/256)
     16  71c8		       28		      .byte.b	$20+(.LUM3/256)
     17  71c9
     18  71c9
     19  71c9
     20  71c9
     21  71c9
     22  71c9				   .LUM1      SET	.LUM1 + .STEP1
     23  71c9				   .LUM2      SET	.LUM2 + .STEP2
     24  71c9				   .LUM3      SET	.LUM3 + .STEP3
     13  71c9					      REPEND
     14  71c9		       94		      .byte.b	$90+(.LUM1/256)
     15  71ca		       16		      .byte.b	$10+(.LUM2/256)
     16  71cb		       28		      .byte.b	$20+(.LUM3/256)
     17  71cc
     18  71cc
     19  71cc
     20  71cc
     21  71cc
     22  71cc				   .LUM1      SET	.LUM1 + .STEP1
     23  71cc				   .LUM2      SET	.LUM2 + .STEP2
     24  71cc				   .LUM3      SET	.LUM3 + .STEP3
     13  71cc					      REPEND
     14  71cc		       94		      .byte.b	$90+(.LUM1/256)
     15  71cd		       16		      .byte.b	$10+(.LUM2/256)
     16  71ce		       28		      .byte.b	$20+(.LUM3/256)
     17  71cf
     18  71cf
     19  71cf
     20  71cf
     21  71cf
     22  71cf				   .LUM1      SET	.LUM1 + .STEP1
     23  71cf				   .LUM2      SET	.LUM2 + .STEP2
     24  71cf				   .LUM3      SET	.LUM3 + .STEP3
     13  71cf					      REPEND
     14  71cf		       94		      .byte.b	$90+(.LUM1/256)
     15  71d0		       16		      .byte.b	$10+(.LUM2/256)
     16  71d1		       28		      .byte.b	$20+(.LUM3/256)
     17  71d2
     18  71d2
     19  71d2
     20  71d2
     21  71d2
     22  71d2				   .LUM1      SET	.LUM1 + .STEP1
     23  71d2				   .LUM2      SET	.LUM2 + .STEP2
     24  71d2				   .LUM3      SET	.LUM3 + .STEP3
     13  71d2					      REPEND
     14  71d2		       94		      .byte.b	$90+(.LUM1/256)
     15  71d3		       16		      .byte.b	$10+(.LUM2/256)
     16  71d4		       28		      .byte.b	$20+(.LUM3/256)
     17  71d5
     18  71d5
     19  71d5
     20  71d5
     21  71d5
     22  71d5				   .LUM1      SET	.LUM1 + .STEP1
     23  71d5				   .LUM2      SET	.LUM2 + .STEP2
     24  71d5				   .LUM3      SET	.LUM3 + .STEP3
     13  71d5					      REPEND
     14  71d5		       94		      .byte.b	$90+(.LUM1/256)
     15  71d6		       16		      .byte.b	$10+(.LUM2/256)
     16  71d7		       28		      .byte.b	$20+(.LUM3/256)
     17  71d8
     18  71d8
     19  71d8
     20  71d8
     21  71d8
     22  71d8				   .LUM1      SET	.LUM1 + .STEP1
     23  71d8				   .LUM2      SET	.LUM2 + .STEP2
     24  71d8				   .LUM3      SET	.LUM3 + .STEP3
     25  71d8					      REPEND
    338  71d8							;colr_ntsc   LUMTABLE $70,$40,$a0,$A,$2,$E,$8,$E,$8
    339  71d8
    340  71d8							;    ECHO "PAL LUMS"
    341  71d8							;    OPTIONAL_PAGEBREAK "colr_pal", 72*3
      0  71d8				   colr_pal   LUMTABLE	$60, $80, $10, $6,$4,$8,$6,$4,$8
      1  71d8
      2  71d8
      3  71d8
      4  71d8
      5  71d8				   .LUM1      SET	$6*256
      6  71d8				   .LUM2      SET	$4*256
      7  71d8				   .LUM3      SET	$8*256
      8  71d8
      9  71d8		       00 00	   .STEP1     =	(256*($6-$6))/72
     10  71d8		       00 00	   .STEP2     =	(256*($4-$4))/72
     11  71d8		       00 00	   .STEP3     =	(256*($8-$8))/72
     12  71d8
     13  71d8					      REPEAT	72
     14  71d8		       66		      .byte.b	$60+(.LUM1/256)
     15  71d9		       84		      .byte.b	$80+(.LUM2/256)
     16  71da		       18		      .byte.b	$10+(.LUM3/256)
     17  71db
     18  71db
     19  71db
     20  71db
     21  71db
     22  71db				   .LUM1      SET	.LUM1 + .STEP1
     23  71db				   .LUM2      SET	.LUM2 + .STEP2
     24  71db				   .LUM3      SET	.LUM3 + .STEP3
     13  71db					      REPEND
     14  71db		       66		      .byte.b	$60+(.LUM1/256)
     15  71dc		       84		      .byte.b	$80+(.LUM2/256)
     16  71dd		       18		      .byte.b	$10+(.LUM3/256)
     17  71de
     18  71de
     19  71de
     20  71de
     21  71de
     22  71de				   .LUM1      SET	.LUM1 + .STEP1
     23  71de				   .LUM2      SET	.LUM2 + .STEP2
     24  71de				   .LUM3      SET	.LUM3 + .STEP3
     13  71de					      REPEND
     14  71de		       66		      .byte.b	$60+(.LUM1/256)
     15  71df		       84		      .byte.b	$80+(.LUM2/256)
     16  71e0		       18		      .byte.b	$10+(.LUM3/256)
     17  71e1
     18  71e1
     19  71e1
     20  71e1
     21  71e1
     22  71e1				   .LUM1      SET	.LUM1 + .STEP1
     23  71e1				   .LUM2      SET	.LUM2 + .STEP2
     24  71e1				   .LUM3      SET	.LUM3 + .STEP3
     13  71e1					      REPEND
     14  71e1		       66		      .byte.b	$60+(.LUM1/256)
     15  71e2		       84		      .byte.b	$80+(.LUM2/256)
     16  71e3		       18		      .byte.b	$10+(.LUM3/256)
     17  71e4
     18  71e4
     19  71e4
     20  71e4
     21  71e4
     22  71e4				   .LUM1      SET	.LUM1 + .STEP1
     23  71e4				   .LUM2      SET	.LUM2 + .STEP2
     24  71e4				   .LUM3      SET	.LUM3 + .STEP3
     13  71e4					      REPEND
     14  71e4		       66		      .byte.b	$60+(.LUM1/256)
     15  71e5		       84		      .byte.b	$80+(.LUM2/256)
     16  71e6		       18		      .byte.b	$10+(.LUM3/256)
     17  71e7
     18  71e7
     19  71e7
     20  71e7
     21  71e7
     22  71e7				   .LUM1      SET	.LUM1 + .STEP1
     23  71e7				   .LUM2      SET	.LUM2 + .STEP2
     24  71e7				   .LUM3      SET	.LUM3 + .STEP3
     13  71e7					      REPEND
     14  71e7		       66		      .byte.b	$60+(.LUM1/256)
     15  71e8		       84		      .byte.b	$80+(.LUM2/256)
     16  71e9		       18		      .byte.b	$10+(.LUM3/256)
     17  71ea
     18  71ea
     19  71ea
     20  71ea
     21  71ea
     22  71ea				   .LUM1      SET	.LUM1 + .STEP1
     23  71ea				   .LUM2      SET	.LUM2 + .STEP2
     24  71ea				   .LUM3      SET	.LUM3 + .STEP3
     13  71ea					      REPEND
     14  71ea		       66		      .byte.b	$60+(.LUM1/256)
     15  71eb		       84		      .byte.b	$80+(.LUM2/256)
     16  71ec		       18		      .byte.b	$10+(.LUM3/256)
     17  71ed
     18  71ed
     19  71ed
     20  71ed
     21  71ed
     22  71ed				   .LUM1      SET	.LUM1 + .STEP1
     23  71ed				   .LUM2      SET	.LUM2 + .STEP2
     24  71ed				   .LUM3      SET	.LUM3 + .STEP3
     13  71ed					      REPEND
     14  71ed		       66		      .byte.b	$60+(.LUM1/256)
     15  71ee		       84		      .byte.b	$80+(.LUM2/256)
     16  71ef		       18		      .byte.b	$10+(.LUM3/256)
     17  71f0
     18  71f0
     19  71f0
     20  71f0
     21  71f0
     22  71f0				   .LUM1      SET	.LUM1 + .STEP1
     23  71f0				   .LUM2      SET	.LUM2 + .STEP2
     24  71f0				   .LUM3      SET	.LUM3 + .STEP3
     13  71f0					      REPEND
     14  71f0		       66		      .byte.b	$60+(.LUM1/256)
     15  71f1		       84		      .byte.b	$80+(.LUM2/256)
     16  71f2		       18		      .byte.b	$10+(.LUM3/256)
     17  71f3
     18  71f3
     19  71f3
     20  71f3
     21  71f3
     22  71f3				   .LUM1      SET	.LUM1 + .STEP1
     23  71f3				   .LUM2      SET	.LUM2 + .STEP2
     24  71f3				   .LUM3      SET	.LUM3 + .STEP3
     13  71f3					      REPEND
     14  71f3		       66		      .byte.b	$60+(.LUM1/256)
     15  71f4		       84		      .byte.b	$80+(.LUM2/256)
     16  71f5		       18		      .byte.b	$10+(.LUM3/256)
     17  71f6
     18  71f6
     19  71f6
     20  71f6
     21  71f6
     22  71f6				   .LUM1      SET	.LUM1 + .STEP1
     23  71f6				   .LUM2      SET	.LUM2 + .STEP2
     24  71f6				   .LUM3      SET	.LUM3 + .STEP3
     13  71f6					      REPEND
     14  71f6		       66		      .byte.b	$60+(.LUM1/256)
     15  71f7		       84		      .byte.b	$80+(.LUM2/256)
     16  71f8		       18		      .byte.b	$10+(.LUM3/256)
     17  71f9
     18  71f9
     19  71f9
     20  71f9
     21  71f9
     22  71f9				   .LUM1      SET	.LUM1 + .STEP1
     23  71f9				   .LUM2      SET	.LUM2 + .STEP2
     24  71f9				   .LUM3      SET	.LUM3 + .STEP3
     13  71f9					      REPEND
     14  71f9		       66		      .byte.b	$60+(.LUM1/256)
     15  71fa		       84		      .byte.b	$80+(.LUM2/256)
     16  71fb		       18		      .byte.b	$10+(.LUM3/256)
     17  71fc
     18  71fc
     19  71fc
     20  71fc
     21  71fc
     22  71fc				   .LUM1      SET	.LUM1 + .STEP1
     23  71fc				   .LUM2      SET	.LUM2 + .STEP2
     24  71fc				   .LUM3      SET	.LUM3 + .STEP3
     13  71fc					      REPEND
     14  71fc		       66		      .byte.b	$60+(.LUM1/256)
     15  71fd		       84		      .byte.b	$80+(.LUM2/256)
     16  71fe		       18		      .byte.b	$10+(.LUM3/256)
     17  71ff
     18  71ff
     19  71ff
     20  71ff
     21  71ff
     22  71ff				   .LUM1      SET	.LUM1 + .STEP1
     23  71ff				   .LUM2      SET	.LUM2 + .STEP2
     24  71ff				   .LUM3      SET	.LUM3 + .STEP3
     13  71ff					      REPEND
     14  71ff		       66		      .byte.b	$60+(.LUM1/256)
     15  7200		       84		      .byte.b	$80+(.LUM2/256)
     16  7201		       18		      .byte.b	$10+(.LUM3/256)
     17  7202
     18  7202
     19  7202
     20  7202
     21  7202
     22  7202				   .LUM1      SET	.LUM1 + .STEP1
     23  7202				   .LUM2      SET	.LUM2 + .STEP2
     24  7202				   .LUM3      SET	.LUM3 + .STEP3
     13  7202					      REPEND
     14  7202		       66		      .byte.b	$60+(.LUM1/256)
     15  7203		       84		      .byte.b	$80+(.LUM2/256)
     16  7204		       18		      .byte.b	$10+(.LUM3/256)
     17  7205
     18  7205
     19  7205
     20  7205
     21  7205
     22  7205				   .LUM1      SET	.LUM1 + .STEP1
     23  7205				   .LUM2      SET	.LUM2 + .STEP2
     24  7205				   .LUM3      SET	.LUM3 + .STEP3
     13  7205					      REPEND
     14  7205		       66		      .byte.b	$60+(.LUM1/256)
     15  7206		       84		      .byte.b	$80+(.LUM2/256)
     16  7207		       18		      .byte.b	$10+(.LUM3/256)
     17  7208
     18  7208
     19  7208
     20  7208
     21  7208
     22  7208				   .LUM1      SET	.LUM1 + .STEP1
     23  7208				   .LUM2      SET	.LUM2 + .STEP2
     24  7208				   .LUM3      SET	.LUM3 + .STEP3
     13  7208					      REPEND
     14  7208		       66		      .byte.b	$60+(.LUM1/256)
     15  7209		       84		      .byte.b	$80+(.LUM2/256)
     16  720a		       18		      .byte.b	$10+(.LUM3/256)
     17  720b
     18  720b
     19  720b
     20  720b
     21  720b
     22  720b				   .LUM1      SET	.LUM1 + .STEP1
     23  720b				   .LUM2      SET	.LUM2 + .STEP2
     24  720b				   .LUM3      SET	.LUM3 + .STEP3
     13  720b					      REPEND
     14  720b		       66		      .byte.b	$60+(.LUM1/256)
     15  720c		       84		      .byte.b	$80+(.LUM2/256)
     16  720d		       18		      .byte.b	$10+(.LUM3/256)
     17  720e
     18  720e
     19  720e
     20  720e
     21  720e
     22  720e				   .LUM1      SET	.LUM1 + .STEP1
     23  720e				   .LUM2      SET	.LUM2 + .STEP2
     24  720e				   .LUM3      SET	.LUM3 + .STEP3
     13  720e					      REPEND
     14  720e		       66		      .byte.b	$60+(.LUM1/256)
     15  720f		       84		      .byte.b	$80+(.LUM2/256)
     16  7210		       18		      .byte.b	$10+(.LUM3/256)
     17  7211
     18  7211
     19  7211
     20  7211
     21  7211
     22  7211				   .LUM1      SET	.LUM1 + .STEP1
     23  7211				   .LUM2      SET	.LUM2 + .STEP2
     24  7211				   .LUM3      SET	.LUM3 + .STEP3
     13  7211					      REPEND
     14  7211		       66		      .byte.b	$60+(.LUM1/256)
     15  7212		       84		      .byte.b	$80+(.LUM2/256)
     16  7213		       18		      .byte.b	$10+(.LUM3/256)
     17  7214
     18  7214
     19  7214
     20  7214
     21  7214
     22  7214				   .LUM1      SET	.LUM1 + .STEP1
     23  7214				   .LUM2      SET	.LUM2 + .STEP2
     24  7214				   .LUM3      SET	.LUM3 + .STEP3
     13  7214					      REPEND
     14  7214		       66		      .byte.b	$60+(.LUM1/256)
     15  7215		       84		      .byte.b	$80+(.LUM2/256)
     16  7216		       18		      .byte.b	$10+(.LUM3/256)
     17  7217
     18  7217
     19  7217
     20  7217
     21  7217
     22  7217				   .LUM1      SET	.LUM1 + .STEP1
     23  7217				   .LUM2      SET	.LUM2 + .STEP2
     24  7217				   .LUM3      SET	.LUM3 + .STEP3
     13  7217					      REPEND
     14  7217		       66		      .byte.b	$60+(.LUM1/256)
     15  7218		       84		      .byte.b	$80+(.LUM2/256)
     16  7219		       18		      .byte.b	$10+(.LUM3/256)
     17  721a
     18  721a
     19  721a
     20  721a
     21  721a
     22  721a				   .LUM1      SET	.LUM1 + .STEP1
     23  721a				   .LUM2      SET	.LUM2 + .STEP2
     24  721a				   .LUM3      SET	.LUM3 + .STEP3
     13  721a					      REPEND
     14  721a		       66		      .byte.b	$60+(.LUM1/256)
     15  721b		       84		      .byte.b	$80+(.LUM2/256)
     16  721c		       18		      .byte.b	$10+(.LUM3/256)
     17  721d
     18  721d
     19  721d
     20  721d
     21  721d
     22  721d				   .LUM1      SET	.LUM1 + .STEP1
     23  721d				   .LUM2      SET	.LUM2 + .STEP2
     24  721d				   .LUM3      SET	.LUM3 + .STEP3
     13  721d					      REPEND
     14  721d		       66		      .byte.b	$60+(.LUM1/256)
     15  721e		       84		      .byte.b	$80+(.LUM2/256)
     16  721f		       18		      .byte.b	$10+(.LUM3/256)
     17  7220
     18  7220
     19  7220
     20  7220
     21  7220
     22  7220				   .LUM1      SET	.LUM1 + .STEP1
     23  7220				   .LUM2      SET	.LUM2 + .STEP2
     24  7220				   .LUM3      SET	.LUM3 + .STEP3
     13  7220					      REPEND
     14  7220		       66		      .byte.b	$60+(.LUM1/256)
     15  7221		       84		      .byte.b	$80+(.LUM2/256)
     16  7222		       18		      .byte.b	$10+(.LUM3/256)
     17  7223
     18  7223
     19  7223
     20  7223
     21  7223
     22  7223				   .LUM1      SET	.LUM1 + .STEP1
     23  7223				   .LUM2      SET	.LUM2 + .STEP2
     24  7223				   .LUM3      SET	.LUM3 + .STEP3
     13  7223					      REPEND
     14  7223		       66		      .byte.b	$60+(.LUM1/256)
     15  7224		       84		      .byte.b	$80+(.LUM2/256)
     16  7225		       18		      .byte.b	$10+(.LUM3/256)
     17  7226
     18  7226
     19  7226
     20  7226
     21  7226
     22  7226				   .LUM1      SET	.LUM1 + .STEP1
     23  7226				   .LUM2      SET	.LUM2 + .STEP2
     24  7226				   .LUM3      SET	.LUM3 + .STEP3
     13  7226					      REPEND
     14  7226		       66		      .byte.b	$60+(.LUM1/256)
     15  7227		       84		      .byte.b	$80+(.LUM2/256)
     16  7228		       18		      .byte.b	$10+(.LUM3/256)
     17  7229
     18  7229
     19  7229
     20  7229
     21  7229
     22  7229				   .LUM1      SET	.LUM1 + .STEP1
     23  7229				   .LUM2      SET	.LUM2 + .STEP2
     24  7229				   .LUM3      SET	.LUM3 + .STEP3
     13  7229					      REPEND
     14  7229		       66		      .byte.b	$60+(.LUM1/256)
     15  722a		       84		      .byte.b	$80+(.LUM2/256)
     16  722b		       18		      .byte.b	$10+(.LUM3/256)
     17  722c
     18  722c
     19  722c
     20  722c
     21  722c
     22  722c				   .LUM1      SET	.LUM1 + .STEP1
     23  722c				   .LUM2      SET	.LUM2 + .STEP2
     24  722c				   .LUM3      SET	.LUM3 + .STEP3
     13  722c					      REPEND
     14  722c		       66		      .byte.b	$60+(.LUM1/256)
     15  722d		       84		      .byte.b	$80+(.LUM2/256)
     16  722e		       18		      .byte.b	$10+(.LUM3/256)
     17  722f
     18  722f
     19  722f
     20  722f
     21  722f
     22  722f				   .LUM1      SET	.LUM1 + .STEP1
     23  722f				   .LUM2      SET	.LUM2 + .STEP2
     24  722f				   .LUM3      SET	.LUM3 + .STEP3
     13  722f					      REPEND
     14  722f		       66		      .byte.b	$60+(.LUM1/256)
     15  7230		       84		      .byte.b	$80+(.LUM2/256)
     16  7231		       18		      .byte.b	$10+(.LUM3/256)
     17  7232
     18  7232
     19  7232
     20  7232
     21  7232
     22  7232				   .LUM1      SET	.LUM1 + .STEP1
     23  7232				   .LUM2      SET	.LUM2 + .STEP2
     24  7232				   .LUM3      SET	.LUM3 + .STEP3
     13  7232					      REPEND
     14  7232		       66		      .byte.b	$60+(.LUM1/256)
     15  7233		       84		      .byte.b	$80+(.LUM2/256)
     16  7234		       18		      .byte.b	$10+(.LUM3/256)
     17  7235
     18  7235
     19  7235
     20  7235
     21  7235
     22  7235				   .LUM1      SET	.LUM1 + .STEP1
     23  7235				   .LUM2      SET	.LUM2 + .STEP2
     24  7235				   .LUM3      SET	.LUM3 + .STEP3
     13  7235					      REPEND
     14  7235		       66		      .byte.b	$60+(.LUM1/256)
     15  7236		       84		      .byte.b	$80+(.LUM2/256)
     16  7237		       18		      .byte.b	$10+(.LUM3/256)
     17  7238
     18  7238
     19  7238
     20  7238
     21  7238
     22  7238				   .LUM1      SET	.LUM1 + .STEP1
     23  7238				   .LUM2      SET	.LUM2 + .STEP2
     24  7238				   .LUM3      SET	.LUM3 + .STEP3
     13  7238					      REPEND
     14  7238		       66		      .byte.b	$60+(.LUM1/256)
     15  7239		       84		      .byte.b	$80+(.LUM2/256)
     16  723a		       18		      .byte.b	$10+(.LUM3/256)
     17  723b
     18  723b
     19  723b
     20  723b
     21  723b
     22  723b				   .LUM1      SET	.LUM1 + .STEP1
     23  723b				   .LUM2      SET	.LUM2 + .STEP2
     24  723b				   .LUM3      SET	.LUM3 + .STEP3
     13  723b					      REPEND
     14  723b		       66		      .byte.b	$60+(.LUM1/256)
     15  723c		       84		      .byte.b	$80+(.LUM2/256)
     16  723d		       18		      .byte.b	$10+(.LUM3/256)
     17  723e
     18  723e
     19  723e
     20  723e
     21  723e
     22  723e				   .LUM1      SET	.LUM1 + .STEP1
     23  723e				   .LUM2      SET	.LUM2 + .STEP2
     24  723e				   .LUM3      SET	.LUM3 + .STEP3
     13  723e					      REPEND
     14  723e		       66		      .byte.b	$60+(.LUM1/256)
     15  723f		       84		      .byte.b	$80+(.LUM2/256)
     16  7240		       18		      .byte.b	$10+(.LUM3/256)
     17  7241
     18  7241
     19  7241
     20  7241
     21  7241
     22  7241				   .LUM1      SET	.LUM1 + .STEP1
     23  7241				   .LUM2      SET	.LUM2 + .STEP2
     24  7241				   .LUM3      SET	.LUM3 + .STEP3
     13  7241					      REPEND
     14  7241		       66		      .byte.b	$60+(.LUM1/256)
     15  7242		       84		      .byte.b	$80+(.LUM2/256)
     16  7243		       18		      .byte.b	$10+(.LUM3/256)
     17  7244
     18  7244
     19  7244
     20  7244
     21  7244
     22  7244				   .LUM1      SET	.LUM1 + .STEP1
     23  7244				   .LUM2      SET	.LUM2 + .STEP2
     24  7244				   .LUM3      SET	.LUM3 + .STEP3
     13  7244					      REPEND
     14  7244		       66		      .byte.b	$60+(.LUM1/256)
     15  7245		       84		      .byte.b	$80+(.LUM2/256)
     16  7246		       18		      .byte.b	$10+(.LUM3/256)
     17  7247
     18  7247
     19  7247
     20  7247
     21  7247
     22  7247				   .LUM1      SET	.LUM1 + .STEP1
     23  7247				   .LUM2      SET	.LUM2 + .STEP2
     24  7247				   .LUM3      SET	.LUM3 + .STEP3
     13  7247					      REPEND
     14  7247		       66		      .byte.b	$60+(.LUM1/256)
     15  7248		       84		      .byte.b	$80+(.LUM2/256)
     16  7249		       18		      .byte.b	$10+(.LUM3/256)
     17  724a
     18  724a
     19  724a
     20  724a
     21  724a
     22  724a				   .LUM1      SET	.LUM1 + .STEP1
     23  724a				   .LUM2      SET	.LUM2 + .STEP2
     24  724a				   .LUM3      SET	.LUM3 + .STEP3
     13  724a					      REPEND
     14  724a		       66		      .byte.b	$60+(.LUM1/256)
     15  724b		       84		      .byte.b	$80+(.LUM2/256)
     16  724c		       18		      .byte.b	$10+(.LUM3/256)
     17  724d
     18  724d
     19  724d
     20  724d
     21  724d
     22  724d				   .LUM1      SET	.LUM1 + .STEP1
     23  724d				   .LUM2      SET	.LUM2 + .STEP2
     24  724d				   .LUM3      SET	.LUM3 + .STEP3
     13  724d					      REPEND
     14  724d		       66		      .byte.b	$60+(.LUM1/256)
     15  724e		       84		      .byte.b	$80+(.LUM2/256)
     16  724f		       18		      .byte.b	$10+(.LUM3/256)
     17  7250
     18  7250
     19  7250
     20  7250
     21  7250
     22  7250				   .LUM1      SET	.LUM1 + .STEP1
     23  7250				   .LUM2      SET	.LUM2 + .STEP2
     24  7250				   .LUM3      SET	.LUM3 + .STEP3
     13  7250					      REPEND
     14  7250		       66		      .byte.b	$60+(.LUM1/256)
     15  7251		       84		      .byte.b	$80+(.LUM2/256)
     16  7252		       18		      .byte.b	$10+(.LUM3/256)
     17  7253
     18  7253
     19  7253
     20  7253
     21  7253
     22  7253				   .LUM1      SET	.LUM1 + .STEP1
     23  7253				   .LUM2      SET	.LUM2 + .STEP2
     24  7253				   .LUM3      SET	.LUM3 + .STEP3
     13  7253					      REPEND
     14  7253		       66		      .byte.b	$60+(.LUM1/256)
     15  7254		       84		      .byte.b	$80+(.LUM2/256)
     16  7255		       18		      .byte.b	$10+(.LUM3/256)
     17  7256
     18  7256
     19  7256
     20  7256
     21  7256
     22  7256				   .LUM1      SET	.LUM1 + .STEP1
     23  7256				   .LUM2      SET	.LUM2 + .STEP2
     24  7256				   .LUM3      SET	.LUM3 + .STEP3
     13  7256					      REPEND
     14  7256		       66		      .byte.b	$60+(.LUM1/256)
     15  7257		       84		      .byte.b	$80+(.LUM2/256)
     16  7258		       18		      .byte.b	$10+(.LUM3/256)
     17  7259
     18  7259
     19  7259
     20  7259
     21  7259
     22  7259				   .LUM1      SET	.LUM1 + .STEP1
     23  7259				   .LUM2      SET	.LUM2 + .STEP2
     24  7259				   .LUM3      SET	.LUM3 + .STEP3
     13  7259					      REPEND
     14  7259		       66		      .byte.b	$60+(.LUM1/256)
     15  725a		       84		      .byte.b	$80+(.LUM2/256)
     16  725b		       18		      .byte.b	$10+(.LUM3/256)
     17  725c
     18  725c
     19  725c
     20  725c
     21  725c
     22  725c				   .LUM1      SET	.LUM1 + .STEP1
     23  725c				   .LUM2      SET	.LUM2 + .STEP2
     24  725c				   .LUM3      SET	.LUM3 + .STEP3
     13  725c					      REPEND
     14  725c		       66		      .byte.b	$60+(.LUM1/256)
     15  725d		       84		      .byte.b	$80+(.LUM2/256)
     16  725e		       18		      .byte.b	$10+(.LUM3/256)
     17  725f
     18  725f
     19  725f
     20  725f
     21  725f
     22  725f				   .LUM1      SET	.LUM1 + .STEP1
     23  725f				   .LUM2      SET	.LUM2 + .STEP2
     24  725f				   .LUM3      SET	.LUM3 + .STEP3
     13  725f					      REPEND
     14  725f		       66		      .byte.b	$60+(.LUM1/256)
     15  7260		       84		      .byte.b	$80+(.LUM2/256)
     16  7261		       18		      .byte.b	$10+(.LUM3/256)
     17  7262
     18  7262
     19  7262
     20  7262
     21  7262
     22  7262				   .LUM1      SET	.LUM1 + .STEP1
     23  7262				   .LUM2      SET	.LUM2 + .STEP2
     24  7262				   .LUM3      SET	.LUM3 + .STEP3
     13  7262					      REPEND
     14  7262		       66		      .byte.b	$60+(.LUM1/256)
     15  7263		       84		      .byte.b	$80+(.LUM2/256)
     16  7264		       18		      .byte.b	$10+(.LUM3/256)
     17  7265
     18  7265
     19  7265
     20  7265
     21  7265
     22  7265				   .LUM1      SET	.LUM1 + .STEP1
     23  7265				   .LUM2      SET	.LUM2 + .STEP2
     24  7265				   .LUM3      SET	.LUM3 + .STEP3
     13  7265					      REPEND
     14  7265		       66		      .byte.b	$60+(.LUM1/256)
     15  7266		       84		      .byte.b	$80+(.LUM2/256)
     16  7267		       18		      .byte.b	$10+(.LUM3/256)
     17  7268
     18  7268
     19  7268
     20  7268
     21  7268
     22  7268				   .LUM1      SET	.LUM1 + .STEP1
     23  7268				   .LUM2      SET	.LUM2 + .STEP2
     24  7268				   .LUM3      SET	.LUM3 + .STEP3
     13  7268					      REPEND
     14  7268		       66		      .byte.b	$60+(.LUM1/256)
     15  7269		       84		      .byte.b	$80+(.LUM2/256)
     16  726a		       18		      .byte.b	$10+(.LUM3/256)
     17  726b
     18  726b
     19  726b
     20  726b
     21  726b
     22  726b				   .LUM1      SET	.LUM1 + .STEP1
     23  726b				   .LUM2      SET	.LUM2 + .STEP2
     24  726b				   .LUM3      SET	.LUM3 + .STEP3
     13  726b					      REPEND
     14  726b		       66		      .byte.b	$60+(.LUM1/256)
     15  726c		       84		      .byte.b	$80+(.LUM2/256)
     16  726d		       18		      .byte.b	$10+(.LUM3/256)
     17  726e
     18  726e
     19  726e
     20  726e
     21  726e
     22  726e				   .LUM1      SET	.LUM1 + .STEP1
     23  726e				   .LUM2      SET	.LUM2 + .STEP2
     24  726e				   .LUM3      SET	.LUM3 + .STEP3
     13  726e					      REPEND
     14  726e		       66		      .byte.b	$60+(.LUM1/256)
     15  726f		       84		      .byte.b	$80+(.LUM2/256)
     16  7270		       18		      .byte.b	$10+(.LUM3/256)
     17  7271
     18  7271
     19  7271
     20  7271
     21  7271
     22  7271				   .LUM1      SET	.LUM1 + .STEP1
     23  7271				   .LUM2      SET	.LUM2 + .STEP2
     24  7271				   .LUM3      SET	.LUM3 + .STEP3
     13  7271					      REPEND
     14  7271		       66		      .byte.b	$60+(.LUM1/256)
     15  7272		       84		      .byte.b	$80+(.LUM2/256)
     16  7273		       18		      .byte.b	$10+(.LUM3/256)
     17  7274
     18  7274
     19  7274
     20  7274
     21  7274
     22  7274				   .LUM1      SET	.LUM1 + .STEP1
     23  7274				   .LUM2      SET	.LUM2 + .STEP2
     24  7274				   .LUM3      SET	.LUM3 + .STEP3
     13  7274					      REPEND
     14  7274		       66		      .byte.b	$60+(.LUM1/256)
     15  7275		       84		      .byte.b	$80+(.LUM2/256)
     16  7276		       18		      .byte.b	$10+(.LUM3/256)
     17  7277
     18  7277
     19  7277
     20  7277
     21  7277
     22  7277				   .LUM1      SET	.LUM1 + .STEP1
     23  7277				   .LUM2      SET	.LUM2 + .STEP2
     24  7277				   .LUM3      SET	.LUM3 + .STEP3
     13  7277					      REPEND
     14  7277		       66		      .byte.b	$60+(.LUM1/256)
     15  7278		       84		      .byte.b	$80+(.LUM2/256)
     16  7279		       18		      .byte.b	$10+(.LUM3/256)
     17  727a
     18  727a
     19  727a
     20  727a
     21  727a
     22  727a				   .LUM1      SET	.LUM1 + .STEP1
     23  727a				   .LUM2      SET	.LUM2 + .STEP2
     24  727a				   .LUM3      SET	.LUM3 + .STEP3
     13  727a					      REPEND
     14  727a		       66		      .byte.b	$60+(.LUM1/256)
     15  727b		       84		      .byte.b	$80+(.LUM2/256)
     16  727c		       18		      .byte.b	$10+(.LUM3/256)
     17  727d
     18  727d
     19  727d
     20  727d
     21  727d
     22  727d				   .LUM1      SET	.LUM1 + .STEP1
     23  727d				   .LUM2      SET	.LUM2 + .STEP2
     24  727d				   .LUM3      SET	.LUM3 + .STEP3
     13  727d					      REPEND
     14  727d		       66		      .byte.b	$60+(.LUM1/256)
     15  727e		       84		      .byte.b	$80+(.LUM2/256)
     16  727f		       18		      .byte.b	$10+(.LUM3/256)
     17  7280
     18  7280
     19  7280
     20  7280
     21  7280
     22  7280				   .LUM1      SET	.LUM1 + .STEP1
     23  7280				   .LUM2      SET	.LUM2 + .STEP2
     24  7280				   .LUM3      SET	.LUM3 + .STEP3
     13  7280					      REPEND
     14  7280		       66		      .byte.b	$60+(.LUM1/256)
     15  7281		       84		      .byte.b	$80+(.LUM2/256)
     16  7282		       18		      .byte.b	$10+(.LUM3/256)
     17  7283
     18  7283
     19  7283
     20  7283
     21  7283
     22  7283				   .LUM1      SET	.LUM1 + .STEP1
     23  7283				   .LUM2      SET	.LUM2 + .STEP2
     24  7283				   .LUM3      SET	.LUM3 + .STEP3
     13  7283					      REPEND
     14  7283		       66		      .byte.b	$60+(.LUM1/256)
     15  7284		       84		      .byte.b	$80+(.LUM2/256)
     16  7285		       18		      .byte.b	$10+(.LUM3/256)
     17  7286
     18  7286
     19  7286
     20  7286
     21  7286
     22  7286				   .LUM1      SET	.LUM1 + .STEP1
     23  7286				   .LUM2      SET	.LUM2 + .STEP2
     24  7286				   .LUM3      SET	.LUM3 + .STEP3
     13  7286					      REPEND
     14  7286		       66		      .byte.b	$60+(.LUM1/256)
     15  7287		       84		      .byte.b	$80+(.LUM2/256)
     16  7288		       18		      .byte.b	$10+(.LUM3/256)
     17  7289
     18  7289
     19  7289
     20  7289
     21  7289
     22  7289				   .LUM1      SET	.LUM1 + .STEP1
     23  7289				   .LUM2      SET	.LUM2 + .STEP2
     24  7289				   .LUM3      SET	.LUM3 + .STEP3
     13  7289					      REPEND
     14  7289		       66		      .byte.b	$60+(.LUM1/256)
     15  728a		       84		      .byte.b	$80+(.LUM2/256)
     16  728b		       18		      .byte.b	$10+(.LUM3/256)
     17  728c
     18  728c
     19  728c
     20  728c
     21  728c
     22  728c				   .LUM1      SET	.LUM1 + .STEP1
     23  728c				   .LUM2      SET	.LUM2 + .STEP2
     24  728c				   .LUM3      SET	.LUM3 + .STEP3
     13  728c					      REPEND
     14  728c		       66		      .byte.b	$60+(.LUM1/256)
     15  728d		       84		      .byte.b	$80+(.LUM2/256)
     16  728e		       18		      .byte.b	$10+(.LUM3/256)
     17  728f
     18  728f
     19  728f
     20  728f
     21  728f
     22  728f				   .LUM1      SET	.LUM1 + .STEP1
     23  728f				   .LUM2      SET	.LUM2 + .STEP2
     24  728f				   .LUM3      SET	.LUM3 + .STEP3
     13  728f					      REPEND
     14  728f		       66		      .byte.b	$60+(.LUM1/256)
     15  7290		       84		      .byte.b	$80+(.LUM2/256)
     16  7291		       18		      .byte.b	$10+(.LUM3/256)
     17  7292
     18  7292
     19  7292
     20  7292
     21  7292
     22  7292				   .LUM1      SET	.LUM1 + .STEP1
     23  7292				   .LUM2      SET	.LUM2 + .STEP2
     24  7292				   .LUM3      SET	.LUM3 + .STEP3
     13  7292					      REPEND
     14  7292		       66		      .byte.b	$60+(.LUM1/256)
     15  7293		       84		      .byte.b	$80+(.LUM2/256)
     16  7294		       18		      .byte.b	$10+(.LUM3/256)
     17  7295
     18  7295
     19  7295
     20  7295
     21  7295
     22  7295				   .LUM1      SET	.LUM1 + .STEP1
     23  7295				   .LUM2      SET	.LUM2 + .STEP2
     24  7295				   .LUM3      SET	.LUM3 + .STEP3
     13  7295					      REPEND
     14  7295		       66		      .byte.b	$60+(.LUM1/256)
     15  7296		       84		      .byte.b	$80+(.LUM2/256)
     16  7297		       18		      .byte.b	$10+(.LUM3/256)
     17  7298
     18  7298
     19  7298
     20  7298
     21  7298
     22  7298				   .LUM1      SET	.LUM1 + .STEP1
     23  7298				   .LUM2      SET	.LUM2 + .STEP2
     24  7298				   .LUM3      SET	.LUM3 + .STEP3
     13  7298					      REPEND
     14  7298		       66		      .byte.b	$60+(.LUM1/256)
     15  7299		       84		      .byte.b	$80+(.LUM2/256)
     16  729a		       18		      .byte.b	$10+(.LUM3/256)
     17  729b
     18  729b
     19  729b
     20  729b
     21  729b
     22  729b				   .LUM1      SET	.LUM1 + .STEP1
     23  729b				   .LUM2      SET	.LUM2 + .STEP2
     24  729b				   .LUM3      SET	.LUM3 + .STEP3
     13  729b					      REPEND
     14  729b		       66		      .byte.b	$60+(.LUM1/256)
     15  729c		       84		      .byte.b	$80+(.LUM2/256)
     16  729d		       18		      .byte.b	$10+(.LUM3/256)
     17  729e
     18  729e
     19  729e
     20  729e
     21  729e
     22  729e				   .LUM1      SET	.LUM1 + .STEP1
     23  729e				   .LUM2      SET	.LUM2 + .STEP2
     24  729e				   .LUM3      SET	.LUM3 + .STEP3
     13  729e					      REPEND
     14  729e		       66		      .byte.b	$60+(.LUM1/256)
     15  729f		       84		      .byte.b	$80+(.LUM2/256)
     16  72a0		       18		      .byte.b	$10+(.LUM3/256)
     17  72a1
     18  72a1
     19  72a1
     20  72a1
     21  72a1
     22  72a1				   .LUM1      SET	.LUM1 + .STEP1
     23  72a1				   .LUM2      SET	.LUM2 + .STEP2
     24  72a1				   .LUM3      SET	.LUM3 + .STEP3
     13  72a1					      REPEND
     14  72a1		       66		      .byte.b	$60+(.LUM1/256)
     15  72a2		       84		      .byte.b	$80+(.LUM2/256)
     16  72a3		       18		      .byte.b	$10+(.LUM3/256)
     17  72a4
     18  72a4
     19  72a4
     20  72a4
     21  72a4
     22  72a4				   .LUM1      SET	.LUM1 + .STEP1
     23  72a4				   .LUM2      SET	.LUM2 + .STEP2
     24  72a4				   .LUM3      SET	.LUM3 + .STEP3
     13  72a4					      REPEND
     14  72a4		       66		      .byte.b	$60+(.LUM1/256)
     15  72a5		       84		      .byte.b	$80+(.LUM2/256)
     16  72a6		       18		      .byte.b	$10+(.LUM3/256)
     17  72a7
     18  72a7
     19  72a7
     20  72a7
     21  72a7
     22  72a7				   .LUM1      SET	.LUM1 + .STEP1
     23  72a7				   .LUM2      SET	.LUM2 + .STEP2
     24  72a7				   .LUM3      SET	.LUM3 + .STEP3
     13  72a7					      REPEND
     14  72a7		       66		      .byte.b	$60+(.LUM1/256)
     15  72a8		       84		      .byte.b	$80+(.LUM2/256)
     16  72a9		       18		      .byte.b	$10+(.LUM3/256)
     17  72aa
     18  72aa
     19  72aa
     20  72aa
     21  72aa
     22  72aa				   .LUM1      SET	.LUM1 + .STEP1
     23  72aa				   .LUM2      SET	.LUM2 + .STEP2
     24  72aa				   .LUM3      SET	.LUM3 + .STEP3
     13  72aa					      REPEND
     14  72aa		       66		      .byte.b	$60+(.LUM1/256)
     15  72ab		       84		      .byte.b	$80+(.LUM2/256)
     16  72ac		       18		      .byte.b	$10+(.LUM3/256)
     17  72ad
     18  72ad
     19  72ad
     20  72ad
     21  72ad
     22  72ad				   .LUM1      SET	.LUM1 + .STEP1
     23  72ad				   .LUM2      SET	.LUM2 + .STEP2
     24  72ad				   .LUM3      SET	.LUM3 + .STEP3
     13  72ad					      REPEND
     14  72ad		       66		      .byte.b	$60+(.LUM1/256)
     15  72ae		       84		      .byte.b	$80+(.LUM2/256)
     16  72af		       18		      .byte.b	$10+(.LUM3/256)
     17  72b0
     18  72b0
     19  72b0
     20  72b0
     21  72b0
     22  72b0				   .LUM1      SET	.LUM1 + .STEP1
     23  72b0				   .LUM2      SET	.LUM2 + .STEP2
     24  72b0				   .LUM3      SET	.LUM3 + .STEP3
     25  72b0					      REPEND
    343  72b0							;colr_pal	  LUMTABLE $90, $20, $60, $6,$A,$a,$C,$6,$8
    344  72b0
    345  72b0
    346  72b0							;---------------------------------------------------------------------------------------------------
    347  72b0
      0  72b0					      END_BANK
      1  72b0				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  72b0				  -	      CHECK_RAM_BANK_SIZE
      3  72b0					      ELSE
      0  72b0					      CHECK_BANK_SIZE
      1  72b0		       02 b0	   .TEMP      =	* - _BANK_START
 ROM bank # 29 TITLESCREEN size = $2b0 free = 335
      2  72b0					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  72b0				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  72b0				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  72b0				  -	      ERR
      6  72b0					      ENDIF
      5  72b0					      ENDIF
    349  72b0
    350  72b0							;---------------------------------------------------------------------------------------------------
    351  72b0							;EOF
------- FILE ./chess.asm
------- FILE TitleScreen@2.asm LEVEL 2 PASS 4
      0  72b0					      include	"TitleScreen@2.asm"
      0  72b0					      SLOT	2
      1  72b0
      2  72b0				  -	      IF	(2 < 0) || (2 > 3)
      3  72b0				  -	      ECHO	"Illegal bank address/segment location", 2
      4  72b0				  -	      ERR
      5  72b0					      ENDIF
      6  72b0
      7  72b0				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  72b0				   _BANK_SLOT SET	2 * 64
      9  72b0
      0  72b0					      ROMBANK	TITLEDATA2
      1  7800 ????				      SEG	ROM_TITLEDATA2
      2  7400					      ORG	_ORIGIN
      3  7400					      RORG	_BANK_ADDRESS_ORIGIN
      4  7400				   _BANK_START SET	*
      5  7400				   TITLEDATA2_START SET	*
      6  7400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  7400				   ROMBANK_TITLEDATA2 SET	_BANK_SLOT + _CURRENT_BANK
      8  7400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  7400				   _LAST_BANK SETSTR	TITLEDATA2
     10  7400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
      3  7400
      0  7400					      DEF	TitleData
      1  7400				   SLOT_TitleData SET	_BANK_SLOT
      2  7400				   BANK_TitleData SET	SLOT_TitleData + _CURRENT_BANK
      3  7400				   TitleData
      4  7400				   TEMPORARY_VAR SET	Overlay
      5  7400				   TEMPORARY_OFFSET SET	0
      6  7400				   VAR_BOUNDARY_TitleData SET	TEMPORARY_OFFSET
      7  7400				   FUNCTION_NAME SET	TitleData
------- FILE titleData.asm LEVEL 3 PASS 4
      0  7400					      include	"titleData.asm"
      1  7400				   COL_0
      2  7400		       07		      .byte.b	7	;R (67)
      3  7401		       06		      .byte.b	6	;G
      4  7402		       00		      .byte.b	0	;B
      5  7403		       02		      .byte.b	2	;R (66)
      6  7404		       00		      .byte.b	0	;G
      7  7405		       00		      .byte.b	0	;B
      8  7406		       00		      .byte.b	0	;R (65)
      9  7407		       00		      .byte.b	0	;G
     10  7408		       0b		      .byte.b	11	;B
     11  7409		       00		      .byte.b	0	;R (64)
     12  740a		       00		      .byte.b	0	;G
     13  740b		       00		      .byte.b	0	;B
     14  740c		       00		      .byte.b	0	;R (63)
     15  740d		       00		      .byte.b	0	;G
     16  740e		       0b		      .byte.b	11	;B
     17  740f		       00		      .byte.b	0	;R (62)
     18  7410		       00		      .byte.b	0	;G
     19  7411		       08		      .byte.b	8	;B
     20  7412		       00		      .byte.b	0	;R (61)
     21  7413		       00		      .byte.b	0	;G
     22  7414		       0b		      .byte.b	11	;B
     23  7415		       00		      .byte.b	0	;R (60)
     24  7416		       00		      .byte.b	0	;G
     25  7417		       00		      .byte.b	0	;B
     26  7418		       00		      .byte.b	0	;R (59)
     27  7419		       00		      .byte.b	0	;G
     28  741a		       00		      .byte.b	0	;B
     29  741b		       04		      .byte.b	4	;R (58)
     30  741c		       04		      .byte.b	4	;G
     31  741d		       00		      .byte.b	0	;B
     32  741e		       0f		      .byte.b	15	;R (57)
     33  741f		       00		      .byte.b	0	;G
     34  7420		       00		      .byte.b	0	;B
     35  7421		       0f		      .byte.b	15	;R (56)
     36  7422		       00		      .byte.b	0	;G
     37  7423		       00		      .byte.b	0	;B
     38  7424		       8f		      .byte.b	143	;R (55)
     39  7425		       80		      .byte.b	128	;G
     40  7426		       00		      .byte.b	0	;B
     41  7427		       8f		      .byte.b	143	;R (54)
     42  7428		       00		      .byte.b	0	;G
     43  7429		       00		      .byte.b	0	;B
     44  742a		       cf		      .byte.b	207	;R (53)
     45  742b		       40		      .byte.b	64	;G
     46  742c		       00		      .byte.b	0	;B
     47  742d		       0f		      .byte.b	15	;R (52)
     48  742e		       00		      .byte.b	0	;G
     49  742f		       00		      .byte.b	0	;B
     50  7430		       0f		      .byte.b	15	;R (51)
     51  7431		       00		      .byte.b	0	;G
     52  7432		       00		      .byte.b	0	;B
     53  7433		       0f		      .byte.b	15	;R (50)
     54  7434		       00		      .byte.b	0	;G
     55  7435		       00		      .byte.b	0	;B
     56  7436		       0f		      .byte.b	15	;R (49)
     57  7437		       08		      .byte.b	8	;G
     58  7438		       00		      .byte.b	0	;B
     59  7439		       07		      .byte.b	7	;R (48)
     60  743a		       00		      .byte.b	0	;G
     61  743b		       00		      .byte.b	0	;B
     62  743c		       07		      .byte.b	7	;R (47)
     63  743d		       00		      .byte.b	0	;G
     64  743e		       00		      .byte.b	0	;B
     65  743f		       07		      .byte.b	7	;R (46)
     66  7440		       00		      .byte.b	0	;G
     67  7441		       00		      .byte.b	0	;B
     68  7442		       07		      .byte.b	7	;R (45)
     69  7443		       00		      .byte.b	0	;G
     70  7444		       00		      .byte.b	0	;B
     71  7445		       07		      .byte.b	7	;R (44)
     72  7446		       00		      .byte.b	0	;G
     73  7447		       00		      .byte.b	0	;B
     74  7448		       07		      .byte.b	7	;R (43)
     75  7449		       00		      .byte.b	0	;G
     76  744a		       00		      .byte.b	0	;B
     77  744b		       8f		      .byte.b	143	;R (42)
     78  744c		       88		      .byte.b	136	;G
     79  744d		       00		      .byte.b	0	;B
     80  744e		       cf		      .byte.b	207	;R (41)
     81  744f		       40		      .byte.b	64	;G
     82  7450		       00		      .byte.b	0	;B
     83  7451		       0f		      .byte.b	15	;R (40)
     84  7452		       00		      .byte.b	0	;G
     85  7453		       00		      .byte.b	0	;B
     86  7454		       0f		      .byte.b	15	;R (39)
     87  7455		       00		      .byte.b	0	;G
     88  7456		       00		      .byte.b	0	;B
     89  7457		       0f		      .byte.b	15	;R (38)
     90  7458		       02		      .byte.b	2	;G
     91  7459		       00		      .byte.b	0	;B
     92  745a		       cf		      .byte.b	207	;R (37)
     93  745b		       c0		      .byte.b	192	;G
     94  745c		       00		      .byte.b	0	;B
     95  745d		       ef		      .byte.b	239	;R (36)
     96  745e		       a0		      .byte.b	160	;G
     97  745f		       00		      .byte.b	0	;B
     98  7460		       ef		      .byte.b	239	;R (35)
     99  7461		       ea		      .byte.b	234	;G
    100  7462		       00		      .byte.b	0	;B
    101  7463		       6f		      .byte.b	111	;R (34)
    102  7464		       40		      .byte.b	64	;G
    103  7465		       00		      .byte.b	0	;B
    104  7466		       0f		      .byte.b	15	;R (33)
    105  7467		       0a		      .byte.b	10	;G
    106  7468		       00		      .byte.b	0	;B
    107  7469		       0f		      .byte.b	15	;R (32)
    108  746a		       00		      .byte.b	0	;G
    109  746b		       00		      .byte.b	0	;B
    110  746c		       4f		      .byte.b	79	;R (31)
    111  746d		       41		      .byte.b	65	;G
    112  746e		       00		      .byte.b	0	;B
    113  746f		       67		      .byte.b	103	;R (30)
    114  7470		       63		      .byte.b	99	;G
    115  7471		       08		      .byte.b	8	;B
    116  7472		       6f		      .byte.b	111	;R (29)
    117  7473		       41		      .byte.b	65	;G
    118  7474		       00		      .byte.b	0	;B
    119  7475		       af		      .byte.b	175	;R (28)
    120  7476		       89		      .byte.b	137	;G
    121  7477		       00		      .byte.b	0	;B
    122  7478		       3f		      .byte.b	63	;R (27)
    123  7479		       33		      .byte.b	51	;G
    124  747a		       00		      .byte.b	0	;B
    125  747b		       0f		      .byte.b	15	;R (26)
    126  747c		       01		      .byte.b	1	;G
    127  747d		       00		      .byte.b	0	;B
    128  747e		       cd		      .byte.b	205	;R (25)
    129  747f		       c9		      .byte.b	201	;G
    130  7480		       02		      .byte.b	2	;B
    131  7481		       cf		      .byte.b	207	;R (24)
    132  7482		       81		      .byte.b	129	;G
    133  7483		       00		      .byte.b	0	;B
    134  7484		       ef		      .byte.b	239	;R (23)
    135  7485		       e5		      .byte.b	229	;G
    136  7486		       00		      .byte.b	0	;B
    137  7487		       4f		      .byte.b	79	;R (22)
    138  7488		       01		      .byte.b	1	;G
    139  7489		       00		      .byte.b	0	;B
    140  748a		       4f		      .byte.b	79	;R (21)
    141  748b		       40		      .byte.b	64	;G
    142  748c		       00		      .byte.b	0	;B
    143  748d		       8f		      .byte.b	143	;R (20)
    144  748e		       8e		      .byte.b	142	;G
    145  748f		       00		      .byte.b	0	;B
    146  7490		       87		      .byte.b	135	;R (19)
    147  7491		       84		      .byte.b	132	;G
    148  7492		       00		      .byte.b	0	;B
    149  7493		       87		      .byte.b	135	;R (18)
    150  7494		       04		      .byte.b	4	;G
    151  7495		       00		      .byte.b	0	;B
    152  7496		       8f		      .byte.b	143	;R (17)
    153  7497		       0e		      .byte.b	14	;G
    154  7498		       00		      .byte.b	0	;B
    155  7499		       8a		      .byte.b	138	;R (16)
    156  749a		       8a		      .byte.b	138	;G
    157  749b		       00		      .byte.b	0	;B
    158  749c		       06		      .byte.b	6	;R (15)
    159  749d		       06		      .byte.b	6	;G
    160  749e		       00		      .byte.b	0	;B
    161  749f		       02		      .byte.b	2	;R (14)
    162  74a0		       02		      .byte.b	2	;G
    163  74a1		       00		      .byte.b	0	;B
    164  74a2		       00		      .byte.b	0	;R (13)
    165  74a3		       00		      .byte.b	0	;G
    166  74a4		       00		      .byte.b	0	;B
    167  74a5		       00		      .byte.b	0	;R (12)
    168  74a6		       00		      .byte.b	0	;G
    169  74a7		       00		      .byte.b	0	;B
    170  74a8		       00		      .byte.b	0	;R (11)
    171  74a9		       00		      .byte.b	0	;G
    172  74aa		       00		      .byte.b	0	;B
    173  74ab		       00		      .byte.b	0	;R (10)
    174  74ac		       00		      .byte.b	0	;G
    175  74ad		       00		      .byte.b	0	;B
    176  74ae		       00		      .byte.b	0	;R (9)
    177  74af		       00		      .byte.b	0	;G
    178  74b0		       00		      .byte.b	0	;B
    179  74b1		       00		      .byte.b	0	;R (8)
    180  74b2		       00		      .byte.b	0	;G
    181  74b3		       07		      .byte.b	7	;B
    182  74b4		       00		      .byte.b	0	;R (7)
    183  74b5		       00		      .byte.b	0	;G
    184  74b6		       05		      .byte.b	5	;B
    185  74b7		       00		      .byte.b	0	;R (6)
    186  74b8		       00		      .byte.b	0	;G
    187  74b9		       05		      .byte.b	5	;B
    188  74ba		       00		      .byte.b	0	;R (5)
    189  74bb		       00		      .byte.b	0	;G
    190  74bc		       05		      .byte.b	5	;B
    191  74bd		       00		      .byte.b	0	;R (4)
    192  74be		       00		      .byte.b	0	;G
    193  74bf		       05		      .byte.b	5	;B
    194  74c0		       00		      .byte.b	0	;R (3)
    195  74c1		       00		      .byte.b	0	;G
    196  74c2		       07		      .byte.b	7	;B
    197  74c3		       00		      .byte.b	0	;R (2)
    198  74c4		       00		      .byte.b	0	;G
    199  74c5		       00		      .byte.b	0	;B
    200  74c6		       00		      .byte.b	0	;R (1)
    201  74c7		       00		      .byte.b	0	;G
    202  74c8		       00		      .byte.b	0	;B
    203  74c9		       00		      .byte.b	0	;R (0)
    204  74ca		       00		      .byte.b	0	;G
    205  74cb		       00		      .byte.b	0	;B
    206  74cc				   COL_1
    207  74cc		       00		      .byte.b	0	;R (67)
    208  74cd		       00		      .byte.b	0	;G
    209  74ce		       00		      .byte.b	0	;B
    210  74cf		       00		      .byte.b	0	;R (66)
    211  74d0		       00		      .byte.b	0	;G
    212  74d1		       00		      .byte.b	0	;B
    213  74d2		       04		      .byte.b	4	;R (65)
    214  74d3		       00		      .byte.b	0	;G
    215  74d4		       00		      .byte.b	0	;B
    216  74d5		       1c		      .byte.b	28	;R (64)
    217  74d6		       18		      .byte.b	24	;G
    218  74d7		       01		      .byte.b	1	;B
    219  74d8		       3c		      .byte.b	60	;R (63)
    220  74d9		       30		      .byte.b	48	;G
    221  74da		       01		      .byte.b	1	;B
    222  74db		       1c		      .byte.b	28	;R (62)
    223  74dc		       00		      .byte.b	0	;G
    224  74dd		       01		      .byte.b	1	;B
    225  74de		       1c		      .byte.b	28	;R (61)
    226  74df		       04		      .byte.b	4	;G
    227  74e0		       21		      .byte.b	33	;B
    228  74e1		       1c		      .byte.b	28	;R (60)
    229  74e2		       08		      .byte.b	8	;G
    230  74e3		       01		      .byte.b	1	;B
    231  74e4		       1c		      .byte.b	28	;R (59)
    232  74e5		       00		      .byte.b	0	;G
    233  74e6		       00		      .byte.b	0	;B
    234  74e7		       1b		      .byte.b	27	;R (58)
    235  74e8		       0b		      .byte.b	11	;G
    236  74e9		       04		      .byte.b	4	;B
    237  74ea		       1f		      .byte.b	31	;R (57)
    238  74eb		       1d		      .byte.b	29	;G
    239  74ec		       00		      .byte.b	0	;B
    240  74ed		       df		      .byte.b	223	;R (56)
    241  74ee		       d2		      .byte.b	210	;G
    242  74ef		       20		      .byte.b	32	;B
    243  74f0		       ff		      .byte.b	255	;R (55)
    244  74f1		       3c		      .byte.b	60	;G
    245  74f2		       00		      .byte.b	0	;B
    246  74f3		       ff		      .byte.b	255	;R (54)
    247  74f4		       4f		      .byte.b	79	;G
    248  74f5		       00		      .byte.b	0	;B
    249  74f6		       ff		      .byte.b	255	;R (53)
    250  74f7		       93		      .byte.b	147	;G
    251  74f8		       00		      .byte.b	0	;B
    252  74f9		       1f		      .byte.b	31	;R (52)
    253  74fa		       1f		      .byte.b	31	;G
    254  74fb		       00		      .byte.b	0	;B
    255  74fc		       00		      .byte.b	0	;R (51)
    256  74fd		       00		      .byte.b	0	;G
    257  74fe		       00		      .byte.b	0	;B
    258  74ff		       00		      .byte.b	0	;R (50)
    259  7500		       00		      .byte.b	0	;G
    260  7501		       00		      .byte.b	0	;B
    261  7502		       1a		      .byte.b	26	;R (49)
    262  7503		       1a		      .byte.b	26	;G
    263  7504		       00		      .byte.b	0	;B
    264  7505		       38		      .byte.b	56	;R (48)
    265  7506		       28		      .byte.b	40	;G
    266  7507		       00		      .byte.b	0	;B
    267  7508		       71		      .byte.b	113	;R (47)
    268  7509		       51		      .byte.b	81	;G
    269  750a		       00		      .byte.b	0	;B
    270  750b		       0b		      .byte.b	11	;R (46)
    271  750c		       0b		      .byte.b	11	;G
    272  750d		       00		      .byte.b	0	;B
    273  750e		       03		      .byte.b	3	;R (45)
    274  750f		       03		      .byte.b	3	;G
    275  7510		       00		      .byte.b	0	;B
    276  7511		       ca		      .byte.b	202	;R (44)
    277  7512		       ca		      .byte.b	202	;G
    278  7513		       00		      .byte.b	0	;B
    279  7514		       c8		      .byte.b	200	;R (43)
    280  7515		       c8		      .byte.b	200	;G
    281  7516		       00		      .byte.b	0	;B
    282  7517		       c8		      .byte.b	200	;R (42)
    283  7518		       40		      .byte.b	64	;G
    284  7519		       00		      .byte.b	0	;B
    285  751a		       48		      .byte.b	72	;R (41)
    286  751b		       40		      .byte.b	64	;G
    287  751c		       00		      .byte.b	0	;B
    288  751d		       08		      .byte.b	8	;R (40)
    289  751e		       08		      .byte.b	8	;G
    290  751f		       00		      .byte.b	0	;B
    291  7520		       a0		      .byte.b	160	;R (39)
    292  7521		       a0		      .byte.b	160	;G
    293  7522		       00		      .byte.b	0	;B
    294  7523		       20		      .byte.b	32	;R (38)
    295  7524		       00		      .byte.b	0	;G
    296  7525		       00		      .byte.b	0	;B
    297  7526		       20		      .byte.b	32	;R (37)
    298  7527		       00		      .byte.b	0	;G
    299  7528		       00		      .byte.b	0	;B
    300  7529		       20		      .byte.b	32	;R (36)
    301  752a		       20		      .byte.b	32	;G
    302  752b		       00		      .byte.b	0	;B
    303  752c		       40		      .byte.b	64	;R (35)
    304  752d		       40		      .byte.b	64	;G
    305  752e		       00		      .byte.b	0	;B
    306  752f		       c0		      .byte.b	192	;R (34)
    307  7530		       c0		      .byte.b	192	;G
    308  7531		       00		      .byte.b	0	;B
    309  7532		       40		      .byte.b	64	;R (33)
    310  7533		       00		      .byte.b	0	;G
    311  7534		       00		      .byte.b	0	;B
    312  7535		       40		      .byte.b	64	;R (32)
    313  7536		       40		      .byte.b	64	;G
    314  7537		       00		      .byte.b	0	;B
    315  7538		       00		      .byte.b	0	;R (31)
    316  7539		       00		      .byte.b	0	;G
    317  753a		       00		      .byte.b	0	;B
    318  753b		       80		      .byte.b	128	;R (30)
    319  753c		       80		      .byte.b	128	;G
    320  753d		       00		      .byte.b	0	;B
    321  753e		       c0		      .byte.b	192	;R (29)
    322  753f		       40		      .byte.b	64	;G
    323  7540		       00		      .byte.b	0	;B
    324  7541		       c0		      .byte.b	192	;R (28)
    325  7542		       c0		      .byte.b	192	;G
    326  7543		       00		      .byte.b	0	;B
    327  7544		       40		      .byte.b	64	;R (27)
    328  7545		       40		      .byte.b	64	;G
    329  7546		       00		      .byte.b	0	;B
    330  7547		       00		      .byte.b	0	;R (26)
    331  7548		       00		      .byte.b	0	;G
    332  7549		       00		      .byte.b	0	;B
    333  754a		       00		      .byte.b	0	;R (25)
    334  754b		       00		      .byte.b	0	;G
    335  754c		       00		      .byte.b	0	;B
    336  754d		       60		      .byte.b	96	;R (24)
    337  754e		       20		      .byte.b	32	;G
    338  754f		       00		      .byte.b	0	;B
    339  7550		       60		      .byte.b	96	;R (23)
    340  7551		       60		      .byte.b	96	;G
    341  7552		       00		      .byte.b	0	;B
    342  7553		       00		      .byte.b	0	;R (22)
    343  7554		       00		      .byte.b	0	;G
    344  7555		       00		      .byte.b	0	;B
    345  7556		       a0		      .byte.b	160	;R (21)
    346  7557		       a0		      .byte.b	160	;G
    347  7558		       00		      .byte.b	0	;B
    348  7559		       70		      .byte.b	112	;R (20)
    349  755a		       50		      .byte.b	80	;G
    350  755b		       00		      .byte.b	0	;B
    351  755c		       c0		      .byte.b	192	;R (19)
    352  755d		       c0		      .byte.b	192	;G
    353  755e		       00		      .byte.b	0	;B
    354  755f		       80		      .byte.b	128	;R (18)
    355  7560		       80		      .byte.b	128	;G
    356  7561		       00		      .byte.b	0	;B
    357  7562		       4c		      .byte.b	76	;R (17)
    358  7563		       4c		      .byte.b	76	;G
    359  7564		       00		      .byte.b	0	;B
    360  7565		       5c		      .byte.b	92	;R (16)
    361  7566		       1c		      .byte.b	28	;G
    362  7567		       00		      .byte.b	0	;B
    363  7568		       60		      .byte.b	96	;R (15)
    364  7569		       60		      .byte.b	96	;G
    365  756a		       00		      .byte.b	0	;B
    366  756b		       60		      .byte.b	96	;R (14)
    367  756c		       20		      .byte.b	32	;G
    368  756d		       00		      .byte.b	0	;B
    369  756e		       50		      .byte.b	80	;R (13)
    370  756f		       50		      .byte.b	80	;G
    371  7570		       06		      .byte.b	6	;B
    372  7571		       40		      .byte.b	64	;R (12)
    373  7572		       40		      .byte.b	64	;G
    374  7573		       08		      .byte.b	8	;B
    375  7574		       00		      .byte.b	0	;R (11)
    376  7575		       00		      .byte.b	0	;G
    377  7576		       08		      .byte.b	8	;B
    378  7577		       00		      .byte.b	0	;R (10)
    379  7578		       00		      .byte.b	0	;G
    380  7579		       08		      .byte.b	8	;B
    381  757a		       00		      .byte.b	0	;R (9)
    382  757b		       00		      .byte.b	0	;G
    383  757c		       08		      .byte.b	8	;B
    384  757d		       00		      .byte.b	0	;R (8)
    385  757e		       00		      .byte.b	0	;G
    386  757f		       06		      .byte.b	6	;B
    387  7580		       00		      .byte.b	0	;R (7)
    388  7581		       00		      .byte.b	0	;G
    389  7582		       00		      .byte.b	0	;B
    390  7583		       00		      .byte.b	0	;R (6)
    391  7584		       00		      .byte.b	0	;G
    392  7585		       00		      .byte.b	0	;B
    393  7586		       00		      .byte.b	0	;R (5)
    394  7587		       00		      .byte.b	0	;G
    395  7588		       00		      .byte.b	0	;B
    396  7589		       00		      .byte.b	0	;R (4)
    397  758a		       00		      .byte.b	0	;G
    398  758b		       00		      .byte.b	0	;B
    399  758c		       00		      .byte.b	0	;R (3)
    400  758d		       00		      .byte.b	0	;G
    401  758e		       00		      .byte.b	0	;B
    402  758f		       00		      .byte.b	0	;R (2)
    403  7590		       00		      .byte.b	0	;G
    404  7591		       00		      .byte.b	0	;B
    405  7592		       00		      .byte.b	0	;R (1)
    406  7593		       00		      .byte.b	0	;G
    407  7594		       00		      .byte.b	0	;B
    408  7595		       00		      .byte.b	0	;R (0)
    409  7596		       00		      .byte.b	0	;G
    410  7597		       00		      .byte.b	0	;B
    411  7598				   COL_2
    412  7598		       f0		      .byte.b	240	;R (67)
    413  7599		       f0		      .byte.b	240	;G
    414  759a		       00		      .byte.b	0	;B
    415  759b		       7f		      .byte.b	127	;R (66)
    416  759c		       21		      .byte.b	33	;G
    417  759d		       00		      .byte.b	0	;B
    418  759e		       00		      .byte.b	0	;R (65)
    419  759f		       00		      .byte.b	0	;G
    420  75a0		       a8		      .byte.b	168	;B
    421  75a1		       00		      .byte.b	0	;R (64)
    422  75a2		       00		      .byte.b	0	;G
    423  75a3		       ab		      .byte.b	171	;B
    424  75a4		       00		      .byte.b	0	;R (63)
    425  75a5		       00		      .byte.b	0	;G
    426  75a6		       b8		      .byte.b	184	;B
    427  75a7		       00		      .byte.b	0	;R (62)
    428  75a8		       00		      .byte.b	0	;G
    429  75a9		       a8		      .byte.b	168	;B
    430  75aa		       00		      .byte.b	0	;R (61)
    431  75ab		       00		      .byte.b	0	;G
    432  75ac		       a8		      .byte.b	168	;B
    433  75ad		       00		      .byte.b	0	;R (60)
    434  75ae		       00		      .byte.b	0	;G
    435  75af		       03		      .byte.b	3	;B
    436  75b0		       01		      .byte.b	1	;R (59)
    437  75b1		       01		      .byte.b	1	;G
    438  75b2		       00		      .byte.b	0	;B
    439  75b3		       89		      .byte.b	137	;R (58)
    440  75b4		       89		      .byte.b	137	;G
    441  75b5		       00		      .byte.b	0	;B
    442  75b6		       fd		      .byte.b	253	;R (57)
    443  75b7		       00		      .byte.b	0	;G
    444  75b8		       00		      .byte.b	0	;B
    445  75b9		       fd		      .byte.b	253	;R (56)
    446  75ba		       00		      .byte.b	0	;G
    447  75bb		       00		      .byte.b	0	;B
    448  75bc		       fd		      .byte.b	253	;R (55)
    449  75bd		       00		      .byte.b	0	;G
    450  75be		       00		      .byte.b	0	;B
    451  75bf		       fd		      .byte.b	253	;R (54)
    452  75c0		       00		      .byte.b	0	;G
    453  75c1		       00		      .byte.b	0	;B
    454  75c2		       fd		      .byte.b	253	;R (53)
    455  75c3		       01		      .byte.b	1	;G
    456  75c4		       00		      .byte.b	0	;B
    457  75c5		       fe		      .byte.b	254	;R (52)
    458  75c6		       06		      .byte.b	6	;G
    459  75c7		       00		      .byte.b	0	;B
    460  75c8		       f9		      .byte.b	249	;R (51)
    461  75c9		       09		      .byte.b	9	;G
    462  75ca		       00		      .byte.b	0	;B
    463  75cb		       f8		      .byte.b	248	;R (50)
    464  75cc		       08		      .byte.b	8	;G
    465  75cd		       00		      .byte.b	0	;B
    466  75ce		       f8		      .byte.b	248	;R (49)
    467  75cf		       00		      .byte.b	0	;G
    468  75d0		       00		      .byte.b	0	;B
    469  75d1		       f8		      .byte.b	248	;R (48)
    470  75d2		       00		      .byte.b	0	;G
    471  75d3		       00		      .byte.b	0	;B
    472  75d4		       fc		      .byte.b	252	;R (47)
    473  75d5		       04		      .byte.b	4	;G
    474  75d6		       00		      .byte.b	0	;B
    475  75d7		       fc		      .byte.b	252	;R (46)
    476  75d8		       04		      .byte.b	4	;G
    477  75d9		       00		      .byte.b	0	;B
    478  75da		       fc		      .byte.b	252	;R (45)
    479  75db		       04		      .byte.b	4	;G
    480  75dc		       00		      .byte.b	0	;B
    481  75dd		       fc		      .byte.b	252	;R (44)
    482  75de		       84		      .byte.b	132	;G
    483  75df		       00		      .byte.b	0	;B
    484  75e0		       fc		      .byte.b	252	;R (43)
    485  75e1		       00		      .byte.b	0	;G
    486  75e2		       00		      .byte.b	0	;B
    487  75e3		       fc		      .byte.b	252	;R (42)
    488  75e4		       00		      .byte.b	0	;G
    489  75e5		       00		      .byte.b	0	;B
    490  75e6		       fc		      .byte.b	252	;R (41)
    491  75e7		       00		      .byte.b	0	;G
    492  75e8		       00		      .byte.b	0	;B
    493  75e9		       fc		      .byte.b	252	;R (40)
    494  75ea		       04		      .byte.b	4	;G
    495  75eb		       00		      .byte.b	0	;B
    496  75ec		       f8		      .byte.b	248	;R (39)
    497  75ed		       00		      .byte.b	0	;G
    498  75ee		       00		      .byte.b	0	;B
    499  75ef		       f8		      .byte.b	248	;R (38)
    500  75f0		       00		      .byte.b	0	;G
    501  75f1		       00		      .byte.b	0	;B
    502  75f2		       f8		      .byte.b	248	;R (37)
    503  75f3		       08		      .byte.b	8	;G
    504  75f4		       00		      .byte.b	0	;B
    505  75f5		       f0		      .byte.b	240	;R (36)
    506  75f6		       00		      .byte.b	0	;G
    507  75f7		       00		      .byte.b	0	;B
    508  75f8		       e0		      .byte.b	224	;R (35)
    509  75f9		       20		      .byte.b	32	;G
    510  75fa		       00		      .byte.b	0	;B
    511  75fb		       c0		      .byte.b	192	;R (34)
    512  75fc		       40		      .byte.b	64	;G
    513  75fd		       00		      .byte.b	0	;B
    514  75fe		       00		      .byte.b	0	;R (33)
    515  75ff		       00		      .byte.b	0	;G
    516  7600		       80		      .byte.b	128	;B
    517  7601		       02		      .byte.b	2	;R (32)
    518  7602		       02		      .byte.b	2	;G
    519  7603		       00		      .byte.b	0	;B
    520  7604		       67		      .byte.b	103	;R (31)
    521  7605		       07		      .byte.b	7	;G
    522  7606		       10		      .byte.b	16	;B
    523  7607		       7f		      .byte.b	127	;R (30)
    524  7608		       0a		      .byte.b	10	;G
    525  7609		       80		      .byte.b	128	;B
    526  760a		       ff		      .byte.b	255	;R (29)
    527  760b		       20		      .byte.b	32	;G
    528  760c		       00		      .byte.b	0	;B
    529  760d		       ff		      .byte.b	255	;R (28)
    530  760e		       12		      .byte.b	18	;G
    531  760f		       00		      .byte.b	0	;B
    532  7610		       ff		      .byte.b	255	;R (27)
    533  7611		       44		      .byte.b	68	;G
    534  7612		       00		      .byte.b	0	;B
    535  7613		       fc		      .byte.b	252	;R (26)
    536  7614		       20		      .byte.b	32	;G
    537  7615		       00		      .byte.b	0	;B
    538  7616		       f8		      .byte.b	248	;R (25)
    539  7617		       e8		      .byte.b	232	;G
    540  7618		       00		      .byte.b	0	;B
    541  7619		       b0		      .byte.b	176	;R (24)
    542  761a		       a0		      .byte.b	160	;G
    543  761b		       00		      .byte.b	0	;B
    544  761c		       40		      .byte.b	64	;R (23)
    545  761d		       40		      .byte.b	64	;G
    546  761e		       80		      .byte.b	128	;B
    547  761f		       e0		      .byte.b	224	;R (22)
    548  7620		       00		      .byte.b	0	;G
    549  7621		       00		      .byte.b	0	;B
    550  7622		       b0		      .byte.b	176	;R (21)
    551  7623		       10		      .byte.b	16	;G
    552  7624		       40		      .byte.b	64	;B
    553  7625		       e0		      .byte.b	224	;R (20)
    554  7626		       20		      .byte.b	32	;G
    555  7627		       00		      .byte.b	0	;B
    556  7628		       c0		      .byte.b	192	;R (19)
    557  7629		       c0		      .byte.b	192	;G
    558  762a		       00		      .byte.b	0	;B
    559  762b		       80		      .byte.b	128	;R (18)
    560  762c		       00		      .byte.b	0	;G
    561  762d		       00		      .byte.b	0	;B
    562  762e		       c0		      .byte.b	192	;R (17)
    563  762f		       c0		      .byte.b	192	;G
    564  7630		       00		      .byte.b	0	;B
    565  7631		       00		      .byte.b	0	;R (16)
    566  7632		       00		      .byte.b	0	;G
    567  7633		       00		      .byte.b	0	;B
    568  7634		       00		      .byte.b	0	;R (15)
    569  7635		       00		      .byte.b	0	;G
    570  7636		       00		      .byte.b	0	;B
    571  7637		       00		      .byte.b	0	;R (14)
    572  7638		       00		      .byte.b	0	;G
    573  7639		       00		      .byte.b	0	;B
    574  763a		       00		      .byte.b	0	;R (13)
    575  763b		       00		      .byte.b	0	;G
    576  763c		       00		      .byte.b	0	;B
    577  763d		       00		      .byte.b	0	;R (12)
    578  763e		       00		      .byte.b	0	;G
    579  763f		       00		      .byte.b	0	;B
    580  7640		       00		      .byte.b	0	;R (11)
    581  7641		       00		      .byte.b	0	;G
    582  7642		       00		      .byte.b	0	;B
    583  7643		       00		      .byte.b	0	;R (10)
    584  7644		       00		      .byte.b	0	;G
    585  7645		       07		      .byte.b	7	;B
    586  7646		       00		      .byte.b	0	;R (9)
    587  7647		       00		      .byte.b	0	;G
    588  7648		       05		      .byte.b	5	;B
    589  7649		       00		      .byte.b	0	;R (8)
    590  764a		       00		      .byte.b	0	;G
    591  764b		       55		      .byte.b	85	;B
    592  764c		       00		      .byte.b	0	;R (7)
    593  764d		       00		      .byte.b	0	;G
    594  764e		       55		      .byte.b	85	;B
    595  764f		       00		      .byte.b	0	;R (6)
    596  7650		       00		      .byte.b	0	;G
    597  7651		       35		      .byte.b	53	;B
    598  7652		       00		      .byte.b	0	;R (5)
    599  7653		       00		      .byte.b	0	;G
    600  7654		       57		      .byte.b	87	;B
    601  7655		       00		      .byte.b	0	;R (4)
    602  7656		       00		      .byte.b	0	;G
    603  7657		       50		      .byte.b	80	;B
    604  7658		       00		      .byte.b	0	;R (3)
    605  7659		       00		      .byte.b	0	;G
    606  765a		       30		      .byte.b	48	;B
    607  765b		       00		      .byte.b	0	;R (2)
    608  765c		       00		      .byte.b	0	;G
    609  765d		       00		      .byte.b	0	;B
    610  765e		       00		      .byte.b	0	;R (1)
    611  765f		       00		      .byte.b	0	;G
    612  7660		       00		      .byte.b	0	;B
    613  7661		       00		      .byte.b	0	;R (0)
    614  7662		       00		      .byte.b	0	;G
    615  7663		       00		      .byte.b	0	;B
    616  7664				   COL_3
    617  7664		       80		      .byte.b	128	;R (67)
    618  7665		       80		      .byte.b	128	;G
    619  7666		       00		      .byte.b	0	;B
    620  7667		       78		      .byte.b	120	;R (66)
    621  7668		       10		      .byte.b	16	;G
    622  7669		       00		      .byte.b	0	;B
    623  766a		       02		      .byte.b	2	;R (65)
    624  766b		       02		      .byte.b	2	;G
    625  766c		       c0		      .byte.b	192	;B
    626  766d		       03		      .byte.b	3	;R (64)
    627  766e		       00		      .byte.b	0	;G
    628  766f		       5c		      .byte.b	92	;B
    629  7670		       01		      .byte.b	1	;R (63)
    630  7671		       00		      .byte.b	0	;G
    631  7672		       c4		      .byte.b	196	;B
    632  7673		       01		      .byte.b	1	;R (62)
    633  7674		       00		      .byte.b	0	;G
    634  7675		       1c		      .byte.b	28	;B
    635  7676		       01		      .byte.b	1	;R (61)
    636  7677		       00		      .byte.b	0	;G
    637  7678		       d0		      .byte.b	208	;B
    638  7679		       01		      .byte.b	1	;R (60)
    639  767a		       00		      .byte.b	0	;G
    640  767b		       1c		      .byte.b	28	;B
    641  767c		       01		      .byte.b	1	;R (59)
    642  767d		       00		      .byte.b	0	;G
    643  767e		       00		      .byte.b	0	;B
    644  767f		       1f		      .byte.b	31	;R (58)
    645  7680		       1f		      .byte.b	31	;G
    646  7681		       00		      .byte.b	0	;B
    647  7682		       df		      .byte.b	223	;R (57)
    648  7683		       53		      .byte.b	83	;G
    649  7684		       00		      .byte.b	0	;B
    650  7685		       df		      .byte.b	223	;R (56)
    651  7686		       14		      .byte.b	20	;G
    652  7687		       00		      .byte.b	0	;B
    653  7688		       df		      .byte.b	223	;R (55)
    654  7689		       13		      .byte.b	19	;G
    655  768a		       00		      .byte.b	0	;B
    656  768b		       df		      .byte.b	223	;R (54)
    657  768c		       1f		      .byte.b	31	;G
    658  768d		       00		      .byte.b	0	;B
    659  768e		       cf		      .byte.b	207	;R (53)
    660  768f		       4e		      .byte.b	78	;G
    661  7690		       00		      .byte.b	0	;B
    662  7691		       ef		      .byte.b	239	;R (52)
    663  7692		       6f		      .byte.b	111	;G
    664  7693		       00		      .byte.b	0	;B
    665  7694		       90		      .byte.b	144	;R (51)
    666  7695		       10		      .byte.b	16	;G
    667  7696		       00		      .byte.b	0	;B
    668  7697		       88		      .byte.b	136	;R (50)
    669  7698		       88		      .byte.b	136	;G
    670  7699		       00		      .byte.b	0	;B
    671  769a		       01		      .byte.b	1	;R (49)
    672  769b		       01		      .byte.b	1	;G
    673  769c		       00		      .byte.b	0	;B
    674  769d		       03		      .byte.b	3	;R (48)
    675  769e		       03		      .byte.b	3	;G
    676  769f		       00		      .byte.b	0	;B
    677  76a0		       09		      .byte.b	9	;R (47)
    678  76a1		       09		      .byte.b	9	;G
    679  76a2		       00		      .byte.b	0	;B
    680  76a3		       08		      .byte.b	8	;R (46)
    681  76a4		       08		      .byte.b	8	;G
    682  76a5		       00		      .byte.b	0	;B
    683  76a6		       0c		      .byte.b	12	;R (45)
    684  76a7		       0c		      .byte.b	12	;G
    685  76a8		       00		      .byte.b	0	;B
    686  76a9		       05		      .byte.b	5	;R (44)
    687  76aa		       05		      .byte.b	5	;G
    688  76ab		       00		      .byte.b	0	;B
    689  76ac		       01		      .byte.b	1	;R (43)
    690  76ad		       00		      .byte.b	0	;G
    691  76ae		       00		      .byte.b	0	;B
    692  76af		       01		      .byte.b	1	;R (42)
    693  76b0		       00		      .byte.b	0	;G
    694  76b1		       00		      .byte.b	0	;B
    695  76b2		       01		      .byte.b	1	;R (41)
    696  76b3		       00		      .byte.b	0	;G
    697  76b4		       00		      .byte.b	0	;B
    698  76b5		       81		      .byte.b	129	;R (40)
    699  76b6		       81		      .byte.b	129	;G
    700  76b7		       00		      .byte.b	0	;B
    701  76b8		       c0		      .byte.b	192	;R (39)
    702  76b9		       40		      .byte.b	64	;G
    703  76ba		       00		      .byte.b	0	;B
    704  76bb		       c0		      .byte.b	192	;R (38)
    705  76bc		       00		      .byte.b	0	;G
    706  76bd		       00		      .byte.b	0	;B
    707  76be		       e0		      .byte.b	224	;R (37)
    708  76bf		       20		      .byte.b	32	;G
    709  76c0		       00		      .byte.b	0	;B
    710  76c1		       e0		      .byte.b	224	;R (36)
    711  76c2		       00		      .byte.b	0	;G
    712  76c3		       00		      .byte.b	0	;B
    713  76c4		       f0		      .byte.b	240	;R (35)
    714  76c5		       10		      .byte.b	16	;G
    715  76c6		       00		      .byte.b	0	;B
    716  76c7		       f0		      .byte.b	240	;R (34)
    717  76c8		       00		      .byte.b	0	;G
    718  76c9		       00		      .byte.b	0	;B
    719  76ca		       f8		      .byte.b	248	;R (33)
    720  76cb		       08		      .byte.b	8	;G
    721  76cc		       00		      .byte.b	0	;B
    722  76cd		       f8		      .byte.b	248	;R (32)
    723  76ce		       08		      .byte.b	8	;G
    724  76cf		       00		      .byte.b	0	;B
    725  76d0		       f0		      .byte.b	240	;R (31)
    726  76d1		       80		      .byte.b	128	;G
    727  76d2		       00		      .byte.b	0	;B
    728  76d3		       f0		      .byte.b	240	;R (30)
    729  76d4		       00		      .byte.b	0	;G
    730  76d5		       00		      .byte.b	0	;B
    731  76d6		       f8		      .byte.b	248	;R (29)
    732  76d7		       88		      .byte.b	136	;G
    733  76d8		       00		      .byte.b	0	;B
    734  76d9		       f8		      .byte.b	248	;R (28)
    735  76da		       08		      .byte.b	8	;G
    736  76db		       00		      .byte.b	0	;B
    737  76dc		       f8		      .byte.b	248	;R (27)
    738  76dd		       08		      .byte.b	8	;G
    739  76de		       00		      .byte.b	0	;B
    740  76df		       f8		      .byte.b	248	;R (26)
    741  76e0		       88		      .byte.b	136	;G
    742  76e1		       00		      .byte.b	0	;B
    743  76e2		       f8		      .byte.b	248	;R (25)
    744  76e3		       08		      .byte.b	8	;G
    745  76e4		       00		      .byte.b	0	;B
    746  76e5		       f8		      .byte.b	248	;R (24)
    747  76e6		       08		      .byte.b	8	;G
    748  76e7		       00		      .byte.b	0	;B
    749  76e8		       f8		      .byte.b	248	;R (23)
    750  76e9		       08		      .byte.b	8	;G
    751  76ea		       00		      .byte.b	0	;B
    752  76eb		       f0		      .byte.b	240	;R (22)
    753  76ec		       00		      .byte.b	0	;G
    754  76ed		       00		      .byte.b	0	;B
    755  76ee		       f0		      .byte.b	240	;R (21)
    756  76ef		       10		      .byte.b	16	;G
    757  76f0		       00		      .byte.b	0	;B
    758  76f1		       e0		      .byte.b	224	;R (20)
    759  76f2		       20		      .byte.b	32	;G
    760  76f3		       00		      .byte.b	0	;B
    761  76f4		       c0		      .byte.b	192	;R (19)
    762  76f5		       00		      .byte.b	0	;G
    763  76f6		       00		      .byte.b	0	;B
    764  76f7		       c0		      .byte.b	192	;R (18)
    765  76f8		       40		      .byte.b	64	;G
    766  76f9		       00		      .byte.b	0	;B
    767  76fa		       83		      .byte.b	131	;R (17)
    768  76fb		       83		      .byte.b	131	;G
    769  76fc		       00		      .byte.b	0	;B
    770  76fd		       03		      .byte.b	3	;R (16)
    771  76fe		       03		      .byte.b	3	;G
    772  76ff		       00		      .byte.b	0	;B
    773  7700		       01		      .byte.b	1	;R (15)
    774  7701		       01		      .byte.b	1	;G
    775  7702		       00		      .byte.b	0	;B
    776  7703		       00		      .byte.b	0	;R (14)
    777  7704		       00		      .byte.b	0	;G
    778  7705		       00		      .byte.b	0	;B
    779  7706		       00		      .byte.b	0	;R (13)
    780  7707		       00		      .byte.b	0	;G
    781  7708		       0a		      .byte.b	10	;B
    782  7709		       00		      .byte.b	0	;R (12)
    783  770a		       00		      .byte.b	0	;G
    784  770b		       0a		      .byte.b	10	;B
    785  770c		       00		      .byte.b	0	;R (11)
    786  770d		       00		      .byte.b	0	;G
    787  770e		       0e		      .byte.b	14	;B
    788  770f		       00		      .byte.b	0	;R (10)
    789  7710		       00		      .byte.b	0	;G
    790  7711		       aa		      .byte.b	170	;B
    791  7712		       00		      .byte.b	0	;R (9)
    792  7713		       00		      .byte.b	0	;G
    793  7714		       ae		      .byte.b	174	;B
    794  7715		       00		      .byte.b	0	;R (8)
    795  7716		       00		      .byte.b	0	;G
    796  7717		       a4		      .byte.b	164	;B
    797  7718		       00		      .byte.b	0	;R (7)
    798  7719		       00		      .byte.b	0	;G
    799  771a		       a0		      .byte.b	160	;B
    800  771b		       00		      .byte.b	0	;R (6)
    801  771c		       00		      .byte.b	0	;G
    802  771d		       a0		      .byte.b	160	;B
    803  771e		       00		      .byte.b	0	;R (5)
    804  771f		       00		      .byte.b	0	;G
    805  7720		       c0		      .byte.b	192	;B
    806  7721		       00		      .byte.b	0	;R (4)
    807  7722		       00		      .byte.b	0	;G
    808  7723		       00		      .byte.b	0	;B
    809  7724		       00		      .byte.b	0	;R (3)
    810  7725		       00		      .byte.b	0	;G
    811  7726		       00		      .byte.b	0	;B
    812  7727		       00		      .byte.b	0	;R (2)
    813  7728		       00		      .byte.b	0	;G
    814  7729		       00		      .byte.b	0	;B
    815  772a		       00		      .byte.b	0	;R (1)
    816  772b		       00		      .byte.b	0	;G
    817  772c		       00		      .byte.b	0	;B
    818  772d		       00		      .byte.b	0	;R (0)
    819  772e		       00		      .byte.b	0	;G
    820  772f		       00		      .byte.b	0	;B
    821  7730				   COL_4
    822  7730		       00		      .byte.b	0	;R (67)
    823  7731		       00		      .byte.b	0	;G
    824  7732		       00		      .byte.b	0	;B
    825  7733		       00		      .byte.b	0	;R (66)
    826  7734		       00		      .byte.b	0	;G
    827  7735		       00		      .byte.b	0	;B
    828  7736		       00		      .byte.b	0	;R (65)
    829  7737		       00		      .byte.b	0	;G
    830  7738		       00		      .byte.b	0	;B
    831  7739		       01		      .byte.b	1	;R (64)
    832  773a		       01		      .byte.b	1	;G
    833  773b		       00		      .byte.b	0	;B
    834  773c		       03		      .byte.b	3	;R (63)
    835  773d		       02		      .byte.b	2	;G
    836  773e		       00		      .byte.b	0	;B
    837  773f		       03		      .byte.b	3	;R (62)
    838  7740		       03		      .byte.b	3	;G
    839  7741		       00		      .byte.b	0	;B
    840  7742		       03		      .byte.b	3	;R (61)
    841  7743		       02		      .byte.b	2	;G
    842  7744		       00		      .byte.b	0	;B
    843  7745		       03		      .byte.b	3	;R (60)
    844  7746		       03		      .byte.b	3	;G
    845  7747		       00		      .byte.b	0	;B
    846  7748		       03		      .byte.b	3	;R (59)
    847  7749		       02		      .byte.b	2	;G
    848  774a		       00		      .byte.b	0	;B
    849  774b		       03		      .byte.b	3	;R (58)
    850  774c		       03		      .byte.b	3	;G
    851  774d		       00		      .byte.b	0	;B
    852  774e		       03		      .byte.b	3	;R (57)
    853  774f		       03		      .byte.b	3	;G
    854  7750		       00		      .byte.b	0	;B
    855  7751		       0d		      .byte.b	13	;R (56)
    856  7752		       0d		      .byte.b	13	;G
    857  7753		       00		      .byte.b	0	;B
    858  7754		       1f		      .byte.b	31	;R (55)
    859  7755		       0b		      .byte.b	11	;G
    860  7756		       00		      .byte.b	0	;B
    861  7757		       3f		      .byte.b	63	;R (54)
    862  7758		       25		      .byte.b	37	;G
    863  7759		       00		      .byte.b	0	;B
    864  775a		       3f		      .byte.b	63	;R (53)
    865  775b		       30		      .byte.b	48	;G
    866  775c		       00		      .byte.b	0	;B
    867  775d		       21		      .byte.b	33	;R (52)
    868  775e		       21		      .byte.b	33	;G
    869  775f		       00		      .byte.b	0	;B
    870  7760		       00		      .byte.b	0	;R (51)
    871  7761		       00		      .byte.b	0	;G
    872  7762		       00		      .byte.b	0	;B
    873  7763		       00		      .byte.b	0	;R (50)
    874  7764		       00		      .byte.b	0	;G
    875  7765		       00		      .byte.b	0	;B
    876  7766		       01		      .byte.b	1	;R (49)
    877  7767		       01		      .byte.b	1	;G
    878  7768		       00		      .byte.b	0	;B
    879  7769		       03		      .byte.b	3	;R (48)
    880  776a		       02		      .byte.b	2	;G
    881  776b		       00		      .byte.b	0	;B
    882  776c		       07		      .byte.b	7	;R (47)
    883  776d		       07		      .byte.b	7	;G
    884  776e		       00		      .byte.b	0	;B
    885  776f		       00		      .byte.b	0	;R (46)
    886  7770		       00		      .byte.b	0	;G
    887  7771		       00		      .byte.b	0	;B
    888  7772		       00		      .byte.b	0	;R (45)
    889  7773		       00		      .byte.b	0	;G
    890  7774		       00		      .byte.b	0	;B
    891  7775		       06		      .byte.b	6	;R (44)
    892  7776		       06		      .byte.b	6	;G
    893  7777		       00		      .byte.b	0	;B
    894  7778		       0c		      .byte.b	12	;R (43)
    895  7779		       04		      .byte.b	4	;G
    896  777a		       00		      .byte.b	0	;B
    897  777b		       1c		      .byte.b	28	;R (42)
    898  777c		       1c		      .byte.b	28	;G
    899  777d		       00		      .byte.b	0	;B
    900  777e		       38		      .byte.b	56	;R (41)
    901  777f		       38		      .byte.b	56	;G
    902  7780		       00		      .byte.b	0	;B
    903  7781		       00		      .byte.b	0	;R (40)
    904  7782		       00		      .byte.b	0	;G
    905  7783		       00		      .byte.b	0	;B
    906  7784		       0a		      .byte.b	10	;R (39)
    907  7785		       0a		      .byte.b	10	;G
    908  7786		       00		      .byte.b	0	;B
    909  7787		       02		      .byte.b	2	;R (38)
    910  7788		       00		      .byte.b	0	;G
    911  7789		       00		      .byte.b	0	;B
    912  778a		       32		      .byte.b	50	;R (37)
    913  778b		       30		      .byte.b	48	;G
    914  778c		       00		      .byte.b	0	;B
    915  778d		       72		      .byte.b	114	;R (36)
    916  778e		       72		      .byte.b	114	;G
    917  778f		       00		      .byte.b	0	;B
    918  7790		       74		      .byte.b	116	;R (35)
    919  7791		       54		      .byte.b	84	;G
    920  7792		       00		      .byte.b	0	;B
    921  7793		       54		      .byte.b	84	;R (34)
    922  7794		       10		      .byte.b	16	;G
    923  7795		       00		      .byte.b	0	;B
    924  7796		       04		      .byte.b	4	;R (33)
    925  7797		       00		      .byte.b	0	;G
    926  7798		       00		      .byte.b	0	;B
    927  7799		       02		      .byte.b	2	;R (32)
    928  779a		       02		      .byte.b	2	;G
    929  779b		       00		      .byte.b	0	;B
    930  779c		       10		      .byte.b	16	;R (31)
    931  779d		       10		      .byte.b	16	;G
    932  779e		       00		      .byte.b	0	;B
    933  779f		       68		      .byte.b	104	;R (30)
    934  77a0		       68		      .byte.b	104	;G
    935  77a1		       00		      .byte.b	0	;B
    936  77a2		       6c		      .byte.b	108	;R (29)
    937  77a3		       24		      .byte.b	36	;G
    938  77a4		       00		      .byte.b	0	;B
    939  77a5		       4c		      .byte.b	76	;R (28)
    940  77a6		       08		      .byte.b	8	;G
    941  77a7		       00		      .byte.b	0	;B
    942  77a8		       d4		      .byte.b	212	;R (27)
    943  77a9		       d4		      .byte.b	212	;G
    944  77aa		       00		      .byte.b	0	;B
    945  77ab		       00		      .byte.b	0	;R (26)
    946  77ac		       00		      .byte.b	0	;G
    947  77ad		       00		      .byte.b	0	;B
    948  77ae		       2c		      .byte.b	44	;R (25)
    949  77af		       2c		      .byte.b	44	;G
    950  77b0		       00		      .byte.b	0	;B
    951  77b1		       36		      .byte.b	54	;R (24)
    952  77b2		       16		      .byte.b	22	;G
    953  77b3		       00		      .byte.b	0	;B
    954  77b4		       2e		      .byte.b	46	;R (23)
    955  77b5		       0e		      .byte.b	14	;G
    956  77b6		       00		      .byte.b	0	;B
    957  77b7		       60		      .byte.b	96	;R (22)
    958  77b8		       40		      .byte.b	64	;G
    959  77b9		       00		      .byte.b	0	;B
    960  77ba		       28		      .byte.b	40	;R (21)
    961  77bb		       28		      .byte.b	40	;G
    962  77bc		       00		      .byte.b	0	;B
    963  77bd		       0f		      .byte.b	15	;R (20)
    964  77be		       0d		      .byte.b	13	;G
    965  77bf		       00		      .byte.b	0	;B
    966  77c0		       1a		      .byte.b	26	;R (19)
    967  77c1		       1a		      .byte.b	26	;G
    968  77c2		       00		      .byte.b	0	;B
    969  77c3		       18		      .byte.b	24	;R (18)
    970  77c4		       08		      .byte.b	8	;G
    971  77c5		       00		      .byte.b	0	;B
    972  77c6		       14		      .byte.b	20	;R (17)
    973  77c7		       04		      .byte.b	4	;G
    974  77c8		       00		      .byte.b	0	;B
    975  77c9		       16		      .byte.b	22	;R (16)
    976  77ca		       16		      .byte.b	22	;G
    977  77cb		       00		      .byte.b	0	;B
    978  77cc		       04		      .byte.b	4	;R (15)
    979  77cd		       00		      .byte.b	0	;G
    980  77ce		       00		      .byte.b	0	;B
    981  77cf		       06		      .byte.b	6	;R (14)
    982  77d0		       02		      .byte.b	2	;G
    983  77d1		       00		      .byte.b	0	;B
    984  77d2		       05		      .byte.b	5	;R (13)
    985  77d3		       05		      .byte.b	5	;G
    986  77d4		       00		      .byte.b	0	;B
    987  77d5		       05		      .byte.b	5	;R (12)
    988  77d6		       05		      .byte.b	5	;G
    989  77d7		       00		      .byte.b	0	;B
    990  77d8		       00		      .byte.b	0	;R (11)
    991  77d9		       00		      .byte.b	0	;G
    992  77da		       00		      .byte.b	0	;B
    993  77db		       00		      .byte.b	0	;R (10)
    994  77dc		       00		      .byte.b	0	;G
    995  77dd		       00		      .byte.b	0	;B
    996  77de		       00		      .byte.b	0	;R (9)
    997  77df		       00		      .byte.b	0	;G
    998  77e0		       00		      .byte.b	0	;B
    999  77e1		       00		      .byte.b	0	;R (8)
   1000  77e2		       00		      .byte.b	0	;G
   1001  77e3		       00		      .byte.b	0	;B
   1002  77e4		       00		      .byte.b	0	;R (7)
   1003  77e5		       00		      .byte.b	0	;G
   1004  77e6		       00		      .byte.b	0	;B
   1005  77e7		       00		      .byte.b	0	;R (6)
   1006  77e8		       00		      .byte.b	0	;G
   1007  77e9		       00		      .byte.b	0	;B
   1008  77ea		       00		      .byte.b	0	;R (5)
   1009  77eb		       00		      .byte.b	0	;G
   1010  77ec		       00		      .byte.b	0	;B
   1011  77ed		       00		      .byte.b	0	;R (4)
   1012  77ee		       00		      .byte.b	0	;G
   1013  77ef		       00		      .byte.b	0	;B
   1014  77f0		       00		      .byte.b	0	;R (3)
   1015  77f1		       00		      .byte.b	0	;G
   1016  77f2		       00		      .byte.b	0	;B
   1017  77f3		       00		      .byte.b	0	;R (2)
   1018  77f4		       00		      .byte.b	0	;G
   1019  77f5		       00		      .byte.b	0	;B
   1020  77f6		       00		      .byte.b	0	;R (1)
   1021  77f7		       00		      .byte.b	0	;G
   1022  77f8		       00		      .byte.b	0	;B
   1023  77f9		       00		      .byte.b	0	;R (0)
   1024  77fa		       00		      .byte.b	0	;G
   1025  77fb		       00		      .byte.b	0	;B
------- FILE TitleScreen@2.asm
      6  77fc
      0  77fc					      END_BANK
      1  77fc				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  77fc				  -	      CHECK_RAM_BANK_SIZE
      3  77fc					      ELSE
      0  77fc					      CHECK_BANK_SIZE
      1  77fc		       03 fc	   .TEMP      =	* - _BANK_START
 ROM bank # 30 TITLEDATA2 size = $3fc free = 3
      2  77fc					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  77fc				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  77fc				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  77fc				  -	      ERR
      6  77fc					      ENDIF
      5  77fc					      ENDIF
------- FILE ./chess.asm
    208  77fc
    209  77fc
    210  7800		       00 00 00 00	      ALIGN	_ROM_BANK_SIZE
    211  7800
 30 ROM BANKS
    212  7800					      ECHO	[_ORIGIN/_ROM_BANK_SIZE]d, "ROM BANKS"
 17 RAM BANKS
    213  7800					      ECHO	[ORIGIN_RAM / _RAM_BANK_SIZE]d, "RAM BANKS"
    214  7800
    215  7800							;---------------------------------------------------------------------------------------------------
    216  7800							;EOF
