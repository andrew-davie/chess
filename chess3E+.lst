------- FILE ./chess.asm LEVEL 1 PASS 4
      1  8400 ????						; Chess
      2  8400 ????						; Atari 2600 Chess display system
      3  8400 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  8400 ????						; andrew@taswegian.com
      5  8400 ????
      6  8400 ????
      7  8400 ????	       00 40	   TIA_BASE_ADDRESS =	$40
      8  8400 ????
      9  8400 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 4
      0  8400 ????				      include	"vcs.h"
      1  8400 ????						; VCS.H
      2  8400 ????						; Version 1.05, 13/November/2003
      3  8400 ????
      4  8400 ????	       00 69	   VERSION_VCS =	105
      5  8400 ????
      6  8400 ????						; This file defines hardware registers and memory mapping for the
      7  8400 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  8400 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  8400 ????						; available at at http://www.atari2600.org/dasm
     10  8400 ????						;
     11  8400 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  8400 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  8400 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  8400 ????						; with your views.  Please contribute, if you think you can improve this
     15  8400 ????						; file!
     16  8400 ????						;
     17  8400 ????						; Latest Revisions...
     18  8400 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  8400 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  8400 ????						;			    This will allow conditional code to verify VCS.H being
     21  8400 ????						;			    used for code assembly.
     22  8400 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  8400 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  8400 ????						;			 mirrored reading/writing differences.	This is more a
     25  8400 ????						;			 readability issue, and binary compatibility with disassembled
     26  8400 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  8400 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  8400 ????						;			 which was broken by the use of segments in this file, as
     29  8400 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  8400 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  8400 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  8400 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  8400 ????						;						   it is safe to leave it undefined, and the base address will
     34  8400 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  8400 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  8400 ????						;			  - register definitions are now generated through assignment
     37  8400 ????						;			    in uninitialised segments.	This allows a changeable base
     38  8400 ????						;			    address architecture.
     39  8400 ????						; 1.0	22/MAR/2003		Initial release
     40  8400 ????
     41  8400 ????
     42  8400 ????						;-------------------------------------------------------------------------------
     43  8400 ????
     44  8400 ????						; TIA_BASE_ADDRESS
     45  8400 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  8400 ????						; Normally 0, the base address should (externally, before including this file)
     47  8400 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  8400 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  8400 ????						; < $40 as a bankswitch.
     50  8400 ????
     51  8400 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  8400 ????			  -TIA_BASE_ADDRESS =	0
     53  8400 ????				      ENDIF
     54  8400 ????
     55  8400 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  8400 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  8400 ????						; *OR* by declaring the label before including this file, eg:
     58  8400 ????						; TIA_BASE_ADDRESS = $40
     59  8400 ????						;   include "vcs.h"
     60  8400 ????
     61  8400 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  8400 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  8400 ????						; for the mirrored ROM hardware registers.
     64  8400 ????
     65  8400 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  8400 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  8400 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  8400 ????
     69  8400 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  8400 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  8400 ????				      ENDIF
     72  8400 ????
     73  8400 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  8400 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  8400 ????				      ENDIF
     76  8400 ????
     77  8400 ????						;-------------------------------------------------------------------------------
     78  8400 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE macro.h LEVEL 2 PASS 4
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE piece_defines.h LEVEL 2 PASS 4
      0  0000 ????				      include	"piece_defines.h"
      1  0000 ????						; Copyright (C)2020 Andrew Davie
      2  0000 ????
      3  0000 ????	       00 80	   BLACK      =	128
      4  0000 ????	       00 00	   WHITE      =	0
      5  0000 ????
      6  0000 ????	       00 80	   FLAG_COLOUR =	128	; mask
      7  0000 ????	       00 40	   FLAG_MOVED =	64	; mark ALL pieces when moved. Used for castling
      8  0000 ????						; but maybe useful for evaluation of development
      9  0000 ????	       00 20	   FLAG_ENPASSANT =	32
     10  0000 ????	       00 10	   FLAG_CASTLE =	16
     11  0000 ????
     12  0000 ????						;---------------------------------------------------------------------------------------------------
     13  0000 ????						; DEFINE THE PIECES
     14  0000 ????						; ID lives in bits 0-2
     15  0000 ????
     16  0000 ????	       00 00	   BLANK      =	0
     17  0000 ????	       00 00	   ███  =	BLANK
     18  0000 ????
     19  0000 ????	       00 01	   WPAWN      =	1
     20  0000 ????	       00 01	   WP	      =	WPAWN
     21  0000 ????	       00 02	   BPAWN      =	2
     22  0000 ????	       00 02	   BP	      =	BPAWN
     23  0000 ????	       00 03	   KNIGHT     =	3
     24  0000 ????	       00 03	   N	      =	KNIGHT
     25  0000 ????	       00 04	   BISHOP     =	4
     26  0000 ????	       00 04	   B	      =	BISHOP
     27  0000 ????	       00 05	   ROOK       =	5
     28  0000 ????	       00 05	   R	      =	ROOK
     29  0000 ????	       00 06	   QUEEN      =	6
     30  0000 ????	       00 06	   Q	      =	QUEEN
     31  0000 ????	       00 07	   KING       =	7
     32  0000 ????	       00 07	   K	      =	KING
     33  0000 ????
     34  0000 ????	       00 0f	   PIECE_MASK =	15	; trim off the flags leaving just piece ID
     35  0000 ????
     36  0000 ????						;---------------------------------------------------------------------------------------------------
     37  0000 ????
     38  0000 ????						; Movements
     39  0000 ????
     40  0000 ????	       00 0a	   _UP	      =	10	; up
     41  0000 ????	       ff ff ff ff _LEFT      =	-1	; left
     42  0000 ????	       ff ff ff f6 _DOWN      =	-10	; down
     43  0000 ????	       00 01	   _RIGHT     =	1	; right
     44  0000 ????
     45  0000 ????						; EOF
------- FILE ./chess.asm
     13  0000 ????
     14  0000 ????	       00 00	   VERBOSE    =	0	; set to 1 for compile messages
     15  0000 ????
     16  0000 ????			   ORIGIN     SET	0
     17  0000 ????			   ORIGIN_RAM SET	0
     18  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	segtime_c
     89  0000 ????			   {1}	      SET	({2}+32)/64 + 2
     90  0000 ????			   TEST_{1}   =	0
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????						; Pathways
     94  0000 ????						; StealPart3, not enough time for SCD_SLOW --> 79✅
     95  0000 ????						; if QuickDraw does immediate exit, 58✅
     96  0000 ????
     97  0000 ????						;---------------------------------------------------------------------------------------------------
     98  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_MINIMUM_TIMESLICE, 54	;✅ abort time maximum requirement for timeslice
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	(54+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    100  0000 ????
    101  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    102  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    103  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    104  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    105  0000 ????						; uses ...
    106  0000 ????
    107  0000 ????
    108  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    109  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    110  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    111  0000 ????
    112  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    113  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    114  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,22	;18 ;12	  ;NFI
      1  0000 ????			   SEGTIME_MAN SET	22
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
------- FILE ./chess.asm
     20  0000 ????
     21  0000 ????
     22  0000 ????	       00 00	   _FIRST_BANK =	0	; 3E+ 1st bank holds reset vectors
     23  0000 ????
     24  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     25  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     26  0000 ????						;FIXED_BANK		 = 15 * 2048	       ; ->> 32K
     27  0000 ????						;FIXED_BANK		 = 31 * 2048	       ; ->> 64K
     28  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     29  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     30  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     31  0000 ????
     32  0000 ????	       00 01	   YES	      =	1
     33  0000 ????	       00 00	   NO	      =	0
     34  0000 ????
     35  0000 ????	       70 00	   INFINITY   =	$7000	;32767
     36  0000 ????
     37  0000 ????
     38  0000 ????						; assemble diagnostics. Remove for release.
     39  0000 ????
     40  0000 ????	       00 00	   TEST_POSITION =	0	; 0=normal, 1 = setup test position
     41  0000 ????	       00 00	   DIAGNOSTICS =	0
     42  0000 ????	       00 01	   QUIESCENCE =	1
     43  0000 ????	       00 00	   ASSERTS    =	0
     44  0000 ????	       00 00	   PVSP       =	0	; player versus player =1
     45  0000 ????	       00 01	   ENPASSANT_ENABLED =	1
     46  0000 ????	       00 01	   CASTLING_ENABLED =	1
     47  0000 ????
     48  0000 ????	       00 03	   SEARCH_DEPTH =	3
     49  0000 ????	       00 04	   QUIESCE_EXTRA_DEPTH =	4
     50  0000 ????
     51  0000 ????
     52  0000 ????	       00 07	   PLY_BANKS  =	SEARCH_DEPTH + QUIESCE_EXTRA_DEPTH
     53  0000 ????	       00 07	   MAX_PLY_DEPTH_BANK =	PLY_BANKS	;TODO -- RAMBANK_PLY + PLY_BANKS
     54  0000 ????
     55  0000 ????						;IF RAMBANK_PLY + MAX_PLY_DEPTH_BANK > 31
     56  0000 ????						;    ERR "Not enough RAM for PLY banks"
     57  0000 ????						;ENDIF
     58  0000 ????
     59  0000 ????
     60  0000 ????
     61  0000 ????
     62  0000 ????	       00 80	   SWAP_SIDE  =	128	;TODO + (RAMBANK_PLY ^ (RAMBANK_PLY+1))
     63  0000 ????
     64  0000 ????
     65  0000 ????
     66  0000 ????						; DELAYS
     67  0000 ????
     68  0000 ????	       00 0a	   READY_TO_MOVE_FLASH =	10
     69  0000 ????
     70  0000 ????						;===================================
     71  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     72  0000 ????						;===================================
     73  0000 ????
     74  0000 ????						;-------------------------------------------------------------------------------
     75  0000 ????						; The following are optional YES/NO depending on phase of the moon
     76  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     77  0000 ????						;-------------------------------------------------------------------------------
     78  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     79  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     80  0000 ????			  -	      IF	FINAL_VERSION = YES
     81  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     82  0000 ????				      ENDIF
     83  0000 ????
     84  0000 ????						;-------------------------------------------------------------------------------
     85  0000 ????
     86  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     87  0000 ????
     88  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
     89  0000 ????
     90  0000 ????						;------------------------------------------------------------------------------
     91  0000 ????
     92  0000 ????	       00 01	   PLUSCART   =	YES
     93  0000 ????
     94  0000 ????						;------------------------------------------------------------------------------
     95  0000 ????
     96  0000 ????
     97  0000 ????	       00 08	   CHESSBOARD_ROWS =	8	; number of ROWS of chessboard
     98  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
     99  0000 ????	       00 48	   PIECE_SHAPE_SIZE =	72	; 3 PF bytes x 24 scanlines
    100  0000 ????
    101  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    102  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    103  0000 ????
    104  0000 ????
    105  0000 ????	       02 00	   RAM_SIZE   =	$200
    106  0000 ????	       02 00	   RAM_WRITE  =	$200	; add this to RAM address when doing writes
    107  0000 ????	       02 00	   RAM	      =	RAM_WRITE
    108  0000 ????
    109  0000 ????
    110  0000 ????
    111  0000 ????						; Platform constants:
    112  0000 ????	       00 02	   PAL	      =	%10
    113  0000 ????	       00 02	   PAL_50     =	PAL|0
    114  0000 ????	       00 03	   PAL_60     =	PAL|1
    115  0000 ????
    116  0000 ????
    117  0000 ????				      IF	L276
    118  0000 ????	       00 30	   VBLANK_TIM_NTSC =	48	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    119  0000 ????			  -	      ELSE
    120  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    121  0000 ????				      ENDIF
    122  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    123  0000 ????
    124  0000 ????				      IF	L276
    125  0000 ????	       00 23	   OVERSCAN_TIM_NTSC =	35	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    126  0000 ????			  -	      ELSE
    127  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    128  0000 ????				      ENDIF
    129  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    130  0000 ????
    131  0000 ????				      IF	L276
    132  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    133  0000 ????			  -	      ELSE
    134  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    135  0000 ????				      ENDIF
    136  0000 ????	       01 38	   SCANLINES_PAL =	312
    137  0000 ????
    138  0000 ????
    139  0000 ????	       00 2e	   TIME_PART_2 =	46
    140  0000 ????	       00 2e	   TIME_PART_1 =	46
    141  0000 ????
    142  0000 ????
    143  0000 ????	       00 00	   SLOT0      =	0
    144  0000 ????	       00 40	   SLOT1      =	64
    145  0000 ????	       00 80	   SLOT2      =	128
    146  0000 ????	       00 c0	   SLOT3      =	192
    147  0000 ????
    148  0000 ????						;------------------------------------------------------------------------------
    149  0000 ????						; MACRO definitions
    150  0000 ????
    151  0000 ????
    152  0000 ????	       04 00	   _ROM_BANK_SIZE =	$400
    153  0000 ????	       02 00	   _RAM_BANK_SIZE =	$200
    154  0000 ????
    155  0000 ????				      MAC	newbank
    156  0000 ????				      SEG	{1}
    157  0000 ????				      ORG	_ORIGIN
    158  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    159  0000 ????			   _BANK_START SET	*
    160  0000 ????			   {1}_START  SET	*
    161  0000 ????			   _CURRENT_BANK SET	_ORIGIN/1024
    162  0000 ????			   {1}	      SET	_BANK_SLOT + _CURRENT_BANK
    163  0000 ????			   _ORIGIN    SET	_ORIGIN + 1024
    164  0000 ????				      ENDM		; bank name
    165  0000 ????
    166  0000 ????						;	      MAC DEFINE_1K_SEGMENT ; {seg name}
    167  0000 ????						;		  ALIGN $400
    168  0000 ????						;SEGMENT_{1}	  SET *
    169  0000 ????						;BANK_{1}	  SET _CURRENT_BANK
    170  0000 ????						;	      ENDM
    171  0000 ????
    172  0000 ????				      MAC	check_bank_size
    173  0000 ????			   .TEMP      =	* - _BANK_START
    174  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
    175  0000 ????				      IF	( .TEMP ) > _ROM_BANK_SIZE
    176  0000 ????				      ECHO	"BANK OVERFLOW @ ", {1}, " size=", * - ORIGIN
    177  0000 ????				      ERR
    178  0000 ????				      ENDIF
    179  0000 ????				      ENDM		; name
    180  0000 ????
    181  0000 ????				      MAC	check_ram_bank_size
    182  0000 ????			   .TEMP      =	* - _BANK_START
    183  0000 ????				      ECHO	{1}, "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
    184  0000 ????				      IF	( .TEMP ) > _RAM_BANK_SIZE
    185  0000 ????				      ECHO	"BANK OVERFLOW @ ", {1}, " size=", * - ORIGIN
    186  0000 ????				      ERR
    187  0000 ????				      ENDIF
    188  0000 ????				      ENDM		; name
    189  0000 ????
    190  0000 ????						;---------------------------------------------------------------------------------------------------
    191  0000 ????
    192  0000 ????						; Macro inserts a page break if the object would overlap a page
    193  0000 ????
    194  0000 ????				      MAC	optional_pagebreak
    195  0000 ????				      LIST	OFF
    196  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    197  0000 ????			   EARLY_LOCATION SET	*
    198  0000 ????				      ALIGN	256
    199  0000 ????				      IF	VERBOSE=1
    200  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR", {1}
    201  0000 ????				      ECHO	"REQUESTED SIZE =", {2}
    202  0000 ????				      ECHO	"WASTED SPACE =", *-EARLY_LOCATION
    203  0000 ????				      ECHO	"PAGEBREAK LOCATION =", *
    204  0000 ????				      ENDIF
    205  0000 ????				      ENDIF
    206  0000 ????				      LIST	ON
    207  0000 ????				      ENDM		; { string, size }
    208  0000 ????
    209  0000 ????
    210  0000 ????				      MAC	check_page_crossing
    211  0000 ????				      LIST	OFF
    212  0000 ????				      IF	( >BLOCK_END != >BLOCK_START )
    213  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    214  0000 ????				      ENDIF
    215  0000 ????				      LIST	ON
    216  0000 ????				      ENDM
    217  0000 ????
    218  0000 ????				      MAC	checkpage
    219  0000 ????				      LIST	OFF
    220  0000 ????				      IF	>. != >{1}
    221  0000 ????				      ECHO	""
    222  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    223  0000 ????				      ECHO	""
    224  0000 ????				      ERR
    225  0000 ????				      ENDIF
    226  0000 ????				      LIST	ON
    227  0000 ????				      ENDM
    228  0000 ????
    229  0000 ????				      MAC	checkpagex
    230  0000 ????				      LIST	OFF
    231  0000 ????				      IF	>. != >{1}
    232  0000 ????				      ECHO	""
    233  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    234  0000 ????				      ECHO	{2}
    235  0000 ????				      ECHO	""
    236  0000 ????				      ERR
    237  0000 ????				      ENDIF
    238  0000 ????				      LIST	ON
    239  0000 ????				      ENDM
    240  0000 ????
    241  0000 ????						;---------------------------------------------------------------------------------------------------
    242  0000 ????
    243  0000 ????						; Defines a variable of the given size, making sure it doesn't cross a page
    244  0000 ????				      MAC	variable
    245  0000 ????				      OPTIONAL_PAGEBREAK	"Variable", {2}
    246  0000 ????			   {1}	      ds	{2}
    247  0000 ????				      ENDM		; {name, size}
    248  0000 ????
    249  0000 ????
    250  0000 ????						;---------------------------------------------------------------------------------------------------
    251  0000 ????
    252  0000 ????				      MAC	def
    253  0000 ????			   SLOT_{1}   SET	_BANK_SLOT
    254  0000 ????			   BANK_{1}   SET	SLOT_{1} + _CURRENT_BANK	; bank in which this subroutine resides
    255  0000 ????			   {1}			; entry point
    256  0000 ????			   TEMPORARY_VAR SET	Overlay
    257  0000 ????			   TEMPORARY_OFFSET SET	0
    258  0000 ????			   VAR_BOUNDARY_{1} SET	TEMPORARY_OFFSET
    259  0000 ????			   FUNCTION_NAME SET	{1}
    260  0000 ????				      ENDM		; name of subroutine
    261  0000 ????
    262  0000 ????
    263  0000 ????						;---------------------------------------------------------------------------------------------------
    264  0000 ????
    265  0000 ????				      MAC	allocate
    266  0000 ????				      OPTIONAL_PAGEBREAK	"Table", {2}
    267  0000 ????				      DEF	{1}
    268  0000 ????				      ENDM
    269  0000 ????
    270  0000 ????						;---------------------------------------------------------------------------------------------------
    271  0000 ????
    272  0000 ????				      MAC	slot
    273  0000 ????				      IF	({1} < 0) || ({1} > 3)
    274  0000 ????				      ECHO	"Illegal bank address/segment location", {1}
    275  0000 ????				      ERR
    276  0000 ????				      ENDIF
    277  0000 ????			   _BANK_ADDRESS_ORIGIN SET	$F000 + ({1} * _ROM_BANK_SIZE)
    278  0000 ????			   _BANK_SLOT SET	{1} * 64	; D7/D6 selector
    279  0000 ????				      ENDM		; {1}
    280  0000 ????
    281  0000 ????
    282  0000 ????						;---------------------------------------------------------------------------------------------------
    283  0000 ????
    284  0000 ????				      MAC	negeval
    285  0000 ????
    286  0000 ????				      sec
    287  0000 ????				      lda	#0
    288  0000 ????				      sbc	Evaluation
    289  0000 ????				      sta	Evaluation
    290  0000 ????				      lda	#0
    291  0000 ????				      sbc	Evaluation+1
    292  0000 ????				      sta	Evaluation+1
    293  0000 ????				      ENDM
    294  0000 ????
    295  0000 ????
    296  0000 ????				      MAC	swap
    297  0000 ????				      lda	sideToMove
    298  0000 ????				      eor	#SWAP_SIDE
    299  0000 ????				      sta	sideToMove
    300  0000 ????				      ENDM
    301  0000 ????
    302  0000 ????
    303  0000 ????						;---------------------------------------------------------------------------------------------------
    304  0000 ????
    305  0000 ????			   TEMPORARY_OFFSET SET	0
    306  0000 ????
    307  0000 ????
    308  0000 ????				      MAC	vend
    309  0000 ????				      IFNCONST	{1}
    310  0000 ????				      ECHO	"Incorrect VEND label", {1}
    311  0000 ????				      ERR
    312  0000 ????				      ENDIF
    313  0000 ????			   VAREND_{1} =	TEMPORARY_VAR
    314  0000 ????				      ENDM		; {1}
    315  0000 ????
    316  0000 ????
    317  0000 ????				      MAC	refer
    318  0000 ????				      IF	VAREND_{1} > TEMPORARY_VAR
    319  0000 ????			   TEMPORARY_VAR SET	VAREND_{1}
    320  0000 ????				      ENDIF
    321  0000 ????				      ENDM		; {1}
    322  0000 ????
    323  0000 ????
    324  0000 ????
    325  0000 ????						; Define a temporary variable for use in a subroutine
    326  0000 ????						; Will allocate appropriate bytes, and also check for overflow of the available overlay buffer
    327  0000 ????
    328  0000 ????				      MAC	var
    329  0000 ????			   {1}	      =	TEMPORARY_VAR
    330  0000 ????			   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + {2}
    331  0000 ????
    332  0000 ????			   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
    333  0000 ????				      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
    334  0000 ????			   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
    335  0000 ????				      ENDIF
    336  0000 ????				      IF	OVERLAY_DELTA > OVERLAY_SIZE
    337  0000 ????				      ECHO	"Temporary Variable", {1}, "overflow!"
    338  0000 ????				      ERR
    339  0000 ????				      ENDIF
    340  0000 ????				      LIST	ON
    341  0000 ????				      ENDM		; { name, size }
    342  0000 ????
    343  0000 ????
    344  0000 ????						;---------------------------------------------------------------------------------------------------
    345  0000 ????
    346  0000 ????				      MAC	tag
    347  0000 ????						; {0}
    348  0000 ????				      ENDM		; {ident/tag}
    349  0000 ????
    350  0000 ????						;---------------------------------------------------------------------------------------------------
    351  0000 ????
    352  0000 ????				      MAC	sta@ram
    353  0000 ????				      sta	[RAM]+{0}
    354  0000 ????				      ENDM		;{}
    355  0000 ????
    356  0000 ????				      MAC	stx@ram
    357  0000 ????				      stx	[RAM]+{0}
    358  0000 ????				      ENDM
    359  0000 ????
    360  0000 ????				      MAC	sty@ram
    361  0000 ????				      sty	[RAM]+{0}
    362  0000 ????				      ENDM
    363  0000 ????
    364  0000 ????				      MAC	sta@ply
    365  0000 ????				      sta	[RAM]+{0}
    366  0000 ????				      ENDM		;{}
    367  0000 ????
    368  0000 ????				      MAC	stx@ply
    369  0000 ????				      stx	[RAM]+{0}
    370  0000 ????				      ENDM
    371  0000 ????
    372  0000 ????				      MAC	sty@ply
    373  0000 ????				      sty	[RAM]+{0}
    374  0000 ????				      ENDM
    375  0000 ????
    376  0000 ????
    377  0000 ????				      MAC	lda@ram
    378  0000 ????				      lda	{0}
    379  0000 ????				      ENDM		;{}
    380  0000 ????
    381  0000 ????				      MAC	ldx@ram
    382  0000 ????				      ldx	{0}
    383  0000 ????				      ENDM		;{}
    384  0000 ????
    385  0000 ????				      MAC	ldy@ram
    386  0000 ????				      ldy	{0}
    387  0000 ????				      ENDM		;{}
    388  0000 ????
    389  0000 ????
    390  0000 ????				      MAC	lda@ply
    391  0000 ????				      lda	{0}
    392  0000 ????				      ENDM		;{}
    393  0000 ????
    394  0000 ????				      MAC	ldx@ply
    395  0000 ????				      ldx	{0}
    396  0000 ????				      ENDM		;{}
    397  0000 ????
    398  0000 ????				      MAC	ldy@ply
    399  0000 ????				      ldy	{0}
    400  0000 ????				      ENDM		;{}
    401  0000 ????
    402  0000 ????
    403  0000 ????				      MAC	adc@ply
    404  0000 ????				      adc	{0}
    405  0000 ????				      ENDM		;{}
    406  0000 ????
    407  0000 ????				      MAC	sbc@ply
    408  0000 ????				      sbc	{0}
    409  0000 ????				      ENDM		;{}
    410  0000 ????
    411  0000 ????				      MAC	cmp@ply
    412  0000 ????				      cmp	{0}
    413  0000 ????				      ENDM		;{}
    414  0000 ????
    415  0000 ????						;---------------------------------------------------------------------------------------------------
    416  0000 ????
    417  0000 ????				      MAC	newrambank
    418  0000 ????						; {1}	     bank name
    419  0000 ????						; {2}	     RAM bank number
    420  0000 ????
    421  0000 ????				      SEG.U	{1}
    422  0000 ????				      ORG	ORIGIN_RAM
    423  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    424  0000 ????			   _BANK_START SET	*
    425  0000 ????			   RAMBANK_{1} SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
    426  0000 ????			   _CURRENT_RAMBANK SET	RAMBANK_{1}
    427  0000 ????			   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    428  0000 ????				      ENDM		; bank name
    429  0000 ????
    430  0000 ????						;---------------------------------------------------------------------------------------------------
    431  0000 ????
    432  0000 ????				      MAC	resync
    433  0000 ????						; resync screen, X and Y == 0 afterwards
    434  0000 ????				      lda	#%10	; make sure VBLANK is ON
    435  0000 ????				      sta	VBLANK
    436  0000 ????
    437  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    438  0000 ????			   .loopResync
    439  0000 ????				      VERTICAL_SYNC
    440  0000 ????
    441  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    442  0000 ????				      lda	Platform
    443  0000 ????				      eor	#PAL_50	; PAL-50?
    444  0000 ????				      bne	.ntsc
    445  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    446  0000 ????			   .ntsc
    447  0000 ????			   .loopWait
    448  0000 ????				      sta	WSYNC
    449  0000 ????				      sta	WSYNC
    450  0000 ????				      dey
    451  0000 ????				      bne	.loopWait
    452  0000 ????				      dex
    453  0000 ????				      bne	.loopResync
    454  0000 ????				      ENDM
    455  0000 ????
    456  0000 ????				      MAC	set_platform
    457  0000 ????						; 00 = NTSC
    458  0000 ????						; 01 = NTSC
    459  0000 ????						; 10 = PAL-50
    460  0000 ????						; 11 = PAL-60
    461  0000 ????				      lda	SWCHB
    462  0000 ????				      rol
    463  0000 ????				      rol
    464  0000 ????				      rol
    465  0000 ????				      and	#%11
    466  0000 ????				      eor	#PAL
    467  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    468  0000 ????				      ENDM
    469  0000 ????
    470  0000 ????
    471  0000 ????						;---------------------------------------------------------------------------------------------------
    472  0000 ????
    473  0000 ????						;    MAC JSROM_SAFE ; {routine}
    474  0000 ????						;    ; Saves bank of routine to variable for later restore.
    475  0000 ????						;    ; Switches to the bank and does a JSR to the routine.
    476  0000 ????
    477  0000 ????						;		  lda #BANK_{1}
    478  0000 ????						;		  sta savedBank
    479  0000 ????						;		  sta SET_BANK
    480  0000 ????						;		  jsr {1}
    481  0000 ????						;    ENDM
    482  0000 ????
    483  0000 ????
    484  0000 ????						;    MAC JSROM ; {routine}
    485  0000 ????
    486  0000 ????						;		  lda #BANK_{1}
    487  0000 ????						;		  sta SET_BANK
    488  0000 ????						;		  jsr {1}
    489  0000 ????						;    ENDM
    490  0000 ????
    491  0000 ????
    492  0000 ????						;    MAC JSRAM
    493  0000 ????						;		  lda #BANK_{1}
    494  0000 ????						;		  sta SET_BANK_RAM
    495  0000 ????						;		  jsr {1}
    496  0000 ????						;    ENDM
    497  0000 ????
    498  0000 ????
    499  0000 ????
    500  0000 ????				      MAC	timecheck
    501  0000 ????				      lda	INTIM
    502  0000 ????				      cmp	#SPEEDOF_{1}
    503  0000 ????				      bcc	{2}
    504  0000 ????				      ENDM		; {ident}, {branch if out of time}
    505  0000 ????
    506  0000 ????
    507  0000 ????				      MAC	timing
    508  0000 ????			   SPEEDOF_{1} =	({2}/64) + 1
    509  0000 ????				      ENDM		; {label}, {cycles}
    510  0000 ????
    511  0000 ????
    512  0000 ????						;---------------------------------------------------------------------------------------------------
    513  0000 ????
    514  0000 ????						; Failsafe call of function in another bank
    515  0000 ????						; This will check the slot #s for current, call to make sure they're not the same!
    516  0000 ????
    517  0000 ????				      MAC	call
    518  0000 ????				      IF	SLOT_{1} == _BANK_SLOT
    519  0000 ????				      ECHO	"ERROR: Incompatible call to function requiring same slot..."
    520  0000 ????				      ECHO	"Cannot switch bank in use for", {0}
    521  0000 ????				      ERR
    522  0000 ????				      ENDIF
    523  0000 ????				      lda	#BANK_{1}
    524  0000 ????				      sta	SET_BANK
    525  0000 ????				      jsr	{1}
    526  0000 ????				      ENDM		; function name
    527  0000 ????
    528  0000 ????
    529  0000 ????
    530  0000 ????						;---------------------------------------------------------------------------------------------------
    531  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						; Chess
      2  0000 ????						; Atari 2600 Chess display system
      3  0000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  0000 ????						; andrew@taswegian.com
      5  0000 ????
      6 U00fa ????				      SEG.U	variables
      7 U0080					      ORG	$80
      8 U0080
      9 U0080		       00	   squareToDraw ds	1
     10 U0081		       00	   rnd	      ds	1	; random
     11 U0082		       00	   drawDelay  ds	1
     12 U0083		       00	   lastSquareX12 ds	1
     13 U0084
     14 U0084		       00	   drawCount  ds	1
     15 U0085		       00	   fromX12    ds	1
     16 U0086		       00	   toX12      ds	1
     17 U0087		       00	   originX12  ds	1
     18 U0088
     19 U0088		       00	   cursorX12  ds	1
     20 U0089
     21 U0089		       00	   mdelay     ds	1
     22 U008a		       00	   ccur       ds	1
     23 U008b		       00	   savedBank  ds	1	; switched-in bank for FIXED returns
     24 U008c		       00	   aiState    ds	1	; state
     25 U008d		       00	   aiFlashDelay ds	1
     26 U008e
     27 U008e		       00	   aiMoveIndex ds	1
     28 U008f
     29 U008f		       00	   aiFlashPhase ds	1
     30 U0090
     31 U0090		       00 00	   Evaluation ds	2	; tracks value of the board position
     32 U0092
     33 U0092		       00	   currentPiece ds	1
     34 U0093		       00	   currentSquare ds	1
     35 U0094		       00	   enPassantPawn ds	1	; TODO - this belongs in PLY bank
     36 U0095		       00	   currentPly ds	1
     37 U0096
     38 U0096		       00	   sideToMove ds	1	; d7 == side, 0=white, 128 = black
     39 U0097		       00	   fromPiece  ds	1
     40 U0098		       00	   lastPiece  ds	1
     41 U0099		       00	   previousPiece ds	1
     42 U009a
     43 U009a		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     44 U009b		       00 00	   speech_addr ds	2
     45 U009d		       00	   bg	      ds	1
     46 U009e
     47 U009e		       00	   capture    ds	1
     48 U009f
     49 U009f				  -	      IF	DIAGNOSTICS
     50 U009f				  -positionCount ds	3
     51 U009f					      ENDIF
     52 U009f
     53 U009f							;maxPly			  ds 1
     54 U009f		       00	   flagCheck  ds	1	; -1 = no, #KING = yes
     55 U00a0		       00	   protecting ds	1
     56 U00a1		       00	   randomness ds	1
------- FILE ./chess.asm
------- FILE overlays.asm LEVEL 2 PASS 4
      0 U00a2					      include	"overlays.asm"
      1 U00a2							; Chess
      2 U00a2							; Atari 2600 Chess display system
      3 U00a2							; Copyright (c) 2019-2020 Andrew Davie
      4 U00a2							; andrew@taswegian.com
      5 U00a2
      6 U00a2							;---------------------------------------------------------------------------------------------------
      7 U00a2							; OVERLAYS!
      8 U00a2							; These variables are overlays, and should be managed with care
      9 U00a2							; They co-exist (each "OVERLAY" starts at the zero-page variable "Overlay"
     10 U00a2							; and thus, overlays cannot be used at the same time (that is, you cannot
     11 U00a2							; use a variable in overlay #1 while at the same time using a variable in
     12 U00a2							; overlay #2
     13 U00a2
     14 U00a2							; for clarity, prefix ALL overlay variables with double-underscore (__)
     15 U00a2
     16 U00a2							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
     17 U00a2							; ensure this by using the VALIDATE_OVERLAY macro
     18 U00a2							;---------------------------------------------------------------------------------------------------
     19 U00a2
     20 U00a2					      MAC	overlay
     21 U00a2				   OVERLAY_NAME SET	{1}
     22 U00a2					      SEG.U	OVERLAY_{1}
     23 U00a2					      org	Overlay
     24 U00a2					      ENDM		; {name}
     25 U00a2
     26 U00a2							;---------------------------------------------------------------------------------------------------
     27 U00a2
     28 U00a2					      MAC	validate_overlay
     29 U00a2					      LIST	OFF
     30 U00a2				   OVERLAY_DELTA SET	* - Overlay
     31 U00a2					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
     32 U00a2				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
     33 U00a2					      ENDIF
     34 U00a2					      IF	OVERLAY_DELTA > OVERLAY_SIZE
     35 U00a2					      ECHO	"Overlay", OVERLAY_NAME, "is too big!"
     36 U00a2					      ECHO	"REQUIRED SIZE =", OVERLAY_DELTA
     37 U00a2					      ERR
     38 U00a2					      ENDIF
     39 U00a2					      LIST	ON
     40 U00a2					      ECHO	OVERLAY_NAME, "-", OVERLAY_SIZE - ( * - Overlay ), "bytes available"
     41 U00a2					      ENDM
     42 U00a2
     43 U00a2							;---------------------------------------------------------------------------------------------------
     44 U00a2
     45 U00a2				   OVERLAY_SIZE SET	$4C	; maximum size
     46 U00a2				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	0
     47 U00a2
     48 U00a2
     49 U00a2							; This overlay variable is used for the overlay variables.  That's OK.
     50 U00a2							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
     51 U00a2							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
     52 U00a2							; (especially the latter ones) are only used in rare occasions.
     53 U00a2
     54 U00a2							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
     55 U00a2							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
     56 U00a2
      0 U00a2					      DEF	Overlay
      1 U00a2				   SLOT_Overlay SET	_BANK_SLOT
      2 U00a2				   BANK_Overlay SET	SLOT_Overlay + _CURRENT_BANK
      3 U00a2				   Overlay
      4 U00a2				   TEMPORARY_VAR SET	Overlay
      5 U00a2				   TEMPORARY_OFFSET SET	0
      6 U00a2				   VAR_BOUNDARY_Overlay SET	TEMPORARY_OFFSET
      7 U00a2				   FUNCTION_NAME SET	Overlay
     58 U00a2		       00 00 00 00*	      ds	OVERLAY_SIZE	;--> overlay (share) variables
     59 U00ee				   END_OF_OVERLAY
     60 U00ee
     61 U00ee							;---------------------------------------------------------------------------------------------------
     62 U00ee							; And now... the overlays....
     63 U00ee
 ---- OVERLAYS ( $4c bytes ) ----
     64 U00ee					      ECHO	"---- OVERLAYS (", OVERLAY_SIZE, "bytes ) ----"
     65 U00ee
     66 U00ee							;---------------------------------------------------------------------------------------------------
     67 U00ee
     68 U00ee							; Some overlays are used across multiple routines/calls, and they will need to be defined
     69 U00ee							; "globally" in this file.
     70 U00ee
      0 U00ee					      VAR	__pieceShapeBuffer, PIECE_SHAPE_SIZE
      1 U00ee		       00 a2	   __pieceShapeBuffer =	TEMPORARY_VAR
      2 U00ee				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + PIECE_SHAPE_SIZE
      3 U00ee
      4 U00ee				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00ee					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00ee				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00ee					      ENDIF
      8 U00ee				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00ee				  -	      ECHO	"Temporary Variable", __pieceShapeBuffer, "overflow!"
     10 U00ee				  -	      ERR
     11 U00ee					      ENDIF
     12 U00ee					      LIST	ON
      0 U00ee					      VAR	__ptr, 2
      1 U00ee		       00 ea	   __ptr      =	TEMPORARY_VAR
      2 U00ee				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3 U00ee
      4 U00ee				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00ee					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00ee				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00ee					      ENDIF
      8 U00ee				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00ee				  -	      ECHO	"Temporary Variable", __ptr, "overflow!"
     10 U00ee				  -	      ERR
     11 U00ee					      ENDIF
     12 U00ee					      LIST	ON
      0 U00ee					      VAR	__ptr2, 2
      1 U00ee		       00 ec	   __ptr2     =	TEMPORARY_VAR
      2 U00ee				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3 U00ee
      4 U00ee				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00ee					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00ee				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00ee					      ENDIF
      8 U00ee				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00ee				  -	      ECHO	"Temporary Variable", __ptr2, "overflow!"
     10 U00ee				  -	      ERR
     11 U00ee					      ENDIF
     12 U00ee					      LIST	ON
     74 U00ee
     75 U00ee							;---------------------------------------------------------------------------------------------------
     76 U00ee
     77 U00ee
     78 U00ee					      ORG	END_OF_OVERLAY
 ---- END OF OVERLAYS ----
     79 U00ee					      ECHO	"---- END OF OVERLAYS ----"
 MAXIMUM OVERLAY SIZE NEEDED =  $4c
     80 U00ee					      ECHO	"MAXIMUM OVERLAY SIZE NEEDED = ", MAXIMUM_REQUIRED_OVERLAY_SIZE
     81 U00ee
     82 U00ee							;EOF
------- FILE ./chess.asm
------- FILE stack.asm LEVEL 2 PASS 4
      0 U00ee					      include	"stack.asm"
      1 U00ee							; Chess
      2 U00ee							; Atari 2600 Chess display system
      3 U00ee							; Copyright (c) 2019-2020 Andrew Davie
      4 U00ee							; andrew@taswegian.com
      5 U00ee
      6 U00ee
      7 U00ee		       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
      8 U00ee
      9 U00ee		       00 00 00 00*	      ds	RESERVED_FOR_STACK
     10 U00fa
     11 U00fa							; WARNING/NOTE - the alphabeta search violates the above size constraints
     12 U00fa							; HOWEVER, the "OVERLAY" segment is beneath this, and will be stomped, depending on # plys
     13 U00fa							;  but since overlay is not generally stressed during alphabeta, we're good.
------- FILE ./chess.asm
    535 U00fa
 FREE BYTES IN ZERO PAGE =  $5
    536 U00fa					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    537 U00fa				  -	      IF	* > $FF
    538 U00fa				  -	      ERR	"Zero Page overflow!"
    539 U00fa					      ENDIF
    540 U00fa
    541 U00fa							;------------------------------------------------------------------------------
    542 U00fa							;##############################################################################
    543 U00fa							;------------------------------------------------------------------------------
    544 U00fa
    545 U00fa							; NOW THE VERY INTERESTING '3E' RAM BANKS
    546 U00fa							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 512 bytes TOTAL ACCESSIBLE
    547 U00fa							; IN A 1K MEMORY SPACE
    548 U00fa
      0 U00fa					      SLOT	0
      1 U00fa				  -	      IF	(0 < 0) || (0 > 3)
      2 U00fa				  -	      ECHO	"Illegal bank address/segment location", 0
      3 U00fa				  -	      ERR
      4 U00fa					      ENDIF
      5 U00fa				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      6 U00fa				   _BANK_SLOT SET	0 * 64
      0 U00fa					      NEWRAMBANK	CHESS_BOARD_ROW
      1 U00fa
      2 U00fa
      3 U00fa
      4 U0000 ????				      SEG.U	CHESS_BOARD_ROW
      5 U0000					      ORG	ORIGIN_RAM
      6 U0000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0000				   _BANK_START SET	*
      8 U0000				   RAMBANK_CHESS_BOARD_ROW SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0000				   _CURRENT_RAMBANK SET	RAMBANK_CHESS_BOARD_ROW
     10 U0000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U0000					      REPEAT	(CHESSBOARD_ROWS) - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U0000
      2 U0000
      3 U0000
      4 U0e00 ????				      SEG.U	.DUMMY
      5 U0200					      ORG	ORIGIN_RAM
      6 U0200					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0200				   _BANK_START SET	*
      8 U0200				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0200				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0200				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U0200					      REPEND
      0 U0200					      NEWRAMBANK	.DUMMY
      1 U0200
      2 U0200
      3 U0200
      4 U0200					      SEG.U	.DUMMY
      5 U0400					      ORG	ORIGIN_RAM
      6 U0400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0400				   _BANK_START SET	*
      8 U0400				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400
      2 U0400
      3 U0400
      4 U0400					      SEG.U	.DUMMY
      5 U0600					      ORG	ORIGIN_RAM
      6 U0600					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0600				   _BANK_START SET	*
      8 U0600				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0600				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0600				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U0600					      REPEND
      0 U0600					      NEWRAMBANK	.DUMMY
      1 U0600
      2 U0600
      3 U0600
      4 U0600					      SEG.U	.DUMMY
      5 U0800					      ORG	ORIGIN_RAM
      6 U0800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0800				   _BANK_START SET	*
      8 U0800				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800
      2 U0800
      3 U0800
      4 U0800					      SEG.U	.DUMMY
      5 U0a00					      ORG	ORIGIN_RAM
      6 U0a00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0a00				   _BANK_START SET	*
      8 U0a00				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0a00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0a00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U0a00					      REPEND
      0 U0a00					      NEWRAMBANK	.DUMMY
      1 U0a00
      2 U0a00
      3 U0a00
      4 U0a00					      SEG.U	.DUMMY
      5 U0c00					      ORG	ORIGIN_RAM
      6 U0c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0c00				   _BANK_START SET	*
      8 U0c00				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00
      2 U0c00
      3 U0c00
      4 U0c00					      SEG.U	.DUMMY
      5 U0e00					      ORG	ORIGIN_RAM
      6 U0e00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0e00				   _BANK_START SET	*
      8 U0e00				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0e00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0e00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    553 U0e00					      REPEND
    554 U0e00
    555 U0e00							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    556 U0e00							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    557 U0e00							; The variable definitions are also in that ROM bank (even though they're RAM :)
    558 U0e00
    559 U0e00							; Now we have the actual graphics data for each of the rows.  This consists of an
    560 U0e00							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    561 U0e00							; character shapes are masked/copied. The depth of the character shapes may be
    562 U0e00							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    563 U0e00							; a multiple of 3, so that the RGB scanlines match at character joins.
    564 U0e00
    565 U0e00							; We have one bank for each chessboard row.  These banks are duplicates of the above,
    566 U0e00							; accessed via the above labels but with the appropriate bank switched in.
    567 U0e00
    568 U0e00							;---------------------------------------------------------------------------------------------------
    569 U0e00
    570 U0e00
    571 U0e00		       00 fe	   RND_EOR_VAL =	$FE	;B4
    572 U0e00
    573 U0e00					      MAC	next_random
    574 U0e00					      lda	rnd
    575 U0e00					      lsr
    576 U0e00					      bcc	.skipEOR
    577 U0e00					      eor	#RND_EOR_VAL
    578 U0e00				   .skipEOR   sta	rnd
    579 U0e00					      ENDM
    580 U0e00
    581 U0e00							;--------------------------------------------------------------------------------
    582 U0e00
    583 U0e00					      MAC	phase
    584 U0e00					      lda	#{1}
    585 U0e00					      sta	aiState
    586 U0e00					      ENDM		;#
    587 U0e00
    588 U0e00
    589 U0e00							;--------------------------------------------------------------------------------
    590 U0e00
    591 U0e00					      MAC	common_vars_alphabeta
    592 U0e00
    593 U0e00					      VAR	__thinkbar, 1
    594 U0e00					      VAR	__toggle, 1
    595 U0e00
    596 U0e00					      VAR	__bestMove, 1
    597 U0e00					      VAR	__alpha, 2
    598 U0e00					      VAR	__beta, 2
    599 U0e00					      VAR	__negaMax, 2
    600 U0e00					      VAR	__value, 2
    601 U0e00
    602 U0e00					      VAR	__quiesceCapOnly, 1
    603 U0e00
    604 U0e00					      ENDM
    605 U0e00
    606 U0e00
    607 U0e00							;---------------------------------------------------------------------------------------------------
    608 U0e00
------- FILE BANK_FIRST@0.asm LEVEL 2 PASS 4
      0 U0e00					      include	"BANK_FIRST@0.asm"	; MUST be first in ROM - contains reset vectors
      1 U0e00							; Chess
      2 U0e00							; Copyright (c) 2019-2020 Andrew Davie
      3 U0e00							; andrew@taswegian.com
      4 U0e00
      5 U0e00
      6 U0e00							; SLOT0 - screen draw, state machine dispatcher
      7 U0e00							; SLOT1 - anything
      8 U0e00							; SLOT2 - moves/ply
      9 U0e00							; SLOT3 - board
     10 U0e00
     11 U0e00
     12 U0e00
     13 U0e00
     14 U0e00
     15 U0e00
      0 U0e00					      SLOT	0
      1 U0e00				  -	      IF	(0 < 0) || (0 > 3)
      2 U0e00				  -	      ECHO	"Illegal bank address/segment location", 0
      3 U0e00				  -	      ERR
      4 U0e00					      ENDIF
      5 U0e00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      6 U0e00				   _BANK_SLOT SET	0 * 64
     17 U0e00
     18 U0e00							;---------------------------------------------------------------------------------------------------
     19 U0e00							;#########################################  FIXED BANK  ############################################
     20 U0e00							;---------------------------------------------------------------------------------------------------
     21 U0e00
     22 U0e00				   _ORIGIN    SET	_FIRST_BANK
     23 U0e00
      0 U0e00					      NEWBANK	THE_FIRST_BANK
      1  01f9 ????				      SEG	THE_FIRST_BANK
      2  0000					      ORG	_ORIGIN
      3  0000					      RORG	_BANK_ADDRESS_ORIGIN
      4  0000				   _BANK_START SET	*
      5  0000				   THE_FIRST_BANK_START SET	*
      6  0000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0000				   THE_FIRST_BANK SET	_BANK_SLOT + _CURRENT_BANK
      8  0000				   _ORIGIN    SET	_ORIGIN + 1024
     25  0000					      RORG	$f000
     26  0000
     27  0000							;---------------------------------------------------------------------------------------------------
     28  0000
      0  0000					      DEF	StartupBankReset
      1  0000				   SLOT_StartupBankReset SET	_BANK_SLOT
      2  0000				   BANK_StartupBankReset SET	SLOT_StartupBankReset + _CURRENT_BANK
      3  0000				   StartupBankReset
      4  0000				   TEMPORARY_VAR SET	Overlay
      5  0000				   TEMPORARY_OFFSET SET	0
      6  0000				   VAR_BOUNDARY_StartupBankReset SET	TEMPORARY_OFFSET
      7  0000				   FUNCTION_NAME SET	StartupBankReset
     30  0000					      SUBROUTINE
     31  0000
      0  0000					      VEND	StartupBankReset
      1  0000				  -	      IFNCONST	StartupBankReset
      2  0000				  -	      ECHO	"Incorrect VEND label", StartupBankReset
      3  0000				  -	      ERR
      4  0000					      ENDIF
      5  0000		       00 a2	   VAREND_StartupBankReset =	TEMPORARY_VAR
     33  0000
     34  0000							; On startup, 3E+ switches banks 0 and 3 to the 1st ROM bank (1K), from which the reset
     35  0000							; vector is obtained from bank 0 (+$FFC). Chess3E+ (maybe) will leave this bank (3) alone
     36  0000							; so that a system reset will always have the reset vectors available at FFFC, where expected
     37  0000
     38  0000		       a2 ff		      ldx	#$FF
     39  0002		       9a		      txs
     40  0003
      0  0003					      CALL	CartInit
      1  0003				  -	      IF	SLOT_CartInit == _BANK_SLOT
      2  0003				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0003				  -	      ECHO	"Cannot switch bank in use for", CartInit
      4  0003				  -	      ERR
      5  0003					      ENDIF
      6  0003		       a9 41		      lda	#BANK_CartInit
      7  0005		       85 3f		      sta	SET_BANK
      8  0007		       20 00 f4 	      jsr	CartInit
      0  000a					      CALL	SetupBanks
      1  000a				  -	      IF	SLOT_SetupBanks == _BANK_SLOT
      2  000a				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  000a				  -	      ECHO	"Cannot switch bank in use for", SetupBanks
      4  000a				  -	      ERR
      5  000a					      ENDIF
      6  000a		       a9 41		      lda	#BANK_SetupBanks
      7  000c		       85 3f		      sta	SET_BANK
      8  000e		       20 3a f4 	      jsr	SetupBanks
      0  0011					      CALL	InitialisePieceSquares
      1  0011				  -	      IF	SLOT_InitialisePieceSquares == _BANK_SLOT
      2  0011				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0011				  -	      ECHO	"Cannot switch bank in use for", InitialisePieceSquares
      4  0011				  -	      ERR
      5  0011					      ENDIF
      6  0011		       a9 41		      lda	#BANK_InitialisePieceSquares
      7  0013		       85 3f		      sta	SET_BANK
      8  0015		       20 cb f4 	      jsr	InitialisePieceSquares
     44  0018							;jsr ListPlayerMoves;@0
     45  0018
     46  0018
     47  0018				   .StartFrame
     48  0018
     49  0018
     50  0018							; START OF FRAME
     51  0018
     52  0018		       a9 0e		      lda	#%1110	; VSYNC ON
     53  001a		       85 42	   .loopVSync3 sta	WSYNC
     54  001c		       85 40		      sta	VSYNC
     55  001e		       4a		      lsr
     56  001f		       d0 f9		      bne	.loopVSync3	; branch until VYSNC has been reset
     57  0021
     58  0021		       85 41		      sta	VBLANK
     59  0023
     60  0023		       a0 2e		      ldy	#TIME_PART_1
     61  0025		       8c 96 02 	      sty	TIM64T
     62  0028
     63  0028							; LOTS OF PROCESSING TIME - USE IT
     64  0028
     65  0028
     66  0028
     67  0028		       20 52 f1 	      jsr	AiStateMachine
     68  002b
     69  002b				  -	      IF	ASSERTS
     70  002b				  -			; Catch timer expired already
     71  002b				  -			;		      bit TIMINT
     72  002b				  -			;.whoops	      bmi .whoops
     73  002b					      ENDIF
     74  002b
     75  002b
     76  002b		       2c 85 02    .wait      bit	TIMINT
     77  002e		       10 fb		      bpl	.wait
     78  0030
     79  0030
     80  0030							; START OF VISIBLE SCANLINES
     81  0030
     82  0030
      0  0030					      CALL	longD
      1  0030				  -	      IF	SLOT_longD == _BANK_SLOT
      2  0030				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0030				  -	      ECHO	"Cannot switch bank in use for", longD
      4  0030				  -	      ERR
      5  0030					      ENDIF
      6  0030		       a9 94		      lda	#BANK_longD
      7  0032		       85 3f		      sta	SET_BANK
      8  0034		       20 20 f8 	      jsr	longD
     84  0037
     85  0037
     86  0037		       a2 80		      ldx	#SLOT_DrawRow	; + BANK_DrawRow
     87  0039		       86 3e		      stx	SET_BANK_RAM
     88  003b		       20 03 f9 	      jsr	DrawRow	; draw the ENTIRE visible screen!
     89  003e
      0  003e					      CALL	tidySc
      1  003e				  -	      IF	SLOT_tidySc == _BANK_SLOT
      2  003e				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  003e				  -	      ECHO	"Cannot switch bank in use for", tidySc
      4  003e				  -	      ERR
      5  003e					      ENDIF
      6  003e		       a9 94		      lda	#BANK_tidySc
      7  0040		       85 3f		      sta	SET_BANK
      8  0042		       20 0c f8 	      jsr	tidySc
     91  0045
     92  0045		       20 52 f1 	      jsr	AiStateMachine
     93  0048
     94  0048		       ad 84 02 	      lda	INTIM
     95  004b		       c9 14		      cmp	#20
     96  004d		       90 1c		      bcc	.notnow
     97  004f
     98  004f							;CALL GameSpeak
      0  004f					      CALL	PositionSprites
      1  004f				  -	      IF	SLOT_PositionSprites == _BANK_SLOT
      2  004f				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  004f				  -	      ECHO	"Cannot switch bank in use for", PositionSprites
      4  004f				  -	      ERR
      5  004f					      ENDIF
      6  004f		       a9 49		      lda	#BANK_PositionSprites
      7  0051		       85 3f		      sta	SET_BANK
      8  0053		       20 00 f5 	      jsr	PositionSprites
    100  0056
    101  0056
    102  0056					      IF	1
    103  0056							; "draw" sprite shapes into row banks
    104  0056
    105  0056		       a2 07		      ldx	#7
    106  0058		       8a	   zapem      txa
    107  0059		       18		      clc
    108  005a		       69 80		      adc	#SLOT_DrawRow
    109  005c		       85 3e		      sta	SET_BANK_RAM
    110  005e		       20 6f fc 	      jsr	WriteBlank	;@3
    111  0061		       ca		      dex
    112  0062		       10 f4		      bpl	zapem
    113  0064
    114  0064		       a9 c3		      lda	#BANK_WriteCursor
    115  0066		       85 3f		      sta	SET_BANK
    116  0068		       20 98 fc 	      jsr	WriteCursor	;@3
    117  006b					      ENDIF
    118  006b
    119  006b				   .notnow
    120  006b
    121  006b		       2c 85 02    .waitTime  bit	TIMINT
    122  006e		       10 fb		      bpl	.waitTime
    123  0070
    124  0070		       4c 18 f0 	      jmp	.StartFrame
    125  0073
    126  0073
    127  0073							;---------------------------------------------------------------------------------------------------
    128  0073
      0  0073					      DEF	ThinkBar
      1  0073				   SLOT_ThinkBar SET	_BANK_SLOT
      2  0073				   BANK_ThinkBar SET	SLOT_ThinkBar + _CURRENT_BANK
      3  0073				   ThinkBar
      4  0073				   TEMPORARY_VAR SET	Overlay
      5  0073				   TEMPORARY_OFFSET SET	0
      6  0073				   VAR_BOUNDARY_ThinkBar SET	TEMPORARY_OFFSET
      7  0073				   FUNCTION_NAME SET	ThinkBar
    130  0073					      SUBROUTINE
    131  0073
    132  0073				  -	      IF	DIAGNOSTICS
    133  0073				  -
    134  0073				  -	      inc	positionCount
    135  0073				  -	      bne	.p1
    136  0073				  -	      inc	positionCount+1
    137  0073				  -	      bne	.p1
    138  0073				  -	      inc	positionCount+2
    139  0073				  -.p1
    140  0073					      ENDIF
    141  0073
    142  0073							; The 'thinkbar' pattern...
    143  0073
    144  0073		       a9 00		      lda	#0
    145  0075		       a4 4c		      ldy	INPT4
    146  0077		       30 0a		      bmi	.doThink
    147  0079
    148  0079		       e6 a2		      inc	__thinkbar
    149  007b		       a5 a2		      lda	__thinkbar
    150  007d		       29 0f		      and	#15
    151  007f		       a8		      tay
    152  0080		       b9 88 f0 	      lda	SynapsePattern,y
    153  0083
    154  0083		       85 4f	   .doThink   sta	PF2
    155  0085		       85 4e		      sta	PF1
    156  0087		       60		      rts
    157  0088
    158  0088
    159  0088
    160  0088				   SynapsePattern
    161  0088
    162  0088		       c1		      .byte.b	%11000001
    163  0089		       60		      .byte.b	%01100000
    164  008a		       30		      .byte.b	%00110000
    165  008b		       18		      .byte.b	%00011000
    166  008c		       0c		      .byte.b	%00001100
    167  008d		       06		      .byte.b	%00000110
    168  008e		       83		      .byte.b	%10000011
    169  008f		       c1		      .byte.b	%11000001
    170  0090
    171  0090		       83		      .byte.b	%10000011
    172  0091		       06		      .byte.b	%00000110
    173  0092		       0c		      .byte.b	%00001100
    174  0093		       18		      .byte.b	%00011000
    175  0094		       30		      .byte.b	%00110000
    176  0095		       60		      .byte.b	%01100000
    177  0096		       c1		      .byte.b	%11000001
    178  0097		       83		      .byte.b	%10000011
    179  0098
    180  0098
    181  0098							;---------------------------------------------------------------------------------------------------
    182  0098
      0  0098					      DEF	CopySinglePiece	;@0 - uses @2
      1  0098				   SLOT_CopySinglePiece SET	_BANK_SLOT
      2  0098				   BANK_CopySinglePiece SET	SLOT_CopySinglePiece + _CURRENT_BANK
      3  0098				   CopySinglePiece
      4  0098				   TEMPORARY_VAR SET	Overlay
      5  0098				   TEMPORARY_OFFSET SET	0
      6  0098				   VAR_BOUNDARY_CopySinglePiece SET	TEMPORARY_OFFSET
      7  0098				   FUNCTION_NAME SET	CopySinglePiece
    184  0098					      SUBROUTINE
      0  0098					      TIMING	COPYSINGLEPIECE, (2600)
      1  0098		       00 29	   SPEEDOF_COPYSINGLEPIECE =	((2600)/64) + 1
    186  0098
      0  0098					      REFER	aiDrawEntireBoard
      1  0098				  -	      IF	VAREND_aiDrawEntireBoard > TEMPORARY_VAR
      2  0098				  -TEMPORARY_VAR SET	VAREND_aiDrawEntireBoard
      3  0098					      ENDIF
      0  0098					      REFER	aiSpecialMoveFixup
      1  0098					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  0098				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  0098					      ENDIF
      0  0098					      REFER	aiWriteStartPieceBlank
      1  0098				  -	      IF	VAREND_aiWriteStartPieceBlank > TEMPORARY_VAR
      2  0098				  -TEMPORARY_VAR SET	VAREND_aiWriteStartPieceBlank
      3  0098					      ENDIF
      0  0098					      REFER	aiDrawPart2
      1  0098				  -	      IF	VAREND_aiDrawPart2 > TEMPORARY_VAR
      2  0098				  -TEMPORARY_VAR SET	VAREND_aiDrawPart2
      3  0098					      ENDIF
      0  0098					      REFER	aiMarchB
      1  0098				  -	      IF	VAREND_aiMarchB > TEMPORARY_VAR
      2  0098				  -TEMPORARY_VAR SET	VAREND_aiMarchB
      3  0098					      ENDIF
      0  0098					      REFER	aiFinalFlash
      1  0098				  -	      IF	VAREND_aiFinalFlash > TEMPORARY_VAR
      2  0098				  -TEMPORARY_VAR SET	VAREND_aiFinalFlash
      3  0098					      ENDIF
      0  0098					      REFER	UNSAFE_showMoveCaptures
      1  0098				  -	      IF	VAREND_UNSAFE_showMoveCaptures > TEMPORARY_VAR
      2  0098				  -TEMPORARY_VAR SET	VAREND_UNSAFE_showMoveCaptures
      3  0098					      ENDIF
      0  0098					      REFER	aiMarchToTargetA
      1  0098				  -	      IF	VAREND_aiMarchToTargetA > TEMPORARY_VAR
      2  0098				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetA
      3  0098					      ENDIF
      0  0098					      REFER	aiMarchB2
      1  0098				  -	      IF	VAREND_aiMarchB2 > TEMPORARY_VAR
      2  0098				  -TEMPORARY_VAR SET	VAREND_aiMarchB2
      3  0098					      ENDIF
      0  0098					      REFER	aiMarchToTargetB
      1  0098				  -	      IF	VAREND_aiMarchToTargetB > TEMPORARY_VAR
      2  0098				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetB
      3  0098					      ENDIF
      0  0098					      REFER	aiSelectDestinationSquare
      1  0098				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  0098				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  0098					      ENDIF
      0  0098					      REFER	aiPromotePawnStart
      1  0098				  -	      IF	VAREND_aiPromotePawnStart > TEMPORARY_VAR
      2  0098				  -TEMPORARY_VAR SET	VAREND_aiPromotePawnStart
      3  0098					      ENDIF
      0  0098					      REFER	aiChoosePromotePiece
      1  0098				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  0098				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  0098					      ENDIF
      0  0098					      VEND	CopySinglePiece
      1  0098				  -	      IFNCONST	CopySinglePiece
      2  0098				  -	      ECHO	"Incorrect VEND label", CopySinglePiece
      3  0098				  -	      ERR
      4  0098					      ENDIF
      5  0098		       00 ae	   VAREND_CopySinglePiece =	TEMPORARY_VAR
    201  0098
    202  0098							; WARNING: CANNOT USE VAR/OVERLAY IN ANY ROUTINE CALLING THIS!!
    203  0098							; ALSO CAN'T USE IN THIS ROUTINE
    204  0098							; This routine will STOMP on those vars due to __pieceShapeBuffer occupying whole overlay
    205  0098							; @2150 max
    206  0098							; = 33 TIM64T
    207  0098
    208  0098							; Board is [SLOT3]
    209  0098
    210  0098
      0  0098					      CALL	CopySetup	;@2
      1  0098				  -	      IF	SLOT_CopySetup == _BANK_SLOT
      2  0098				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0098				  -	      ECHO	"Cannot switch bank in use for", CopySetup
      4  0098				  -	      ERR
      5  0098					      ENDIF
      6  0098		       a9 94		      lda	#BANK_CopySetup
      7  009a		       85 3f		      sta	SET_BANK
      8  009c		       20 60 f8 	      jsr	CopySetup
    212  009f
    213  009f
      0  009f					      DEF	InterceptMarkerCopy
      1  009f				   SLOT_InterceptMarkerCopy SET	_BANK_SLOT
      2  009f				   BANK_InterceptMarkerCopy SET	SLOT_InterceptMarkerCopy + _CURRENT_BANK
      3  009f				   InterceptMarkerCopy
      4  009f				   TEMPORARY_VAR SET	Overlay
      5  009f				   TEMPORARY_OFFSET SET	0
      6  009f				   VAR_BOUNDARY_InterceptMarkerCopy SET	TEMPORARY_OFFSET
      7  009f				   FUNCTION_NAME SET	InterceptMarkerCopy
    215  009f					      SUBROUTINE
    216  009f
    217  009f
    218  009f							; Copy a piece shape (3 PF bytes wide x 24 lines) to the RAM buffer
    219  009f							; y = piece index
    220  009f
    221  009f		       a9 94		      lda	#BANK_PIECE_VECTOR_BANK
    222  00a1		       85 3f		      sta	SET_BANK	;@2
    223  00a3
    224  00a3		       b9 ab f8 	      lda	PIECE_VECTOR_LO,y
    225  00a6		       85 ea		      sta	__ptr
    226  00a8		       b9 3b f9 	      lda	PIECE_VECTOR_HI,y
    227  00ab		       85 eb		      sta	__ptr+1
    228  00ad		       b9 cb f9 	      lda	PIECE_VECTOR_BANK,y
    229  00b0		       85 3f		      sta	SET_BANK	;@2
    230  00b2
    231  00b2		       a0 47		      ldy	#PIECE_SHAPE_SIZE-1
    232  00b4		       b1 ea	   .copy      lda	(__ptr),y
    233  00b6		       99 a2 00 	      sta	__pieceShapeBuffer,y
    234  00b9		       88		      dey
    235  00ba		       10 f8		      bpl	.copy
    236  00bc
    237  00bc		       a5 80		      lda	squareToDraw
    238  00be		       38		      sec
    239  00bf		       a2 0a		      ldx	#10
    240  00c1		       e9 0a	   .sub10     sbc	#10
    241  00c3		       ca		      dex
    242  00c4		       b0 fb		      bcs	.sub10
    243  00c6
    244  00c6		       69 08		      adc	#8
    245  00c8		       c9 04		      cmp	#4	; CS = right side of screen
    246  00ca
    247  00ca		       8a		      txa
    248  00cb		       09 80		      ora	#[SLOT2]
    249  00cd		       85 3e		      sta	SET_BANK_RAM	;@2		 ; bank row
    250  00cf
      0  00cf					      CALL	CopyPieceToRowBitmap	;@3
      1  00cf				  -	      IF	SLOT_CopyPieceToRowBitmap == _BANK_SLOT
      2  00cf				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  00cf				  -	      ECHO	"Cannot switch bank in use for", CopyPieceToRowBitmap
      4  00cf				  -	      ERR
      5  00cf					      ENDIF
      6  00cf		       a9 c3		      lda	#BANK_CopyPieceToRowBitmap
      7  00d1		       85 3f		      sta	SET_BANK
      8  00d3		       20 0b fc 	      jsr	CopyPieceToRowBitmap
    252  00d6		       60		      rts
    253  00d7
    254  00d7
    255  00d7							;---------------------------------------------------------------------------------------------------
    256  00d7
    257  00d7				   P	      SET	0
    258  00d7					      MAC	ain
    259  00d7				   AI_{1}     SET	P
    260  00d7				   P	      SET	P+1
    261  00d7					      ENDM
    262  00d7
    263  00d7					      MAC	lo
    264  00d7					      .byte	<ai{1}
    265  00d7					      ENDM
    266  00d7
    267  00d7					      MAC	hi
    268  00d7					      .byte	>ai{1}
    269  00d7					      ENDM
    270  00d7
    271  00d7					      MAC	bk
    272  00d7					      .byte	BANK_ai{1}
    273  00d7					      ENDM
    274  00d7
    275  00d7
    276  00d7		       00 28	   ONCEPERFRAME =	40
    277  00d7
    278  00d7					      MAC	tabdef
    279  00d7
    280  00d7					      {1}	FlashComputerMove	; 0
    281  00d7					      {1}	BeginSelectMovePhase	; 1
    282  00d7					      {1}	SelectStartSquare	; 2
    283  00d7					      {1}	StartSquareSelected	; 3
    284  00d7					      {1}	DrawMoves	; 4
    285  00d7					      {1}	ShowMoveCaptures	; 5
    286  00d7					      {1}	SlowFlash	; 6
    287  00d7					      {1}	UnDrawTargetSquares	; 7
    288  00d7					      {1}	SelectDestinationSquare	; 8
    289  00d7					      {1}	Quiescent	; 9
    290  00d7					      {1}	ReselectDebounce	; 10
    291  00d7					      {1}	StartMoveGen	; 11
    292  00d7					      {1}	StepMoveGen	; 12
    293  00d7					      {1}	StartClearBoard	; 13
    294  00d7					      {1}	ClearEachRow	; 14
    295  00d7					      {1}	DrawEntireBoard	; 15
    296  00d7					      {1}	DrawPart2	; 16
    297  00d7					      {1}	DrawPart3	; 17
    298  00d7					      {1}	GenerateMoves	; 18
    299  00d7					      {1}	ComputerMove	; 19
    300  00d7					      {1}	MoveIsSelected	; 20
    301  00d7					      {1}	WriteStartPieceBlank	; 21
    302  00d7					      {1}	MarchToTargetA	; 22
    303  00d7					      {1}	MarchA2	; 23
    304  00d7					      {1}	MarchB	; 24
    305  00d7					      {1}	MarchToTargetB	; 25
    306  00d7					      {1}	MarchB2	; 26
    307  00d7					      {1}	FinalFlash	; 27
    308  00d7					      {1}	SpecialMoveFixup	; 28
    309  00d7					      {1}	InCheckBackup	; 29
    310  00d7					      {1}	InCheckDelay	; 30
    311  00d7					      {1}	PromotePawnStart	; 31
    312  00d7					      {1}	RollPromotionPiece	; 32
    313  00d7					      {1}	ChoosePromotePiece	; 33
    314  00d7					      {1}	ChooseDebounce	; 34
    315  00d7					      {1}	CheckMate	; 35
    316  00d7					      {1}	Draw	; 36
    317  00d7					      {1}	DelayAfterMove	; 37
    318  00d7					      {1}	DelayAfterMove2	; 38
    319  00d7					      {1}	DelayAfterPlaced	; 39
    320  00d7					      {1}	DelayAfterPlaced2	; 40
    321  00d7
    322  00d7					      ENDM		; {1} = macro to use
    323  00d7
      0  00d7					      TABDEF	AIN
      1  00d7
      0  00d7					      AIN	FlashComputerMove
      1  00d7				   AI_FlashComputerMove SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	BeginSelectMovePhase
      1  00d7				   AI_BeginSelectMovePhase SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	SelectStartSquare
      1  00d7				   AI_SelectStartSquare SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	StartSquareSelected
      1  00d7				   AI_StartSquareSelected SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	DrawMoves
      1  00d7				   AI_DrawMoves SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	ShowMoveCaptures
      1  00d7				   AI_ShowMoveCaptures SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	SlowFlash
      1  00d7				   AI_SlowFlash SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	UnDrawTargetSquares
      1  00d7				   AI_UnDrawTargetSquares SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	SelectDestinationSquare
      1  00d7				   AI_SelectDestinationSquare SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	Quiescent
      1  00d7				   AI_Quiescent SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	ReselectDebounce
      1  00d7				   AI_ReselectDebounce SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	StartMoveGen
      1  00d7				   AI_StartMoveGen SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	StepMoveGen
      1  00d7				   AI_StepMoveGen SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	StartClearBoard
      1  00d7				   AI_StartClearBoard SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	ClearEachRow
      1  00d7				   AI_ClearEachRow SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	DrawEntireBoard
      1  00d7				   AI_DrawEntireBoard SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	DrawPart2
      1  00d7				   AI_DrawPart2 SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	DrawPart3
      1  00d7				   AI_DrawPart3 SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	GenerateMoves
      1  00d7				   AI_GenerateMoves SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	ComputerMove
      1  00d7				   AI_ComputerMove SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	MoveIsSelected
      1  00d7				   AI_MoveIsSelected SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	WriteStartPieceBlank
      1  00d7				   AI_WriteStartPieceBlank SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	MarchToTargetA
      1  00d7				   AI_MarchToTargetA SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	MarchA2
      1  00d7				   AI_MarchA2 SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	MarchB
      1  00d7				   AI_MarchB  SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	MarchToTargetB
      1  00d7				   AI_MarchToTargetB SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	MarchB2
      1  00d7				   AI_MarchB2 SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	FinalFlash
      1  00d7				   AI_FinalFlash SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	SpecialMoveFixup
      1  00d7				   AI_SpecialMoveFixup SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	InCheckBackup
      1  00d7				   AI_InCheckBackup SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	InCheckDelay
      1  00d7				   AI_InCheckDelay SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	PromotePawnStart
      1  00d7				   AI_PromotePawnStart SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	RollPromotionPiece
      1  00d7				   AI_RollPromotionPiece SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	ChoosePromotePiece
      1  00d7				   AI_ChoosePromotePiece SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	ChooseDebounce
      1  00d7				   AI_ChooseDebounce SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	CheckMate
      1  00d7				   AI_CheckMate SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	Draw
      1  00d7				   AI_Draw    SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	DelayAfterMove
      1  00d7				   AI_DelayAfterMove SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	DelayAfterMove2
      1  00d7				   AI_DelayAfterMove2 SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	DelayAfterPlaced
      1  00d7				   AI_DelayAfterPlaced SET	P
      2  00d7				   P	      SET	P+1
      0  00d7					      AIN	DelayAfterPlaced2
      1  00d7				   AI_DelayAfterPlaced2 SET	P
      2  00d7				   P	      SET	P+1
     43  00d7
    325  00d7
      0  00d7					      DEF	AiVectorLO
      1  00d7				   SLOT_AiVectorLO SET	_BANK_SLOT
      2  00d7				   BANK_AiVectorLO SET	SLOT_AiVectorLO + _CURRENT_BANK
      3  00d7				   AiVectorLO
      4  00d7				   TEMPORARY_VAR SET	Overlay
      5  00d7				   TEMPORARY_OFFSET SET	0
      6  00d7				   VAR_BOUNDARY_AiVectorLO SET	TEMPORARY_OFFSET
      7  00d7				   FUNCTION_NAME SET	AiVectorLO
      0  00d7					      TABDEF	LO
      1  00d7
      0  00d7					      LO	FlashComputerMove
      1  00d7		       3a		      .byte.b	<aiFlashComputerMove
      0  00d8					      LO	BeginSelectMovePhase
      1  00d8		       1d		      .byte.b	<aiBeginSelectMovePhase
      0  00d9					      LO	SelectStartSquare
      1  00d9		       62		      .byte.b	<aiSelectStartSquare
      0  00da					      LO	StartSquareSelected
      1  00da		       c8		      .byte.b	<aiStartSquareSelected
      0  00db					      LO	DrawMoves
      1  00db		       e3		      .byte.b	<aiDrawMoves
      0  00dc					      LO	ShowMoveCaptures
      1  00dc		       87		      .byte.b	<aiShowMoveCaptures
      0  00dd					      LO	SlowFlash
      1  00dd		       a5		      .byte.b	<aiSlowFlash
      0  00de					      LO	UnDrawTargetSquares
      1  00de		       65		      .byte.b	<aiUnDrawTargetSquares
      0  00df					      LO	SelectDestinationSquare
      1  00df		       fc		      .byte.b	<aiSelectDestinationSquare
      0  00e0					      LO	Quiescent
      1  00e0		       5a		      .byte.b	<aiQuiescent
      0  00e1					      LO	ReselectDebounce
      1  00e1		       51		      .byte.b	<aiReselectDebounce
      0  00e2					      LO	StartMoveGen
      1  00e2		       00		      .byte.b	<aiStartMoveGen
      0  00e3					      LO	StepMoveGen
      1  00e3		       f0		      .byte.b	<aiStepMoveGen
      0  00e4					      LO	StartClearBoard
      1  00e4		       34		      .byte.b	<aiStartClearBoard
      0  00e5					      LO	ClearEachRow
      1  00e5		       41		      .byte.b	<aiClearEachRow
      0  00e6					      LO	DrawEntireBoard
      1  00e6		       d4		      .byte.b	<aiDrawEntireBoard
      0  00e7					      LO	DrawPart2
      1  00e7		       2a		      .byte.b	<aiDrawPart2
      0  00e8					      LO	DrawPart3
      1  00e8		       2d		      .byte.b	<aiDrawPart3
      0  00e9					      LO	GenerateMoves
      1  00e9		       de		      .byte.b	<aiGenerateMoves
      0  00ea					      LO	ComputerMove
      1  00ea		       7b		      .byte.b	<aiComputerMove
      0  00eb					      LO	MoveIsSelected
      1  00eb		       4e		      .byte.b	<aiMoveIsSelected
      0  00ec					      LO	WriteStartPieceBlank
      1  00ec		       00		      .byte.b	<aiWriteStartPieceBlank
      0  00ed					      LO	MarchToTargetA
      1  00ed		       c0		      .byte.b	<aiMarchToTargetA
      0  00ee					      LO	MarchA2
      1  00ee		       0f		      .byte.b	<aiMarchA2
      0  00ef					      LO	MarchB
      1  00ef		       47		      .byte.b	<aiMarchB
      0  00f0					      LO	MarchToTargetB
      1  00f0		       a7		      .byte.b	<aiMarchToTargetB
      0  00f1					      LO	MarchB2
      1  00f1		       36		      .byte.b	<aiMarchB2
      0  00f2					      LO	FinalFlash
      1  00f2		       57		      .byte.b	<aiFinalFlash
      0  00f3					      LO	SpecialMoveFixup
      1  00f3		       b5		      .byte.b	<aiSpecialMoveFixup
      0  00f4					      LO	InCheckBackup
      1  00f4		       05		      .byte.b	<aiInCheckBackup
      0  00f5					      LO	InCheckDelay
      1  00f5		       10		      .byte.b	<aiInCheckDelay
      0  00f6					      LO	PromotePawnStart
      1  00f6		       be		      .byte.b	<aiPromotePawnStart
      0  00f7					      LO	RollPromotionPiece
      1  00f7		       7a		      .byte.b	<aiRollPromotionPiece
      0  00f8					      LO	ChoosePromotePiece
      1  00f8		       00		      .byte.b	<aiChoosePromotePiece
      0  00f9					      LO	ChooseDebounce
      1  00f9		       6b		      .byte.b	<aiChooseDebounce
      0  00fa					      LO	CheckMate
      1  00fa		       7e		      .byte.b	<aiCheckMate
      0  00fb					      LO	Draw
      1  00fb		       79		      .byte.b	<aiDraw
      0  00fc					      LO	DelayAfterMove
      1  00fc		       7d		      .byte.b	<aiDelayAfterMove
      0  00fd					      LO	DelayAfterMove2
      1  00fd		       86		      .byte.b	<aiDelayAfterMove2
      0  00fe					      LO	DelayAfterPlaced
      1  00fe		       8f		      .byte.b	<aiDelayAfterPlaced
      0  00ff					      LO	DelayAfterPlaced2
      1  00ff		       9e		      .byte.b	<aiDelayAfterPlaced2
     43  0100
    328  0100
      0  0100					      DEF	AiVectorHI
      1  0100				   SLOT_AiVectorHI SET	_BANK_SLOT
      2  0100				   BANK_AiVectorHI SET	SLOT_AiVectorHI + _CURRENT_BANK
      3  0100				   AiVectorHI
      4  0100				   TEMPORARY_VAR SET	Overlay
      5  0100				   TEMPORARY_OFFSET SET	0
      6  0100				   VAR_BOUNDARY_AiVectorHI SET	TEMPORARY_OFFSET
      7  0100				   FUNCTION_NAME SET	AiVectorHI
      0  0100					      TABDEF	HI
      1  0100
      0  0100					      HI	FlashComputerMove
      1  0100		       f4		      .byte.b	>aiFlashComputerMove
      0  0101					      HI	BeginSelectMovePhase
      1  0101		       f4		      .byte.b	>aiBeginSelectMovePhase
      0  0102					      HI	SelectStartSquare
      1  0102		       f4		      .byte.b	>aiSelectStartSquare
      0  0103					      HI	StartSquareSelected
      1  0103		       f4		      .byte.b	>aiStartSquareSelected
      0  0104					      HI	DrawMoves
      1  0104		       f4		      .byte.b	>aiDrawMoves
      0  0105					      HI	ShowMoveCaptures
      1  0105		       f5		      .byte.b	>aiShowMoveCaptures
      0  0106					      HI	SlowFlash
      1  0106		       f5		      .byte.b	>aiSlowFlash
      0  0107					      HI	UnDrawTargetSquares
      1  0107		       f5		      .byte.b	>aiUnDrawTargetSquares
      0  0108					      HI	SelectDestinationSquare
      1  0108		       f5		      .byte.b	>aiSelectDestinationSquare
      0  0109					      HI	Quiescent
      1  0109		       f6		      .byte.b	>aiQuiescent
      0  010a					      HI	ReselectDebounce
      1  010a		       f6		      .byte.b	>aiReselectDebounce
      0  010b					      HI	StartMoveGen
      1  010b		       f4		      .byte.b	>aiStartMoveGen
      0  010c					      HI	StepMoveGen
      1  010c		       f4		      .byte.b	>aiStepMoveGen
      0  010d					      HI	StartClearBoard
      1  010d		       f8		      .byte.b	>aiStartClearBoard
      0  010e					      HI	ClearEachRow
      1  010e		       f8		      .byte.b	>aiClearEachRow
      0  010f					      HI	DrawEntireBoard
      1  010f		       f5		      .byte.b	>aiDrawEntireBoard
      0  0110					      HI	DrawPart2
      1  0110		       f4		      .byte.b	>aiDrawPart2
      0  0111					      HI	DrawPart3
      1  0111		       f4		      .byte.b	>aiDrawPart3
      0  0112					      HI	GenerateMoves
      1  0112		       f4		      .byte.b	>aiGenerateMoves
      0  0113					      HI	ComputerMove
      1  0113		       f5		      .byte.b	>aiComputerMove
      0  0114					      HI	MoveIsSelected
      1  0114		       f8		      .byte.b	>aiMoveIsSelected
      0  0115					      HI	WriteStartPieceBlank
      1  0115		       f4		      .byte.b	>aiWriteStartPieceBlank
      0  0116					      HI	MarchToTargetA
      1  0116		       f6		      .byte.b	>aiMarchToTargetA
      0  0117					      HI	MarchA2
      1  0117		       f7		      .byte.b	>aiMarchA2
      0  0118					      HI	MarchB
      1  0118		       f4		      .byte.b	>aiMarchB
      0  0119					      HI	MarchToTargetB
      1  0119		       f4		      .byte.b	>aiMarchToTargetB
      0  011a					      HI	MarchB2
      1  011a		       f7		      .byte.b	>aiMarchB2
      0  011b					      HI	FinalFlash
      1  011b		       f4		      .byte.b	>aiFinalFlash
      0  011c					      HI	SpecialMoveFixup
      1  011c		       f5		      .byte.b	>aiSpecialMoveFixup
      0  011d					      HI	InCheckBackup
      1  011d		       f4		      .byte.b	>aiInCheckBackup
      0  011e					      HI	InCheckDelay
      1  011e		       f4		      .byte.b	>aiInCheckDelay
      0  011f					      HI	PromotePawnStart
      1  011f		       f4		      .byte.b	>aiPromotePawnStart
      0  0120					      HI	RollPromotionPiece
      1  0120		       f6		      .byte.b	>aiRollPromotionPiece
      0  0121					      HI	ChoosePromotePiece
      1  0121		       f4		      .byte.b	>aiChoosePromotePiece
      0  0122					      HI	ChooseDebounce
      1  0122		       f4		      .byte.b	>aiChooseDebounce
      0  0123					      HI	CheckMate
      1  0123		       f4		      .byte.b	>aiCheckMate
      0  0124					      HI	Draw
      1  0124		       f4		      .byte.b	>aiDraw
      0  0125					      HI	DelayAfterMove
      1  0125		       f4		      .byte.b	>aiDelayAfterMove
      0  0126					      HI	DelayAfterMove2
      1  0126		       f4		      .byte.b	>aiDelayAfterMove2
      0  0127					      HI	DelayAfterPlaced
      1  0127		       f4		      .byte.b	>aiDelayAfterPlaced
      0  0128					      HI	DelayAfterPlaced2
      1  0128		       f4		      .byte.b	>aiDelayAfterPlaced2
     43  0129
    331  0129
      0  0129					      DEF	AiVectorBANK
      1  0129				   SLOT_AiVectorBANK SET	_BANK_SLOT
      2  0129				   BANK_AiVectorBANK SET	SLOT_AiVectorBANK + _CURRENT_BANK
      3  0129				   AiVectorBANK
      4  0129				   TEMPORARY_VAR SET	Overlay
      5  0129				   TEMPORARY_OFFSET SET	0
      6  0129				   VAR_BOUNDARY_AiVectorBANK SET	TEMPORARY_OFFSET
      7  0129				   FUNCTION_NAME SET	AiVectorBANK
      0  0129					      TABDEF	BK
      1  0129
      0  0129					      BK	FlashComputerMove
      1  0129		       48		      .byte.b	BANK_aiFlashComputerMove
      0  012a					      BK	BeginSelectMovePhase
      1  012a		       48		      .byte.b	BANK_aiBeginSelectMovePhase
      0  012b					      BK	SelectStartSquare
      1  012b		       48		      .byte.b	BANK_aiSelectStartSquare
      0  012c					      BK	StartSquareSelected
      1  012c		       48		      .byte.b	BANK_aiStartSquareSelected
      0  012d					      BK	DrawMoves
      1  012d		       48		      .byte.b	BANK_aiDrawMoves
      0  012e					      BK	ShowMoveCaptures
      1  012e		       48		      .byte.b	BANK_aiShowMoveCaptures
      0  012f					      BK	SlowFlash
      1  012f		       48		      .byte.b	BANK_aiSlowFlash
      0  0130					      BK	UnDrawTargetSquares
      1  0130		       48		      .byte.b	BANK_aiUnDrawTargetSquares
      0  0131					      BK	SelectDestinationSquare
      1  0131		       48		      .byte.b	BANK_aiSelectDestinationSquare
      0  0132					      BK	Quiescent
      1  0132		       48		      .byte.b	BANK_aiQuiescent
      0  0133					      BK	ReselectDebounce
      1  0133		       48		      .byte.b	BANK_aiReselectDebounce
      0  0134					      BK	StartMoveGen
      1  0134		       48		      .byte.b	BANK_aiStartMoveGen
      0  0135					      BK	StepMoveGen
      1  0135		       49		      .byte.b	BANK_aiStepMoveGen
      0  0136					      BK	StartClearBoard
      1  0136		       94		      .byte.b	BANK_aiStartClearBoard
      0  0137					      BK	ClearEachRow
      1  0137		       94		      .byte.b	BANK_aiClearEachRow
      0  0138					      BK	DrawEntireBoard
      1  0138		       5d		      .byte.b	BANK_aiDrawEntireBoard
      0  0139					      BK	DrawPart2
      1  0139		       55		      .byte.b	BANK_aiDrawPart2
      0  013a					      BK	DrawPart3
      1  013a		       55		      .byte.b	BANK_aiDrawPart3
      0  013b					      BK	GenerateMoves
      1  013b		       49		      .byte.b	BANK_aiGenerateMoves
      0  013c					      BK	ComputerMove
      1  013c		       5d		      .byte.b	BANK_aiComputerMove
      0  013d					      BK	MoveIsSelected
      1  013d		       94		      .byte.b	BANK_aiMoveIsSelected
      0  013e					      BK	WriteStartPieceBlank
      1  013e		       55		      .byte.b	BANK_aiWriteStartPieceBlank
      0  013f					      BK	MarchToTargetA
      1  013f		       48		      .byte.b	BANK_aiMarchToTargetA
      0  0140					      BK	MarchA2
      1  0140		       48		      .byte.b	BANK_aiMarchA2
      0  0141					      BK	MarchB
      1  0141		       55		      .byte.b	BANK_aiMarchB
      0  0142					      BK	MarchToTargetB
      1  0142		       49		      .byte.b	BANK_aiMarchToTargetB
      0  0143					      BK	MarchB2
      1  0143		       48		      .byte.b	BANK_aiMarchB2
      0  0144					      BK	FinalFlash
      1  0144		       55		      .byte.b	BANK_aiFinalFlash
      0  0145					      BK	SpecialMoveFixup
      1  0145		       5d		      .byte.b	BANK_aiSpecialMoveFixup
      0  0146					      BK	InCheckBackup
      1  0146		       48		      .byte.b	BANK_aiInCheckBackup
      0  0147					      BK	InCheckDelay
      1  0147		       48		      .byte.b	BANK_aiInCheckDelay
      0  0148					      BK	PromotePawnStart
      1  0148		       49		      .byte.b	BANK_aiPromotePawnStart
      0  0149					      BK	RollPromotionPiece
      1  0149		       48		      .byte.b	BANK_aiRollPromotionPiece
      0  014a					      BK	ChoosePromotePiece
      1  014a		       49		      .byte.b	BANK_aiChoosePromotePiece
      0  014b					      BK	ChooseDebounce
      1  014b		       49		      .byte.b	BANK_aiChooseDebounce
      0  014c					      BK	CheckMate
      1  014c		       55		      .byte.b	BANK_aiCheckMate
      0  014d					      BK	Draw
      1  014d		       55		      .byte.b	BANK_aiDraw
      0  014e					      BK	DelayAfterMove
      1  014e		       49		      .byte.b	BANK_aiDelayAfterMove
      0  014f					      BK	DelayAfterMove2
      1  014f		       49		      .byte.b	BANK_aiDelayAfterMove2
      0  0150					      BK	DelayAfterPlaced
      1  0150		       49		      .byte.b	BANK_aiDelayAfterPlaced
      0  0151					      BK	DelayAfterPlaced2
      1  0151		       49		      .byte.b	BANK_aiDelayAfterPlaced2
     43  0152
    334  0152
    335  0152
    336  0152							;---------------------------------------------------------------------------------------------------
    337  0152
      0  0152					      DEF	AiStateMachine
      1  0152				   SLOT_AiStateMachine SET	_BANK_SLOT
      2  0152				   BANK_AiStateMachine SET	SLOT_AiStateMachine + _CURRENT_BANK
      3  0152				   AiStateMachine
      4  0152				   TEMPORARY_VAR SET	Overlay
      5  0152				   TEMPORARY_OFFSET SET	0
      6  0152				   VAR_BOUNDARY_AiStateMachine SET	TEMPORARY_OFFSET
      7  0152				   FUNCTION_NAME SET	AiStateMachine
    339  0152					      SUBROUTINE
    340  0152
      0  0152					      REFER	StartupBankReset
      1  0152				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0152				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0152					      ENDIF
      0  0152					      VEND	AiStateMachine
      1  0152				  -	      IFNCONST	AiStateMachine
      2  0152				  -	      ECHO	"Incorrect VEND label", AiStateMachine
      3  0152				  -	      ERR
      4  0152					      ENDIF
      5  0152		       00 a2	   VAREND_AiStateMachine =	TEMPORARY_VAR
    343  0152
    344  0152
    345  0152							; State machine vector setup - points to current routine to execute
    346  0152
    347  0152		       a6 8c		      ldx	aiState
    348  0154		       bd d7 f0 	      lda	AiVectorLO,x
    349  0157		       85 ea		      sta	__ptr
    350  0159		       bd 00 f1 	      lda	AiVectorHI,x
    351  015c		       85 eb		      sta	__ptr+1
    352  015e
    353  015e		       bd 29 f1 	      lda	AiVectorBANK,x
    354  0161		       85 8b		      sta	savedBank
    355  0163
    356  0163		       85 3f		      sta	SET_BANK
    357  0165		       6c ea 00 	      jmp	(__ptr)	; NOTE: could branch back to squeeze cycles
    358  0168
    359  0168
    360  0168							;---------------------------------------------------------------------------------------------------
    361  0168
      0  0168					      DEF	GenerateAllMoves
      1  0168				   SLOT_GenerateAllMoves SET	_BANK_SLOT
      2  0168				   BANK_GenerateAllMoves SET	SLOT_GenerateAllMoves + _CURRENT_BANK
      3  0168				   GenerateAllMoves
      4  0168				   TEMPORARY_VAR SET	Overlay
      5  0168				   TEMPORARY_OFFSET SET	0
      6  0168				   VAR_BOUNDARY_GenerateAllMoves SET	TEMPORARY_OFFSET
      7  0168				   FUNCTION_NAME SET	GenerateAllMoves
    363  0168					      SUBROUTINE
    364  0168
      0  0168					      REFER	negaMax
      1  0168					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0168				   TEMPORARY_VAR SET	VAREND_negaMax
      3  0168					      ENDIF
      0  0168					      REFER	quiesce
      1  0168				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  0168				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  0168					      ENDIF
      0  0168					      REFER	aiStepMoveGen
      1  0168				  -	      IF	VAREND_aiStepMoveGen > TEMPORARY_VAR
      2  0168				  -TEMPORARY_VAR SET	VAREND_aiStepMoveGen
      3  0168					      ENDIF
      0  0168					      REFER	aiGenerateMoves
      1  0168				  -	      IF	VAREND_aiGenerateMoves > TEMPORARY_VAR
      2  0168				  -TEMPORARY_VAR SET	VAREND_aiGenerateMoves
      3  0168					      ENDIF
      0  0168					      REFER	selectmove
      1  0168				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  0168				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  0168					      ENDIF
      0  0168					      VAR	__vector, 2
      1  0168		       00 ae	   __vector   =	TEMPORARY_VAR
      2  0168				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0168
      4  0168				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0168				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0168				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0168					      ENDIF
      8  0168				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0168				  -	      ECHO	"Temporary Variable", __vector, "overflow!"
     10  0168				  -	      ERR
     11  0168					      ENDIF
     12  0168					      LIST	ON
      0  0168					      VAR	__masker, 2
      1  0168		       00 b0	   __masker   =	TEMPORARY_VAR
      2  0168				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0168
      4  0168				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0168				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0168				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0168					      ENDIF
      8  0168				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0168				  -	      ECHO	"Temporary Variable", __masker, "overflow!"
     10  0168				  -	      ERR
     11  0168					      ENDIF
     12  0168					      LIST	ON
      0  0168					      VAR	__pieceFilter, 1
      1  0168		       00 b2	   __pieceFilter =	TEMPORARY_VAR
      2  0168				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0168
      4  0168				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0168				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0168				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0168					      ENDIF
      8  0168				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0168				  -	      ECHO	"Temporary Variable", __pieceFilter, "overflow!"
     10  0168				  -	      ERR
     11  0168					      ENDIF
     12  0168					      LIST	ON
      0  0168					      VEND	GenerateAllMoves
      1  0168				  -	      IFNCONST	GenerateAllMoves
      2  0168				  -	      ECHO	"Incorrect VEND label", GenerateAllMoves
      3  0168				  -	      ERR
      4  0168					      ENDIF
      5  0168		       00 b3	   VAREND_GenerateAllMoves =	TEMPORARY_VAR
    374  0168
    375  0168							; Do the move generation in two passes - pawns then pieces
    376  0168							; This is an effort to get the alphabeta pruning happening with major pieces handled first in list
    377  0168
    378  0168		       a5 95		      lda	currentPly
    379  016a		       85 3e		      sta	SET_BANK_RAM	;@2
    380  016c		       20 00 f8 	      jsr	NewPlyInitialise
    381  016f
    382  016f		       a9 08		      lda	#8	; pawns
    383  0171		       85 b2		      sta	__pieceFilter
    384  0173		       20 88 f1 	      jsr	MoveGenX
    385  0176		       a9 63		      lda	#99
    386  0178		       85 93		      sta	currentSquare
    387  017a		       a9 00		      lda	#0
    388  017c		       85 b2		      sta	__pieceFilter
    389  017e		       20 88 f1 	      jsr	MoveGenX
    390  0181
    391  0181		       a5 95		      lda	currentPly
    392  0183		       85 3e		      sta	SET_BANK_RAM
    393  0185		       4c de f8 	      jmp	Sort
    394  0188
    395  0188
    396  0188
      0  0188					      DEF	MoveGenX
      1  0188				   SLOT_MoveGenX SET	_BANK_SLOT
      2  0188				   BANK_MoveGenX SET	SLOT_MoveGenX + _CURRENT_BANK
      3  0188				   MoveGenX
      4  0188				   TEMPORARY_VAR SET	Overlay
      5  0188				   TEMPORARY_OFFSET SET	0
      6  0188				   VAR_BOUNDARY_MoveGenX SET	TEMPORARY_OFFSET
      7  0188				   FUNCTION_NAME SET	MoveGenX
    398  0188					      SUBROUTINE
    399  0188
    400  0188		       a2 64		      ldx	#100
    401  018a		       d0 02		      bne	.next2
    402  018c
      0  018c					      DEF	MoveReturn
      1  018c				   SLOT_MoveReturn SET	_BANK_SLOT
      2  018c				   BANK_MoveReturn SET	SLOT_MoveReturn + _CURRENT_BANK
      3  018c				   MoveReturn
      4  018c				   TEMPORARY_VAR SET	Overlay
      5  018c				   TEMPORARY_OFFSET SET	0
      6  018c				   VAR_BOUNDARY_MoveReturn SET	TEMPORARY_OFFSET
      7  018c				   FUNCTION_NAME SET	MoveReturn
    404  018c
    405  018c
    406  018c		       a6 93		      ldx	currentSquare
    407  018e
    408  018e		       a9 cf	   .next2     lda	#RAMBANK_BOARD
    409  0190		       85 3e		      sta	SET_BANK_RAM	;@3
    410  0192
    411  0192		       ca	   .next      dex
    412  0193		       e0 16		      cpx	#22
    413  0195		       90 2c		      bcc	.exit
    414  0197
    415  0197		       bd 79 fc 	      lda	Board,x
    416  019a		       f0 f6		      beq	.next
    417  019c		       c9 ff		      cmp	#-1
    418  019e		       f0 f2		      beq	.next
    419  01a0		       45 96		      eor	sideToMove
    420  01a2		       30 ee		      bmi	.next
    421  01a4
    422  01a4							;    DEF handleIt
    423  01a4							;    SUBROUTINE
    424  01a4
    425  01a4
    426  01a4		       86 93		      stx	currentSquare
    427  01a6
    428  01a6		       45 96		      eor	sideToMove
    429  01a8		       29 ef		      and	#~FLAG_CASTLE	; todo: better part of the move, mmh?
    430  01aa		       85 92		      sta	currentPiece
    431  01ac		       29 0f		      and	#PIECE_MASK
    432  01ae		       05 b2		      ora	__pieceFilter
    433  01b0		       a8		      tay
    434  01b1
    435  01b1		       b9 10 f4 	      lda	HandlerVectorHI,y
    436  01b4		       85 af		      sta	__vector+1
    437  01b6		       b9 00 f4 	      lda	HandlerVectorLO,y
    438  01b9		       85 ae		      sta	__vector
    439  01bb
    440  01bb		       b9 20 f4 	      lda	HandlerVectorBANK,y
    441  01be		       85 3f		      sta	SET_BANK	;@1
    442  01c0
    443  01c0		       6c ae 00 	      jmp	(__vector)
    444  01c3
    445  01c3
    446  01c3
    447  01c3				   .exit
    448  01c3		       60		      rts
    449  01c4
    450  01c4
    451  01c4							;---------------------------------------------------------------------------------------------------
    452  01c4
      0  01c4					      DEF	ListPlayerMoves
      1  01c4				   SLOT_ListPlayerMoves SET	_BANK_SLOT
      2  01c4				   BANK_ListPlayerMoves SET	SLOT_ListPlayerMoves + _CURRENT_BANK
      3  01c4				   ListPlayerMoves
      4  01c4				   TEMPORARY_VAR SET	Overlay
      5  01c4				   TEMPORARY_OFFSET SET	0
      6  01c4				   VAR_BOUNDARY_ListPlayerMoves SET	TEMPORARY_OFFSET
      7  01c4				   FUNCTION_NAME SET	ListPlayerMoves
    454  01c4					      SUBROUTINE
    455  01c4
    456  01c4
    457  01c4		       a9 00		      lda	#0
    458  01c6		       85 ad		      sta	__quiesceCapOnly	; gen ALL moves
    459  01c8
    460  01c8		       a9 c9		      lda	#RAMBANK_PLY+1
    461  01ca		       85 95		      sta	currentPly
    462  01cc		       20 68 f1 	      jsr	GenerateAllMoves
    463  01cf
      0  01cf					      ldx@PLY	moveIndex
      1  01cf		       ae 9e ff 	      ldx	moveIndex
      0  01d2				   .scan      stx@PLY	movePtr
      1  01d2		       8e 9f 01 	      stx	[RAM]+movePtr
    466  01d5
    467  01d5		       20 00 f4 	      jsr	MakeMove
    468  01d8
    469  01d8		       e6 95		      inc	currentPly
    470  01da		       20 68 f1 	      jsr	GenerateAllMoves
    471  01dd
    472  01dd		       c6 95		      dec	currentPly
    473  01df		       a5 95		      lda	currentPly
    474  01e1		       85 3e		      sta	SET_BANK_RAM
    475  01e3
    476  01e3		       20 6f f4 	      jsr	unmakeMove
    477  01e6
    478  01e6		       a5 9f		      lda	flagCheck
    479  01e8		       f0 08		      beq	.next
    480  01ea
      0  01ea					      ldx@PLY	movePtr
      1  01ea		       ae 9f ff 	      ldx	movePtr
    482  01ed		       a9 00		      lda	#0
      0  01ef					      sta@PLY	MoveFrom,x	; invalidate move (still in check!)
      1  01ef		       9d 00 fe 	      sta	[RAM]+MoveFrom,x
    484  01f2
      0  01f2				   .next      ldx@PLY	movePtr
      1  01f2		       ae 9f ff 	      ldx	movePtr
    486  01f5		       ca		      dex
    487  01f6		       10 da		      bpl	.scan
    488  01f8
    489  01f8		       60		      rts
    490  01f9
    491  01f9
    492  01f9							;---------------------------------------------------------------------------------------------------
    493  01f9
 FREE BYTES IN STARTUP BANK =  $203
    494  01f9					      ECHO	"FREE BYTES IN STARTUP BANK = ", $F3FC - *
    495  01f9
    496  01f9							;---------------------------------------------------------------------------------------------------
    497  01f9							; The reset vectors
    498  01f9							; these must live in the first 1K bank of the ROM
    499  01f9
    500  0400 ????				      SEG	StartupInterruptVectors
    501  03fc					      ORG	_FIRST_BANK + $3FC
    502  03fc
    503  03fc		       00 f0		      .word.w	StartupBankReset	; RESET
    504  03fe		       00 f0		      .word.w	StartupBankReset	; IRQ	      (not used)
    505  0400
    506  0400							;---------------------------------------------------------------------------------------------------
    507  0400
    508  0400
    509  0400							; EOF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@1#1.asm LEVEL 2 PASS 4
      0  0400					      include	"BANK_GENERIC@1#1.asm"
      1  0400							; Chess
      2  0400							; Copyright (c) 2019-2020 Andrew Davie
      3  0400							; andrew@taswegian.com
      4  0400
      0  0400					      SLOT	1	; which bank this code switches to
      1  0400				  -	      IF	(1 < 0) || (1 > 3)
      2  0400				  -	      ECHO	"Illegal bank address/segment location", 1
      3  0400				  -	      ERR
      4  0400					      ENDIF
      5  0400				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  0400				   _BANK_SLOT SET	1 * 64
      0  0400					      NEWBANK	ONE
      1  0682 ????				      SEG	ONE
      2  0400					      ORG	_ORIGIN
      3  0400					      RORG	_BANK_ADDRESS_ORIGIN
      4  0400				   _BANK_START SET	*
      5  0400				   ONE_START  SET	*
      6  0400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0400				   ONE	      SET	_BANK_SLOT + _CURRENT_BANK
      8  0400				   _ORIGIN    SET	_ORIGIN + 1024
      7  0400
      8  0400
      9  0400							;---------------------------------------------------------------------------------------------------
     10  0400							; ... the above is a (potentially) RAM-copied section -- the following is ROM-only.  Note that
     11  0400							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     12  0400							; bank finishes.  Just continue on from where it left off...
     13  0400							;---------------------------------------------------------------------------------------------------
     14  0400
      0  0400					      DEF	CartInit
      1  0400				   SLOT_CartInit SET	_BANK_SLOT
      2  0400				   BANK_CartInit SET	SLOT_CartInit + _CURRENT_BANK
      3  0400				   CartInit
      4  0400				   TEMPORARY_VAR SET	Overlay
      5  0400				   TEMPORARY_OFFSET SET	0
      6  0400				   VAR_BOUNDARY_CartInit SET	TEMPORARY_OFFSET
      7  0400				   FUNCTION_NAME SET	CartInit
     16  0400					      SUBROUTINE
     17  0400
      0  0400					      REFER	StartupBankReset
      1  0400				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0400				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0400					      ENDIF
      0  0400					      VEND	CartInit
      1  0400				  -	      IFNCONST	CartInit
      2  0400				  -	      ECHO	"Incorrect VEND label", CartInit
      3  0400				  -	      ERR
      4  0400					      ENDIF
      5  0400		       00 a2	   VAREND_CartInit =	TEMPORARY_VAR
     20  0400
     21  0400		       78		      sei
     22  0401		       d8		      cld
     23  0402							; See if we can come up with something 'random' for startup
     24  0402
     25  0402		       ac 84 02 	      ldy	INTIM
     26  0405		       d0 02		      bne	.toR
     27  0407		       a0 9a		      ldy	#$9A
     28  0409		       84 81	   .toR       sty	rnd
     29  040b
     30  040b		       a9 ff		      lda	#255
     31  040d		       85 a1		      sta	randomness
     32  040f
     33  040f		       a9 00		      lda	#0
     34  0411		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     35  0414		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     36  0417		       85 6b		      sta	HMCLR
     37  0419
     38  0419							; cleanup remains of title screen
     39  0419		       85 5b		      sta	GRP0
     40  041b		       85 5c		      sta	GRP1
     41  041d
     42  041d		       a9 10		      lda	#%00010000	; double width missile, double width player
     43  041f		       85 44		      sta	NUSIZ0
     44  0421		       85 45		      sta	NUSIZ1
     45  0423
     46  0423		       a9 04		      lda	#%100	; players/missiles BEHIND BG
     47  0425		       85 4a		      sta	CTRLPF
     48  0427		       a9 07		      lda	#%111
     49  0429		       85 44		      sta	NUSIZ0
     50  042b		       85 45		      sta	NUSIZ1	; quad-width
     51  042d
     52  042d		       a9 04		      lda	#%00000100
     53  042f		       85 4a		      sta	CTRLPF
     54  0431		       a9 00		      lda	#BACKGCOL
     55  0433		       85 49		      sta	COLUBK
     56  0435
     57  0435
     58  0435		       a9 00		      lda	#WHITE	;tmp+RAMBANK_PLY
     59  0437		       85 96		      sta	sideToMove
     60  0439
     61  0439		       60		      rts
     62  043a
     63  043a
     64  043a							;---------------------------------------------------------------------------------------------------
     65  043a
      0  043a					      DEF	SetupBanks
      1  043a				   SLOT_SetupBanks SET	_BANK_SLOT
      2  043a				   BANK_SetupBanks SET	SLOT_SetupBanks + _CURRENT_BANK
      3  043a				   SetupBanks
      4  043a				   TEMPORARY_VAR SET	Overlay
      5  043a				   TEMPORARY_OFFSET SET	0
      6  043a				   VAR_BOUNDARY_SetupBanks SET	TEMPORARY_OFFSET
      7  043a				   FUNCTION_NAME SET	SetupBanks
     67  043a					      SUBROUTINE
     68  043a
     69  043a							; Move a copy of the row bank template to the first 8 banks of RAM
     70  043a							; and then terminate the draw subroutine by substituting in a RTS on the last one
     71  043a
      0  043a					      REFER	StartupBankReset
      1  043a				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  043a				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  043a					      ENDIF
      0  043a					      VAR	__plyBank, 1
      1  043a		       00 a2	   __plyBank  =	TEMPORARY_VAR
      2  043a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  043a
      4  043a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  043a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  043a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  043a					      ENDIF
      8  043a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  043a				  -	      ECHO	"Temporary Variable", __plyBank, "overflow!"
     10  043a				  -	      ERR
     11  043a					      ENDIF
     12  043a					      LIST	ON
      0  043a					      VEND	SetupBanks
      1  043a				  -	      IFNCONST	SetupBanks
      2  043a				  -	      ECHO	"Incorrect VEND label", SetupBanks
      3  043a				  -	      ERR
      4  043a					      ENDIF
      5  043a		       00 a3	   VAREND_SetupBanks =	TEMPORARY_VAR
     75  043a
     76  043a							; Copy the bitmap shadow into the first 8 RAM banks via x(SLOT3)-->y(SLOT2)
     77  043a
     78  043a				   .ROWBANK   SET	0
     79  043a					      REPEAT	8
     80  043a		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  043c		       a0 c0		      ldy	#[SLOT3] + .ROWBANK
     82  043e		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
     83  043e				   .ROWBANK   SET	.ROWBANK+1
     79  043e					      REPEND
     80  0441		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  0443		       a0 c1		      ldy	#[SLOT3] + .ROWBANK
     82  0445		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
     83  0445				   .ROWBANK   SET	.ROWBANK+1
     79  0445					      REPEND
     80  0448		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  044a		       a0 c2		      ldy	#[SLOT3] + .ROWBANK
     82  044c		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
     83  044c				   .ROWBANK   SET	.ROWBANK+1
     79  044c					      REPEND
     80  044f		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  0451		       a0 c3		      ldy	#[SLOT3] + .ROWBANK
     82  0453		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
     83  0453				   .ROWBANK   SET	.ROWBANK+1
     79  0453					      REPEND
     80  0456		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  0458		       a0 c4		      ldy	#[SLOT3] + .ROWBANK
     82  045a		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
     83  045a				   .ROWBANK   SET	.ROWBANK+1
     79  045a					      REPEND
     80  045d		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  045f		       a0 c5		      ldy	#[SLOT3] + .ROWBANK
     82  0461		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
     83  0461				   .ROWBANK   SET	.ROWBANK+1
     79  0461					      REPEND
     80  0464		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  0466		       a0 c6		      ldy	#[SLOT3] + .ROWBANK
     82  0468		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
     83  0468				   .ROWBANK   SET	.ROWBANK+1
     79  0468					      REPEND
     80  046b		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  046d		       a0 c7		      ldy	#[SLOT3] + .ROWBANK
     82  046f		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
     83  046f				   .ROWBANK   SET	.ROWBANK+1
     84  0472					      REPEND
     85  0472
     86  0472
     87  0472							; Patch the final row's "loop" to a RTS
     88  0472
     89  0472		       a2 87		      ldx	#[SLOT2] + 7	; last ROW BITMAP bank
     90  0474		       86 3e		      stx	SET_BANK_RAM
     91  0476		       a9 60		      lda	#$60	; "rts"
      0  0478					      sta@RAM	SELFMOD_RTS_ON_LAST_ROW
      1  0478		       8d 00 fb 	      sta	[RAM]+SELFMOD_RTS_ON_LAST_ROW
     93  047b
     94  047b
     95  047b
     96  047b							; copy the BOARD/MOVES bank
     97  047b
     98  047b		       a2 86		      ldx	#SHADOW_BOARD
     99  047d		       a0 cf		      ldy	#RAMBANK_BOARD
    100  047f		       20 b4 f4 	      jsr	CopyShadowROMtoRAM	; this auto-initialises Board too
    101  0482
    102  0482
    103  0482							; copy the PLY banks
    104  0482							; If there's no content (only variable decs) then we don't really need to do this.
    105  0482
    106  0482				   .PLY       SET	0
    107  0482					      REPEAT	PLY_BANKS
    108  0482
    109  0482		       a2 c5		      ldx	#SHADOW_PLY
    110  0484		       a0 c8		      ldy	#RAMBANK_PLY + .PLY
    111  0486		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
    112  0486				   .PLY       SET	.PLY + 1
    107  0486					      REPEND
    108  0489
    109  0489		       a2 c5		      ldx	#SHADOW_PLY
    110  048b		       a0 c9		      ldy	#RAMBANK_PLY + .PLY
    111  048d		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
    112  048d				   .PLY       SET	.PLY + 1
    107  048d					      REPEND
    108  0490
    109  0490		       a2 c5		      ldx	#SHADOW_PLY
    110  0492		       a0 ca		      ldy	#RAMBANK_PLY + .PLY
    111  0494		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
    112  0494				   .PLY       SET	.PLY + 1
    107  0494					      REPEND
    108  0497
    109  0497		       a2 c5		      ldx	#SHADOW_PLY
    110  0499		       a0 cb		      ldy	#RAMBANK_PLY + .PLY
    111  049b		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
    112  049b				   .PLY       SET	.PLY + 1
    107  049b					      REPEND
    108  049e
    109  049e		       a2 c5		      ldx	#SHADOW_PLY
    110  04a0		       a0 cc		      ldy	#RAMBANK_PLY + .PLY
    111  04a2		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
    112  04a2				   .PLY       SET	.PLY + 1
    107  04a2					      REPEND
    108  04a5
    109  04a5		       a2 c5		      ldx	#SHADOW_PLY
    110  04a7		       a0 cd		      ldy	#RAMBANK_PLY + .PLY
    111  04a9		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
    112  04a9				   .PLY       SET	.PLY + 1
    107  04a9					      REPEND
    108  04ac
    109  04ac		       a2 c5		      ldx	#SHADOW_PLY
    110  04ae		       a0 ce		      ldy	#RAMBANK_PLY + .PLY
    111  04b0		       20 b4 f4 	      jsr	CopyShadowROMtoRAM
    112  04b0				   .PLY       SET	.PLY + 1
    113  04b3					      REPEND
    114  04b3
    115  04b3							; copy the evaluation code/tables
    116  04b3							; 3E+ moved from RAM to ROM
    117  04b3
    118  04b3							;		      ldx #[SLOT2] + SHADOW_EVAL
    119  04b3							;		      ldy #[SLOT3] + EVAL
    120  04b3							;		      jsr CopyShadowROMtoRAM
    121  04b3
    122  04b3
    123  04b3							;		      ldy #RAMBANK_RAM_PIECELIST
    124  04b3							;		      ldx #ROM_PIECELIST
    125  04b3							;		      jsr CopyShadowROMtoRAM
    126  04b3
    127  04b3		       60		      rts
    128  04b4
    129  04b4
    130  04b4							;---------------------------------------------------------------------------------------------------
    131  04b4
      0  04b4					      DEF	CopyShadowROMtoRAM
      1  04b4				   SLOT_CopyShadowROMtoRAM SET	_BANK_SLOT
      2  04b4				   BANK_CopyShadowROMtoRAM SET	SLOT_CopyShadowROMtoRAM + _CURRENT_BANK
      3  04b4				   CopyShadowROMtoRAM
      4  04b4				   TEMPORARY_VAR SET	Overlay
      5  04b4				   TEMPORARY_OFFSET SET	0
      6  04b4				   VAR_BOUNDARY_CopyShadowROMtoRAM SET	TEMPORARY_OFFSET
      7  04b4				   FUNCTION_NAME SET	CopyShadowROMtoRAM
    133  04b4					      SUBROUTINE
    134  04b4
      0  04b4					      REFER	SetupBanks
      1  04b4					      IF	VAREND_SetupBanks > TEMPORARY_VAR
      2  04b4				   TEMPORARY_VAR SET	VAREND_SetupBanks
      3  04b4					      ENDIF
      0  04b4					      VEND	CopyShadowROMtoRAM
      1  04b4				  -	      IFNCONST	CopyShadowROMtoRAM
      2  04b4				  -	      ECHO	"Incorrect VEND label", CopyShadowROMtoRAM
      3  04b4				  -	      ERR
      4  04b4					      ENDIF
      5  04b4		       00 a3	   VAREND_CopyShadowROMtoRAM =	TEMPORARY_VAR
    137  04b4
    138  04b4							; Copy a whole ROM SHADOW into a destination RAM 512 byte bank
    139  04b4							; used to setup callable RAM code from ROM templates
    140  04b4
    141  04b4							; x = source ROM bank
    142  04b4							; y = destination RAM bank (preserved)
    143  04b4
    144  04b4		       86 3f		      stx	SET_BANK
    145  04b6		       84 3e		      sty	SET_BANK_RAM
    146  04b8
    147  04b8		       a2 00		      ldx	#0
    148  04ba		       bd 00 f8    .copyPage  lda	$F800,x
      0  04bd					      sta@RAM	$FC00,x
      1  04bd		       9d 00 fe 	      sta	[RAM]+$FC00,x
    150  04c0		       bd 00 f9 	      lda	$F900,x
      0  04c3					      sta@RAM	$FD00,x
      1  04c3		       9d 00 ff 	      sta	[RAM]+$FD00,x
    152  04c6		       ca		      dex
    153  04c7		       d0 f1		      bne	.copyPage
    154  04c9		       60		      rts
    155  04ca
    156  04ca
    157  04ca							;---------------------------------------------------------------------------------------------------
    158  04ca
      0  04ca					      DEF	CallClear
      1  04ca				   SLOT_CallClear SET	_BANK_SLOT
      2  04ca				   BANK_CallClear SET	SLOT_CallClear + _CURRENT_BANK
      3  04ca				   CallClear
      4  04ca				   TEMPORARY_VAR SET	Overlay
      5  04ca				   TEMPORARY_OFFSET SET	0
      6  04ca				   VAR_BOUNDARY_CallClear SET	TEMPORARY_OFFSET
      7  04ca				   FUNCTION_NAME SET	CallClear
    160  04ca					      SUBROUTINE
    161  04ca
    162  04ca				  -	      IF	0
    163  04ca				  -	      REFER	aiClearEachRow
    164  04ca					      ENDIF
      0  04ca					      VEND	CallClear
      1  04ca				  -	      IFNCONST	CallClear
      2  04ca				  -	      ECHO	"Incorrect VEND label", CallClear
      3  04ca				  -	      ERR
      4  04ca					      ENDIF
      5  04ca		       00 a2	   VAREND_CallClear =	TEMPORARY_VAR
    166  04ca
    167  04ca				  -	      IF	0
    168  04ca				  -			; No transient variable dependencies/calls
    169  04ca				  -
    170  04ca				  -	      sty	SET_BANK_RAM
    171  04ca				  -	      jsr	ClearRowBitmap
    172  04ca					      ENDIF
    173  04ca		       60		      rts
    174  04cb
    175  04cb
    176  04cb							;---------------------------------------------------------------------------------------------------
    177  04cb
      0  04cb					      DEF	InitialisePieceSquares
      1  04cb				   SLOT_InitialisePieceSquares SET	_BANK_SLOT
      2  04cb				   BANK_InitialisePieceSquares SET	SLOT_InitialisePieceSquares + _CURRENT_BANK
      3  04cb				   InitialisePieceSquares
      4  04cb				   TEMPORARY_VAR SET	Overlay
      5  04cb				   TEMPORARY_OFFSET SET	0
      6  04cb				   VAR_BOUNDARY_InitialisePieceSquares SET	TEMPORARY_OFFSET
      7  04cb				   FUNCTION_NAME SET	InitialisePieceSquares
    179  04cb					      SUBROUTINE
    180  04cb
      0  04cb					      REFER	StartupBankReset
      1  04cb				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  04cb				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  04cb					      ENDIF
      0  04cb					      VAR	__initPiece, 1
      1  04cb		       00 a2	   __initPiece =	TEMPORARY_VAR
      2  04cb				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  04cb
      4  04cb				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  04cb				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  04cb				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  04cb					      ENDIF
      8  04cb				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  04cb				  -	      ECHO	"Temporary Variable", __initPiece, "overflow!"
     10  04cb				  -	      ERR
     11  04cb					      ENDIF
     12  04cb					      LIST	ON
      0  04cb					      VAR	__initSquare, 1
      1  04cb		       00 a3	   __initSquare =	TEMPORARY_VAR
      2  04cb				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  04cb
      4  04cb				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  04cb				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  04cb				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  04cb					      ENDIF
      8  04cb				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  04cb				  -	      ECHO	"Temporary Variable", __initSquare, "overflow!"
     10  04cb				  -	      ERR
     11  04cb					      ENDIF
     12  04cb					      LIST	ON
      0  04cb					      VAR	__initListPtr, 1
      1  04cb		       00 a4	   __initListPtr =	TEMPORARY_VAR
      2  04cb				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  04cb
      4  04cb				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  04cb				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  04cb				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  04cb					      ENDIF
      8  04cb				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  04cb				  -	      ECHO	"Temporary Variable", __initListPtr, "overflow!"
     10  04cb				  -	      ERR
     11  04cb					      ENDIF
     12  04cb					      LIST	ON
      0  04cb					      VEND	InitialisePieceSquares
      1  04cb				  -	      IFNCONST	InitialisePieceSquares
      2  04cb				  -	      ECHO	"Incorrect VEND label", InitialisePieceSquares
      3  04cb				  -	      ERR
      4  04cb					      ENDIF
      5  04cb		       00 a5	   VAREND_InitialisePieceSquares =	TEMPORARY_VAR
    186  04cb
    187  04cb							;---------------------------------------------------------------------------------------------------
    188  04cb
      0  04cb					      DEF	InitPieceLists
      1  04cb				   SLOT_InitPieceLists SET	_BANK_SLOT
      2  04cb				   BANK_InitPieceLists SET	SLOT_InitPieceLists + _CURRENT_BANK
      3  04cb				   InitPieceLists
      4  04cb				   TEMPORARY_VAR SET	Overlay
      5  04cb				   TEMPORARY_OFFSET SET	0
      6  04cb				   VAR_BOUNDARY_InitPieceLists SET	TEMPORARY_OFFSET
      7  04cb				   FUNCTION_NAME SET	InitPieceLists
    190  04cb					      SUBROUTINE
    191  04cb
      0  04cb					      REFER	InitialisePieceSquares
      1  04cb					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  04cb				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  04cb					      ENDIF
      0  04cb					      VEND	InitPieceLists
      1  04cb				  -	      IFNCONST	InitPieceLists
      2  04cb				  -	      ECHO	"Incorrect VEND label", InitPieceLists
      3  04cb				  -	      ERR
      4  04cb					      ENDIF
      5  04cb		       00 a5	   VAREND_InitPieceLists =	TEMPORARY_VAR
    194  04cb
    195  04cb
    196  04cb		       a9 00		      lda	#0
    197  04cd		       85 90		      sta	Evaluation
    198  04cf		       85 91		      sta	Evaluation+1	; tracks CURRENT value of everything (signed 16-bit)
    199  04d1		       85 94		      sta	enPassantPawn	; no en-passant
    200  04d3
    201  04d3
      0  04d3					      PHASE	AI_StartClearBoard
      1  04d3		       a9 0d		      lda	#AI_StartClearBoard
      2  04d5		       85 8c		      sta	aiState
    203  04d7
    204  04d7		       a2 00		      ldx	#0
    205  04d9				   .fillPieceLists
    206  04d9
    207  04d9
    208  04d9		       bd 23 f5 	      lda	InitPieceList,x	; colour/-1
    209  04dc		       f0 44		      beq	.exit
    210  04de		       85 a2		      sta	__originalPiece	; type
    211  04e0		       bc 24 f5 	      ldy	InitPieceList+1,x	; square
    212  04e3		       84 a3		      sty	__initSquare
    213  04e5
    214  04e5		       a9 cf		      lda	#RAMBANK_BOARD
    215  04e7		       85 3e		      sta	SET_BANK_RAM
    216  04e9		       a5 a2		      lda	__originalPiece
      0  04eb					      sta@RAM	Board,y
      1  04eb		       99 79 fe 	      sta	[RAM]+Board,y
    218  04ee		       10 0d		      bpl	.white
    219  04f0
      0  04f0					      NEGEVAL
      1  04f0
      2  04f0		       38		      sec
      3  04f1		       a9 00		      lda	#0
      4  04f3		       e5 90		      sbc	Evaluation
      5  04f5		       85 90		      sta	Evaluation
      6  04f7		       a9 00		      lda	#0
      7  04f9		       e5 91		      sbc	Evaluation+1
      8  04fb		       85 91		      sta	Evaluation+1
    221  04fd				   .white
    222  04fd
    223  04fd							; Add the material value of the piece to the evaluation
    224  04fd
    225  04fd		       a5 a2		      lda	__originalPiece
    226  04ff
    227  04ff							;lda #RAMBANK_BANK_EVAL ;BANK_AddPiecePositionValue
    228  04ff							;sta SET_BANK_RAM
    229  04ff		       20 0b f6 	      jsr	AddPieceMaterialValue
    230  0502
    231  0502		       86 a4		      stx	__initListPtr
    232  0504
    233  0504							; add the positional value of the piece to the evaluation
    234  0504
    235  0504		       a4 a3		      ldy	__initSquare
    236  0506		       a5 a2		      lda	__originalPiece
    237  0508
    238  0508							;ldx #BANK_AddPiecePositionValue
    239  0508							;stx SET_BANK
    240  0508		       20 c8 f5 	      jsr	AddPiecePositionValue
    241  050b
    242  050b		       a5 a2		      lda	__originalPiece	; type/colour
    243  050d		       10 0d		      bpl	.white2
      0  050f					      NEGEVAL
      1  050f
      2  050f		       38		      sec
      3  0510		       a9 00		      lda	#0
      4  0512		       e5 90		      sbc	Evaluation
      5  0514		       85 90		      sta	Evaluation
      6  0516		       a9 00		      lda	#0
      7  0518		       e5 91		      sbc	Evaluation+1
      8  051a		       85 91		      sta	Evaluation+1
    245  051c				   .white2
    246  051c
    247  051c		       a6 a4		      ldx	__initListPtr
    248  051e		       e8		      inx
    249  051f		       e8		      inx
    250  0520		       10 b7		      bpl	.fillPieceLists
    251  0522
    252  0522				   .exit
    253  0522		       60		      rts
    254  0523
    255  0523
    256  0523				   InitPieceList
    257  0523
    258  0523
    259  0523					      IF	!TEST_POSITION
    260  0523
    261  0523		       06 19		      .byte.b	WHITE|Q, 25
    262  0525		       04 18		      .byte.b	WHITE|B, 24
    263  0527		       04 1b		      .byte.b	WHITE|B, 27
    264  0529		       05 16		      .byte.b	WHITE|R, 22
    265  052b		       05 1d		      .byte.b	WHITE|R, 29
    266  052d		       03 17		      .byte.b	WHITE|N, 23
    267  052f		       03 1c		      .byte.b	WHITE|N, 28
    268  0531
    269  0531		       01 23		      .byte.b	WHITE|WP, 35
    270  0533		       01 24		      .byte.b	WHITE|WP, 36
    271  0535		       01 22		      .byte.b	WHITE|WP, 34
    272  0537		       01 25		      .byte.b	WHITE|WP, 37
    273  0539		       01 21		      .byte.b	WHITE|WP, 33
    274  053b		       01 26		      .byte.b	WHITE|WP, 38
    275  053d		       01 20		      .byte.b	WHITE|WP, 32
    276  053f		       01 27		      .byte.b	WHITE|WP, 39
    277  0541
    278  0541		       07 1a		      .byte.b	WHITE|K, 26
    279  0543
    280  0543		       86 5f		      .byte.b	BLACK|Q, 95
    281  0545		       84 5e		      .byte.b	BLACK|B, 94
    282  0547		       84 61		      .byte.b	BLACK|B, 97
    283  0549		       85 5c		      .byte.b	BLACK|R, 92
    284  054b		       85 63		      .byte.b	BLACK|R, 99
    285  054d		       83 5d		      .byte.b	BLACK|N, 93
    286  054f		       83 62		      .byte.b	BLACK|N, 98
    287  0551
    288  0551		       82 55		      .byte.b	BLACK|BP, 85
    289  0553		       82 56		      .byte.b	BLACK|BP, 86
    290  0555		       82 54		      .byte.b	BLACK|BP, 84
    291  0557		       82 57		      .byte.b	BLACK|BP, 87
    292  0559		       82 53		      .byte.b	BLACK|BP, 83
    293  055b		       82 58		      .byte.b	BLACK|BP, 88
    294  055d		       82 52		      .byte.b	BLACK|BP, 82
    295  055f		       82 59		      .byte.b	BLACK|BP, 89
    296  0561
    297  0561		       87 60		      .byte.b	BLACK|K, 96
    298  0563
    299  0563		       00		      .byte.b	0	;end
    300  0564
    301  0564				  -	      ELSE		; test position...
    302  0564				  -
    303  0564				  -
    304  0564				  -	      IF	0
    305  0564				  -
    306  0564				  -	      .byte	WHITE|K, 28
    307  0564				  -	      .byte	WHITE|WP, 37
    308  0564				  -	      .byte	WHITE|WP, 38
    309  0564				  -	      .byte	WHITE|WP, 53
    310  0564				  -	      .byte	WHITE|WP, 49
    311  0564				  -	      .byte	WHITE|WP, 32
    312  0564				  -	      .byte	WHITE|R, 27
    313  0564				  -	      .byte	WHITE|B, 46
    314  0564				  -	      .byte	WHITE|R, 54
    315  0564				  -
    316  0564				  -	      .byte	BLACK|BP, 56
    317  0564				  -	      .byte	BLACK|BP, 87
    318  0564				  -	      .byte	BLACK|BP, 88
    319  0564				  -	      .byte	BLACK|BP, 89
    320  0564				  -	      .byte	BLACK|BP, 84
    321  0564				  -	      .byte	BLACK|B, 66
    322  0564				  -	      .byte	BLACK|R, 69
    323  0564				  -	      .byte	BLACK|K, 98
    324  0564				  -
    325  0564				  -	      .byte	BLACK|R, 92
    326  0564				  -
    327  0564				  -
    328  0564				  -
    329  0564				  -	      ENDIF
    330  0564				  -
    331  0564				  -
    332  0564				  -	      IF	0
    333  0564				  -			; En passant test
    334  0564				  -
    335  0564				  -	      .byte	BLACK|BP, 88
    336  0564				  -	      .byte	BLACK|BP, 86
    337  0564				  -
    338  0564				  -	      .byte	WHITE|WP, 67
    339  0564				  -	      .byte	WHITE|K, 52
    340  0564				  -
    341  0564				  -
    342  0564				  -	      ENDIF
    343  0564				  -
    344  0564				  -
    345  0564				  -
    346  0564				  -
    347  0564				  -	      IF	1
    348  0564				  -
    349  0564				  -
    350  0564				  -			;.byte BLACK|R, 97
    351  0564				  -	      .byte	BLACK|K, 98
    352  0564				  -	      .byte	BLACK|BP, 87
    353  0564				  -	      .byte	BLACK|BP, 88
    354  0564				  -	      .byte	BLACK|BP, 89
    355  0564				  -			;    .byte BLACK|B, 76
    356  0564				  -
    357  0564				  -
    358  0564				  -	      .byte	WHITE|R,28
    359  0564				  -	      .byte	WHITE|Q,58
    360  0564				  -			;   .byte WHITE|N,65
    361  0564				  -	      ENDIF
    362  0564				  -
    363  0564				  -	      IF	0
    364  0564				  -			;.byte WHITE|WP, 56
    365  0564				  -
    366  0564				  -
    367  0564				  -	      .byte	BLACK|K, 98
    368  0564				  -
    369  0564				  -
    370  0564				  -	      .byte	WHITE|R,29
    371  0564				  -	      .byte	WHITE|Q,49
    372  0564				  -	      .byte	WHITE|N,65
    373  0564				  -	      ENDIF
    374  0564				  -	      .byte	0	;end
    375  0564				  -
    376  0564					      ENDIF
    377  0564
    378  0564
    379  0564
    380  0564
    381  0564							;---------------------------------------------------------------------------------------------------
    382  0564
      0  0564					      DEF	AdjustMaterialPositionalValue
      1  0564				   SLOT_AdjustMaterialPositionalValue SET	_BANK_SLOT
      2  0564				   BANK_AdjustMaterialPositionalValue SET	SLOT_AdjustMaterialPositionalValue + _CURRENT_BANK
      3  0564				   AdjustMaterialPositionalValue
      4  0564				   TEMPORARY_VAR SET	Overlay
      5  0564				   TEMPORARY_OFFSET SET	0
      6  0564				   VAR_BOUNDARY_AdjustMaterialPositionalValue SET	TEMPORARY_OFFSET
      7  0564				   FUNCTION_NAME SET	AdjustMaterialPositionalValue
    384  0564					      SUBROUTINE
    385  0564
    386  0564							; A move is about to be made, so  adjust material and positional values based on from/to and
    387  0564							; capture.
    388  0564
    389  0564							; First, nominate referencing subroutines so that local variables can be adjusted properly
    390  0564
    391  0564							;TODO REFER negaMax
    392  0564							;TODO REFER MakeMove
    393  0564							;TODO REFER aiMoveIsSelected
      0  0564					      VAR	__originalPiece, 1
      1  0564		       00 a2	   __originalPiece =	TEMPORARY_VAR
      2  0564				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0564
      4  0564				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0564				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0564				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0564					      ENDIF
      8  0564				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0564				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  0564				  -	      ERR
     11  0564					      ENDIF
     12  0564					      LIST	ON
      0  0564					      VAR	__capturedPiece, 1
      1  0564		       00 a3	   __capturedPiece =	TEMPORARY_VAR
      2  0564				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0564
      4  0564				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0564				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0564				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0564					      ENDIF
      8  0564				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0564				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  0564				  -	      ERR
     11  0564					      ENDIF
     12  0564					      LIST	ON
      0  0564					      VEND	AdjustMaterialPositionalValue
      1  0564				  -	      IFNCONST	AdjustMaterialPositionalValue
      2  0564				  -	      ECHO	"Incorrect VEND label", AdjustMaterialPositionalValue
      3  0564				  -	      ERR
      4  0564					      ENDIF
      5  0564		       00 a4	   VAREND_AdjustMaterialPositionalValue =	TEMPORARY_VAR
    397  0564
    398  0564							; fromPiece	 piece doing the move (promoted type)
    399  0564							; fromX12	 current square
    400  0564							; originX12	 starting square
    401  0564							; toX12	 ending square
    402  0564
    403  0564
    404  0564							; get the piece types from the board
    405  0564
    406  0564		       a9 cf		      lda	#RAMBANK_BOARD
    407  0566		       85 3e		      sta	SET_BANK_RAM
    408  0568		       a4 87		      ldy	originX12
    409  056a		       b9 79 fc 	      lda	Board,y
    410  056d		       85 a2		      sta	__originalPiece
    411  056f		       a4 86		      ldy	toX12
    412  0571		       b9 79 fc 	      lda	Board,y
    413  0574		       85 a3		      sta	__capturedPiece
    414  0576
    415  0576							; {
    416  0576							;   adjust the positional value  (originX12 --> fromX12)
    417  0576
    418  0576		       a9 90		      lda	#RAMBANK_BANK_EVAL	;BANK_AddPiecePositionValue
    419  0578		       85 3e		      sta	SET_BANK_RAM
    420  057a
    421  057a
    422  057a							;ldy toX12
    423  057a		       a5 97		      lda	fromPiece
    424  057c		       20 c8 f5 	      jsr	AddPiecePositionValue	; add pos value for new position
    425  057f
    426  057f
    427  057f		       a5 a2		      lda	__originalPiece
    428  0581		       45 97		      eor	fromPiece	; the new piece
    429  0583		       29 0f		      and	#PIECE_MASK
    430  0585		       f0 05		      beq	.same1	; unchanged, so skip
    431  0587
    432  0587		       a5 97		      lda	fromPiece	; new piece
    433  0589							;and #PIECE_MASK
    434  0589							;tay
    435  0589		       20 0b f6 	      jsr	AddPieceMaterialValue
    436  058c
    437  058c				   .same1
    438  058c
    439  058c							; and now the 'subtracts'
    440  058c
      0  058c					      NEGEVAL
      1  058c
      2  058c		       38		      sec
      3  058d		       a9 00		      lda	#0
      4  058f		       e5 90		      sbc	Evaluation
      5  0591		       85 90		      sta	Evaluation
      6  0593		       a9 00		      lda	#0
      7  0595		       e5 91		      sbc	Evaluation+1
      8  0597		       85 91		      sta	Evaluation+1
    442  0599
    443  0599		       a4 87		      ldy	originX12
    444  059b		       a5 a2		      lda	__originalPiece
    445  059d		       20 c8 f5 	      jsr	AddPiecePositionValue	; remove pos value for original position
    446  05a0
    447  05a0
    448  05a0		       a5 a2		      lda	__originalPiece
    449  05a2		       45 97		      eor	fromPiece	; the new piece
    450  05a4		       29 0f		      and	#PIECE_MASK
    451  05a6		       f0 05		      beq	.same2	; unchanged, so skip
    452  05a8
    453  05a8		       a5 a2		      lda	__originalPiece
    454  05aa							;and #PIECE_MASK
    455  05aa							;tay
    456  05aa		       20 0b f6 	      jsr	AddPieceMaterialValue	; remove material for original type
    457  05ad				   .same2
    458  05ad
      0  05ad					      NEGEVAL
      1  05ad
      2  05ad		       38		      sec
      3  05ae		       a9 00		      lda	#0
      4  05b0		       e5 90		      sbc	Evaluation
      5  05b2		       85 90		      sta	Evaluation
      6  05b4		       a9 00		      lda	#0
      7  05b6		       e5 91		      sbc	Evaluation+1
      8  05b8		       85 91		      sta	Evaluation+1
    460  05ba
    461  05ba							; If there's a capture, we adjust the material value
    462  05ba
    463  05ba							;		      lda __capturedPiece
    464  05ba							;		      eor __originalPiece
    465  05ba							;		      bpl .noCapture		      ; special-case capture rook castling onto king
    466  05ba
    467  05ba
    468  05ba		       a5 a3		      lda	__capturedPiece
    469  05bc		       29 0f		      and	#PIECE_MASK
    470  05be		       f0 03		      beq	.noCapture
    471  05c0							;tay
    472  05c0		       20 0b f6 	      jsr	AddPieceMaterialValue	; -other colour = + my colour!
    473  05c3				   .noCapture
    474  05c3
    475  05c3							; }
    476  05c3		       a5 8b		      lda	savedBank
    477  05c5		       85 3f		      sta	SET_BANK
    478  05c7		       60		      rts
    479  05c8
    480  05c8
    481  05c8							;---------------------------------------------------------------------------------------------------
    482  05c8
      0  05c8					      DEF	AddPiecePositionValue
      1  05c8				   SLOT_AddPiecePositionValue SET	_BANK_SLOT
      2  05c8				   BANK_AddPiecePositionValue SET	SLOT_AddPiecePositionValue + _CURRENT_BANK
      3  05c8				   AddPiecePositionValue
      4  05c8				   TEMPORARY_VAR SET	Overlay
      5  05c8				   TEMPORARY_OFFSET SET	0
      6  05c8				   VAR_BOUNDARY_AddPiecePositionValue SET	TEMPORARY_OFFSET
      7  05c8				   FUNCTION_NAME SET	AddPiecePositionValue
    484  05c8					      SUBROUTINE
    485  05c8
      0  05c8					      REFER	AdjustMaterialPositionalValue
      1  05c8					      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  05c8				   TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  05c8					      ENDIF
      0  05c8					      REFER	EnPassantRemovePiece
      1  05c8					      IF	VAREND_EnPassantRemovePiece > TEMPORARY_VAR
      2  05c8				   TEMPORARY_VAR SET	VAREND_EnPassantRemovePiece
      3  05c8					      ENDIF
      0  05c8					      REFER	InitPieceLists
      1  05c8				  -	      IF	VAREND_InitPieceLists > TEMPORARY_VAR
      2  05c8				  -TEMPORARY_VAR SET	VAREND_InitPieceLists
      3  05c8					      ENDIF
      0  05c8					      REFER	negaMax
      1  05c8				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  05c8				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  05c8					      ENDIF
      0  05c8					      REFER	quiesce
      1  05c8				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  05c8				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  05c8					      ENDIF
    491  05c8
      0  05c8					      VAR	__valPtr, 2
      1  05c8		       00 b2	   __valPtr   =	TEMPORARY_VAR
      2  05c8				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  05c8
      4  05c8				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05c8				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05c8				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05c8					      ENDIF
      8  05c8				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  05c8				  -	      ECHO	"Temporary Variable", __valPtr, "overflow!"
     10  05c8				  -	      ERR
     11  05c8					      ENDIF
     12  05c8					      LIST	ON
      0  05c8					      VAR	__valHi, 1
      1  05c8		       00 b4	   __valHi    =	TEMPORARY_VAR
      2  05c8				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  05c8
      4  05c8				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05c8				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05c8				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05c8					      ENDIF
      8  05c8				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  05c8				  -	      ECHO	"Temporary Variable", __valHi, "overflow!"
     10  05c8				  -	      ERR
     11  05c8					      ENDIF
     12  05c8					      LIST	ON
      0  05c8					      VEND	AddPiecePositionValue
      1  05c8				  -	      IFNCONST	AddPiecePositionValue
      2  05c8				  -	      ECHO	"Incorrect VEND label", AddPiecePositionValue
      3  05c8				  -	      ERR
      4  05c8					      ENDIF
      5  05c8		       00 b5	   VAREND_AddPiecePositionValue =	TEMPORARY_VAR
    495  05c8
    496  05c8
    497  05c8							; adds value of square piece is on to the evaluation
    498  05c8							; note to do the subtraction as -( -x + val) == x - val
    499  05c8
    500  05c8							; y = square
    501  05c8							; a = piece type (+flags)
    502  05c8
    503  05c8
    504  05c8
    505  05c8		       c9 80		      cmp	#128	; black = CS
    506  05ca		       29 0f		      and	#PIECE_MASK
    507  05cc		       aa		      tax
    508  05cd
    509  05cd							; black pieces flip rows so we can use the same eval tables
    510  05cd
    511  05cd		       98		      tya
    512  05ce		       90 03		      bcc	.white
    513  05d0		       b9 1e f6 	      lda	FlipSquareIndex,y
    514  05d3							;clc
    515  05d3				   .white
    516  05d3		       7d 10 f8 	      adc	PosValVecLO,x
    517  05d6		       85 b2		      sta	__valPtr
    518  05d8		       bd 18 f8 	      lda	PosValVecHI,x
    519  05db		       69 00		      adc	#0
    520  05dd		       85 b3		      sta	__valPtr+1
    521  05df
    522  05df		       a0 00		      ldy	#0
    523  05e1		       84 b4		      sty	__valHi
    524  05e3		       b1 b2		      lda	(__valPtr),y
    525  05e5		       10 02		      bpl	.sum
    526  05e7		       c6 b4		      dec	__valHi
    527  05e9
    528  05e9		       18	   .sum       clc
    529  05ea		       65 90		      adc	Evaluation
    530  05ec		       85 90		      sta	Evaluation
    531  05ee		       a5 91		      lda	Evaluation+1
    532  05f0		       65 b4		      adc	__valHi
    533  05f2		       85 91		      sta	Evaluation+1
    534  05f4		       60		      rts
    535  05f5
    536  05f5
    537  05f5
    538  05f5							;---------------------------------------------------------------------------------------------------
    539  05f5
      0  05f5					      DEF	EnPassantRemovePiece
      1  05f5				   SLOT_EnPassantRemovePiece SET	_BANK_SLOT
      2  05f5				   BANK_EnPassantRemovePiece SET	SLOT_EnPassantRemovePiece + _CURRENT_BANK
      3  05f5				   EnPassantRemovePiece
      4  05f5				   TEMPORARY_VAR SET	Overlay
      5  05f5				   TEMPORARY_OFFSET SET	0
      6  05f5				   VAR_BOUNDARY_EnPassantRemovePiece SET	TEMPORARY_OFFSET
      7  05f5				   FUNCTION_NAME SET	EnPassantRemovePiece
    541  05f5					      SUBROUTINE
    542  05f5
    543  05f5							;TODO REFER MakeMove
    544  05f5					      IF	ENPASSANT_ENABLED
      0  05f5					      REFER	EnPassantCheck
      1  05f5					      IF	VAREND_EnPassantCheck > TEMPORARY_VAR
      2  05f5				   TEMPORARY_VAR SET	VAREND_EnPassantCheck
      3  05f5					      ENDIF
    546  05f5					      ENDIF
      0  05f5					      VAR	__y, 1
      1  05f5		       00 b0	   __y	      =	TEMPORARY_VAR
      2  05f5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  05f5
      4  05f5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05f5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05f5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05f5					      ENDIF
      8  05f5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  05f5				  -	      ECHO	"Temporary Variable", __y, "overflow!"
     10  05f5				  -	      ERR
     11  05f5					      ENDIF
     12  05f5					      LIST	ON
      0  05f5					      VAR	__col, 1
      1  05f5		       00 b1	   __col      =	TEMPORARY_VAR
      2  05f5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  05f5
      4  05f5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05f5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05f5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05f5					      ENDIF
      8  05f5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  05f5				  -	      ECHO	"Temporary Variable", __col, "overflow!"
     10  05f5				  -	      ERR
     11  05f5					      ENDIF
     12  05f5					      LIST	ON
      0  05f5					      VEND	EnPassantRemovePiece
      1  05f5				  -	      IFNCONST	EnPassantRemovePiece
      2  05f5				  -	      ECHO	"Incorrect VEND label", EnPassantRemovePiece
      3  05f5				  -	      ERR
      4  05f5					      ENDIF
      5  05f5		       00 b2	   VAREND_EnPassantRemovePiece =	TEMPORARY_VAR
    550  05f5
    551  05f5
    552  05f5							; Based on piece square, adjust material and position value with piece deleted
    553  05f5							; y = piece square
    554  05f5
    555  05f5		       84 b0		      sty	__y
    556  05f7
    557  05f7		       a9 cf		      lda	#RAMBANK_BOARD
    558  05f9		       85 3e		      sta	SET_BANK_RAM
    559  05fb		       b9 79 fc 	      lda	Board,y
    560  05fe		       85 b1		      sta	__col
    561  0600		       20 0b f6 	      jsr	AddPieceMaterialValue	; adding for opponent = taking
    562  0603
    563  0603		       a5 b1		      lda	__col
    564  0605		       a4 b0		      ldy	__y
    565  0607		       20 c8 f5 	      jsr	AddPiecePositionValue	; adding for opponent = taking
    566  060a
    567  060a		       60		      rts
    568  060b
    569  060b
    570  060b							;---------------------------------------------------------------------------------------------------
    571  060b
      0  060b					      DEF	AddPieceMaterialValue
      1  060b				   SLOT_AddPieceMaterialValue SET	_BANK_SLOT
      2  060b				   BANK_AddPieceMaterialValue SET	SLOT_AddPieceMaterialValue + _CURRENT_BANK
      3  060b				   AddPieceMaterialValue
      4  060b				   TEMPORARY_VAR SET	Overlay
      5  060b				   TEMPORARY_OFFSET SET	0
      6  060b				   VAR_BOUNDARY_AddPieceMaterialValue SET	TEMPORARY_OFFSET
      7  060b				   FUNCTION_NAME SET	AddPieceMaterialValue
    573  060b					      SUBROUTINE
    574  060b
      0  060b					      REFER	AdjustMaterialPositionalValue
      1  060b					      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  060b				   TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  060b					      ENDIF
      0  060b					      REFER	InitialisePieceSquares
      1  060b					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  060b				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  060b					      ENDIF
      0  060b					      REFER	EnPassantRemovePiece
      1  060b					      IF	VAREND_EnPassantRemovePiece > TEMPORARY_VAR
      2  060b				   TEMPORARY_VAR SET	VAREND_EnPassantRemovePiece
      3  060b					      ENDIF
      0  060b					      REFER	InitPieceLists
      1  060b				  -	      IF	VAREND_InitPieceLists > TEMPORARY_VAR
      2  060b				  -TEMPORARY_VAR SET	VAREND_InitPieceLists
      3  060b					      ENDIF
      0  060b					      VEND	AddPieceMaterialValue
      1  060b				  -	      IFNCONST	AddPieceMaterialValue
      2  060b				  -	      ECHO	"Incorrect VEND label", AddPieceMaterialValue
      3  060b				  -	      ERR
      4  060b					      ENDIF
      5  060b		       00 b2	   VAREND_AddPieceMaterialValue =	TEMPORARY_VAR
    580  060b
    581  060b							; Adjust the material score based on the piece
    582  060b							; a = piece type + flags
    583  060b
    584  060b		       29 0f		      and	#PIECE_MASK
    585  060d		       a8		      tay
    586  060e
    587  060e		       18		      clc
    588  060f		       b9 00 f8 	      lda	PieceValueLO,y
    589  0612		       65 90		      adc	Evaluation
    590  0614		       85 90		      sta	Evaluation
    591  0616		       b9 08 f8 	      lda	PieceValueHI,y
    592  0619		       65 91		      adc	Evaluation+1
    593  061b		       85 91		      sta	Evaluation+1
    594  061d		       60		      rts
    595  061e
    596  061e
    597  061e
    598  061e
    599  061e				  -	      IF	0
    600  061e				  -	      DEF	IncVal
    601  061e				  -	      SUBROUTINE
    602  061e				  -
    603  061e				  -	      ldx	#99
    604  061e				  -.higher    clc
    605  061e				  -	      lda@RAM	PositionalValue_PAWN_BLACK,x
    606  061e				  -	      adc	#10
    607  061e				  -	      cmp	#$7F
    608  061e				  -	      bcc	.norm
    609  061e				  -	      lda	#$7f
    610  061e				  -.norm      sta@RAM	PositionalValue_PAWN_BLACK,x
    611  061e				  -	      dex
    612  061e				  -	      bpl	.higher
    613  061e				  -	      rts
    614  061e					      ENDIF
    615  061e							;---------------------------------------------------------------------------------------------------
    616  061e
      0  061e					      ALLOCATE	FlipSquareIndex, 100
      0  061e					      OPTIONAL_PAGEBREAK	"Table", 100
     12  061e					      LIST	ON
      0  061e					      DEF	FlipSquareIndex
      1  061e				   SLOT_FlipSquareIndex SET	_BANK_SLOT
      2  061e				   BANK_FlipSquareIndex SET	SLOT_FlipSquareIndex + _CURRENT_BANK
      3  061e				   FlipSquareIndex
      4  061e				   TEMPORARY_VAR SET	Overlay
      5  061e				   TEMPORARY_OFFSET SET	0
      6  061e				   VAR_BOUNDARY_FlipSquareIndex SET	TEMPORARY_OFFSET
      7  061e				   FUNCTION_NAME SET	FlipSquareIndex
    618  061e
    619  061e		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    620  0628		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    621  0632
    622  0632				   .SQBASE    SET	90-1
    623  0632					      REPEAT	8
    624  0632		       00 00		      .byte.b	0,0
    625  0632				   .SQX       SET	2
    626  0634					      REPEAT	8
    627  0634		       5b		      .byte.b	(.SQBASE+.SQX)
    628  0634				   .SQX       SET	.SQX + 1
    626  0634					      REPEND
    627  0635		       5c		      .byte.b	(.SQBASE+.SQX)
    628  0635				   .SQX       SET	.SQX + 1
    626  0635					      REPEND
    627  0636		       5d		      .byte.b	(.SQBASE+.SQX)
    628  0636				   .SQX       SET	.SQX + 1
    626  0636					      REPEND
    627  0637		       5e		      .byte.b	(.SQBASE+.SQX)
    628  0637				   .SQX       SET	.SQX + 1
    626  0637					      REPEND
    627  0638		       5f		      .byte.b	(.SQBASE+.SQX)
    628  0638				   .SQX       SET	.SQX + 1
    626  0638					      REPEND
    627  0639		       60		      .byte.b	(.SQBASE+.SQX)
    628  0639				   .SQX       SET	.SQX + 1
    626  0639					      REPEND
    627  063a		       61		      .byte.b	(.SQBASE+.SQX)
    628  063a				   .SQX       SET	.SQX + 1
    626  063a					      REPEND
    627  063b		       62		      .byte.b	(.SQBASE+.SQX)
    628  063b				   .SQX       SET	.SQX + 1
    629  063c					      REPEND
    630  063c				   .SQBASE    SET	.SQBASE - 10
    623  063c					      REPEND
    624  063c		       00 00		      .byte.b	0,0
    625  063c				   .SQX       SET	2
    626  063e					      REPEAT	8
    627  063e		       51		      .byte.b	(.SQBASE+.SQX)
    628  063e				   .SQX       SET	.SQX + 1
    626  063e					      REPEND
    627  063f		       52		      .byte.b	(.SQBASE+.SQX)
    628  063f				   .SQX       SET	.SQX + 1
    626  063f					      REPEND
    627  0640		       53		      .byte.b	(.SQBASE+.SQX)
    628  0640				   .SQX       SET	.SQX + 1
    626  0640					      REPEND
    627  0641		       54		      .byte.b	(.SQBASE+.SQX)
    628  0641				   .SQX       SET	.SQX + 1
    626  0641					      REPEND
    627  0642		       55		      .byte.b	(.SQBASE+.SQX)
    628  0642				   .SQX       SET	.SQX + 1
    626  0642					      REPEND
    627  0643		       56		      .byte.b	(.SQBASE+.SQX)
    628  0643				   .SQX       SET	.SQX + 1
    626  0643					      REPEND
    627  0644		       57		      .byte.b	(.SQBASE+.SQX)
    628  0644				   .SQX       SET	.SQX + 1
    626  0644					      REPEND
    627  0645		       58		      .byte.b	(.SQBASE+.SQX)
    628  0645				   .SQX       SET	.SQX + 1
    629  0646					      REPEND
    630  0646				   .SQBASE    SET	.SQBASE - 10
    623  0646					      REPEND
    624  0646		       00 00		      .byte.b	0,0
    625  0646				   .SQX       SET	2
    626  0648					      REPEAT	8
    627  0648		       47		      .byte.b	(.SQBASE+.SQX)
    628  0648				   .SQX       SET	.SQX + 1
    626  0648					      REPEND
    627  0649		       48		      .byte.b	(.SQBASE+.SQX)
    628  0649				   .SQX       SET	.SQX + 1
    626  0649					      REPEND
    627  064a		       49		      .byte.b	(.SQBASE+.SQX)
    628  064a				   .SQX       SET	.SQX + 1
    626  064a					      REPEND
    627  064b		       4a		      .byte.b	(.SQBASE+.SQX)
    628  064b				   .SQX       SET	.SQX + 1
    626  064b					      REPEND
    627  064c		       4b		      .byte.b	(.SQBASE+.SQX)
    628  064c				   .SQX       SET	.SQX + 1
    626  064c					      REPEND
    627  064d		       4c		      .byte.b	(.SQBASE+.SQX)
    628  064d				   .SQX       SET	.SQX + 1
    626  064d					      REPEND
    627  064e		       4d		      .byte.b	(.SQBASE+.SQX)
    628  064e				   .SQX       SET	.SQX + 1
    626  064e					      REPEND
    627  064f		       4e		      .byte.b	(.SQBASE+.SQX)
    628  064f				   .SQX       SET	.SQX + 1
    629  0650					      REPEND
    630  0650				   .SQBASE    SET	.SQBASE - 10
    623  0650					      REPEND
    624  0650		       00 00		      .byte.b	0,0
    625  0650				   .SQX       SET	2
    626  0652					      REPEAT	8
    627  0652		       3d		      .byte.b	(.SQBASE+.SQX)
    628  0652				   .SQX       SET	.SQX + 1
    626  0652					      REPEND
    627  0653		       3e		      .byte.b	(.SQBASE+.SQX)
    628  0653				   .SQX       SET	.SQX + 1
    626  0653					      REPEND
    627  0654		       3f		      .byte.b	(.SQBASE+.SQX)
    628  0654				   .SQX       SET	.SQX + 1
    626  0654					      REPEND
    627  0655		       40		      .byte.b	(.SQBASE+.SQX)
    628  0655				   .SQX       SET	.SQX + 1
    626  0655					      REPEND
    627  0656		       41		      .byte.b	(.SQBASE+.SQX)
    628  0656				   .SQX       SET	.SQX + 1
    626  0656					      REPEND
    627  0657		       42		      .byte.b	(.SQBASE+.SQX)
    628  0657				   .SQX       SET	.SQX + 1
    626  0657					      REPEND
    627  0658		       43		      .byte.b	(.SQBASE+.SQX)
    628  0658				   .SQX       SET	.SQX + 1
    626  0658					      REPEND
    627  0659		       44		      .byte.b	(.SQBASE+.SQX)
    628  0659				   .SQX       SET	.SQX + 1
    629  065a					      REPEND
    630  065a				   .SQBASE    SET	.SQBASE - 10
    623  065a					      REPEND
    624  065a		       00 00		      .byte.b	0,0
    625  065a				   .SQX       SET	2
    626  065c					      REPEAT	8
    627  065c		       33		      .byte.b	(.SQBASE+.SQX)
    628  065c				   .SQX       SET	.SQX + 1
    626  065c					      REPEND
    627  065d		       34		      .byte.b	(.SQBASE+.SQX)
    628  065d				   .SQX       SET	.SQX + 1
    626  065d					      REPEND
    627  065e		       35		      .byte.b	(.SQBASE+.SQX)
    628  065e				   .SQX       SET	.SQX + 1
    626  065e					      REPEND
    627  065f		       36		      .byte.b	(.SQBASE+.SQX)
    628  065f				   .SQX       SET	.SQX + 1
    626  065f					      REPEND
    627  0660		       37		      .byte.b	(.SQBASE+.SQX)
    628  0660				   .SQX       SET	.SQX + 1
    626  0660					      REPEND
    627  0661		       38		      .byte.b	(.SQBASE+.SQX)
    628  0661				   .SQX       SET	.SQX + 1
    626  0661					      REPEND
    627  0662		       39		      .byte.b	(.SQBASE+.SQX)
    628  0662				   .SQX       SET	.SQX + 1
    626  0662					      REPEND
    627  0663		       3a		      .byte.b	(.SQBASE+.SQX)
    628  0663				   .SQX       SET	.SQX + 1
    629  0664					      REPEND
    630  0664				   .SQBASE    SET	.SQBASE - 10
    623  0664					      REPEND
    624  0664		       00 00		      .byte.b	0,0
    625  0664				   .SQX       SET	2
    626  0666					      REPEAT	8
    627  0666		       29		      .byte.b	(.SQBASE+.SQX)
    628  0666				   .SQX       SET	.SQX + 1
    626  0666					      REPEND
    627  0667		       2a		      .byte.b	(.SQBASE+.SQX)
    628  0667				   .SQX       SET	.SQX + 1
    626  0667					      REPEND
    627  0668		       2b		      .byte.b	(.SQBASE+.SQX)
    628  0668				   .SQX       SET	.SQX + 1
    626  0668					      REPEND
    627  0669		       2c		      .byte.b	(.SQBASE+.SQX)
    628  0669				   .SQX       SET	.SQX + 1
    626  0669					      REPEND
    627  066a		       2d		      .byte.b	(.SQBASE+.SQX)
    628  066a				   .SQX       SET	.SQX + 1
    626  066a					      REPEND
    627  066b		       2e		      .byte.b	(.SQBASE+.SQX)
    628  066b				   .SQX       SET	.SQX + 1
    626  066b					      REPEND
    627  066c		       2f		      .byte.b	(.SQBASE+.SQX)
    628  066c				   .SQX       SET	.SQX + 1
    626  066c					      REPEND
    627  066d		       30		      .byte.b	(.SQBASE+.SQX)
    628  066d				   .SQX       SET	.SQX + 1
    629  066e					      REPEND
    630  066e				   .SQBASE    SET	.SQBASE - 10
    623  066e					      REPEND
    624  066e		       00 00		      .byte.b	0,0
    625  066e				   .SQX       SET	2
    626  0670					      REPEAT	8
    627  0670		       1f		      .byte.b	(.SQBASE+.SQX)
    628  0670				   .SQX       SET	.SQX + 1
    626  0670					      REPEND
    627  0671		       20		      .byte.b	(.SQBASE+.SQX)
    628  0671				   .SQX       SET	.SQX + 1
    626  0671					      REPEND
    627  0672		       21		      .byte.b	(.SQBASE+.SQX)
    628  0672				   .SQX       SET	.SQX + 1
    626  0672					      REPEND
    627  0673		       22		      .byte.b	(.SQBASE+.SQX)
    628  0673				   .SQX       SET	.SQX + 1
    626  0673					      REPEND
    627  0674		       23		      .byte.b	(.SQBASE+.SQX)
    628  0674				   .SQX       SET	.SQX + 1
    626  0674					      REPEND
    627  0675		       24		      .byte.b	(.SQBASE+.SQX)
    628  0675				   .SQX       SET	.SQX + 1
    626  0675					      REPEND
    627  0676		       25		      .byte.b	(.SQBASE+.SQX)
    628  0676				   .SQX       SET	.SQX + 1
    626  0676					      REPEND
    627  0677		       26		      .byte.b	(.SQBASE+.SQX)
    628  0677				   .SQX       SET	.SQX + 1
    629  0678					      REPEND
    630  0678				   .SQBASE    SET	.SQBASE - 10
    623  0678					      REPEND
    624  0678		       00 00		      .byte.b	0,0
    625  0678				   .SQX       SET	2
    626  067a					      REPEAT	8
    627  067a		       15		      .byte.b	(.SQBASE+.SQX)
    628  067a				   .SQX       SET	.SQX + 1
    626  067a					      REPEND
    627  067b		       16		      .byte.b	(.SQBASE+.SQX)
    628  067b				   .SQX       SET	.SQX + 1
    626  067b					      REPEND
    627  067c		       17		      .byte.b	(.SQBASE+.SQX)
    628  067c				   .SQX       SET	.SQX + 1
    626  067c					      REPEND
    627  067d		       18		      .byte.b	(.SQBASE+.SQX)
    628  067d				   .SQX       SET	.SQX + 1
    626  067d					      REPEND
    627  067e		       19		      .byte.b	(.SQBASE+.SQX)
    628  067e				   .SQX       SET	.SQX + 1
    626  067e					      REPEND
    627  067f		       1a		      .byte.b	(.SQBASE+.SQX)
    628  067f				   .SQX       SET	.SQX + 1
    626  067f					      REPEND
    627  0680		       1b		      .byte.b	(.SQBASE+.SQX)
    628  0680				   .SQX       SET	.SQX + 1
    626  0680					      REPEND
    627  0681		       1c		      .byte.b	(.SQBASE+.SQX)
    628  0681				   .SQX       SET	.SQX + 1
    629  0682					      REPEND
    630  0682				   .SQBASE    SET	.SQBASE - 10
    631  0682					      REPEND
    632  0682
    633  0682
    634  0682							;---------------------------------------------------------------------------------------------------
    635  0682
      0  0682					      CHECK_BANK_SIZE	"BANK_1"
      1  0682		       02 82	   .TEMP      =	* - _BANK_START
 BANK_1 (1K) SIZE =  $282 , FREE= $17e
      2  0682					      ECHO	"BANK_1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  0682				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  0682				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_1", " size=", * - ORIGIN
      5  0682				  -	      ERR
      6  0682					      ENDIF
    637  0682
    638  0682							;---------------------------------------------------------------------------------------------------
    639  0682							; EOF
------- FILE ./chess.asm
------- FILE BANK_ROM_SHADOW_SCREEN.asm LEVEL 2 PASS 4
      0  0682					      include	"BANK_ROM_SHADOW_SCREEN.asm"
      1  0682
      0  0682					      SLOT	2
      1  0682				  -	      IF	(2 < 0) || (2 > 3)
      2  0682				  -	      ECHO	"Illegal bank address/segment location", 2
      3  0682				  -	      ERR
      4  0682					      ENDIF
      5  0682				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  0682				   _BANK_SLOT SET	2 * 64
      0  0682					      NEWBANK	BITMAP
      1  09a6 ????				      SEG	BITMAP
      2  0800					      ORG	_ORIGIN
      3  0800					      RORG	_BANK_ADDRESS_ORIGIN
      4  0800				   _BANK_START SET	*
      5  0800				   BITMAP_START SET	*
      6  0800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0800				   BITMAP     SET	_BANK_SLOT + _CURRENT_BANK
      8  0800				   _ORIGIN    SET	_ORIGIN + 1024
      4  0800
      5  0800							; These equates allow revectoring (address offset) if the RAM slot is not the same as the SHADOW slot
      6  0800
      7  0800		       f8 00	   ChessBitmap =	SHADOW_ChessBitmap
      8  0800
      9  0800		       f8 00	   ChessBitmap0 =	SHADOW_ChessBitmap0
     10  0800		       f8 18	   ChessBitmap1 =	SHADOW_ChessBitmap1
     11  0800		       f8 30	   ChessBitmap2 =	SHADOW_ChessBitmap2
     12  0800		       f8 48	   ChessBitmap3 =	SHADOW_ChessBitmap3
     13  0800		       f8 60	   ChessBitmap4 =	SHADOW_ChessBitmap4
     14  0800		       f8 78	   ChessBitmap5 =	SHADOW_ChessBitmap5
     15  0800
     16  0800							; Template bank for a SINGLE ROW of the chessboard display.
     17  0800							; There are 8x of these.
     18  0800							; The bank contains the definition of the bitmap, and also the code to draw the bitmap
     19  0800							; The bank is copied from ROM into RAM at startup.
     20  0800							; The draw switches between consecutive row banks, with the last returning
     21  0800							; we effectively have 1K
     22  0800							;---------------------------------------------------------------------------------------------------
     23  0800
     24  0800		       00 84	   COLOUR_LINE_1 =	$84
     25  0800		       00 36	   COLOUR_LINE_2 =	$36
     26  0800		       00 28	   COLOUR_LINE_3 =	$28
     27  0800		       00 00	   BACKGCOL   =	$00
     28  0800
     29  0800
     30  0800		       00 90	   ROW_BITMAP_SIZE =	6 * 24	; PF0/PF1/PF2/(PF0)/(PF1)/(PF2) x 8 ICC pixels
     31  0800
     32  0800
      0  0800					      ALLOCATE	SHADOW_ChessBitmap, ROW_BITMAP_SIZE
      0  0800					      OPTIONAL_PAGEBREAK	"Table", ROW_BITMAP_SIZE
     12  0800					      LIST	ON
      0  0800					      DEF	SHADOW_ChessBitmap
      1  0800				   SLOT_SHADOW_ChessBitmap SET	_BANK_SLOT
      2  0800				   BANK_SHADOW_ChessBitmap SET	SLOT_SHADOW_ChessBitmap + _CURRENT_BANK
      3  0800				   SHADOW_ChessBitmap
      4  0800				   TEMPORARY_VAR SET	Overlay
      5  0800				   TEMPORARY_OFFSET SET	0
      6  0800				   VAR_BOUNDARY_SHADOW_ChessBitmap SET	TEMPORARY_OFFSET
      7  0800				   FUNCTION_NAME SET	SHADOW_ChessBitmap
     34  0800		       00 00 00 00*SHADOW_ChessBitmap0 ds	24
     35  0818		       00 00 00 00*SHADOW_ChessBitmap1 ds	24
     36  0830		       00 00 00 00*SHADOW_ChessBitmap2 ds	24
     37  0848		       00 00 00 00*SHADOW_ChessBitmap3 ds	24
     38  0860		       00 00 00 00*SHADOW_ChessBitmap4 ds	24
     39  0878		       00 00 00 00*SHADOW_ChessBitmap5 ds	24
     40  0890
      0  0890					      ALLOCATE	BlankSprite, 8
      0  0890					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0890					      LIST	ON
      0  0890					      DEF	BlankSprite
      1  0890				   SLOT_BlankSprite SET	_BANK_SLOT
      2  0890				   BANK_BlankSprite SET	SLOT_BlankSprite + _CURRENT_BANK
      3  0890				   BlankSprite
      4  0890				   TEMPORARY_VAR SET	Overlay
      5  0890				   TEMPORARY_OFFSET SET	0
      6  0890				   VAR_BOUNDARY_BlankSprite SET	TEMPORARY_OFFSET
      7  0890				   FUNCTION_NAME SET	BlankSprite
     42  0890		       00 00 00 00*	      ds	8, 0
     43  0898
      0  0898					      ALLOCATE	SpriteBuffer, 8
      0  0898					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0898					      LIST	ON
      0  0898					      DEF	SpriteBuffer
      1  0898				   SLOT_SpriteBuffer SET	_BANK_SLOT
      2  0898				   BANK_SpriteBuffer SET	SLOT_SpriteBuffer + _CURRENT_BANK
      3  0898				   SpriteBuffer
      4  0898				   TEMPORARY_VAR SET	Overlay
      5  0898				   TEMPORARY_OFFSET SET	0
      6  0898				   VAR_BOUNDARY_SpriteBuffer SET	TEMPORARY_OFFSET
      7  0898				   FUNCTION_NAME SET	SpriteBuffer
     45  0898				   SpriteBuffer2
     46  0898		       f8		      .byte.b	%11111000
     47  0899		       f8		      .byte.b	%11111000
     48  089a		       f8		      .byte.b	%11111000
     49  089b		       f8		      .byte.b	%11111000
     50  089c		       f8		      .byte.b	%11111000
     51  089d		       f8		      .byte.b	%11111000
     52  089e		       f8		      .byte.b	%11111000
     53  089f		       f8		      .byte.b	%11111000
     54  08a0
     55  08a0				  -	      IF	0
     56  08a0				  -	      ALLOCATE	BackupBitmap, ROW_BITMAP_SIZE
     57  08a0				  -	      ds	ROW_BITMAP_SIZE, 0
     58  08a0					      ENDIF
     59  08a0
     60  08a0							;---------------------------------------------------------------------------------------------------
     61  08a0
     62  0900		       00 00 00 00*	      ALIGN	256
     63  0900					      SUBROUTINE
     64  0900
      0  0900					      REFER	StartupBankReset
      1  0900				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0900				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0900					      ENDIF
     66  0900				   __dummy
      0  0900					      VEND	__dummy
      1  0900				  -	      IFNCONST	__dummy
      2  0900				  -	      ECHO	"Incorrect VEND label", __dummy
      3  0900				  -	      ERR
      4  0900					      ENDIF
      5  0900		       00 a2	   VAREND___dummy =	TEMPORARY_VAR
     68  0900
     69  0900							; x = row # (and bank#)
     70  0900
     71  0900				   .endline
     72  0900
     73  0900							;@59
     74  0900
     75  0900							; The following 'inx' is replaced in the LAST row bank with a 'RTS', thus ending the draw loop
     76  0900							; Note that the other 7 row banks are unmodified (keeping the 'inx')
     77  0900				   SELFMOD_RTS_ON_LAST_ROW
     78  0900
     79  0900		       e8		      inx		; 2
     80  0901		       86 3e		      stx	SET_BANK_RAM	; 3 @64     BANK switch to next row
     81  0903
      0  0903					      DEF	DrawRow
      1  0903				   SLOT_DrawRow SET	_BANK_SLOT
      2  0903				   BANK_DrawRow SET	SLOT_DrawRow + _CURRENT_BANK
      3  0903				   DrawRow
      4  0903				   TEMPORARY_VAR SET	Overlay
      5  0903				   TEMPORARY_OFFSET SET	0
      6  0903				   VAR_BOUNDARY_DrawRow SET	TEMPORARY_OFFSET
      7  0903				   FUNCTION_NAME SET	DrawRow
     83  0903
     84  0903							;@64
     85  0903		       a0 07		      ldy	#7	; 2
     86  0905		       10 3b		      bpl	.dl2	; 3   (must be 69 here)
     87  0907
     88  0907							;@58...
     89  0907
     90  0907				   .l3
     91  0907
     92  0907		       b9 a8 f8    SMSPRITE16_0 lda	SpriteBuffer+16,y	; 4
     93  090a		       85 5b		      sta	GRP0	; 3
     94  090c		       b9 a8 f8    SMSPRITE16_1 lda	SpriteBuffer2+16,y	; 4
     95  090f		       85 5c		      sta	GRP1	; 3
     96  0911
     97  0911							;@-4
     98  0911
     99  0911		       a9 84		      lda	#COLOUR_LINE_1	;#$94			  ; 2
    100  0913		       85 48		      sta	COLUPF	; 3 @1
    101  0915
    102  0915		       b9 10 f8 	      lda	ChessBitmap0+16,y	; 4
    103  0918		       85 4d		      sta	PF0	; 3
    104  091a		       b9 28 f8 	      lda	ChessBitmap1+16,y	; 4
    105  091d		       85 4e		      sta	PF1	; 3
    106  091f		       b9 40 f8 	      lda	ChessBitmap2+16,y	; 4
    107  0922		       85 4f		      sta	PF2	; 3 @22
    108  0924
      0  0924					      SLEEP	6	; 6 @28
      1  0924				   .CYCLES    SET	6
      2  0924
      3  0924				  -	      IF	.CYCLES < 2
      4  0924				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0924				  -	      ERR
      6  0924					      ENDIF
      7  0924
      8  0924				  -	      IF	.CYCLES & 1
      9  0924				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0924				  -	      nop	0
     11  0924				  -	      ELSE
     12  0924				  -	      bit	VSYNC
     13  0924				  -	      ENDIF
     14  0924				  -.CYCLES    SET	.CYCLES - 3
     15  0924					      ENDIF
     16  0924
     17  0924					      REPEAT	.CYCLES / 2
     18  0924		       ea		      nop
     17  0924					      REPEND
     18  0925		       ea		      nop
     17  0925					      REPEND
     18  0926		       ea		      nop
     19  0927					      REPEND
    110  0927
    111  0927		       b9 58 f8 	      lda	ChessBitmap3+16,y	; 4
    112  092a		       85 4d		      sta	PF0	; 3
    113  092c		       b9 70 f8 	      lda	ChessBitmap4+16,y	; 4
    114  092f		       85 4e		      sta	PF1	; 3
    115  0931		       b9 88 f8 	      lda	ChessBitmap5+16,y	; 4
    116  0934		       8d 4f 00 	      sta.w	PF2	; 4 @50
    117  0937
      0  0937					      SLEEP	4	; 4
      1  0937				   .CYCLES    SET	4
      2  0937
      3  0937				  -	      IF	.CYCLES < 2
      4  0937				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0937				  -	      ERR
      6  0937					      ENDIF
      7  0937
      8  0937				  -	      IF	.CYCLES & 1
      9  0937				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0937				  -	      nop	0
     11  0937				  -	      ELSE
     12  0937				  -	      bit	VSYNC
     13  0937				  -	      ENDIF
     14  0937				  -.CYCLES    SET	.CYCLES - 3
     15  0937					      ENDIF
     16  0937
     17  0937					      REPEAT	.CYCLES / 2
     18  0937		       ea		      nop
     17  0937					      REPEND
     18  0938		       ea		      nop
     19  0939					      REPEND
    119  0939
    120  0939		       88		      dey		; 2
    121  093a		       30 c4		      bmi	.endline	; 2 (3)
    122  093c
    123  093c							;@57
    124  093c				   .drawLine
    125  093c
      0  093c					      SLEEP	11
      1  093c				   .CYCLES    SET	11
      2  093c
      3  093c				  -	      IF	.CYCLES < 2
      4  093c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  093c				  -	      ERR
      6  093c					      ENDIF
      7  093c
      8  093c					      IF	.CYCLES & 1
      9  093c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  093c		       04 00		      nop	0
     11  093e				  -	      ELSE
     12  093e				  -	      bit	VSYNC
     13  093e					      ENDIF
     14  093e				   .CYCLES    SET	.CYCLES - 3
     15  093e					      ENDIF
     16  093e
     17  093e					      REPEAT	.CYCLES / 2
     18  093e		       ea		      nop
     17  093e					      REPEND
     18  093f		       ea		      nop
     17  093f					      REPEND
     18  0940		       ea		      nop
     17  0940					      REPEND
     18  0941		       ea		      nop
     19  0942					      REPEND
    127  0942
    128  0942				   .dl2
    129  0942		       b9 98 f8    SMSPRITE0_0 lda	SpriteBuffer,y	; 4
    130  0945		       85 5b		      sta	GRP0	; 3
    131  0947		       b9 98 f8    SMSPRITE0_1 lda	SpriteBuffer2,y	; 4
    132  094a		       85 5c		      sta	GRP1	; 3
    133  094c
    134  094c							;@7
    135  094c
    136  094c		       a9 36		      lda	#COLOUR_LINE_2	;#$4A			  ; 2
    137  094e		       85 48		      sta	COLUPF	; 3 @12
    138  0950
    139  0950		       b9 00 f8 	      lda	ChessBitmap0,y	; 4
    140  0953		       85 4d		      sta	PF0	; 3
    141  0955		       b9 18 f8 	      lda	ChessBitmap1,y	; 4
    142  0958		       85 4e		      sta	PF1	; 3
    143  095a		       b9 30 f8 	      lda	ChessBitmap2,y	; 4
    144  095d		       85 4f		      sta	PF2	; 3 @33
    145  095f
      0  095f					      SLEEP	3	; 3 @36
      1  095f				   .CYCLES    SET	3
      2  095f
      3  095f				  -	      IF	.CYCLES < 2
      4  095f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  095f				  -	      ERR
      6  095f					      ENDIF
      7  095f
      8  095f					      IF	.CYCLES & 1
      9  095f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  095f		       04 00		      nop	0
     11  0961				  -	      ELSE
     12  0961				  -	      bit	VSYNC
     13  0961					      ENDIF
     14  0961				   .CYCLES    SET	.CYCLES - 3
     15  0961					      ENDIF
     16  0961
     17  0961				  -	      REPEAT	.CYCLES / 2
     18  0961				  -	      nop
     19  0961					      REPEND
    147  0961
    148  0961		       b9 48 f8 	      lda	ChessBitmap3,y	; 4
    149  0964		       85 4d		      sta	PF0	; 3
    150  0966		       b9 60 f8 	      lda	ChessBitmap4,y	; 4
    151  0969		       85 4e		      sta	PF1	; 3
    152  096b		       b9 78 f8 	      lda	ChessBitmap5,y	; 4
    153  096e		       85 4f		      sta	PF2	; 3 @57
    154  0970
      0  0970					      SLEEP	5
      1  0970				   .CYCLES    SET	5
      2  0970
      3  0970				  -	      IF	.CYCLES < 2
      4  0970				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0970				  -	      ERR
      6  0970					      ENDIF
      7  0970
      8  0970					      IF	.CYCLES & 1
      9  0970					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0970		       04 00		      nop	0
     11  0972				  -	      ELSE
     12  0972				  -	      bit	VSYNC
     13  0972					      ENDIF
     14  0972				   .CYCLES    SET	.CYCLES - 3
     15  0972					      ENDIF
     16  0972
     17  0972					      REPEAT	.CYCLES / 2
     18  0972		       ea		      nop
     19  0973					      REPEND
    156  0973
    157  0973		       b9 a0 f8    SMSPRITE8_0 lda	SpriteBuffer+8,y	; 4
    158  0976		       85 5b		      sta	GRP0	; 3
    159  0978		       b9 a0 f8    SMSPRITE8_1 lda	SpriteBuffer2+8,y	; 4
    160  097b		       85 5c		      sta	GRP1	; 3
    161  097d
    162  097d							;@0
    163  097d		       a9 28		      lda	#COLOUR_LINE_3	;#$28			  ; 2
    164  097f		       85 48		      sta	COLUPF	; 3 @5
    165  0981
    166  0981		       b9 08 f8 	      lda	ChessBitmap0+8,y	; 4
    167  0984		       85 4d		      sta	PF0	; 3
    168  0986		       b9 20 f8 	      lda	ChessBitmap1+8,y	; 4
    169  0989		       85 4e		      sta	PF1	; 3
    170  098b		       b9 38 f8 	      lda	ChessBitmap2+8,y	; 4
    171  098e		       85 4f		      sta	PF2	; 3 @26
    172  0990
      0  0990					      SLEEP	8	; 6 @34
      1  0990				   .CYCLES    SET	8
      2  0990
      3  0990				  -	      IF	.CYCLES < 2
      4  0990				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0990				  -	      ERR
      6  0990					      ENDIF
      7  0990
      8  0990				  -	      IF	.CYCLES & 1
      9  0990				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0990				  -	      nop	0
     11  0990				  -	      ELSE
     12  0990				  -	      bit	VSYNC
     13  0990				  -	      ENDIF
     14  0990				  -.CYCLES    SET	.CYCLES - 3
     15  0990					      ENDIF
     16  0990
     17  0990					      REPEAT	.CYCLES / 2
     18  0990		       ea		      nop
     17  0990					      REPEND
     18  0991		       ea		      nop
     17  0991					      REPEND
     18  0992		       ea		      nop
     17  0992					      REPEND
     18  0993		       ea		      nop
     19  0994					      REPEND
    174  0994
    175  0994		       b9 50 f8 	      lda	ChessBitmap3+8,y	; 4
    176  0997		       85 4d		      sta	PF0	; 3
    177  0999		       b9 68 f8 	      lda	ChessBitmap4+8,y	; 4
    178  099c		       85 4e		      sta	PF1	; 3
    179  099e		       b9 80 f8 	      lda	ChessBitmap5+8,y	; 4
    180  09a1		       85 4f		      sta	PF2	; 3 @55
    181  09a3
    182  09a3		       4c 07 f9 	      jmp	.l3	; 3 @58
    183  09a6
    184  09a6
    185  09a6
    186  09a6							;---------------------------------------------------------------------------------------------------
    187  09a6
      0  09a6					      CHECK_RAM_BANK_SIZE	"ROM_SHADOW_SCREEN"
      1  09a6		       01 a6	   .TEMP      =	* - _BANK_START
 ROM_SHADOW_SCREEN (512 byte) SIZE =  $1a6 , FREE= $5a
      2  09a6					      ECHO	"ROM_SHADOW_SCREEN", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3  09a6				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  09a6				  -	      ECHO	"BANK OVERFLOW @ ", "ROM_SHADOW_SCREEN", " size=", * - ORIGIN
      5  09a6				  -	      ERR
      6  09a6					      ENDIF
    189  09a6
    190  09a6							;---------------------------------------------------------------------------------------------------
    191  09a6							;EOF
------- FILE ./chess.asm
------- FILE ROM_SCREEN@3.asm LEVEL 2 PASS 4
      0  09a6					      include	"ROM_SCREEN@3.asm"
      1  09a6
      0  09a6					      SLOT	3
      1  09a6				  -	      IF	(3 < 0) || (3 > 3)
      2  09a6				  -	      ECHO	"Illegal bank address/segment location", 3
      3  09a6				  -	      ERR
      4  09a6					      ENDIF
      5  09a6				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  09a6				   _BANK_SLOT SET	3 * 64
      0  09a6					      NEWBANK	BITMAP2
      1  0cc0 ????				      SEG	BITMAP2
      2  0c00					      ORG	_ORIGIN
      3  0c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  0c00				   _BANK_START SET	*
      5  0c00				   BITMAP2_START SET	*
      6  0c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0c00				   BITMAP2    SET	_BANK_SLOT + _CURRENT_BANK
      8  0c00				   _ORIGIN    SET	_ORIGIN + 1024
      4  0c00
      5  0c00							;---------------------------------------------------------------------------------------------------
      6  0c00
      0  0c00					      DEF	ClearRowBitmap
      1  0c00				   SLOT_ClearRowBitmap SET	_BANK_SLOT
      2  0c00				   BANK_ClearRowBitmap SET	SLOT_ClearRowBitmap + _CURRENT_BANK
      3  0c00				   ClearRowBitmap
      4  0c00				   TEMPORARY_VAR SET	Overlay
      5  0c00				   TEMPORARY_OFFSET SET	0
      6  0c00				   VAR_BOUNDARY_ClearRowBitmap SET	TEMPORARY_OFFSET
      7  0c00				   FUNCTION_NAME SET	ClearRowBitmap
      8  0c00					      SUBROUTINE
      9  0c00
      0  0c00					      REFER	CallClear
      1  0c00				  -	      IF	VAREND_CallClear > TEMPORARY_VAR
      2  0c00				  -TEMPORARY_VAR SET	VAREND_CallClear
      3  0c00					      ENDIF
      0  0c00					      VEND	ClearRowBitmap
      1  0c00				  -	      IFNCONST	ClearRowBitmap
      2  0c00				  -	      ECHO	"Incorrect VEND label", ClearRowBitmap
      3  0c00				  -	      ERR
      4  0c00					      ENDIF
      5  0c00		       00 a2	   VAREND_ClearRowBitmap =	TEMPORARY_VAR
     12  0c00
     13  0c00							; No transient variable dependencies/calls
     14  0c00
     15  0c00		       a9 00		      lda	#0
     16  0c02		       a0 90		      ldy	#ROW_BITMAP_SIZE
      0  0c04				   .clearRow  sta@RAM	ChessBitmap-1,y
      1  0c04		       99 ff f9 	      sta	[RAM]+ChessBitmap-1,y
     18  0c07		       88		      dey
     19  0c08		       d0 fa		      bne	.clearRow
     20  0c0a		       60		      rts
     21  0c0b
     22  0c0b
     23  0c0b							;---------------------------------------------------------------------------------------------------
     24  0c0b
      0  0c0b					      DEF	CopyPieceToRowBitmap	;@3
      1  0c0b				   SLOT_CopyPieceToRowBitmap SET	_BANK_SLOT
      2  0c0b				   BANK_CopyPieceToRowBitmap SET	SLOT_CopyPieceToRowBitmap + _CURRENT_BANK
      3  0c0b				   CopyPieceToRowBitmap
      4  0c0b				   TEMPORARY_VAR SET	Overlay
      5  0c0b				   TEMPORARY_OFFSET SET	0
      6  0c0b				   VAR_BOUNDARY_CopyPieceToRowBitmap SET	TEMPORARY_OFFSET
      7  0c0b				   FUNCTION_NAME SET	CopyPieceToRowBitmap
     26  0c0b					      SUBROUTINE
     27  0c0b
     28  0c0b							;REFER CopySinglePiece 	  ; special-case due to 'intercept'
      0  0c0b					      VEND	CopyPieceToRowBitmap
      1  0c0b				  -	      IFNCONST	CopyPieceToRowBitmap
      2  0c0b				  -	      ECHO	"Incorrect VEND label", CopyPieceToRowBitmap
      3  0c0b				  -	      ERR
      4  0c0b					      ENDIF
      5  0c0b		       00 a2	   VAREND_CopyPieceToRowBitmap =	TEMPORARY_VAR
     30  0c0b
     31  0c0b		       a0 11		      ldy	#17
     32  0c0d		       b0 30		      bcs	.rightSide
     33  0c0f
     34  0c0f		       b9 a2 00    .copyPiece lda	__pieceShapeBuffer,y
     35  0c12		       f0 06		      beq	.blank1
     36  0c14		       59 00 f8 	      eor	ChessBitmap,y
      0  0c17					      sta@RAM	ChessBitmap,y
      1  0c17		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
     38  0c1a
     39  0c1a		       b9 b4 00    .blank1    lda	__pieceShapeBuffer+18,y
     40  0c1d		       f0 06		      beq	.blank2
     41  0c1f		       59 12 f8 	      eor	ChessBitmap+18,y
      0  0c22					      sta@RAM	ChessBitmap+18,y
      1  0c22		       99 12 fa 	      sta	[RAM]+ChessBitmap+18,y
     43  0c25
     44  0c25		       b9 c6 00    .blank2    lda	__pieceShapeBuffer+36,y
     45  0c28		       f0 06		      beq	.blank3
     46  0c2a		       59 24 f8 	      eor	ChessBitmap+36,y
      0  0c2d					      sta@RAM	ChessBitmap+36,y
      1  0c2d		       99 24 fa 	      sta	[RAM]+ChessBitmap+36,y
     48  0c30
     49  0c30		       b9 d8 00    .blank3    lda	__pieceShapeBuffer+54,y
     50  0c33		       f0 06		      beq	.blank4
     51  0c35		       59 36 f8 	      eor	ChessBitmap+54,y
      0  0c38					      sta@RAM	ChessBitmap+54,y
      1  0c38		       99 36 fa 	      sta	[RAM]+ChessBitmap+54,y
     53  0c3b
     54  0c3b		       88	   .blank4    dey
     55  0c3c		       10 d1		      bpl	.copyPiece
     56  0c3e		       60		      rts
     57  0c3f
     58  0c3f				   .rightSide
     59  0c3f
     60  0c3f					      SUBROUTINE
     61  0c3f
     62  0c3f		       b9 a2 00    .copyPieceR lda	__pieceShapeBuffer,y
     63  0c42		       f0 06		      beq	.blank1
     64  0c44		       59 48 f8 	      eor	ChessBitmap+72,y
      0  0c47					      sta@RAM	ChessBitmap+72,y
      1  0c47		       99 48 fa 	      sta	[RAM]+ChessBitmap+72,y
     66  0c4a
     67  0c4a		       b9 b4 00    .blank1    lda	__pieceShapeBuffer+18,y
     68  0c4d		       f0 06		      beq	.blank2
     69  0c4f		       59 5a f8 	      eor	ChessBitmap+72+18,y
      0  0c52					      sta@RAM	ChessBitmap+72+18,y
      1  0c52		       99 5a fa 	      sta	[RAM]+ChessBitmap+72+18,y
     71  0c55
     72  0c55		       b9 c6 00    .blank2    lda	__pieceShapeBuffer+36,y
     73  0c58		       f0 06		      beq	.blank3
     74  0c5a		       59 6c f8 	      eor	ChessBitmap+72+36,y
      0  0c5d					      sta@RAM	ChessBitmap+72+36,y
      1  0c5d		       99 6c fa 	      sta	[RAM]+ChessBitmap+72+36,y
     76  0c60
     77  0c60		       b9 d8 00    .blank3    lda	__pieceShapeBuffer+54,y
     78  0c63		       f0 06		      beq	.blank4
     79  0c65		       59 7e f8 	      eor	ChessBitmap+72+54,y
      0  0c68					      sta@RAM	ChessBitmap+72+54,y
      1  0c68		       99 7e fa 	      sta	[RAM]+ChessBitmap+72+54,y
     81  0c6b
     82  0c6b		       88	   .blank4    dey
     83  0c6c		       10 d1		      bpl	.copyPieceR
     84  0c6e		       60		      rts
     85  0c6f
     86  0c6f
     87  0c6f							;---------------------------------------------------------------------------------------------------
     88  0c6f
     89  0c6f					      IF	1
      0  0c6f					      DEF	WriteBlank
      1  0c6f				   SLOT_WriteBlank SET	_BANK_SLOT
      2  0c6f				   BANK_WriteBlank SET	SLOT_WriteBlank + _CURRENT_BANK
      3  0c6f				   WriteBlank
      4  0c6f				   TEMPORARY_VAR SET	Overlay
      5  0c6f				   TEMPORARY_OFFSET SET	0
      6  0c6f				   VAR_BOUNDARY_WriteBlank SET	TEMPORARY_OFFSET
      7  0c6f				   FUNCTION_NAME SET	WriteBlank
     91  0c6f					      SUBROUTINE
     92  0c6f
      0  0c6f					      REFER	StartupBankReset
      1  0c6f				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0c6f				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0c6f					      ENDIF
      0  0c6f					      VEND	WriteBlank
      1  0c6f				  -	      IFNCONST	WriteBlank
      2  0c6f				  -	      ECHO	"Incorrect VEND label", WriteBlank
      3  0c6f				  -	      ERR
      4  0c6f					      ENDIF
      5  0c6f		       00 a2	   VAREND_WriteBlank =	TEMPORARY_VAR
     95  0c6f
     96  0c6f		       a9 90		      lda	#<BlankSprite
      0  0c71					      sta@RAM	SMSPRITE0_0+1
      1  0c71		       8d 43 fb 	      sta	[RAM]+SMSPRITE0_0+1
      0  0c74					      sta@RAM	SMSPRITE8_0+1
      1  0c74		       8d 74 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  0c77					      sta@RAM	SMSPRITE16_0+1
      1  0c77		       8d 08 fb 	      sta	[RAM]+SMSPRITE16_0+1
      0  0c7a					      sta@RAM	SMSPRITE0_1+1
      1  0c7a		       8d 48 fb 	      sta	[RAM]+SMSPRITE0_1+1
      0  0c7d					      sta@RAM	SMSPRITE8_1+1
      1  0c7d		       8d 79 fb 	      sta	[RAM]+SMSPRITE8_1+1
      0  0c80					      sta@RAM	SMSPRITE16_1+1
      1  0c80		       8d 0d fb 	      sta	[RAM]+SMSPRITE16_1+1
    103  0c83
    104  0c83		       a9 f8		      lda	#>BlankSprite
      0  0c85					      sta@RAM	SMSPRITE0_0+2
      1  0c85		       8d 44 fb 	      sta	[RAM]+SMSPRITE0_0+2
      0  0c88					      sta@RAM	SMSPRITE8_0+2
      1  0c88		       8d 75 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  0c8b					      sta@RAM	SMSPRITE16_0+2
      1  0c8b		       8d 09 fb 	      sta	[RAM]+SMSPRITE16_0+2
      0  0c8e					      sta@RAM	SMSPRITE0_1+2
      1  0c8e		       8d 49 fb 	      sta	[RAM]+SMSPRITE0_1+2
      0  0c91					      sta@RAM	SMSPRITE8_1+2
      1  0c91		       8d 7a fb 	      sta	[RAM]+SMSPRITE8_1+2
      0  0c94					      sta@RAM	SMSPRITE16_1+2
      1  0c94		       8d 0e fb 	      sta	[RAM]+SMSPRITE16_1+2
    111  0c97
    112  0c97		       60		      rts
    113  0c98					      ENDIF
    114  0c98
    115  0c98							;---------------------------------------------------------------------------------------------------
    116  0c98
    117  0c98					      IF	1
      0  0c98					      DEF	WriteCursor
      1  0c98				   SLOT_WriteCursor SET	_BANK_SLOT
      2  0c98				   BANK_WriteCursor SET	SLOT_WriteCursor + _CURRENT_BANK
      3  0c98				   WriteCursor
      4  0c98				   TEMPORARY_VAR SET	Overlay
      5  0c98				   TEMPORARY_OFFSET SET	0
      6  0c98				   VAR_BOUNDARY_WriteCursor SET	TEMPORARY_OFFSET
      7  0c98				   FUNCTION_NAME SET	WriteCursor
    119  0c98					      SUBROUTINE
    120  0c98
      0  0c98					      REFER	StartupBankReset
      1  0c98				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0c98				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0c98					      ENDIF
      0  0c98					      VEND	WriteCursor
      1  0c98				  -	      IFNCONST	WriteCursor
      2  0c98				  -	      ECHO	"Incorrect VEND label", WriteCursor
      3  0c98				  -	      ERR
      4  0c98					      ENDIF
      5  0c98		       00 a2	   VAREND_WriteCursor =	TEMPORARY_VAR
    123  0c98
    124  0c98		       38		      sec
    125  0c99		       a5 88		      lda	cursorX12
    126  0c9b		       30 22		      bmi	.exit
    127  0c9d		       a2 0a		      ldx	#10
    128  0c9f		       e9 0a	   .sub10     sbc	#10
    129  0ca1		       ca		      dex
    130  0ca2		       b0 fb		      bcs	.sub10
    131  0ca4
    132  0ca4		       8a		      txa
    133  0ca5		       69 80		      adc	#SLOT_DrawRow	;cc implied
    134  0ca7		       85 3e		      sta	SET_BANK_RAM
    135  0ca9
    136  0ca9		       a9 98		      lda	#<SpriteBuffer
      0  0cab					      sta@RAM	SMSPRITE0_0+1
      1  0cab		       8d 43 fb 	      sta	[RAM]+SMSPRITE0_0+1
      0  0cae					      sta@RAM	SMSPRITE8_0+1
      1  0cae		       8d 74 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  0cb1					      sta@RAM	SMSPRITE16_0+1
      1  0cb1		       8d 08 fb 	      sta	[RAM]+SMSPRITE16_0+1
    140  0cb4		       a9 f8		      lda	#>SpriteBuffer
      0  0cb6					      sta@RAM	SMSPRITE0_0+2
      1  0cb6		       8d 44 fb 	      sta	[RAM]+SMSPRITE0_0+2
      0  0cb9					      sta@RAM	SMSPRITE8_0+2
      1  0cb9		       8d 75 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  0cbc					      sta@RAM	SMSPRITE16_0+2
      1  0cbc		       8d 09 fb 	      sta	[RAM]+SMSPRITE16_0+2
    144  0cbf
    145  0cbf		       60	   .exit      rts
    146  0cc0					      ENDIF
    147  0cc0
    148  0cc0
    149  0cc0							;---------------------------------------------------------------------------------------------------
    150  0cc0
    151  0cc0				  -	      IF	0
    152  0cc0				  -	      DEF	SaveBitmap
    153  0cc0				  -	      SUBROUTINE
    154  0cc0				  -
    155  0cc0				  -	      REFER	SAFE_BackupBitmaps
    156  0cc0				  -	      VEND	SaveBitmap
    157  0cc0				  -
    158  0cc0				  -	      ldy	#71
    159  0cc0				  -.fromTo    lda	ChessBitmap,y
    160  0cc0				  -	      sta@RAM	BackupBitmap,y
    161  0cc0				  -	      lda	ChessBitmap+72,y
    162  0cc0				  -	      sta@RAM	BackupBitmap+72,y
    163  0cc0				  -	      dey
    164  0cc0				  -	      bpl	.fromTo
    165  0cc0				  -	      rts
    166  0cc0					      ENDIF
    167  0cc0
    168  0cc0							;---------------------------------------------------------------------------------------------------
    169  0cc0
    170  0cc0				  -	      IF	0
    171  0cc0				  -
    172  0cc0				  -	      DEF	RestoreBitmap
    173  0cc0				  -	      SUBROUTINE
    174  0cc0				  -
    175  0cc0				  -	      VEND	RestoreBitmap
    176  0cc0				  -
    177  0cc0				  -	      ldy	#71
    178  0cc0				  -.fromTo    lda	BackupBitmap,y
    179  0cc0				  -	      sta@RAM	ChessBitmap,y
    180  0cc0				  -	      lda	BackupBitmap+72,y
    181  0cc0				  -	      sta@RAM	ChessBitmap+72,y
    182  0cc0				  -	      dey
    183  0cc0				  -	      bpl	.fromTo
    184  0cc0				  -	      rts
    185  0cc0					      ENDIF
    186  0cc0
    187  0cc0							;---------------------------------------------------------------------------------------------------
    188  0cc0
    189  0cc0				  -	      IF	0
    190  0cc0				  -
    191  0cc0				  -	      DEF	CopyTextToRowBitmap
    192  0cc0				  -	      SUBROUTINE
    193  0cc0				  -
    194  0cc0				  -	      VEND	CopyTextToRowBitmap
    195  0cc0				  -
    196  0cc0				  -			; An OR-draw, used for placing matricies/text onscreen
    197  0cc0				  -			; Similar to the EOR - first copy data into __pieceShapeBuffer, then call this function
    198  0cc0				  -			; The draw can be bracketed by "SaveBitmap" and "RestoreBitmap" to leave screen
    199  0cc0				  -			; in original state once text disappears
    200  0cc0				  -
    201  0cc0				  -	      ldy	#71
    202  0cc0				  -	      bcs	.rightSide
    203  0cc0				  -
    204  0cc0				  -.copy      lda	__pieceShapeBuffer,y
    205  0cc0				  -	      ora	ChessBitmap,y
    206  0cc0				  -	      sta@RAM	ChessBitmap,y
    207  0cc0				  -	      dey
    208  0cc0				  -	      bpl	.copy
    209  0cc0				  -
    210  0cc0				  -	      rts
    211  0cc0				  -
    212  0cc0				  -.rightSide
    213  0cc0				  -
    214  0cc0				  -	      SUBROUTINE
    215  0cc0				  -
    216  0cc0				  -.copy      lda	__pieceShapeBuffer,y
    217  0cc0				  -	      ora	ChessBitmap+72,y
    218  0cc0				  -	      sta@RAM	ChessBitmap+72,y
    219  0cc0				  -	      dey
    220  0cc0				  -	      bpl	.copy
    221  0cc0				  -
    222  0cc0				  -	      rts
    223  0cc0				  -
    224  0cc0					      ENDIF
    225  0cc0
    226  0cc0							;---------------------------------------------------------------------------------------------------
    227  0cc0
      0  0cc0					      CHECK_RAM_BANK_SIZE	"ROM_SHADOW_SCREEN"
      1  0cc0		       00 c0	   .TEMP      =	* - _BANK_START
 ROM_SHADOW_SCREEN (512 byte) SIZE =  $c0 , FREE= $140
      2  0cc0					      ECHO	"ROM_SHADOW_SCREEN", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3  0cc0				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  0cc0				  -	      ECHO	"BANK OVERFLOW @ ", "ROM_SHADOW_SCREEN", " size=", * - ORIGIN
      5  0cc0				  -	      ERR
      6  0cc0					      ENDIF
    229  0cc0
    230  0cc0							;---------------------------------------------------------------------------------------------------
    231  0cc0							;EOF
------- FILE ./chess.asm
------- FILE BANK_PLY.asm LEVEL 2 PASS 4
      0  0cc0					      include	"BANK_PLY.asm"
      1  0cc0							; Copyright (C)2020 Andrew Davie
      2  0cc0							; andrew@taswegian.com
      3  0cc0
      0  0cc0					      SLOT	2	;TODO
      1  0cc0				  -	      IF	(2 < 0) || (2 > 3)
      2  0cc0				  -	      ECHO	"Illegal bank address/segment location", 2
      3  0cc0				  -	      ERR
      4  0cc0					      ENDIF
      5  0cc0				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  0cc0				   _BANK_SLOT SET	2 * 64
      0  0cc0					      NEWBANK	BANK_PLY	; ROM SHADOW
      1  125f ????				      SEG	BANK_PLY
      2  1000					      ORG	_ORIGIN
      3  1000					      RORG	_BANK_ADDRESS_ORIGIN
      4  1000				   _BANK_START SET	*
      5  1000				   BANK_PLY_START SET	*
      6  1000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1000				   BANK_PLY   SET	_BANK_SLOT + _CURRENT_BANK
      8  1000				   _ORIGIN    SET	_ORIGIN + 1024
      6  1000
      7  1000
      8  1000							;---------------------------------------------------------------------------------------------------
      9  1000
      0  1000					      DEF	NewPlyInitialise
      1  1000				   SLOT_NewPlyInitialise SET	_BANK_SLOT
      2  1000				   BANK_NewPlyInitialise SET	SLOT_NewPlyInitialise + _CURRENT_BANK
      3  1000				   NewPlyInitialise
      4  1000				   TEMPORARY_VAR SET	Overlay
      5  1000				   TEMPORARY_OFFSET SET	0
      6  1000				   VAR_BOUNDARY_NewPlyInitialise SET	TEMPORARY_OFFSET
      7  1000				   FUNCTION_NAME SET	NewPlyInitialise
     11  1000					      SUBROUTINE
     12  1000
      0  1000					      REFER	GenerateAllMoves
      1  1000					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1000				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1000					      ENDIF
      0  1000					      REFER	negaMax
      1  1000				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  1000				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  1000					      ENDIF
      0  1000					      VEND	NewPlyInitialise
      1  1000				  -	      IFNCONST	NewPlyInitialise
      2  1000				  -	      ECHO	"Incorrect VEND label", NewPlyInitialise
      3  1000				  -	      ERR
      4  1000					      ENDIF
      5  1000		       00 b3	   VAREND_NewPlyInitialise =	TEMPORARY_VAR
     16  1000
     17  1000							; This MUST be called at the start of a new ply
     18  1000							; It initialises the movelist to empty
     19  1000							; x must be preserved
     20  1000
     21  1000							; note that 'alpha' and 'beta' are set externally!!
     22  1000
     23  1000		       a9 ff		      lda	#-1
      0  1002					      sta@PLY	moveIndex	; no valid moves
      1  1002		       8d 9e 01 	      sta	[RAM]+moveIndex
      0  1005					      sta@PLY	bestMove
      1  1005		       8d a0 01 	      sta	[RAM]+bestMove
     26  1008
     27  1008		       a5 94		      lda	enPassantPawn	; flag/square from last actual move made
      0  100a					      sta@PLY	enPassantSquare	; used for backtracking, to reset the flag
      1  100a		       8d 98 01 	      sta	[RAM]+enPassantSquare
     29  100d
     30  100d
     31  100d							; The value of the material (signed, 16-bit) is restored to the saved value at the reversion
     32  100d							; of a move. It's quicker to restore than to re-sum. So we save the current evaluation at the
     33  100d							; start of each new ply.
     34  100d
     35  100d		       a5 90		      lda	Evaluation
      0  100f					      sta@PLY	savedEvaluation
      1  100f		       8d 96 01 	      sta	[RAM]+savedEvaluation
     37  1012		       a5 91		      lda	Evaluation+1
      0  1014					      sta@PLY	savedEvaluation+1
      1  1014		       8d 97 01 	      sta	[RAM]+savedEvaluation+1
     39  1017
     40  1017		       60		      rts
     41  1018
     42  1018
     43  1018							;---------------------------------------------------------------------------------------------------
     44  1018
      0  1018					      DEF	CheckMoveListFromSquare
      1  1018				   SLOT_CheckMoveListFromSquare SET	_BANK_SLOT
      2  1018				   BANK_CheckMoveListFromSquare SET	SLOT_CheckMoveListFromSquare + _CURRENT_BANK
      3  1018				   CheckMoveListFromSquare
      4  1018				   TEMPORARY_VAR SET	Overlay
      5  1018				   TEMPORARY_OFFSET SET	0
      6  1018				   VAR_BOUNDARY_CheckMoveListFromSquare SET	TEMPORARY_OFFSET
      7  1018				   FUNCTION_NAME SET	CheckMoveListFromSquare
     46  1018					      SUBROUTINE
     47  1018
      0  1018					      REFER	IsValidMoveFromSquare
      1  1018				  -	      IF	VAREND_IsValidMoveFromSquare > TEMPORARY_VAR
      2  1018				  -TEMPORARY_VAR SET	VAREND_IsValidMoveFromSquare
      3  1018					      ENDIF
      0  1018					      VEND	CheckMoveListFromSquare
      1  1018				  -	      IFNCONST	CheckMoveListFromSquare
      2  1018				  -	      ECHO	"Incorrect VEND label", CheckMoveListFromSquare
      3  1018				  -	      ERR
      4  1018					      ENDIF
      5  1018		       00 a2	   VAREND_CheckMoveListFromSquare =	TEMPORARY_VAR
     50  1018
     51  1018							; X12 in A
     52  1018							; y = -1 on return if NOT FOUND
     53  1018
      0  1018					      ldy@RAM	moveIndex
      1  1018		       ac 9e ff 	      ldy	moveIndex
     55  101b		       30 08		      bmi	.exit
     56  101d
     57  101d		       d9 00 fc    .scan      cmp	MoveFrom,y
     58  1020		       f0 04		      beq	.scanned
     59  1022		       88		      dey
     60  1023		       10 f8		      bpl	.scan
     61  1025		       60	   .exit      rts
     62  1026
      0  1026				   .scanned   lda@PLY	MovePiece,y
      1  1026		       b9 00 fe 	      lda	MovePiece,y
     64  1029		       85 97		      sta	fromPiece
     65  102b		       60		      rts
     66  102c
     67  102c
     68  102c							;---------------------------------------------------------------------------------------------------
     69  102c
      0  102c					      DEF	GetPieceGivenFromToSquares
      1  102c				   SLOT_GetPieceGivenFromToSquares SET	_BANK_SLOT
      2  102c				   BANK_GetPieceGivenFromToSquares SET	SLOT_GetPieceGivenFromToSquares + _CURRENT_BANK
      3  102c				   GetPieceGivenFromToSquares
      4  102c				   TEMPORARY_VAR SET	Overlay
      5  102c				   TEMPORARY_OFFSET SET	0
      6  102c				   VAR_BOUNDARY_GetPieceGivenFromToSquares SET	TEMPORARY_OFFSET
      7  102c				   FUNCTION_NAME SET	GetPieceGivenFromToSquares
     71  102c					      SUBROUTINE
     72  102c
      0  102c					      REFER	GetPiece
      1  102c				  -	      IF	VAREND_GetPiece > TEMPORARY_VAR
      2  102c				  -TEMPORARY_VAR SET	VAREND_GetPiece
      3  102c					      ENDIF
      0  102c					      VEND	GetPieceGivenFromToSquares
      1  102c				  -	      IFNCONST	GetPieceGivenFromToSquares
      2  102c				  -	      ECHO	"Incorrect VEND label", GetPieceGivenFromToSquares
      3  102c				  -	      ERR
      4  102c					      ENDIF
      5  102c		       00 a2	   VAREND_GetPieceGivenFromToSquares =	TEMPORARY_VAR
     75  102c
     76  102c							; returns piece in A+fromPiece
     77  102c							; or Y=-1 if not found
     78  102c
     79  102c							; We need to get the piece from the movelist because it contains flags (e.g., castling) about
     80  102c							; the move. We need to do from/to checks because moves can have multiple origin/desinations.
     81  102c							; This fixes the move with/without castle flag
     82  102c
     83  102c
      0  102c					      ldy@PLY	moveIndex
      1  102c		       ac 9e ff 	      ldy	moveIndex
     85  102f							;bmi .fail		  ; shouldn't happen
     86  102f		       a5 85	   .scan      lda	fromX12
      0  1031					      cmp@PLY	MoveFrom,y
      1  1031		       d9 00 fc 	      cmp	MoveFrom,y
     88  1034		       d0 07		      bne	.next
     89  1036		       a5 86		      lda	toX12
      0  1038					      cmp@PLY	MoveTo,y
      1  1038		       d9 00 fd 	      cmp	MoveTo,y
     91  103b		       f0 04		      beq	.found
     92  103d		       88	   .next      dey
     93  103e		       10 ef		      bpl	.scan
     94  1040		       60	   .fail      rts
     95  1041
      0  1041				   .found     lda@PLY	MovePiece,y
      1  1041		       b9 00 fe 	      lda	MovePiece,y
     97  1044		       85 97		      sta	fromPiece
     98  1046		       60		      rts
     99  1047
    100  1047
    101  1047
    102  1047							;---------------------------------------------------------------------------------------------------
    103  1047
      0  1047					      DEF	selectmove
      1  1047				   SLOT_selectmove SET	_BANK_SLOT
      2  1047				   BANK_selectmove SET	SLOT_selectmove + _CURRENT_BANK
      3  1047				   selectmove
      4  1047				   TEMPORARY_VAR SET	Overlay
      5  1047				   TEMPORARY_OFFSET SET	0
      6  1047				   VAR_BOUNDARY_selectmove SET	TEMPORARY_OFFSET
      7  1047				   FUNCTION_NAME SET	selectmove
    105  1047					      SUBROUTINE
    106  1047
      0  1047					      COMMON_VARS_ALPHABETA
      1  1047
      0  1047					      VAR	__thinkbar, 1
      1  1047		       00 a2	   __thinkbar =	TEMPORARY_VAR
      2  1047				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1047
      4  1047				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1047				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1047				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1047					      ENDIF
      8  1047				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1047				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  1047				  -	      ERR
     11  1047					      ENDIF
     12  1047					      LIST	ON
      0  1047					      VAR	__toggle, 1
      1  1047		       00 a3	   __toggle   =	TEMPORARY_VAR
      2  1047				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1047
      4  1047				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1047				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1047				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1047					      ENDIF
      8  1047				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1047				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  1047				  -	      ERR
     11  1047					      ENDIF
     12  1047					      LIST	ON
      4  1047
      0  1047					      VAR	__bestMove, 1
      1  1047		       00 a4	   __bestMove =	TEMPORARY_VAR
      2  1047				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1047
      4  1047				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1047				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1047				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1047					      ENDIF
      8  1047				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1047				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  1047				  -	      ERR
     11  1047					      ENDIF
     12  1047					      LIST	ON
      0  1047					      VAR	__alpha, 2
      1  1047		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  1047				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1047
      4  1047				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1047				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1047				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1047					      ENDIF
      8  1047				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1047				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  1047				  -	      ERR
     11  1047					      ENDIF
     12  1047					      LIST	ON
      0  1047					      VAR	__beta, 2
      1  1047		       00 a7	   __beta     =	TEMPORARY_VAR
      2  1047				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1047
      4  1047				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1047				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1047				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1047					      ENDIF
      8  1047				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1047				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  1047				  -	      ERR
     11  1047					      ENDIF
     12  1047					      LIST	ON
      0  1047					      VAR	__negaMax, 2
      1  1047		       00 a9	   __negaMax  =	TEMPORARY_VAR
      2  1047				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1047
      4  1047				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1047				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1047				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1047					      ENDIF
      8  1047				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1047				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  1047				  -	      ERR
     11  1047					      ENDIF
     12  1047					      LIST	ON
      0  1047					      VAR	__value, 2
      1  1047		       00 ab	   __value    =	TEMPORARY_VAR
      2  1047				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1047
      4  1047				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1047				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1047				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1047					      ENDIF
      8  1047				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1047				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  1047				  -	      ERR
     11  1047					      ENDIF
     12  1047					      LIST	ON
     10  1047
      0  1047					      VAR	__quiesceCapOnly, 1
      1  1047		       00 ad	   __quiesceCapOnly =	TEMPORARY_VAR
      2  1047				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1047
      4  1047				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1047				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1047				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1047					      ENDIF
      8  1047				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1047				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  1047				  -	      ERR
     11  1047					      ENDIF
     12  1047					      LIST	ON
     12  1047
      0  1047					      REFER	aiComputerMove
      1  1047				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  1047				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  1047					      ENDIF
      0  1047					      VEND	selectmove
      1  1047				  -	      IFNCONST	selectmove
      2  1047				  -	      ECHO	"Incorrect VEND label", selectmove
      3  1047				  -	      ERR
      4  1047					      ENDIF
      5  1047		       00 ae	   VAREND_selectmove =	TEMPORARY_VAR
    110  1047
    111  1047
    112  1047
    113  1047							; RAM bank already switched in!!!
    114  1047							; returns with RAM bank switched
    115  1047
    116  1047
    117  1047				  -	      IF	DIAGNOSTICS
    118  1047				  -
    119  1047				  -	      lda	#0
    120  1047				  -	      sta	positionCount
    121  1047				  -	      sta	positionCount+1
    122  1047				  -	      sta	positionCount+2
    123  1047				  -			;sta maxPly
    124  1047					      ENDIF
    125  1047
    126  1047
    127  1047		       a9 00		      lda	#<INFINITY
    128  1049		       85 a7		      sta	__beta
    129  104b		       a9 70		      lda	#>INFINITY
    130  104d		       85 a8		      sta	__beta+1
    131  104f
    132  104f		       a9 00		      lda	#<-INFINITY
    133  1051		       85 a5		      sta	__alpha
    134  1053		       a9 90		      lda	#>-INFINITY
    135  1055		       85 a6		      sta	__alpha+1	; player tries to maximise
    136  1057
    137  1057		       a2 03		      ldx	#SEARCH_DEPTH
    138  1059		       a9 00		      lda	#0	; no captured piece
    139  105b		       85 ad		      sta	__quiesceCapOnly	; ALL moves to be generated
    140  105d
    141  105d		       20 22 f4 	      jsr	negaMax
    142  1060
      0  1060					      ldx@PLY	bestMove
      1  1060		       ae a0 ff 	      ldx	bestMove
    144  1063		       30 28		      bmi	.nomove
    145  1065
    146  1065							; Generate player's moves in reply
    147  1065							; Make the computer move, list player moves (PLY+1), unmake computer move
    148  1065
    149  1065
      0  1065					      stx@PLY	movePtr
      1  1065		       8e 9f 01 	      stx	[RAM]+movePtr
    151  1068		       20 00 f4 	      jsr	MakeMove
    152  106b
    153  106b		       20 c4 f1 	      jsr	ListPlayerMoves
    154  106e
    155  106e		       a9 c8		      lda	#RAMBANK_PLY
    156  1070		       85 3e		      sta	SET_BANK_RAM
    157  1072
    158  1072		       20 6f f4 	      jsr	unmakeMove
    159  1075
    160  1075							; Grab the computer move details for the UI animation
    161  1075
    162  1075		       a9 c8		      lda	#RAMBANK_PLY
    163  1077		       85 3e		      sta	SET_BANK_RAM
    164  1079
      0  1079					      ldx@PLY	bestMove
      1  1079		       ae a0 ff 	      ldx	bestMove
      0  107c					      lda@PLY	MoveTo,x
      1  107c		       bd 00 fd 	      lda	MoveTo,x
    167  107f		       85 86		      sta	toX12
      0  1081					      lda@PLY	MoveFrom,x
      1  1081		       bd 00 fc 	      lda	MoveFrom,x
    169  1084		       85 87		      sta	originX12
    170  1086		       85 85		      sta	fromX12
      0  1088					      lda@PLY	MovePiece,x
      1  1088		       bd 00 fe 	      lda	MovePiece,x
    172  108b		       85 97		      sta	fromPiece
    173  108d
    174  108d				   .nomove
    175  108d		       60		      rts
    176  108e
    177  108e
    178  108e							;---------------------------------------------------------------------------------------------------
    179  108e
      0  108e					      DEF	GenCastleMoveForRook
      1  108e				   SLOT_GenCastleMoveForRook SET	_BANK_SLOT
      2  108e				   BANK_GenCastleMoveForRook SET	SLOT_GenCastleMoveForRook + _CURRENT_BANK
      3  108e				   GenCastleMoveForRook
      4  108e				   TEMPORARY_VAR SET	Overlay
      5  108e				   TEMPORARY_OFFSET SET	0
      6  108e				   VAR_BOUNDARY_GenCastleMoveForRook SET	TEMPORARY_OFFSET
      7  108e				   FUNCTION_NAME SET	GenCastleMoveForRook
    181  108e					      SUBROUTINE
    182  108e
      0  108e					      REFER	MakeMove
      1  108e					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  108e				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  108e					      ENDIF
      0  108e					      REFER	CastleFixupDraw
      1  108e				  -	      IF	VAREND_CastleFixupDraw > TEMPORARY_VAR
      2  108e				  -TEMPORARY_VAR SET	VAREND_CastleFixupDraw
      3  108e					      ENDIF
      0  108e					      VEND	GenCastleMoveForRook
      1  108e				  -	      IFNCONST	GenCastleMoveForRook
      2  108e				  -	      ECHO	"Incorrect VEND label", GenCastleMoveForRook
      3  108e				  -	      ERR
      4  108e					      ENDIF
      5  108e		       00 b0	   VAREND_GenCastleMoveForRook =	TEMPORARY_VAR
    186  108e
    187  108e		       18		      clc
    188  108f
    189  108f		       a5 97		      lda	fromPiece
    190  1091		       29 10		      and	#FLAG_CASTLE
    191  1093		       f0 2b		      beq	.exit	; NOT involved in castle!
    192  1095
    193  1095		       a2 04		      ldx	#4
    194  1097		       a5 85		      lda	fromX12	; *destination*
    195  1099		       18	   .findCast  clc
    196  109a		       ca		      dex
    197  109b		       30 23		      bmi	.exit
    198  109d		       dd d2 f8 	      cmp	KSquare,x
    199  10a0		       d0 f7		      bne	.findCast
    200  10a2
    201  10a2		       bd da f8 	      lda	RSquareEnd,x
    202  10a5		       85 86		      sta	toX12
      0  10a7					      sta@PLY	secondaryBlank
      1  10a7		       8d 9d 01 	      sta	[RAM]+secondaryBlank
    204  10aa		       bc d6 f8 	      ldy	RSquareStart,x
    205  10ad		       84 85		      sty	fromX12
    206  10af		       84 87		      sty	originX12
      0  10b1					      sty@PLY	secondarySquare
      1  10b1		       8c 9c 01 	      sty	[RAM]+secondarySquare
    208  10b4
    209  10b4		       a5 97		      lda	fromPiece
    210  10b6		       29 80		      and	#128	; colour bit
    211  10b8		       09 05		      ora	#ROOK	; preserve colour
    212  10ba		       85 97		      sta	fromPiece
      0  10bc					      sta@PLY	secondaryPiece
      1  10bc		       8d 9b 01 	      sta	[RAM]+secondaryPiece
    214  10bf
    215  10bf		       38		      sec
    216  10c0		       60	   .exit      rts
    217  10c1
    218  10c1
    219  10c1							;---------------------------------------------------------------------------------------------------
    220  10c1
      0  10c1					      DEF	CastleFixupDraw
      1  10c1				   SLOT_CastleFixupDraw SET	_BANK_SLOT
      2  10c1				   BANK_CastleFixupDraw SET	SLOT_CastleFixupDraw + _CURRENT_BANK
      3  10c1				   CastleFixupDraw
      4  10c1				   TEMPORARY_VAR SET	Overlay
      5  10c1				   TEMPORARY_OFFSET SET	0
      6  10c1				   VAR_BOUNDARY_CastleFixupDraw SET	TEMPORARY_OFFSET
      7  10c1				   FUNCTION_NAME SET	CastleFixupDraw
    222  10c1					      SUBROUTINE
    223  10c1
      0  10c1					      REFER	aiSpecialMoveFixup
      1  10c1					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  10c1				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  10c1					      ENDIF
      0  10c1					      VEND	CastleFixupDraw
      1  10c1				  -	      IFNCONST	CastleFixupDraw
      2  10c1				  -	      ECHO	"Incorrect VEND label", CastleFixupDraw
      3  10c1				  -	      ERR
      4  10c1					      ENDIF
      5  10c1		       00 ae	   VAREND_CastleFixupDraw =	TEMPORARY_VAR
    226  10c1
    227  10c1							; fixup any castling issues
    228  10c1							; at this point the king has finished his two-square march
    229  10c1							; based on the finish square, we determine which rook we're interacting with
    230  10c1							; and generate a 'move' for the rook to position on the other side of the king
    231  10c1
    232  10c1
    233  10c1					      IF	CASTLING_ENABLED
    234  10c1		       20 8e f8 	      jsr	GenCastleMoveForRook
    235  10c4		       b0 07		      bcs	.phase
    236  10c6					      ENDIF
    237  10c6
      0  10c6					      SWAP
      1  10c6		       a5 96		      lda	sideToMove
      2  10c8		       49 80		      eor	#SWAP_SIDE
      3  10ca		       85 96		      sta	sideToMove
    239  10cc		       60		      rts
    240  10cd
    241  10cd				   .phase
    242  10cd
    243  10cd							; in this siutation (castle, rook moving) we do not change sides yet!
    244  10cd
      0  10cd					      PHASE	AI_MoveIsSelected
      1  10cd		       a9 14		      lda	#AI_MoveIsSelected
      2  10cf		       85 8c		      sta	aiState
    246  10d1		       60		      rts
    247  10d2
    248  10d2
    249  10d2
    250  10d2		       18 1c 5e 62 KSquare    .byte.b	24,28,94,98
    251  10d6		       16 1d 5c 63 RSquareStart .byte.b	22,29,92,99
    252  10da		       19 1b 5f 61 RSquareEnd .byte.b	25,27,95,97
    253  10de
    254  10de
    255  10de							;---------------------------------------------------------------------------------------------------
    256  10de
    257  10de					      MAC	xchg
    258  10de					      lda@PLY	{1},x
    259  10de					      sta	__xchg
    260  10de					      lda@PLY	{1},y
    261  10de					      sta@PLY	{1},x
    262  10de					      lda	__xchg
    263  10de					      sta@PLY	{1},y
    264  10de					      ENDM		;{name}
    265  10de
    266  10de
      0  10de					      DEF	Sort
      1  10de				   SLOT_Sort  SET	_BANK_SLOT
      2  10de				   BANK_Sort  SET	SLOT_Sort + _CURRENT_BANK
      3  10de				   Sort
      4  10de				   TEMPORARY_VAR SET	Overlay
      5  10de				   TEMPORARY_OFFSET SET	0
      6  10de				   VAR_BOUNDARY_Sort SET	TEMPORARY_OFFSET
      7  10de				   FUNCTION_NAME SET	Sort
    268  10de					      SUBROUTINE
    269  10de
      0  10de					      REFER	GenerateAllMoves
      1  10de					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  10de				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  10de					      ENDIF
      0  10de					      VAR	__xchg, 1
      1  10de		       00 b3	   __xchg     =	TEMPORARY_VAR
      2  10de				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  10de
      4  10de				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  10de				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  10de				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  10de					      ENDIF
      8  10de				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  10de				  -	      ECHO	"Temporary Variable", __xchg, "overflow!"
     10  10de				  -	      ERR
     11  10de					      ENDIF
     12  10de					      LIST	ON
      0  10de					      VEND	Sort
      1  10de				  -	      IFNCONST	Sort
      2  10de				  -	      ECHO	"Incorrect VEND label", Sort
      3  10de				  -	      ERR
      4  10de					      ENDIF
      5  10de		       00 b4	   VAREND_Sort =	TEMPORARY_VAR
    273  10de
    274  10de							;lda currentPly
    275  10de							;sta savedBank 	  ; ??
    276  10de
    277  10de		       a5 ad		      lda	__quiesceCapOnly
    278  10e0		       30 51		      bmi	.exit	; only caps present so already sorted!
    279  10e2
      0  10e2					      ldx@PLY	moveIndex
      1  10e2		       ae 9e ff 	      ldx	moveIndex
      0  10e5					      ldy@PLY	moveIndex
      1  10e5		       ac 9e ff 	      ldy	moveIndex
    282  10e8		       88	   .next      dey
    283  10e9		       30 48		      bmi	.exit
    284  10eb
      0  10eb					      lda@PLY	MoveCapture,y
      1  10eb		       b9 00 ff 	      lda	MoveCapture,y
    286  10ee		       f0 f8		      beq	.next
    287  10f0
      0  10f0					      XCHG	MoveFrom
      0  10f0					      lda@PLY	MoveFrom,x
      1  10f0		       bd 00 fc 	      lda	MoveFrom,x
      2  10f3		       85 b3		      sta	__xchg
      0  10f5					      lda@PLY	MoveFrom,y
      1  10f5		       b9 00 fc 	      lda	MoveFrom,y
      0  10f8					      sta@PLY	MoveFrom,x
      1  10f8		       9d 00 fe 	      sta	[RAM]+MoveFrom,x
      5  10fb		       a5 b3		      lda	__xchg
      0  10fd					      sta@PLY	MoveFrom,y
      1  10fd		       99 00 fe 	      sta	[RAM]+MoveFrom,y
      0  1100					      XCHG	MoveTo
      0  1100					      lda@PLY	MoveTo,x
      1  1100		       bd 00 fd 	      lda	MoveTo,x
      2  1103		       85 b3		      sta	__xchg
      0  1105					      lda@PLY	MoveTo,y
      1  1105		       b9 00 fd 	      lda	MoveTo,y
      0  1108					      sta@PLY	MoveTo,x
      1  1108		       9d 00 ff 	      sta	[RAM]+MoveTo,x
      5  110b		       a5 b3		      lda	__xchg
      0  110d					      sta@PLY	MoveTo,y
      1  110d		       99 00 ff 	      sta	[RAM]+MoveTo,y
      0  1110					      XCHG	MovePiece
      0  1110					      lda@PLY	MovePiece,x
      1  1110		       bd 00 fe 	      lda	MovePiece,x
      2  1113		       85 b3		      sta	__xchg
      0  1115					      lda@PLY	MovePiece,y
      1  1115		       b9 00 fe 	      lda	MovePiece,y
      0  1118					      sta@PLY	MovePiece,x
      1  1118		       9d 00 00 	      sta	[RAM]+MovePiece,x
      5  111b		       a5 b3		      lda	__xchg
      0  111d					      sta@PLY	MovePiece,y
      1  111d		       99 00 00 	      sta	[RAM]+MovePiece,y
      0  1120					      XCHG	MoveCapture
      0  1120					      lda@PLY	MoveCapture,x
      1  1120		       bd 00 ff 	      lda	MoveCapture,x
      2  1123		       85 b3		      sta	__xchg
      0  1125					      lda@PLY	MoveCapture,y
      1  1125		       b9 00 ff 	      lda	MoveCapture,y
      0  1128					      sta@PLY	MoveCapture,x
      1  1128		       9d 00 01 	      sta	[RAM]+MoveCapture,x
      5  112b		       a5 b3		      lda	__xchg
      0  112d					      sta@PLY	MoveCapture,y
      1  112d		       99 00 01 	      sta	[RAM]+MoveCapture,y
    292  1130
    293  1130		       ca		      dex
    294  1131		       10 b5		      bpl	.next
    295  1133
    296  1133				   .exit
    297  1133
    298  1133
    299  1133
    300  1133
    301  1133							; Scan for capture of king
    302  1133
      0  1133					      ldx@PLY	moveIndex
      1  1133		       ae 9e ff 	      ldx	moveIndex
    304  1136
      0  1136				   .scanCheck lda@PLY	MoveCapture,x
      1  1136		       bd 00 ff 	      lda	MoveCapture,x
    306  1139		       f0 0b		      beq	.check	; since they're sorted with captures "first" we can exit
    307  113b		       29 0f		      and	#PIECE_MASK
    308  113d		       c9 07		      cmp	#KING
    309  113f		       f0 05		      beq	.check
    310  1141		       ca		      dex
    311  1142		       10 f2		      bpl	.scanCheck
    312  1144
    313  1144		       a9 00		      lda	#0
    314  1146		       85 9f	   .check     sta	flagCheck
    315  1148		       60		      rts
    316  1149
    317  1149
    318  1149							;---------------------------------------------------------------------------------------------------
    319  1149							; QUIESCE!
    320  1149
    321  1149							;int Quiesce( int alpha, int beta ) {
    322  1149							;    int stand_pat = Evaluate();
    323  1149							;    if( stand_pat >= beta )
    324  1149							;	  return beta;
    325  1149							;    if( alpha < stand_pat )
    326  1149							;	  alpha = stand_pat;
    327  1149
    328  1149							;    until( every_capture_has_been_examined )	{
    329  1149							;	  MakeCapture();
    330  1149							;	  score = -Quiesce( -beta, -alpha );
    331  1149							;	  TakeBackMove();
    332  1149
    333  1149							;	  if( score >= beta )
    334  1149							;	      return beta;
    335  1149							;	  if( score > alpha )
    336  1149							;	     alpha = score;
    337  1149							;    }
    338  1149							;    return alpha;
    339  1149							;}
    340  1149
    341  1149
      0  1149					      DEF	quiesce
      1  1149				   SLOT_quiesce SET	_BANK_SLOT
      2  1149				   BANK_quiesce SET	SLOT_quiesce + _CURRENT_BANK
      3  1149				   quiesce
      4  1149				   TEMPORARY_VAR SET	Overlay
      5  1149				   TEMPORARY_OFFSET SET	0
      6  1149				   VAR_BOUNDARY_quiesce SET	TEMPORARY_OFFSET
      7  1149				   FUNCTION_NAME SET	quiesce
    343  1149					      SUBROUTINE
    344  1149
    345  1149							; pass...
    346  1149							; x = depthleft
    347  1149							; SET_BANK_RAM      --> current ply
    348  1149							; __alpha[2] = param alpha
    349  1149							; __beta[2] = param beta
    350  1149
    351  1149
      0  1149					      COMMON_VARS_ALPHABETA
      1  1149
      0  1149					      VAR	__thinkbar, 1
      1  1149		       00 a2	   __thinkbar =	TEMPORARY_VAR
      2  1149				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1149
      4  1149				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1149				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1149				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1149					      ENDIF
      8  1149				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1149				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  1149				  -	      ERR
     11  1149					      ENDIF
     12  1149					      LIST	ON
      0  1149					      VAR	__toggle, 1
      1  1149		       00 a3	   __toggle   =	TEMPORARY_VAR
      2  1149				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1149
      4  1149				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1149				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1149				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1149					      ENDIF
      8  1149				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1149				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  1149				  -	      ERR
     11  1149					      ENDIF
     12  1149					      LIST	ON
      4  1149
      0  1149					      VAR	__bestMove, 1
      1  1149		       00 a4	   __bestMove =	TEMPORARY_VAR
      2  1149				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1149
      4  1149				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1149				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1149				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1149					      ENDIF
      8  1149				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1149				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  1149				  -	      ERR
     11  1149					      ENDIF
     12  1149					      LIST	ON
      0  1149					      VAR	__alpha, 2
      1  1149		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  1149				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1149
      4  1149				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1149				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1149				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1149					      ENDIF
      8  1149				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1149				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  1149				  -	      ERR
     11  1149					      ENDIF
     12  1149					      LIST	ON
      0  1149					      VAR	__beta, 2
      1  1149		       00 a7	   __beta     =	TEMPORARY_VAR
      2  1149				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1149
      4  1149				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1149				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1149				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1149					      ENDIF
      8  1149				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1149				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  1149				  -	      ERR
     11  1149					      ENDIF
     12  1149					      LIST	ON
      0  1149					      VAR	__negaMax, 2
      1  1149		       00 a9	   __negaMax  =	TEMPORARY_VAR
      2  1149				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1149
      4  1149				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1149				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1149				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1149					      ENDIF
      8  1149				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1149				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  1149				  -	      ERR
     11  1149					      ENDIF
     12  1149					      LIST	ON
      0  1149					      VAR	__value, 2
      1  1149		       00 ab	   __value    =	TEMPORARY_VAR
      2  1149				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1149
      4  1149				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1149				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1149				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1149					      ENDIF
      8  1149				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1149				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  1149				  -	      ERR
     11  1149					      ENDIF
     12  1149					      LIST	ON
     10  1149
      0  1149					      VAR	__quiesceCapOnly, 1
      1  1149		       00 ad	   __quiesceCapOnly =	TEMPORARY_VAR
      2  1149				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1149
      4  1149				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1149				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1149				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1149					      ENDIF
      8  1149				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1149				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  1149				  -	      ERR
     11  1149					      ENDIF
     12  1149					      LIST	ON
     12  1149
      0  1149					      REFER	selectmove
      1  1149				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  1149				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  1149					      ENDIF
      0  1149					      REFER	negaMax
      1  1149				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  1149				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  1149					      ENDIF
      0  1149					      VEND	quiesce
      1  1149				  -	      IFNCONST	quiesce
      2  1149				  -	      ECHO	"Incorrect VEND label", quiesce
      3  1149				  -	      ERR
      4  1149					      ENDIF
      5  1149		       00 ae	   VAREND_quiesce =	TEMPORARY_VAR
    356  1149
    357  1149		       a5 95		      lda	currentPly
    358  114b		       c9 ce		      cmp	#RAMBANK_PLY + MAX_PLY_DEPTH_BANK -1
    359  114d		       b0 43		      bcs	.retBeta
    360  114f
    361  114f							; The 'thinkbar' pattern...
    362  114f
    363  114f		       a9 00		      lda	#0
    364  1151		       a4 4c		      ldy	INPT4
    365  1153		       30 14		      bmi	.doThink
    366  1155
    367  1155		       a5 a2		      lda	__thinkbar
    368  1157		       0a		      asl
    369  1158		       0a		      asl
    370  1159		       0a		      asl
    371  115a		       0a		      asl
    372  115b		       09 02		      ora	#2
    373  115d		       85 48		      sta	COLUPF
    374  115f
    375  115f		       e6 a2		      inc	__thinkbar
    376  1161		       a5 a2		      lda	__thinkbar
    377  1163		       29 0f		      and	#15
    378  1165		       a8		      tay
    379  1166		       b9 4f fa 	      lda	SynapsePattern2,y
    380  1169
    381  1169		       85 4e	   .doThink   sta	PF1
    382  116b		       85 4f		      sta	PF2
    383  116d
    384  116d							; ^
    385  116d
    386  116d		       a5 a7		      lda	__beta
      0  116f					      sta@PLY	beta
      1  116f		       8d a3 01 	      sta	[RAM]+beta
    388  1172		       a5 a8		      lda	__beta+1
      0  1174					      sta@PLY	beta+1
      1  1174		       8d a4 01 	      sta	[RAM]+beta+1
    390  1177
    391  1177		       a5 a5		      lda	__alpha
      0  1179					      sta@PLY	alpha
      1  1179		       8d a1 01 	      sta	[RAM]+alpha
    393  117c		       a5 a6		      lda	__alpha+1
      0  117e					      sta@PLY	alpha+1
      1  117e		       8d a2 01 	      sta	[RAM]+alpha+1
    395  1181
    396  1181
    397  1181							;    int stand_pat = Evaluate();
    398  1181							;    if( stand_pat >= beta )
    399  1181							;	  return beta;
    400  1181
    401  1181		       38		      sec
    402  1182		       a5 90		      lda	Evaluation
      0  1184					      sbc@PLY	beta
      1  1184		       ed a3 ff 	      sbc	beta
    404  1187		       a5 91		      lda	Evaluation+1
      0  1189					      sbc@PLY	beta+1
      1  1189		       ed a4 ff 	      sbc	beta+1
    406  118c		       50 02		      bvc	.spat0
    407  118e		       49 80		      eor	#$80
    408  1190		       30 0b	   .spat0     bmi	.norb	;pl .retBeta			 ; branch if stand_pat >= beta
    409  1192
    410  1192		       ad a3 ff    .retBeta   lda	beta
    411  1195		       85 a9		      sta	__negaMax
    412  1197		       ad a4 ff 	      lda	beta+1
    413  119a		       85 aa		      sta	__negaMax+1
    414  119c
    415  119c		       60	   .abort     rts
    416  119d
    417  119d				   .norb
    418  119d
    419  119d
    420  119d							;    if( alpha < stand_pat )
    421  119d							;	  alpha = stand_pat;
    422  119d
    423  119d		       38		      sec
    424  119e		       ad a1 ff 	      lda	alpha
    425  11a1		       e5 90		      sbc	Evaluation
    426  11a3		       ad a2 ff 	      lda	alpha+1
    427  11a6		       e5 91		      sbc	Evaluation+1
    428  11a8		       50 02		      bvc	.spat1
    429  11aa		       49 80		      eor	#$80
    430  11ac		       10 0a	   .spat1     bpl	.alpha	; branch if alpha >= stand_pat
    431  11ae
    432  11ae							; alpha < stand_pat
    433  11ae
    434  11ae		       a5 90		      lda	Evaluation
      0  11b0					      sta@PLY	alpha
      1  11b0		       8d a1 01 	      sta	[RAM]+alpha
    436  11b3		       a5 91		      lda	Evaluation+1
      0  11b5					      sta@PLY	alpha+1
      1  11b5		       8d a2 01 	      sta	[RAM]+alpha+1
    438  11b8
    439  11b8				   .alpha
    440  11b8		       20 68 f1 	      jsr	GenerateAllMoves
    441  11bb		       a5 9f		      lda	flagCheck
    442  11bd		       d0 dd		      bne	.abort	; pure abort
    443  11bf
      0  11bf					      ldx@PLY	moveIndex
      1  11bf		       ae 9e ff 	      ldx	moveIndex
    445  11c2		       30 7a		      bmi	.exit
    446  11c4
      0  11c4				   .forChild  stx@PLY	movePtr
      1  11c4		       8e 9f 01 	      stx	[RAM]+movePtr
    448  11c7
    449  11c7							; The movelist has captures ONLY (ref: __quiesceCapOnly != 0)
    450  11c7
    451  11c7		       20 00 f4 	      jsr	MakeMove
    452  11ca
    453  11ca		       38		      sec
    454  11cb		       a9 00		      lda	#0
      0  11cd					      sbc@PLY	beta
      1  11cd		       ed a3 ff 	      sbc	beta
    456  11d0		       85 a5		      sta	__alpha
    457  11d2		       a9 00		      lda	#0
      0  11d4					      sbc@PLY	beta+1
      1  11d4		       ed a4 ff 	      sbc	beta+1
    459  11d7		       85 a6		      sta	__alpha+1
    460  11d9
    461  11d9		       38		      sec
    462  11da		       a9 00		      lda	#0
      0  11dc					      sbc@PLY	alpha
      1  11dc		       ed a1 ff 	      sbc	alpha
    464  11df		       85 a7		      sta	__beta
    465  11e1		       a9 00		      lda	#0
      0  11e3					      sbc@PLY	alpha+1
      1  11e3		       ed a2 ff 	      sbc	alpha+1
    467  11e6		       85 a8		      sta	__beta+1
    468  11e8
    469  11e8		       e6 95		      inc	currentPly
    470  11ea		       a5 95		      lda	currentPly
    471  11ec		       85 3e		      sta	SET_BANK_RAM	; self-switch
    472  11ee
    473  11ee		       20 49 f9 	      jsr	quiesce
    474  11f1
    475  11f1		       c6 95		      dec	currentPly
    476  11f3		       a5 95		      lda	currentPly
    477  11f5		       85 3e		      sta	SET_BANK_RAM
    478  11f7
    479  11f7		       20 6f f4 	      jsr	unmakeMove
    480  11fa
    481  11fa		       a5 9f		      lda	flagCheck	; don't consider moves which leave us in check
    482  11fc		       d0 4b		      bne	.inCheck
    483  11fe
    484  11fe		       38		      sec
    485  11ff							;lda #0			 ; already 0
    486  11ff		       e5 a9		      sbc	__negaMax
    487  1201		       85 a9		      sta	__negaMax
    488  1203		       a9 00		      lda	#0
    489  1205		       e5 aa		      sbc	__negaMax+1
    490  1207		       85 aa		      sta	__negaMax+1	; -negaMax(...)
    491  1209
    492  1209
    493  1209
    494  1209							;	  if( score >= beta )
    495  1209							;	      return beta;
    496  1209
    497  1209
    498  1209		       38		      sec
    499  120a		       a5 a9		      lda	__negaMax
      0  120c					      sbc@PLY	beta
      1  120c		       ed a3 ff 	      sbc	beta
    501  120f		       a5 aa		      lda	__negaMax+1
      0  1211					      sbc@PLY	beta+1
      1  1211		       ed a4 ff 	      sbc	beta+1
    503  1214		       50 02		      bvc	.lab0
    504  1216		       49 80		      eor	#$80
    505  1218		       30 03	   .lab0      bmi	.nrb2	; .retBeta		       ; branch if score >= beta
    506  121a		       4c 92 f9 	      jmp	.retBeta
    507  121d				   .nrb2
    508  121d
    509  121d							;	  if( score > alpha )
    510  121d							;	     alpha = score;
    511  121d							;    }
    512  121d
    513  121d		       38		      sec
      0  121e					      lda@PLY	alpha
      1  121e		       ad a1 ff 	      lda	alpha
    515  1221		       e5 a9		      sbc	__negaMax
      0  1223					      lda@PLY	alpha+1
      1  1223		       ad a2 ff 	      lda	alpha+1
    517  1226		       e5 aa		      sbc	__negaMax+1
    518  1228		       50 02		      bvc	.lab2
    519  122a		       49 80		      eor	#$80
    520  122c		       10 0a	   .lab2      bpl	.nextMove	; alpha >= score
    521  122e
    522  122e							; score > alpha
    523  122e
    524  122e		       a5 a9		      lda	__negaMax
      0  1230					      sta@PLY	alpha
      1  1230		       8d a1 01 	      sta	[RAM]+alpha
    526  1233		       a5 aa		      lda	__negaMax+1
      0  1235					      sta@PLY	alpha+1
      1  1235		       8d a2 01 	      sta	[RAM]+alpha+1
    528  1238
      0  1238				   .nextMove  ldx@PLY	movePtr
      1  1238		       ae 9f ff 	      ldx	movePtr
    530  123b		       ca		      dex
    531  123c		       10 86		      bpl	.forChild
    532  123e
    533  123e							;    return alpha;
    534  123e
    535  123e				   .exit
      0  123e					      lda@PLY	alpha
      1  123e		       ad a1 ff 	      lda	alpha
    537  1241		       85 a9		      sta	__negaMax
      0  1243					      lda@PLY	alpha+1
      1  1243		       ad a2 ff 	      lda	alpha+1
    539  1246		       85 aa		      sta	__negaMax+1
    540  1248		       60		      rts
    541  1249
    542  1249		       a9 00	   .inCheck   lda	#0
    543  124b		       85 9f		      sta	flagCheck
    544  124d		       f0 e9		      beq	.nextMove
    545  124f
    546  124f
    547  124f
    548  124f				   SynapsePattern2
    549  124f
    550  124f		       c1		      .byte.b	%11000001
    551  1250		       60		      .byte.b	%01100000
    552  1251		       30		      .byte.b	%00110000
    553  1252		       18		      .byte.b	%00011000
    554  1253		       0c		      .byte.b	%00001100
    555  1254		       06		      .byte.b	%00000110
    556  1255		       83		      .byte.b	%10000011
    557  1256		       c1		      .byte.b	%11000001
    558  1257
    559  1257		       83		      .byte.b	%10000011
    560  1258		       06		      .byte.b	%00000110
    561  1259		       0c		      .byte.b	%00001100
    562  125a		       18		      .byte.b	%00011000
    563  125b		       30		      .byte.b	%00110000
    564  125c		       60		      .byte.b	%01100000
    565  125d		       c1		      .byte.b	%11000001
    566  125e		       83		      .byte.b	%10000011
    567  125f
    568  125f
    569  125f							;---------------------------------------------------------------------------------------------------
    570  125f
      0  125f					      CHECK_BANK_SIZE	"BANK_PLY"
      1  125f		       02 5f	   .TEMP      =	* - _BANK_START
 BANK_PLY (1K) SIZE =  $25f , FREE= $1a1
      2  125f					      ECHO	"BANK_PLY", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  125f				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  125f				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_PLY", " size=", * - ORIGIN
      5  125f				  -	      ERR
      6  125f					      ENDIF
    572  125f
    573  125f							;---------------------------------------------------------------------------------------------------
    574  125f							; EOF
------- FILE ./chess.asm
------- FILE SHADOW_PLY.asm LEVEL 2 PASS 4
      0  125f					      include	"SHADOW_PLY.asm"
      1  125f							; Chess
      2  125f							; Copyright (c) 2019-2020 Andrew Davie
      3  125f							; andrew@taswegian.com
      4  125f
      5  125f
      6  125f							;---------------------------------------------------------------------------------------------------
      7  125f							; Define the RAM banks
      8  125f							; A "PLY" bank represents all the data required on any single ply of the search tree.
      9  125f							; The banks are organised sequentially, PLY_BANKS of them starting at RAMBANK_PLY
     10  125f							; The startup code copies the ROM shadow into each of these PLY banks, and from then on
     11  125f							; they act as independant switchable banks usable for data on each ply during the search.
     12  125f							; A ply will hold the move list for that position
     13  125f
     14  125f
      0  125f					      SLOT	3
      1  125f				  -	      IF	(3 < 0) || (3 > 3)
      2  125f				  -	      ECHO	"Illegal bank address/segment location", 3
      3  125f				  -	      ERR
      4  125f					      ENDIF
      5  125f				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  125f				   _BANK_SLOT SET	3 * 64
      0  125f					      NEWRAMBANK	PLY	; RAM bank for holding the following ROM shadow
      1  125f
      2  125f
      3  125f
      4 U1000 ????				      SEG.U	PLY
      5 U1000					      ORG	ORIGIN_RAM
      6 U1000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1000				   _BANK_START SET	*
      8 U1000				   RAMBANK_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1000				   _CURRENT_RAMBANK SET	RAMBANK_PLY
     10 U1000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U1000					      REPEAT	PLY_BANKS-1
      0 U1000					      NEWRAMBANK	.DUMMY_PLY
      1 U1000
      2 U1000
      3 U1000
      4 U1c00 ????				      SEG.U	.DUMMY_PLY
      5 U1200					      ORG	ORIGIN_RAM
      6 U1200					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1200				   _BANK_START SET	*
      8 U1200				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1200				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U1200				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U1200					      REPEND
      0 U1200					      NEWRAMBANK	.DUMMY_PLY
      1 U1200
      2 U1200
      3 U1200
      4 U1200					      SEG.U	.DUMMY_PLY
      5 U1400					      ORG	ORIGIN_RAM
      6 U1400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1400				   _BANK_START SET	*
      8 U1400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U1400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY_PLY
      1 U1400
      2 U1400
      3 U1400
      4 U1400					      SEG.U	.DUMMY_PLY
      5 U1600					      ORG	ORIGIN_RAM
      6 U1600					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1600				   _BANK_START SET	*
      8 U1600				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1600				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U1600				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U1600					      REPEND
      0 U1600					      NEWRAMBANK	.DUMMY_PLY
      1 U1600
      2 U1600
      3 U1600
      4 U1600					      SEG.U	.DUMMY_PLY
      5 U1800					      ORG	ORIGIN_RAM
      6 U1800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1800				   _BANK_START SET	*
      8 U1800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U1800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY_PLY
      1 U1800
      2 U1800
      3 U1800
      4 U1800					      SEG.U	.DUMMY_PLY
      5 U1a00					      ORG	ORIGIN_RAM
      6 U1a00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1a00				   _BANK_START SET	*
      8 U1a00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1a00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U1a00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U1a00					      REPEND
      0 U1a00					      NEWRAMBANK	.DUMMY_PLY
      1 U1a00
      2 U1a00
      3 U1a00
      4 U1a00					      SEG.U	.DUMMY_PLY
      5 U1c00					      ORG	ORIGIN_RAM
      6 U1c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1c00				   _BANK_START SET	*
      8 U1c00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     19 U1c00					      REPEND
     20 U1c00
     21 U1c00
     22 U1c00							; and now the ROM shadow - this is copied to ALL of the RAM ply banks
     23 U1c00
      0 U1c00					      SLOT	3
      1 U1c00				  -	      IF	(3 < 0) || (3 > 3)
      2 U1c00				  -	      ECHO	"Illegal bank address/segment location", 3
      3 U1c00				  -	      ERR
      4 U1c00					      ENDIF
      5 U1c00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6 U1c00				   _BANK_SLOT SET	3 * 64
      0 U1c00					      NEWBANK	SHADOW_PLY
      1  17ac ????				      SEG	SHADOW_PLY
      2  1400					      ORG	_ORIGIN
      3  1400					      RORG	_BANK_ADDRESS_ORIGIN
      4  1400				   _BANK_START SET	*
      5  1400				   SHADOW_PLY_START SET	*
      6  1400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1400				   SHADOW_PLY SET	_BANK_SLOT + _CURRENT_BANK
      8  1400				   _ORIGIN    SET	_ORIGIN + 1024
     26  1400
     27  1400							;---------------------------------------------------------------------------------------------------
     28  1400
     29  1400		       00 96	   MAX_MOVES  =	150	; big is good
     30  1400
      0  1400					      VARIABLE	MoveFrom, MAX_MOVES
      0  1400					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  1400					      LIST	ON
      2  1400		       00 00 00 00*MoveFrom   ds	MAX_MOVES
      0  1496					      VARIABLE	MoveTo, MAX_MOVES
      0  1496					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  1500					      LIST	ON
      2  1500		       00 00 00 00*MoveTo     ds	MAX_MOVES
      0  1596					      VARIABLE	MovePiece, MAX_MOVES
      0  1596					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  1600					      LIST	ON
      2  1600		       00 00 00 00*MovePiece  ds	MAX_MOVES
      0  1696					      VARIABLE	MoveCapture, MAX_MOVES
      0  1696					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  1700					      LIST	ON
      2  1700		       00 00 00 00*MoveCapture ds	MAX_MOVES
     35  1796
     36  1796
     37  1796							;---------------------------------------------------------------------------------------------------
     38  1796
     39  1796							; The X12 square at which a pawn CAN be taken en-passant. Normally 0.
     40  1796							; This is set/cleared whenever a move is made. The flag is indicated in the move description.
     41  1796
      0  1796					      VARIABLE	savedEvaluation, 2	; THIS node's evaluation - used for reverting moves!
      0  1796					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  1796					      LIST	ON
      2  1796		       00 00	   savedEvaluation ds	2
      0  1798					      VARIABLE	enPassantSquare, 1
      0  1798					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  1798					      LIST	ON
      2  1798		       00	   enPassantSquare ds	1
      0  1799					      VARIABLE	capturedPiece, 1
      0  1799					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  1799					      LIST	ON
      2  1799		       00	   capturedPiece ds	1
      0  179a					      VARIABLE	originalPiece, 1
      0  179a					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  179a					      LIST	ON
      2  179a		       00	   originalPiece ds	1
      0  179b					      VARIABLE	secondaryPiece, 1	; original piece on secondary (castle, enpassant)
      0  179b					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  179b					      LIST	ON
      2  179b		       00	   secondaryPiece ds	1
      0  179c					      VARIABLE	secondarySquare, 1	; original square of secondary piece
      0  179c					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  179c					      LIST	ON
      2  179c		       00	   secondarySquare ds	1
      0  179d					      VARIABLE	secondaryBlank, 1	; square to blank on secondary
      0  179d					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  179d					      LIST	ON
      2  179d		       00	   secondaryBlank ds	1
      0  179e					      VARIABLE	moveIndex, 1	; points to first available 'slot' for move storage
      0  179e					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  179e					      LIST	ON
      2  179e		       00	   moveIndex  ds	1
      0  179f					      VARIABLE	movePtr, 1
      0  179f					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  179f					      LIST	ON
      2  179f		       00	   movePtr    ds	1
      0  17a0					      VARIABLE	bestMove, 1
      0  17a0					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  17a0					      LIST	ON
      2  17a0		       00	   bestMove   ds	1
      0  17a1					      VARIABLE	alpha, 2
      0  17a1					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  17a1					      LIST	ON
      2  17a1		       00 00	   alpha      ds	2
      0  17a3					      VARIABLE	beta, 2
      0  17a3					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  17a3					      LIST	ON
      2  17a3		       00 00	   beta       ds	2
      0  17a5					      VARIABLE	value, 2
      0  17a5					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  17a5					      LIST	ON
      2  17a5		       00 00	   value      ds	2
      0  17a7					      VARIABLE	depthLeft, 1
      0  17a7					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  17a7					      LIST	ON
      2  17a7		       00	   depthLeft  ds	1
      0  17a8					      VARIABLE	restorePiece, 1
      0  17a8					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  17a8					      LIST	ON
      2  17a8		       00	   restorePiece ds	1
      0  17a9					      VARIABLE	kingSquare, 3	; traversing squares for castle/check
      0  17a9					      OPTIONAL_PAGEBREAK	"Variable", 3
     12  17a9					      LIST	ON
      2  17a9		       00 00 00    kingSquare ds	3
     58  17ac
     59  17ac
     60  17ac							;---------------------------------------------------------------------------------------------------
     61  17ac							; EOF
------- FILE ./chess.asm
------- FILE SHADOW_BOARD.asm LEVEL 2 PASS 4
      0  17ac					      include	"SHADOW_BOARD.asm"
      1  17ac							; Copyright (C)2020 Andrew Davie
      2  17ac
      3  17ac
      4  17ac							;---------------------------------------------------------------------------------------------------
      0  17ac					      SLOT	3
      1  17ac				  -	      IF	(3 < 0) || (3 > 3)
      2  17ac				  -	      ECHO	"Illegal bank address/segment location", 3
      3  17ac				  -	      ERR
      4  17ac					      ENDIF
      5  17ac				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  17ac				   _BANK_SLOT SET	3 * 64
      0  17ac					      NEWRAMBANK	BOARD	; RAM bank for holding the following ROM shadow
      1  17ac
      2  17ac
      3  17ac
      4 U1e00 ????				      SEG.U	BOARD
      5 U1e00					      ORG	ORIGIN_RAM
      6 U1e00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1e00				   _BANK_START SET	*
      8 U1e00				   RAMBANK_BOARD SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1e00				   _CURRENT_RAMBANK SET	RAMBANK_BOARD
     10 U1e00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      7 U1e00
      8 U1e00		       fc 15	   ValidSquare =	ShadowValidSquare + $400
      9 U1e00		       fc 79	   Board      =	ShadowBoard + $400
     10 U1e00
      0 U1e00					      SLOT	2
      1 U1e00				  -	      IF	(2 < 0) || (2 > 3)
      2 U1e00				  -	      ECHO	"Illegal bank address/segment location", 2
      3 U1e00				  -	      ERR
      4 U1e00					      ENDIF
      5 U1e00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6 U1e00				   _BANK_SLOT SET	2 * 64
      0 U1e00					      NEWBANK	SHADOW_BOARD	; copy the following bank to RAMBANK_BOARD
      1  18dd ????				      SEG	SHADOW_BOARD
      2  1800					      ORG	_ORIGIN
      3  1800					      RORG	_BANK_ADDRESS_ORIGIN
      4  1800				   _BANK_START SET	*
      5  1800				   SHADOW_BOARD_START SET	*
      6  1800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1800				   SHADOW_BOARD SET	_BANK_SLOT + _CURRENT_BANK
      8  1800				   _ORIGIN    SET	_ORIGIN + 1024
     13  1800
     14  1800							; Board is a 10 x 12 object which simplifies the generation of moves
     15  1800							; The squares marked '░░░' are illegal. The ("X12") index of each square is the left
     16  1800							; number + the bottom number. Bottom left legal square (AS VISIBLE ON SCREEN) is #22
     17  1800
     18  1800							;     X12 numbering
     19  1800							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     20  1800							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     21  1800							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     22  1800							; 90 ┃░░░┊░░░┊ 92┊ 93┊ 94┊ 95┊ 96┊ 97┊ 98┊ 99┃ 8 BLACK
     23  1800							; 80 ┃░░░┊░░░┊ 82┊ 83┊ 84┊ 85┊ 86┊ 87┊ 88┊ 89┃ 7 BLACK
     24  1800							; 70 ┃░░░┊░░░┊ 72┊ 73┊ 74┊ 75┊ 76┊ 77┊ 78┊ 79┃ 6
     25  1800							; 60 ┃░░░┊░░░┊ 62┊ 63┊ 64┊ 65┊ 66┊ 67┊ 68┊ 69┃ 5
     26  1800							; 50 ┃░░░┊░░░┊ 52┊ 53┊ 54┊ 55┊ 56┊ 57┊ 58┊ 59┃ 4
     27  1800							; 40 ┃░░░┊░░░┊ 42┊ 43┊ 44┊ 45┊ 46┊ 47┊ 48┊ 49┃ 3
     28  1800							; 30 ┃░░░┊░░░┊ 32┊ 33┊ 34┊ 35┊ 36┊ 37┊ 38┊ 39┃ 2 WHITE
     29  1800							; 20 ┃░░░┊░░░┊ 22┊ 23┊ 24┊ 25┊ 26┊ 27┊ 28┊ 29┃ 1 WHITE
     30  1800							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     31  1800							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     32  1800							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     33  1800							;	0   1	2   3	4   5	6   7	8   9
     34  1800							;		A   B	C   D	E   F	G   H
     35  1800
     36  1800							;     HEX X12
     37  1800							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     38  1800							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     39  1800							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     40  1800							; 90 ┃░░░┊░░░┊$5C┊$5D┊$5E┊$5F┊$60┊$61┊$62┊$63┃ 8
     41  1800							; 80 ┃░░░┊░░░┊$52┊$53┊$54┊$55┊$56┊$57┊$58┊$59┃ 7
     42  1800							; 70 ┃░░░┊░░░┊$48┊$49┊$4A┊$4B┊$4C┊$4D┊$4E┊$4F┃ 6
     43  1800							; 60 ┃░░░┊░░░┊$3E┊$3F┊$40┊$41┊$42┊$43┊$44┊$45┃ 5
     44  1800							; 50 ┃░░░┊░░░┊$34┊$35┊$36┊$37┊$38┊$39┊$3A┊$3B┃ 4
     45  1800							; 40 ┃░░░┊░░░┊$2A┊$2B┊$2C┊$2D┊$2E┊$2F┊$30┊$31┃ 3
     46  1800							; 30 ┃░░░┊░░░┊$20┊$21┊$22┊$23┊$24┊$25┊$26|$27┃ 2
     47  1800							; 20 ┃░░░┊░░░┊$16┊$17┊$18┊$19┊$1A┊$1B┊$1C┊$1D┃ 1
     48  1800							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     49  1800							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     50  1800							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     51  1800							;	0   1	2   3	4   5	6   7	8   9
     52  1800							;		A   B	C   D	E   F	G   H
     53  1800
     54  1800
     55  1800							; We put a short buffer before 'ValidSquare' when it is at the start of the bank, so that
     56  1800							; the move indexing (ie., "ValidSquare+{1},x" won't drop off the beginning of the bank
     57  1800							; and sause "segfaults". 21 is the max offset (a knight move). These spare bytes can
     58  1800							; be re-used for something else - we just need to guarantee there are 21 of them there
     59  1800
      0  1800					      ALLOCATE	Valid, 120 + 80 + 21
      0  1800					      OPTIONAL_PAGEBREAK	"Table", 120 + 80 + 21
     12  1800					      LIST	ON
      0  1800					      DEF	Valid
      1  1800				   SLOT_Valid SET	_BANK_SLOT
      2  1800				   BANK_Valid SET	SLOT_Valid + _CURRENT_BANK
      3  1800				   Valid
      4  1800				   TEMPORARY_VAR SET	Overlay
      5  1800				   TEMPORARY_OFFSET SET	0
      6  1800				   VAR_BOUNDARY_Valid SET	TEMPORARY_OFFSET
      7  1800				   FUNCTION_NAME SET	Valid
     61  1800		       00 00 00 00*	      ds	21	; so indexing of "ValidSquare-21,x" won't fail
     62  1815							; Note, we will never index INTO the above bytes - x will always be >= 21
     63  1815							; We just need to make sure that the actual indexing will not have an address before
     64  1815							; the index of outside the page.
     65  1815
      0  1815					      DEF	ShadowValidSquare
      1  1815				   SLOT_ShadowValidSquare SET	_BANK_SLOT
      2  1815				   BANK_ShadowValidSquare SET	SLOT_ShadowValidSquare + _CURRENT_BANK
      3  1815				   ShadowValidSquare
      4  1815				   TEMPORARY_VAR SET	Overlay
      5  1815				   TEMPORARY_OFFSET SET	0
      6  1815				   VAR_BOUNDARY_ShadowValidSquare SET	TEMPORARY_OFFSET
      7  1815				   FUNCTION_NAME SET	ShadowValidSquare
     67  1815
     68  1815
     69  1815							; Use this table to
     70  1815							;   a) Determine if a square is valid (-1 = NO)
     71  1815							;   b) Move pieces without addition.  e.g., "lda ValidSquareTable+10,x" will let you know
     72  1815							;	if a white pawn on square "x" can move "up" the board.
     73  1815
     74  1815		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     75  181f		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     76  1829		       ff ff 16 17*	      .byte.b	-1, -1, 22, 23, 24, 25, 26, 27, 28, 29
     77  1833		       ff ff 20 21*	      .byte.b	-1, -1, 32, 33, 34, 35, 36, 37, 38, 39
     78  183d		       ff ff 2a 2b*	      .byte.b	-1, -1, 42, 43, 44, 45, 46, 47, 48, 49
     79  1847		       ff ff 34 35*	      .byte.b	-1, -1, 52, 53, 54, 55, 56, 57, 58, 59
     80  1851		       ff ff 3e 3f*	      .byte.b	-1, -1, 62, 63, 64, 65, 66, 67, 68, 69
     81  185b		       ff ff 48 49*	      .byte.b	-1, -1, 72, 73, 74, 75, 76, 77, 78, 79
     82  1865		       ff ff 52 53*	      .byte.b	-1, -1, 82, 83, 84, 85, 86, 87, 88, 89
     83  186f		       ff ff 5c 5d*	      .byte.b	-1, -1, 92, 93, 94, 95, 96, 97, 98, 99	; CONTINUES...
     84  1879
      0  1879					      DEF	ShadowBoard
      1  1879				   SLOT_ShadowBoard SET	_BANK_SLOT
      2  1879				   BANK_ShadowBoard SET	SLOT_ShadowBoard + _CURRENT_BANK
      3  1879				   ShadowBoard
      4  1879				   TEMPORARY_VAR SET	Overlay
      5  1879				   TEMPORARY_OFFSET SET	0
      6  1879				   VAR_BOUNDARY_ShadowBoard SET	TEMPORARY_OFFSET
      7  1879				   FUNCTION_NAME SET	ShadowBoard
     86  1879
     87  1879							; A 10X10... we should never write using invalid square
     88  1879							; ON COPY TO RAM BANK, 'BOARD' SELF-INITIALISES TO THE FOLLOWING VALUES
     89  1879							; FROM THEN ON IT'S WRITEABLE (REMEMBER TO +RAM_WRITE) FOR MODIFICATIONS
     90  1879
     91  1879		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     92  1883		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     93  188d
     94  188d					      REPEAT	8
     95  188d		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  188d					      REPEND
     95  1897		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  1897					      REPEND
     95  18a1		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  18a1					      REPEND
     95  18ab		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  18ab					      REPEND
     95  18b5		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  18b5					      REPEND
     95  18bf		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  18bf					      REPEND
     95  18c9		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  18c9					      REPEND
     95  18d3		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     96  18dd					      REPEND
     97  18dd
     98  18dd							; DON'T OVERSTEP BOUNDS WHEN WRITING BOARD - MAXIMUM INDEX = 99
     99  18dd
    100  18dd
    101  18dd							;---------------------------------------------------------------------------------------------------
    102  18dd							; EOF
------- FILE ./chess.asm
------- FILE BANK_EVAL.asm LEVEL 2 PASS 4
      0  18dd					      include	"BANK_EVAL.asm"
      1  18dd
      0  18dd					      SLOT	2
      1  18dd				  -	      IF	(2 < 0) || (2 > 3)
      2  18dd				  -	      ECHO	"Illegal bank address/segment location", 2
      3  18dd				  -	      ERR
      4  18dd					      ENDIF
      5  18dd				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  18dd				   _BANK_SLOT SET	2 * 64
      3  18dd
      4  18dd
      0  18dd					      NEWRAMBANK	BANK_EVAL
      1  18dd
      2  18dd
      3  18dd
      4 U2000 ????				      SEG.U	BANK_EVAL
      5 U2000					      ORG	ORIGIN_RAM
      6 U2000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2000				   _BANK_START SET	*
      8 U2000				   RAMBANK_BANK_EVAL SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2000				   _CURRENT_RAMBANK SET	RAMBANK_BANK_EVAL
     10 U2000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U2000					      NEWBANK	EVAL
      1  1e50 ????				      SEG	EVAL
      2  1c00					      ORG	_ORIGIN
      3  1c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  1c00				   _BANK_START SET	*
      5  1c00				   EVAL_START SET	*
      6  1c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1c00				   EVAL       SET	_BANK_SLOT + _CURRENT_BANK
      8  1c00				   _ORIGIN    SET	_ORIGIN + 1024
      7  1c00
      8  1c00
      9  1c00							; see https://www.chessprogramming.org/Simplified_Evaluation_Function
     10  1c00
     11  1c00
     12  1c00
     13  1c00					      MAC	vequ
     14  1c00				   VALUE_{1}  =	{2}
     15  1c00					      ENDM
     16  1c00
     17  1c00					      MAC	lobyte
     18  1c00					      .byte	<{2}
     19  1c00					      ENDM
     20  1c00
     21  1c00					      MAC	hibyte
     22  1c00					      .byte	>{2}
     23  1c00					      ENDM
     24  1c00
     25  1c00
     26  1c00					      MAC	valuetable
     27  1c00					      {1}	BLANK, 0
     28  1c00					      {1}	PAWN, 100	; white
     29  1c00					      {1}	PAWN, 100	; black
     30  1c00					      {1}	KNIGHT, 320
     31  1c00					      {1}	BISHOP, 375
     32  1c00					      {1}	ROOK, 575
     33  1c00					      {1}	QUEEN, 900
     34  1c00					      {1}	KING, 10000
     35  1c00					      ENDM
     36  1c00
     37  1c00
      0  1c00					      VALUETABLE	VEQU
      0  1c00					      VEQU	BLANK, 0
      1  1c00		       00 00	   VALUE_BLANK =	0
      0  1c00					      VEQU	PAWN, 100
      1  1c00		       00 64	   VALUE_PAWN =	100
      0  1c00					      VEQU	PAWN, 100
      1  1c00		       00 64	   VALUE_PAWN =	100
      0  1c00					      VEQU	KNIGHT, 320
      1  1c00		       01 40	   VALUE_KNIGHT =	320
      0  1c00					      VEQU	BISHOP, 375
      1  1c00		       01 77	   VALUE_BISHOP =	375
      0  1c00					      VEQU	ROOK, 575
      1  1c00		       02 3f	   VALUE_ROOK =	575
      0  1c00					      VEQU	QUEEN, 900
      1  1c00		       03 84	   VALUE_QUEEN =	900
      0  1c00					      VEQU	KING, 10000
      1  1c00		       27 10	   VALUE_KING =	10000
     39  1c00
      0  1c00					      DEF	PieceValueLO
      1  1c00				   SLOT_PieceValueLO SET	_BANK_SLOT
      2  1c00				   BANK_PieceValueLO SET	SLOT_PieceValueLO + _CURRENT_BANK
      3  1c00				   PieceValueLO
      4  1c00				   TEMPORARY_VAR SET	Overlay
      5  1c00				   TEMPORARY_OFFSET SET	0
      6  1c00				   VAR_BOUNDARY_PieceValueLO SET	TEMPORARY_OFFSET
      7  1c00				   FUNCTION_NAME SET	PieceValueLO
      0  1c00					      VALUETABLE	LOBYTE
      0  1c00					      LOBYTE	BLANK, 0
      1  1c00		       00		      .byte.b	<0
      0  1c01					      LOBYTE	PAWN, 100
      1  1c01		       64		      .byte.b	<100
      0  1c02					      LOBYTE	PAWN, 100
      1  1c02		       64		      .byte.b	<100
      0  1c03					      LOBYTE	KNIGHT, 320
      1  1c03		       40		      .byte.b	<320
      0  1c04					      LOBYTE	BISHOP, 375
      1  1c04		       77		      .byte.b	<375
      0  1c05					      LOBYTE	ROOK, 575
      1  1c05		       3f		      .byte.b	<575
      0  1c06					      LOBYTE	QUEEN, 900
      1  1c06		       84		      .byte.b	<900
      0  1c07					      LOBYTE	KING, 10000
      1  1c07		       10		      .byte.b	<10000
     42  1c08
      0  1c08					      DEF	PieceValueHI
      1  1c08				   SLOT_PieceValueHI SET	_BANK_SLOT
      2  1c08				   BANK_PieceValueHI SET	SLOT_PieceValueHI + _CURRENT_BANK
      3  1c08				   PieceValueHI
      4  1c08				   TEMPORARY_VAR SET	Overlay
      5  1c08				   TEMPORARY_OFFSET SET	0
      6  1c08				   VAR_BOUNDARY_PieceValueHI SET	TEMPORARY_OFFSET
      7  1c08				   FUNCTION_NAME SET	PieceValueHI
      0  1c08					      VALUETABLE	HIBYTE
      0  1c08					      HIBYTE	BLANK, 0
      1  1c08		       00		      .byte.b	>0
      0  1c09					      HIBYTE	PAWN, 100
      1  1c09		       00		      .byte.b	>100
      0  1c0a					      HIBYTE	PAWN, 100
      1  1c0a		       00		      .byte.b	>100
      0  1c0b					      HIBYTE	KNIGHT, 320
      1  1c0b		       01		      .byte.b	>320
      0  1c0c					      HIBYTE	BISHOP, 375
      1  1c0c		       01		      .byte.b	>375
      0  1c0d					      HIBYTE	ROOK, 575
      1  1c0d		       02		      .byte.b	>575
      0  1c0e					      HIBYTE	QUEEN, 900
      1  1c0e		       03		      .byte.b	>900
      0  1c0f					      HIBYTE	KING, 10000
      1  1c0f		       27		      .byte.b	>10000
     45  1c10
     46  1c10
     47  1c10							;---------------------------------------------------------------------------------------------------
     48  1c10							; Vectors to the position value tables for each piece
     49  1c10
     50  1c10					      MAC	posval
     51  1c10					      .byte	0
     52  1c10					      .byte	{1}(PositionalValue_PAWN - 22)
     53  1c10					      .byte	{1}(PositionalValue_PAWN - 22)
     54  1c10					      .byte	{1}(PositionalValue_KNIGHT - 22)
     55  1c10					      .byte	{1}(PositionalValue_BISHOP - 22)
     56  1c10					      .byte	{1}(PositionalValue_ROOK - 22)
     57  1c10					      .byte	{1}(PositionalValue_QUEEN - 22)
     58  1c10					      .byte	{1}(PositionalValue_KING_MIDGAME - 22)
     59  1c10					      ENDM
     60  1c10
      0  1c10					      ALLOCATE	PosValVecLO, 8
      0  1c10					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1c10					      LIST	ON
      0  1c10					      DEF	PosValVecLO
      1  1c10				   SLOT_PosValVecLO SET	_BANK_SLOT
      2  1c10				   BANK_PosValVecLO SET	SLOT_PosValVecLO + _CURRENT_BANK
      3  1c10				   PosValVecLO
      4  1c10				   TEMPORARY_VAR SET	Overlay
      5  1c10				   TEMPORARY_OFFSET SET	0
      6  1c10				   VAR_BOUNDARY_PosValVecLO SET	TEMPORARY_OFFSET
      7  1c10				   FUNCTION_NAME SET	PosValVecLO
      0  1c10					      POSVAL	<
      1  1c10		       00		      .byte.b	0
      2  1c11		       0a		      .byte.b	<(PositionalValue_PAWN - 22)
      3  1c12		       0a		      .byte.b	<(PositionalValue_PAWN - 22)
      4  1c13		       5a		      .byte.b	<(PositionalValue_KNIGHT - 22)
      5  1c14		       aa		      .byte.b	<(PositionalValue_BISHOP - 22)
      6  1c15		       fa		      .byte.b	<(PositionalValue_ROOK - 22)
      7  1c16		       4a		      .byte.b	<(PositionalValue_QUEEN - 22)
      8  1c17		       9a		      .byte.b	<(PositionalValue_KING_MIDGAME - 22)
      0  1c18					      ALLOCATE	PosValVecHI, 8
      0  1c18					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1c18					      LIST	ON
      0  1c18					      DEF	PosValVecHI
      1  1c18				   SLOT_PosValVecHI SET	_BANK_SLOT
      2  1c18				   BANK_PosValVecHI SET	SLOT_PosValVecHI + _CURRENT_BANK
      3  1c18				   PosValVecHI
      4  1c18				   TEMPORARY_VAR SET	Overlay
      5  1c18				   TEMPORARY_OFFSET SET	0
      6  1c18				   VAR_BOUNDARY_PosValVecHI SET	TEMPORARY_OFFSET
      7  1c18				   FUNCTION_NAME SET	PosValVecHI
      0  1c18					      POSVAL	>
      1  1c18		       00		      .byte.b	0
      2  1c19		       f8		      .byte.b	>(PositionalValue_PAWN - 22)
      3  1c1a		       f8		      .byte.b	>(PositionalValue_PAWN - 22)
      4  1c1b		       f8		      .byte.b	>(PositionalValue_KNIGHT - 22)
      5  1c1c		       f8		      .byte.b	>(PositionalValue_BISHOP - 22)
      6  1c1d		       f8		      .byte.b	>(PositionalValue_ROOK - 22)
      7  1c1e		       f9		      .byte.b	>(PositionalValue_QUEEN - 22)
      8  1c1f		       f9		      .byte.b	>(PositionalValue_KING_MIDGAME - 22)
     65  1c20
     66  1c20		       00 32	   BZ	      =	50
     67  1c20
     68  1c20					      MAC	pval
     69  1c20					      .byte	BZ + {1}
     70  1c20					      .byte	BZ + {2}
     71  1c20					      .byte	BZ + {3}
     72  1c20					      .byte	BZ + {4}
     73  1c20					      .byte	BZ + {5}
     74  1c20					      .byte	BZ + {6}
     75  1c20					      .byte	BZ + {7}
     76  1c20					      .byte	BZ + {8}
     77  1c20					      .byte	BZ
     78  1c20					      .byte	BZ
     79  1c20					      ENDM		;{ 10 entries }
     80  1c20
     81  1c20							;---------------------------------------------------------------------------------------------------
     82  1c20
     83  1c20				   PositionalValue_PAWN
     84  1c20
      0  1c20					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  1c20		       32		      .byte.b	BZ + 0
      2  1c21		       32		      .byte.b	BZ + 0
      3  1c22		       32		      .byte.b	BZ + 0
      4  1c23		       32		      .byte.b	BZ + 0
      5  1c24		       32		      .byte.b	BZ + 0
      6  1c25		       32		      .byte.b	BZ + 0
      7  1c26		       32		      .byte.b	BZ + 0
      8  1c27		       32		      .byte.b	BZ + 0
      9  1c28		       32		      .byte.b	BZ
     10  1c29		       32		      .byte.b	BZ
      0  1c2a					      PVAL	15, 10, 0, -20, -20, 0, 10, 15
      1  1c2a		       41		      .byte.b	BZ + 15
      2  1c2b		       3c		      .byte.b	BZ + 10
      3  1c2c		       32		      .byte.b	BZ + 0
      4  1c2d		       1e		      .byte.b	BZ + -20
      5  1c2e		       1e		      .byte.b	BZ + -20
      6  1c2f		       32		      .byte.b	BZ + 0
      7  1c30		       3c		      .byte.b	BZ + 10
      8  1c31		       41		      .byte.b	BZ + 15
      9  1c32		       32		      .byte.b	BZ
     10  1c33		       32		      .byte.b	BZ
      0  1c34					      PVAL	5, -5, -10, 0, 0, -10, -5, 5
      1  1c34		       37		      .byte.b	BZ + 5
      2  1c35		       2d		      .byte.b	BZ + -5
      3  1c36		       28		      .byte.b	BZ + -10
      4  1c37		       32		      .byte.b	BZ + 0
      5  1c38		       32		      .byte.b	BZ + 0
      6  1c39		       28		      .byte.b	BZ + -10
      7  1c3a		       2d		      .byte.b	BZ + -5
      8  1c3b		       37		      .byte.b	BZ + 5
      9  1c3c		       32		      .byte.b	BZ
     10  1c3d		       32		      .byte.b	BZ
      0  1c3e					      PVAL	0, 0, 0, 10, 40, 0, 0, 0
      1  1c3e		       32		      .byte.b	BZ + 0
      2  1c3f		       32		      .byte.b	BZ + 0
      3  1c40		       32		      .byte.b	BZ + 0
      4  1c41		       3c		      .byte.b	BZ + 10
      5  1c42		       5a		      .byte.b	BZ + 40
      6  1c43		       32		      .byte.b	BZ + 0
      7  1c44		       32		      .byte.b	BZ + 0
      8  1c45		       32		      .byte.b	BZ + 0
      9  1c46		       32		      .byte.b	BZ
     10  1c47		       32		      .byte.b	BZ
      0  1c48					      PVAL	15, 15, 20, 20, 50, 20, 15, 15
      1  1c48		       41		      .byte.b	BZ + 15
      2  1c49		       41		      .byte.b	BZ + 15
      3  1c4a		       46		      .byte.b	BZ + 20
      4  1c4b		       46		      .byte.b	BZ + 20
      5  1c4c		       64		      .byte.b	BZ + 50
      6  1c4d		       46		      .byte.b	BZ + 20
      7  1c4e		       41		      .byte.b	BZ + 15
      8  1c4f		       41		      .byte.b	BZ + 15
      9  1c50		       32		      .byte.b	BZ
     10  1c51		       32		      .byte.b	BZ
      0  1c52					      PVAL	30, 30, 40, 50, 50, 40, 30, 30
      1  1c52		       50		      .byte.b	BZ + 30
      2  1c53		       50		      .byte.b	BZ + 30
      3  1c54		       5a		      .byte.b	BZ + 40
      4  1c55		       64		      .byte.b	BZ + 50
      5  1c56		       64		      .byte.b	BZ + 50
      6  1c57		       5a		      .byte.b	BZ + 40
      7  1c58		       50		      .byte.b	BZ + 30
      8  1c59		       50		      .byte.b	BZ + 30
      9  1c5a		       32		      .byte.b	BZ
     10  1c5b		       32		      .byte.b	BZ
      0  1c5c					      PVAL	40, 50, 60, 70, 70, 60, 50, 40
      1  1c5c		       5a		      .byte.b	BZ + 40
      2  1c5d		       64		      .byte.b	BZ + 50
      3  1c5e		       6e		      .byte.b	BZ + 60
      4  1c5f		       78		      .byte.b	BZ + 70
      5  1c60		       78		      .byte.b	BZ + 70
      6  1c61		       6e		      .byte.b	BZ + 60
      7  1c62		       64		      .byte.b	BZ + 50
      8  1c63		       5a		      .byte.b	BZ + 40
      9  1c64		       32		      .byte.b	BZ
     10  1c65		       32		      .byte.b	BZ
      0  1c66					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  1c66		       32		      .byte.b	BZ + 0
      2  1c67		       32		      .byte.b	BZ + 0
      3  1c68		       32		      .byte.b	BZ + 0
      4  1c69		       32		      .byte.b	BZ + 0
      5  1c6a		       32		      .byte.b	BZ + 0
      6  1c6b		       32		      .byte.b	BZ + 0
      7  1c6c		       32		      .byte.b	BZ + 0
      8  1c6d		       32		      .byte.b	BZ + 0
      9  1c6e		       32		      .byte.b	BZ
     10  1c6f		       32		      .byte.b	BZ
     93  1c70
     94  1c70							;---------------------------------------------------------------------------------------------------
     95  1c70
     96  1c70				   PositionalValue_KNIGHT
     97  1c70
      0  1c70					      PVAL	-50, -40, -30, -30, -30, -30, -40, -50
      1  1c70		       00		      .byte.b	BZ + -50
      2  1c71		       0a		      .byte.b	BZ + -40
      3  1c72		       14		      .byte.b	BZ + -30
      4  1c73		       14		      .byte.b	BZ + -30
      5  1c74		       14		      .byte.b	BZ + -30
      6  1c75		       14		      .byte.b	BZ + -30
      7  1c76		       0a		      .byte.b	BZ + -40
      8  1c77		       00		      .byte.b	BZ + -50
      9  1c78		       32		      .byte.b	BZ
     10  1c79		       32		      .byte.b	BZ
      0  1c7a					      PVAL	-40, -20, 0, 5, 5, 0, -20, -40
      1  1c7a		       0a		      .byte.b	BZ + -40
      2  1c7b		       1e		      .byte.b	BZ + -20
      3  1c7c		       32		      .byte.b	BZ + 0
      4  1c7d		       37		      .byte.b	BZ + 5
      5  1c7e		       37		      .byte.b	BZ + 5
      6  1c7f		       32		      .byte.b	BZ + 0
      7  1c80		       1e		      .byte.b	BZ + -20
      8  1c81		       0a		      .byte.b	BZ + -40
      9  1c82		       32		      .byte.b	BZ
     10  1c83		       32		      .byte.b	BZ
      0  1c84					      PVAL	-30, 0, 20, 15, 15, 20, 0, -30
      1  1c84		       14		      .byte.b	BZ + -30
      2  1c85		       32		      .byte.b	BZ + 0
      3  1c86		       46		      .byte.b	BZ + 20
      4  1c87		       41		      .byte.b	BZ + 15
      5  1c88		       41		      .byte.b	BZ + 15
      6  1c89		       46		      .byte.b	BZ + 20
      7  1c8a		       32		      .byte.b	BZ + 0
      8  1c8b		       14		      .byte.b	BZ + -30
      9  1c8c		       32		      .byte.b	BZ
     10  1c8d		       32		      .byte.b	BZ
      0  1c8e					      PVAL	-30, 0, 15, 30, 30, 15, 0, -30
      1  1c8e		       14		      .byte.b	BZ + -30
      2  1c8f		       32		      .byte.b	BZ + 0
      3  1c90		       41		      .byte.b	BZ + 15
      4  1c91		       50		      .byte.b	BZ + 30
      5  1c92		       50		      .byte.b	BZ + 30
      6  1c93		       41		      .byte.b	BZ + 15
      7  1c94		       32		      .byte.b	BZ + 0
      8  1c95		       14		      .byte.b	BZ + -30
      9  1c96		       32		      .byte.b	BZ
     10  1c97		       32		      .byte.b	BZ
      0  1c98					      PVAL	-30, 5, 15, 30, 30, 15, 5, -30
      1  1c98		       14		      .byte.b	BZ + -30
      2  1c99		       37		      .byte.b	BZ + 5
      3  1c9a		       41		      .byte.b	BZ + 15
      4  1c9b		       50		      .byte.b	BZ + 30
      5  1c9c		       50		      .byte.b	BZ + 30
      6  1c9d		       41		      .byte.b	BZ + 15
      7  1c9e		       37		      .byte.b	BZ + 5
      8  1c9f		       14		      .byte.b	BZ + -30
      9  1ca0		       32		      .byte.b	BZ
     10  1ca1		       32		      .byte.b	BZ
      0  1ca2					      PVAL	-30, 0, 10, 15, 15, 10, 0, -30
      1  1ca2		       14		      .byte.b	BZ + -30
      2  1ca3		       32		      .byte.b	BZ + 0
      3  1ca4		       3c		      .byte.b	BZ + 10
      4  1ca5		       41		      .byte.b	BZ + 15
      5  1ca6		       41		      .byte.b	BZ + 15
      6  1ca7		       3c		      .byte.b	BZ + 10
      7  1ca8		       32		      .byte.b	BZ + 0
      8  1ca9		       14		      .byte.b	BZ + -30
      9  1caa		       32		      .byte.b	BZ
     10  1cab		       32		      .byte.b	BZ
      0  1cac					      PVAL	-40, -20, 30, 0, 0, 30, -20, -40
      1  1cac		       0a		      .byte.b	BZ + -40
      2  1cad		       1e		      .byte.b	BZ + -20
      3  1cae		       50		      .byte.b	BZ + 30
      4  1caf		       32		      .byte.b	BZ + 0
      5  1cb0		       32		      .byte.b	BZ + 0
      6  1cb1		       50		      .byte.b	BZ + 30
      7  1cb2		       1e		      .byte.b	BZ + -20
      8  1cb3		       0a		      .byte.b	BZ + -40
      9  1cb4		       32		      .byte.b	BZ
     10  1cb5		       32		      .byte.b	BZ
      0  1cb6					      PVAL	-50, -20, -30, -30, -30, -30, -20, -50
      1  1cb6		       00		      .byte.b	BZ + -50
      2  1cb7		       1e		      .byte.b	BZ + -20
      3  1cb8		       14		      .byte.b	BZ + -30
      4  1cb9		       14		      .byte.b	BZ + -30
      5  1cba		       14		      .byte.b	BZ + -30
      6  1cbb		       14		      .byte.b	BZ + -30
      7  1cbc		       1e		      .byte.b	BZ + -20
      8  1cbd		       00		      .byte.b	BZ + -50
      9  1cbe		       32		      .byte.b	BZ
     10  1cbf		       32		      .byte.b	BZ
    106  1cc0
    107  1cc0
    108  1cc0							;---------------------------------------------------------------------------------------------------
    109  1cc0
    110  1cc0				   PositionalValue_BISHOP
    111  1cc0
      0  1cc0					      PVAL	-20, -10, -50, -10, -10, -50, -10, -20
      1  1cc0		       1e		      .byte.b	BZ + -20
      2  1cc1		       28		      .byte.b	BZ + -10
      3  1cc2		       00		      .byte.b	BZ + -50
      4  1cc3		       28		      .byte.b	BZ + -10
      5  1cc4		       28		      .byte.b	BZ + -10
      6  1cc5		       00		      .byte.b	BZ + -50
      7  1cc6		       28		      .byte.b	BZ + -10
      8  1cc7		       1e		      .byte.b	BZ + -20
      9  1cc8		       32		      .byte.b	BZ
     10  1cc9		       32		      .byte.b	BZ
      0  1cca					      PVAL	-10, 5, 0, 0, 0, 0, 5, -10
      1  1cca		       28		      .byte.b	BZ + -10
      2  1ccb		       37		      .byte.b	BZ + 5
      3  1ccc		       32		      .byte.b	BZ + 0
      4  1ccd		       32		      .byte.b	BZ + 0
      5  1cce		       32		      .byte.b	BZ + 0
      6  1ccf		       32		      .byte.b	BZ + 0
      7  1cd0		       37		      .byte.b	BZ + 5
      8  1cd1		       28		      .byte.b	BZ + -10
      9  1cd2		       32		      .byte.b	BZ
     10  1cd3		       32		      .byte.b	BZ
      0  1cd4					      PVAL	-10, 10, 10, 10, 10, 10, 10, -10
      1  1cd4		       28		      .byte.b	BZ + -10
      2  1cd5		       3c		      .byte.b	BZ + 10
      3  1cd6		       3c		      .byte.b	BZ + 10
      4  1cd7		       3c		      .byte.b	BZ + 10
      5  1cd8		       3c		      .byte.b	BZ + 10
      6  1cd9		       3c		      .byte.b	BZ + 10
      7  1cda		       3c		      .byte.b	BZ + 10
      8  1cdb		       28		      .byte.b	BZ + -10
      9  1cdc		       32		      .byte.b	BZ
     10  1cdd		       32		      .byte.b	BZ
      0  1cde					      PVAL	-10, 0, 10, 20, 20, 10, 0, -10
      1  1cde		       28		      .byte.b	BZ + -10
      2  1cdf		       32		      .byte.b	BZ + 0
      3  1ce0		       3c		      .byte.b	BZ + 10
      4  1ce1		       46		      .byte.b	BZ + 20
      5  1ce2		       46		      .byte.b	BZ + 20
      6  1ce3		       3c		      .byte.b	BZ + 10
      7  1ce4		       32		      .byte.b	BZ + 0
      8  1ce5		       28		      .byte.b	BZ + -10
      9  1ce6		       32		      .byte.b	BZ
     10  1ce7		       32		      .byte.b	BZ
      0  1ce8					      PVAL	-10, 5, 5, 20, 20, 5, 5, -10
      1  1ce8		       28		      .byte.b	BZ + -10
      2  1ce9		       37		      .byte.b	BZ + 5
      3  1cea		       37		      .byte.b	BZ + 5
      4  1ceb		       46		      .byte.b	BZ + 20
      5  1cec		       46		      .byte.b	BZ + 20
      6  1ced		       37		      .byte.b	BZ + 5
      7  1cee		       37		      .byte.b	BZ + 5
      8  1cef		       28		      .byte.b	BZ + -10
      9  1cf0		       32		      .byte.b	BZ
     10  1cf1		       32		      .byte.b	BZ
      0  1cf2					      PVAL	-10, 0, 5, 10, 10, 5, 0, -10
      1  1cf2		       28		      .byte.b	BZ + -10
      2  1cf3		       32		      .byte.b	BZ + 0
      3  1cf4		       37		      .byte.b	BZ + 5
      4  1cf5		       3c		      .byte.b	BZ + 10
      5  1cf6		       3c		      .byte.b	BZ + 10
      6  1cf7		       37		      .byte.b	BZ + 5
      7  1cf8		       32		      .byte.b	BZ + 0
      8  1cf9		       28		      .byte.b	BZ + -10
      9  1cfa		       32		      .byte.b	BZ
     10  1cfb		       32		      .byte.b	BZ
      0  1cfc					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      1  1cfc		       28		      .byte.b	BZ + -10
      2  1cfd		       32		      .byte.b	BZ + 0
      3  1cfe		       32		      .byte.b	BZ + 0
      4  1cff		       32		      .byte.b	BZ + 0
      5  1d00		       32		      .byte.b	BZ + 0
      6  1d01		       32		      .byte.b	BZ + 0
      7  1d02		       32		      .byte.b	BZ + 0
      8  1d03		       28		      .byte.b	BZ + -10
      9  1d04		       32		      .byte.b	BZ
     10  1d05		       32		      .byte.b	BZ
      0  1d06					      PVAL	-20, -10, -10, -10, -10, -10, -10, -20
      1  1d06		       1e		      .byte.b	BZ + -20
      2  1d07		       28		      .byte.b	BZ + -10
      3  1d08		       28		      .byte.b	BZ + -10
      4  1d09		       28		      .byte.b	BZ + -10
      5  1d0a		       28		      .byte.b	BZ + -10
      6  1d0b		       28		      .byte.b	BZ + -10
      7  1d0c		       28		      .byte.b	BZ + -10
      8  1d0d		       1e		      .byte.b	BZ + -20
      9  1d0e		       32		      .byte.b	BZ
     10  1d0f		       32		      .byte.b	BZ
    120  1d10
    121  1d10
    122  1d10							;---------------------------------------------------------------------------------------------------
    123  1d10
    124  1d10				   PositionalValue_ROOK
    125  1d10
      0  1d10					      PVAL	-120, -10, 10, 25, 25, 10, -10, -200
      1  1d10		       ba		      .byte.b	BZ + -120
      2  1d11		       28		      .byte.b	BZ + -10
      3  1d12		       3c		      .byte.b	BZ + 10
      4  1d13		       4b		      .byte.b	BZ + 25
      5  1d14		       4b		      .byte.b	BZ + 25
      6  1d15		       3c		      .byte.b	BZ + 10
      7  1d16		       28		      .byte.b	BZ + -10
      8  1d17		       6a		      .byte.b	BZ + -200
      9  1d18		       32		      .byte.b	BZ
     10  1d19		       32		      .byte.b	BZ
      0  1d1a					      PVAL	-75, 0, 0, 0, 0, 0, 0, -200
      1  1d1a		       e7		      .byte.b	BZ + -75
      2  1d1b		       32		      .byte.b	BZ + 0
      3  1d1c		       32		      .byte.b	BZ + 0
      4  1d1d		       32		      .byte.b	BZ + 0
      5  1d1e		       32		      .byte.b	BZ + 0
      6  1d1f		       32		      .byte.b	BZ + 0
      7  1d20		       32		      .byte.b	BZ + 0
      8  1d21		       6a		      .byte.b	BZ + -200
      9  1d22		       32		      .byte.b	BZ
     10  1d23		       32		      .byte.b	BZ
      0  1d24					      PVAL	-75, 0, 0, 0, 0, 0, 0, -150
      1  1d24		       e7		      .byte.b	BZ + -75
      2  1d25		       32		      .byte.b	BZ + 0
      3  1d26		       32		      .byte.b	BZ + 0
      4  1d27		       32		      .byte.b	BZ + 0
      5  1d28		       32		      .byte.b	BZ + 0
      6  1d29		       32		      .byte.b	BZ + 0
      7  1d2a		       32		      .byte.b	BZ + 0
      8  1d2b		       9c		      .byte.b	BZ + -150
      9  1d2c		       32		      .byte.b	BZ
     10  1d2d		       32		      .byte.b	BZ
      0  1d2e					      PVAL	-50, 0, 0, 0, 0, 0, 0, -100
      1  1d2e		       00		      .byte.b	BZ + -50
      2  1d2f		       32		      .byte.b	BZ + 0
      3  1d30		       32		      .byte.b	BZ + 0
      4  1d31		       32		      .byte.b	BZ + 0
      5  1d32		       32		      .byte.b	BZ + 0
      6  1d33		       32		      .byte.b	BZ + 0
      7  1d34		       32		      .byte.b	BZ + 0
      8  1d35		       ce		      .byte.b	BZ + -100
      9  1d36		       32		      .byte.b	BZ
     10  1d37		       32		      .byte.b	BZ
      0  1d38					      PVAL	-5, 0, 0, 0, 0, 0, 0, -50
      1  1d38		       2d		      .byte.b	BZ + -5
      2  1d39		       32		      .byte.b	BZ + 0
      3  1d3a		       32		      .byte.b	BZ + 0
      4  1d3b		       32		      .byte.b	BZ + 0
      5  1d3c		       32		      .byte.b	BZ + 0
      6  1d3d		       32		      .byte.b	BZ + 0
      7  1d3e		       32		      .byte.b	BZ + 0
      8  1d3f		       00		      .byte.b	BZ + -50
      9  1d40		       32		      .byte.b	BZ
     10  1d41		       32		      .byte.b	BZ
      0  1d42					      PVAL	-5, 0, 30, 30, 30, 30, 0, -5
      1  1d42		       2d		      .byte.b	BZ + -5
      2  1d43		       32		      .byte.b	BZ + 0
      3  1d44		       50		      .byte.b	BZ + 30
      4  1d45		       50		      .byte.b	BZ + 30
      5  1d46		       50		      .byte.b	BZ + 30
      6  1d47		       50		      .byte.b	BZ + 30
      7  1d48		       32		      .byte.b	BZ + 0
      8  1d49		       2d		      .byte.b	BZ + -5
      9  1d4a		       32		      .byte.b	BZ
     10  1d4b		       32		      .byte.b	BZ
      0  1d4c					      PVAL	5, 10, 50, 50, 50, 50, 10, 5
      1  1d4c		       37		      .byte.b	BZ + 5
      2  1d4d		       3c		      .byte.b	BZ + 10
      3  1d4e		       64		      .byte.b	BZ + 50
      4  1d4f		       64		      .byte.b	BZ + 50
      5  1d50		       64		      .byte.b	BZ + 50
      6  1d51		       64		      .byte.b	BZ + 50
      7  1d52		       3c		      .byte.b	BZ + 10
      8  1d53		       37		      .byte.b	BZ + 5
      9  1d54		       32		      .byte.b	BZ
     10  1d55		       32		      .byte.b	BZ
      0  1d56					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  1d56		       32		      .byte.b	BZ + 0
      2  1d57		       32		      .byte.b	BZ + 0
      3  1d58		       32		      .byte.b	BZ + 0
      4  1d59		       32		      .byte.b	BZ + 0
      5  1d5a		       32		      .byte.b	BZ + 0
      6  1d5b		       32		      .byte.b	BZ + 0
      7  1d5c		       32		      .byte.b	BZ + 0
      8  1d5d		       32		      .byte.b	BZ + 0
      9  1d5e		       32		      .byte.b	BZ
     10  1d5f		       32		      .byte.b	BZ
    134  1d60
    135  1d60
    136  1d60							;---------------------------------------------------------------------------------------------------
    137  1d60
    138  1d60				   PositionalValue_QUEEN
    139  1d60
      0  1d60					      PVAL	-20, -10, -5, -5, -5, -10, -10, -20
      1  1d60		       1e		      .byte.b	BZ + -20
      2  1d61		       28		      .byte.b	BZ + -10
      3  1d62		       2d		      .byte.b	BZ + -5
      4  1d63		       2d		      .byte.b	BZ + -5
      5  1d64		       2d		      .byte.b	BZ + -5
      6  1d65		       28		      .byte.b	BZ + -10
      7  1d66		       28		      .byte.b	BZ + -10
      8  1d67		       1e		      .byte.b	BZ + -20
      9  1d68		       32		      .byte.b	BZ
     10  1d69		       32		      .byte.b	BZ
      0  1d6a					      PVAL	-10, 0, 5, 0, 0, 0, 0, -10
      1  1d6a		       28		      .byte.b	BZ + -10
      2  1d6b		       32		      .byte.b	BZ + 0
      3  1d6c		       37		      .byte.b	BZ + 5
      4  1d6d		       32		      .byte.b	BZ + 0
      5  1d6e		       32		      .byte.b	BZ + 0
      6  1d6f		       32		      .byte.b	BZ + 0
      7  1d70		       32		      .byte.b	BZ + 0
      8  1d71		       28		      .byte.b	BZ + -10
      9  1d72		       32		      .byte.b	BZ
     10  1d73		       32		      .byte.b	BZ
      0  1d74					      PVAL	-10, 5, 5, 5, 5, 25, 0, -10
      1  1d74		       28		      .byte.b	BZ + -10
      2  1d75		       37		      .byte.b	BZ + 5
      3  1d76		       37		      .byte.b	BZ + 5
      4  1d77		       37		      .byte.b	BZ + 5
      5  1d78		       37		      .byte.b	BZ + 5
      6  1d79		       4b		      .byte.b	BZ + 25
      7  1d7a		       32		      .byte.b	BZ + 0
      8  1d7b		       28		      .byte.b	BZ + -10
      9  1d7c		       32		      .byte.b	BZ
     10  1d7d		       32		      .byte.b	BZ
      0  1d7e					      PVAL	-10, 0, 5, 25, 25, 25, 0, -10
      1  1d7e		       28		      .byte.b	BZ + -10
      2  1d7f		       32		      .byte.b	BZ + 0
      3  1d80		       37		      .byte.b	BZ + 5
      4  1d81		       4b		      .byte.b	BZ + 25
      5  1d82		       4b		      .byte.b	BZ + 25
      6  1d83		       4b		      .byte.b	BZ + 25
      7  1d84		       32		      .byte.b	BZ + 0
      8  1d85		       28		      .byte.b	BZ + -10
      9  1d86		       32		      .byte.b	BZ
     10  1d87		       32		      .byte.b	BZ
      0  1d88					      PVAL	-5, 0, 15, 55, 55, 55, 0, -5
      1  1d88		       2d		      .byte.b	BZ + -5
      2  1d89		       32		      .byte.b	BZ + 0
      3  1d8a		       41		      .byte.b	BZ + 15
      4  1d8b		       69		      .byte.b	BZ + 55
      5  1d8c		       69		      .byte.b	BZ + 55
      6  1d8d		       69		      .byte.b	BZ + 55
      7  1d8e		       32		      .byte.b	BZ + 0
      8  1d8f		       2d		      .byte.b	BZ + -5
      9  1d90		       32		      .byte.b	BZ
     10  1d91		       32		      .byte.b	BZ
      0  1d92					      PVAL	-10, 0, 25, 75, 75, 75, 0, -10
      1  1d92		       28		      .byte.b	BZ + -10
      2  1d93		       32		      .byte.b	BZ + 0
      3  1d94		       4b		      .byte.b	BZ + 25
      4  1d95		       7d		      .byte.b	BZ + 75
      5  1d96		       7d		      .byte.b	BZ + 75
      6  1d97		       7d		      .byte.b	BZ + 75
      7  1d98		       32		      .byte.b	BZ + 0
      8  1d99		       28		      .byte.b	BZ + -10
      9  1d9a		       32		      .byte.b	BZ
     10  1d9b		       32		      .byte.b	BZ
      0  1d9c					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      1  1d9c		       28		      .byte.b	BZ + -10
      2  1d9d		       32		      .byte.b	BZ + 0
      3  1d9e		       32		      .byte.b	BZ + 0
      4  1d9f		       32		      .byte.b	BZ + 0
      5  1da0		       32		      .byte.b	BZ + 0
      6  1da1		       32		      .byte.b	BZ + 0
      7  1da2		       32		      .byte.b	BZ + 0
      8  1da3		       28		      .byte.b	BZ + -10
      9  1da4		       32		      .byte.b	BZ
     10  1da5		       32		      .byte.b	BZ
      0  1da6					      PVAL	-20, -10, -10, -5, -5, -10, -10, -20
      1  1da6		       1e		      .byte.b	BZ + -20
      2  1da7		       28		      .byte.b	BZ + -10
      3  1da8		       28		      .byte.b	BZ + -10
      4  1da9		       2d		      .byte.b	BZ + -5
      5  1daa		       2d		      .byte.b	BZ + -5
      6  1dab		       28		      .byte.b	BZ + -10
      7  1dac		       28		      .byte.b	BZ + -10
      8  1dad		       1e		      .byte.b	BZ + -20
      9  1dae		       32		      .byte.b	BZ
     10  1daf		       32		      .byte.b	BZ
    148  1db0
    149  1db0
    150  1db0							;---------------------------------------------------------------------------------------------------
    151  1db0
    152  1db0				   PositionalValue_KING_MIDGAME
    153  1db0
      0  1db0					      PVAL	0, 0, 30, -20, 0, 10, 40, 10
      1  1db0		       32		      .byte.b	BZ + 0
      2  1db1		       32		      .byte.b	BZ + 0
      3  1db2		       50		      .byte.b	BZ + 30
      4  1db3		       1e		      .byte.b	BZ + -20
      5  1db4		       32		      .byte.b	BZ + 0
      6  1db5		       3c		      .byte.b	BZ + 10
      7  1db6		       5a		      .byte.b	BZ + 40
      8  1db7		       3c		      .byte.b	BZ + 10
      9  1db8		       32		      .byte.b	BZ
     10  1db9		       32		      .byte.b	BZ
      0  1dba					      PVAL	20, 20, 0, -10, -10, 0, 20, 20
      1  1dba		       46		      .byte.b	BZ + 20
      2  1dbb		       46		      .byte.b	BZ + 20
      3  1dbc		       32		      .byte.b	BZ + 0
      4  1dbd		       28		      .byte.b	BZ + -10
      5  1dbe		       28		      .byte.b	BZ + -10
      6  1dbf		       32		      .byte.b	BZ + 0
      7  1dc0		       46		      .byte.b	BZ + 20
      8  1dc1		       46		      .byte.b	BZ + 20
      9  1dc2		       32		      .byte.b	BZ
     10  1dc3		       32		      .byte.b	BZ
      0  1dc4					      PVAL	-10, -20, -20, -20, -20, -20, -20, -10
      1  1dc4		       28		      .byte.b	BZ + -10
      2  1dc5		       1e		      .byte.b	BZ + -20
      3  1dc6		       1e		      .byte.b	BZ + -20
      4  1dc7		       1e		      .byte.b	BZ + -20
      5  1dc8		       1e		      .byte.b	BZ + -20
      6  1dc9		       1e		      .byte.b	BZ + -20
      7  1dca		       1e		      .byte.b	BZ + -20
      8  1dcb		       28		      .byte.b	BZ + -10
      9  1dcc		       32		      .byte.b	BZ
     10  1dcd		       32		      .byte.b	BZ
      0  1dce					      PVAL	-20, -30, -30, -40, -40, -30, -30, -20
      1  1dce		       1e		      .byte.b	BZ + -20
      2  1dcf		       14		      .byte.b	BZ + -30
      3  1dd0		       14		      .byte.b	BZ + -30
      4  1dd1		       0a		      .byte.b	BZ + -40
      5  1dd2		       0a		      .byte.b	BZ + -40
      6  1dd3		       14		      .byte.b	BZ + -30
      7  1dd4		       14		      .byte.b	BZ + -30
      8  1dd5		       1e		      .byte.b	BZ + -20
      9  1dd6		       32		      .byte.b	BZ
     10  1dd7		       32		      .byte.b	BZ
      0  1dd8					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  1dd8		       14		      .byte.b	BZ + -30
      2  1dd9		       0a		      .byte.b	BZ + -40
      3  1dda		       0a		      .byte.b	BZ + -40
      4  1ddb		       00		      .byte.b	BZ + -50
      5  1ddc		       00		      .byte.b	BZ + -50
      6  1ddd		       0a		      .byte.b	BZ + -40
      7  1dde		       0a		      .byte.b	BZ + -40
      8  1ddf		       14		      .byte.b	BZ + -30
      9  1de0		       32		      .byte.b	BZ
     10  1de1		       32		      .byte.b	BZ
      0  1de2					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  1de2		       14		      .byte.b	BZ + -30
      2  1de3		       0a		      .byte.b	BZ + -40
      3  1de4		       0a		      .byte.b	BZ + -40
      4  1de5		       00		      .byte.b	BZ + -50
      5  1de6		       00		      .byte.b	BZ + -50
      6  1de7		       0a		      .byte.b	BZ + -40
      7  1de8		       0a		      .byte.b	BZ + -40
      8  1de9		       14		      .byte.b	BZ + -30
      9  1dea		       32		      .byte.b	BZ
     10  1deb		       32		      .byte.b	BZ
      0  1dec					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  1dec		       14		      .byte.b	BZ + -30
      2  1ded		       0a		      .byte.b	BZ + -40
      3  1dee		       0a		      .byte.b	BZ + -40
      4  1def		       00		      .byte.b	BZ + -50
      5  1df0		       00		      .byte.b	BZ + -50
      6  1df1		       0a		      .byte.b	BZ + -40
      7  1df2		       0a		      .byte.b	BZ + -40
      8  1df3		       14		      .byte.b	BZ + -30
      9  1df4		       32		      .byte.b	BZ
     10  1df5		       32		      .byte.b	BZ
      0  1df6					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  1df6		       14		      .byte.b	BZ + -30
      2  1df7		       0a		      .byte.b	BZ + -40
      3  1df8		       0a		      .byte.b	BZ + -40
      4  1df9		       00		      .byte.b	BZ + -50
      5  1dfa		       00		      .byte.b	BZ + -50
      6  1dfb		       0a		      .byte.b	BZ + -40
      7  1dfc		       0a		      .byte.b	BZ + -40
      8  1dfd		       14		      .byte.b	BZ + -30
      9  1dfe		       32		      .byte.b	BZ
     10  1dff		       32		      .byte.b	BZ
    162  1e00
    163  1e00
    164  1e00							;---------------------------------------------------------------------------------------------------
    165  1e00
    166  1e00				   PositionalValue_KING_ENDGAME
    167  1e00
      0  1e00					      PVAL	-50, -30, -30, -30, -30, -30, -30, -50
      1  1e00		       00		      .byte.b	BZ + -50
      2  1e01		       14		      .byte.b	BZ + -30
      3  1e02		       14		      .byte.b	BZ + -30
      4  1e03		       14		      .byte.b	BZ + -30
      5  1e04		       14		      .byte.b	BZ + -30
      6  1e05		       14		      .byte.b	BZ + -30
      7  1e06		       14		      .byte.b	BZ + -30
      8  1e07		       00		      .byte.b	BZ + -50
      9  1e08		       32		      .byte.b	BZ
     10  1e09		       32		      .byte.b	BZ
      0  1e0a					      PVAL	-30, -30, 0, 0, 0, 0, -30, -30
      1  1e0a		       14		      .byte.b	BZ + -30
      2  1e0b		       14		      .byte.b	BZ + -30
      3  1e0c		       32		      .byte.b	BZ + 0
      4  1e0d		       32		      .byte.b	BZ + 0
      5  1e0e		       32		      .byte.b	BZ + 0
      6  1e0f		       32		      .byte.b	BZ + 0
      7  1e10		       14		      .byte.b	BZ + -30
      8  1e11		       14		      .byte.b	BZ + -30
      9  1e12		       32		      .byte.b	BZ
     10  1e13		       32		      .byte.b	BZ
      0  1e14					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      1  1e14		       14		      .byte.b	BZ + -30
      2  1e15		       28		      .byte.b	BZ + -10
      3  1e16		       46		      .byte.b	BZ + 20
      4  1e17		       50		      .byte.b	BZ + 30
      5  1e18		       50		      .byte.b	BZ + 30
      6  1e19		       46		      .byte.b	BZ + 20
      7  1e1a		       28		      .byte.b	BZ + -10
      8  1e1b		       14		      .byte.b	BZ + -30
      9  1e1c		       32		      .byte.b	BZ
     10  1e1d		       32		      .byte.b	BZ
      0  1e1e					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      1  1e1e		       14		      .byte.b	BZ + -30
      2  1e1f		       28		      .byte.b	BZ + -10
      3  1e20		       50		      .byte.b	BZ + 30
      4  1e21		       5a		      .byte.b	BZ + 40
      5  1e22		       5a		      .byte.b	BZ + 40
      6  1e23		       50		      .byte.b	BZ + 30
      7  1e24		       28		      .byte.b	BZ + -10
      8  1e25		       14		      .byte.b	BZ + -30
      9  1e26		       32		      .byte.b	BZ
     10  1e27		       32		      .byte.b	BZ
      0  1e28					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      1  1e28		       14		      .byte.b	BZ + -30
      2  1e29		       28		      .byte.b	BZ + -10
      3  1e2a		       50		      .byte.b	BZ + 30
      4  1e2b		       5a		      .byte.b	BZ + 40
      5  1e2c		       5a		      .byte.b	BZ + 40
      6  1e2d		       50		      .byte.b	BZ + 30
      7  1e2e		       28		      .byte.b	BZ + -10
      8  1e2f		       14		      .byte.b	BZ + -30
      9  1e30		       32		      .byte.b	BZ
     10  1e31		       32		      .byte.b	BZ
      0  1e32					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      1  1e32		       14		      .byte.b	BZ + -30
      2  1e33		       28		      .byte.b	BZ + -10
      3  1e34		       46		      .byte.b	BZ + 20
      4  1e35		       50		      .byte.b	BZ + 30
      5  1e36		       50		      .byte.b	BZ + 30
      6  1e37		       46		      .byte.b	BZ + 20
      7  1e38		       28		      .byte.b	BZ + -10
      8  1e39		       14		      .byte.b	BZ + -30
      9  1e3a		       32		      .byte.b	BZ
     10  1e3b		       32		      .byte.b	BZ
      0  1e3c					      PVAL	-30, -20, -10, 0, 0, -10, -20, -30
      1  1e3c		       14		      .byte.b	BZ + -30
      2  1e3d		       1e		      .byte.b	BZ + -20
      3  1e3e		       28		      .byte.b	BZ + -10
      4  1e3f		       32		      .byte.b	BZ + 0
      5  1e40		       32		      .byte.b	BZ + 0
      6  1e41		       28		      .byte.b	BZ + -10
      7  1e42		       1e		      .byte.b	BZ + -20
      8  1e43		       14		      .byte.b	BZ + -30
      9  1e44		       32		      .byte.b	BZ
     10  1e45		       32		      .byte.b	BZ
      0  1e46					      PVAL	-50, -40, -30, -20,- 20, -30, -40, -50
      1  1e46		       00		      .byte.b	BZ + -50
      2  1e47		       0a		      .byte.b	BZ + -40
      3  1e48		       14		      .byte.b	BZ + -30
      4  1e49		       1e		      .byte.b	BZ + -20
      5  1e4a		       1e		      .byte.b	BZ + - 20
      6  1e4b		       14		      .byte.b	BZ + -30
      7  1e4c		       0a		      .byte.b	BZ + -40
      8  1e4d		       00		      .byte.b	BZ + -50
      9  1e4e		       32		      .byte.b	BZ
     10  1e4f		       32		      .byte.b	BZ
    176  1e50
    177  1e50
      0  1e50					      CHECK_BANK_SIZE	"BANK_EVAL"
      1  1e50		       02 50	   .TEMP      =	* - _BANK_START
 BANK_EVAL (1K) SIZE =  $250 , FREE= $1b0
      2  1e50					      ECHO	"BANK_EVAL", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1e50				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1e50				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_EVAL", " size=", * - ORIGIN
      5  1e50				  -	      ERR
      6  1e50					      ENDIF
    179  1e50
    180  1e50							;---------------------------------------------------------------------------------------------------
    181  1e50							; EOF
------- FILE ./chess.asm
------- FILE BANK_StateMachine@1#1.asm LEVEL 2 PASS 4
      0  1e50					      include	"BANK_StateMachine@1#1.asm"
      0  1e50					      SLOT	1
      1  1e50				  -	      IF	(1 < 0) || (1 > 3)
      2  1e50				  -	      ECHO	"Illegal bank address/segment location", 1
      3  1e50				  -	      ERR
      4  1e50					      ENDIF
      5  1e50				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  1e50				   _BANK_SLOT SET	1 * 64
      0  1e50					      NEWBANK	STATEMACHINE
      1  2360 ????				      SEG	STATEMACHINE
      2  2000					      ORG	_ORIGIN
      3  2000					      RORG	_BANK_ADDRESS_ORIGIN
      4  2000				   _BANK_START SET	*
      5  2000				   STATEMACHINE_START SET	*
      6  2000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2000				   STATEMACHINE SET	_BANK_SLOT + _CURRENT_BANK
      8  2000				   _ORIGIN    SET	_ORIGIN + 1024
      3  2000
      4  2000
      5  2000							; Banks holding data (ply 0 doubles as WHITE, and ply 1 as BLACK)
      6  2000
      7  2000
      8  2000		       00 10	   CURSOR_MOVE_SPEED =	16
      9  2000		       00 14	   CAP_SPEED  =	20
     10  2000		       00 28	   HOLD_DELAY =	40
     11  2000
     12  2000
     13  2000							;---------------------------------------------------------------------------------------------------
     14  2000
     15  2000
     16  2000							;---------------------------------------------------------------------------------------------------
     17  2000
      0  2000					      DEF	aiStartMoveGen
      1  2000				   SLOT_aiStartMoveGen SET	_BANK_SLOT
      2  2000				   BANK_aiStartMoveGen SET	SLOT_aiStartMoveGen + _CURRENT_BANK
      3  2000				   aiStartMoveGen
      4  2000				   TEMPORARY_VAR SET	Overlay
      5  2000				   TEMPORARY_OFFSET SET	0
      6  2000				   VAR_BOUNDARY_aiStartMoveGen SET	TEMPORARY_OFFSET
      7  2000				   FUNCTION_NAME SET	aiStartMoveGen
     19  2000					      SUBROUTINE
     20  2000
      0  2000					      REFER	AiStateMachine
      1  2000				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2000				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2000					      ENDIF
      0  2000					      VEND	aiStartMoveGen
      1  2000				  -	      IFNCONST	aiStartMoveGen
      2  2000				  -	      ECHO	"Incorrect VEND label", aiStartMoveGen
      3  2000				  -	      ERR
      4  2000					      ENDIF
      5  2000		       00 a2	   VAREND_aiStartMoveGen =	TEMPORARY_VAR
     23  2000
     24  2000							; To assist with castling, generate the moves for the opponent, giving us effectively
     25  2000							; a list of squares that are being attacked. The castling can't happen if the king is
     26  2000							; in check or if the squares it would have to move over are in check
     27  2000
     28  2000							; we don't need to worry about this if K has moved, or relevant R has moved or if
     29  2000							; the squares between are occupied. We can tell THAT by examining the movelist to see
     30  2000							; if there are K-moves marked "FLAG_CASTLE" - and the relevant squares
     31  2000
     32  2000							;inc currentPly
     33  2000							;jsr InitialiseMoveGeneration
     34  2000
      0  2000					      PHASE	AI_StepMoveGen
      1  2000		       a9 0c		      lda	#AI_StepMoveGen
      2  2002		       85 8c		      sta	aiState
     36  2004		       60		      rts
     37  2005
     38  2005
     39  2005							;---------------------------------------------------------------------------------------------------
     40  2005
      0  2005					      DEF	aiInCheckBackup
      1  2005				   SLOT_aiInCheckBackup SET	_BANK_SLOT
      2  2005				   BANK_aiInCheckBackup SET	SLOT_aiInCheckBackup + _CURRENT_BANK
      3  2005				   aiInCheckBackup
      4  2005				   TEMPORARY_VAR SET	Overlay
      5  2005				   TEMPORARY_OFFSET SET	0
      6  2005				   VAR_BOUNDARY_aiInCheckBackup SET	TEMPORARY_OFFSET
      7  2005				   FUNCTION_NAME SET	aiInCheckBackup
     42  2005					      SUBROUTINE
     43  2005
      0  2005					      REFER	AiStateMachine
      1  2005				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2005				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2005					      ENDIF
      0  2005					      VEND	aiInCheckBackup
      1  2005				  -	      IFNCONST	aiInCheckBackup
      2  2005				  -	      ECHO	"Incorrect VEND label", aiInCheckBackup
      3  2005				  -	      ERR
      4  2005					      ENDIF
      5  2005		       00 a2	   VAREND_aiInCheckBackup =	TEMPORARY_VAR
     46  2005
     47  2005							; We're about to draw some large text on the screen
     48  2005							; Make a backup copy of all of the row bitmaps, so that we can restore once text is done
     49  2005
     50  2005		       c6 84		      dec	drawCount
     51  2007		       30 02		      bmi	.exit	; done all rows
     52  2009		       a4 84		      ldy	drawCount
     53  200b				  -	      IF	0
     54  200b				  -	      jmp	SAFE_BackupBitmaps
     55  200b					      ENDIF
     56  200b
      0  200b				   .exit      PHASE	AI_InCheckDelay
      1  200b		       a9 1e		      lda	#AI_InCheckDelay
      2  200d		       85 8c		      sta	aiState
     58  200f		       60		      rts
     59  2010
     60  2010
     61  2010							;---------------------------------------------------------------------------------------------------
     62  2010
      0  2010					      DEF	aiInCheckDelay
      1  2010				   SLOT_aiInCheckDelay SET	_BANK_SLOT
      2  2010				   BANK_aiInCheckDelay SET	SLOT_aiInCheckDelay + _CURRENT_BANK
      3  2010				   aiInCheckDelay
      4  2010				   TEMPORARY_VAR SET	Overlay
      5  2010				   TEMPORARY_OFFSET SET	0
      6  2010				   VAR_BOUNDARY_aiInCheckDelay SET	TEMPORARY_OFFSET
      7  2010				   FUNCTION_NAME SET	aiInCheckDelay
     64  2010					      SUBROUTINE
     65  2010
      0  2010					      REFER	AiStateMachine
      1  2010				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2010				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2010					      ENDIF
      0  2010					      VEND	aiInCheckDelay
      1  2010				  -	      IFNCONST	aiInCheckDelay
      2  2010				  -	      ECHO	"Incorrect VEND label", aiInCheckDelay
      3  2010				  -	      ERR
      4  2010					      ENDIF
      5  2010		       00 a2	   VAREND_aiInCheckDelay =	TEMPORARY_VAR
     68  2010
     69  2010		       c6 89		      dec	mdelay
     70  2012		       d0 08		      bne	.exit
     71  2014
     72  2014		       a9 00		      lda	#0
     73  2016		       85 49		      sta	COLUBK
     74  2018
      0  2018					      PHASE	AI_BeginSelectMovePhase
      1  2018		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  201a		       85 8c		      sta	aiState
     76  201c		       60	   .exit      rts
     77  201d
     78  201d
     79  201d							;---------------------------------------------------------------------------------------------------
     80  201d
      0  201d					      DEF	aiBeginSelectMovePhase
      1  201d				   SLOT_aiBeginSelectMovePhase SET	_BANK_SLOT
      2  201d				   BANK_aiBeginSelectMovePhase SET	SLOT_aiBeginSelectMovePhase + _CURRENT_BANK
      3  201d				   aiBeginSelectMovePhase
      4  201d				   TEMPORARY_VAR SET	Overlay
      5  201d				   TEMPORARY_OFFSET SET	0
      6  201d				   VAR_BOUNDARY_aiBeginSelectMovePhase SET	TEMPORARY_OFFSET
      7  201d				   FUNCTION_NAME SET	aiBeginSelectMovePhase
     82  201d					      SUBROUTINE
     83  201d
      0  201d					      REFER	AiStateMachine
      1  201d				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  201d				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  201d					      ENDIF
      0  201d					      VEND	aiBeginSelectMovePhase
      1  201d				  -	      IFNCONST	aiBeginSelectMovePhase
      2  201d				  -	      ECHO	"Incorrect VEND label", aiBeginSelectMovePhase
      3  201d				  -	      ERR
      4  201d					      ENDIF
      5  201d		       00 a2	   VAREND_aiBeginSelectMovePhase =	TEMPORARY_VAR
     86  201d
     87  201d		       a9 02		      lda	#$2
     88  201f		       85 46		      sta	COLUP0
     89  2021		       a2 04		      ldx	#%100
     90  2023		       86 4a		      stx	CTRLPF	; under
     91  2025
     92  2025		       a9 00		      lda	#0
     93  2027		       85 89		      sta	mdelay	;?
     94  2029		       85 8f		      sta	aiFlashPhase	; odd/even for flashing pieces
     95  202b
     96  202b		       a9 28		      lda	#CAP_SPEED*2
     97  202d		       85 8d		      sta	aiFlashDelay
     98  202f
     99  202f		       a9 ff		      lda	#-1
    100  2031		       85 85		      sta	fromX12
    101  2033		       85 86		      sta	toX12
    102  2035
    103  2035							;lsr randomness
    104  2035
      0  2035					      PHASE	AI_FlashComputerMove
      1  2035		       a9 00		      lda	#AI_FlashComputerMove
      2  2037		       85 8c		      sta	aiState
    106  2039		       60		      rts
    107  203a
    108  203a
    109  203a							;---------------------------------------------------------------------------------------------------
    110  203a
      0  203a					      DEF	aiFlashComputerMove
      1  203a				   SLOT_aiFlashComputerMove SET	_BANK_SLOT
      2  203a				   BANK_aiFlashComputerMove SET	SLOT_aiFlashComputerMove + _CURRENT_BANK
      3  203a				   aiFlashComputerMove
      4  203a				   TEMPORARY_VAR SET	Overlay
      5  203a				   TEMPORARY_OFFSET SET	0
      6  203a				   VAR_BOUNDARY_aiFlashComputerMove SET	TEMPORARY_OFFSET
      7  203a				   FUNCTION_NAME SET	aiFlashComputerMove
    112  203a					      SUBROUTINE
    113  203a
    114  203a		       a5 80		      lda	squareToDraw
    115  203c		       30 1f		      bmi	.initial	; startup - no computer move to show
    116  203e
    117  203e							; "squareToDraw" is the piece that should flash while human waits
    118  203e
    119  203e		       ad 80 02 	      lda	SWCHA
    120  2041		       29 f0		      and	#$F0
    121  2043		       c9 f0		      cmp	#$F0
    122  2045		       f0 08		      beq	.nodir
    123  2047
    124  2047		       a9 01		      lda	#1
    125  2049		       85 8d		      sta	aiFlashDelay
    126  204b		       25 8f		      and	aiFlashPhase
    127  204d		       f0 0e		      beq	.initial
    128  204f
    129  204f		       c6 8d	   .nodir     dec	aiFlashDelay
    130  2051		       d0 0e		      bne	.exit	; don't flash
    131  2053		       a9 28		      lda	#CAP_SPEED*2
    132  2055		       85 8d		      sta	aiFlashDelay
    133  2057
    134  2057		       e6 8f		      inc	aiFlashPhase
    135  2059
    136  2059		       20 98 f0 	      jsr	CopySinglePiece	;@0
    137  205c		       60		      rts
    138  205d
      0  205d				   .initial   PHASE	AI_SelectStartSquare
      1  205d		       a9 02		      lda	#AI_SelectStartSquare
      2  205f		       85 8c		      sta	aiState
    140  2061
    141  2061		       60	   .exit      rts
    142  2062
    143  2062
    144  2062							;---------------------------------------------------------------------------------------------------
    145  2062
      0  2062					      DEF	aiSelectStartSquare
      1  2062				   SLOT_aiSelectStartSquare SET	_BANK_SLOT
      2  2062				   BANK_aiSelectStartSquare SET	SLOT_aiSelectStartSquare + _CURRENT_BANK
      3  2062				   aiSelectStartSquare
      4  2062				   TEMPORARY_VAR SET	Overlay
      5  2062				   TEMPORARY_OFFSET SET	0
      6  2062				   VAR_BOUNDARY_aiSelectStartSquare SET	TEMPORARY_OFFSET
      7  2062				   FUNCTION_NAME SET	aiSelectStartSquare
    147  2062					      SUBROUTINE
    148  2062
      0  2062					      REFER	AiStateMachine
      1  2062				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2062				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2062					      ENDIF
      0  2062					      VEND	aiSelectStartSquare
      1  2062				  -	      IFNCONST	aiSelectStartSquare
      2  2062				  -	      ECHO	"Incorrect VEND label", aiSelectStartSquare
      3  2062				  -	      ERR
      4  2062					      ENDIF
      5  2062		       00 a2	   VAREND_aiSelectStartSquare =	TEMPORARY_VAR
    151  2062
    152  2062		       a2 01		      ldx	#1
    153  2064		       e0 00	   kk	      cpx	#0
    154  2066							;bne kk
    155  2066
      0  2066					      NEXT_RANDOM
      1  2066		       a5 81		      lda	rnd
      2  2068		       4a		      lsr
      3  2069		       90 02		      bcc	.skipEOR
      4  206b		       49 fe		      eor	#RND_EOR_VAL
      5  206d		       85 81	   .skipEOR   sta	rnd
    157  206f
    158  206f		       20 ca f5 	      jsr	moveCursor
    159  2072							;jsr IsValidMoveFromSquare;@2
    160  2072
    161  2072		       c6 8a		      dec	ccur	; pulse colour for valid squares
    162  2074		       20 95 f4 	      jsr	setCursorColours
    163  2077
    164  2077		       98		      tya
    165  2078		       05 4c		      ora	INPT4
    166  207a		       30 00		      bmi	.exit	; illegal square or no button press
    167  207c
    168  207c							;PHASE AI_StartSquareSelected
    169  207c
    170  207c		       60	   .exit      rts
    171  207d
    172  207d							;---------------------------------------------------------------------------------------------------
    173  207d
      0  207d					      DEF	setCursorPriority
      1  207d				   SLOT_setCursorPriority SET	_BANK_SLOT
      2  207d				   BANK_setCursorPriority SET	SLOT_setCursorPriority + _CURRENT_BANK
      3  207d				   setCursorPriority
      4  207d				   TEMPORARY_VAR SET	Overlay
      5  207d				   TEMPORARY_OFFSET SET	0
      6  207d				   VAR_BOUNDARY_setCursorPriority SET	TEMPORARY_OFFSET
      7  207d				   FUNCTION_NAME SET	setCursorPriority
    175  207d					      SUBROUTINE
    176  207d
      0  207d					      REFER	moveCursor
      1  207d					      IF	VAREND_moveCursor > TEMPORARY_VAR
      2  207d				   TEMPORARY_VAR SET	VAREND_moveCursor
      3  207d					      ENDIF
      0  207d					      VEND	setCursorPriority
      1  207d				  -	      IFNCONST	setCursorPriority
      2  207d				  -	      ECHO	"Incorrect VEND label", setCursorPriority
      3  207d				  -	      ERR
      4  207d					      ENDIF
      5  207d		       00 a3	   VAREND_setCursorPriority =	TEMPORARY_VAR
    179  207d
    180  207d		       98		      tya
    181  207e		       48		      pha
    182  207f
    183  207f		       a2 04		      ldx	#%100
    184  2081
    185  2081		       a4 88		      ldy	cursorX12
    186  2083		       30 0b		      bmi	.under
    187  2085
    188  2085		       a9 cf		      lda	#RAMBANK_BOARD
    189  2087		       85 3e		      sta	SET_BANK_RAM	;@3
    190  2089		       b9 79 fc 	      lda	Board,y
    191  208c		       d0 02		      bne	.under
    192  208e		       a2 00		      ldx	#0
    193  2090		       86 4a	   .under     stx	CTRLPF	; UNDER
    194  2092
    195  2092		       68		      pla
    196  2093		       a8		      tay
    197  2094		       60		      rts
    198  2095
    199  2095							;---------------------------------------------------------------------------------------------------
    200  2095
      0  2095					      DEF	setCursorColours
      1  2095				   SLOT_setCursorColours SET	_BANK_SLOT
      2  2095				   BANK_setCursorColours SET	SLOT_setCursorColours + _CURRENT_BANK
      3  2095				   setCursorColours
      4  2095				   TEMPORARY_VAR SET	Overlay
      5  2095				   TEMPORARY_OFFSET SET	0
      6  2095				   VAR_BOUNDARY_setCursorColours SET	TEMPORARY_OFFSET
      7  2095				   FUNCTION_NAME SET	setCursorColours
    202  2095					      SUBROUTINE
    203  2095
      0  2095					      REFER	aiSelectStartSquare
      1  2095				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  2095				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  2095					      ENDIF
      0  2095					      REFER	aiDrawMoves
      1  2095				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  2095				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  2095					      ENDIF
      0  2095					      REFER	aiUnDrawTargetSquares
      1  2095				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  2095				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  2095					      ENDIF
      0  2095					      REFER	aiShowMoveCaptures
      1  2095				  -	      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  2095				  -TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  2095					      ENDIF
      0  2095					      REFER	aiSlowFlash
      1  2095				  -	      IF	VAREND_aiSlowFlash > TEMPORARY_VAR
      2  2095				  -TEMPORARY_VAR SET	VAREND_aiSlowFlash
      3  2095					      ENDIF
      0  2095					      REFER	aiSelectDestinationSquare
      1  2095				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  2095				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  2095					      ENDIF
      0  2095					      VEND	setCursorColours
      1  2095				  -	      IFNCONST	setCursorColours
      2  2095				  -	      ECHO	"Incorrect VEND label", setCursorColours
      3  2095				  -	      ERR
      4  2095					      ENDIF
      5  2095		       00 a2	   VAREND_setCursorColours =	TEMPORARY_VAR
    211  2095
    212  2095							; pass y=-1 if move is NOT in the movelist
    213  2095							; preserve y
    214  2095
    215  2095		       a9 40		      lda	#$40
    216  2097
    217  2097		       c0 ff		      cpy	#-1
    218  2099		       f0 0a		      beq	.writeCursorCol	; NOT in the movelist
    219  209b
    220  209b		       a5 8a		      lda	ccur
    221  209d		       4a		      lsr
    222  209e		       4a		      lsr
    223  209f		       4a		      lsr
    224  20a0		       29 03		      and	#3
    225  20a2		       18		      clc
    226  20a3		       69 d0		      adc	#$D0	;COLOUR_LINE_1
    227  20a5
    228  20a5		       85 46	   .writeCursorCol sta	COLUP0
    229  20a7		       60		      rts
    230  20a8
    231  20a8
    232  20a8							;---------------------------------------------------------------------------------------------------
    233  20a8
    234  20a8							;	    RLDU RLD  RL U RL	R DU R D  R  U R     LDU  LD   L U  L	  DU   D     U
    235  20a8							;	    0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    236  20a8
      0  20a8					      ALLOCATE	JoyCombined, 16
      0  20a8					      OPTIONAL_PAGEBREAK	"Table", 16
     12  20a8					      LIST	ON
      0  20a8					      DEF	JoyCombined
      1  20a8				   SLOT_JoyCombined SET	_BANK_SLOT
      2  20a8				   BANK_JoyCombined SET	SLOT_JoyCombined + _CURRENT_BANK
      3  20a8				   JoyCombined
      4  20a8				   TEMPORARY_VAR SET	Overlay
      5  20a8				   TEMPORARY_OFFSET SET	0
      6  20a8				   VAR_BOUNDARY_JoyCombined SET	TEMPORARY_OFFSET
      7  20a8				   FUNCTION_NAME SET	JoyCombined
    238  20a8		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, -1, 0
    239  20b8
      0  20b8					      ALLOCATE	JoyMoveCursor, 16
      0  20b8					      OPTIONAL_PAGEBREAK	"Table", 16
     12  20b8					      LIST	ON
      0  20b8					      DEF	JoyMoveCursor
      1  20b8				   SLOT_JoyMoveCursor SET	_BANK_SLOT
      2  20b8				   BANK_JoyMoveCursor SET	SLOT_JoyMoveCursor + _CURRENT_BANK
      3  20b8				   JoyMoveCursor
      4  20b8				   TEMPORARY_VAR SET	Overlay
      5  20b8				   TEMPORARY_OFFSET SET	0
      6  20b8				   VAR_BOUNDARY_JoyMoveCursor SET	TEMPORARY_OFFSET
      7  20b8				   FUNCTION_NAME SET	JoyMoveCursor
    241  20b8		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, -9, 11, 1, 0, -11, 9, -1, 0, -10, 10, 0
    242  20c8
    243  20c8
    244  20c8							;---------------------------------------------------------------------------------------------------
    245  20c8
      0  20c8					      DEF	aiStartSquareSelected
      1  20c8				   SLOT_aiStartSquareSelected SET	_BANK_SLOT
      2  20c8				   BANK_aiStartSquareSelected SET	SLOT_aiStartSquareSelected + _CURRENT_BANK
      3  20c8				   aiStartSquareSelected
      4  20c8				   TEMPORARY_VAR SET	Overlay
      5  20c8				   TEMPORARY_OFFSET SET	0
      6  20c8				   VAR_BOUNDARY_aiStartSquareSelected SET	TEMPORARY_OFFSET
      7  20c8				   FUNCTION_NAME SET	aiStartSquareSelected
    247  20c8					      SUBROUTINE
    248  20c8
      0  20c8					      REFER	AiStateMachine
      1  20c8				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  20c8				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  20c8					      ENDIF
      0  20c8					      VEND	aiStartSquareSelected
      1  20c8				  -	      IFNCONST	aiStartSquareSelected
      2  20c8				  -	      ECHO	"Incorrect VEND label", aiStartSquareSelected
      3  20c8				  -	      ERR
      4  20c8					      ENDIF
      5  20c8		       00 a2	   VAREND_aiStartSquareSelected =	TEMPORARY_VAR
    251  20c8
    252  20c8
    253  20c8							; Mark all the valid moves for the selected piece on the board
    254  20c8							; and then start pulsing the piece
    255  20c8							; AND start choosing for selection of TO square
    256  20c8
    257  20c8							; Iterate the movelist and for all from squares which = drawPieceNumber
    258  20c8							; then draw a BLANK at that square
    259  20c8							; do 1 by one, when none found then increment state
    260  20c8
    261  20c8		       a5 88		      lda	cursorX12
    262  20ca		       85 80		      sta	squareToDraw
    263  20cc
    264  20cc		       a9 0a		      lda	#10
    265  20ce		       85 8d		      sta	aiFlashDelay
    266  20d0
    267  20d0		       a9 00		      lda	#0
    268  20d2		       85 86		      sta	toX12	;aiToSquareX12
    269  20d4		       85 8f		      sta	aiFlashPhase	; for debounce exit timing
    270  20d6
    271  20d6		       a9 ff		      lda	#-1
    272  20d8		       85 8e		      sta	aiMoveIndex
    273  20da
    274  20da		       a9 28		      lda	#HOLD_DELAY
    275  20dc		       85 89		      sta	mdelay	; hold-down delay before moves are shown
    276  20de
      0  20de					      PHASE	AI_DrawMoves
      1  20de		       a9 04		      lda	#AI_DrawMoves
      2  20e0		       85 8c		      sta	aiState
    278  20e2		       60		      rts
    279  20e3
    280  20e3
    281  20e3							;---------------------------------------------------------------------------------------------------
    282  20e3
      0  20e3					      DEF	aiDrawMoves
      1  20e3				   SLOT_aiDrawMoves SET	_BANK_SLOT
      2  20e3				   BANK_aiDrawMoves SET	SLOT_aiDrawMoves + _CURRENT_BANK
      3  20e3				   aiDrawMoves
      4  20e3				   TEMPORARY_VAR SET	Overlay
      5  20e3				   TEMPORARY_OFFSET SET	0
      6  20e3				   VAR_BOUNDARY_aiDrawMoves SET	TEMPORARY_OFFSET
      7  20e3				   FUNCTION_NAME SET	aiDrawMoves
    284  20e3					      SUBROUTINE
    285  20e3
      0  20e3					      REFER	AiStateMachine
      1  20e3				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  20e3				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  20e3					      ENDIF
      0  20e3					      VEND	aiDrawMoves
      1  20e3				  -	      IFNCONST	aiDrawMoves
      2  20e3				  -	      ECHO	"Incorrect VEND label", aiDrawMoves
      3  20e3				  -	      ERR
      4  20e3					      ENDIF
      5  20e3		       00 a2	   VAREND_aiDrawMoves =	TEMPORARY_VAR
    288  20e3
    289  20e3		       c6 8a		      dec	ccur
    290  20e5		       20 95 f4 	      jsr	setCursorColours
    291  20e8
    292  20e8		       c6 89		      dec	mdelay
    293  20ea		       d0 21		      bne	.exit
    294  20ec		       a9 01		      lda	#1	; larger number will slow the draw of available moves
    295  20ee		       85 89		      sta	mdelay	; once triggered, runs always
    296  20f0
    297  20f0		       a5 8e		      lda	aiMoveIndex
    298  20f2		       10 05		      bpl	.valid
    299  20f4		       20 c2 f4 	      jsr	SAFE_getMoveIndex
    300  20f7		       85 8e		      sta	aiMoveIndex
    301  20f9				   .valid
    302  20f9
    303  20f9		       20 1a f5 	      jsr	SAFE_showMoveOptions	; draw potential moves one at a time
    304  20fc		       a5 8e		      lda	aiMoveIndex
    305  20fe		       10 19		      bpl	.unsure	; still drawing in this phase
    306  2100
    307  2100		       a9 14		      lda	#CAP_SPEED
    308  2102		       85 89		      sta	mdelay
    309  2104
    310  2104		       a9 00		      lda	#0
    311  2106		       85 8f		      sta	aiFlashPhase	; controls odd/even exit of flashing
    312  2108
      0  2108					      PHASE	AI_ShowMoveCaptures
      1  2108		       a9 05		      lda	#AI_ShowMoveCaptures
      2  210a		       85 8c		      sta	aiState
    314  210c		       60		      rts
    315  210d
    316  210d				   .exit
    317  210d
    318  210d							; Initial piece selection has happened, but the button hasn't been released yet
    319  210d							; AND we're still in the waiting phase to see if the button was held long enough for move show
    320  210d
    321  210d		       a5 4c		      lda	INPT4
    322  210f		       10 08		      bpl	.unsure	; button still pressed, so still unsure what to do
    323  2111
    324  2111							; Aha! Button released, so we know the selected piece and can start flashing it
    325  2111							; and allowing movement of the selector to a destination square...
    326  2111
    327  2111		       a9 18		      lda	#6*4
    328  2113		       85 8a		      sta	ccur	; bright green square for selection
    329  2115
      0  2115					      PHASE	AI_SelectDestinationSquare
      1  2115		       a9 08		      lda	#AI_SelectDestinationSquare
      2  2117		       85 8c		      sta	aiState
    331  2119
    332  2119		       60	   .unsure    rts
    333  211a
    334  211a
    335  211a							;---------------------------------------------------------------------------------------------------
    336  211a
      0  211a					      DEF	SAFE_showMoveOptions
      1  211a				   SLOT_SAFE_showMoveOptions SET	_BANK_SLOT
      2  211a				   BANK_SAFE_showMoveOptions SET	SLOT_SAFE_showMoveOptions + _CURRENT_BANK
      3  211a				   SAFE_showMoveOptions
      4  211a				   TEMPORARY_VAR SET	Overlay
      5  211a				   TEMPORARY_OFFSET SET	0
      6  211a				   VAR_BOUNDARY_SAFE_showMoveOptions SET	TEMPORARY_OFFSET
      7  211a				   FUNCTION_NAME SET	SAFE_showMoveOptions
    338  211a					      SUBROUTINE
    339  211a
      0  211a					      REFER	aiDrawMoves
      1  211a				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  211a				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  211a					      ENDIF
      0  211a					      REFER	aiUnDrawTargetSquares
      1  211a				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  211a				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  211a					      ENDIF
      0  211a					      VAR	__saveIdx, 1
      1  211a		       00 a2	   __saveIdx  =	TEMPORARY_VAR
      2  211a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  211a
      4  211a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  211a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  211a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  211a					      ENDIF
      8  211a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  211a				  -	      ECHO	"Temporary Variable", __saveIdx, "overflow!"
     10  211a				  -	      ERR
     11  211a					      ENDIF
     12  211a					      LIST	ON
      0  211a					      VAR	__piece, 1
      1  211a		       00 a3	   __piece    =	TEMPORARY_VAR
      2  211a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  211a
      4  211a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  211a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  211a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  211a					      ENDIF
      8  211a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  211a				  -	      ECHO	"Temporary Variable", __piece, "overflow!"
     10  211a				  -	      ERR
     11  211a					      ENDIF
     12  211a					      LIST	ON
      0  211a					      VEND	SAFE_showMoveOptions
      1  211a				  -	      IFNCONST	SAFE_showMoveOptions
      2  211a				  -	      ECHO	"Incorrect VEND label", SAFE_showMoveOptions
      3  211a				  -	      ERR
      4  211a					      ENDIF
      5  211a		       00 a4	   VAREND_SAFE_showMoveOptions =	TEMPORARY_VAR
    345  211a
    346  211a							; place a marker on the board for any square matching the piece
    347  211a							; EXCEPT for squares which are occupied (we'll flash those later)
    348  211a
    349  211a		       a6 8e	   .next      ldx	aiMoveIndex
    350  211c		       86 a2		      stx	__saveIdx
    351  211e		       30 40		      bmi	.skip
    352  2120
    353  2120		       ad 84 02 	      lda	INTIM
    354  2123		       c9 2b		      cmp	#2+SPEEDOF_COPYSINGLEPIECE
    355  2125		       90 39		      bcc	.skip
    356  2127
    357  2127		       c6 8e		      dec	aiMoveIndex
    358  2129
    359  2129		       20 4b f5 	      jsr	GetP_MoveFrom
    360  212c		       c5 85		      cmp	fromX12
    361  212e		       d0 ea		      bne	.next
    362  2130
    363  2130		       20 57 f5 	      jsr	GetP_MoveTo
    364  2133		       85 80		      sta	squareToDraw
    365  2135
    366  2135		       20 6f f5 	      jsr	GetP_MovePiece
    367  2138		       85 a3		      sta	__piece
    368  213a
    369  213a							; If it's a pawn promote (duplicate "to" AND piece different (TODO) then skip others)
    370  213a							; TODO this could/will fail on sorted lists. MMh.
    371  213a
    372  213a		       ca	   .sk	      dex
    373  213b		       30 16		      bmi	.prom
    374  213d		       20 57 f5 	      jsr	GetP_MoveTo
    375  2140		       c5 80		      cmp	squareToDraw
    376  2142		       d0 0f		      bne	.prom
    377  2144		       20 6f f5 	      jsr	GetP_MovePiece
    378  2147		       45 a3		      eor	__piece
    379  2149		       29 0f		      and	#PIECE_MASK
    380  214b		       f0 06		      beq	.prom	; same piece type so not a promote
    381  214d
    382  214d		       c6 8e		      dec	aiMoveIndex
    383  214f		       c6 8e		      dec	aiMoveIndex
    384  2151		       c6 8e		      dec	aiMoveIndex
    385  2153				   .prom
    386  2153
    387  2153		       a4 80		      ldy	squareToDraw
    388  2155		       20 14 f6 	      jsr	GetBoard
    389  2158		       29 0f		      and	#PIECE_MASK
    390  215a		       d0 be		      bne	.next	; don't draw dots on captures - they are flashed later
    391  215c
    392  215c
    393  215c							;lda INTIM
    394  215c							;cmp #SPEEDOF_COPYSINGLEPIECE
    395  215c							;bcc .skip
    396  215c
    397  215c							;lda aiMoveIndex
    398  215c							;sta __saveIdx
    399  215c
    400  215c		       20 43 f5 	      jsr	markerDraw
    401  215f		       60		      rts
    402  2160
    403  2160		       a5 a2	   .skip      lda	__saveIdx
    404  2162		       85 8e		      sta	aiMoveIndex
    405  2164		       60		      rts
    406  2165
    407  2165
    408  2165							;---------------------------------------------------------------------------------------------------
    409  2165
      0  2165					      DEF	aiUnDrawTargetSquares
      1  2165				   SLOT_aiUnDrawTargetSquares SET	_BANK_SLOT
      2  2165				   BANK_aiUnDrawTargetSquares SET	SLOT_aiUnDrawTargetSquares + _CURRENT_BANK
      3  2165				   aiUnDrawTargetSquares
      4  2165				   TEMPORARY_VAR SET	Overlay
      5  2165				   TEMPORARY_OFFSET SET	0
      6  2165				   VAR_BOUNDARY_aiUnDrawTargetSquares SET	TEMPORARY_OFFSET
      7  2165				   FUNCTION_NAME SET	aiUnDrawTargetSquares
    411  2165					      SUBROUTINE
    412  2165
      0  2165					      REFER	AiStateMachine
      1  2165				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2165				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2165					      ENDIF
      0  2165					      VEND	aiUnDrawTargetSquares
      1  2165				  -	      IFNCONST	aiUnDrawTargetSquares
      2  2165				  -	      ECHO	"Incorrect VEND label", aiUnDrawTargetSquares
      3  2165				  -	      ERR
      4  2165					      ENDIF
      5  2165		       00 a2	   VAREND_aiUnDrawTargetSquares =	TEMPORARY_VAR
    415  2165
    416  2165
    417  2165		       c6 8a		      dec	ccur
    418  2167		       20 95 f4 	      jsr	setCursorColours
    419  216a
    420  216a		       c6 89		      dec	mdelay
    421  216c		       d0 18		      bne	.exit
    422  216e		       a9 01		      lda	#1
    423  2170		       85 89		      sta	mdelay	; once triggered, runs always
    424  2172
    425  2172		       a5 8e		      lda	aiMoveIndex
    426  2174		       10 05		      bpl	.valid
    427  2176		       20 c2 f4 	      jsr	SAFE_getMoveIndex
    428  2179		       85 8e		      sta	aiMoveIndex
    429  217b				   .valid
    430  217b
    431  217b		       20 1a f5 	      jsr	SAFE_showMoveOptions	; draw potential moves one at a time
    432  217e		       a5 8e		      lda	aiMoveIndex
    433  2180		       10 04		      bpl	.exit	; still drawing in this phase
    434  2182
      0  2182					      PHASE	AI_SelectStartSquare
      1  2182		       a9 02		      lda	#AI_SelectStartSquare
      2  2184		       85 8c		      sta	aiState
    436  2186
    437  2186		       60	   .exit      rts
    438  2187
    439  2187
    440  2187							;---------------------------------------------------------------------------------------------------
    441  2187
    442  2187
      0  2187					      DEF	aiShowMoveCaptures
      1  2187				   SLOT_aiShowMoveCaptures SET	_BANK_SLOT
      2  2187				   BANK_aiShowMoveCaptures SET	SLOT_aiShowMoveCaptures + _CURRENT_BANK
      3  2187				   aiShowMoveCaptures
      4  2187				   TEMPORARY_VAR SET	Overlay
      5  2187				   TEMPORARY_OFFSET SET	0
      6  2187				   VAR_BOUNDARY_aiShowMoveCaptures SET	TEMPORARY_OFFSET
      7  2187				   FUNCTION_NAME SET	aiShowMoveCaptures
    444  2187					      SUBROUTINE
    445  2187
      0  2187					      REFER	AiStateMachine
      1  2187				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2187				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2187					      ENDIF
      0  2187					      VEND	aiShowMoveCaptures
      1  2187				  -	      IFNCONST	aiShowMoveCaptures
      2  2187				  -	      ECHO	"Incorrect VEND label", aiShowMoveCaptures
      3  2187				  -	      ERR
      4  2187					      ENDIF
      5  2187		       00 a2	   VAREND_aiShowMoveCaptures =	TEMPORARY_VAR
    448  2187
    449  2187							; draw/undraw ALL captured pieces
    450  2187							; we should do this an even number of times so that pieces don't disappEOR
    451  2187
    452  2187		       c6 8a		      dec	ccur
    453  2189		       20 95 f4 	      jsr	setCursorColours
    454  218c
    455  218c		       c6 89		      dec	mdelay	; flash speed UNVARYING despite draw happening
    456  218e
    457  218e		       a5 8e		      lda	aiMoveIndex
    458  2190		       10 05		      bpl	.valid	; guaranteed -1 on 1st call
    459  2192		       20 c2 f4 	      jsr	SAFE_getMoveIndex
    460  2195		       85 8e		      sta	aiMoveIndex
    461  2197				   .valid
    462  2197
    463  2197		       20 00 f4 	      jsr	SAFE_showMoveCaptures
    464  219a		       a5 8e		      lda	aiMoveIndex
    465  219c		       10 06		      bpl	.exit
    466  219e
    467  219e		       e6 8f		      inc	aiFlashPhase
    468  21a0
      0  21a0					      PHASE	AI_SlowFlash
      1  21a0		       a9 06		      lda	#AI_SlowFlash
      2  21a2		       85 8c		      sta	aiState
    470  21a4
    471  21a4		       60	   .exit      rts
    472  21a5
    473  21a5
    474  21a5							;---------------------------------------------------------------------------------------------------
    475  21a5
      0  21a5					      DEF	aiSlowFlash
      1  21a5				   SLOT_aiSlowFlash SET	_BANK_SLOT
      2  21a5				   BANK_aiSlowFlash SET	SLOT_aiSlowFlash + _CURRENT_BANK
      3  21a5				   aiSlowFlash
      4  21a5				   TEMPORARY_VAR SET	Overlay
      5  21a5				   TEMPORARY_OFFSET SET	0
      6  21a5				   VAR_BOUNDARY_aiSlowFlash SET	TEMPORARY_OFFSET
      7  21a5				   FUNCTION_NAME SET	aiSlowFlash
    477  21a5					      SUBROUTINE
    478  21a5
      0  21a5					      REFER	AiStateMachine
      1  21a5				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  21a5				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  21a5					      ENDIF
      0  21a5					      VEND	aiSlowFlash
      1  21a5				  -	      IFNCONST	aiSlowFlash
      2  21a5				  -	      ECHO	"Incorrect VEND label", aiSlowFlash
      3  21a5				  -	      ERR
      4  21a5					      ENDIF
      5  21a5		       00 a2	   VAREND_aiSlowFlash =	TEMPORARY_VAR
    481  21a5
    482  21a5							; Joystick button is held down, so we're displaying the available moves
    483  21a5							; They have all been drawn, so now we "slow" flash any pieces that can be captures
    484  21a5
    485  21a5		       c6 8a		      dec	ccur
    486  21a7		       20 95 f4 	      jsr	setCursorColours
    487  21aa
    488  21aa		       a5 8f		      lda	aiFlashPhase
    489  21ac		       29 01		      and	#1
    490  21ae		       d0 04		      bne	.notEven	; only exit after even # EOR-draws
    491  21b0
    492  21b0		       a5 4c		      lda	INPT4
    493  21b2		       30 0d		      bmi	.butpress	; exit on button release
    494  21b4
    495  21b4				   .notEven
    496  21b4
    497  21b4							; Wait for delay to expire then back and flash 'em again
    498  21b4
    499  21b4		       c6 89		      dec	mdelay
    500  21b6		       10 08		      bpl	.slowWait
    501  21b8
    502  21b8		       a9 14		      lda	#CAP_SPEED
    503  21ba		       85 89		      sta	mdelay
    504  21bc
      0  21bc					      PHASE	AI_ShowMoveCaptures	; go back and rEORdraw all captures again
      1  21bc		       a9 05		      lda	#AI_ShowMoveCaptures
      2  21be		       85 8c		      sta	aiState
    506  21c0
    507  21c0		       60	   .slowWait  rts
    508  21c1
    509  21c1
    510  21c1		       a9 01	   .butpress  lda	#1
    511  21c3		       85 89		      sta	mdelay
    512  21c5
      0  21c5					      PHASE	AI_UnDrawTargetSquares
      1  21c5		       a9 07		      lda	#AI_UnDrawTargetSquares
      2  21c7		       85 8c		      sta	aiState
    514  21c9		       60		      rts
    515  21ca
    516  21ca
    517  21ca							;---------------------------------------------------------------------------------------------------
    518  21ca
      0  21ca					      DEF	moveCursor
      1  21ca				   SLOT_moveCursor SET	_BANK_SLOT
      2  21ca				   BANK_moveCursor SET	SLOT_moveCursor + _CURRENT_BANK
      3  21ca				   moveCursor
      4  21ca				   TEMPORARY_VAR SET	Overlay
      5  21ca				   TEMPORARY_OFFSET SET	0
      6  21ca				   VAR_BOUNDARY_moveCursor SET	TEMPORARY_OFFSET
      7  21ca				   FUNCTION_NAME SET	moveCursor
    520  21ca					      SUBROUTINE
    521  21ca
      0  21ca					      REFER	aiSelectStartSquare
      1  21ca				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  21ca				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  21ca					      ENDIF
      0  21ca					      REFER	aiSelectDestinationSquare
      1  21ca				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  21ca				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  21ca					      ENDIF
      0  21ca					      VAR	__newCursor, 1
      1  21ca		       00 a2	   __newCursor =	TEMPORARY_VAR
      2  21ca				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  21ca
      4  21ca				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  21ca				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  21ca				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  21ca					      ENDIF
      8  21ca				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  21ca				  -	      ECHO	"Temporary Variable", __newCursor, "overflow!"
     10  21ca				  -	      ERR
     11  21ca					      ENDIF
     12  21ca					      LIST	ON
      0  21ca					      VEND	moveCursor
      1  21ca				  -	      IFNCONST	moveCursor
      2  21ca				  -	      ECHO	"Incorrect VEND label", moveCursor
      3  21ca				  -	      ERR
      4  21ca					      ENDIF
      5  21ca		       00 a3	   VAREND_moveCursor =	TEMPORARY_VAR
    526  21ca
    527  21ca							; Part (a) move cursor around the board waiting for joystick press
    528  21ca
    529  21ca		       a2 00		      ldx	#0	; delay
    530  21cc
    531  21cc		       ad 80 02 	      lda	SWCHA
    532  21cf		       4a		      lsr
    533  21d0		       4a		      lsr
    534  21d1		       4a		      lsr
    535  21d2		       4a		      lsr
    536  21d3		       a8		      tay
    537  21d4
    538  21d4		       c9 0f		      cmp	#15
    539  21d6		       f0 1e		      beq	.cursor	; nothing pressed - skip delays
    540  21d8
    541  21d8		       c6 89		      dec	mdelay
    542  21da		       10 1f		      bpl	.delaym
    543  21dc
    544  21dc		       18		      clc
    545  21dd		       a5 88		      lda	cursorX12
    546  21df		       79 b8 f4 	      adc	JoyMoveCursor,y
    547  21e2		       85 a2		      sta	__newCursor
    548  21e4		       a8		      tay
    549  21e5
    550  21e5		       a9 cf		      lda	#RAMBANK_BOARD
    551  21e7		       85 3e		      sta	SET_BANK_RAM	;@3
    552  21e9		       b9 15 fc 	      lda	ValidSquare,y
    553  21ec		       c9 ff		      cmp	#-1
    554  21ee		       f0 04		      beq	.invalid
    555  21f0		       a5 a2		      lda	__newCursor
    556  21f2		       85 88		      sta	cursorX12
    557  21f4				   .invalid
    558  21f4
    559  21f4		       a2 10		      ldx	#CURSOR_MOVE_SPEED
    560  21f6		       86 89	   .cursor    stx	mdelay
    561  21f8		       20 7d f4 	      jsr	setCursorPriority
    562  21fb		       60	   .delaym    rts
    563  21fc
    564  21fc
    565  21fc							;---------------------------------------------------------------------------------------------------
    566  21fc
      0  21fc					      DEF	aiSelectDestinationSquare
      1  21fc				   SLOT_aiSelectDestinationSquare SET	_BANK_SLOT
      2  21fc				   BANK_aiSelectDestinationSquare SET	SLOT_aiSelectDestinationSquare + _CURRENT_BANK
      3  21fc				   aiSelectDestinationSquare
      4  21fc				   TEMPORARY_VAR SET	Overlay
      5  21fc				   TEMPORARY_OFFSET SET	0
      6  21fc				   VAR_BOUNDARY_aiSelectDestinationSquare SET	TEMPORARY_OFFSET
      7  21fc				   FUNCTION_NAME SET	aiSelectDestinationSquare
    568  21fc					      SUBROUTINE
    569  21fc
      0  21fc					      REFER	AiStateMachine
      1  21fc				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  21fc				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  21fc					      ENDIF
      0  21fc					      VEND	aiSelectDestinationSquare
      1  21fc				  -	      IFNCONST	aiSelectDestinationSquare
      2  21fc				  -	      ECHO	"Incorrect VEND label", aiSelectDestinationSquare
      3  21fc				  -	      ERR
      4  21fc					      ENDIF
      5  21fc		       00 a2	   VAREND_aiSelectDestinationSquare =	TEMPORARY_VAR
    572  21fc
    573  21fc							; Piece is selected and now we're looking for a button press on a destination square
    574  21fc							; we flash the piece on-and-off while we're doing that
    575  21fc							; Flash the selected piece
    576  21fc
    577  21fc		       ad 84 02 	      lda	INTIM
    578  21ff		       c9 28		      cmp	#ONCEPERFRAME
    579  2201		       90 0e		      bcc	.exit
    580  2203
    581  2203
    582  2203		       c6 8d		      dec	aiFlashDelay
    583  2205		       d0 0a		      bne	.exit	; don't flash
    584  2207		       a9 14		      lda	#CAP_SPEED
    585  2209		       85 8d		      sta	aiFlashDelay
    586  220b
    587  220b		       e6 8f		      inc	aiFlashPhase
    588  220d
    589  220d		       20 98 f0 	      jsr	CopySinglePiece	;@0
    590  2210		       60		      rts
    591  2211
    592  2211				   .exit
    593  2211		       20 ca f5 	      jsr	moveCursor
    594  2214
    595  2214		       ad 84 02 	      lda	INTIM
    596  2217		       c9 14		      cmp	#20
    597  2219		       90 35		      bcc	.noButton
    598  221b
    599  221b
    600  221b		       a4 88		      ldy	cursorX12
    601  221d		       84 86		      sty	toX12
    602  221f
    603  221f		       20 63 f5 	      jsr	GetPiece
    604  2222		       20 95 f4 	      jsr	setCursorColours
    605  2225
    606  2225
    607  2225							; y = valid square
    608  2225
    609  2225		       a5 4c		      lda	INPT4
    610  2227		       30 27		      bmi	.noButton
    611  2229
    612  2229		       a5 86		      lda	toX12
    613  222b		       c5 85		      cmp	fromX12
    614  222d		       f0 0d		      beq	.cancel
    615  222f
    616  222f		       c0 ff		      cpy	#-1
    617  2231		       f0 1d		      beq	.noButton	; not a valid square
    618  2233
    619  2233		       a5 8f		      lda	aiFlashPhase
    620  2235		       29 01		      and	#1
    621  2237		       f0 13		      beq	.done
    622  2239		       85 8d		      sta	aiFlashDelay	; EOR-phase incorrect - force quick fix to allow next-frame button detect
    623  223b		       60		      rts
    624  223c
    625  223c				   .cancel
    626  223c
    627  223c		       a5 8f		      lda	aiFlashPhase
    628  223e		       29 01		      and	#1
    629  2240		       f0 05		      beq	.doCancel
    630  2242
    631  2242							; EOR-phase incorrect - force quick fix to allow next-frame button detect
    632  2242
    633  2242		       a9 01		      lda	#1
    634  2244		       85 8d		      sta	aiFlashDelay
    635  2246		       60		      rts
    636  2247
    637  2247
      0  2247				   .doCancel  PHASE	AI_ReselectDebounce
      1  2247		       a9 0a		      lda	#AI_ReselectDebounce
      2  2249		       85 8c		      sta	aiState
    639  224b		       60		      rts
    640  224c
      0  224c				   .done      PHASE	AI_Quiescent	; destination selected!
      1  224c		       a9 09		      lda	#AI_Quiescent
      2  224e		       85 8c		      sta	aiState
    642  2250		       60	   .noButton  rts
    643  2251
    644  2251
    645  2251
    646  2251
    647  2251							;---------------------------------------------------------------------------------------------------
    648  2251
      0  2251					      DEF	aiReselectDebounce
      1  2251				   SLOT_aiReselectDebounce SET	_BANK_SLOT
      2  2251				   BANK_aiReselectDebounce SET	SLOT_aiReselectDebounce + _CURRENT_BANK
      3  2251				   aiReselectDebounce
      4  2251				   TEMPORARY_VAR SET	Overlay
      5  2251				   TEMPORARY_OFFSET SET	0
      6  2251				   VAR_BOUNDARY_aiReselectDebounce SET	TEMPORARY_OFFSET
      7  2251				   FUNCTION_NAME SET	aiReselectDebounce
    650  2251					      SUBROUTINE
    651  2251
      0  2251					      REFER	AiStateMachine
      1  2251				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2251				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2251					      ENDIF
      0  2251					      VEND	aiReselectDebounce
      1  2251				  -	      IFNCONST	aiReselectDebounce
      2  2251				  -	      ECHO	"Incorrect VEND label", aiReselectDebounce
      3  2251				  -	      ERR
      4  2251					      ENDIF
      5  2251		       00 a2	   VAREND_aiReselectDebounce =	TEMPORARY_VAR
    654  2251
    655  2251							; We've just cancelled the move. Wait for the button to be released
    656  2251							; and then go back to selecting a piece to move
    657  2251
    658  2251		       a5 4c		      lda	INPT4
    659  2253		       10 04		      bpl	.exit	; button still pressed, so wait
    660  2255
      0  2255					      PHASE	AI_SelectStartSquare
      1  2255		       a9 02		      lda	#AI_SelectStartSquare
      2  2257		       85 8c		      sta	aiState
    662  2259		       60	   .exit      rts
    663  225a
    664  225a
    665  225a							;---------------------------------------------------------------------------------------------------
    666  225a
      0  225a					      DEF	aiQuiescent
      1  225a				   SLOT_aiQuiescent SET	_BANK_SLOT
      2  225a				   BANK_aiQuiescent SET	SLOT_aiQuiescent + _CURRENT_BANK
      3  225a				   aiQuiescent
      4  225a				   TEMPORARY_VAR SET	Overlay
      5  225a				   TEMPORARY_OFFSET SET	0
      6  225a				   VAR_BOUNDARY_aiQuiescent SET	TEMPORARY_OFFSET
      7  225a				   FUNCTION_NAME SET	aiQuiescent
    668  225a					      SUBROUTINE
    669  225a
      0  225a					      REFER	AiStateMachine
      1  225a				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  225a				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  225a					      ENDIF
      0  225a					      VEND	aiQuiescent
      1  225a				  -	      IFNCONST	aiQuiescent
      2  225a				  -	      ECHO	"Incorrect VEND label", aiQuiescent
      3  225a				  -	      ERR
      4  225a					      ENDIF
      5  225a		       00 a2	   VAREND_aiQuiescent =	TEMPORARY_VAR
    672  225a
    673  225a							; Move has been selected
    674  225a
    675  225a		       a9 ff		      lda	#-1
    676  225c		       85 88		      sta	cursorX12
    677  225e
    678  225e		       a5 85		      lda	fromX12
    679  2260		       85 87		      sta	originX12
    680  2262		       20 63 f5 	      jsr	GetPiece	; from the movelist
    681  2265
    682  2265		       a4 85		      ldy	fromX12
    683  2267		       20 14 f6 	      jsr	GetBoard	; get the piece from the board itself
    684  226a
    685  226a		       45 97		      eor	fromPiece
    686  226c		       29 0f		      and	#PIECE_MASK	; if not the same piece board/movelist...
    687  226e		       d0 05		      bne	.promote	; promote a pawn
    688  2270
      0  2270					      PHASE	AI_MoveIsSelected
      1  2270		       a9 14		      lda	#AI_MoveIsSelected
      2  2272		       85 8c		      sta	aiState
    690  2274		       60		      rts
    691  2275
      0  2275				   .promote   PHASE	AI_PromotePawnStart
      1  2275		       a9 1f		      lda	#AI_PromotePawnStart
      2  2277		       85 8c		      sta	aiState
    693  2279		       60		      rts
    694  227a
    695  227a
    696  227a							;---------------------------------------------------------------------------------------------------
    697  227a
      0  227a					      DEF	aiRollPromotionPiece
      1  227a				   SLOT_aiRollPromotionPiece SET	_BANK_SLOT
      2  227a				   BANK_aiRollPromotionPiece SET	SLOT_aiRollPromotionPiece + _CURRENT_BANK
      3  227a				   aiRollPromotionPiece
      4  227a				   TEMPORARY_VAR SET	Overlay
      5  227a				   TEMPORARY_OFFSET SET	0
      6  227a				   VAR_BOUNDARY_aiRollPromotionPiece SET	TEMPORARY_OFFSET
      7  227a				   FUNCTION_NAME SET	aiRollPromotionPiece
    699  227a					      SUBROUTINE
    700  227a
      0  227a					      REFER	AiStateMachine
      1  227a				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  227a				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  227a					      ENDIF
      0  227a					      VEND	aiRollPromotionPiece
      1  227a				  -	      IFNCONST	aiRollPromotionPiece
      2  227a				  -	      ECHO	"Incorrect VEND label", aiRollPromotionPiece
      3  227a				  -	      ERR
      4  227a					      ENDIF
      5  227a		       00 a2	   VAREND_aiRollPromotionPiece =	TEMPORARY_VAR
    703  227a
    704  227a							; Flash the '?' and wait for an UDLR move
    705  227a
    706  227a		       ad 84 02 	      lda	INTIM
    707  227d		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    708  227f		       90 28		      bcc	.exit
    709  2281
    710  2281		       ad 80 02 	      lda	SWCHA
    711  2284		       29 f0		      and	#$F0
    712  2286		       c9 f0		      cmp	#$F0
    713  2288		       f0 0a		      beq	.nojoy
    714  228a
    715  228a		       a9 00		      lda	#0
    716  228c		       85 8d		      sta	aiFlashDelay
    717  228e
    718  228e		       a5 8f		      lda	aiFlashPhase
    719  2290		       29 01		      and	#1
    720  2292		       f0 16		      beq	.even
    721  2294
    722  2294		       c6 8d	   .nojoy     dec	aiFlashDelay
    723  2296		       10 11		      bpl	.exit
    724  2298
    725  2298		       a9 0a		      lda	#10
    726  229a		       85 8d		      sta	aiFlashDelay
    727  229c
    728  229c		       a2 20		      ldx	#INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0
    729  229e		       a5 96		      lda	sideToMove
    730  22a0		       10 02		      bpl	.wtm
    731  22a2		       a2 68		      ldx	#INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0
    732  22a4				   .wtm
    733  22a4		       20 53 f4 	      jsr	showPromoteOptions
    734  22a7
    735  22a7		       e6 8f		      inc	aiFlashPhase
    736  22a9
    737  22a9		       60	   .exit      rts
    738  22aa
    739  22aa
    740  22aa		       a9 03	   .even      lda	#3	; QUEEN
    741  22ac		       85 97		      sta	fromPiece	; cycles as index to NBRQ
    742  22ae
    743  22ae		       e6 8f		      inc	aiFlashPhase
    744  22b0
    745  22b0
    746  22b0		       a2 14		      ldx	#INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0	;TODO: fix for colour
    747  22b2		       a5 96		      lda	sideToMove
    748  22b4		       10 02		      bpl	.whiteToMove
    749  22b6		       a2 5c		      ldx	#INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    750  22b8				   .whiteToMove
    751  22b8
    752  22b8		       20 53 f4 	      jsr	showPromoteOptions
    753  22bb
      0  22bb					      PHASE	AI_ChooseDebounce
      1  22bb		       a9 22		      lda	#AI_ChooseDebounce
      2  22bd		       85 8c		      sta	aiState
    755  22bf		       60		      rts
    756  22c0
    757  22c0
    758  22c0							;---------------------------------------------------------------------------------------------------
    759  22c0
      0  22c0					      DEF	aiMarchToTargetA
      1  22c0				   SLOT_aiMarchToTargetA SET	_BANK_SLOT
      2  22c0				   BANK_aiMarchToTargetA SET	SLOT_aiMarchToTargetA + _CURRENT_BANK
      3  22c0				   aiMarchToTargetA
      4  22c0				   TEMPORARY_VAR SET	Overlay
      5  22c0				   TEMPORARY_OFFSET SET	0
      6  22c0				   VAR_BOUNDARY_aiMarchToTargetA SET	TEMPORARY_OFFSET
      7  22c0				   FUNCTION_NAME SET	aiMarchToTargetA
    761  22c0					      SUBROUTINE
    762  22c0
      0  22c0					      REFER	AiStateMachine
      1  22c0				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  22c0				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  22c0					      ENDIF
      0  22c0					      VAR	__fromRow, 1
      1  22c0		       00 a2	   __fromRow  =	TEMPORARY_VAR
      2  22c0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  22c0
      4  22c0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  22c0				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  22c0				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  22c0					      ENDIF
      8  22c0				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  22c0				  -	      ECHO	"Temporary Variable", __fromRow, "overflow!"
     10  22c0				  -	      ERR
     11  22c0					      ENDIF
     12  22c0					      LIST	ON
      0  22c0					      VAR	__boardIndex, 1
      1  22c0		       00 a3	   __boardIndex =	TEMPORARY_VAR
      2  22c0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  22c0
      4  22c0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  22c0				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  22c0				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  22c0					      ENDIF
      8  22c0				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  22c0				  -	      ECHO	"Temporary Variable", __boardIndex, "overflow!"
     10  22c0				  -	      ERR
     11  22c0					      ENDIF
     12  22c0					      LIST	ON
      0  22c0					      VAR	__fromCol, 1
      1  22c0		       00 a4	   __fromCol  =	TEMPORARY_VAR
      2  22c0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  22c0
      4  22c0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  22c0				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  22c0				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  22c0					      ENDIF
      8  22c0				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  22c0				  -	      ECHO	"Temporary Variable", __fromCol, "overflow!"
     10  22c0				  -	      ERR
     11  22c0					      ENDIF
     12  22c0					      LIST	ON
      0  22c0					      VAR	__toCol, 1
      1  22c0		       00 a5	   __toCol    =	TEMPORARY_VAR
      2  22c0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  22c0
      4  22c0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  22c0				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  22c0				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  22c0					      ENDIF
      8  22c0				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  22c0				  -	      ECHO	"Temporary Variable", __toCol, "overflow!"
     10  22c0				  -	      ERR
     11  22c0					      ENDIF
     12  22c0					      LIST	ON
      0  22c0					      VEND	aiMarchToTargetA
      1  22c0				  -	      IFNCONST	aiMarchToTargetA
      2  22c0				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetA
      3  22c0				  -	      ERR
      4  22c0					      ENDIF
      5  22c0		       00 a6	   VAREND_aiMarchToTargetA =	TEMPORARY_VAR
    769  22c0
    770  22c0
    771  22c0							; Now we calculate move to new square
    772  22c0
    773  22c0		       a5 85		      lda	fromX12
    774  22c2		       c5 86		      cmp	toX12
    775  22c4		       f0 44		      beq	.unmovedx
    776  22c6		       85 83		      sta	lastSquareX12
    777  22c8
    778  22c8		       38		      sec
    779  22c9		       a2 fd		      ldx	#-3
    780  22cb		       e9 0a	   .sub10     sbc	#10
    781  22cd		       e8		      inx
    782  22ce		       b0 fb		      bcs	.sub10
    783  22d0		       69 08		      adc	#8
    784  22d2		       85 a4		      sta	__fromCol
    785  22d4		       86 a2		      stx	__fromRow
    786  22d6
    787  22d6		       a5 86		      lda	toX12
    788  22d8		       38		      sec
    789  22d9		       a2 fd		      ldx	#-3
    790  22db		       e9 0a	   .sub10b    sbc	#10
    791  22dd		       e8		      inx
    792  22de		       b0 fb		      bcs	.sub10b
    793  22e0		       69 08		      adc	#8
    794  22e2		       85 a5		      sta	__toCol
    795  22e4
    796  22e4
    797  22e4		       e4 a2		      cpx	__fromRow
    798  22e6		       f0 13		      beq	.rowDone
    799  22e8
    800  22e8		       b0 0a		      bcs	.incRow
    801  22ea
    802  22ea		       38		      sec
    803  22eb		       a5 85		      lda	fromX12
    804  22ed		       e9 0a		      sbc	#10
    805  22ef		       85 85		      sta	fromX12
    806  22f1		       4c fb f6 	      jmp	.rowDone
    807  22f4
    808  22f4		       18	   .incRow    clc
    809  22f5		       a5 85		      lda	fromX12
    810  22f7		       69 0a		      adc	#10
    811  22f9		       85 85		      sta	fromX12
    812  22fb
    813  22fb				   .rowDone
    814  22fb
    815  22fb		       a5 a5		      lda	__toCol
    816  22fd		       c5 a4		      cmp	__fromCol
    817  22ff		       f0 09		      beq	.colDone
    818  2301
    819  2301		       b0 05		      bcs	.incCol
    820  2303
    821  2303		       c6 85		      dec	fromX12
    822  2305		       4c 0a f7 	      jmp	.colDone
    823  2308
    824  2308		       e6 85	   .incCol    inc	fromX12
    825  230a				   .colDone
    826  230a				   .unmovedx
    827  230a
      0  230a					      PHASE	AI_MarchA2
      1  230a		       a9 17		      lda	#AI_MarchA2
      2  230c		       85 8c		      sta	aiState
    829  230e		       60		      rts
    830  230f
    831  230f
    832  230f							;---------------------------------------------------------------------------------------------------
    833  230f
      0  230f					      DEF	aiMarchA2
      1  230f				   SLOT_aiMarchA2 SET	_BANK_SLOT
      2  230f				   BANK_aiMarchA2 SET	SLOT_aiMarchA2 + _CURRENT_BANK
      3  230f				   aiMarchA2
      4  230f				   TEMPORARY_VAR SET	Overlay
      5  230f				   TEMPORARY_OFFSET SET	0
      6  230f				   VAR_BOUNDARY_aiMarchA2 SET	TEMPORARY_OFFSET
      7  230f				   FUNCTION_NAME SET	aiMarchA2
    835  230f					      SUBROUTINE
    836  230f
    837  230f
    838  230f							; erase object in new sqare --> blank
    839  230f
    840  230f		       a4 85		      ldy	fromX12
    841  2311		       84 80		      sty	squareToDraw
    842  2313
    843  2313		       20 14 f6 	      jsr	GetBoard
    844  2316		       c9 00		      cmp	#0
    845  2318		       f0 03		      beq	.skipbl
    846  231a		       20 98 f0 	      jsr	CopySinglePiece	;@0	      ; erase next square along --> blank
    847  231d
    848  231d				   .skipbl
    849  231d		       a4 85		      ldy	fromX12
    850  231f		       84 a3		      sty	__boardIndex
    851  2321
    852  2321		       20 14 f6 	      jsr	GetBoard
    853  2324		       85 98		      sta	lastPiece	; what we are overwriting
    854  2326		       a5 97		      lda	fromPiece
    855  2328		       09 40		      ora	#FLAG_MOVED	; prevents usage in castling for K/R
    856  232a		       29 df		      and	#~FLAG_ENPASSANT
    857  232c		       a4 a3		      ldy	__boardIndex
    858  232e		       20 08 f6 	      jsr	PutBoard
    859  2331
      0  2331					      PHASE	AI_MarchB
      1  2331		       a9 18		      lda	#AI_MarchB
      2  2333		       85 8c		      sta	aiState
    861  2335		       60		      rts
    862  2336
    863  2336
    864  2336							;---------------------------------------------------------------------------------------------------
    865  2336
      0  2336					      DEF	aiMarchB2
      1  2336				   SLOT_aiMarchB2 SET	_BANK_SLOT
      2  2336				   BANK_aiMarchB2 SET	SLOT_aiMarchB2 + _CURRENT_BANK
      3  2336				   aiMarchB2
      4  2336				   TEMPORARY_VAR SET	Overlay
      5  2336				   TEMPORARY_OFFSET SET	0
      6  2336				   VAR_BOUNDARY_aiMarchB2 SET	TEMPORARY_OFFSET
      7  2336				   FUNCTION_NAME SET	aiMarchB2
    867  2336					      SUBROUTINE
    868  2336
      0  2336					      REFER	AiStateMachine
      1  2336				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2336				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2336					      ENDIF
      0  2336					      VEND	aiMarchB2
      1  2336				  -	      IFNCONST	aiMarchB2
      2  2336				  -	      ECHO	"Incorrect VEND label", aiMarchB2
      3  2336				  -	      ERR
      4  2336					      ENDIF
      5  2336		       00 a2	   VAREND_aiMarchB2 =	TEMPORARY_VAR
    871  2336
    872  2336		       a4 83		      ldy	lastSquareX12
    873  2338		       84 80		      sty	squareToDraw
    874  233a
    875  233a		       20 14 f6 	      jsr	GetBoard
    876  233d		       c9 00		      cmp	#0
    877  233f		       f0 03		      beq	.skipbl2
    878  2341
    879  2341		       20 98 f0 	      jsr	CopySinglePiece	;@0	      ; draw previous piece back in old position
    880  2344				   .skipbl2
    881  2344
    882  2344		       a5 85		      lda	fromX12
    883  2346		       c5 86		      cmp	toX12
    884  2348		       f0 09		      beq	xhalt
    885  234a
    886  234a		       a9 00		      lda	#0	; inter-move segment speed (can be 0)
    887  234c		       85 82		      sta	drawDelay
      0  234e					      PHASE	AI_MarchToTargetA
      1  234e		       a9 16		      lda	#AI_MarchToTargetA
      2  2350		       85 8c		      sta	aiState
    889  2352
    890  2352		       60		      rts
    891  2353
    892  2353				   xhalt
    893  2353
    894  2353							;??? jsr FinaliseMove
    895  2353
    896  2353		       a9 04		      lda	#4	; on/off count
    897  2355		       85 84		      sta	drawCount	; flashing for piece about to move
    898  2357		       a9 00		      lda	#0
    899  2359		       85 82		      sta	drawDelay
    900  235b
      0  235b					      PHASE	AI_FinalFlash
      1  235b		       a9 1b		      lda	#AI_FinalFlash
      2  235d		       85 8c		      sta	aiState
    902  235f		       60		      rts
    903  2360
    904  2360							;---------------------------------------------------------------------------------------------------
    905  2360
      0  2360					      CHECK_BANK_SIZE	"BANK_StateMachine"
      1  2360		       03 60	   .TEMP      =	* - _BANK_START
 BANK_StateMachine (1K) SIZE =  $360 , FREE= $a0
      2  2360					      ECHO	"BANK_StateMachine", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2360				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2360				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_StateMachine", " size=", * - ORIGIN
      5  2360				  -	      ERR
      6  2360					      ENDIF
    907  2360
    908  2360
    909  2360							;---------------------------------------------------------------------------------------------------
    910  2360
    911  2360							; EOF
------- FILE ./chess.asm
------- FILE BANK_StateMachine@1#2.asm LEVEL 2 PASS 4
      0  2360					      include	"BANK_StateMachine@1#2.asm"
      0  2360					      SLOT	1
      1  2360				  -	      IF	(1 < 0) || (1 > 3)
      2  2360				  -	      ECHO	"Illegal bank address/segment location", 1
      3  2360				  -	      ERR
      4  2360					      ENDIF
      5  2360				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  2360				   _BANK_SLOT SET	1 * 64
      0  2360					      NEWBANK	STATEMACHINE2
      1  2538 ????				      SEG	STATEMACHINE2
      2  2400					      ORG	_ORIGIN
      3  2400					      RORG	_BANK_ADDRESS_ORIGIN
      4  2400				   _BANK_START SET	*
      5  2400				   STATEMACHINE2_START SET	*
      6  2400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2400				   STATEMACHINE2 SET	_BANK_SLOT + _CURRENT_BANK
      8  2400				   _ORIGIN    SET	_ORIGIN + 1024
      3  2400
      4  2400							;---------------------------------------------------------------------------------------------------
      5  2400
      0  2400					      DEF	aiChoosePromotePiece
      1  2400				   SLOT_aiChoosePromotePiece SET	_BANK_SLOT
      2  2400				   BANK_aiChoosePromotePiece SET	SLOT_aiChoosePromotePiece + _CURRENT_BANK
      3  2400				   aiChoosePromotePiece
      4  2400				   TEMPORARY_VAR SET	Overlay
      5  2400				   TEMPORARY_OFFSET SET	0
      6  2400				   VAR_BOUNDARY_aiChoosePromotePiece SET	TEMPORARY_OFFSET
      7  2400				   FUNCTION_NAME SET	aiChoosePromotePiece
      7  2400					      SUBROUTINE
      8  2400
      0  2400					      REFER	AiStateMachine
      1  2400				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2400				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2400					      ENDIF
      0  2400					      VEND	aiChoosePromotePiece
      1  2400				  -	      IFNCONST	aiChoosePromotePiece
      2  2400				  -	      ECHO	"Incorrect VEND label", aiChoosePromotePiece
      3  2400				  -	      ERR
      4  2400					      ENDIF
      5  2400		       00 a2	   VAREND_aiChoosePromotePiece =	TEMPORARY_VAR
     11  2400
     12  2400							; Question-mark phase has exited via joystick direction
     13  2400							; Now we cycle through the selectable pieces
     14  2400
     15  2400		       ad 84 02 	      lda	INTIM
     16  2403		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
     17  2405		       90 40		      bcc	.exit
     18  2407
     19  2407		       a5 4c		      lda	INPT4
     20  2409		       30 0a		      bmi	.nobut	; no press
     21  240b
     22  240b							; button pressed but make sure phase is correct for exit
     23  240b
     24  240b		       a9 00		      lda	#0
     25  240d		       85 8d		      sta	aiFlashDelay
     26  240f
     27  240f		       a5 8f		      lda	aiFlashPhase
     28  2411		       29 01		      and	#1
     29  2413		       f0 33		      beq	.chosen	; button pressed --> selection made
     30  2415
     31  2415				   .nobut
     32  2415		       ad 80 02 	      lda	SWCHA
     33  2418		       29 f0		      and	#$F0
     34  241a		       c9 f0		      cmp	#$F0
     35  241c		       f0 17		      beq	.odd	; no direction pressed
     36  241e
     37  241e		       4a		      lsr
     38  241f		       4a		      lsr
     39  2420		       4a		      lsr
     40  2421		       4a		      lsr
     41  2422		       a8		      tay
     42  2423
     43  2423							; joystick but make sure phase is correct
     44  2423
     45  2423		       a5 8f		      lda	aiFlashPhase
     46  2425		       4a		      lsr
     47  2426		       b0 0d		      bcs	.odd	; must wait until piece undrawn
     48  2428
     49  2428							; cycle to the next promotable piece (N/B/R/Q)
     50  2428							; TODO; use joy table for mod instead of just incrementing all the time
     51  2428
     52  2428							;clc
     53  2428		       a5 97		      lda	fromPiece
     54  242a		       79 a8 f4 	      adc	JoyCombined,y
     55  242d		       29 03		      and	#3
     56  242f		       85 97		      sta	fromPiece
     57  2431
      0  2431					      PHASE	AI_ChooseDebounce	; wait for release
      1  2431		       a9 22		      lda	#AI_ChooseDebounce
      2  2433		       85 8c		      sta	aiState
     59  2435
     60  2435		       c6 8d	   .odd       dec	aiFlashDelay
     61  2437		       10 0e		      bpl	.exit
     62  2439
     63  2439		       a9 0a	   .force     lda	#10
     64  243b		       85 8d		      sta	aiFlashDelay
     65  243d
     66  243d		       e6 8f		      inc	aiFlashPhase
     67  243f
     68  243f		       a4 97		      ldy	fromPiece
     69  2441		       be 63 f4 	      ldx	promotePiece,y
     70  2444		       20 53 f4 	      jsr	showPromoteOptions
     71  2447
     72  2447		       60	   .exit      rts
     73  2448
     74  2448
     75  2448				   .chosen
     76  2448		       a5 97		      lda	fromPiece
     77  244a		       29 0f		      and	#PIECE_MASK
     78  244c		       aa		      tax
     79  244d
     80  244d		       bd 67 f4 	      lda	promoteType,x
     81  2450		       85 97		      sta	fromPiece
     82  2452
     83  2452		       a4 86		      ldy	toX12
     84  2454		       20 14 f6 	      jsr	GetBoard
     85  2457		       29 0f		      and	#PIECE_MASK
     86  2459		       f0 03		      beq	.nothing
     87  245b
     88  245b		       20 98 f0 	      jsr	CopySinglePiece	;@0	      ; put back whatever was there to start
     89  245e
      0  245e				   .nothing   PHASE	AI_MoveIsSelected
      1  245e		       a9 14		      lda	#AI_MoveIsSelected
      2  2460		       85 8c		      sta	aiState
     91  2462		       60		      rts
     92  2463
      0  2463					      ALLOCATE	promotePiece, 4
      0  2463					      OPTIONAL_PAGEBREAK	"Table", 4
     12  2463					      LIST	ON
      0  2463					      DEF	promotePiece
      1  2463				   SLOT_promotePiece SET	_BANK_SLOT
      2  2463				   BANK_promotePiece SET	SLOT_promotePiece + _CURRENT_BANK
      3  2463				   promotePiece
      4  2463				   TEMPORARY_VAR SET	Overlay
      5  2463				   TEMPORARY_OFFSET SET	0
      6  2463				   VAR_BOUNDARY_promotePiece SET	TEMPORARY_OFFSET
      7  2463				   FUNCTION_NAME SET	promotePiece
     94  2463		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
     95  2464		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
     96  2465		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
     97  2466		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
     98  2467
      0  2467					      ALLOCATE	promoteType,4
      0  2467					      OPTIONAL_PAGEBREAK	"Table", 4
     12  2467					      LIST	ON
      0  2467					      DEF	promoteType
      1  2467				   SLOT_promoteType SET	_BANK_SLOT
      2  2467				   BANK_promoteType SET	SLOT_promoteType + _CURRENT_BANK
      3  2467				   promoteType
      4  2467				   TEMPORARY_VAR SET	Overlay
      5  2467				   TEMPORARY_OFFSET SET	0
      6  2467				   VAR_BOUNDARY_promoteType SET	TEMPORARY_OFFSET
      7  2467				   FUNCTION_NAME SET	promoteType
    100  2467		       03 04 05 06	      .byte.b	KNIGHT, BISHOP, ROOK, QUEEN
    101  246b
    102  246b
    103  246b							;---------------------------------------------------------------------------------------------------
    104  246b
      0  246b					      DEF	aiChooseDebounce
      1  246b				   SLOT_aiChooseDebounce SET	_BANK_SLOT
      2  246b				   BANK_aiChooseDebounce SET	SLOT_aiChooseDebounce + _CURRENT_BANK
      3  246b				   aiChooseDebounce
      4  246b				   TEMPORARY_VAR SET	Overlay
      5  246b				   TEMPORARY_OFFSET SET	0
      6  246b				   VAR_BOUNDARY_aiChooseDebounce SET	TEMPORARY_OFFSET
      7  246b				   FUNCTION_NAME SET	aiChooseDebounce
    106  246b					      SUBROUTINE
    107  246b
      0  246b					      REFER	AiStateMachine
      1  246b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  246b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  246b					      ENDIF
      0  246b					      VEND	aiChooseDebounce
      1  246b				  -	      IFNCONST	aiChooseDebounce
      2  246b				  -	      ECHO	"Incorrect VEND label", aiChooseDebounce
      3  246b				  -	      ERR
      4  246b					      ENDIF
      5  246b		       00 a2	   VAREND_aiChooseDebounce =	TEMPORARY_VAR
    110  246b
    111  246b							; We've changed promotion piece, but wait for joystick to be released
    112  246b
    113  246b		       ad 80 02 	      lda	SWCHA
    114  246e		       29 f0		      and	#$F0
    115  2470		       c9 f0		      cmp	#$F0
    116  2472		       d0 08		      bne	.exit	; wait while joystick still pressed
    117  2474
    118  2474		       a9 01		      lda	#1
    119  2476		       85 8d		      sta	aiFlashDelay
    120  2478
      0  2478					      PHASE	AI_ChoosePromotePiece
      1  2478		       a9 21		      lda	#AI_ChoosePromotePiece
      2  247a		       85 8c		      sta	aiState
    122  247c		       60	   .exit      rts
    123  247d
    124  247d
    125  247d							;---------------------------------------------------------------------------------------------------
    126  247d
      0  247d					      DEF	aiDelayAfterMove
      1  247d				   SLOT_aiDelayAfterMove SET	_BANK_SLOT
      2  247d				   BANK_aiDelayAfterMove SET	SLOT_aiDelayAfterMove + _CURRENT_BANK
      3  247d				   aiDelayAfterMove
      4  247d				   TEMPORARY_VAR SET	Overlay
      5  247d				   TEMPORARY_OFFSET SET	0
      6  247d				   VAR_BOUNDARY_aiDelayAfterMove SET	TEMPORARY_OFFSET
      7  247d				   FUNCTION_NAME SET	aiDelayAfterMove
    128  247d					      SUBROUTINE
    129  247d
      0  247d					      VEND	aiDelayAfterMove
      1  247d				  -	      IFNCONST	aiDelayAfterMove
      2  247d				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  247d				  -	      ERR
      4  247d					      ENDIF
      5  247d		       00 a2	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
    131  247d
    132  247d		       a9 32		      lda	#50
    133  247f		       85 8d		      sta	aiFlashDelay
      0  2481					      PHASE	AI_DelayAfterMove2
      1  2481		       a9 26		      lda	#AI_DelayAfterMove2
      2  2483		       85 8c		      sta	aiState
    135  2485		       60	   .exit      rts
    136  2486
    137  2486
    138  2486							;---------------------------------------------------------------------------------------------------
    139  2486
      0  2486					      DEF	aiDelayAfterMove2
      1  2486				   SLOT_aiDelayAfterMove2 SET	_BANK_SLOT
      2  2486				   BANK_aiDelayAfterMove2 SET	SLOT_aiDelayAfterMove2 + _CURRENT_BANK
      3  2486				   aiDelayAfterMove2
      4  2486				   TEMPORARY_VAR SET	Overlay
      5  2486				   TEMPORARY_OFFSET SET	0
      6  2486				   VAR_BOUNDARY_aiDelayAfterMove2 SET	TEMPORARY_OFFSET
      7  2486				   FUNCTION_NAME SET	aiDelayAfterMove2
    141  2486					      SUBROUTINE
    142  2486
      0  2486					      VEND	aiDelayAfterMove
      1  2486				  -	      IFNCONST	aiDelayAfterMove
      2  2486				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  2486				  -	      ERR
      4  2486					      ENDIF
      5  2486		       00 a2	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
    144  2486
    145  2486		       c6 8d		      dec	aiFlashDelay
    146  2488		       d0 04		      bne	.exit
      0  248a					      PHASE	AI_MoveIsSelected
      1  248a		       a9 14		      lda	#AI_MoveIsSelected
      2  248c		       85 8c		      sta	aiState
    148  248e		       60	   .exit      rts
    149  248f
    150  248f
    151  248f							;---------------------------------------------------------------------------------------------------
    152  248f
      0  248f					      DEF	aiDelayAfterPlaced
      1  248f				   SLOT_aiDelayAfterPlaced SET	_BANK_SLOT
      2  248f				   BANK_aiDelayAfterPlaced SET	SLOT_aiDelayAfterPlaced + _CURRENT_BANK
      3  248f				   aiDelayAfterPlaced
      4  248f				   TEMPORARY_VAR SET	Overlay
      5  248f				   TEMPORARY_OFFSET SET	0
      6  248f				   VAR_BOUNDARY_aiDelayAfterPlaced SET	TEMPORARY_OFFSET
      7  248f				   FUNCTION_NAME SET	aiDelayAfterPlaced
    154  248f					      SUBROUTINE
    155  248f
      0  248f					      VEND	aiDelayAfterPlaced
      1  248f				  -	      IFNCONST	aiDelayAfterPlaced
      2  248f				  -	      ECHO	"Incorrect VEND label", aiDelayAfterPlaced
      3  248f				  -	      ERR
      4  248f					      ENDIF
      5  248f		       00 a2	   VAREND_aiDelayAfterPlaced =	TEMPORARY_VAR
    157  248f
    158  248f		       a2 4b		      ldx	#75	; delay after human move
    159  2491		       a5 96		      lda	sideToMove
    160  2493		       30 02		      bmi	.computer
    161  2495		       a2 01		      ldx	#1	; delay after computer move
    162  2497		       86 8d	   .computer  stx	aiFlashDelay
    163  2499
      0  2499					      PHASE	AI_DelayAfterPlaced2
      1  2499		       a9 28		      lda	#AI_DelayAfterPlaced2
      2  249b		       85 8c		      sta	aiState
    165  249d		       60		      rts
    166  249e
    167  249e
    168  249e							;---------------------------------------------------------------------------------------------------
    169  249e
      0  249e					      DEF	aiDelayAfterPlaced2
      1  249e				   SLOT_aiDelayAfterPlaced2 SET	_BANK_SLOT
      2  249e				   BANK_aiDelayAfterPlaced2 SET	SLOT_aiDelayAfterPlaced2 + _CURRENT_BANK
      3  249e				   aiDelayAfterPlaced2
      4  249e				   TEMPORARY_VAR SET	Overlay
      5  249e				   TEMPORARY_OFFSET SET	0
      6  249e				   VAR_BOUNDARY_aiDelayAfterPlaced2 SET	TEMPORARY_OFFSET
      7  249e				   FUNCTION_NAME SET	aiDelayAfterPlaced2
    171  249e					      SUBROUTINE
    172  249e
    173  249e							;jsr debug
    174  249e
    175  249e		       c6 8d		      dec	aiFlashDelay
    176  24a0		       d0 04		      bne	.exit
      0  24a2					      PHASE	AI_GenerateMoves
      1  24a2		       a9 12		      lda	#AI_GenerateMoves
      2  24a4		       85 8c		      sta	aiState
    178  24a6		       60	   .exit      rts
    179  24a7
    180  24a7
    181  24a7							;---------------------------------------------------------------------------------------------------
    182  24a7
      0  24a7					      DEF	aiMarchToTargetB
      1  24a7				   SLOT_aiMarchToTargetB SET	_BANK_SLOT
      2  24a7				   BANK_aiMarchToTargetB SET	SLOT_aiMarchToTargetB + _CURRENT_BANK
      3  24a7				   aiMarchToTargetB
      4  24a7				   TEMPORARY_VAR SET	Overlay
      5  24a7				   TEMPORARY_OFFSET SET	0
      6  24a7				   VAR_BOUNDARY_aiMarchToTargetB SET	TEMPORARY_OFFSET
      7  24a7				   FUNCTION_NAME SET	aiMarchToTargetB
    184  24a7					      SUBROUTINE
    185  24a7
      0  24a7					      REFER	AiStateMachine
      1  24a7				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  24a7				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  24a7					      ENDIF
      0  24a7					      VEND	aiMarchToTargetB
      1  24a7				  -	      IFNCONST	aiMarchToTargetB
      2  24a7				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetB
      3  24a7				  -	      ERR
      4  24a7					      ENDIF
      5  24a7		       00 a2	   VAREND_aiMarchToTargetB =	TEMPORARY_VAR
    188  24a7
    189  24a7							; now we want to undraw the piece in the old square
    190  24a7
    191  24a7		       a5 83		      lda	lastSquareX12
    192  24a9		       85 80		      sta	squareToDraw
    193  24ab
    194  24ab		       20 98 f0 	      jsr	CopySinglePiece	;@0	      ; erase whatever was on the previous square (completely blank)
    195  24ae
    196  24ae		       a4 83		      ldy	lastSquareX12
    197  24b0		       a5 99		      lda	previousPiece
    198  24b2		       20 08 f6 	      jsr	PutBoard
    199  24b5
    200  24b5		       a5 98		      lda	lastPiece
    201  24b7		       85 99		      sta	previousPiece
    202  24b9
      0  24b9					      PHASE	AI_MarchB2
      1  24b9		       a9 1a		      lda	#AI_MarchB2
      2  24bb		       85 8c		      sta	aiState
    204  24bd		       60		      rts
    205  24be
    206  24be
    207  24be							;---------------------------------------------------------------------------------------------------
    208  24be
      0  24be					      DEF	aiPromotePawnStart
      1  24be				   SLOT_aiPromotePawnStart SET	_BANK_SLOT
      2  24be				   BANK_aiPromotePawnStart SET	SLOT_aiPromotePawnStart + _CURRENT_BANK
      3  24be				   aiPromotePawnStart
      4  24be				   TEMPORARY_VAR SET	Overlay
      5  24be				   TEMPORARY_OFFSET SET	0
      6  24be				   VAR_BOUNDARY_aiPromotePawnStart SET	TEMPORARY_OFFSET
      7  24be				   FUNCTION_NAME SET	aiPromotePawnStart
    210  24be					      SUBROUTINE
    211  24be
      0  24be					      REFER	AiStateMachine
      1  24be				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  24be				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  24be					      ENDIF
      0  24be					      VEND	aiPromotePawnStart
      1  24be				  -	      IFNCONST	aiPromotePawnStart
      2  24be				  -	      ECHO	"Incorrect VEND label", aiPromotePawnStart
      3  24be				  -	      ERR
      4  24be					      ENDIF
      5  24be		       00 a2	   VAREND_aiPromotePawnStart =	TEMPORARY_VAR
    214  24be
    215  24be
    216  24be		       ad 84 02 	      lda	INTIM
    217  24c1		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    218  24c3		       90 18		      bcc	.exit
    219  24c5
    220  24c5		       a9 00		      lda	#0
    221  24c7		       85 8f		      sta	aiFlashPhase
    222  24c9		       85 8d		      sta	aiFlashDelay
    223  24cb
    224  24cb		       a4 86		      ldy	toX12
    225  24cd		       84 80		      sty	squareToDraw
    226  24cf
    227  24cf		       20 14 f6 	      jsr	GetBoard
    228  24d2		       29 0f		      and	#PIECE_MASK
    229  24d4		       f0 03		      beq	.empty
    230  24d6
    231  24d6		       20 98 f0 	      jsr	CopySinglePiece	;@0	      ; remove any capturable piece for display purposes
    232  24d9
      0  24d9				   .empty     PHASE	AI_RollPromotionPiece
      1  24d9		       a9 20		      lda	#AI_RollPromotionPiece
      2  24db		       85 8c		      sta	aiState
    234  24dd		       60	   .exit      rts
    235  24de
    236  24de
    237  24de							;---------------------------------------------------------------------------------------------------
    238  24de
      0  24de					      DEF	aiGenerateMoves
      1  24de				   SLOT_aiGenerateMoves SET	_BANK_SLOT
      2  24de				   BANK_aiGenerateMoves SET	SLOT_aiGenerateMoves + _CURRENT_BANK
      3  24de				   aiGenerateMoves
      4  24de				   TEMPORARY_VAR SET	Overlay
      5  24de				   TEMPORARY_OFFSET SET	0
      6  24de				   VAR_BOUNDARY_aiGenerateMoves SET	TEMPORARY_OFFSET
      7  24de				   FUNCTION_NAME SET	aiGenerateMoves
    240  24de					      SUBROUTINE
    241  24de
      0  24de					      REFER	AiStateMachine
      1  24de				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  24de				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  24de					      ENDIF
      0  24de					      VEND	aiGenerateMoves
      1  24de				  -	      IFNCONST	aiGenerateMoves
      2  24de				  -	      ECHO	"Incorrect VEND label", aiGenerateMoves
      3  24de				  -	      ERR
      4  24de					      ENDIF
      5  24de		       00 a2	   VAREND_aiGenerateMoves =	TEMPORARY_VAR
    244  24de
    245  24de							; Player comes here at the start of making a move
    246  24de							; This generates a valid movelist by calling 'negaMax' (removing illegal moves)
    247  24de
    248  24de		       a5 86		      lda	toX12
    249  24e0		       85 80		      sta	squareToDraw	; for showing move (display square)
    250  24e2
    251  24e2		       a6 96		      ldx	sideToMove
    252  24e4		       10 05		      bpl	.player
    253  24e6
    254  24e6
      0  24e6				   .computer  PHASE	AI_ComputerMove	; computer select move
      1  24e6		       a9 13		      lda	#AI_ComputerMove
      2  24e8		       85 8c		      sta	aiState
    256  24ea		       60		      rts
    257  24eb
    258  24eb
      0  24eb				   .player    PHASE	AI_StartMoveGen
      1  24eb		       a9 0b		      lda	#AI_StartMoveGen
      2  24ed		       85 8c		      sta	aiState
    260  24ef		       60		      rts
    261  24f0
    262  24f0
    263  24f0							;---------------------------------------------------------------------------------------------------
    264  24f0
      0  24f0					      DEF	aiStepMoveGen
      1  24f0				   SLOT_aiStepMoveGen SET	_BANK_SLOT
      2  24f0				   BANK_aiStepMoveGen SET	SLOT_aiStepMoveGen + _CURRENT_BANK
      3  24f0				   aiStepMoveGen
      4  24f0				   TEMPORARY_VAR SET	Overlay
      5  24f0				   TEMPORARY_OFFSET SET	0
      6  24f0				   VAR_BOUNDARY_aiStepMoveGen SET	TEMPORARY_OFFSET
      7  24f0				   FUNCTION_NAME SET	aiStepMoveGen
    266  24f0					      SUBROUTINE
    267  24f0
      0  24f0					      REFER	AiStateMachine
      1  24f0				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  24f0				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  24f0					      ENDIF
      0  24f0					      VEND	aiStepMoveGen
      1  24f0				  -	      IFNCONST	aiStepMoveGen
      2  24f0				  -	      ECHO	"Incorrect VEND label", aiStepMoveGen
      3  24f0				  -	      ERR
      4  24f0					      ENDIF
      5  24f0		       00 a2	   VAREND_aiStepMoveGen =	TEMPORARY_VAR
    270  24f0
    271  24f0		       a5 87		      lda	originX12	; location of cursor (show move)
    272  24f2		       85 88		      sta	cursorX12
      0  24f4					      PHASE	AI_BeginSelectMovePhase
      1  24f4		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  24f6		       85 8c		      sta	aiState
    274  24f8		       60		      rts
    275  24f9
    276  24f9
    277  24f9							;---------------------------------------------------------------------------------------------------
    278  24f9
    279  2500		       00 00 00 00*	      align	256
      0  2500					      DEF	PositionSprites
      1  2500				   SLOT_PositionSprites SET	_BANK_SLOT
      2  2500				   BANK_PositionSprites SET	SLOT_PositionSprites + _CURRENT_BANK
      3  2500				   PositionSprites
      4  2500				   TEMPORARY_VAR SET	Overlay
      5  2500				   TEMPORARY_OFFSET SET	0
      6  2500				   VAR_BOUNDARY_PositionSprites SET	TEMPORARY_OFFSET
      7  2500				   FUNCTION_NAME SET	PositionSprites
    281  2500					      SUBROUTINE
    282  2500
      0  2500					      REFER	StartupBankReset
      1  2500				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  2500				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  2500					      ENDIF
      0  2500					      VEND	PositionSprites
      1  2500				  -	      IFNCONST	PositionSprites
      2  2500				  -	      ECHO	"Incorrect VEND label", PositionSprites
      3  2500				  -	      ERR
      4  2500					      ENDIF
      5  2500		       00 a2	   VAREND_PositionSprites =	TEMPORARY_VAR
    285  2500
    286  2500
    287  2500		       a5 88		      lda	cursorX12
    288  2502		       38		      sec
    289  2503		       e9 0a	   .sub10     sbc	#10
    290  2505		       b0 fc		      bcs	.sub10
    291  2507		       69 08		      adc	#8
    292  2509		       a8		      tay
    293  250a
    294  250a		       85 42		      sta	WSYNC	; 00	  Sync to start of scanline.
    295  250c
    296  250c		       b9 30 f5 	      lda	colToPixel,y
    297  250f
    298  250f		       38		      sec		; 02	  Set the carry flag so no borrow will be applied during the division.
    299  2510		       e9 0f	   .divideby15 sbc	#15	; 04	  Waste the necessary amount of time dividing X-pos by 15!
    300  2512		       b0 fc		      bcs	.divideby15	; 06/07  11/16/21/26/31/36/41/46/51/56/61/66
    301  2514
    302  2514		       a8		      tay
    303  2515		       b9 30 f4 	      lda	fineAdjustTable,y	; 13 -> Consume 5 cycles by guaranteeing we cross a page boundary
    304  2518		       85 60		      sta	HMP0
    305  251a		       85 50		      sta	RESP0	; 21/ 26/31/36/41/46/51/56/61/66/71 - Set the rough position.
    306  251c
    307  251c		       85 42		      sta	WSYNC
    308  251e		       85 6a		      sta	HMOVE
    309  2520
    310  2520		       60		      rts
    311  2521
    312  2521							; This table converts the "remainder" of the division by 15 (-1 to -15) to the correct
    313  2521							; fine adjustment value. This table is on a page boundary to guarantee the processor
    314  2521							; will cross a page boundary and waste a cycle in order to be at the precise position
    315  2521							; for a RESP0,x write
    316  2521
    317  2521				   fineAdjustBegin
    318  2521
    319  2521		       70		      DC.B	%01110000	; Left 7
    320  2522		       60		      DC.B	%01100000	; Left 6
    321  2523		       50		      DC.B	%01010000	; Left 5
    322  2524		       40		      DC.B	%01000000	; Left 4
    323  2525		       30		      DC.B	%00110000	; Left 3
    324  2526		       20		      DC.B	%00100000	; Left 2
    325  2527		       10		      DC.B	%00010000	; Left 1
    326  2528		       00		      DC.B	%00000000	; No movement.
    327  2529		       f0		      DC.B	%11110000	; Right 1
    328  252a		       e0		      DC.B	%11100000	; Right 2
    329  252b		       d0		      DC.B	%11010000	; Right 3
    330  252c		       c0		      DC.B	%11000000	; Right 4
    331  252d		       b0		      DC.B	%10110000	; Right 5
    332  252e		       a0		      DC.B	%10100000	; Right 6
    333  252f		       90		      DC.B	%10010000	; Right 7
    334  2530
    335  2530		       f4 30	   fineAdjustTable EQU	fineAdjustBegin - %11110001	; NOTE: %11110001 = -15
    336  2530
    337  2530
      0  2530					      ALLOCATE	colToPixel, 8
      0  2530					      OPTIONAL_PAGEBREAK	"Table", 8
     12  2530					      LIST	ON
      0  2530					      DEF	colToPixel
      1  2530				   SLOT_colToPixel SET	_BANK_SLOT
      2  2530				   BANK_colToPixel SET	SLOT_colToPixel + _CURRENT_BANK
      3  2530				   colToPixel
      4  2530				   TEMPORARY_VAR SET	Overlay
      5  2530				   TEMPORARY_OFFSET SET	0
      6  2530				   VAR_BOUNDARY_colToPixel SET	TEMPORARY_OFFSET
      7  2530				   FUNCTION_NAME SET	colToPixel
    339  2530		       00 14 28 3c*	      .byte.b	0,20,40,60,80,100,120,140
    340  2538
    341  2538							;---------------------------------------------------------------------------------------------------
    342  2538
    343  2538
      0  2538					      CHECK_BANK_SIZE	"BANK_StateMachine2"
      1  2538		       01 38	   .TEMP      =	* - _BANK_START
 BANK_StateMachine2 (1K) SIZE =  $138 , FREE= $2c8
      2  2538					      ECHO	"BANK_StateMachine2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2538				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2538				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_StateMachine2", " size=", * - ORIGIN
      5  2538				  -	      ERR
      6  2538					      ENDIF
    345  2538
    346  2538
    347  2538							;---------------------------------------------------------------------------------------------------
    348  2538
    349  2538							; EOF
------- FILE ./chess.asm
------- FILE BANK_RECON.asm LEVEL 2 PASS 4
      0  2538					      include	"BANK_RECON.asm"
      0  2538					      SLOT	1
      1  2538				  -	      IF	(1 < 0) || (1 > 3)
      2  2538				  -	      ECHO	"Illegal bank address/segment location", 1
      3  2538				  -	      ERR
      4  2538					      ENDIF
      5  2538				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  2538				   _BANK_SLOT SET	1 * 64
      0  2538					      NEWBANK	RECON
      1  285d ????				      SEG	RECON
      2  2800					      ORG	_ORIGIN
      3  2800					      RORG	_BANK_ADDRESS_ORIGIN
      4  2800				   _BANK_START SET	*
      5  2800				   RECON_START SET	*
      6  2800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2800				   RECON      SET	_BANK_SLOT + _CURRENT_BANK
      8  2800				   _ORIGIN    SET	_ORIGIN + 1024
      3  2800
      4  2800							;---------------------------------------------------------------------------------------------------
      5  2800
      0  2800					      DEF	SAFE_showMoveCaptures
      1  2800				   SLOT_SAFE_showMoveCaptures SET	_BANK_SLOT
      2  2800				   BANK_SAFE_showMoveCaptures SET	SLOT_SAFE_showMoveCaptures + _CURRENT_BANK
      3  2800				   SAFE_showMoveCaptures
      4  2800				   TEMPORARY_VAR SET	Overlay
      5  2800				   TEMPORARY_OFFSET SET	0
      6  2800				   VAR_BOUNDARY_SAFE_showMoveCaptures SET	TEMPORARY_OFFSET
      7  2800				   FUNCTION_NAME SET	SAFE_showMoveCaptures
      7  2800					      SUBROUTINE
      8  2800
      0  2800					      VEND	SAFE_showMoveCaptures
      1  2800				  -	      IFNCONST	SAFE_showMoveCaptures
      2  2800				  -	      ECHO	"Incorrect VEND label", SAFE_showMoveCaptures
      3  2800				  -	      ERR
      4  2800					      ENDIF
      5  2800		       00 a2	   VAREND_SAFE_showMoveCaptures =	TEMPORARY_VAR
     10  2800
     11  2800		       20 08 f4 	      jsr	UNSAFE_showMoveCaptures
     12  2803		       a5 8b		      lda	savedBank
     13  2805		       85 3f		      sta	SET_BANK
     14  2807		       60		      rts
     15  2808
     16  2808
     17  2808							;---------------------------------------------------------------------------------------------------
     18  2808
      0  2808					      DEF	UNSAFE_showMoveCaptures
      1  2808				   SLOT_UNSAFE_showMoveCaptures SET	_BANK_SLOT
      2  2808				   BANK_UNSAFE_showMoveCaptures SET	SLOT_UNSAFE_showMoveCaptures + _CURRENT_BANK
      3  2808				   UNSAFE_showMoveCaptures
      4  2808				   TEMPORARY_VAR SET	Overlay
      5  2808				   TEMPORARY_OFFSET SET	0
      6  2808				   VAR_BOUNDARY_UNSAFE_showMoveCaptures SET	TEMPORARY_OFFSET
      7  2808				   FUNCTION_NAME SET	UNSAFE_showMoveCaptures
     20  2808					      SUBROUTINE
     21  2808
      0  2808					      REFER	SAFE_showMoveCaptures
      1  2808				  -	      IF	VAREND_SAFE_showMoveCaptures > TEMPORARY_VAR
      2  2808				  -TEMPORARY_VAR SET	VAREND_SAFE_showMoveCaptures
      3  2808					      ENDIF
      0  2808					      VAR	__toSquareX12, 1
      1  2808		       00 a2	   __toSquareX12 =	TEMPORARY_VAR
      2  2808				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  2808
      4  2808				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  2808				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  2808				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  2808					      ENDIF
      8  2808				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  2808				  -	      ECHO	"Temporary Variable", __toSquareX12, "overflow!"
     10  2808				  -	      ERR
     11  2808					      ENDIF
     12  2808					      LIST	ON
      0  2808					      VAR	__fromPiece, 1
      1  2808		       00 a3	   __fromPiece =	TEMPORARY_VAR
      2  2808				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  2808
      4  2808				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  2808				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  2808				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  2808					      ENDIF
      8  2808				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  2808				  -	      ECHO	"Temporary Variable", __fromPiece, "overflow!"
     10  2808				  -	      ERR
     11  2808					      ENDIF
     12  2808					      LIST	ON
      0  2808					      VAR	__aiMoveIndex, 1
      1  2808		       00 a4	   __aiMoveIndex =	TEMPORARY_VAR
      2  2808				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  2808
      4  2808				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  2808				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  2808				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  2808					      ENDIF
      8  2808				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  2808				  -	      ECHO	"Temporary Variable", __aiMoveIndex, "overflow!"
     10  2808				  -	      ERR
     11  2808					      ENDIF
     12  2808					      LIST	ON
      0  2808					      VEND	UNSAFE_showMoveCaptures
      1  2808				  -	      IFNCONST	UNSAFE_showMoveCaptures
      2  2808				  -	      ECHO	"Incorrect VEND label", UNSAFE_showMoveCaptures
      3  2808				  -	      ERR
      4  2808					      ENDIF
      5  2808		       00 a5	   VAREND_UNSAFE_showMoveCaptures =	TEMPORARY_VAR
     27  2808
     28  2808							; place a marker on the board for any square matching the piece
     29  2808							; EXCEPT for squares which are occupied (we'll flash those later)
     30  2808							; x = movelist item # being checked
     31  2808
     32  2808		       a5 8b		      lda	savedBank
     33  280a		       48		      pha
     34  280b
     35  280b		       a9 4a		      lda	#BANK_UNSAFE_showMoveCaptures
     36  280d		       85 8b		      sta	savedBank
     37  280f
     38  280f
     39  280f		       a6 8e	   .next      ldx	aiMoveIndex
     40  2811		       86 a4		      stx	__aiMoveIndex
     41  2813		       30 3a		      bmi	.skip	; no moves in list
     42  2815
     43  2815		       ad 84 02 	      lda	INTIM
     44  2818		       c9 14		      cmp	#20
     45  281a		       90 33		      bcc	.skip
     46  281c
     47  281c		       c6 8e		      dec	aiMoveIndex
     48  281e
     49  281e		       20 4b f5 	      jsr	GetP_MoveFrom
     50  2821		       c5 85		      cmp	fromX12
     51  2823		       d0 ea		      bne	.next
     52  2825
     53  2825
     54  2825		       20 57 f5 	      jsr	GetP_MoveTo
     55  2828		       85 a2		      sta	__toSquareX12
     56  282a		       a8		      tay
     57  282b		       20 14 f6 	      jsr	GetBoard
     58  282e		       29 0f		      and	#PIECE_MASK
     59  2830		       f0 dd		      beq	.next
     60  2832
     61  2832							; There's something on the board at destination, so it's a capture
     62  2832							; Let's see if we are doing a pawn promote...
     63  2832
     64  2832		       a4 85		      ldy	fromX12
     65  2834		       20 14 f6 	      jsr	GetBoard
     66  2837		       85 a3		      sta	__fromPiece
     67  2839
     68  2839		       20 6f f5 	      jsr	GetP_MovePiece
     69  283c		       45 a3		      eor	__fromPiece
     70  283e		       29 0f		      and	#PIECE_MASK
     71  2840		       f0 06		      beq	.legit	; from == to, so not a promote
     72  2842
     73  2842							; Have detected a promotion duplicate - skip all 3 of them
     74  2842
     75  2842		       c6 8e		      dec	aiMoveIndex	; skip "KBRQ" promotes
     76  2844		       c6 8e		      dec	aiMoveIndex
     77  2846		       c6 8e		      dec	aiMoveIndex
     78  2848
     79  2848				   .legit
     80  2848
     81  2848							;TIMECHECK COPYSINGLEPIECE, restoreIndex     ; not enough time to draw
     82  2848
     83  2848		       a5 a2		      lda	__toSquareX12
     84  284a		       85 80		      sta	squareToDraw
     85  284c
     86  284c		       20 98 f0 	      jsr	CopySinglePiece	;@0
     87  284f
     88  284f		       68	   .skip      pla
     89  2850		       85 8b		      sta	savedBank
     90  2852		       60		      rts
     91  2853
     92  2853
     93  2853							;---------------------------------------------------------------------------------------------------
     94  2853
      0  2853					      DEF	showPromoteOptions
      1  2853				   SLOT_showPromoteOptions SET	_BANK_SLOT
      2  2853				   BANK_showPromoteOptions SET	SLOT_showPromoteOptions + _CURRENT_BANK
      3  2853				   showPromoteOptions
      4  2853				   TEMPORARY_VAR SET	Overlay
      5  2853				   TEMPORARY_OFFSET SET	0
      6  2853				   VAR_BOUNDARY_showPromoteOptions SET	TEMPORARY_OFFSET
      7  2853				   FUNCTION_NAME SET	showPromoteOptions
     96  2853					      SUBROUTINE
     97  2853
      0  2853					      REFER	aiRollPromotionPiece
      1  2853				  -	      IF	VAREND_aiRollPromotionPiece > TEMPORARY_VAR
      2  2853				  -TEMPORARY_VAR SET	VAREND_aiRollPromotionPiece
      3  2853					      ENDIF
      0  2853					      REFER	aiChoosePromotePiece
      1  2853				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  2853				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  2853					      ENDIF
      0  2853					      VEND	showPromoteOptions
      1  2853				  -	      IFNCONST	showPromoteOptions
      2  2853				  -	      ECHO	"Incorrect VEND label", showPromoteOptions
      3  2853				  -	      ERR
      4  2853					      ENDIF
      5  2853		       00 a2	   VAREND_showPromoteOptions =	TEMPORARY_VAR
    101  2853
    102  2853							; X = character shape # (?/N/B/R/Q)
    103  2853
    104  2853		       a4 86		      ldy	toX12
    105  2855		       84 80		      sty	squareToDraw
    106  2857
    107  2857		       20 ce f4 	      jsr	CopySetupForMarker
    108  285a		       4c 9f f0 	      jmp	InterceptMarkerCopy
    109  285d
    110  285d
    111  285d
    112  285d							;---------------------------------------------------------------------------------------------------
    113  285d
    114  285d
      0  285d					      CHECK_BANK_SIZE	"BANK_RECON"
      1  285d		       00 5d	   .TEMP      =	* - _BANK_START
 BANK_RECON (1K) SIZE =  $5d , FREE= $3a3
      2  285d					      ECHO	"BANK_RECON", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  285d				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  285d				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_RECON", " size=", * - ORIGIN
      5  285d				  -	      ERR
      6  285d					      ENDIF
    116  285d
    117  285d							; EOF
------- FILE ./chess.asm
------- FILE piece_graphics.asm LEVEL 2 PASS 4
      0  285d					      include	"piece_graphics.asm"
      1  285d							; Import the graphics definitions generated by ConvertChessPieces.py
      2  285d
      0  285d					      SLOT	2
      1  285d				  -	      IF	(2 < 0) || (2 > 3)
      2  285d				  -	      ECHO	"Illegal bank address/segment location", 2
      3  285d				  -	      ERR
      4  285d					      ENDIF
      5  285d				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  285d				   _BANK_SLOT SET	2 * 64
      0  285d					      NEWBANK	PIECES_0
      1  2fd8 ????				      SEG	PIECES_0
      2  2c00					      ORG	_ORIGIN
      3  2c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  2c00				   _BANK_START SET	*
      5  2c00				   PIECES_0_START SET	*
      6  2c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2c00				   PIECES_0   SET	_BANK_SLOT + _CURRENT_BANK
      8  2c00				   _ORIGIN    SET	_ORIGIN + 1024
      5  2c00
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2c00					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm"
      0  2c00					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_0", 72
     12  2c00					      LIST	ON
      0  2c00					      DEF	WHITE_BLANK_on_WHITE_SQUARE_0
      1  2c00				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2c00				   BANK_WHITE_BLANK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2c00				   WHITE_BLANK_on_WHITE_SQUARE_0
      4  2c00				   TEMPORARY_VAR SET	Overlay
      5  2c00				   TEMPORARY_OFFSET SET	0
      6  2c00				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2c00				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_0
      3  2c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$e0,$f0,$f0,$f0,$f0,$f0,$f0,$e0	;PF0
      4  2c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$00	;PF1
      5  2c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2c48					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm"
      0  2c48					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_1", 72
     12  2c48					      LIST	ON
      0  2c48					      DEF	WHITE_BLANK_on_WHITE_SQUARE_1
      1  2c48				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2c48				   BANK_WHITE_BLANK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2c48				   WHITE_BLANK_on_WHITE_SQUARE_1
      4  2c48				   TEMPORARY_VAR SET	Overlay
      5  2c48				   TEMPORARY_OFFSET SET	0
      6  2c48				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2c48				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_1
      3  2c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$38,$7c,$7c,$7c,$7c,$7c,$7c,$38	;PF1
      5  2c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2c90					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm"
      0  2c90					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_2", 72
     12  2c90					      LIST	ON
      0  2c90					      DEF	WHITE_BLANK_on_WHITE_SQUARE_2
      1  2c90				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2c90				   BANK_WHITE_BLANK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2c90				   WHITE_BLANK_on_WHITE_SQUARE_2
      4  2c90				   TEMPORARY_VAR SET	Overlay
      5  2c90				   TEMPORARY_OFFSET SET	0
      6  2c90				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2c90				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_2
      3  2c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$03,$03,$03,$01	;PF1
      5  2cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$07,$07,$07,$07,$07,$07,$03	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2cd8					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm"
      0  2cd8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_3", 72
     12  2d00					      LIST	ON
      0  2d00					      DEF	WHITE_BLANK_on_WHITE_SQUARE_3
      1  2d00				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2d00				   BANK_WHITE_BLANK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2d00				   WHITE_BLANK_on_WHITE_SQUARE_3
      4  2d00				   TEMPORARY_VAR SET	Overlay
      5  2d00				   TEMPORARY_OFFSET SET	0
      6  2d00				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2d00				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_3
      3  2d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$70,$f8,$f8,$f8,$f8,$f8,$f8,$70	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2d48					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm"
      0  2d48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_0", 72
     12  2d48					      LIST	ON
      0  2d48					      DEF	WHITE_PAWN_on_WHITE_SQUARE_0
      1  2d48				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2d48				   BANK_WHITE_PAWN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2d48				   WHITE_PAWN_on_WHITE_SQUARE_0
      4  2d48				   TEMPORARY_VAR SET	Overlay
      5  2d48				   TEMPORARY_OFFSET SET	0
      6  2d48				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2d48				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_0
      3  2d48		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2d90					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm"
      0  2d90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_1", 72
     12  2d90					      LIST	ON
      0  2d90					      DEF	WHITE_PAWN_on_WHITE_SQUARE_1
      1  2d90				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2d90				   BANK_WHITE_PAWN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2d90				   WHITE_PAWN_on_WHITE_SQUARE_1
      4  2d90				   TEMPORARY_VAR SET	Overlay
      5  2d90				   TEMPORARY_OFFSET SET	0
      6  2d90				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2d90				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_1
      3  2d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2da8		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2dd8					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm"
      0  2dd8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_2", 72
     12  2e00					      LIST	ON
      0  2e00					      DEF	WHITE_PAWN_on_WHITE_SQUARE_2
      1  2e00				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2e00				   BANK_WHITE_PAWN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2e00				   WHITE_PAWN_on_WHITE_SQUARE_2
      4  2e00				   TEMPORARY_VAR SET	Overlay
      5  2e00				   TEMPORARY_OFFSET SET	0
      6  2e00				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2e00				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_2
      3  2e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e18		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e30		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2e48					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm"
      0  2e48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_3", 72
     12  2e48					      LIST	ON
      0  2e48					      DEF	WHITE_PAWN_on_WHITE_SQUARE_3
      1  2e48				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2e48				   BANK_WHITE_PAWN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2e48				   WHITE_PAWN_on_WHITE_SQUARE_3
      4  2e48				   TEMPORARY_VAR SET	Overlay
      5  2e48				   TEMPORARY_OFFSET SET	0
      6  2e48				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2e48				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_3
      3  2e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e78		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2e90					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  2e90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_0", 72
     12  2e90					      LIST	ON
      0  2e90					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_0
      1  2e90				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2e90				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2e90				   WHITE_KNIGHT_on_WHITE_SQUARE_0
      4  2e90				   TEMPORARY_VAR SET	Overlay
      5  2e90				   TEMPORARY_OFFSET SET	0
      6  2e90				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2e90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_0
      3  2e90		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$10,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ea8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2ed8					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  2ed8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_1", 72
     12  2f00					      LIST	ON
      0  2f00					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_1
      1  2f00				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2f00				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2f00				   WHITE_KNIGHT_on_WHITE_SQUARE_1
      4  2f00				   TEMPORARY_VAR SET	Overlay
      5  2f00				   TEMPORARY_OFFSET SET	0
      6  2f00				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2f00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_1
      3  2f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f18		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$44,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2f48					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  2f48					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_2", 72
     12  2f48					      LIST	ON
      0  2f48					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_2
      1  2f48				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2f48				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2f48				   WHITE_KNIGHT_on_WHITE_SQUARE_2
      4  2f48				   TEMPORARY_VAR SET	Overlay
      5  2f48				   TEMPORARY_OFFSET SET	0
      6  2f48				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2f48				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_2
      3  2f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f60		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$02,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2f78		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$04,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2f90					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  2f90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_3", 72
     12  2f90					      LIST	ON
      0  2f90					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_3
      1  2f90				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2f90				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2f90				   WHITE_KNIGHT_on_WHITE_SQUARE_3
      4  2f90				   TEMPORARY_VAR SET	Overlay
      5  2f90				   TEMPORARY_OFFSET SET	0
      6  2f90				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2f90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_3
      3  2f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2fc0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$88,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  2fd8					      CHECK_BANK_SIZE	"PIECE_0 (1K)"
      1  2fd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_0 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  2fd8					      ECHO	"PIECE_0 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2fd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_0 (1K)", " size=", * - ORIGIN
      5  2fd8				  -	      ERR
      6  2fd8					      ENDIF
     19  2fd8
      0  2fd8					      SLOT	2
      1  2fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  2fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  2fd8				  -	      ERR
      4  2fd8					      ENDIF
      5  2fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  2fd8				   _BANK_SLOT SET	2 * 64
      0  2fd8					      NEWBANK	PIECES_1
      1  33d8 ????				      SEG	PIECES_1
      2  3000					      ORG	_ORIGIN
      3  3000					      RORG	_BANK_ADDRESS_ORIGIN
      4  3000				   _BANK_START SET	*
      5  3000				   PIECES_1_START SET	*
      6  3000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3000				   PIECES_1   SET	_BANK_SLOT + _CURRENT_BANK
      8  3000				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3000					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm"
      0  3000					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_0", 72
     12  3000					      LIST	ON
      0  3000					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_0
      1  3000				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3000				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3000				   WHITE_BISHOP_on_WHITE_SQUARE_0
      4  3000				   TEMPORARY_VAR SET	Overlay
      5  3000				   TEMPORARY_OFFSET SET	0
      6  3000				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3000				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_0
      3  3000		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$10,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3018		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3048					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm"
      0  3048					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_1", 72
     12  3048					      LIST	ON
      0  3048					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_1
      1  3048				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3048				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3048				   WHITE_BISHOP_on_WHITE_SQUARE_1
      4  3048				   TEMPORARY_VAR SET	Overlay
      5  3048				   TEMPORARY_OFFSET SET	0
      6  3048				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3048				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_1
      3  3048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3060		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$44,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3090					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm"
      0  3090					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_2", 72
     12  3090					      LIST	ON
      0  3090					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_2
      1  3090				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3090				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3090				   WHITE_BISHOP_on_WHITE_SQUARE_2
      4  3090				   TEMPORARY_VAR SET	Overlay
      5  3090				   TEMPORARY_OFFSET SET	0
      6  3090				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3090				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_2
      3  3090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  30a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$02,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  30c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$04,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  30d8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm"
      0  30d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_3", 72
     12  3100					      LIST	ON
      0  3100					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_3
      1  3100				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3100				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3100				   WHITE_BISHOP_on_WHITE_SQUARE_3
      4  3100				   TEMPORARY_VAR SET	Overlay
      5  3100				   TEMPORARY_OFFSET SET	0
      6  3100				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3100				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_3
      3  3100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3130		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$88,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3148					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm"
      0  3148					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_0", 72
     12  3148					      LIST	ON
      0  3148					      DEF	WHITE_ROOK_on_WHITE_SQUARE_0
      1  3148				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3148				   BANK_WHITE_ROOK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3148				   WHITE_ROOK_on_WHITE_SQUARE_0
      4  3148				   TEMPORARY_VAR SET	Overlay
      5  3148				   TEMPORARY_OFFSET SET	0
      6  3148				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3148				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_0
      3  3148		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$10,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3160		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3190					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm"
      0  3190					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_1", 72
     12  3190					      LIST	ON
      0  3190					      DEF	WHITE_ROOK_on_WHITE_SQUARE_1
      1  3190				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3190				   BANK_WHITE_ROOK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3190				   WHITE_ROOK_on_WHITE_SQUARE_1
      4  3190				   TEMPORARY_VAR SET	Overlay
      5  3190				   TEMPORARY_OFFSET SET	0
      6  3190				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3190				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_1
      3  3190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  31a8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$44,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  31c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  31d8					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm"
      0  31d8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_2", 72
     12  3200					      LIST	ON
      0  3200					      DEF	WHITE_ROOK_on_WHITE_SQUARE_2
      1  3200				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3200				   BANK_WHITE_ROOK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3200				   WHITE_ROOK_on_WHITE_SQUARE_2
      4  3200				   TEMPORARY_VAR SET	Overlay
      5  3200				   TEMPORARY_OFFSET SET	0
      6  3200				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3200				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_2
      3  3200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3218		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$02,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3230		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$04,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3248					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm"
      0  3248					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_3", 72
     12  3248					      LIST	ON
      0  3248					      DEF	WHITE_ROOK_on_WHITE_SQUARE_3
      1  3248				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3248				   BANK_WHITE_ROOK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3248				   WHITE_ROOK_on_WHITE_SQUARE_3
      4  3248				   TEMPORARY_VAR SET	Overlay
      5  3248				   TEMPORARY_OFFSET SET	0
      6  3248				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3248				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_3
      3  3248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3278		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$88,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3290					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm"
      0  3290					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_0", 72
     12  3290					      LIST	ON
      0  3290					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_0
      1  3290				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3290				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3290				   WHITE_QUEEN_on_WHITE_SQUARE_0
      4  3290				   TEMPORARY_VAR SET	Overlay
      5  3290				   TEMPORARY_OFFSET SET	0
      6  3290				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3290				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_0
      3  3290		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  32a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  32c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  32d8					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm"
      0  32d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_1", 72
     12  3300					      LIST	ON
      0  3300					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_1
      1  3300				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3300				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3300				   WHITE_QUEEN_on_WHITE_SQUARE_1
      4  3300				   TEMPORARY_VAR SET	Overlay
      5  3300				   TEMPORARY_OFFSET SET	0
      6  3300				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3300				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_1
      3  3300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3318		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3348					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm"
      0  3348					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_2", 72
     12  3348					      LIST	ON
      0  3348					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_2
      1  3348				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3348				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3348				   WHITE_QUEEN_on_WHITE_SQUARE_2
      4  3348				   TEMPORARY_VAR SET	Overlay
      5  3348				   TEMPORARY_OFFSET SET	0
      6  3348				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3348				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_2
      3  3348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3360		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3378		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3390					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm"
      0  3390					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_3", 72
     12  3390					      LIST	ON
      0  3390					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_3
      1  3390				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3390				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3390				   WHITE_QUEEN_on_WHITE_SQUARE_3
      4  3390				   TEMPORARY_VAR SET	Overlay
      5  3390				   TEMPORARY_OFFSET SET	0
      6  3390				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3390				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_3
      3  3390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  33a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  33c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  33d8					      CHECK_BANK_SIZE	"PIECE_1 (1K)"
      1  33d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_1 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  33d8					      ECHO	"PIECE_1 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  33d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  33d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_1 (1K)", " size=", * - ORIGIN
      5  33d8				  -	      ERR
      6  33d8					      ENDIF
      0  33d8					      SLOT	2
      1  33d8				  -	      IF	(2 < 0) || (2 > 3)
      2  33d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  33d8				  -	      ERR
      4  33d8					      ENDIF
      5  33d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  33d8				   _BANK_SLOT SET	2 * 64
      0  33d8					      NEWBANK	PIECES_2
      1  37d8 ????				      SEG	PIECES_2
      2  3400					      ORG	_ORIGIN
      3  3400					      RORG	_BANK_ADDRESS_ORIGIN
      4  3400				   _BANK_START SET	*
      5  3400				   PIECES_2_START SET	*
      6  3400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3400				   PIECES_2   SET	_BANK_SLOT + _CURRENT_BANK
      8  3400				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3400					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_0.asm"
      0  3400					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_0", 72
     12  3400					      LIST	ON
      0  3400					      DEF	WHITE_KING_on_WHITE_SQUARE_0
      1  3400				   SLOT_WHITE_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3400				   BANK_WHITE_KING_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3400				   WHITE_KING_on_WHITE_SQUARE_0
      4  3400				   TEMPORARY_VAR SET	Overlay
      5  3400				   TEMPORARY_OFFSET SET	0
      6  3400				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3400				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_0
      3  3400		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$80,$40,$00,$00	;PF0
      4  3418		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3448					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_1.asm"
      0  3448					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_1", 72
     12  3448					      LIST	ON
      0  3448					      DEF	WHITE_KING_on_WHITE_SQUARE_1
      1  3448				   SLOT_WHITE_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3448				   BANK_WHITE_KING_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3448				   WHITE_KING_on_WHITE_SQUARE_1
      4  3448				   TEMPORARY_VAR SET	Overlay
      5  3448				   TEMPORARY_OFFSET SET	0
      6  3448				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3448				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_1
      3  3448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3460		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$08,$10,$00,$00	;PF1
      5  3478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3490					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_2.asm"
      0  3490					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_2", 72
     12  3490					      LIST	ON
      0  3490					      DEF	WHITE_KING_on_WHITE_SQUARE_2
      1  3490				   SLOT_WHITE_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3490				   BANK_WHITE_KING_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3490				   WHITE_KING_on_WHITE_SQUARE_2
      4  3490				   TEMPORARY_VAR SET	Overlay
      5  3490				   TEMPORARY_OFFSET SET	0
      6  3490				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3490				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_2
      3  3490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  34a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  34c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$02,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  34d8					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_3.asm"
      0  34d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_3", 72
     12  3500					      LIST	ON
      0  3500					      DEF	WHITE_KING_on_WHITE_SQUARE_3
      1  3500				   SLOT_WHITE_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3500				   BANK_WHITE_KING_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3500				   WHITE_KING_on_WHITE_SQUARE_3
      4  3500				   TEMPORARY_VAR SET	Overlay
      5  3500				   TEMPORARY_OFFSET SET	0
      6  3500				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3500				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_3
      3  3500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3530		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$40,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3548					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm"
      0  3548					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_0", 72
     12  3548					      LIST	ON
      0  3548					      DEF	WHITE_BLANK_on_BLACK_SQUARE_0
      1  3548				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3548				   BANK_WHITE_BLANK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3548				   WHITE_BLANK_on_BLACK_SQUARE_0
      4  3548				   TEMPORARY_VAR SET	Overlay
      5  3548				   TEMPORARY_OFFSET SET	0
      6  3548				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3548				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_0
      3  3548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3590					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm"
      0  3590					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_1", 72
     12  3590					      LIST	ON
      0  3590					      DEF	WHITE_BLANK_on_BLACK_SQUARE_1
      1  3590				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3590				   BANK_WHITE_BLANK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3590				   WHITE_BLANK_on_BLACK_SQUARE_1
      4  3590				   TEMPORARY_VAR SET	Overlay
      5  3590				   TEMPORARY_OFFSET SET	0
      6  3590				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3590				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_1
      3  3590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  35a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  35c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  35d8					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm"
      0  35d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_2", 72
     12  3600					      LIST	ON
      0  3600					      DEF	WHITE_BLANK_on_BLACK_SQUARE_2
      1  3600				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3600				   BANK_WHITE_BLANK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3600				   WHITE_BLANK_on_BLACK_SQUARE_2
      4  3600				   TEMPORARY_VAR SET	Overlay
      5  3600				   TEMPORARY_OFFSET SET	0
      6  3600				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3600				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_2
      3  3600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3630		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3648					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm"
      0  3648					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_3", 72
     12  3648					      LIST	ON
      0  3648					      DEF	WHITE_BLANK_on_BLACK_SQUARE_3
      1  3648				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3648				   BANK_WHITE_BLANK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3648				   WHITE_BLANK_on_BLACK_SQUARE_3
      4  3648				   TEMPORARY_VAR SET	Overlay
      5  3648				   TEMPORARY_OFFSET SET	0
      6  3648				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3648				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_3
      3  3648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3678		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3690					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm"
      0  3690					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_0", 72
     12  3690					      LIST	ON
      0  3690					      DEF	WHITE_PAWN_on_BLACK_SQUARE_0
      1  3690				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3690				   BANK_WHITE_PAWN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3690				   WHITE_PAWN_on_BLACK_SQUARE_0
      4  3690				   TEMPORARY_VAR SET	Overlay
      5  3690				   TEMPORARY_OFFSET SET	0
      6  3690				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3690				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_0
      3  3690		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  36a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  36c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  36d8					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm"
      0  36d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_1", 72
     12  3700					      LIST	ON
      0  3700					      DEF	WHITE_PAWN_on_BLACK_SQUARE_1
      1  3700				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3700				   BANK_WHITE_PAWN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3700				   WHITE_PAWN_on_BLACK_SQUARE_1
      4  3700				   TEMPORARY_VAR SET	Overlay
      5  3700				   TEMPORARY_OFFSET SET	0
      6  3700				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3700				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_1
      3  3700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3718		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  3730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3748					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm"
      0  3748					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_2", 72
     12  3748					      LIST	ON
      0  3748					      DEF	WHITE_PAWN_on_BLACK_SQUARE_2
      1  3748				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3748				   BANK_WHITE_PAWN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3748				   WHITE_PAWN_on_BLACK_SQUARE_2
      4  3748				   TEMPORARY_VAR SET	Overlay
      5  3748				   TEMPORARY_OFFSET SET	0
      6  3748				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3748				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_2
      3  3748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3760		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  3778		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3790					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm"
      0  3790					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_3", 72
     12  3790					      LIST	ON
      0  3790					      DEF	WHITE_PAWN_on_BLACK_SQUARE_3
      1  3790				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3790				   BANK_WHITE_PAWN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3790				   WHITE_PAWN_on_BLACK_SQUARE_3
      4  3790				   TEMPORARY_VAR SET	Overlay
      5  3790				   TEMPORARY_OFFSET SET	0
      6  3790				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3790				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_3
      3  3790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  37a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  37c0		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
      0  37d8					      CHECK_BANK_SIZE	"PIECE_2 (1K)"
      1  37d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_2 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  37d8					      ECHO	"PIECE_2 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  37d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  37d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_2 (1K)", " size=", * - ORIGIN
      5  37d8				  -	      ERR
      6  37d8					      ENDIF
      0  37d8					      SLOT	2
      1  37d8				  -	      IF	(2 < 0) || (2 > 3)
      2  37d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  37d8				  -	      ERR
      4  37d8					      ENDIF
      5  37d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  37d8				   _BANK_SLOT SET	2 * 64
      0  37d8					      NEWBANK	PIECES_3
      1  3bd8 ????				      SEG	PIECES_3
      2  3800					      ORG	_ORIGIN
      3  3800					      RORG	_BANK_ADDRESS_ORIGIN
      4  3800				   _BANK_START SET	*
      5  3800				   PIECES_3_START SET	*
      6  3800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3800				   PIECES_3   SET	_BANK_SLOT + _CURRENT_BANK
      8  3800				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3800					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  3800					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_0", 72
     12  3800					      LIST	ON
      0  3800					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_0
      1  3800				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3800				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3800				   WHITE_KNIGHT_on_BLACK_SQUARE_0
      4  3800				   TEMPORARY_VAR SET	Overlay
      5  3800				   TEMPORARY_OFFSET SET	0
      6  3800				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3800				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_0
      3  3800		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$f0,$e0,$e0,$f0,$f0,$40,$00	;PF0
      4  3818		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  3830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3848					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  3848					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_1", 72
     12  3848					      LIST	ON
      0  3848					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_1
      1  3848				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3848				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3848				   WHITE_KNIGHT_on_BLACK_SQUARE_1
      4  3848				   TEMPORARY_VAR SET	Overlay
      5  3848				   TEMPORARY_OFFSET SET	0
      6  3848				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3848				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_1
      3  3848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3860		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$78,$38,$3c,$7c,$7c,$14,$00	;PF1
      5  3878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3890					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  3890					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_2", 72
     12  3890					      LIST	ON
      0  3890					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_2
      1  3890				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3890				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3890				   WHITE_KNIGHT_on_BLACK_SQUARE_2
      4  3890				   TEMPORARY_VAR SET	Overlay
      5  3890				   TEMPORARY_OFFSET SET	0
      6  3890				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3890				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_2
      3  3890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  38a8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$01,$03,$03,$00,$00	;PF1
      5  38c0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$03,$03,$07,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  38d8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  38d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_3", 72
     12  3900					      LIST	ON
      0  3900					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_3
      1  3900				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3900				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3900				   WHITE_KNIGHT_on_BLACK_SQUARE_3
      4  3900				   TEMPORARY_VAR SET	Overlay
      5  3900				   TEMPORARY_OFFSET SET	0
      6  3900				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3900				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_3
      3  3900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3930		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$78,$70,$f0,$f8,$f8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3948					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm"
      0  3948					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_0", 72
     12  3948					      LIST	ON
      0  3948					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_0
      1  3948				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3948				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3948				   WHITE_BISHOP_on_BLACK_SQUARE_0
      4  3948				   TEMPORARY_VAR SET	Overlay
      5  3948				   TEMPORARY_OFFSET SET	0
      6  3948				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3948				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_0
      3  3948		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$b0,$d0,$e0,$40,$40	;PF0
      4  3960		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  3978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3990					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm"
      0  3990					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_1", 72
     12  3990					      LIST	ON
      0  3990					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_1
      1  3990				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3990				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3990				   WHITE_BISHOP_on_BLACK_SQUARE_1
      4  3990				   TEMPORARY_VAR SET	Overlay
      5  3990				   TEMPORARY_OFFSET SET	0
      6  3990				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3990				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_1
      3  3990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  39a8		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$6c,$5c,$38,$10,$10	;PF1
      5  39c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  39d8					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm"
      0  39d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_2", 72
     12  3a00					      LIST	ON
      0  3a00					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_2
      1  3a00				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3a00				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3a00				   WHITE_BISHOP_on_BLACK_SQUARE_2
      4  3a00				   TEMPORARY_VAR SET	Overlay
      5  3a00				   TEMPORARY_OFFSET SET	0
      6  3a00				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3a00				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_2
      3  3a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a18		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  3a30		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$06,$07,$03,$01,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3a48					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm"
      0  3a48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_3", 72
     12  3a48					      LIST	ON
      0  3a48					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_3
      1  3a48				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3a48				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3a48				   WHITE_BISHOP_on_BLACK_SQUARE_3
      4  3a48				   TEMPORARY_VAR SET	Overlay
      5  3a48				   TEMPORARY_OFFSET SET	0
      6  3a48				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3a48				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_3
      3  3a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3a78		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$d8,$e8,$70,$20,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3a90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm"
      0  3a90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_0", 72
     12  3a90					      LIST	ON
      0  3a90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_0
      1  3a90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3a90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3a90				   WHITE_ROOK_on_BLACK_SQUARE_0
      4  3a90				   TEMPORARY_VAR SET	Overlay
      5  3a90				   TEMPORARY_OFFSET SET	0
      6  3a90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3a90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_0
      3  3a90		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$f0,$50,$00	;PF0
      4  3aa8		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  3ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ad8					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm"
      0  3ad8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_1", 72
     12  3b00					      LIST	ON
      0  3b00					      DEF	WHITE_ROOK_on_BLACK_SQUARE_1
      1  3b00				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3b00				   BANK_WHITE_ROOK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3b00				   WHITE_ROOK_on_BLACK_SQUARE_1
      4  3b00				   TEMPORARY_VAR SET	Overlay
      5  3b00				   TEMPORARY_OFFSET SET	0
      6  3b00				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3b00				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_1
      3  3b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b18		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$7c,$54,$00	;PF1
      5  3b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3b48					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm"
      0  3b48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_2", 72
     12  3b48					      LIST	ON
      0  3b48					      DEF	WHITE_ROOK_on_BLACK_SQUARE_2
      1  3b48				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3b48				   BANK_WHITE_ROOK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3b48				   WHITE_ROOK_on_BLACK_SQUARE_2
      4  3b48				   TEMPORARY_VAR SET	Overlay
      5  3b48				   TEMPORARY_OFFSET SET	0
      6  3b48				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3b48				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_2
      3  3b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b60		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$03,$02,$00	;PF1
      5  3b78		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3b90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm"
      0  3b90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_3", 72
     12  3b90					      LIST	ON
      0  3b90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_3
      1  3b90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3b90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3b90				   WHITE_ROOK_on_BLACK_SQUARE_3
      4  3b90				   TEMPORARY_VAR SET	Overlay
      5  3b90				   TEMPORARY_OFFSET SET	0
      6  3b90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3b90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_3
      3  3b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3bc0		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$f8,$a8,$00	;PF2
------- FILE piece_graphics.asm
      0  3bd8					      CHECK_BANK_SIZE	"PIECE_3 (1K)"
      1  3bd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_3 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  3bd8					      ECHO	"PIECE_3 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  3bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3bd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_3 (1K)", " size=", * - ORIGIN
      5  3bd8				  -	      ERR
      6  3bd8					      ENDIF
      0  3bd8					      SLOT	2
      1  3bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  3bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  3bd8				  -	      ERR
      4  3bd8					      ENDIF
      5  3bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  3bd8				   _BANK_SLOT SET	2 * 64
      0  3bd8					      NEWBANK	PIECE_4
      1  3fd8 ????				      SEG	PIECE_4
      2  3c00					      ORG	_ORIGIN
      3  3c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  3c00				   _BANK_START SET	*
      5  3c00				   PIECE_4_START SET	*
      6  3c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3c00				   PIECE_4    SET	_BANK_SLOT + _CURRENT_BANK
      8  3c00				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3c00					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm"
      0  3c00					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_0", 72
     12  3c00					      LIST	ON
      0  3c00					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_0
      1  3c00				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3c00				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3c00				   WHITE_QUEEN_on_BLACK_SQUARE_0
      4  3c00				   TEMPORARY_VAR SET	Overlay
      5  3c00				   TEMPORARY_OFFSET SET	0
      6  3c00				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3c00				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_0
      3  3c00		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  3c18		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00,$80,$00	;PF1
      5  3c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3c48					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm"
      0  3c48					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_1", 72
     12  3c48					      LIST	ON
      0  3c48					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_1
      1  3c48				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3c48				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3c48				   WHITE_QUEEN_on_BLACK_SQUARE_1
      4  3c48				   TEMPORARY_VAR SET	Overlay
      5  3c48				   TEMPORARY_OFFSET SET	0
      6  3c48				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3c48				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_1
      3  3c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3c60		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$7c,$7c,$54,$00,$54,$00	;PF1
      5  3c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3c90					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm"
      0  3c90					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_2", 72
     12  3c90					      LIST	ON
      0  3c90					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_2
      1  3c90				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3c90				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3c90				   WHITE_QUEEN_on_BLACK_SQUARE_2
      4  3c90				   TEMPORARY_VAR SET	Overlay
      5  3c90				   TEMPORARY_OFFSET SET	0
      6  3c90				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3c90				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_2
      3  3c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ca8		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  3cc0		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$07,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3cd8					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm"
      0  3cd8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_3", 72
     12  3d00					      LIST	ON
      0  3d00					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_3
      1  3d00				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3d00				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3d00				   WHITE_QUEEN_on_BLACK_SQUARE_3
      4  3d00				   TEMPORARY_VAR SET	Overlay
      5  3d00				   TEMPORARY_OFFSET SET	0
      6  3d00				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3d00				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_3
      3  3d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d30		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$f8,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3d48					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_0.asm"
      0  3d48					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_0", 72
     12  3d48					      LIST	ON
      0  3d48					      DEF	WHITE_KING_on_BLACK_SQUARE_0
      1  3d48				   SLOT_WHITE_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3d48				   BANK_WHITE_KING_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3d48				   WHITE_KING_on_BLACK_SQUARE_0
      4  3d48				   TEMPORARY_VAR SET	Overlay
      5  3d48				   TEMPORARY_OFFSET SET	0
      6  3d48				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3d48				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_0
      3  3d48		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$70,$00,$e0,$40	;PF0
      4  3d60		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  3d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3d90					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_1.asm"
      0  3d90					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_1", 72
     12  3d90					      LIST	ON
      0  3d90					      DEF	WHITE_KING_on_BLACK_SQUARE_1
      1  3d90				   SLOT_WHITE_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3d90				   BANK_WHITE_KING_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3d90				   WHITE_KING_on_BLACK_SQUARE_1
      4  3d90				   TEMPORARY_VAR SET	Overlay
      5  3d90				   TEMPORARY_OFFSET SET	0
      6  3d90				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3d90				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_1
      3  3d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3da8		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$74,$00,$38,$10	;PF1
      5  3dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3dd8					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_2.asm"
      0  3dd8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_2", 72
     12  3e00					      LIST	ON
      0  3e00					      DEF	WHITE_KING_on_BLACK_SQUARE_2
      1  3e00				   SLOT_WHITE_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3e00				   BANK_WHITE_KING_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3e00				   WHITE_KING_on_BLACK_SQUARE_2
      4  3e00				   TEMPORARY_VAR SET	Overlay
      5  3e00				   TEMPORARY_OFFSET SET	0
      6  3e00				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3e00				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_2
      3  3e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e18		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  3e30		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$05,$00,$03,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3e48					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_3.asm"
      0  3e48					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_3", 72
     12  3e48					      LIST	ON
      0  3e48					      DEF	WHITE_KING_on_BLACK_SQUARE_3
      1  3e48				   SLOT_WHITE_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3e48				   BANK_WHITE_KING_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3e48				   WHITE_KING_on_BLACK_SQUARE_3
      4  3e48				   TEMPORARY_VAR SET	Overlay
      5  3e48				   TEMPORARY_OFFSET SET	0
      6  3e48				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3e48				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_3
      3  3e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e78		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$b8,$00,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3e90					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm"
      0  3e90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_0", 72
     12  3e90					      LIST	ON
      0  3e90					      DEF	BLACK_BLANK_on_WHITE_SQUARE_0
      1  3e90				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3e90				   BANK_BLACK_BLANK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3e90				   BLACK_BLANK_on_WHITE_SQUARE_0
      4  3e90				   TEMPORARY_VAR SET	Overlay
      5  3e90				   TEMPORARY_OFFSET SET	0
      6  3e90				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3e90				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_0
      3  3e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$e0,$f0,$f0,$f0,$f0,$f0,$f0,$e0	;PF0
      4  3ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$00	;PF1
      5  3ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ed8					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm"
      0  3ed8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_1", 72
     12  3f00					      LIST	ON
      0  3f00					      DEF	BLACK_BLANK_on_WHITE_SQUARE_1
      1  3f00				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3f00				   BANK_BLACK_BLANK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3f00				   BLACK_BLANK_on_WHITE_SQUARE_1
      4  3f00				   TEMPORARY_VAR SET	Overlay
      5  3f00				   TEMPORARY_OFFSET SET	0
      6  3f00				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3f00				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_1
      3  3f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$38,$7c,$7c,$7c,$7c,$7c,$7c,$38	;PF1
      5  3f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3f48					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm"
      0  3f48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_2", 72
     12  3f48					      LIST	ON
      0  3f48					      DEF	BLACK_BLANK_on_WHITE_SQUARE_2
      1  3f48				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3f48				   BANK_BLACK_BLANK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3f48				   BLACK_BLANK_on_WHITE_SQUARE_2
      4  3f48				   TEMPORARY_VAR SET	Overlay
      5  3f48				   TEMPORARY_OFFSET SET	0
      6  3f48				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3f48				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_2
      3  3f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$03,$03,$03,$01	;PF1
      5  3f78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$07,$07,$07,$07,$07,$07,$03	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3f90					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm"
      0  3f90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_3", 72
     12  3f90					      LIST	ON
      0  3f90					      DEF	BLACK_BLANK_on_WHITE_SQUARE_3
      1  3f90				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3f90				   BANK_BLACK_BLANK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3f90				   BLACK_BLANK_on_WHITE_SQUARE_3
      4  3f90				   TEMPORARY_VAR SET	Overlay
      5  3f90				   TEMPORARY_OFFSET SET	0
      6  3f90				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3f90				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_3
      3  3f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3fc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$70,$f8,$f8,$f8,$f8,$f8,$f8,$70	;PF2
------- FILE piece_graphics.asm
      0  3fd8					      CHECK_BANK_SIZE	"PIECE_4 (1K)"
      1  3fd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_4 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  3fd8					      ECHO	"PIECE_4 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  3fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3fd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_4 (1K)", " size=", * - ORIGIN
      5  3fd8				  -	      ERR
      6  3fd8					      ENDIF
      0  3fd8					      SLOT	2
      1  3fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  3fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  3fd8				  -	      ERR
      4  3fd8					      ENDIF
      5  3fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  3fd8				   _BANK_SLOT SET	2 * 64
      0  3fd8					      NEWBANK	PIECE_5
      1  43d8 ????				      SEG	PIECE_5
      2  4000					      ORG	_ORIGIN
      3  4000					      RORG	_BANK_ADDRESS_ORIGIN
      4  4000				   _BANK_START SET	*
      5  4000				   PIECE_5_START SET	*
      6  4000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4000				   PIECE_5    SET	_BANK_SLOT + _CURRENT_BANK
      8  4000				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4000					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm"
      0  4000					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_0", 72
     12  4000					      LIST	ON
      0  4000					      DEF	BLACK_PAWN_on_WHITE_SQUARE_0
      1  4000				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4000				   BANK_BLACK_PAWN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4000				   BLACK_PAWN_on_WHITE_SQUARE_0
      4  4000				   TEMPORARY_VAR SET	Overlay
      5  4000				   TEMPORARY_OFFSET SET	0
      6  4000				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4000				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_0
      3  4000		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$00,$00,$e0,$00,$00,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  4018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4048					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm"
      0  4048					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_1", 72
     12  4048					      LIST	ON
      0  4048					      DEF	BLACK_PAWN_on_WHITE_SQUARE_1
      1  4048				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4048				   BANK_BLACK_PAWN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4048				   BLACK_PAWN_on_WHITE_SQUARE_1
      4  4048				   TEMPORARY_VAR SET	Overlay
      5  4048				   TEMPORARY_OFFSET SET	0
      6  4048				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4048				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_1
      3  4048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4060		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$38,$10,$10,$00,$00,$38,$00,$00,$38,$00,$00,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  4078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4090					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm"
      0  4090					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_2", 72
     12  4090					      LIST	ON
      0  4090					      DEF	BLACK_PAWN_on_WHITE_SQUARE_2
      1  4090				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4090				   BANK_BLACK_PAWN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4090				   BLACK_PAWN_on_WHITE_SQUARE_2
      4  4090				   TEMPORARY_VAR SET	Overlay
      5  4090				   TEMPORARY_OFFSET SET	0
      6  4090				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4090				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_2
      3  4090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  40a8		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  40c0		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$03,$01,$01,$00,$00,$03,$00,$00,$03,$00,$00,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  40d8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm"
      0  40d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_3", 72
     12  4100					      LIST	ON
      0  4100					      DEF	BLACK_PAWN_on_WHITE_SQUARE_3
      1  4100				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4100				   BANK_BLACK_PAWN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4100				   BLACK_PAWN_on_WHITE_SQUARE_3
      4  4100				   TEMPORARY_VAR SET	Overlay
      5  4100				   TEMPORARY_OFFSET SET	0
      6  4100				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4100				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_3
      3  4100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4130		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$70,$20,$20,$00,$00,$70,$00,$00,$70,$00,$00,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4148					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  4148					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_0", 72
     12  4148					      LIST	ON
      0  4148					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_0
      1  4148				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4148				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4148				   BLACK_KNIGHT_on_WHITE_SQUARE_0
      4  4148				   TEMPORARY_VAR SET	Overlay
      5  4148				   TEMPORARY_OFFSET SET	0
      6  4148				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4148				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_0
      3  4148		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$e0,$70,$e0,$c0,$f0,$b0,$40,$00	;PF0
      4  4160		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  4178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4190					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  4190					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_1", 72
     12  4190					      LIST	ON
      0  4190					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_1
      1  4190				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4190				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4190				   BLACK_KNIGHT_on_WHITE_SQUARE_1
      4  4190				   TEMPORARY_VAR SET	Overlay
      5  4190				   TEMPORARY_OFFSET SET	0
      6  4190				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4190				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_1
      3  4190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  41a8		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$38,$70,$38,$1c,$7c,$6c,$14,$00	;PF1
      5  41c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  41d8					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  41d8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_2", 72
     12  4200					      LIST	ON
      0  4200					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_2
      1  4200				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4200				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4200				   BLACK_KNIGHT_on_WHITE_SQUARE_2
      4  4200				   TEMPORARY_VAR SET	Overlay
      5  4200				   TEMPORARY_OFFSET SET	0
      6  4200				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4200				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_2
      3  4200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4218		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$01,$03,$01,$00,$03,$03,$00,$00	;PF1
      5  4230		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$03,$01,$03,$07,$07,$06,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4248					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  4248					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_3", 72
     12  4248					      LIST	ON
      0  4248					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_3
      1  4248				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4248				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4248				   BLACK_KNIGHT_on_WHITE_SQUARE_3
      4  4248				   TEMPORARY_VAR SET	Overlay
      5  4248				   TEMPORARY_OFFSET SET	0
      6  4248				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4248				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_3
      3  4248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4278		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$70,$38,$70,$e0,$f8,$d8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4290					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm"
      0  4290					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_0", 72
     12  4290					      LIST	ON
      0  4290					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_0
      1  4290				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4290				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4290				   BLACK_BISHOP_on_WHITE_SQUARE_0
      4  4290				   TEMPORARY_VAR SET	Overlay
      5  4290				   TEMPORARY_OFFSET SET	0
      6  4290				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4290				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_0
      3  4290		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$e0,$e0,$f0,$b0,$d0,$e0,$00,$40	;PF0
      4  42a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  42c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  42d8					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm"
      0  42d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_1", 72
     12  4300					      LIST	ON
      0  4300					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_1
      1  4300				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4300				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4300				   BLACK_BISHOP_on_WHITE_SQUARE_1
      4  4300				   TEMPORARY_VAR SET	Overlay
      5  4300				   TEMPORARY_OFFSET SET	0
      6  4300				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4300				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_1
      3  4300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4318		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$38,$38,$78,$6c,$5c,$38,$00,$10	;PF1
      5  4330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4348					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm"
      0  4348					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_2", 72
     12  4348					      LIST	ON
      0  4348					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_2
      1  4348				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4348				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4348				   BLACK_BISHOP_on_WHITE_SQUARE_2
      4  4348				   TEMPORARY_VAR SET	Overlay
      5  4348				   TEMPORARY_OFFSET SET	0
      6  4348				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4348				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_2
      3  4348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4360		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$01,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  4378		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$03,$03,$03,$06,$07,$03,$00,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4390					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm"
      0  4390					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_3", 72
     12  4390					      LIST	ON
      0  4390					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_3
      1  4390				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4390				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4390				   BLACK_BISHOP_on_WHITE_SQUARE_3
      4  4390				   TEMPORARY_VAR SET	Overlay
      5  4390				   TEMPORARY_OFFSET SET	0
      6  4390				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4390				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_3
      3  4390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  43a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  43c0		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$70,$70,$78,$d8,$e8,$70,$00,$20	;PF2
------- FILE piece_graphics.asm
      0  43d8					      CHECK_BANK_SIZE	"PIECE_5 (1K)"
      1  43d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_5 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  43d8					      ECHO	"PIECE_5 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  43d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  43d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_5 (1K)", " size=", * - ORIGIN
      5  43d8				  -	      ERR
      6  43d8					      ENDIF
      0  43d8					      SLOT	2
      1  43d8				  -	      IF	(2 < 0) || (2 > 3)
      2  43d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  43d8				  -	      ERR
      4  43d8					      ENDIF
      5  43d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  43d8				   _BANK_SLOT SET	2 * 64
      0  43d8					      NEWBANK	PIECE_6
      1  4790 ????				      SEG	PIECE_6
      2  4400					      ORG	_ORIGIN
      3  4400					      RORG	_BANK_ADDRESS_ORIGIN
      4  4400				   _BANK_START SET	*
      5  4400				   PIECE_6_START SET	*
      6  4400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4400				   PIECE_6    SET	_BANK_SLOT + _CURRENT_BANK
      8  4400				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4400					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm"
      0  4400					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_0", 72
     12  4400					      LIST	ON
      0  4400					      DEF	BLACK_ROOK_on_WHITE_SQUARE_0
      1  4400				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4400				   BANK_BLACK_ROOK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4400				   BLACK_ROOK_on_WHITE_SQUARE_0
      4  4400				   TEMPORARY_VAR SET	Overlay
      5  4400				   TEMPORARY_OFFSET SET	0
      6  4400				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4400				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_0
      3  4400		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$e0,$e0,$e0,$e0,$f0,$50,$50,$00	;PF0
      4  4418		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  4430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4448					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm"
      0  4448					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_1", 72
     12  4448					      LIST	ON
      0  4448					      DEF	BLACK_ROOK_on_WHITE_SQUARE_1
      1  4448				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4448				   BANK_BLACK_ROOK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4448				   BLACK_ROOK_on_WHITE_SQUARE_1
      4  4448				   TEMPORARY_VAR SET	Overlay
      5  4448				   TEMPORARY_OFFSET SET	0
      6  4448				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4448				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_1
      3  4448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4460		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$38,$38,$38,$38,$7c,$54,$54,$00	;PF1
      5  4478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4490					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm"
      0  4490					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_2", 72
     12  4490					      LIST	ON
      0  4490					      DEF	BLACK_ROOK_on_WHITE_SQUARE_2
      1  4490				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4490				   BANK_BLACK_ROOK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4490				   BLACK_ROOK_on_WHITE_SQUARE_2
      4  4490				   TEMPORARY_VAR SET	Overlay
      5  4490				   TEMPORARY_OFFSET SET	0
      6  4490				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4490				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_2
      3  4490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  44a8		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$01,$01,$01,$01,$03,$02,$02,$00	;PF1
      5  44c0		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$03,$03,$03,$03,$07,$05,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  44d8					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm"
      0  44d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_3", 72
     12  4500					      LIST	ON
      0  4500					      DEF	BLACK_ROOK_on_WHITE_SQUARE_3
      1  4500				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4500				   BANK_BLACK_ROOK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4500				   BLACK_ROOK_on_WHITE_SQUARE_3
      4  4500				   TEMPORARY_VAR SET	Overlay
      5  4500				   TEMPORARY_OFFSET SET	0
      6  4500				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4500				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_3
      3  4500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4530		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$70,$70,$70,$70,$f8,$a8,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4548					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm"
      0  4548					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_0", 72
     12  4548					      LIST	ON
      0  4548					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_0
      1  4548				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4548				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4548				   BLACK_QUEEN_on_WHITE_SQUARE_0
      4  4548				   TEMPORARY_VAR SET	Overlay
      5  4548				   TEMPORARY_OFFSET SET	0
      6  4548				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4548				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_0
      3  4548		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  4560		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$80,$80,$00,$80,$00	;PF1
      5  4578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4590					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm"
      0  4590					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_1", 72
     12  4590					      LIST	ON
      0  4590					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_1
      1  4590				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4590				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4590				   BLACK_QUEEN_on_WHITE_SQUARE_1
      4  4590				   TEMPORARY_VAR SET	Overlay
      5  4590				   TEMPORARY_OFFSET SET	0
      6  4590				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4590				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_1
      3  4590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  45a8		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$78,$7c,$54,$00,$54,$00	;PF1
      5  45c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  45d8					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm"
      0  45d8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_2", 72
     12  4600					      LIST	ON
      0  4600					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_2
      1  4600				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4600				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4600				   BLACK_QUEEN_on_WHITE_SQUARE_2
      4  4600				   TEMPORARY_VAR SET	Overlay
      5  4600				   TEMPORARY_OFFSET SET	0
      6  4600				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4600				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_2
      3  4600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4618		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  4630		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$03,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4648					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm"
      0  4648					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_3", 72
     12  4648					      LIST	ON
      0  4648					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_3
      1  4648				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4648				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4648				   BLACK_QUEEN_on_WHITE_SQUARE_3
      4  4648				   TEMPORARY_VAR SET	Overlay
      5  4648				   TEMPORARY_OFFSET SET	0
      6  4648				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4648				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_3
      3  4648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4678		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$78,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4690					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_0.asm"
      0  4690					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_0", 72
     12  4690					      LIST	ON
      0  4690					      DEF	BLACK_KING_on_WHITE_SQUARE_0
      1  4690				   SLOT_BLACK_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4690				   BANK_BLACK_KING_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4690				   BLACK_KING_on_WHITE_SQUARE_0
      4  4690				   TEMPORARY_VAR SET	Overlay
      5  4690				   TEMPORARY_OFFSET SET	0
      6  4690				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4690				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_0
      3  4690		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$f0,$40,$e0,$40	;PF0
      4  46a8		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  46c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  46d8					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_1.asm"
      0  46d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_1", 72
     12  4700					      LIST	ON
      0  4700					      DEF	BLACK_KING_on_WHITE_SQUARE_1
      1  4700				   SLOT_BLACK_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4700				   BANK_BLACK_KING_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4700				   BLACK_KING_on_WHITE_SQUARE_1
      4  4700				   TEMPORARY_VAR SET	Overlay
      5  4700				   TEMPORARY_OFFSET SET	0
      6  4700				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4700				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_1
      3  4700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4718		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$7c,$10,$38,$10	;PF1
      5  4730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4748					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_2.asm"
      0  4748					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_2", 72
     12  4748					      LIST	ON
      0  4748					      DEF	BLACK_KING_on_WHITE_SQUARE_2
      1  4748				   SLOT_BLACK_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4748				   BANK_BLACK_KING_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4748				   BLACK_KING_on_WHITE_SQUARE_2
      4  4748				   TEMPORARY_VAR SET	Overlay
      5  4748				   TEMPORARY_OFFSET SET	0
      6  4748				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4748				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_2
      3  4748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4760		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  4778		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$07,$01,$03,$01	;PF2
------- FILE piece_graphics.asm
      0  4790					      CHECK_BANK_SIZE	"PIECE_6 (1K)"
      1  4790		       03 90	   .TEMP      =	* - _BANK_START
 PIECE_6 (1K) (1K) SIZE =  $390 , FREE= $70
      2  4790					      ECHO	"PIECE_6 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4790				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4790				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_6 (1K)", " size=", * - ORIGIN
      5  4790				  -	      ERR
      6  4790					      ENDIF
      0  4790					      SLOT	2
      1  4790				  -	      IF	(2 < 0) || (2 > 3)
      2  4790				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4790				  -	      ERR
      4  4790					      ENDIF
      5  4790				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4790				   _BANK_SLOT SET	2 * 64
      0  4790					      NEWBANK	PIECE_7
      1  4c48 ????				      SEG	PIECE_7
      2  4800					      ORG	_ORIGIN
      3  4800					      RORG	_BANK_ADDRESS_ORIGIN
      4  4800				   _BANK_START SET	*
      5  4800				   PIECE_7_START SET	*
      6  4800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4800				   PIECE_7    SET	_BANK_SLOT + _CURRENT_BANK
      8  4800				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4800					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_3.asm"
      0  4800					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_3", 72
     12  4800					      LIST	ON
      0  4800					      DEF	BLACK_KING_on_WHITE_SQUARE_3
      1  4800				   SLOT_BLACK_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4800				   BANK_BLACK_KING_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4800				   BLACK_KING_on_WHITE_SQUARE_3
      4  4800				   TEMPORARY_VAR SET	Overlay
      5  4800				   TEMPORARY_OFFSET SET	0
      6  4800				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4800				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_3
      3  4800		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4830		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$f8,$20,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4848					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm"
      0  4848					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_0", 72
     12  4848					      LIST	ON
      0  4848					      DEF	BLACK_BLANK_on_BLACK_SQUARE_0
      1  4848				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4848				   BANK_BLACK_BLANK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4848				   BLACK_BLANK_on_BLACK_SQUARE_0
      4  4848				   TEMPORARY_VAR SET	Overlay
      5  4848				   TEMPORARY_OFFSET SET	0
      6  4848				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4848				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_0
      3  4848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4860		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4890					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm"
      0  4890					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_1", 72
     12  4890					      LIST	ON
      0  4890					      DEF	BLACK_BLANK_on_BLACK_SQUARE_1
      1  4890				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4890				   BANK_BLACK_BLANK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4890				   BLACK_BLANK_on_BLACK_SQUARE_1
      4  4890				   TEMPORARY_VAR SET	Overlay
      5  4890				   TEMPORARY_OFFSET SET	0
      6  4890				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4890				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_1
      3  4890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  48a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  48c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  48d8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm"
      0  48d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_2", 72
     12  4900					      LIST	ON
      0  4900					      DEF	BLACK_BLANK_on_BLACK_SQUARE_2
      1  4900				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4900				   BANK_BLACK_BLANK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4900				   BLACK_BLANK_on_BLACK_SQUARE_2
      4  4900				   TEMPORARY_VAR SET	Overlay
      5  4900				   TEMPORARY_OFFSET SET	0
      6  4900				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4900				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_2
      3  4900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4930		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4948					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm"
      0  4948					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_3", 72
     12  4948					      LIST	ON
      0  4948					      DEF	BLACK_BLANK_on_BLACK_SQUARE_3
      1  4948				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4948				   BANK_BLACK_BLANK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4948				   BLACK_BLANK_on_BLACK_SQUARE_3
      4  4948				   TEMPORARY_VAR SET	Overlay
      5  4948				   TEMPORARY_OFFSET SET	0
      6  4948				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4948				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_3
      3  4948		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4990					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm"
      0  4990					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_0", 72
     12  4990					      LIST	ON
      0  4990					      DEF	BLACK_PAWN_on_BLACK_SQUARE_0
      1  4990				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4990				   BANK_BLACK_PAWN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4990				   BLACK_PAWN_on_BLACK_SQUARE_0
      4  4990				   TEMPORARY_VAR SET	Overlay
      5  4990				   TEMPORARY_OFFSET SET	0
      6  4990				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4990				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_0
      3  4990		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$00,$00,$e0,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  49a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  49c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  49d8					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm"
      0  49d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_1", 72
     12  4a00					      LIST	ON
      0  4a00					      DEF	BLACK_PAWN_on_BLACK_SQUARE_1
      1  4a00				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4a00				   BANK_BLACK_PAWN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4a00				   BLACK_PAWN_on_BLACK_SQUARE_1
      4  4a00				   TEMPORARY_VAR SET	Overlay
      5  4a00				   TEMPORARY_OFFSET SET	0
      6  4a00				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4a00				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_1
      3  4a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a18		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$38,$10,$10,$00,$00,$38,$00,$00,$38,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4a30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4a48					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm"
      0  4a48					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_2", 72
     12  4a48					      LIST	ON
      0  4a48					      DEF	BLACK_PAWN_on_BLACK_SQUARE_2
      1  4a48				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4a48				   BANK_BLACK_PAWN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4a48				   BLACK_PAWN_on_BLACK_SQUARE_2
      4  4a48				   TEMPORARY_VAR SET	Overlay
      5  4a48				   TEMPORARY_OFFSET SET	0
      6  4a48				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4a48				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_2
      3  4a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a60		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4a78		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$03,$01,$01,$00,$00,$03,$00,$00,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4a90					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm"
      0  4a90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_3", 72
     12  4a90					      LIST	ON
      0  4a90					      DEF	BLACK_PAWN_on_BLACK_SQUARE_3
      1  4a90				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4a90				   BANK_BLACK_PAWN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4a90				   BLACK_PAWN_on_BLACK_SQUARE_3
      4  4a90				   TEMPORARY_VAR SET	Overlay
      5  4a90				   TEMPORARY_OFFSET SET	0
      6  4a90				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4a90				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_3
      3  4a90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4ac0		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$70,$20,$20,$00,$00,$70,$00,$00,$70,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4ad8					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  4ad8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_0", 72
     12  4b00					      LIST	ON
      0  4b00					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_0
      1  4b00				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4b00				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4b00				   BLACK_KNIGHT_on_BLACK_SQUARE_0
      4  4b00				   TEMPORARY_VAR SET	Overlay
      5  4b00				   TEMPORARY_OFFSET SET	0
      6  4b00				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4b00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_0
      3  4b00		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$40,$00,$00	;PF0
      4  4b18		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4b48					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  4b48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_1", 72
     12  4b48					      LIST	ON
      0  4b48					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_1
      1  4b48				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4b48				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4b48				   BLACK_KNIGHT_on_BLACK_SQUARE_1
      4  4b48				   TEMPORARY_VAR SET	Overlay
      5  4b48				   TEMPORARY_OFFSET SET	0
      6  4b48				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4b48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_1
      3  4b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4b60		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$10,$00,$00	;PF1
      5  4b78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4b90					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  4b90					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_2", 72
     12  4b90					      LIST	ON
      0  4b90					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_2
      1  4b90				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4b90				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4b90				   BLACK_KNIGHT_on_BLACK_SQUARE_2
      4  4b90				   TEMPORARY_VAR SET	Overlay
      5  4b90				   TEMPORARY_OFFSET SET	0
      6  4b90				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4b90				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_2
      3  4b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ba8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4bc0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  4bd8					      CHECK_BANK_SIZE	"PIECE_7 (1K)"
      1  4bd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_7 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  4bd8					      ECHO	"PIECE_7 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4bd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_7 (1K)", " size=", * - ORIGIN
      5  4bd8				  -	      ERR
      6  4bd8					      ENDIF
      0  4bd8					      SLOT	2
      1  4bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  4bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4bd8				  -	      ERR
      4  4bd8					      ENDIF
      5  4bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4bd8				   _BANK_SLOT SET	2 * 64
      0  4bd8					      NEWBANK	PIECE_7
      1  4bd8					      SEG	PIECE_7
      2  4c00					      ORG	_ORIGIN
      3  4c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  4c00				   _BANK_START SET	*
      5  4c00				   PIECE_7_START SET	*
      6  4c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4c00				   PIECE_7    SET	_BANK_SLOT + _CURRENT_BANK
      8  4c00				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4c00					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  4c00					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_3", 72
     12  4c00					      LIST	ON
      0  4c00					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_3
      1  4c00				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4c00				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4c00				   BLACK_KNIGHT_on_BLACK_SQUARE_3
      4  4c00				   TEMPORARY_VAR SET	Overlay
      5  4c00				   TEMPORARY_OFFSET SET	0
      6  4c00				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4c00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_3
      3  4c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4c30		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
    127  4c48
    128  4c48							;    CHECK_BANK_SIZE "PIECES_4 (2K)"
    129  4c48
    130  4c48							;    NEWBANK PIECES_5
    131  4c48
    132  4c48							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
    133  4c48							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
    134  4c48							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
    135  4c48							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
    136  4c48							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
    137  4c48							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
    138  4c48							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
    139  4c48							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
    140  4c48
    141  4c48
    142  4c48				  -	      IF	0
    143  4c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    144  4c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    145  4c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    146  4c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    147  4c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    148  4c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    149  4c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    150  4c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    151  4c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    152  4c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    153  4c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    154  4c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    155  4c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    156  4c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    157  4c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    158  4c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    159  4c48					      ENDIF
    160  4c48
    161  4c48							;    CHECK_BANK_SIZE "PIECES_5 (2K)"
    162  4c48
    163  4c48				  -	      IF	0
    164  4c48				  -	      NEWBANK	PIECES_6
    165  4c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    166  4c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    167  4c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    168  4c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    169  4c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    170  4c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    171  4c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    172  4c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    173  4c48				  -
    174  4c48				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_0.asm"
    175  4c48				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_1.asm"
    176  4c48				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_2.asm"
    177  4c48				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_3.asm"
    178  4c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    179  4c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    180  4c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    181  4c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    182  4c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    183  4c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    184  4c48				  -
    185  4c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    186  4c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    187  4c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    188  4c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    189  4c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    190  4c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    191  4c48				  -	      CHECK_BANK_SIZE	"PIECES_6 (2K)"
    192  4c48				  -
    193  4c48				  -
    194  4c48				  -	      NEWBANK	PIECES_7
    195  4c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    196  4c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    197  4c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    198  4c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    199  4c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    200  4c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    201  4c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    202  4c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    203  4c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    204  4c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    205  4c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    206  4c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    207  4c48				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_0.asm"
    208  4c48				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_1.asm"
    209  4c48				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_2.asm"
    210  4c48				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_3.asm"
    211  4c48				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    212  4c48				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    213  4c48				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    214  4c48				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    215  4c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    216  4c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    217  4c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    218  4c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    219  4c48				  -	      CHECK_BANK_SIZE	"PIECES_7 (2K)"
    220  4c48				  -
    221  4c48				  -
    222  4c48				  -	      NEWBANK	PIECES_8
    223  4c48				  -
    224  4c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    225  4c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    226  4c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    227  4c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    228  4c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    229  4c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    230  4c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    231  4c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    232  4c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    233  4c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    234  4c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    235  4c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    236  4c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    237  4c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    238  4c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    239  4c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    240  4c48				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_0.asm"
    241  4c48				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_1.asm"
    242  4c48				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_2.asm"
    243  4c48				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_3.asm"
    244  4c48				  -
    245  4c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    246  4c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    247  4c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    248  4c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    249  4c48				  -	      CHECK_BANK_SIZE	"PIECES_8 (2K)"
    250  4c48				  -
    251  4c48					      ENDIF
    252  4c48
    253  4c48							;    NEWBANK PIECES_9
    254  4c48
    255  4c48							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    256  4c48							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    257  4c48							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    258  4c48							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    259  4c48							; include "gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    260  4c48
    261  4c48				  -	      IF	0
    262  4c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    263  4c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    264  4c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    265  4c48					      ENDIF
    266  4c48
    267  4c48							;    CHECK_BANK_SIZE "PIECES_9 (2K)"
    268  4c48
    269  4c48				  -	      IF	0
    270  4c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    271  4c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    272  4c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    273  4c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    274  4c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    275  4c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    276  4c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    277  4c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    278  4c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    279  4c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    280  4c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    281  4c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    282  4c48				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_0.asm"
    283  4c48				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_1.asm"
    284  4c48				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_2.asm"
    285  4c48				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_3.asm"
    286  4c48					      ENDIF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@2.asm LEVEL 2 PASS 4
      0  4c48					      include	"BANK_GENERIC@2.asm"
      1  4c48
      0  4c48					      SLOT	2
      1  4c48				  -	      IF	(2 < 0) || (2 > 3)
      2  4c48				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4c48				  -	      ERR
      4  4c48					      ENDIF
      5  4c48				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4c48				   _BANK_SLOT SET	2 * 64
      0  4c48					      NEWBANK	GENERIC_BANK@2
      1  525b ????				      SEG	GENERIC_BANK@2
      2  5000					      ORG	_ORIGIN
      3  5000					      RORG	_BANK_ADDRESS_ORIGIN
      4  5000				   _BANK_START SET	*
      5  5000				   GENERIC_BANK@2_START SET	*
      6  5000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5000				   GENERIC_BANK@2 SET	_BANK_SLOT + _CURRENT_BANK
      8  5000				   _ORIGIN    SET	_ORIGIN + 1024
      4  5000
      5  5000							;    DEFINE_1K_SEGMENT DECODE_LEVEL_SHADOW
      6  5000
      7  5000				  -	      IF	0
      8  5000				  -	      IF	PLUSCART = YES
      9  5000				  -	      .byte	"ChessAPI.php", #0 //TODO: change!
     10  5000				  -	      .byte	"pluscart.firmaplus.de", #0
     11  5000				  -	      ENDIF
     12  5000					      ENDIF
     13  5000
     14  5000							;STELLA_AUTODETECT .byte $85,$3e,$a9,$00 ; 3E
     15  5000
     16  5000
     17  5000							;---------------------------------------------------------------------------------------------------
     18  5000
      0  5000					      DEF	IsValidMoveFromSquare
      1  5000				   SLOT_IsValidMoveFromSquare SET	_BANK_SLOT
      2  5000				   BANK_IsValidMoveFromSquare SET	SLOT_IsValidMoveFromSquare + _CURRENT_BANK
      3  5000				   IsValidMoveFromSquare
      4  5000				   TEMPORARY_VAR SET	Overlay
      5  5000				   TEMPORARY_OFFSET SET	0
      6  5000				   VAR_BOUNDARY_IsValidMoveFromSquare SET	TEMPORARY_OFFSET
      7  5000				   FUNCTION_NAME SET	IsValidMoveFromSquare
     20  5000					      SUBROUTINE
     21  5000
      0  5000					      REFER	aiSelectStartSquare
      1  5000				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  5000				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  5000					      ENDIF
      0  5000					      VEND	IsValidMoveFromSquare
      1  5000				  -	      IFNCONST	IsValidMoveFromSquare
      2  5000				  -	      ECHO	"Incorrect VEND label", IsValidMoveFromSquare
      3  5000				  -	      ERR
      4  5000					      ENDIF
      5  5000		       00 a2	   VAREND_IsValidMoveFromSquare =	TEMPORARY_VAR
     24  5000
     25  5000							; Does the square exist in the movelist?
     26  5000							; Return: y = -1 if NOT FOUND
     27  5000
     28  5000		       a5 88		      lda	cursorX12
     29  5002		       85 85		      sta	fromX12
     30  5004
     31  5004		       a5 95		      lda	currentPly
     32  5006		       85 3e		      sta	SET_BANK_RAM
     33  5008		       20 18 f8 	      jsr	CheckMoveListFromSquare
     34  500b
     35  500b							;lda savedBank
     36  500b							;sta SET_BANK
     37  500b		       60		      rts
     38  500c
     39  500c
     40  500c							;---------------------------------------------------------------------------------------------------
     41  500c
      0  500c					      DEF	tidySc
      1  500c				   SLOT_tidySc SET	_BANK_SLOT
      2  500c				   BANK_tidySc SET	SLOT_tidySc + _CURRENT_BANK
      3  500c				   tidySc
      4  500c				   TEMPORARY_VAR SET	Overlay
      5  500c				   TEMPORARY_OFFSET SET	0
      6  500c				   VAR_BOUNDARY_tidySc SET	TEMPORARY_OFFSET
      7  500c				   FUNCTION_NAME SET	tidySc
     43  500c					      SUBROUTINE
     44  500c
     45  500c		       a9 00		      lda	#0
     46  500e		       85 4d		      sta	PF0
     47  5010		       85 4e		      sta	PF1
     48  5012		       85 4f		      sta	PF2
     49  5014		       85 5b		      sta	GRP0
     50  5016		       85 5c		      sta	GRP1
     51  5018
     52  5018		       a9 42		      lda	#%01000010	; bit6 is not required
     53  501a							;sta VBLANK			  ; end of screen - enter blanking
     54  501a
     55  501a
     56  501a							; END OF VISIBLE SCREEN
     57  501a							; HERE'S SOME TIME TO DO STUFF
     58  501a
     59  501a		       a9 2e		      lda	#TIME_PART_2
     60  501c		       8d 96 02 	      sta	TIM64T
     61  501f		       60		      rts
     62  5020
     63  5020
     64  5020							;---------------------------------------------------------------------------------------------------
     65  5020
      0  5020					      DEF	longD
      1  5020				   SLOT_longD SET	_BANK_SLOT
      2  5020				   BANK_longD SET	SLOT_longD + _CURRENT_BANK
      3  5020				   longD
      4  5020				   TEMPORARY_VAR SET	Overlay
      5  5020				   TEMPORARY_OFFSET SET	0
      6  5020				   VAR_BOUNDARY_longD SET	TEMPORARY_OFFSET
      7  5020				   FUNCTION_NAME SET	longD
     67  5020					      SUBROUTINE
     68  5020
     69  5020		       85 42		      sta	WSYNC
     70  5022
     71  5022		       20 33 f8 	      jsr	_rts
     72  5025		       20 33 f8 	      jsr	_rts
     73  5028		       20 33 f8 	      jsr	_rts
      0  502b					      SLEEP	7
      1  502b				   .CYCLES    SET	7
      2  502b
      3  502b				  -	      IF	.CYCLES < 2
      4  502b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  502b				  -	      ERR
      6  502b					      ENDIF
      7  502b
      8  502b					      IF	.CYCLES & 1
      9  502b					      IFNCONST	NO_ILLEGAL_OPCODES
     10  502b		       04 00		      nop	0
     11  502d				  -	      ELSE
     12  502d				  -	      bit	VSYNC
     13  502d					      ENDIF
     14  502d				   .CYCLES    SET	.CYCLES - 3
     15  502d					      ENDIF
     16  502d
     17  502d					      REPEAT	.CYCLES / 2
     18  502d		       ea		      nop
     17  502d					      REPEND
     18  502e		       ea		      nop
     19  502f					      REPEND
     75  502f
     76  502f		       a2 00		      ldx	#0
     77  5031		       86 41		      stx	VBLANK
     78  5033		       60	   _rts       rts
     79  5034
     80  5034				  -	      IF	0
     81  5034				  -	      DEF	Resync
     82  5034				  -	      SUBROUTINE
     83  5034				  -
     84  5034				  -	      RESYNC
     85  5034				  -	      rts
     86  5034					      ENDIF
     87  5034
     88  5034
     89  5034							;---------------------------------------------------------------------------------------------------
     90  5034
      0  5034					      DEF	aiStartClearBoard
      1  5034				   SLOT_aiStartClearBoard SET	_BANK_SLOT
      2  5034				   BANK_aiStartClearBoard SET	SLOT_aiStartClearBoard + _CURRENT_BANK
      3  5034				   aiStartClearBoard
      4  5034				   TEMPORARY_VAR SET	Overlay
      5  5034				   TEMPORARY_OFFSET SET	0
      6  5034				   VAR_BOUNDARY_aiStartClearBoard SET	TEMPORARY_OFFSET
      7  5034				   FUNCTION_NAME SET	aiStartClearBoard
     92  5034					      SUBROUTINE
     93  5034
      0  5034					      REFER	AiStateMachine
      1  5034				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5034				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5034					      ENDIF
      0  5034					      VEND	aiStartClearBoard
      1  5034				  -	      IFNCONST	aiStartClearBoard
      2  5034				  -	      ECHO	"Incorrect VEND label", aiStartClearBoard
      3  5034				  -	      ERR
      4  5034					      ENDIF
      5  5034		       00 a2	   VAREND_aiStartClearBoard =	TEMPORARY_VAR
     96  5034
     97  5034		       a2 08		      ldx	#8
     98  5036		       86 84		      stx	drawCount	; = bank
     99  5038
    100  5038		       a9 ff		      lda	#-1
    101  503a		       85 88		      sta	cursorX12
    102  503c
      0  503c					      PHASE	AI_ClearEachRow
      1  503c		       a9 0e		      lda	#AI_ClearEachRow
      2  503e		       85 8c		      sta	aiState
    104  5040		       60		      rts
    105  5041
    106  5041							;---------------------------------------------------------------------------------------------------
    107  5041
      0  5041					      DEF	aiClearEachRow
      1  5041				   SLOT_aiClearEachRow SET	_BANK_SLOT
      2  5041				   BANK_aiClearEachRow SET	SLOT_aiClearEachRow + _CURRENT_BANK
      3  5041				   aiClearEachRow
      4  5041				   TEMPORARY_VAR SET	Overlay
      5  5041				   TEMPORARY_OFFSET SET	0
      6  5041				   VAR_BOUNDARY_aiClearEachRow SET	TEMPORARY_OFFSET
      7  5041				   FUNCTION_NAME SET	aiClearEachRow
    109  5041					      SUBROUTINE
    110  5041
      0  5041					      REFER	AiStateMachine
      1  5041				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5041				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5041					      ENDIF
      0  5041					      VEND	aiClearEachRow
      1  5041				  -	      IFNCONST	aiClearEachRow
      2  5041				  -	      ECHO	"Incorrect VEND label", aiClearEachRow
      3  5041				  -	      ERR
      4  5041					      ENDIF
      5  5041		       00 a2	   VAREND_aiClearEachRow =	TEMPORARY_VAR
    113  5041
    114  5041		       c6 84		      dec	drawCount
    115  5043		       30 00		      bmi	.bitmapCleared
    116  5045							;TODOldy drawCount
    117  5045							;TODO jmp CallClear
    118  5045
    119  5045				   .bitmapCleared
    120  5045
    121  5045		       a9 63		      lda	#99
    122  5047		       85 80		      sta	squareToDraw
    123  5049
      0  5049					      PHASE	AI_DrawEntireBoard
      1  5049		       a9 0f		      lda	#AI_DrawEntireBoard
      2  504b		       85 8c		      sta	aiState
    125  504d		       60		      rts
    126  504e
    127  504e
    128  504e
    129  504e							;---------------------------------------------------------------------------------------------------
    130  504e
      0  504e					      DEF	aiMoveIsSelected
      1  504e				   SLOT_aiMoveIsSelected SET	_BANK_SLOT
      2  504e				   BANK_aiMoveIsSelected SET	SLOT_aiMoveIsSelected + _CURRENT_BANK
      3  504e				   aiMoveIsSelected
      4  504e				   TEMPORARY_VAR SET	Overlay
      5  504e				   TEMPORARY_OFFSET SET	0
      6  504e				   VAR_BOUNDARY_aiMoveIsSelected SET	TEMPORARY_OFFSET
      7  504e				   FUNCTION_NAME SET	aiMoveIsSelected
    132  504e					      SUBROUTINE
    133  504e
      0  504e					      REFER	AiStateMachine
      1  504e				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  504e				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  504e					      ENDIF
      0  504e					      VEND	aiMoveIsSelected
      1  504e				  -	      IFNCONST	aiMoveIsSelected
      2  504e				  -	      ECHO	"Incorrect VEND label", aiMoveIsSelected
      3  504e				  -	      ERR
      4  504e					      ENDIF
      5  504e		       00 a2	   VAREND_aiMoveIsSelected =	TEMPORARY_VAR
    136  504e
    137  504e
    138  504e							; Both computer and human have now seleted a move, and converge here
    139  504e
    140  504e
    141  504e							; fromPiece	 piece doing the move
    142  504e							; fromX12	 current square X12
    143  504e							; originX12	 starting square X12
    144  504e							; toX12	 ending square X12
    145  504e
    146  504e
    147  504e
    148  504e		       20 64 f5 	      jsr	AdjustMaterialPositionalValue
    149  5051
    150  5051		       a9 00		      lda	#0
    151  5053		       85 99		      sta	previousPiece
    152  5055		       85 82		      sta	drawDelay
    153  5057
    154  5057		       a9 0a		      lda	#10	; on/off count
    155  5059		       85 84		      sta	drawCount	; flashing for piece about to move
    156  505b
      0  505b					      PHASE	AI_WriteStartPieceBlank
      1  505b		       a9 15		      lda	#AI_WriteStartPieceBlank
      2  505d		       85 8c		      sta	aiState
    158  505f		       60	   .idleErase rts
    159  5060
    160  5060
    161  5060							;---------------------------------------------------------------------------------------------------
    162  5060
      0  5060					      DEF	CopySetup	;@2 - uses @3
      1  5060				   SLOT_CopySetup SET	_BANK_SLOT
      2  5060				   BANK_CopySetup SET	SLOT_CopySetup + _CURRENT_BANK
      3  5060				   CopySetup
      4  5060				   TEMPORARY_VAR SET	Overlay
      5  5060				   TEMPORARY_OFFSET SET	0
      6  5060				   VAR_BOUNDARY_CopySetup SET	TEMPORARY_OFFSET
      7  5060				   FUNCTION_NAME SET	CopySetup
    164  5060					      SUBROUTINE
    165  5060
      0  5060					      REFER	CopySinglePiece
      1  5060					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  5060				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  5060					      ENDIF
      0  5060					      VAR	__tmp, 1
      1  5060		       00 ae	   __tmp      =	TEMPORARY_VAR
      2  5060				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5060
      4  5060				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5060				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5060				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5060					      ENDIF
      8  5060				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5060				  -	      ECHO	"Temporary Variable", __tmp, "overflow!"
     10  5060				  -	      ERR
     11  5060					      ENDIF
     12  5060					      LIST	ON
      0  5060					      VAR	__shiftx, 1
      1  5060		       00 af	   __shiftx   =	TEMPORARY_VAR
      2  5060				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5060
      4  5060				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5060				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5060				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5060					      ENDIF
      8  5060				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5060				  -	      ECHO	"Temporary Variable", __shiftx, "overflow!"
     10  5060				  -	      ERR
     11  5060					      ENDIF
     12  5060					      LIST	ON
      0  5060					      VAR	__pieceColour2, 1
      1  5060		       00 b0	   __pieceColour2 =	TEMPORARY_VAR
      2  5060				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5060
      4  5060				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5060				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5060				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5060					      ENDIF
      8  5060				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5060				  -	      ECHO	"Temporary Variable", __pieceColour2, "overflow!"
     10  5060				  -	      ERR
     11  5060					      ENDIF
     12  5060					      LIST	ON
      0  5060					      VEND	CopySetup
      1  5060				  -	      IFNCONST	CopySetup
      2  5060				  -	      ECHO	"Incorrect VEND label", CopySetup
      3  5060				  -	      ERR
      4  5060					      ENDIF
      5  5060		       00 b1	   VAREND_CopySetup =	TEMPORARY_VAR
    171  5060
    172  5060							; figure colouration of square
    173  5060
    174  5060		       a5 80		      lda	squareToDraw
    175  5062
    176  5062				  -	      IF	DIAGNOSTICS
    177  5062				  -			; Catch out-of-range piece square
    178  5062				  -			; will not catch off left/right edge
    179  5062				  -
    180  5062				  -.fail      cmp	#100
    181  5062				  -	      bcs	.fail
    182  5062				  -	      cmp	#22
    183  5062				  -	      bcc	.fail
    184  5062					      ENDIF
    185  5062
    186  5062
    187  5062		       a2 0a		      ldx	#10
    188  5064		       38		      sec
    189  5065		       e9 0a	   .sub10     sbc	#10
    190  5067		       ca		      dex
    191  5068		       b0 fb		      bcs	.sub10
    192  506a		       69 08		      adc	#8
    193  506c		       85 af		      sta	__shiftx
    194  506e				  -	      IF	DIAGNOSTICS
    195  506e				  -.fail2     cmp	#8
    196  506e				  -	      bcs	.fail2
    197  506e				  -	      cpx	#8
    198  506e				  -	      bcs	.fail2
    199  506e					      ENDIF
    200  506e		       86 ae		      stx	__tmp
    201  5070		       65 ae		      adc	__tmp
    202  5072
    203  5072
    204  5072		       29 01		      and	#1
    205  5074		       49 01		      eor	#1
    206  5076		       f0 02		      beq	.white
    207  5078		       a9 24		      lda	#36
    208  507a				   .white
    209  507a		       85 b0		      sta	__pieceColour2	; actually SQUARE black/white
    210  507c
    211  507c							; PieceColour = 0 for white square, 36 for black square
    212  507c
    213  507c		       a9 cf		      lda	#RAMBANK_BOARD
    214  507e		       85 3e		      sta	SET_BANK_RAM	;@3
    215  5080
    216  5080		       a4 80		      ldy	squareToDraw
    217  5082		       b9 79 fc 	      lda	Board,y
    218  5085							;and #$87
    219  5085		       0a		      asl
    220  5086		       90 02		      bcc	.blackAdjust
    221  5088		       09 10		      ora	#16	; switch white pieces
    222  508a		       4a	   .blackAdjust lsr
    223  508b		       29 0f		      and	#%1111
    224  508d		       aa		      tax
    225  508e
    226  508e		       a5 af		      lda	__shiftx
    227  5090		       29 03		      and	#3	; shift position in P
    228  5092
    229  5092		       18		      clc
    230  5093		       7d 9b f8 	      adc	PieceToShape,x
    231  5096		       18		      clc
    232  5097		       65 b0		      adc	__pieceColour2
    233  5099		       a8		      tay
    234  509a		       60		      rts
    235  509b
    236  509b				   PieceToShape
    237  509b
    238  509b		       00		      .byte.b	INDEX_WHITE_BLANK_on_WHITE_SQUARE_0
    239  509c		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    240  509d		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (black P)
    241  509e		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    242  509f		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    243  50a0		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    244  50a1		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    245  50a2		       18		      .byte.b	INDEX_WHITE_KING_on_WHITE_SQUARE_0
    246  50a3
    247  50a3		       48		      .byte.b	INDEX_BLACK_BLANK_on_WHITE_SQUARE_0
    248  50a4		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (white P)
    249  50a5		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    250  50a6		       50		      .byte.b	INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0
    251  50a7		       54		      .byte.b	INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0
    252  50a8		       58		      .byte.b	INDEX_BLACK_ROOK_on_WHITE_SQUARE_0
    253  50a9		       5c		      .byte.b	INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    254  50aa		       60		      .byte.b	INDEX_BLACK_KING_on_WHITE_SQUARE_0
    255  50ab
    256  50ab
    257  50ab
    258  50ab							;---------------------------------------------------------------------------------------------------
    259  50ab
------- FILE piece_vectors.asm LEVEL 3 PASS 4
      0  50ab					      include	"piece_vectors.asm"
      1  50ab							; Created by ConvertChessPieces.py
      0  50ab					      DEF	PIECE_VECTOR_LO
      1  50ab				   SLOT_PIECE_VECTOR_LO SET	_BANK_SLOT
      2  50ab				   BANK_PIECE_VECTOR_LO SET	SLOT_PIECE_VECTOR_LO + _CURRENT_BANK
      3  50ab				   PIECE_VECTOR_LO
      4  50ab				   TEMPORARY_VAR SET	Overlay
      5  50ab				   TEMPORARY_OFFSET SET	0
      6  50ab				   VAR_BOUNDARY_PIECE_VECTOR_LO SET	TEMPORARY_OFFSET
      7  50ab				   FUNCTION_NAME SET	PIECE_VECTOR_LO
      3  50ab		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_0
      4  50ac		       48		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_1
      5  50ad		       90		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_2
      6  50ae		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_3
      7  50af		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_0
      8  50b0		       90		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_1
      9  50b1		       00		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_2
     10  50b2		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_3
     11  50b3		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_0
     12  50b4		       00		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_1
     13  50b5		       48		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_2
     14  50b6		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_3
     15  50b7		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_0
     16  50b8		       48		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_1
     17  50b9		       90		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_2
     18  50ba		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_3
     19  50bb		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_0
     20  50bc		       90		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_1
     21  50bd		       00		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_2
     22  50be		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_3
     23  50bf		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_0
     24  50c0		       00		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_1
     25  50c1		       48		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_2
     26  50c2		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_3
     27  50c3		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_0
     28  50c4		       48		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_1
     29  50c5		       90		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_2
     30  50c6		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_3
     31  50c7		       00		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_0
     32  50c8		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_1
     33  50c9		       90		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_2
     34  50ca		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_3
     35  50cb		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_0
     36  50cc		       00		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_1
     37  50cd		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_2
     38  50ce		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_3
     39  50cf		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_0
     40  50d0		       90		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_1
     41  50d1		       00		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_2
     42  50d2		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_3
     43  50d3		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_0
     44  50d4		       00		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_1
     45  50d5		       48		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_2
     46  50d6		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_3
     47  50d7		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_0
     48  50d8		       48		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_1
     49  50d9		       90		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_2
     50  50da		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_3
     51  50db		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_0
     52  50dc		       90		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_1
     53  50dd		       00		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_2
     54  50de		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_3
     55  50df		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_0
     56  50e0		       00		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_1
     57  50e1		       48		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_2
     58  50e2		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_3
     59  50e3		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_0
     60  50e4		       48		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_1
     61  50e5		       90		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_2
     62  50e6		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_3
     63  50e7		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_0
     64  50e8		       90		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_1
     65  50e9		       00		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_2
     66  50ea		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_3
     67  50eb		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_0
     68  50ec		       00		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_1
     69  50ed		       48		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_2
     70  50ee		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_3
     71  50ef		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_0
     72  50f0		       90		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_1
     73  50f1		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_2
     74  50f2		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_3
     75  50f3		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_0
     76  50f4		       00		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_1
     77  50f5		       48		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_2
     78  50f6		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_3
     79  50f7		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_0
     80  50f8		       48		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_1
     81  50f9		       90		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_2
     82  50fa		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_3
     83  50fb		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_0
     84  50fc		       90		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_1
     85  50fd		       00		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_2
     86  50fe		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_3
     87  50ff		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_0
     88  5100		       00		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_1
     89  5101		       48		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_2
     90  5102		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_3
     91  5103		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_0
     92  5104		       48		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_1
     93  5105		       90		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_2
     94  5106		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_3
     95  5107		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_0
     96  5108		       90		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_1
     97  5109		       00		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_2
     98  510a		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_3
     99  510b		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_0
    100  510c		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_1
    101  510d		       48		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_2
    102  510e		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_3
    103  510f		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_0
    104  5110		       48		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_1
    105  5111		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_2
    106  5112		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_3
    107  5113		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_0
    108  5114		       90		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_1
    109  5115		       00		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_2
    110  5116		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_3
    111  5117		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_0
    112  5118		       90		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_1
    113  5119		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_2
    114  511a		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_3
    115  511b		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_0
    116  511c		       00		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_1
    117  511d		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_2
    118  511e		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_3
    119  511f		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_0
    120  5120		       48		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_1
    121  5121		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_2
    122  5122		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_3
    123  5123		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_0
    124  5124		       48		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_1
    125  5125		       90		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_2
    126  5126		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_3
    127  5127		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_0
    128  5128		       90		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_1
    129  5129		       00		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_2
    130  512a		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_3
    131  512b		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_0
    132  512c		       00		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_1
    133  512d		       48		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_2
    134  512e		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_3
    135  512f		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_0
    136  5130		       48		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_1
    137  5131		       90		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_2
    138  5132		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_3
    139  5133		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_0
    140  5134		       00		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_1
    141  5135		       48		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_2
    142  5136		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_3
    143  5137		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_0
    144  5138		       48		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_1
    145  5139		       90		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_2
    146  513a		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  513b					      DEF	PIECE_VECTOR_HI
      1  513b				   SLOT_PIECE_VECTOR_HI SET	_BANK_SLOT
      2  513b				   BANK_PIECE_VECTOR_HI SET	SLOT_PIECE_VECTOR_HI + _CURRENT_BANK
      3  513b				   PIECE_VECTOR_HI
      4  513b				   TEMPORARY_VAR SET	Overlay
      5  513b				   TEMPORARY_OFFSET SET	0
      6  513b				   VAR_BOUNDARY_PIECE_VECTOR_HI SET	TEMPORARY_OFFSET
      7  513b				   FUNCTION_NAME SET	PIECE_VECTOR_HI
    148  513b		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_0
    149  513c		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_1
    150  513d		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_2
    151  513e		       f9		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_3
    152  513f		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_0
    153  5140		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_1
    154  5141		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_2
    155  5142		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_3
    156  5143		       fa		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_0
    157  5144		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_1
    158  5145		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_2
    159  5146		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_3
    160  5147		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_0
    161  5148		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_1
    162  5149		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_2
    163  514a		       f9		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_3
    164  514b		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_0
    165  514c		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_1
    166  514d		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_2
    167  514e		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_3
    168  514f		       fa		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_0
    169  5150		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_1
    170  5151		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_2
    171  5152		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_3
    172  5153		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_0
    173  5154		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_1
    174  5155		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_2
    175  5156		       f9		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_3
    176  5157		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_0
    177  5158		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_1
    178  5159		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_2
    179  515a		       fa		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_3
    180  515b		       fa		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_0
    181  515c		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_1
    182  515d		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_2
    183  515e		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_3
    184  515f		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_0
    185  5160		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_1
    186  5161		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_2
    187  5162		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_3
    188  5163		       fa		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_0
    189  5164		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_1
    190  5165		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_2
    191  5166		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_3
    192  5167		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_0
    193  5168		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_1
    194  5169		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_2
    195  516a		       f9		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_3
    196  516b		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_0
    197  516c		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_1
    198  516d		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_2
    199  516e		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_3
    200  516f		       fa		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_0
    201  5170		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_1
    202  5171		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_2
    203  5172		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_3
    204  5173		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_0
    205  5174		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_1
    206  5175		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_2
    207  5176		       f9		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_3
    208  5177		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_0
    209  5178		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_1
    210  5179		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_2
    211  517a		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_3
    212  517b		       fa		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_0
    213  517c		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_1
    214  517d		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_2
    215  517e		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_3
    216  517f		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_0
    217  5180		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_1
    218  5181		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_2
    219  5182		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_3
    220  5183		       fa		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_0
    221  5184		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_1
    222  5185		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_2
    223  5186		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_3
    224  5187		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_0
    225  5188		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_1
    226  5189		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_2
    227  518a		       f9		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_3
    228  518b		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_0
    229  518c		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_1
    230  518d		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_2
    231  518e		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_3
    232  518f		       fa		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_0
    233  5190		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_1
    234  5191		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_2
    235  5192		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_3
    236  5193		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_0
    237  5194		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_1
    238  5195		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_2
    239  5196		       f9		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_3
    240  5197		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_0
    241  5198		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_1
    242  5199		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_2
    243  519a		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_3
    244  519b		       fa		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_0
    245  519c		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_1
    246  519d		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_2
    247  519e		       f8		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_3
    248  519f		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_0
    249  51a0		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_1
    250  51a1		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_2
    251  51a2		       f9		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_3
    252  51a3		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_0
    253  51a4		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_1
    254  51a5		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_2
    255  51a6		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_3
    256  51a7		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_0
    257  51a8		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_1
    258  51a9		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_2
    259  51aa		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_3
    260  51ab		       f9		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_0
    261  51ac		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_1
    262  51ad		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_2
    263  51ae		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_3
    264  51af		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_0
    265  51b0		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_1
    266  51b1		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_2
    267  51b2		       f8		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_3
    268  51b3		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_0
    269  51b4		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_1
    270  51b5		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_2
    271  51b6		       fa		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_3
    272  51b7		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_0
    273  51b8		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_1
    274  51b9		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_2
    275  51ba		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_3
    276  51bb		       fb		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_0
    277  51bc		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_1
    278  51bd		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_2
    279  51be		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_3
    280  51bf		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_0
    281  51c0		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_1
    282  51c1		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_2
    283  51c2		       fa		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_3
    284  51c3		       fa		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_0
    285  51c4		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_1
    286  51c5		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_2
    287  51c6		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_3
    288  51c7		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_0
    289  51c8		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_1
    290  51c9		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_2
    291  51ca		       f9		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  51cb					      DEF	PIECE_VECTOR_BANK
      1  51cb				   SLOT_PIECE_VECTOR_BANK SET	_BANK_SLOT
      2  51cb				   BANK_PIECE_VECTOR_BANK SET	SLOT_PIECE_VECTOR_BANK + _CURRENT_BANK
      3  51cb				   PIECE_VECTOR_BANK
      4  51cb				   TEMPORARY_VAR SET	Overlay
      5  51cb				   TEMPORARY_OFFSET SET	0
      6  51cb				   VAR_BOUNDARY_PIECE_VECTOR_BANK SET	TEMPORARY_OFFSET
      7  51cb				   FUNCTION_NAME SET	PIECE_VECTOR_BANK
    293  51cb		       8b		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_0
    294  51cc		       8b		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_1
    295  51cd		       8b		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_2
    296  51ce		       8b		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_3
    297  51cf		       8b		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_0
    298  51d0		       8b		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_1
    299  51d1		       8b		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_2
    300  51d2		       8b		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_3
    301  51d3		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0
    302  51d4		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1
    303  51d5		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2
    304  51d6		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3
    305  51d7		       8c		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_0
    306  51d8		       8c		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_1
    307  51d9		       8c		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_2
    308  51da		       8c		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_3
    309  51db		       8c		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_0
    310  51dc		       8c		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_1
    311  51dd		       8c		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_2
    312  51de		       8c		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_3
    313  51df		       8c		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_0
    314  51e0		       8c		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_1
    315  51e1		       8c		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_2
    316  51e2		       8c		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_3
    317  51e3		       8d		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_0
    318  51e4		       8d		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_1
    319  51e5		       8d		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_2
    320  51e6		       8d		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_3
    321  51e7		       97		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_0
    322  51e8		       97		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_1
    323  51e9		       97		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_2
    324  51ea		       98		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_3
    325  51eb		       99		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0
    326  51ec		       99		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1
    327  51ed		       99		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2
    328  51ee		       99		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3
    329  51ef		       8d		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_0
    330  51f0		       8d		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_1
    331  51f1		       8d		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_2
    332  51f2		       8d		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_3
    333  51f3		       8d		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_0
    334  51f4		       8d		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_1
    335  51f5		       8d		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_2
    336  51f6		       8d		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_3
    337  51f7		       8e		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0
    338  51f8		       8e		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1
    339  51f9		       8e		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2
    340  51fa		       8e		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3
    341  51fb		       8e		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_0
    342  51fc		       8e		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_1
    343  51fd		       8e		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_2
    344  51fe		       8e		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_3
    345  51ff		       8e		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_0
    346  5200		       8e		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_1
    347  5201		       8e		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_2
    348  5202		       8e		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_3
    349  5203		       8f		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_0
    350  5204		       8f		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_1
    351  5205		       8f		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_2
    352  5206		       8f		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_3
    353  5207		       8f		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_0
    354  5208		       8f		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_1
    355  5209		       8f		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_2
    356  520a		       8f		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_3
    357  520b		       96		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_0
    358  520c		       96		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_1
    359  520d		       96		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_2
    360  520e		       96		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_3
    361  520f		       99		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0
    362  5210		       99		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1
    363  5211		       99		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2
    364  5212		       99		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3
    365  5213		       8f		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_0
    366  5214		       8f		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_1
    367  5215		       8f		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_2
    368  5216		       8f		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_3
    369  5217		       90		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_0
    370  5218		       90		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_1
    371  5219		       90		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_2
    372  521a		       90		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_3
    373  521b		       90		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0
    374  521c		       90		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1
    375  521d		       90		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2
    376  521e		       90		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3
    377  521f		       90		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_0
    378  5220		       90		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_1
    379  5221		       90		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_2
    380  5222		       90		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_3
    381  5223		       91		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_0
    382  5224		       91		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_1
    383  5225		       91		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_2
    384  5226		       91		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_3
    385  5227		       91		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_0
    386  5228		       91		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_1
    387  5229		       91		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_2
    388  522a		       91		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_3
    389  522b		       91		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_0
    390  522c		       91		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_1
    391  522d		       91		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_2
    392  522e		       92		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_3
    393  522f		       99		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_0
    394  5230		       99		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_1
    395  5231		       99		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_2
    396  5232		       99		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_3
    397  5233		       96		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0
    398  5234		       96		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1
    399  5235		       96		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2
    400  5236		       96		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3
    401  5237		       92		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_0
    402  5238		       92		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_1
    403  5239		       92		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_2
    404  523a		       92		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_3
    405  523b		       92		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_0
    406  523c		       92		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_1
    407  523d		       92		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_2
    408  523e		       92		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_3
    409  523f		       92		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0
    410  5240		       92		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1
    411  5241		       92		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2
    412  5242		       93		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3
    413  5243		       97		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_0
    414  5244		       97		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_1
    415  5245		       97		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_2
    416  5246		       97		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_3
    417  5247		       97		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_0
    418  5248		       97		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_1
    419  5249		       97		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_2
    420  524a		       97		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_3
    421  524b		       97		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_0
    422  524c		       98		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_1
    423  524d		       98		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_2
    424  524e		       98		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_3
    425  524f		       98		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_0
    426  5250		       98		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_1
    427  5251		       98		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_2
    428  5252		       98		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_3
    429  5253		       98		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_0
    430  5254		       98		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_1
    431  5255		       98		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_2
    432  5256		       98		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_3
    433  5257		       96		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0
    434  5258		       96		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1
    435  5259		       96		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2
    436  525a		       96		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3
    437  525b
    438  525b							; piece index equates...
    439  525b		       00 00	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_0 =	0
    440  525b		       00 01	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_1 =	1
    441  525b		       00 02	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_2 =	2
    442  525b		       00 03	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_3 =	3
    443  525b		       00 04	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_0 =	4
    444  525b		       00 05	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_1 =	5
    445  525b		       00 06	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_2 =	6
    446  525b		       00 07	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_3 =	7
    447  525b		       00 08	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0 =	8
    448  525b		       00 09	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_1 =	9
    449  525b		       00 0a	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_2 =	10
    450  525b		       00 0b	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_3 =	11
    451  525b		       00 0c	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0 =	12
    452  525b		       00 0d	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_1 =	13
    453  525b		       00 0e	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_2 =	14
    454  525b		       00 0f	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_3 =	15
    455  525b		       00 10	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_0 =	16
    456  525b		       00 11	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_1 =	17
    457  525b		       00 12	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_2 =	18
    458  525b		       00 13	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_3 =	19
    459  525b		       00 14	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0 =	20
    460  525b		       00 15	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_1 =	21
    461  525b		       00 16	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_2 =	22
    462  525b		       00 17	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_3 =	23
    463  525b		       00 18	   INDEX_WHITE_KING_on_WHITE_SQUARE_0 =	24
    464  525b		       00 19	   INDEX_WHITE_KING_on_WHITE_SQUARE_1 =	25
    465  525b		       00 1a	   INDEX_WHITE_KING_on_WHITE_SQUARE_2 =	26
    466  525b		       00 1b	   INDEX_WHITE_KING_on_WHITE_SQUARE_3 =	27
    467  525b		       00 1c	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_0 =	28
    468  525b		       00 1d	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_1 =	29
    469  525b		       00 1e	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_2 =	30
    470  525b		       00 1f	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_3 =	31
    471  525b		       00 20	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0 =	32
    472  525b		       00 21	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_1 =	33
    473  525b		       00 22	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_2 =	34
    474  525b		       00 23	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_3 =	35
    475  525b		       00 24	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_0 =	36
    476  525b		       00 25	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_1 =	37
    477  525b		       00 26	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_2 =	38
    478  525b		       00 27	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_3 =	39
    479  525b		       00 28	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_0 =	40
    480  525b		       00 29	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_1 =	41
    481  525b		       00 2a	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_2 =	42
    482  525b		       00 2b	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_3 =	43
    483  525b		       00 2c	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_0 =	44
    484  525b		       00 2d	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_1 =	45
    485  525b		       00 2e	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_2 =	46
    486  525b		       00 2f	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_3 =	47
    487  525b		       00 30	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_0 =	48
    488  525b		       00 31	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_1 =	49
    489  525b		       00 32	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_2 =	50
    490  525b		       00 33	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_3 =	51
    491  525b		       00 34	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_0 =	52
    492  525b		       00 35	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_1 =	53
    493  525b		       00 36	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_2 =	54
    494  525b		       00 37	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_3 =	55
    495  525b		       00 38	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_0 =	56
    496  525b		       00 39	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_1 =	57
    497  525b		       00 3a	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_2 =	58
    498  525b		       00 3b	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_3 =	59
    499  525b		       00 3c	   INDEX_WHITE_KING_on_BLACK_SQUARE_0 =	60
    500  525b		       00 3d	   INDEX_WHITE_KING_on_BLACK_SQUARE_1 =	61
    501  525b		       00 3e	   INDEX_WHITE_KING_on_BLACK_SQUARE_2 =	62
    502  525b		       00 3f	   INDEX_WHITE_KING_on_BLACK_SQUARE_3 =	63
    503  525b		       00 40	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_0 =	64
    504  525b		       00 41	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_1 =	65
    505  525b		       00 42	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_2 =	66
    506  525b		       00 43	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_3 =	67
    507  525b		       00 44	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_0 =	68
    508  525b		       00 45	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_1 =	69
    509  525b		       00 46	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_2 =	70
    510  525b		       00 47	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_3 =	71
    511  525b		       00 48	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_0 =	72
    512  525b		       00 49	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_1 =	73
    513  525b		       00 4a	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_2 =	74
    514  525b		       00 4b	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_3 =	75
    515  525b		       00 4c	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_0 =	76
    516  525b		       00 4d	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_1 =	77
    517  525b		       00 4e	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_2 =	78
    518  525b		       00 4f	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_3 =	79
    519  525b		       00 50	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0 =	80
    520  525b		       00 51	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_1 =	81
    521  525b		       00 52	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_2 =	82
    522  525b		       00 53	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_3 =	83
    523  525b		       00 54	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0 =	84
    524  525b		       00 55	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_1 =	85
    525  525b		       00 56	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_2 =	86
    526  525b		       00 57	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_3 =	87
    527  525b		       00 58	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_0 =	88
    528  525b		       00 59	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_1 =	89
    529  525b		       00 5a	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_2 =	90
    530  525b		       00 5b	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_3 =	91
    531  525b		       00 5c	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0 =	92
    532  525b		       00 5d	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_1 =	93
    533  525b		       00 5e	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_2 =	94
    534  525b		       00 5f	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_3 =	95
    535  525b		       00 60	   INDEX_BLACK_KING_on_WHITE_SQUARE_0 =	96
    536  525b		       00 61	   INDEX_BLACK_KING_on_WHITE_SQUARE_1 =	97
    537  525b		       00 62	   INDEX_BLACK_KING_on_WHITE_SQUARE_2 =	98
    538  525b		       00 63	   INDEX_BLACK_KING_on_WHITE_SQUARE_3 =	99
    539  525b		       00 64	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_0 =	100
    540  525b		       00 65	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_1 =	101
    541  525b		       00 66	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_2 =	102
    542  525b		       00 67	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_3 =	103
    543  525b		       00 68	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0 =	104
    544  525b		       00 69	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_1 =	105
    545  525b		       00 6a	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_2 =	106
    546  525b		       00 6b	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_3 =	107
    547  525b		       00 6c	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_0 =	108
    548  525b		       00 6d	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_1 =	109
    549  525b		       00 6e	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_2 =	110
    550  525b		       00 6f	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_3 =	111
    551  525b		       00 70	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_0 =	112
    552  525b		       00 71	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_1 =	113
    553  525b		       00 72	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_2 =	114
    554  525b		       00 73	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_3 =	115
    555  525b		       00 74	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_0 =	116
    556  525b		       00 75	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_1 =	117
    557  525b		       00 76	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_2 =	118
    558  525b		       00 77	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_3 =	119
    559  525b		       00 78	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_0 =	120
    560  525b		       00 79	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_1 =	121
    561  525b		       00 7a	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_2 =	122
    562  525b		       00 7b	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_3 =	123
    563  525b		       00 7c	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_0 =	124
    564  525b		       00 7d	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_1 =	125
    565  525b		       00 7e	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_2 =	126
    566  525b		       00 7f	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_3 =	127
    567  525b		       00 80	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_0 =	128
    568  525b		       00 81	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_1 =	129
    569  525b		       00 82	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_2 =	130
    570  525b		       00 83	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_3 =	131
    571  525b		       00 84	   INDEX_BLACK_KING_on_BLACK_SQUARE_0 =	132
    572  525b		       00 85	   INDEX_BLACK_KING_on_BLACK_SQUARE_1 =	133
    573  525b		       00 86	   INDEX_BLACK_KING_on_BLACK_SQUARE_2 =	134
    574  525b		       00 87	   INDEX_BLACK_KING_on_BLACK_SQUARE_3 =	135
    575  525b		       00 88	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_0 =	136
    576  525b		       00 89	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_1 =	137
    577  525b		       00 8a	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_2 =	138
    578  525b		       00 8b	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_3 =	139
    579  525b		       00 8c	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_0 =	140
    580  525b		       00 8d	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_1 =	141
    581  525b		       00 8e	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_2 =	142
    582  525b		       00 8f	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_3 =	143
------- FILE BANK_GENERIC@2.asm
    261  525b
    262  525b							;---------------------------------------------------------------------------------------------------
    263  525b
      0  525b					      CHECK_BANK_SIZE	"BANK_GENERIC@2"
      1  525b		       02 5b	   .TEMP      =	* - _BANK_START
 BANK_GENERIC@2 (1K) SIZE =  $25b , FREE= $1a5
      2  525b					      ECHO	"BANK_GENERIC@2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  525b				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  525b				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC@2", " size=", * - ORIGIN
      5  525b				  -	      ERR
      6  525b					      ENDIF
    265  525b
    266  525b							;---------------------------------------------------------------------------------------------------
    267  525b							;EOF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@1#3.asm LEVEL 2 PASS 4
      0  525b					      include	"BANK_GENERIC@1#3.asm"
      0  525b					      SLOT	1
      1  525b				  -	      IF	(1 < 0) || (1 > 3)
      2  525b				  -	      ECHO	"Illegal bank address/segment location", 1
      3  525b				  -	      ERR
      4  525b					      ENDIF
      5  525b				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  525b				   _BANK_SLOT SET	1 * 64
      0  525b					      NEWBANK	GENERIC_BANK_2
      1  5483 ????				      SEG	GENERIC_BANK_2
      2  5400					      ORG	_ORIGIN
      3  5400					      RORG	_BANK_ADDRESS_ORIGIN
      4  5400				   _BANK_START SET	*
      5  5400				   GENERIC_BANK_2_START SET	*
      6  5400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5400				   GENERIC_BANK_2 SET	_BANK_SLOT + _CURRENT_BANK
      8  5400				   _ORIGIN    SET	_ORIGIN + 1024
      3  5400
      4  5400							;---------------------------------------------------------------------------------------------------
      5  5400
      0  5400					      DEF	aiWriteStartPieceBlank
      1  5400				   SLOT_aiWriteStartPieceBlank SET	_BANK_SLOT
      2  5400				   BANK_aiWriteStartPieceBlank SET	SLOT_aiWriteStartPieceBlank + _CURRENT_BANK
      3  5400				   aiWriteStartPieceBlank
      4  5400				   TEMPORARY_VAR SET	Overlay
      5  5400				   TEMPORARY_OFFSET SET	0
      6  5400				   VAR_BOUNDARY_aiWriteStartPieceBlank SET	TEMPORARY_OFFSET
      7  5400				   FUNCTION_NAME SET	aiWriteStartPieceBlank
      7  5400					      SUBROUTINE
      8  5400
      0  5400					      REFER	AiStateMachine
      1  5400				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5400				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5400					      ENDIF
      0  5400					      VEND	aiWriteStartPieceBlank
      1  5400				  -	      IFNCONST	aiWriteStartPieceBlank
      2  5400				  -	      ECHO	"Incorrect VEND label", aiWriteStartPieceBlank
      3  5400				  -	      ERR
      4  5400					      ENDIF
      5  5400		       00 a2	   VAREND_aiWriteStartPieceBlank =	TEMPORARY_VAR
     11  5400
     12  5400							; Flash the piece in-place preparatory to moving it.
     13  5400							; drawDelay = flash speed
     14  5400							; drawCount = # of flashes
     15  5400
     16  5400		       a5 87		      lda	originX12
     17  5402		       85 88		      sta	cursorX12
     18  5404
     19  5404		       a9 04		      lda	#%100
     20  5406		       85 4a		      sta	CTRLPF
     21  5408		       a9 02		      lda	#2
     22  540a		       85 46		      sta	COLUP0
     23  540c
     24  540c
     25  540c		       a5 82		      lda	drawDelay
     26  540e		       f0 03		      beq	deCount
     27  5410		       c6 82		      dec	drawDelay
     28  5412		       60		      rts
     29  5413				   deCount
     30  5413
     31  5413		       a5 84		      lda	drawCount
     32  5415		       f0 0e		      beq	flashDone
     33  5417		       c6 84		      dec	drawCount
     34  5419
     35  5419		       a9 0a		      lda	#READY_TO_MOVE_FLASH
     36  541b		       85 82		      sta	drawDelay	; "getting ready to move" flash
     37  541d
     38  541d		       a5 85		      lda	fromX12
     39  541f		       85 80		      sta	squareToDraw
     40  5421
     41  5421		       20 98 f0 	      jsr	CopySinglePiece	;@0	      ; EOR-draw = flash
     42  5424		       60		      rts
     43  5425
     44  5425				   flashDone
     45  5425
      0  5425					      PHASE	AI_MarchToTargetA
      1  5425		       a9 16		      lda	#AI_MarchToTargetA
      2  5427		       85 8c		      sta	aiState
     47  5429		       60		      rts
     48  542a
     49  542a
     50  542a							;---------------------------------------------------------------------------------------------------
     51  542a
      0  542a					      DEF	aiDrawPart2
      1  542a				   SLOT_aiDrawPart2 SET	_BANK_SLOT
      2  542a				   BANK_aiDrawPart2 SET	SLOT_aiDrawPart2 + _CURRENT_BANK
      3  542a				   aiDrawPart2
      4  542a				   TEMPORARY_VAR SET	Overlay
      5  542a				   TEMPORARY_OFFSET SET	0
      6  542a				   VAR_BOUNDARY_aiDrawPart2 SET	TEMPORARY_OFFSET
      7  542a				   FUNCTION_NAME SET	aiDrawPart2
     53  542a					      SUBROUTINE
     54  542a
      0  542a					      REFER	AiStateMachine
      1  542a				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  542a				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  542a					      ENDIF
      0  542a					      VEND	aiDrawPart2
      1  542a				  -	      IFNCONST	aiDrawPart2
      2  542a				  -	      ECHO	"Incorrect VEND label", aiDrawPart2
      3  542a				  -	      ERR
      4  542a					      ENDIF
      5  542a		       00 a2	   VAREND_aiDrawPart2 =	TEMPORARY_VAR
     57  542a
     58  542a		       20 98 f0 	      jsr	CopySinglePiece	;@0
     59  542d
      0  542d					      DEF	aiDrawPart3
      1  542d				   SLOT_aiDrawPart3 SET	_BANK_SLOT
      2  542d				   BANK_aiDrawPart3 SET	SLOT_aiDrawPart3 + _CURRENT_BANK
      3  542d				   aiDrawPart3
      4  542d				   TEMPORARY_VAR SET	Overlay
      5  542d				   TEMPORARY_OFFSET SET	0
      6  542d				   VAR_BOUNDARY_aiDrawPart3 SET	TEMPORARY_OFFSET
      7  542d				   FUNCTION_NAME SET	aiDrawPart3
     61  542d					      SUBROUTINE
     62  542d
     63  542d		       c6 80		      dec	squareToDraw
     64  542f		       a5 80		      lda	squareToDraw
     65  5431		       c9 16		      cmp	#22
     66  5433		       90 05		      bcc	.comp
     67  5435
      0  5435					      PHASE	AI_DrawEntireBoard
      1  5435		       a9 0f		      lda	#AI_DrawEntireBoard
      2  5437		       85 8c		      sta	aiState
     69  5439		       60		      rts
     70  543a
     71  543a				   .comp
     72  543a
     73  543a		       a9 ff		      lda	#-1
     74  543c		       85 86		      sta	toX12	; becomes startup flash square
     75  543e		       a9 24		      lda	#36	; becomes cursor position
     76  5440		       85 87		      sta	originX12
     77  5442
     78  5442
      0  5442					      PHASE	AI_GenerateMoves
      1  5442		       a9 12		      lda	#AI_GenerateMoves
      2  5444		       85 8c		      sta	aiState
     80  5446		       60		      rts
     81  5447
     82  5447
     83  5447
     84  5447
     85  5447							;---------------------------------------------------------------------------------------------------
     86  5447
      0  5447					      DEF	aiMarchB
      1  5447				   SLOT_aiMarchB SET	_BANK_SLOT
      2  5447				   BANK_aiMarchB SET	SLOT_aiMarchB + _CURRENT_BANK
      3  5447				   aiMarchB
      4  5447				   TEMPORARY_VAR SET	Overlay
      5  5447				   TEMPORARY_OFFSET SET	0
      6  5447				   VAR_BOUNDARY_aiMarchB SET	TEMPORARY_OFFSET
      7  5447				   FUNCTION_NAME SET	aiMarchB
     88  5447					      SUBROUTINE
     89  5447
      0  5447					      REFER	AiStateMachine
      1  5447				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5447				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5447					      ENDIF
      0  5447					      VEND	aiMarchB
      1  5447				  -	      IFNCONST	aiMarchB
      2  5447				  -	      ECHO	"Incorrect VEND label", aiMarchB
      3  5447				  -	      ERR
      4  5447					      ENDIF
      5  5447		       00 a2	   VAREND_aiMarchB =	TEMPORARY_VAR
     92  5447
     93  5447							; Draw the piece in the new square
     94  5447
     95  5447		       a5 85		      lda	fromX12
     96  5449		       85 80		      sta	squareToDraw
     97  544b
     98  544b		       20 98 f0 	      jsr	CopySinglePiece	;@0	      ; draw the moving piece into the new square
     99  544e
    100  544e		       a9 06		      lda	#6	; snail trail delay
    101  5450		       85 82		      sta	drawDelay
    102  5452
      0  5452					      PHASE	AI_MarchToTargetB
      1  5452		       a9 19		      lda	#AI_MarchToTargetB
      2  5454		       85 8c		      sta	aiState
    104  5456		       60		      rts
    105  5457
    106  5457
    107  5457							;---------------------------------------------------------------------------------------------------
    108  5457
      0  5457					      DEF	aiFinalFlash
      1  5457				   SLOT_aiFinalFlash SET	_BANK_SLOT
      2  5457				   BANK_aiFinalFlash SET	SLOT_aiFinalFlash + _CURRENT_BANK
      3  5457				   aiFinalFlash
      4  5457				   TEMPORARY_VAR SET	Overlay
      5  5457				   TEMPORARY_OFFSET SET	0
      6  5457				   VAR_BOUNDARY_aiFinalFlash SET	TEMPORARY_OFFSET
      7  5457				   FUNCTION_NAME SET	aiFinalFlash
    110  5457					      SUBROUTINE
    111  5457
      0  5457					      REFER	AiStateMachine
      1  5457				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5457				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5457					      ENDIF
      0  5457					      VEND	aiFinalFlash
      1  5457				  -	      IFNCONST	aiFinalFlash
      2  5457				  -	      ECHO	"Incorrect VEND label", aiFinalFlash
      3  5457				  -	      ERR
      4  5457					      ENDIF
      5  5457		       00 a2	   VAREND_aiFinalFlash =	TEMPORARY_VAR
    114  5457
    115  5457
    116  5457		       a5 82		      lda	drawDelay
    117  5459		       f0 03		      beq	.deCount
    118  545b		       c6 82		      dec	drawDelay
    119  545d		       60		      rts
    120  545e
    121  545e		       a5 84	   .deCount   lda	drawCount
    122  5460		       f0 0e		      beq	.flashDone2
    123  5462		       c6 84		      dec	drawCount
    124  5464
    125  5464		       a9 0a		      lda	#10
    126  5466		       85 82		      sta	drawDelay	; "getting ready to move" flash
    127  5468
    128  5468		       a5 85		      lda	fromX12
    129  546a		       85 80		      sta	squareToDraw
    130  546c
    131  546c		       20 98 f0 	      jsr	CopySinglePiece	;@0
    132  546f		       60		      rts
    133  5470
    134  5470				   .flashDone2
    135  5470
    136  5470		       a9 64		      lda	#100
    137  5472		       85 8d		      sta	aiFlashDelay
    138  5474
      0  5474					      PHASE	AI_SpecialMoveFixup
      1  5474		       a9 1c		      lda	#AI_SpecialMoveFixup
      2  5476		       85 8c		      sta	aiState
    140  5478		       60		      rts
    141  5479
    142  5479
    143  5479							;---------------------------------------------------------------------------------------------------
    144  5479
      0  5479					      DEF	aiDraw
      1  5479				   SLOT_aiDraw SET	_BANK_SLOT
      2  5479				   BANK_aiDraw SET	SLOT_aiDraw + _CURRENT_BANK
      3  5479				   aiDraw
      4  5479				   TEMPORARY_VAR SET	Overlay
      5  5479				   TEMPORARY_OFFSET SET	0
      6  5479				   VAR_BOUNDARY_aiDraw SET	TEMPORARY_OFFSET
      7  5479				   FUNCTION_NAME SET	aiDraw
    146  5479					      SUBROUTINE
    147  5479		       a9 c0		      lda	#$C0
    148  547b		       85 49		      sta	COLUBK
    149  547d		       60		      rts
    150  547e
    151  547e
    152  547e							;---------------------------------------------------------------------------------------------------
    153  547e
      0  547e					      DEF	aiCheckMate
      1  547e				   SLOT_aiCheckMate SET	_BANK_SLOT
      2  547e				   BANK_aiCheckMate SET	SLOT_aiCheckMate + _CURRENT_BANK
      3  547e				   aiCheckMate
      4  547e				   TEMPORARY_VAR SET	Overlay
      5  547e				   TEMPORARY_OFFSET SET	0
      6  547e				   VAR_BOUNDARY_aiCheckMate SET	TEMPORARY_OFFSET
      7  547e				   FUNCTION_NAME SET	aiCheckMate
    155  547e					      SUBROUTINE
    156  547e		       a9 44		      lda	#$44
    157  5480		       85 49		      sta	COLUBK
    158  5482		       60		      rts
    159  5483
    160  5483							;---------------------------------------------------------------------------------------------------
    161  5483
      0  5483					      CHECK_BANK_SIZE	"BANK_GENERIC2"
      1  5483		       00 83	   .TEMP      =	* - _BANK_START
 BANK_GENERIC2 (1K) SIZE =  $83 , FREE= $37d
      2  5483					      ECHO	"BANK_GENERIC2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5483				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5483				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC2", " size=", * - ORIGIN
      5  5483				  -	      ERR
      6  5483					      ENDIF
    163  5483
    164  5483							;---------------------------------------------------------------------------------------------------
    165  5483							;EOF
------- FILE ./chess.asm
------- FILE GFX1.asm LEVEL 2 PASS 4
      0  5483					      include	"GFX1.asm"
      0  5483					      SLOT	2
      1  5483				  -	      IF	(2 < 0) || (2 > 3)
      2  5483				  -	      ECHO	"Illegal bank address/segment location", 2
      3  5483				  -	      ERR
      4  5483					      ENDIF
      5  5483				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  5483				   _BANK_SLOT SET	2 * 64
      0  5483					      NEWBANK	GFX1
      1  5bd8 ????				      SEG	GFX1
      2  5800					      ORG	_ORIGIN
      3  5800					      RORG	_BANK_ADDRESS_ORIGIN
      4  5800				   _BANK_START SET	*
      5  5800				   GFX1_START SET	*
      6  5800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5800				   GFX1       SET	_BANK_SLOT + _CURRENT_BANK
      8  5800				   _ORIGIN    SET	_ORIGIN + 1024
      3  5800
      4  5800
      5  5800							;---------------------------------------------------------------------------------------------------
      6  5800
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5800					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  5800					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_0", 72
     12  5800					      LIST	ON
      0  5800					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_0
      1  5800				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5800				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5800				   BLACK_PROMOTE_on_BLACK_SQUARE_0
      4  5800				   TEMPORARY_VAR SET	Overlay
      5  5800				   TEMPORARY_OFFSET SET	0
      6  5800				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5800				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_0
      3  5800		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5848					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  5848					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_1", 72
     12  5848					      LIST	ON
      0  5848					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_1
      1  5848				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5848				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5848				   BLACK_PROMOTE_on_BLACK_SQUARE_1
      4  5848				   TEMPORARY_VAR SET	Overlay
      5  5848				   TEMPORARY_OFFSET SET	0
      6  5848				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5848				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_1
      3  5848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5860		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5890					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  5890					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_2", 72
     12  5890					      LIST	ON
      0  5890					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_2
      1  5890				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5890				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5890				   BLACK_PROMOTE_on_BLACK_SQUARE_2
      4  5890				   TEMPORARY_VAR SET	Overlay
      5  5890				   TEMPORARY_OFFSET SET	0
      6  5890				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5890				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_2
      3  5890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  58a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  58c0		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  58d8					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  58d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_3", 72
     12  5900					      LIST	ON
      0  5900					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_3
      1  5900				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5900				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5900				   BLACK_PROMOTE_on_BLACK_SQUARE_3
      4  5900				   TEMPORARY_VAR SET	Overlay
      5  5900				   TEMPORARY_OFFSET SET	0
      6  5900				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5900				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_3
      3  5900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5930		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5948					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  5948					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_0", 72
     12  5948					      LIST	ON
      0  5948					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_0
      1  5948				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5948				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5948				   BLACK_PROMOTE_on_WHITE_SQUARE_0
      4  5948				   TEMPORARY_VAR SET	Overlay
      5  5948				   TEMPORARY_OFFSET SET	0
      6  5948				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5948				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_0
      3  5948		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  5960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5990					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  5990					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_1", 72
     12  5990					      LIST	ON
      0  5990					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_1
      1  5990				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5990				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5990				   BLACK_PROMOTE_on_WHITE_SQUARE_1
      4  5990				   TEMPORARY_VAR SET	Overlay
      5  5990				   TEMPORARY_OFFSET SET	0
      6  5990				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5990				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_1
      3  5990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  59a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  59c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  59d8					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  59d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_2", 72
     12  5a00					      LIST	ON
      0  5a00					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_2
      1  5a00				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5a00				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5a00				   BLACK_PROMOTE_on_WHITE_SQUARE_2
      4  5a00				   TEMPORARY_VAR SET	Overlay
      5  5a00				   TEMPORARY_OFFSET SET	0
      6  5a00				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5a00				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_2
      3  5a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  5a30		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5a48					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  5a48					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_3", 72
     12  5a48					      LIST	ON
      0  5a48					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_3
      1  5a48				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5a48				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5a48				   BLACK_PROMOTE_on_WHITE_SQUARE_3
      4  5a48				   TEMPORARY_VAR SET	Overlay
      5  5a48				   TEMPORARY_OFFSET SET	0
      6  5a48				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5a48				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_3
      3  5a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5a78		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE GFX1.asm
     15  5a90
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5a90					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm"
      0  5a90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_0", 72
     12  5a90					      LIST	ON
      0  5a90					      DEF	WHITE_MARKER_on_BLACK_SQUARE_0
      1  5a90				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5a90				   BANK_WHITE_MARKER_on_BLACK_SQUARE_0 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5a90				   WHITE_MARKER_on_BLACK_SQUARE_0
      4  5a90				   TEMPORARY_VAR SET	Overlay
      5  5a90				   TEMPORARY_OFFSET SET	0
      6  5a90				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5a90				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_0
      3  5a90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5ad8					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm"
      0  5ad8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_1", 72
     12  5b00					      LIST	ON
      0  5b00					      DEF	WHITE_MARKER_on_BLACK_SQUARE_1
      1  5b00				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5b00				   BANK_WHITE_MARKER_on_BLACK_SQUARE_1 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5b00				   WHITE_MARKER_on_BLACK_SQUARE_1
      4  5b00				   TEMPORARY_VAR SET	Overlay
      5  5b00				   TEMPORARY_OFFSET SET	0
      6  5b00				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5b00				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_1
      3  5b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5b18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5b48					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm"
      0  5b48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_2", 72
     12  5b48					      LIST	ON
      0  5b48					      DEF	WHITE_MARKER_on_BLACK_SQUARE_2
      1  5b48				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5b48				   BANK_WHITE_MARKER_on_BLACK_SQUARE_2 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5b48				   WHITE_MARKER_on_BLACK_SQUARE_2
      4  5b48				   TEMPORARY_VAR SET	Overlay
      5  5b48				   TEMPORARY_OFFSET SET	0
      6  5b48				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5b48				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_2
      3  5b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5b60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5b78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5b90					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm"
      0  5b90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_3", 72
     12  5b90					      LIST	ON
      0  5b90					      DEF	WHITE_MARKER_on_BLACK_SQUARE_3
      1  5b90				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5b90				   BANK_WHITE_MARKER_on_BLACK_SQUARE_3 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5b90				   WHITE_MARKER_on_BLACK_SQUARE_3
      4  5b90				   TEMPORARY_VAR SET	Overlay
      5  5b90				   TEMPORARY_OFFSET SET	0
      6  5b90				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5b90				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_3
      3  5b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5bc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
     20  5bd8
     21  5bd8
     22  5bd8							;---------------------------------------------------------------------------------------------------
     23  5bd8
      0  5bd8					      CHECK_BANK_SIZE	"BANK_GFX1"
      1  5bd8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX1 (1K) SIZE =  $3d8 , FREE= $28
      2  5bd8					      ECHO	"BANK_GFX1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5bd8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX1", " size=", * - ORIGIN
      5  5bd8				  -	      ERR
      6  5bd8					      ENDIF
     25  5bd8
     26  5bd8							;---------------------------------------------------------------------------------------------------
     27  5bd8							;EOF
------- FILE ./chess.asm
------- FILE GFX2.asm LEVEL 2 PASS 4
      0  5bd8					      include	"GFX2.asm"
      0  5bd8					      SLOT	2
      1  5bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  5bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  5bd8				  -	      ERR
      4  5bd8					      ENDIF
      5  5bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  5bd8				   _BANK_SLOT SET	2 * 64
      0  5bd8					      NEWBANK	GFX2
      1  5fd8 ????				      SEG	GFX2
      2  5c00					      ORG	_ORIGIN
      3  5c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  5c00				   _BANK_START SET	*
      5  5c00				   GFX2_START SET	*
      6  5c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5c00				   GFX2       SET	_BANK_SLOT + _CURRENT_BANK
      8  5c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  5c00
      4  5c00							;---------------------------------------------------------------------------------------------------
      5  5c00
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5c00					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm"
      0  5c00					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_0", 72
     12  5c00					      LIST	ON
      0  5c00					      DEF	WHITE_MARKER_on_WHITE_SQUARE_0
      1  5c00				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5c00				   BANK_WHITE_MARKER_on_WHITE_SQUARE_0 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5c00				   WHITE_MARKER_on_WHITE_SQUARE_0
      4  5c00				   TEMPORARY_VAR SET	Overlay
      5  5c00				   TEMPORARY_OFFSET SET	0
      6  5c00				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5c00				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_0
      3  5c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00	;PF0
      4  5c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5c48					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm"
      0  5c48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_1", 72
     12  5c48					      LIST	ON
      0  5c48					      DEF	WHITE_MARKER_on_WHITE_SQUARE_1
      1  5c48				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5c48				   BANK_WHITE_MARKER_on_WHITE_SQUARE_1 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5c48				   WHITE_MARKER_on_WHITE_SQUARE_1
      4  5c48				   TEMPORARY_VAR SET	Overlay
      5  5c48				   TEMPORARY_OFFSET SET	0
      6  5c48				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5c48				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_1
      3  5c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5c60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00	;PF1
      5  5c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5c90					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm"
      0  5c90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_2", 72
     12  5c90					      LIST	ON
      0  5c90					      DEF	WHITE_MARKER_on_WHITE_SQUARE_2
      1  5c90				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5c90				   BANK_WHITE_MARKER_on_WHITE_SQUARE_2 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5c90				   WHITE_MARKER_on_WHITE_SQUARE_2
      4  5c90				   TEMPORARY_VAR SET	Overlay
      5  5c90				   TEMPORARY_OFFSET SET	0
      6  5c90				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5c90				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_2
      3  5c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00	;PF1
      5  5cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00	;PF2
------- FILE GFX2.asm
      9  5cd8
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5cd8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm"
      0  5cd8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_0", 72
     12  5d00					      LIST	ON
      0  5d00					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_0
      1  5d00				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5d00				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5d00				   BLACK_BISHOP_on_BLACK_SQUARE_0
      4  5d00				   TEMPORARY_VAR SET	Overlay
      5  5d00				   TEMPORARY_OFFSET SET	0
      6  5d00				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5d00				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_0
      3  5d00		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$40,$00	;PF0
      4  5d18		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5d48					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm"
      0  5d48					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_1", 72
     12  5d48					      LIST	ON
      0  5d48					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_1
      1  5d48				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5d48				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5d48				   BLACK_BISHOP_on_BLACK_SQUARE_1
      4  5d48				   TEMPORARY_VAR SET	Overlay
      5  5d48				   TEMPORARY_OFFSET SET	0
      6  5d48				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5d48				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_1
      3  5d48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5d60		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$00,$00,$00,$10,$00	;PF1
      5  5d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5d90					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm"
      0  5d90					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_2", 72
     12  5d90					      LIST	ON
      0  5d90					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_2
      1  5d90				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5d90				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5d90				   BLACK_BISHOP_on_BLACK_SQUARE_2
      4  5d90				   TEMPORARY_VAR SET	Overlay
      5  5d90				   TEMPORARY_OFFSET SET	0
      6  5d90				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5d90				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_2
      3  5d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5da8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5dc0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$00,$00,$00,$01,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5dd8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm"
      0  5dd8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_3", 72
     12  5e00					      LIST	ON
      0  5e00					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_3
      1  5e00				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5e00				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5e00				   BLACK_BISHOP_on_BLACK_SQUARE_3
      4  5e00				   TEMPORARY_VAR SET	Overlay
      5  5e00				   TEMPORARY_OFFSET SET	0
      6  5e00				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5e00				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_3
      3  5e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5e18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5e30		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$00,$00,$00,$20,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5e48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm"
      0  5e48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_0", 72
     12  5e48					      LIST	ON
      0  5e48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_0
      1  5e48				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5e48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5e48				   BLACK_ROOK_on_BLACK_SQUARE_0
      4  5e48				   TEMPORARY_VAR SET	Overlay
      5  5e48				   TEMPORARY_OFFSET SET	0
      6  5e48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5e48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_0
      3  5e48		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$a0,$00,$00	;PF0
      4  5e60		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5e78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5e90					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm"
      0  5e90					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_1", 72
     12  5e90					      LIST	ON
      0  5e90					      DEF	BLACK_ROOK_on_BLACK_SQUARE_1
      1  5e90				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5e90				   BANK_BLACK_ROOK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5e90				   BLACK_ROOK_on_BLACK_SQUARE_1
      4  5e90				   TEMPORARY_VAR SET	Overlay
      5  5e90				   TEMPORARY_OFFSET SET	0
      6  5e90				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5e90				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_1
      3  5e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ea8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$28,$00,$00	;PF1
      5  5ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5ed8					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm"
      0  5ed8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_2", 72
     12  5f00					      LIST	ON
      0  5f00					      DEF	BLACK_ROOK_on_BLACK_SQUARE_2
      1  5f00				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5f00				   BANK_BLACK_ROOK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5f00				   BLACK_ROOK_on_BLACK_SQUARE_2
      4  5f00				   TEMPORARY_VAR SET	Overlay
      5  5f00				   TEMPORARY_OFFSET SET	0
      6  5f00				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5f00				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_2
      3  5f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5f18		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF1
      5  5f30		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$02,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5f48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm"
      0  5f48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_3", 72
     12  5f48					      LIST	ON
      0  5f48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_3
      1  5f48				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5f48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5f48				   BLACK_ROOK_on_BLACK_SQUARE_3
      4  5f48				   TEMPORARY_VAR SET	Overlay
      5  5f48				   TEMPORARY_OFFSET SET	0
      6  5f48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5f48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_3
      3  5f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5f78		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00	;PF2
------- FILE GFX2.asm
     18  5f90
     19  5f90
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5f90					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm"
      0  5f90					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_0", 72
     12  5f90					      LIST	ON
      0  5f90					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_0
      1  5f90				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5f90				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5f90				   BLACK_QUEEN_on_BLACK_SQUARE_0
      4  5f90				   TEMPORARY_VAR SET	Overlay
      5  5f90				   TEMPORARY_OFFSET SET	0
      6  5f90				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5f90				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_0
      3  5f90		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5fa8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5fc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
     21  5fd8
     22  5fd8
     23  5fd8							;---------------------------------------------------------------------------------------------------
     24  5fd8
      0  5fd8					      CHECK_BANK_SIZE	"BANK_GFX2"
      1  5fd8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX2 (1K) SIZE =  $3d8 , FREE= $28
      2  5fd8					      ECHO	"BANK_GFX2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5fd8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX2", " size=", * - ORIGIN
      5  5fd8				  -	      ERR
      6  5fd8					      ENDIF
     26  5fd8
     27  5fd8							;---------------------------------------------------------------------------------------------------
     28  5fd8							;EOF
------- FILE ./chess.asm
------- FILE GFX3.asm LEVEL 2 PASS 4
      0  5fd8					      include	"GFX3.asm"
      0  5fd8					      SLOT	2
      1  5fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  5fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  5fd8				  -	      ERR
      4  5fd8					      ENDIF
      5  5fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  5fd8				   _BANK_SLOT SET	2 * 64
      0  5fd8					      NEWBANK	GFX3
      1  63d8 ????				      SEG	GFX3
      2  6000					      ORG	_ORIGIN
      3  6000					      RORG	_BANK_ADDRESS_ORIGIN
      4  6000				   _BANK_START SET	*
      5  6000				   GFX3_START SET	*
      6  6000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6000				   GFX3       SET	_BANK_SLOT + _CURRENT_BANK
      8  6000				   _ORIGIN    SET	_ORIGIN + 1024
      3  6000
      4  6000							;---------------------------------------------------------------------------------------------------
      5  6000
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  6000					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm"
      0  6000					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_1", 72
     12  6000					      LIST	ON
      0  6000					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_1
      1  6000				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  6000				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  6000				   BLACK_QUEEN_on_BLACK_SQUARE_1
      4  6000				   TEMPORARY_VAR SET	Overlay
      5  6000				   TEMPORARY_OFFSET SET	0
      6  6000				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  6000				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_1
      3  6000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6018		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
      7  6048
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  6048					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm"
      0  6048					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_2", 72
     12  6048					      LIST	ON
      0  6048					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_2
      1  6048				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  6048				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  6048				   BLACK_QUEEN_on_BLACK_SQUARE_2
      4  6048				   TEMPORARY_VAR SET	Overlay
      5  6048				   TEMPORARY_OFFSET SET	0
      6  6048				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  6048				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_2
      3  6048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6060		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6078		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  6090					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm"
      0  6090					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_3", 72
     12  6090					      LIST	ON
      0  6090					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_3
      1  6090				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  6090				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  6090				   BLACK_QUEEN_on_BLACK_SQUARE_3
      4  6090				   TEMPORARY_VAR SET	Overlay
      5  6090				   TEMPORARY_OFFSET SET	0
      6  6090				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  6090				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_3
      3  6090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  60a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  60c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     10  60d8
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  60d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_0.asm"
      0  60d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_0", 72
     12  6100					      LIST	ON
      0  6100					      DEF	BLACK_KING_on_BLACK_SQUARE_0
      1  6100				   SLOT_BLACK_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  6100				   BANK_BLACK_KING_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  6100				   BLACK_KING_on_BLACK_SQUARE_0
      4  6100				   TEMPORARY_VAR SET	Overlay
      5  6100				   TEMPORARY_OFFSET SET	0
      6  6100				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  6100				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_0
      3  6100		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6118		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6130		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  6148					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_1.asm"
      0  6148					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_1", 72
     12  6148					      LIST	ON
      0  6148					      DEF	BLACK_KING_on_BLACK_SQUARE_1
      1  6148				   SLOT_BLACK_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  6148				   BANK_BLACK_KING_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  6148				   BLACK_KING_on_BLACK_SQUARE_1
      4  6148				   TEMPORARY_VAR SET	Overlay
      5  6148				   TEMPORARY_OFFSET SET	0
      6  6148				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  6148				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_1
      3  6148		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6160		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  6190					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_2.asm"
      0  6190					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_2", 72
     12  6190					      LIST	ON
      0  6190					      DEF	BLACK_KING_on_BLACK_SQUARE_2
      1  6190				   SLOT_BLACK_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  6190				   BANK_BLACK_KING_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  6190				   BLACK_KING_on_BLACK_SQUARE_2
      4  6190				   TEMPORARY_VAR SET	Overlay
      5  6190				   TEMPORARY_OFFSET SET	0
      6  6190				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  6190				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_2
      3  6190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  61a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  61c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  61d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_3.asm"
      0  61d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_3", 72
     12  6200					      LIST	ON
      0  6200					      DEF	BLACK_KING_on_BLACK_SQUARE_3
      1  6200				   SLOT_BLACK_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  6200				   BANK_BLACK_KING_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  6200				   BLACK_KING_on_BLACK_SQUARE_3
      4  6200				   TEMPORARY_VAR SET	Overlay
      5  6200				   TEMPORARY_OFFSET SET	0
      6  6200				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  6200				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_3
      3  6200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6218		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6230		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     15  6248
     16  6248
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  6248					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm"
      0  6248					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_3", 72
     12  6248					      LIST	ON
      0  6248					      DEF	WHITE_MARKER_on_WHITE_SQUARE_3
      1  6248				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  6248				   BANK_WHITE_MARKER_on_WHITE_SQUARE_3 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  6248				   WHITE_MARKER_on_WHITE_SQUARE_3
      4  6248				   TEMPORARY_VAR SET	Overlay
      5  6248				   TEMPORARY_OFFSET SET	0
      6  6248				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  6248				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_3
      3  6248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6278		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00	;PF2
------- FILE GFX3.asm
     18  6290
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  6290					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
      0  6290					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_0", 72
     12  6290					      LIST	ON
      0  6290					      DEF	BLACK_MARKER_on_BLACK_SQUARE_0
      1  6290				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  6290				   BANK_BLACK_MARKER_on_BLACK_SQUARE_0 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  6290				   BLACK_MARKER_on_BLACK_SQUARE_0
      4  6290				   TEMPORARY_VAR SET	Overlay
      5  6290				   TEMPORARY_OFFSET SET	0
      6  6290				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  6290				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_0
      3  6290		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  62a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  62c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  62d8					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
      0  62d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_1", 72
     12  6300					      LIST	ON
      0  6300					      DEF	BLACK_MARKER_on_BLACK_SQUARE_1
      1  6300				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  6300				   BANK_BLACK_MARKER_on_BLACK_SQUARE_1 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  6300				   BLACK_MARKER_on_BLACK_SQUARE_1
      4  6300				   TEMPORARY_VAR SET	Overlay
      5  6300				   TEMPORARY_OFFSET SET	0
      6  6300				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  6300				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_1
      3  6300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6318		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  6348					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
      0  6348					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_2", 72
     12  6348					      LIST	ON
      0  6348					      DEF	BLACK_MARKER_on_BLACK_SQUARE_2
      1  6348				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  6348				   BANK_BLACK_MARKER_on_BLACK_SQUARE_2 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  6348				   BLACK_MARKER_on_BLACK_SQUARE_2
      4  6348				   TEMPORARY_VAR SET	Overlay
      5  6348				   TEMPORARY_OFFSET SET	0
      6  6348				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  6348				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_2
      3  6348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6378		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  6390					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
      0  6390					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_3", 72
     12  6390					      LIST	ON
      0  6390					      DEF	BLACK_MARKER_on_BLACK_SQUARE_3
      1  6390				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  6390				   BANK_BLACK_MARKER_on_BLACK_SQUARE_3 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  6390				   BLACK_MARKER_on_BLACK_SQUARE_3
      4  6390				   TEMPORARY_VAR SET	Overlay
      5  6390				   TEMPORARY_OFFSET SET	0
      6  6390				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  6390				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_3
      3  6390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  63a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  63c0		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     23  63d8
     24  63d8							;---------------------------------------------------------------------------------------------------
     25  63d8
      0  63d8					      CHECK_BANK_SIZE	"BANK_GFX3"
      1  63d8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX3 (1K) SIZE =  $3d8 , FREE= $28
      2  63d8					      ECHO	"BANK_GFX3", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  63d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  63d8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX3", " size=", * - ORIGIN
      5  63d8				  -	      ERR
      6  63d8					      ENDIF
     27  63d8
     28  63d8							;---------------------------------------------------------------------------------------------------
     29  63d8							;EOF
------- FILE ./chess.asm
------- FILE GFX4.asm LEVEL 2 PASS 4
      0  63d8					      include	"GFX4.asm"
      0  63d8					      SLOT	2
      1  63d8				  -	      IF	(2 < 0) || (2 > 3)
      2  63d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  63d8				  -	      ERR
      4  63d8					      ENDIF
      5  63d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  63d8				   _BANK_SLOT SET	2 * 64
      0  63d8					      NEWBANK	GFX4
      1  67d8 ????				      SEG	GFX4
      2  6400					      ORG	_ORIGIN
      3  6400					      RORG	_BANK_ADDRESS_ORIGIN
      4  6400				   _BANK_START SET	*
      5  6400				   GFX4_START SET	*
      6  6400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6400				   GFX4       SET	_BANK_SLOT + _CURRENT_BANK
      8  6400				   _ORIGIN    SET	_ORIGIN + 1024
      3  6400
      4  6400							;---------------------------------------------------------------------------------------------------
      5  6400
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  6400					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
      0  6400					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_0", 72
     12  6400					      LIST	ON
      0  6400					      DEF	BLACK_MARKER_on_WHITE_SQUARE_0
      1  6400				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  6400				   BANK_BLACK_MARKER_on_WHITE_SQUARE_0 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  6400				   BLACK_MARKER_on_WHITE_SQUARE_0
      4  6400				   TEMPORARY_VAR SET	Overlay
      5  6400				   TEMPORARY_OFFSET SET	0
      6  6400				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  6400				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_0
      3  6400		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00	;PF0
      4  6418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  6448					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
      0  6448					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_1", 72
     12  6448					      LIST	ON
      0  6448					      DEF	BLACK_MARKER_on_WHITE_SQUARE_1
      1  6448				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  6448				   BANK_BLACK_MARKER_on_WHITE_SQUARE_1 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  6448				   BLACK_MARKER_on_WHITE_SQUARE_1
      4  6448				   TEMPORARY_VAR SET	Overlay
      5  6448				   TEMPORARY_OFFSET SET	0
      6  6448				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  6448				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_1
      3  6448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6460		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00	;PF1
      5  6478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  6490					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
      0  6490					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_2", 72
     12  6490					      LIST	ON
      0  6490					      DEF	BLACK_MARKER_on_WHITE_SQUARE_2
      1  6490				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  6490				   BANK_BLACK_MARKER_on_WHITE_SQUARE_2 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  6490				   BLACK_MARKER_on_WHITE_SQUARE_2
      4  6490				   TEMPORARY_VAR SET	Overlay
      5  6490				   TEMPORARY_OFFSET SET	0
      6  6490				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  6490				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_2
      3  6490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  64a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  64c0		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  64d8					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
      0  64d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_3", 72
     12  6500					      LIST	ON
      0  6500					      DEF	BLACK_MARKER_on_WHITE_SQUARE_3
      1  6500				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  6500				   BANK_BLACK_MARKER_on_WHITE_SQUARE_3 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  6500				   BLACK_MARKER_on_WHITE_SQUARE_3
      4  6500				   TEMPORARY_VAR SET	Overlay
      5  6500				   TEMPORARY_OFFSET SET	0
      6  6500				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  6500				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_3
      3  6500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6530		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00	;PF2
------- FILE GFX4.asm
     10  6548
     11  6548
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  6548					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  6548					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_0", 72
     12  6548					      LIST	ON
      0  6548					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_0
      1  6548				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  6548				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  6548				   WHITE_PROMOTE_on_BLACK_SQUARE_0
      4  6548				   TEMPORARY_VAR SET	Overlay
      5  6548				   TEMPORARY_OFFSET SET	0
      6  6548				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  6548				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_0
      3  6548		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  6560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  6590					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  6590					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_1", 72
     12  6590					      LIST	ON
      0  6590					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_1
      1  6590				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  6590				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  6590				   WHITE_PROMOTE_on_BLACK_SQUARE_1
      4  6590				   TEMPORARY_VAR SET	Overlay
      5  6590				   TEMPORARY_OFFSET SET	0
      6  6590				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  6590				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_1
      3  6590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  65a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  65c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  65d8					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  65d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_2", 72
     12  6600					      LIST	ON
      0  6600					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_2
      1  6600				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  6600				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  6600				   WHITE_PROMOTE_on_BLACK_SQUARE_2
      4  6600				   TEMPORARY_VAR SET	Overlay
      5  6600				   TEMPORARY_OFFSET SET	0
      6  6600				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  6600				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_2
      3  6600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  6630		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  6648					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  6648					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_3", 72
     12  6648					      LIST	ON
      0  6648					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_3
      1  6648				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  6648				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  6648				   WHITE_PROMOTE_on_BLACK_SQUARE_3
      4  6648				   TEMPORARY_VAR SET	Overlay
      5  6648				   TEMPORARY_OFFSET SET	0
      6  6648				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  6648				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_3
      3  6648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6678		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  6690					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  6690					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_0", 72
     12  6690					      LIST	ON
      0  6690					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_0
      1  6690				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  6690				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  6690				   WHITE_PROMOTE_on_WHITE_SQUARE_0
      4  6690				   TEMPORARY_VAR SET	Overlay
      5  6690				   TEMPORARY_OFFSET SET	0
      6  6690				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  6690				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_0
      3  6690		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  66a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  66c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  66d8					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  66d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_1", 72
     12  6700					      LIST	ON
      0  6700					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_1
      1  6700				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  6700				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  6700				   WHITE_PROMOTE_on_WHITE_SQUARE_1
      4  6700				   TEMPORARY_VAR SET	Overlay
      5  6700				   TEMPORARY_OFFSET SET	0
      6  6700				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  6700				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_1
      3  6700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6718		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  6748					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  6748					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_2", 72
     12  6748					      LIST	ON
      0  6748					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_2
      1  6748				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  6748				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  6748				   WHITE_PROMOTE_on_WHITE_SQUARE_2
      4  6748				   TEMPORARY_VAR SET	Overlay
      5  6748				   TEMPORARY_OFFSET SET	0
      6  6748				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  6748				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_2
      3  6748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6760		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6778		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  6790					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  6790					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_3", 72
     12  6790					      LIST	ON
      0  6790					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_3
      1  6790				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  6790				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  6790				   WHITE_PROMOTE_on_WHITE_SQUARE_3
      4  6790				   TEMPORARY_VAR SET	Overlay
      5  6790				   TEMPORARY_OFFSET SET	0
      6  6790				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  6790				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_3
      3  6790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  67a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  67c0		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
     20  67d8
     21  67d8
     22  67d8							;---------------------------------------------------------------------------------------------------
     23  67d8
      0  67d8					      CHECK_BANK_SIZE	"BANK_GFX4"
      1  67d8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX4 (1K) SIZE =  $3d8 , FREE= $28
      2  67d8					      ECHO	"BANK_GFX4", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  67d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  67d8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX4", " size=", * - ORIGIN
      5  67d8				  -	      ERR
      6  67d8					      ENDIF
     25  67d8
     26  67d8							;---------------------------------------------------------------------------------------------------
     27  67d8							;EOF
------- FILE ./chess.asm
------- FILE NEGAMAX.asm LEVEL 2 PASS 4
      0  67d8					      include	"NEGAMAX.asm"
      1  67d8							; Chess
      2  67d8							; Copyright (c) 2019-2020 Andrew Davie
      3  67d8							; andrew@taswegian.com
      4  67d8
      0  67d8					      SLOT	1	; this code assembles for bank #1
      1  67d8				  -	      IF	(1 < 0) || (1 > 3)
      2  67d8				  -	      ECHO	"Illegal bank address/segment location", 1
      3  67d8				  -	      ERR
      4  67d8					      ENDIF
      5  67d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  67d8				   _BANK_SLOT SET	1 * 64
      0  67d8					      NEWBANK	NEGAMAX
      1  693b ????				      SEG	NEGAMAX
      2  6800					      ORG	_ORIGIN
      3  6800					      RORG	_BANK_ADDRESS_ORIGIN
      4  6800				   _BANK_START SET	*
      5  6800				   NEGAMAX_START SET	*
      6  6800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6800				   NEGAMAX    SET	_BANK_SLOT + _CURRENT_BANK
      8  6800				   _ORIGIN    SET	_ORIGIN + 1024
      7  6800
      8  6800							;---------------------------------------------------------------------------------------------------
      9  6800
     10  6800							;function negaMax(node, depth, α, β, color) is
     11  6800							;    if depth = 0 or node is a terminal node then
     12  6800							;	  return color × the heuristic value of node
     13  6800
     14  6800							;    childNodes := generateMoves(node)
     15  6800							;    childNodes := orderMoves(childNodes)
     16  6800							;    value := −∞
     17  6800							;    foreach child in childNodes do
     18  6800							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
     19  6800							;	  α := max(α, value)
     20  6800							;	  if α ≥ β then
     21  6800							;	      break (* cut-off *)
     22  6800							;    return value
     23  6800							;(* Initial call for Player A's root node *)
     24  6800							;negaMax(rootNode, depth, −∞, +∞, 1)
     25  6800
     26  6800
     27  6800					      SUBROUTINE
     28  6800
     29  6800		       a9 ff	   .doQ       lda	#-1
     30  6802		       85 ad		      sta	__quiesceCapOnly
     31  6804		       20 49 f9 	      jsr	quiesce
     32  6807		       e6 ad		      inc	__quiesceCapOnly
     33  6809		       60		      rts
     34  680a
     35  680a
      0  680a				   .exit      lda@PLY	value
      1  680a		       ad a5 ff 	      lda	value
     37  680d		       85 a9		      sta	__negaMax
      0  680f					      lda@PLY	value+1
      1  680f		       ad a6 ff 	      lda	value+1
     39  6812		       85 aa		      sta	__negaMax+1
     40  6814		       60		      rts
     41  6815
     42  6815
     43  6815		       c9 00	   .terminal  cmp	#0	; captured piece
     44  6817		       d0 e7		      bne	.doQ	; last move was capture, so quiesce
     45  6819
     46  6819
     47  6819				  -	      IF	0
     48  6819				  -			; king moves will also quiesce
     49  6819				  -			; theory is - we need to see if it was an illegal move
     50  6819				  -
     51  6819				  -	      lda	fromPiece
     52  6819				  -	      and	#PIECE_MASK
     53  6819				  -	      cmp	#KING
     54  6819				  -	      beq	.doQ
     55  6819					      ENDIF
     56  6819
     57  6819		       a5 90		      lda	Evaluation
     58  681b		       85 a9		      sta	__negaMax
     59  681d		       a5 91		      lda	Evaluation+1
     60  681f		       85 aa		      sta	__negaMax+1
     61  6821
     62  6821		       60	   .inCheck2  rts
     63  6822
     64  6822
     65  6822
      0  6822					      DEF	negaMax
      1  6822				   SLOT_negaMax SET	_BANK_SLOT
      2  6822				   BANK_negaMax SET	SLOT_negaMax + _CURRENT_BANK
      3  6822				   negaMax
      4  6822				   TEMPORARY_VAR SET	Overlay
      5  6822				   TEMPORARY_OFFSET SET	0
      6  6822				   VAR_BOUNDARY_negaMax SET	TEMPORARY_OFFSET
      7  6822				   FUNCTION_NAME SET	negaMax
     67  6822
     68  6822							; PARAMS depth-1, -beta, -alpha
     69  6822							; pased through temporary variables (__alpha, __beta) and X reg
     70  6822
     71  6822							; pass...
     72  6822							; x = depthleft
     73  6822							; a = captured piece
     74  6822							; SET_BANK_RAM      --> current ply
     75  6822							; __alpha[2] = param alpha
     76  6822							; __beta[2] = param beta
     77  6822
     78  6822
      0  6822					      COMMON_VARS_ALPHABETA
      1  6822
      0  6822					      VAR	__thinkbar, 1
      1  6822		       00 a2	   __thinkbar =	TEMPORARY_VAR
      2  6822				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6822
      4  6822				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6822				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6822				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6822					      ENDIF
      8  6822				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6822				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  6822				  -	      ERR
     11  6822					      ENDIF
     12  6822					      LIST	ON
      0  6822					      VAR	__toggle, 1
      1  6822		       00 a3	   __toggle   =	TEMPORARY_VAR
      2  6822				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6822
      4  6822				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6822				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6822				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6822					      ENDIF
      8  6822				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6822				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  6822				  -	      ERR
     11  6822					      ENDIF
     12  6822					      LIST	ON
      4  6822
      0  6822					      VAR	__bestMove, 1
      1  6822		       00 a4	   __bestMove =	TEMPORARY_VAR
      2  6822				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6822
      4  6822				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6822				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6822				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6822					      ENDIF
      8  6822				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6822				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  6822				  -	      ERR
     11  6822					      ENDIF
     12  6822					      LIST	ON
      0  6822					      VAR	__alpha, 2
      1  6822		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  6822				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6822
      4  6822				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6822				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6822				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6822					      ENDIF
      8  6822				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6822				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  6822				  -	      ERR
     11  6822					      ENDIF
     12  6822					      LIST	ON
      0  6822					      VAR	__beta, 2
      1  6822		       00 a7	   __beta     =	TEMPORARY_VAR
      2  6822				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6822
      4  6822				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6822				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6822				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6822					      ENDIF
      8  6822				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6822				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  6822				  -	      ERR
     11  6822					      ENDIF
     12  6822					      LIST	ON
      0  6822					      VAR	__negaMax, 2
      1  6822		       00 a9	   __negaMax  =	TEMPORARY_VAR
      2  6822				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6822
      4  6822				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6822				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6822				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6822					      ENDIF
      8  6822				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6822				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  6822				  -	      ERR
     11  6822					      ENDIF
     12  6822					      LIST	ON
      0  6822					      VAR	__value, 2
      1  6822		       00 ab	   __value    =	TEMPORARY_VAR
      2  6822				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6822
      4  6822				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6822				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6822				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6822					      ENDIF
      8  6822				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6822				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  6822				  -	      ERR
     11  6822					      ENDIF
     12  6822					      LIST	ON
     10  6822
      0  6822					      VAR	__quiesceCapOnly, 1
      1  6822		       00 ad	   __quiesceCapOnly =	TEMPORARY_VAR
      2  6822				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6822
      4  6822				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6822				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6822				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6822					      ENDIF
      8  6822				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6822				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  6822				  -	      ERR
     11  6822					      ENDIF
     12  6822					      LIST	ON
     12  6822
      0  6822					      REFER	selectmove
      1  6822				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  6822				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  6822					      ENDIF
      0  6822					      VEND	negaMax
      1  6822				  -	      IFNCONST	negaMax
      2  6822				  -	      ECHO	"Incorrect VEND label", negaMax
      3  6822				  -	      ERR
      4  6822					      ENDIF
      5  6822		       00 ae	   VAREND_negaMax =	TEMPORARY_VAR
     82  6822
     83  6822		       48		      pha
     84  6823
      0  6823					      CALL	ThinkBar
      1  6823				  -	      IF	SLOT_ThinkBar == _BANK_SLOT
      2  6823				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  6823				  -	      ECHO	"Cannot switch bank in use for", ThinkBar
      4  6823				  -	      ERR
      5  6823					      ENDIF
      6  6823		       a9 00		      lda	#BANK_ThinkBar
      7  6825		       85 3f		      sta	SET_BANK
      8  6827		       20 73 f0 	      jsr	ThinkBar
     86  682a		       a5 95		      lda	currentPly
     87  682c		       85 3e		      sta	SET_BANK_RAM
     88  682e
     89  682e		       68		      pla
     90  682f		       ca		      dex
     91  6830		       30 e3		      bmi	.terminal
      0  6832					      stx@PLY	depthLeft
      1  6832		       8e a7 01 	      stx	[RAM]+depthLeft
     93  6835
     94  6835
     95  6835							; Allow the player to force computer to select a move. Press the SELECT switch
     96  6835							; This may have issues if no move has been selected yet. Still... if you wanna cheat....
     97  6835
     98  6835		       ad 82 02 	      lda	SWCHB
     99  6838		       29 02		      and	#2
    100  683a		       f0 ce		      beq	.exit	; SELECT abort
    101  683c		       85 48		      sta	COLUPF	; grey thinkbars
    102  683e
    103  683e		       a5 a5		      lda	__alpha
      0  6840					      sta@PLY	alpha
      1  6840		       8d a1 01 	      sta	[RAM]+alpha
    105  6843		       a5 a6		      lda	__alpha+1
      0  6845					      sta@PLY	alpha+1
      1  6845		       8d a2 01 	      sta	[RAM]+alpha+1
    107  6848
    108  6848		       a5 a7		      lda	__beta
      0  684a					      sta@PLY	beta
      1  684a		       8d a3 01 	      sta	[RAM]+beta
    110  684d		       a5 a8		      lda	__beta+1
      0  684f					      sta@PLY	beta+1
      1  684f		       8d a4 01 	      sta	[RAM]+beta+1
    112  6852
    113  6852
    114  6852					      IF	1
    115  6852		       a5 90		      lda	Evaluation
    116  6854		       65 a1		      adc	randomness
    117  6856		       85 90		      sta	Evaluation
    118  6858		       90 02		      bcc	.evh
    119  685a		       e6 91		      inc	Evaluation+1
    120  685c				   .evh
    121  685c					      ENDIF
    122  685c
    123  685c		       20 68 f1 	      jsr	GenerateAllMoves
    124  685f		       a5 9f		      lda	flagCheck
    125  6861		       d0 be		      bne	.inCheck2	; OTHER guy in check
    126  6863
    127  6863					      IF	1
      0  6863					      lda@PLY	moveIndex
      1  6863		       ad 9e ff 	      lda	moveIndex
    129  6866		       30 0f		      bmi	.none
    130  6868		       4a		      lsr
    131  6869		       4a		      lsr
    132  686a		       4a		      lsr
    133  686b		       4a		      lsr
    134  686c		       4a		      lsr
    135  686d		       65 90		      adc	Evaluation
    136  686f		       85 90		      sta	Evaluation
    137  6871		       a5 91		      lda	Evaluation+1
    138  6873		       69 00		      adc	#0
    139  6875		       85 91		      sta	Evaluation+1
    140  6877				   .none
    141  6877					      ENDIF
    142  6877
    143  6877
    144  6877		       a9 00		      lda	#<-INFINITY
      0  6879					      sta@PLY	value
      1  6879		       8d a5 01 	      sta	[RAM]+value
    146  687c		       a9 90		      lda	#>-INFINITY
      0  687e					      sta@PLY	value+1
      1  687e		       8d a6 01 	      sta	[RAM]+value+1
    148  6881
      0  6881					      ldx@PLY	moveIndex
      1  6881		       ae 9e ff 	      ldx	moveIndex
    150  6884		       10 03		      bpl	.forChild
    151  6886		       4c 0a f4 	      jmp	.exit
    152  6889
      0  6889				   .forChild  stx@PLY	movePtr
      1  6889		       8e 9f 01 	      stx	[RAM]+movePtr
    154  688c
    155  688c		       20 00 f4 	      jsr	MakeMove
    156  688f
    157  688f
    158  688f
    159  688f							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    160  688f
    161  688f							; PARAMS depth-1, -beta, -alpha
    162  688f							; pased through temporary variables (__alpha, __beta) and X reg
    163  688f
    164  688f		       38		      sec
    165  6890		       a9 00		      lda	#0
      0  6892					      sbc@PLY	beta
      1  6892		       ed a3 ff 	      sbc	beta
    167  6895		       85 a5		      sta	__alpha
    168  6897		       a9 00		      lda	#0
      0  6899					      sbc@PLY	beta+1
      1  6899		       ed a4 ff 	      sbc	beta+1
    170  689c		       85 a6		      sta	__alpha+1
    171  689e
    172  689e		       38		      sec
    173  689f		       a9 00		      lda	#0
      0  68a1					      sbc@PLY	alpha
      1  68a1		       ed a1 ff 	      sbc	alpha
    175  68a4		       85 a7		      sta	__beta
    176  68a6		       a9 00		      lda	#0
      0  68a8					      sbc@PLY	alpha+1
      1  68a8		       ed a2 ff 	      sbc	alpha+1
    178  68ab		       85 a8		      sta	__beta+1
    179  68ad
    180  68ad
      0  68ad					      ldx@PLY	depthLeft
      1  68ad		       ae a7 ff 	      ldx	depthLeft
      0  68b0					      lda@PLY	capturedPiece
      1  68b0		       ad 99 ff 	      lda	capturedPiece
    183  68b3
    184  68b3		       e6 95		      inc	currentPly
    185  68b5		       a4 95		      ldy	currentPly
    186  68b7		       84 3e		      sty	SET_BANK_RAM	; self-switch
    187  68b9
    188  68b9		       20 22 f4 	      jsr	negaMax
    189  68bc
    190  68bc		       c6 95		      dec	currentPly
    191  68be		       a5 95		      lda	currentPly
    192  68c0		       85 3e		      sta	SET_BANK_RAM
    193  68c2
    194  68c2		       20 6f f4 	      jsr	unmakeMove
    195  68c5
    196  68c5		       38		      sec
    197  68c6		       a9 00		      lda	#0
    198  68c8		       e5 a9		      sbc	__negaMax
    199  68ca		       85 a9		      sta	__negaMax
    200  68cc		       a9 00		      lda	#0
    201  68ce		       e5 aa		      sbc	__negaMax+1
    202  68d0		       85 aa		      sta	__negaMax+1	; -negaMax(...)
    203  68d2
    204  68d2		       a5 9f		      lda	flagCheck
    205  68d4		       f0 06		      beq	.notCheck
    206  68d6
    207  68d6							; at this point we've determined that the move was illegal, because the next ply detected
    208  68d6							; a king capture. So, the move should be totally discounted
    209  68d6
    210  68d6		       a9 00		      lda	#0
    211  68d8		       85 9f		      sta	flagCheck	; so we don't retrigger in future - it's been handled!
    212  68da		       f0 53		      beq	.nextMove	; unconditional - move is not considered!
    213  68dc
    214  68dc		       38	   .notCheck  sec
      0  68dd					      lda@PLY	value
      1  68dd		       ad a5 ff 	      lda	value
    216  68e0		       e5 a9		      sbc	__negaMax
      0  68e2					      lda@PLY	value+1
      1  68e2		       ad a6 ff 	      lda	value+1
    218  68e5		       e5 aa		      sbc	__negaMax+1
    219  68e7		       50 02		      bvc	.lab0
    220  68e9		       49 80		      eor	#$80
    221  68eb		       10 10	   .lab0      bpl	.lt0	; branch if value >= negaMax
    222  68ed
    223  68ed							; so, negaMax > value!
    224  68ed
    225  68ed		       a5 a9		      lda	__negaMax
      0  68ef					      sta@PLY	value
      1  68ef		       8d a5 01 	      sta	[RAM]+value
    227  68f2		       a5 aa		      lda	__negaMax+1
      0  68f4					      sta@PLY	value+1	; max(value, -negaMax)
      1  68f4		       8d a6 01 	      sta	[RAM]+value+1
    229  68f7
      0  68f7					      lda@PLY	movePtr
      1  68f7		       ad 9f ff 	      lda	movePtr
      0  68fa					      sta@PLY	bestMove
      1  68fa		       8d a0 01 	      sta	[RAM]+bestMove
    232  68fd				   .lt0
    233  68fd
    234  68fd							;	  α := max(α, value)
    235  68fd
    236  68fd		       38		      sec
      0  68fe					      lda@PLY	value
      1  68fe		       ad a5 ff 	      lda	value
      0  6901					      sbc@PLY	alpha
      1  6901		       ed a1 ff 	      sbc	alpha
      0  6904					      lda@PLY	value+1
      1  6904		       ad a6 ff 	      lda	value+1
      0  6907					      sbc@PLY	alpha+1
      1  6907		       ed a2 ff 	      sbc	alpha+1
    241  690a		       50 02		      bvc	.lab1
    242  690c		       49 80		      eor	#$80
    243  690e		       30 0c	   .lab1      bmi	.lt1	; value < alpha
    244  6910
      0  6910					      lda@PLY	value
      1  6910		       ad a5 ff 	      lda	value
      0  6913					      sta@PLY	alpha
      1  6913		       8d a1 01 	      sta	[RAM]+alpha
      0  6916					      lda@PLY	value+1
      1  6916		       ad a6 ff 	      lda	value+1
      0  6919					      sta@PLY	alpha+1	; alpha = max(alpha, value)
      1  6919		       8d a2 01 	      sta	[RAM]+alpha+1
    249  691c
    250  691c				   .lt1
    251  691c
    252  691c							;	  if α ≥ β then
    253  691c							;	      break (* cut-off *)
    254  691c
    255  691c		       38		      sec
      0  691d					      lda@PLY	alpha
      1  691d		       ad a1 ff 	      lda	alpha
      0  6920					      sbc@PLY	beta
      1  6920		       ed a3 ff 	      sbc	beta
      0  6923					      lda@PLY	alpha+1
      1  6923		       ad a2 ff 	      lda	alpha+1
      0  6926					      sbc@PLY	beta+1
      1  6926		       ed a4 ff 	      sbc	beta+1
    260  6929		       50 02		      bvc	.lab2
    261  692b		       49 80		      eor	#$80
    262  692d		       10 09	   .lab2      bpl	.retrn	; alpha >= beta
    263  692f
    264  692f
      0  692f				   .nextMove  ldx@PLY	movePtr
      1  692f		       ae 9f ff 	      ldx	movePtr
    266  6932		       ca	   .nextX     dex
    267  6933		       30 03		      bmi	.retrn
    268  6935		       4c 89 f4 	      jmp	.forChild
    269  6938
    270  6938		       4c 0a f4    .retrn     jmp	.exit
    271  693b
    272  693b
    273  693b							;---------------------------------------------------------------------------------------------------
    274  693b
      0  693b					      CHECK_BANK_SIZE	"NEGAMAX"
      1  693b		       01 3b	   .TEMP      =	* - _BANK_START
 NEGAMAX (1K) SIZE =  $13b , FREE= $2c5
      2  693b					      ECHO	"NEGAMAX", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  693b				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  693b				  -	      ECHO	"BANK OVERFLOW @ ", "NEGAMAX", " size=", * - ORIGIN
      5  693b				  -	      ERR
      6  693b					      ENDIF
    276  693b
    277  693b							;---------------------------------------------------------------------------------------------------
    278  693b							; EOF
------- FILE ./chess.asm
    628  693b
------- FILE PIECE_MACROS.asm LEVEL 2 PASS 4
      0  693b					      include	"PIECE_MACROS.asm"
      1  693b							; Copyright (C)2020 Andrew Davie
      2  693b							; Common macros for piece move handlers
      3  693b
      4  693b							;---------------------------------------------------------------------------------------------------
      5  693b							; Looks at a square offset {1} to see if piece can move to it
      6  693b							; Adds the square to the movelist if it can
      7  693b							; Keeps moving in the same direction until it's blocked/off=board
      8  693b
      9  693b					      MAC	move_towards
     10  693b					      SUBROUTINE
     11  693b
     12  693b							; = 76 for single square (empty/take)
     13  693b
     14  693b					      lda	#0
     15  693b					      sta	capture
     16  693b
     17  693b					      ldx	currentSquare	; 3
     18  693b					      bne	.project	; 3   unconditional
     19  693b
     20  693b				   .empty     jsr	AddMoveSlider	; 57
     21  693b				   .project   ldy	ValidSquare+{1},x	; 4
     22  693b					      bmi	.invalid	; 2/3 off board!
     23  693b					      lda	Board,y	; 4   piece @ destination
     24  693b					      beq	.empty	; 2/3
     25  693b					      sta	capture
     26  693b					      eor	currentPiece	; 3
     27  693b					      bpl	.invalid	; 2/3 same colour
     28  693b					      jsr	AddMove	; 57  and exit
     29  693b
     30  693b				   .invalid
     31  693b					      ENDM
     32  693b
     33  693b
     34  693b							;---------------------------------------------------------------------------------------------------
     35  693b
     36  693b					      MAC	move_to
     37  693b					      SUBROUTINE
     38  693b					      ldy	ValidSquare+{1},x
     39  693b					      bmi	.invalid	; off board!
     40  693b					      lda	Board,y	; piece @ destination
     41  693b					      sta	capture
     42  693b					      beq	.squareEmpty
     43  693b					      eor	currentPiece
     44  693b					      bpl	.invalid	; same colour
     45  693b				   .squareEmpty jsr	AddMove
     46  693b				   .invalid
     47  693b					      ENDM
     48  693b
     49  693b
     50  693b							;---------------------------------------------------------------------------------------------------
     51  693b
     52  693b					      MAC	move_to_x
     53  693b					      ldx	currentSquare
     54  693b					      MOVE_TO	{1}
     55  693b					      ENDM
     56  693b
     57  693b
     58  693b							;---------------------------------------------------------------------------------------------------
     59  693b							; EOF
------- FILE ./chess.asm
------- FILE GENMOVE.asm LEVEL 2 PASS 4
      0  693b					      include	"GENMOVE.asm"
      1  693b							; Chess
      2  693b							; Copyright (c) 2019-2020 Andrew Davie
      3  693b							; andrew@taswegian.com
      4  693b
      0  693b					      SLOT	1	; this code assembles for bank #1
      1  693b				  -	      IF	(1 < 0) || (1 > 3)
      2  693b				  -	      ECHO	"Illegal bank address/segment location", 1
      3  693b				  -	      ERR
      4  693b					      ENDIF
      5  693b				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  693b				   _BANK_SLOT SET	1 * 64
      0  693b					      NEWBANK	GENMOVE
      1  6c30 ????				      SEG	GENMOVE
      2  6c00					      ORG	_ORIGIN
      3  6c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  6c00				   _BANK_START SET	*
      5  6c00				   GENMOVE_START SET	*
      6  6c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6c00				   GENMOVE    SET	_BANK_SLOT + _CURRENT_BANK
      8  6c00				   _ORIGIN    SET	_ORIGIN + 1024
      7  6c00
      8  6c00					      MAC	handlevec
      9  6c00					      .byte	{1}MoveReturn
     10  6c00					      .byte	{1}MoveReturn	;byte {1}Handle_WHITE_PAWN	   ; 1
     11  6c00					      .byte	{1}MoveReturn	;.byte {1}Handle_BLACK_PAWN	    ; 2
     12  6c00					      .byte	{1}Handle_KNIGHT	; 3
     13  6c00					      .byte	{1}Handle_BISHOP	; 4
     14  6c00					      .byte	{1}Handle_ROOK	; 5
     15  6c00					      .byte	{1}Handle_QUEEN	; 6
     16  6c00					      .byte	{1}Handle_KING	; 7
     17  6c00
     18  6c00					      .byte	{1}MoveReturn
     19  6c00					      .byte	{1}Handle_WHITE_PAWN	; 1
     20  6c00					      .byte	{1}Handle_BLACK_PAWN	; 2
     21  6c00					      .byte	{1}MoveReturn	;.byte {1}Handle_KNIGHT	    ; 3
     22  6c00					      .byte	{1}MoveReturn	;.byte {1}Handle_BISHOP	    ; 4
     23  6c00					      .byte	{1}MoveReturn	;.byte {1}Handle_ROOK		    ; 5
     24  6c00					      .byte	{1}MoveReturn	;.byte {1}Handle_QUEEN 	    ; 6
     25  6c00					      .byte	{1}MoveReturn	;.byte {1}Handle_KING		    ; 7
     26  6c00					      ENDM
     27  6c00
     28  6c00
     29  6c00							;    .byte 0	  ; dummy to prevent page cross access on index 0
     30  6c00
      0  6c00				   HandlerVectorLO HANDLEVEC	<
      1  6c00		       8c		      .byte.b	<MoveReturn
      2  6c01		       8c		      .byte.b	<MoveReturn
      3  6c02		       8c		      .byte.b	<MoveReturn
      4  6c03		       a8		      .byte.b	<Handle_KNIGHT
      5  6c04		       51		      .byte.b	<Handle_BISHOP
      6  6c05		       00		      .byte.b	<Handle_ROOK
      7  6c06		       7b		      .byte.b	<Handle_QUEEN
      8  6c07		       6e		      .byte.b	<Handle_KING
      9  6c08
     10  6c08		       8c		      .byte.b	<MoveReturn
     11  6c09		       29		      .byte.b	<Handle_WHITE_PAWN
     12  6c0a		       fd		      .byte.b	<Handle_BLACK_PAWN
     13  6c0b		       8c		      .byte.b	<MoveReturn
     14  6c0c		       8c		      .byte.b	<MoveReturn
     15  6c0d		       8c		      .byte.b	<MoveReturn
     16  6c0e		       8c		      .byte.b	<MoveReturn
     17  6c0f		       8c		      .byte.b	<MoveReturn
      0  6c10				   HandlerVectorHI HANDLEVEC	>
      1  6c10		       f1		      .byte.b	>MoveReturn
      2  6c11		       f1		      .byte.b	>MoveReturn
      3  6c12		       f1		      .byte.b	>MoveReturn
      4  6c13		       f5		      .byte.b	>Handle_KNIGHT
      5  6c14		       f6		      .byte.b	>Handle_BISHOP
      6  6c15		       f4		      .byte.b	>Handle_ROOK
      7  6c16		       f4		      .byte.b	>Handle_QUEEN
      8  6c17		       f5		      .byte.b	>Handle_KING
      9  6c18
     10  6c18		       f1		      .byte.b	>MoveReturn
     11  6c19		       f4		      .byte.b	>Handle_WHITE_PAWN
     12  6c1a		       f4		      .byte.b	>Handle_BLACK_PAWN
     13  6c1b		       f1		      .byte.b	>MoveReturn
     14  6c1c		       f1		      .byte.b	>MoveReturn
     15  6c1d		       f1		      .byte.b	>MoveReturn
     16  6c1e		       f1		      .byte.b	>MoveReturn
     17  6c1f		       f1		      .byte.b	>MoveReturn
      0  6c20				   HandlerVectorBANK HANDLEVEC	BANK_
      1  6c20		       00		      .byte.b	BANK_MoveReturn
      2  6c21		       00		      .byte.b	BANK_MoveReturn
      3  6c22		       00		      .byte.b	BANK_MoveReturn
      4  6c23		       5e		      .byte.b	BANK_Handle_KNIGHT
      5  6c24		       5e		      .byte.b	BANK_Handle_BISHOP
      6  6c25		       5f		      .byte.b	BANK_Handle_ROOK
      7  6c26		       5f		      .byte.b	BANK_Handle_QUEEN
      8  6c27		       5f		      .byte.b	BANK_Handle_KING
      9  6c28
     10  6c28		       00		      .byte.b	BANK_MoveReturn
     11  6c29		       5e		      .byte.b	BANK_Handle_WHITE_PAWN
     12  6c2a		       5e		      .byte.b	BANK_Handle_BLACK_PAWN
     13  6c2b		       00		      .byte.b	BANK_MoveReturn
     14  6c2c		       00		      .byte.b	BANK_MoveReturn
     15  6c2d		       00		      .byte.b	BANK_MoveReturn
     16  6c2e		       00		      .byte.b	BANK_MoveReturn
     17  6c2f		       00		      .byte.b	BANK_MoveReturn
     34  6c30
     35  6c30
     36  6c30
     37  6c30							;---------------------------------------------------------------------------------------------------
     38  6c30
      0  6c30					      CHECK_BANK_SIZE	"GENMOVE"
      1  6c30		       00 30	   .TEMP      =	* - _BANK_START
 GENMOVE (1K) SIZE =  $30 , FREE= $3d0
      2  6c30					      ECHO	"GENMOVE", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  6c30				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6c30				  -	      ECHO	"BANK OVERFLOW @ ", "GENMOVE", " size=", * - ORIGIN
      5  6c30				  -	      ERR
      6  6c30					      ENDIF
     40  6c30
     41  6c30							;---------------------------------------------------------------------------------------------------
     42  6c30							; EOF
------- FILE ./chess.asm
------- FILE GENMOVE2.asm LEVEL 2 PASS 4
      0  6c30					      include	"GENMOVE2.asm"
      1  6c30							; Chess
      2  6c30							; Copyright (c) 2019-2020 Andrew Davie
      3  6c30							; andrew@taswegian.com
      4  6c30
      0  6c30					      SLOT	1	; this code assembles for bank #1
      1  6c30				  -	      IF	(1 < 0) || (1 > 3)
      2  6c30				  -	      ECHO	"Illegal bank address/segment location", 1
      3  6c30				  -	      ERR
      4  6c30					      ENDIF
      5  6c30				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  6c30				   _BANK_SLOT SET	1 * 64
      0  6c30					      NEWBANK	GENMOVE2
      1  7000 ????				      SEG	GENMOVE2
      2  7000					      ORG	_ORIGIN
      3  7000					      RORG	_BANK_ADDRESS_ORIGIN
      4  7000				   _BANK_START SET	*
      5  7000				   GENMOVE2_START SET	*
      6  7000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7000				   GENMOVE2   SET	_BANK_SLOT + _CURRENT_BANK
      8  7000				   _ORIGIN    SET	_ORIGIN + 1024
      7  7000
      8  7000							;---------------------------------------------------------------------------------------------------
      9  7000
      0  7000					      CHECK_BANK_SIZE	"GENMOVE2"
      1  7000		       00 00	   .TEMP      =	* - _BANK_START
 GENMOVE2 (1K) SIZE =  $0 , FREE= $400
      2  7000					      ECHO	"GENMOVE2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  7000				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  7000				  -	      ECHO	"BANK OVERFLOW @ ", "GENMOVE2", " size=", * - ORIGIN
      5  7000				  -	      ERR
      6  7000					      ENDIF
     11  7000
     12  7000							;---------------------------------------------------------------------------------------------------
     13  7000							; EOF
------- FILE ./chess.asm
    632  7000
------- FILE BANK_GENERIC@1#2.asm LEVEL 2 PASS 4
      0  7000					      include	"BANK_GENERIC@1#2.asm"
      1  7000							; Chess
      2  7000							; Copyright (c) 2019-2020 Andrew Davie
      3  7000							; andrew@taswegian.com
      4  7000
      0  7000					      SLOT	1
      1  7000				  -	      IF	(1 < 0) || (1 > 3)
      2  7000				  -	      ECHO	"Illegal bank address/segment location", 1
      3  7000				  -	      ERR
      4  7000					      ENDIF
      5  7000				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  7000				   _BANK_SLOT SET	1 * 64
      0  7000					      NEWBANK	TWO
      1  764b ????				      SEG	TWO
      2  7400					      ORG	_ORIGIN
      3  7400					      RORG	_BANK_ADDRESS_ORIGIN
      4  7400				   _BANK_START SET	*
      5  7400				   TWO_START  SET	*
      6  7400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7400				   TWO	      SET	_BANK_SLOT + _CURRENT_BANK
      8  7400				   _ORIGIN    SET	_ORIGIN + 1024
      7  7400
      8  7400
      9  7400							;---------------------------------------------------------------------------------------------------
     10  7400
     11  7400				  -	      IF	0
     12  7400				  -	      DEF	SAFE_BackupBitmaps
     13  7400				  -	      SUBROUTINE
     14  7400				  -
     15  7400				  -	      VEND	SAFE_BackupBitmaps
     16  7400				  -
     17  7400				  -	      sty	SET_BANK_RAM
     18  7400				  -	      jsr	SaveBitmap
     19  7400				  -	      lda	savedBank
     20  7400				  -	      sta	SET_BANK
     21  7400				  -	      rts
     22  7400					      ENDIF
     23  7400
     24  7400							;---------------------------------------------------------------------------------------------------
     25  7400
      0  7400					      DEF	MakeMove
      1  7400				   SLOT_MakeMove SET	_BANK_SLOT
      2  7400				   BANK_MakeMove SET	SLOT_MakeMove + _CURRENT_BANK
      3  7400				   MakeMove
      4  7400				   TEMPORARY_VAR SET	Overlay
      5  7400				   TEMPORARY_OFFSET SET	0
      6  7400				   VAR_BOUNDARY_MakeMove SET	TEMPORARY_OFFSET
      7  7400				   FUNCTION_NAME SET	MakeMove
     27  7400					      SUBROUTINE
     28  7400
      0  7400					      REFER	negaMax
      1  7400					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  7400				   TEMPORARY_VAR SET	VAREND_negaMax
      3  7400					      ENDIF
      0  7400					      VAR	__capture, 1
      1  7400		       00 ae	   __capture  =	TEMPORARY_VAR
      2  7400				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7400
      4  7400				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7400				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7400				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7400					      ENDIF
      8  7400				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7400				  -	      ECHO	"Temporary Variable", __capture, "overflow!"
     10  7400				  -	      ERR
     11  7400					      ENDIF
     12  7400					      LIST	ON
      0  7400					      VAR	__restore, 1
      1  7400		       00 af	   __restore  =	TEMPORARY_VAR
      2  7400				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7400
      4  7400				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7400				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7400				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7400					      ENDIF
      8  7400				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7400				  -	      ECHO	"Temporary Variable", __restore, "overflow!"
     10  7400				  -	      ERR
     11  7400					      ENDIF
     12  7400					      LIST	ON
      0  7400					      VEND	MakeMove
      1  7400				  -	      IFNCONST	MakeMove
      2  7400				  -	      ECHO	"Incorrect VEND label", MakeMove
      3  7400				  -	      ERR
      4  7400					      ENDIF
      5  7400		       00 b0	   VAREND_MakeMove =	TEMPORARY_VAR
     33  7400
     34  7400							; Do a move without any GUI stuff
     35  7400							; This function is ALWAYS paired with "unmakeMove" - a call to both will leave board
     36  7400							; and all relevant flags in original state. This is NOT used for the visible move on the
     37  7400							; screen.
     38  7400
     39  7400
     40  7400							; fromPiece	 piece doing the move
     41  7400							; fromX12	 current square X12
     42  7400							; originX12	 starting square X12
     43  7400							; toX12	 ending square X12
     44  7400
     45  7400
     46  7400							; There are potentially "two" moves, with the following
     47  7400							; a) Castling, moving both rook and king
     48  7400							; b) en-Passant, capturing pawn on "odd" square
     49  7400							; These both set "secondary" movers which are used for restoring during unmakeMove
     50  7400
     51  7400		       a9 00		      lda	#0
      0  7402					      sta@PLY	secondaryPiece
      1  7402		       8d 9b 01 	      sta	[RAM]+secondaryPiece
     53  7405
      0  7405					      ldx@PLY	movePtr
      1  7405		       ae 9f ff 	      ldx	movePtr
      0  7408					      lda@PLY	MoveFrom,x
      1  7408		       bd 00 fc 	      lda	MoveFrom,x
     56  740b		       85 85		      sta	fromX12
     57  740d		       85 87		      sta	originX12
      0  740f					      lda@PLY	MoveTo,x
      1  740f		       bd 00 fd 	      lda	MoveTo,x
     59  7412		       85 86		      sta	toX12
      0  7414					      lda@PLY	MovePiece,x
      1  7414		       bd 00 fe 	      lda	MovePiece,x
     61  7417		       85 97		      sta	fromPiece
     62  7419
     63  7419		       20 64 f5    .move      jsr	AdjustMaterialPositionalValue
     64  741c
     65  741c							; Modify the board
     66  741c
     67  741c		       a0 cf		      ldy	#RAMBANK_BOARD
     68  741e		       84 3e		      sty	SET_BANK_RAM
     69  7420		       a4 87		      ldy	originX12
      0  7422					      lda@RAM	Board,y
      1  7422		       b9 79 fc 	      lda	Board,y
     71  7425		       85 af		      sta	__restore
     72  7427		       a9 00		      lda	#0
      0  7429					      sta@RAM	Board,y
      1  7429		       99 79 fe 	      sta	[RAM]+Board,y
     74  742c		       a4 86		      ldy	toX12
      0  742e					      lda@RAM	Board,y
      1  742e		       b9 79 fc 	      lda	Board,y
     76  7431		       85 ae		      sta	__capture
     77  7433		       a5 97		      lda	fromPiece
     78  7435		       29 8f		      and	#PIECE_MASK|FLAG_COLOUR
     79  7437		       09 40		      ora	#FLAG_MOVED
      0  7439					      sta@RAM	Board,y
      1  7439		       99 79 fe 	      sta	[RAM]+Board,y
     81  743c
     82  743c		       a5 95		      lda	currentPly
     83  743e		       85 3e		      sta	SET_BANK_RAM
     84  7440		       a5 ae		      lda	__capture
      0  7442					      sta@PLY	capturedPiece
      1  7442		       8d 99 01 	      sta	[RAM]+capturedPiece
     86  7445		       a5 af		      lda	__restore
      0  7447					      sta@PLY	restorePiece
      1  7447		       8d a8 01 	      sta	[RAM]+restorePiece
     88  744a
     89  744a					      IF	CASTLING_ENABLED
     90  744a
     91  744a							; If the FROM piece has the castle bit set (i.e., it's a king that's just moved 2 squares)
     92  744a							; then we find the appropriate ROOK, set the secondary piece "undo" information, and then
     93  744a							; redo the moving code (for the rook, this time).
     94  744a
     95  744a		       20 8e f8 	      jsr	GenCastleMoveForRook
     96  744d		       b0 ca		      bcs	.move	; move the rook!
     97  744f					      ENDIF
     98  744f
     99  744f
    100  744f					      IF	ENPASSANT_ENABLED
    101  744f		       20 20 f6 	      jsr	EnPassantCheck
    102  7452		       f0 03		      beq	.notEnPassant
    103  7454		       20 f5 f5 	      jsr	EnPassantRemovePiece	; y = origin X12
    104  7457				   .notEnPassant
    105  7457					      ENDIF
    106  7457
    107  7457							; Swap over sides
    108  7457
      0  7457					      NEGEVAL
      1  7457
      2  7457		       38		      sec
      3  7458		       a9 00		      lda	#0
      4  745a		       e5 90		      sbc	Evaluation
      5  745c		       85 90		      sta	Evaluation
      6  745e		       a9 00		      lda	#0
      7  7460		       e5 91		      sbc	Evaluation+1
      8  7462		       85 91		      sta	Evaluation+1
      0  7464					      SWAP
      1  7464		       a5 96		      lda	sideToMove
      2  7466		       49 80		      eor	#SWAP_SIDE
      3  7468		       85 96		      sta	sideToMove
    111  746a
    112  746a		       a5 95		      lda	currentPly
    113  746c		       85 3e		      sta	SET_BANK_RAM
    114  746e		       60		      rts
    115  746f
    116  746f
    117  746f							;---------------------------------------------------------------------------------------------------
    118  746f
      0  746f					      DEF	unmakeMove
      1  746f				   SLOT_unmakeMove SET	_BANK_SLOT
      2  746f				   BANK_unmakeMove SET	SLOT_unmakeMove + _CURRENT_BANK
      3  746f				   unmakeMove
      4  746f				   TEMPORARY_VAR SET	Overlay
      5  746f				   TEMPORARY_OFFSET SET	0
      6  746f				   VAR_BOUNDARY_unmakeMove SET	TEMPORARY_OFFSET
      7  746f				   FUNCTION_NAME SET	unmakeMove
    120  746f					      SUBROUTINE
    121  746f
      0  746f					      REFER	negaMax
      1  746f					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  746f				   TEMPORARY_VAR SET	VAREND_negaMax
      3  746f					      ENDIF
      0  746f					      VAR	__unmake_capture, 1
      1  746f		       00 ae	   __unmake_capture =	TEMPORARY_VAR
      2  746f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  746f
      4  746f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  746f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  746f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  746f					      ENDIF
      8  746f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  746f				  -	      ECHO	"Temporary Variable", __unmake_capture, "overflow!"
     10  746f				  -	      ERR
     11  746f					      ENDIF
     12  746f					      LIST	ON
      0  746f					      VAR	__secondaryBlank, 1
      1  746f		       00 af	   __secondaryBlank =	TEMPORARY_VAR
      2  746f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  746f
      4  746f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  746f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  746f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  746f					      ENDIF
      8  746f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  746f				  -	      ECHO	"Temporary Variable", __secondaryBlank, "overflow!"
     10  746f				  -	      ERR
     11  746f					      ENDIF
     12  746f					      LIST	ON
      0  746f					      VEND	unmakeMove
      1  746f				  -	      IFNCONST	unmakeMove
      2  746f				  -	      ECHO	"Incorrect VEND label", unmakeMove
      3  746f				  -	      ERR
      4  746f					      ENDIF
      5  746f		       00 b0	   VAREND_unmakeMove =	TEMPORARY_VAR
    126  746f
    127  746f							; restore the board evaluation to what it was at the start of this ply
    128  746f							; TODO: note: moved flag seems wrong on restoration
    129  746f
      0  746f					      lda@PLY	savedEvaluation
      1  746f		       ad 96 ff 	      lda	savedEvaluation
    131  7472		       85 90		      sta	Evaluation
      0  7474					      lda@PLY	savedEvaluation+1
      1  7474		       ad 97 ff 	      lda	savedEvaluation+1
    133  7477		       85 91		      sta	Evaluation+1
    134  7479
    135  7479		       ae 9f ff 	      ldx	movePtr
      0  747c					      lda@PLY	MoveFrom,x
      1  747c		       bd 00 fc 	      lda	MoveFrom,x
    137  747f		       85 85		      sta	fromX12
      0  7481					      ldy@PLY	MoveTo,x
      1  7481		       bc 00 fd 	      ldy	MoveTo,x
    139  7484
      0  7484					      lda@PLY	restorePiece
      1  7484		       ad a8 ff 	      lda	restorePiece
    141  7487		       48		      pha
      0  7488					      lda@PLY	capturedPiece
      1  7488		       ad 99 ff 	      lda	capturedPiece
    143  748b
    144  748b		       a2 cf		      ldx	#RAMBANK_BOARD
    145  748d		       86 3e		      stx	SET_BANK_RAM
      0  748f					      sta@RAM	Board,y
      1  748f		       99 79 fe 	      sta	[RAM]+Board,y
    147  7492		       a4 85		      ldy	fromX12
    148  7494		       68		      pla
      0  7495					      sta@RAM	Board,y
      1  7495		       99 79 fe 	      sta	[RAM]+Board,y
    150  7498
    151  7498
    152  7498		       a5 95		      lda	currentPly
    153  749a		       85 3e		      sta	SET_BANK_RAM
    154  749c
    155  749c							; See if there are any 'secondary' pieces that moved
    156  749c							; here we're dealing with reverting a castling or enPassant move
    157  749c
      0  749c					      lda@PLY	secondaryPiece
      1  749c		       ad 9b ff 	      lda	secondaryPiece
    159  749f		       f0 1a		      beq	.noSecondary
      0  74a1					      ldy@PLY	secondaryBlank
      1  74a1		       ac 9d ff 	      ldy	secondaryBlank
    161  74a4		       84 af		      sty	__secondaryBlank
      0  74a6					      ldy@PLY	secondarySquare
      1  74a6		       ac 9c ff 	      ldy	secondarySquare
    163  74a9
    164  74a9
    165  74a9		       a2 cf		      ldx	#RAMBANK_BOARD
    166  74ab		       86 3e		      stx	SET_BANK_RAM
      0  74ad					      sta@RAM	Board,y	; put piece back
      1  74ad		       99 79 fe 	      sta	[RAM]+Board,y
    168  74b0
    169  74b0		       a4 af		      ldy	__secondaryBlank
    170  74b2		       a9 00		      lda	#0
      0  74b4					      sta@RAM	Board,y	; blank piece origin
      1  74b4		       99 79 fe 	      sta	[RAM]+Board,y
    172  74b7
    173  74b7		       a5 95		      lda	currentPly
    174  74b9		       85 3e		      sta	SET_BANK_RAM
    175  74bb
    176  74bb
    177  74bb				   .noSecondary
      0  74bb					      SWAP
      1  74bb		       a5 96		      lda	sideToMove
      2  74bd		       49 80		      eor	#SWAP_SIDE
      3  74bf		       85 96		      sta	sideToMove
    179  74c1		       60		      rts
    180  74c2
    181  74c2
    182  74c2							;---------------------------------------------------------------------------------------------------
    183  74c2
      0  74c2					      DEF	SAFE_getMoveIndex
      1  74c2				   SLOT_SAFE_getMoveIndex SET	_BANK_SLOT
      2  74c2				   BANK_SAFE_getMoveIndex SET	SLOT_SAFE_getMoveIndex + _CURRENT_BANK
      3  74c2				   SAFE_getMoveIndex
      4  74c2				   TEMPORARY_VAR SET	Overlay
      5  74c2				   TEMPORARY_OFFSET SET	0
      6  74c2				   VAR_BOUNDARY_SAFE_getMoveIndex SET	TEMPORARY_OFFSET
      7  74c2				   FUNCTION_NAME SET	SAFE_getMoveIndex
    185  74c2					      SUBROUTINE
    186  74c2
    187  74c2		       a9 c9		      lda	#RAMBANK_PLY+1
    188  74c4		       85 3e		      sta	SET_BANK_RAM
      0  74c6					      lda@PLY	moveIndex
      1  74c6		       ad 9e ff 	      lda	moveIndex
    190  74c9		       a6 8b		      ldx	savedBank
    191  74cb		       86 3f		      stx	SET_BANK
    192  74cd		       60		      rts
    193  74ce
    194  74ce
    195  74ce							;---------------------------------------------------------------------------------------------------
    196  74ce
      0  74ce					      DEF	CopySetupForMarker
      1  74ce				   SLOT_CopySetupForMarker SET	_BANK_SLOT
      2  74ce				   BANK_CopySetupForMarker SET	SLOT_CopySetupForMarker + _CURRENT_BANK
      3  74ce				   CopySetupForMarker
      4  74ce				   TEMPORARY_VAR SET	Overlay
      5  74ce				   TEMPORARY_OFFSET SET	0
      6  74ce				   VAR_BOUNDARY_CopySetupForMarker SET	TEMPORARY_OFFSET
      7  74ce				   FUNCTION_NAME SET	CopySetupForMarker
    198  74ce					      SUBROUTINE
    199  74ce
      0  74ce					      REFER	markerDraw
      1  74ce					      IF	VAREND_markerDraw > TEMPORARY_VAR
      2  74ce				   TEMPORARY_VAR SET	VAREND_markerDraw
      3  74ce					      ENDIF
      0  74ce					      REFER	showPromoteOptions
      1  74ce				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  74ce				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  74ce					      ENDIF
      0  74ce					      VAR	__pieceColour, 1
      1  74ce		       00 a4	   __pieceColour =	TEMPORARY_VAR
      2  74ce				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  74ce
      4  74ce				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  74ce				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  74ce				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  74ce					      ENDIF
      8  74ce				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  74ce				  -	      ECHO	"Temporary Variable", __pieceColour, "overflow!"
     10  74ce				  -	      ERR
     11  74ce					      ENDIF
     12  74ce					      LIST	ON
      0  74ce					      VAR	__oddeven, 1
      1  74ce		       00 a5	   __oddeven  =	TEMPORARY_VAR
      2  74ce				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  74ce
      4  74ce				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  74ce				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  74ce				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  74ce					      ENDIF
      8  74ce				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  74ce				  -	      ECHO	"Temporary Variable", __oddeven, "overflow!"
     10  74ce				  -	      ERR
     11  74ce					      ENDIF
     12  74ce					      LIST	ON
      0  74ce					      VAR	__pmcol, 1
      1  74ce		       00 a6	   __pmcol    =	TEMPORARY_VAR
      2  74ce				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  74ce
      4  74ce				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  74ce				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  74ce				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  74ce					      ENDIF
      8  74ce				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  74ce				  -	      ECHO	"Temporary Variable", __pmcol, "overflow!"
     10  74ce				  -	      ERR
     11  74ce					      ENDIF
     12  74ce					      LIST	ON
      0  74ce					      VEND	CopySetupForMarker
      1  74ce				  -	      IFNCONST	CopySetupForMarker
      2  74ce				  -	      ECHO	"Incorrect VEND label", CopySetupForMarker
      3  74ce				  -	      ERR
      4  74ce					      ENDIF
      5  74ce		       00 a7	   VAREND_CopySetupForMarker =	TEMPORARY_VAR
    206  74ce
    207  74ce		       a5 80		      lda	squareToDraw
    208  74d0		       38		      sec
    209  74d1		       a0 0a		      ldy	#10
    210  74d3		       e9 0a	   .sub10     sbc	#10
    211  74d5		       88		      dey
    212  74d6		       b0 fb		      bcs	.sub10
    213  74d8		       84 a5		      sty	__oddeven
    214  74da		       69 08		      adc	#8
    215  74dc		       85 a6		      sta	__pmcol
    216  74de		       65 a5		      adc	__oddeven
    217  74e0
    218  74e0		       29 01		      and	#1
    219  74e2		       49 01		      eor	#1
    220  74e4		       f0 02		      beq	.white
    221  74e6		       a9 24		      lda	#36
    222  74e8				   .white
    223  74e8		       85 a4		      sta	__pieceColour	; actually SQUARE black/white
    224  74ea
    225  74ea		       8a		      txa
    226  74eb		       18		      clc
    227  74ec		       65 a4		      adc	__pieceColour
    228  74ee		       85 a4		      sta	__pieceColour
    229  74f0
    230  74f0		       a5 a6		      lda	__pmcol
    231  74f2		       29 03		      and	#3
    232  74f4
    233  74f4		       18		      clc
    234  74f5		       65 a4		      adc	__pieceColour
    235  74f7		       a8		      tay
    236  74f8		       60		      rts
    237  74f9
    238  74f9
    239  74f9							;---------------------------------------------------------------------------------------------------
    240  74f9
      0  74f9					      DEF	AddMoveSlider
      1  74f9				   SLOT_AddMoveSlider SET	_BANK_SLOT
      2  74f9				   BANK_AddMoveSlider SET	SLOT_AddMoveSlider + _CURRENT_BANK
      3  74f9				   AddMoveSlider
      4  74f9				   TEMPORARY_VAR SET	Overlay
      5  74f9				   TEMPORARY_OFFSET SET	0
      6  74f9				   VAR_BOUNDARY_AddMoveSlider SET	TEMPORARY_OFFSET
      7  74f9				   FUNCTION_NAME SET	AddMoveSlider
    242  74f9					      SUBROUTINE
    243  74f9
      0  74f9					      VEND	AddMoveSlider
      1  74f9				  -	      IFNCONST	AddMoveSlider
      2  74f9				  -	      ECHO	"Incorrect VEND label", AddMoveSlider
      3  74f9				  -	      ERR
      4  74f9					      ENDIF
      5  74f9		       00 a2	   VAREND_AddMoveSlider =	TEMPORARY_VAR
    245  74f9
    246  74f9							; add square in y register to movelist as destination (X12 format)
    247  74f9							; [y]		     to square (X12)
    248  74f9							; currentSquare     from square (X12)
    249  74f9							; currentPiece      piece.
    250  74f9							;   ENPASSANT flag set if pawn double-moving off opening rank
    251  74f9							; capture	     captured piece
    252  74f9
    253  74f9		       a5 9e		      lda	capture
    254  74fb		       d0 04		      bne	.always
    255  74fd		       a5 ad		      lda	__quiesceCapOnly
    256  74ff		       d0 1c		      bne	.abort
    257  7501
    258  7501				   .always
    259  7501		       98		      tya
    260  7502
      0  7502					      ldy@PLY	moveIndex
      1  7502		       ac 9e ff 	      ldy	moveIndex
    262  7505		       c8		      iny
      0  7506					      sty@PLY	moveIndex
      1  7506		       8c 9e 01 	      sty	[RAM]+moveIndex
    264  7509
      0  7509					      sta@PLY	MoveTo,y
      1  7509		       99 00 ff 	      sta	[RAM]+MoveTo,y
    266  750c		       aa		      tax		; used for continuation of sliding moves
    267  750d		       a5 93		      lda	currentSquare
      0  750f					      sta@PLY	MoveFrom,y
      1  750f		       99 00 fe 	      sta	[RAM]+MoveFrom,y
    269  7512		       a5 92		      lda	currentPiece
      0  7514					      sta@PLY	MovePiece,y
      1  7514		       99 00 00 	      sta	[RAM]+MovePiece,y
    271  7517		       a5 9e		      lda	capture
      0  7519					      sta@PLY	MoveCapture,y
      1  7519		       99 00 01 	      sta	[RAM]+MoveCapture,y
    273  751c
    274  751c		       60		      rts
    275  751d
    276  751d		       98	   .abort     tya
    277  751e		       aa		      tax
    278  751f		       60		      rts
    279  7520
    280  7520
      0  7520					      DEF	AddMove
      1  7520				   SLOT_AddMove SET	_BANK_SLOT
      2  7520				   BANK_AddMove SET	SLOT_AddMove + _CURRENT_BANK
      3  7520				   AddMove
      4  7520				   TEMPORARY_VAR SET	Overlay
      5  7520				   TEMPORARY_OFFSET SET	0
      6  7520				   VAR_BOUNDARY_AddMove SET	TEMPORARY_OFFSET
      7  7520				   FUNCTION_NAME SET	AddMove
    282  7520					      SUBROUTINE
    283  7520
      0  7520					      VEND	AddMove
      1  7520				  -	      IFNCONST	AddMove
      2  7520				  -	      ECHO	"Incorrect VEND label", AddMove
      3  7520				  -	      ERR
      4  7520					      ENDIF
      5  7520		       00 a2	   VAREND_AddMove =	TEMPORARY_VAR
    285  7520
    286  7520							; add square in y register to movelist as destination (X12 format)
    287  7520							; [y]		     to square (X12)
    288  7520							; currentSquare     from square (X12)
    289  7520							; currentPiece      piece.
    290  7520							;   ENPASSANT flag set if pawn double-moving off opening rank
    291  7520							; capture	     captured piece
    292  7520
    293  7520		       a5 9e		      lda	capture
    294  7522		       d0 04		      bne	.always
    295  7524		       a5 ad		      lda	__quiesceCapOnly
    296  7526		       d0 1a		      bne	.abort
    297  7528
    298  7528				   .always		;lda currentPly
    299  7528							;sta SET_BANK_RAM
    300  7528
    301  7528		       98		      tya
    302  7529
      0  7529					      ldy@PLY	moveIndex
      1  7529		       ac 9e ff 	      ldy	moveIndex
    304  752c		       c8		      iny
      0  752d					      sty@PLY	moveIndex
      1  752d		       8c 9e 01 	      sty	[RAM]+moveIndex
    306  7530
      0  7530					      sta@PLY	MoveTo,y
      1  7530		       99 00 ff 	      sta	[RAM]+MoveTo,y
    308  7533		       a5 93		      lda	currentSquare
      0  7535					      sta@PLY	MoveFrom,y
      1  7535		       99 00 fe 	      sta	[RAM]+MoveFrom,y
    310  7538		       a5 92		      lda	currentPiece
      0  753a					      sta@PLY	MovePiece,y
      1  753a		       99 00 00 	      sta	[RAM]+MovePiece,y
    312  753d		       a5 9e		      lda	capture
      0  753f					      sta@PLY	MoveCapture,y
      1  753f		       99 00 01 	      sta	[RAM]+MoveCapture,y
    314  7542
    315  7542		       60	   .abort     rts
    316  7543
    317  7543							;---------------------------------------------------------------------------------------------------
    318  7543							; TODO - is this valid?
    319  7543
      0  7543					      DEF	markerDraw
      1  7543				   SLOT_markerDraw SET	_BANK_SLOT
      2  7543				   BANK_markerDraw SET	SLOT_markerDraw + _CURRENT_BANK
      3  7543				   markerDraw
      4  7543				   TEMPORARY_VAR SET	Overlay
      5  7543				   TEMPORARY_OFFSET SET	0
      6  7543				   VAR_BOUNDARY_markerDraw SET	TEMPORARY_OFFSET
      7  7543				   FUNCTION_NAME SET	markerDraw
    321  7543					      SUBROUTINE
    322  7543
      0  7543					      REFER	SAFE_showMoveOptions
      1  7543					      IF	VAREND_SAFE_showMoveOptions > TEMPORARY_VAR
      2  7543				   TEMPORARY_VAR SET	VAREND_SAFE_showMoveOptions
      3  7543					      ENDIF
      0  7543					      VEND	markerDraw
      1  7543				  -	      IFNCONST	markerDraw
      2  7543				  -	      ECHO	"Incorrect VEND label", markerDraw
      3  7543				  -	      ERR
      4  7543					      ENDIF
      5  7543		       00 a4	   VAREND_markerDraw =	TEMPORARY_VAR
    325  7543		       a2 1c		      ldx	#INDEX_WHITE_MARKER_on_WHITE_SQUARE_0
    326  7545		       20 ce f4 	      jsr	CopySetupForMarker
    327  7548		       4c 9f f0 	      jmp	InterceptMarkerCopy
    328  754b
    329  754b
    330  754b							;---------------------------------------------------------------------------------------------------
    331  754b
      0  754b					      DEF	GetP_MoveFrom
      1  754b				   SLOT_GetP_MoveFrom SET	_BANK_SLOT
      2  754b				   BANK_GetP_MoveFrom SET	SLOT_GetP_MoveFrom + _CURRENT_BANK
      3  754b				   GetP_MoveFrom
      4  754b				   TEMPORARY_VAR SET	Overlay
      5  754b				   TEMPORARY_OFFSET SET	0
      6  754b				   VAR_BOUNDARY_GetP_MoveFrom SET	TEMPORARY_OFFSET
      7  754b				   FUNCTION_NAME SET	GetP_MoveFrom
    333  754b		       a9 c9		      lda	#RAMBANK_PLY+1
    334  754d		       85 3e		      sta	SET_BANK_RAM
    335  754f		       a4 8b		      ldy	savedBank
      0  7551					      lda@PLY	MoveFrom,x
      1  7551		       bd 00 fc 	      lda	MoveFrom,x
    337  7554		       84 3f		      sty	SET_BANK
    338  7556		       60		      rts
    339  7557
    340  7557
    341  7557							;---------------------------------------------------------------------------------------------------
    342  7557
      0  7557					      DEF	GetP_MoveTo
      1  7557				   SLOT_GetP_MoveTo SET	_BANK_SLOT
      2  7557				   BANK_GetP_MoveTo SET	SLOT_GetP_MoveTo + _CURRENT_BANK
      3  7557				   GetP_MoveTo
      4  7557				   TEMPORARY_VAR SET	Overlay
      5  7557				   TEMPORARY_OFFSET SET	0
      6  7557				   VAR_BOUNDARY_GetP_MoveTo SET	TEMPORARY_OFFSET
      7  7557				   FUNCTION_NAME SET	GetP_MoveTo
    344  7557					      SUBROUTINE
    345  7557
    346  7557		       a9 c9		      lda	#RAMBANK_PLY+1
    347  7559		       85 3e		      sta	SET_BANK_RAM
    348  755b		       a4 8b		      ldy	savedBank
      0  755d					      lda@PLY	MoveTo,x
      1  755d		       bd 00 fd 	      lda	MoveTo,x
    350  7560		       84 3f		      sty	SET_BANK
    351  7562		       60		      rts
    352  7563
    353  7563
    354  7563							;---------------------------------------------------------------------------------------------------
    355  7563
      0  7563					      DEF	GetPiece
      1  7563				   SLOT_GetPiece SET	_BANK_SLOT
      2  7563				   BANK_GetPiece SET	SLOT_GetPiece + _CURRENT_BANK
      3  7563				   GetPiece
      4  7563				   TEMPORARY_VAR SET	Overlay
      5  7563				   TEMPORARY_OFFSET SET	0
      6  7563				   VAR_BOUNDARY_GetPiece SET	TEMPORARY_OFFSET
      7  7563				   FUNCTION_NAME SET	GetPiece
    357  7563					      SUBROUTINE
    358  7563
      0  7563					      REFER	aiSelectDestinationSquare
      1  7563				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  7563				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  7563					      ENDIF
      0  7563					      REFER	aiQuiescent
      1  7563				  -	      IF	VAREND_aiQuiescent > TEMPORARY_VAR
      2  7563				  -TEMPORARY_VAR SET	VAREND_aiQuiescent
      3  7563					      ENDIF
      0  7563					      VEND	GetPiece
      1  7563				  -	      IFNCONST	GetPiece
      2  7563				  -	      ECHO	"Incorrect VEND label", GetPiece
      3  7563				  -	      ERR
      4  7563					      ENDIF
      5  7563		       00 a2	   VAREND_GetPiece =	TEMPORARY_VAR
    362  7563
    363  7563							; Retrieve the piece+flags from the movelist, given from/to squares
    364  7563							; Required as moves have different flags but same origin squares (e.g., castling)
    365  7563
    366  7563		       a5 95		      lda	currentPly
    367  7565		       85 3e		      sta	SET_BANK_RAM
    368  7567
    369  7567		       20 2c f8 	      jsr	GetPieceGivenFromToSquares
    370  756a
    371  756a		       a5 8b		      lda	savedBank
    372  756c		       85 3f		      sta	SET_BANK
    373  756e		       60		      rts
    374  756f
    375  756f
    376  756f							;---------------------------------------------------------------------------------------------------
    377  756f
      0  756f					      DEF	GetP_MovePiece
      1  756f				   SLOT_GetP_MovePiece SET	_BANK_SLOT
      2  756f				   BANK_GetP_MovePiece SET	SLOT_GetP_MovePiece + _CURRENT_BANK
      3  756f				   GetP_MovePiece
      4  756f				   TEMPORARY_VAR SET	Overlay
      5  756f				   TEMPORARY_OFFSET SET	0
      6  756f				   VAR_BOUNDARY_GetP_MovePiece SET	TEMPORARY_OFFSET
      7  756f				   FUNCTION_NAME SET	GetP_MovePiece
    379  756f					      SUBROUTINE
    380  756f
    381  756f		       a9 c9		      lda	#RAMBANK_PLY+1
    382  7571		       85 3e		      sta	SET_BANK_RAM
    383  7573		       a4 8b		      ldy	savedBank
      0  7575					      lda@PLY	MovePiece,x
      1  7575		       bd 00 fe 	      lda	MovePiece,x
    385  7578		       84 3f		      sty	SET_BANK
    386  757a		       60		      rts
    387  757b
    388  757b
    389  757b							;---------------------------------------------------------------------------------------------------
    390  757b
      0  757b					      DEF	aiComputerMove
      1  757b				   SLOT_aiComputerMove SET	_BANK_SLOT
      2  757b				   BANK_aiComputerMove SET	SLOT_aiComputerMove + _CURRENT_BANK
      3  757b				   aiComputerMove
      4  757b				   TEMPORARY_VAR SET	Overlay
      5  757b				   TEMPORARY_OFFSET SET	0
      6  757b				   VAR_BOUNDARY_aiComputerMove SET	TEMPORARY_OFFSET
      7  757b				   FUNCTION_NAME SET	aiComputerMove
    392  757b					      SUBROUTINE
    393  757b
      0  757b					      REFER	AiStateMachine
      1  757b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  757b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  757b					      ENDIF
      0  757b					      VEND	aiComputerMove
      1  757b				  -	      IFNCONST	aiComputerMove
      2  757b				  -	      ECHO	"Incorrect VEND label", aiComputerMove
      3  757b				  -	      ERR
      4  757b					      ENDIF
      5  757b		       00 a2	   VAREND_aiComputerMove =	TEMPORARY_VAR
    396  757b
    397  757b
    398  757b		       a9 c8		      lda	#RAMBANK_PLY
    399  757d		       85 95		      sta	currentPly
    400  757f		       85 3e		      sta	SET_BANK_RAM	; switch in movelist
    401  7581
    402  7581		       a9 01		      lda	#1
    403  7583		       85 4a		      sta	CTRLPF	; mirroring for thinkbars
    404  7585
    405  7585		       20 47 f8 	      jsr	selectmove
    406  7588
    407  7588		       a9 00		      lda	#0
    408  758a		       85 4a		      sta	CTRLPF	; clear mirroring
    409  758c		       85 4e		      sta	PF1
    410  758e		       85 4f		      sta	PF2
    411  7590
      0  7590					      lda@PLY	bestMove
      1  7590		       ad a0 ff 	      lda	bestMove
    413  7593		       10 17		      bpl	.notComputer
    414  7595
    415  7595							; Computer could not find a valid move. It's checkmate or stalemate. Find which...
    416  7595
      0  7595					      SWAP
      1  7595		       a5 96		      lda	sideToMove
      2  7597		       49 80		      eor	#SWAP_SIDE
      3  7599		       85 96		      sta	sideToMove
    418  759b		       20 68 f1 	      jsr	GenerateAllMoves
    419  759e		       a5 9f		      lda	flagCheck
    420  75a0		       f0 05		      beq	.gameDrawn
    421  75a2
      0  75a2					      PHASE	AI_CheckMate
      1  75a2		       a9 23		      lda	#AI_CheckMate
      2  75a4		       85 8c		      sta	aiState
    423  75a6		       60		      rts
    424  75a7
    425  75a7
      0  75a7				   .gameDrawn PHASE	AI_Draw
      1  75a7		       a9 24		      lda	#AI_Draw
      2  75a9		       85 8c		      sta	aiState
    427  75ab		       60		      rts
    428  75ac
    429  75ac				   .notComputer
    430  75ac
    431  75ac
    432  75ac		       a9 ff		      lda	#-1
    433  75ae		       85 88		      sta	cursorX12
    434  75b0
      0  75b0					      PHASE	AI_DelayAfterMove
      1  75b0		       a9 25		      lda	#AI_DelayAfterMove
      2  75b2		       85 8c		      sta	aiState
    436  75b4		       60	   .halted    rts
    437  75b5
    438  75b5
    439  75b5
    440  75b5							;---------------------------------------------------------------------------------------------------
    441  75b5
      0  75b5					      DEF	aiSpecialMoveFixup
      1  75b5				   SLOT_aiSpecialMoveFixup SET	_BANK_SLOT
      2  75b5				   BANK_aiSpecialMoveFixup SET	SLOT_aiSpecialMoveFixup + _CURRENT_BANK
      3  75b5				   aiSpecialMoveFixup
      4  75b5				   TEMPORARY_VAR SET	Overlay
      5  75b5				   TEMPORARY_OFFSET SET	0
      6  75b5				   VAR_BOUNDARY_aiSpecialMoveFixup SET	TEMPORARY_OFFSET
      7  75b5				   FUNCTION_NAME SET	aiSpecialMoveFixup
    443  75b5					      SUBROUTINE
    444  75b5
      0  75b5					      COMMON_VARS_ALPHABETA
      1  75b5
      0  75b5					      VAR	__thinkbar, 1
      1  75b5		       00 a2	   __thinkbar =	TEMPORARY_VAR
      2  75b5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  75b5
      4  75b5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  75b5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  75b5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  75b5					      ENDIF
      8  75b5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  75b5				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  75b5				  -	      ERR
     11  75b5					      ENDIF
     12  75b5					      LIST	ON
      0  75b5					      VAR	__toggle, 1
      1  75b5		       00 a3	   __toggle   =	TEMPORARY_VAR
      2  75b5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  75b5
      4  75b5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  75b5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  75b5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  75b5					      ENDIF
      8  75b5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  75b5				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  75b5				  -	      ERR
     11  75b5					      ENDIF
     12  75b5					      LIST	ON
      4  75b5
      0  75b5					      VAR	__bestMove, 1
      1  75b5		       00 a4	   __bestMove =	TEMPORARY_VAR
      2  75b5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  75b5
      4  75b5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  75b5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  75b5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  75b5					      ENDIF
      8  75b5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  75b5				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  75b5				  -	      ERR
     11  75b5					      ENDIF
     12  75b5					      LIST	ON
      0  75b5					      VAR	__alpha, 2
      1  75b5		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  75b5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  75b5
      4  75b5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  75b5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  75b5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  75b5					      ENDIF
      8  75b5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  75b5				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  75b5				  -	      ERR
     11  75b5					      ENDIF
     12  75b5					      LIST	ON
      0  75b5					      VAR	__beta, 2
      1  75b5		       00 a7	   __beta     =	TEMPORARY_VAR
      2  75b5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  75b5
      4  75b5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  75b5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  75b5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  75b5					      ENDIF
      8  75b5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  75b5				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  75b5				  -	      ERR
     11  75b5					      ENDIF
     12  75b5					      LIST	ON
      0  75b5					      VAR	__negaMax, 2
      1  75b5		       00 a9	   __negaMax  =	TEMPORARY_VAR
      2  75b5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  75b5
      4  75b5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  75b5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  75b5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  75b5					      ENDIF
      8  75b5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  75b5				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  75b5				  -	      ERR
     11  75b5					      ENDIF
     12  75b5					      LIST	ON
      0  75b5					      VAR	__value, 2
      1  75b5		       00 ab	   __value    =	TEMPORARY_VAR
      2  75b5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  75b5
      4  75b5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  75b5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  75b5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  75b5					      ENDIF
      8  75b5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  75b5				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  75b5				  -	      ERR
     11  75b5					      ENDIF
     12  75b5					      LIST	ON
     10  75b5
      0  75b5					      VAR	__quiesceCapOnly, 1
      1  75b5		       00 ad	   __quiesceCapOnly =	TEMPORARY_VAR
      2  75b5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  75b5
      4  75b5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  75b5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  75b5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  75b5					      ENDIF
      8  75b5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  75b5				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  75b5				  -	      ERR
     11  75b5					      ENDIF
     12  75b5					      LIST	ON
     12  75b5
      0  75b5					      REFER	AiStateMachine
      1  75b5				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  75b5				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  75b5					      ENDIF
      0  75b5					      VEND	aiSpecialMoveFixup
      1  75b5				  -	      IFNCONST	aiSpecialMoveFixup
      2  75b5				  -	      ECHO	"Incorrect VEND label", aiSpecialMoveFixup
      3  75b5				  -	      ERR
      4  75b5					      ENDIF
      5  75b5		       00 ae	   VAREND_aiSpecialMoveFixup =	TEMPORARY_VAR
    448  75b5
    449  75b5		       ad 84 02 	      lda	INTIM
    450  75b8		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    451  75ba		       b0 01		      bcs	.cont
    452  75bc		       60		      rts
    453  75bd
    454  75bd
    455  75bd				   .cont
    456  75bd
    457  75bd
      0  75bd					      PHASE	AI_DelayAfterPlaced
      1  75bd		       a9 27		      lda	#AI_DelayAfterPlaced
      2  75bf		       85 8c		      sta	aiState
    459  75c1
    460  75c1
    461  75c1							; Special move fixup
    462  75c1
    463  75c1					      IF	ENPASSANT_ENABLED
    464  75c1
    465  75c1							; Handle en-passant captures
    466  75c1							; The (dual-use) FLAG_ENPASSANT will have been cleared if it was set for a home-rank move
    467  75c1							; but if we're here and the flag is still set, then it's an actual en-passant CAPTURE and we
    468  75c1							; need to do the appropriate things...
    469  75c1
    470  75c1		       a9 5d		      lda	#BANK_EnPassantCheck
    471  75c3		       85 3f		      sta	SET_BANK
    472  75c5		       20 20 f6 	      jsr	EnPassantCheck
    473  75c8
    474  75c8					      ENDIF
    475  75c8
    476  75c8
    477  75c8		       a5 95		      lda	currentPly
    478  75ca		       85 3e		      sta	SET_BANK_RAM
    479  75cc		       20 c1 f8 	      jsr	CastleFixupDraw
    480  75cf
    481  75cf		       a5 85		      lda	fromX12
    482  75d1		       85 80		      sta	squareToDraw
    483  75d3
    484  75d3		       60		      rts
    485  75d4
    486  75d4
    487  75d4							;---------------------------------------------------------------------------------------------------
    488  75d4
      0  75d4					      DEF	aiDrawEntireBoard
      1  75d4				   SLOT_aiDrawEntireBoard SET	_BANK_SLOT
      2  75d4				   BANK_aiDrawEntireBoard SET	SLOT_aiDrawEntireBoard + _CURRENT_BANK
      3  75d4				   aiDrawEntireBoard
      4  75d4				   TEMPORARY_VAR SET	Overlay
      5  75d4				   TEMPORARY_OFFSET SET	0
      6  75d4				   VAR_BOUNDARY_aiDrawEntireBoard SET	TEMPORARY_OFFSET
      7  75d4				   FUNCTION_NAME SET	aiDrawEntireBoard
    490  75d4					      SUBROUTINE
    491  75d4
      0  75d4					      REFER	AiStateMachine
      1  75d4				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  75d4				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  75d4					      ENDIF
      0  75d4					      VEND	aiDrawEntireBoard
      1  75d4				  -	      IFNCONST	aiDrawEntireBoard
      2  75d4				  -	      ECHO	"Incorrect VEND label", aiDrawEntireBoard
      3  75d4				  -	      ERR
      4  75d4					      ENDIF
      5  75d4		       00 a2	   VAREND_aiDrawEntireBoard =	TEMPORARY_VAR
    494  75d4
    495  75d4
    496  75d4		       ad 84 02 	      lda	INTIM
    497  75d7		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    498  75d9		       90 2c		      bcc	.exit
    499  75db
    500  75db							; We use [SLOT3] for accessing board
    501  75db
    502  75db		       a9 cf		      lda	#RAMBANK_BOARD
    503  75dd		       85 3e		      sta	SET_BANK_RAM
    504  75df		       a4 80		      ldy	squareToDraw
    505  75e1		       b9 15 fc 	      lda	ValidSquare,y
    506  75e4		       30 1d		      bmi	.isablank2
    507  75e6
    508  75e6		       b9 79 fc 	      lda	Board,y
    509  75e9		       f0 13		      beq	.isablank
    510  75eb		       48		      pha
    511  75ec		       a9 00		      lda	#BLANK
      0  75ee					      sta@RAM	Board,y
      1  75ee		       99 79 fe 	      sta	[RAM]+Board,y
    513  75f1
    514  75f1		       20 98 f0 	      jsr	CopySinglePiece
    515  75f4
    516  75f4		       a9 cf		      lda	#RAMBANK_BOARD
    517  75f6		       85 3e		      sta	SET_BANK_RAM
    518  75f8
    519  75f8		       a4 80		      ldy	squareToDraw
    520  75fa		       68		      pla
      0  75fb					      sta@RAM	Board,y
      1  75fb		       99 79 fe 	      sta	[RAM]+Board,y
    522  75fe
      0  75fe				   .isablank  PHASE	AI_DrawPart2
      1  75fe		       a9 10		      lda	#AI_DrawPart2
      2  7600		       85 8c		      sta	aiState
    524  7602		       60		      rts
    525  7603
      0  7603				   .isablank2 PHASE	AI_DrawPart3
      1  7603		       a9 11		      lda	#AI_DrawPart3
      2  7605		       85 8c		      sta	aiState
    527  7607		       60	   .exit      rts
    528  7608
    529  7608
    530  7608							;---------------------------------------------------------------------------------------------------
    531  7608
      0  7608					      DEF	PutBoard
      1  7608				   SLOT_PutBoard SET	_BANK_SLOT
      2  7608				   BANK_PutBoard SET	SLOT_PutBoard + _CURRENT_BANK
      3  7608				   PutBoard
      4  7608				   TEMPORARY_VAR SET	Overlay
      5  7608				   TEMPORARY_OFFSET SET	0
      6  7608				   VAR_BOUNDARY_PutBoard SET	TEMPORARY_OFFSET
      7  7608				   FUNCTION_NAME SET	PutBoard
    533  7608		       a2 cf		      ldx	#RAMBANK_BOARD
    534  760a		       86 3e		      stx	SET_BANK_RAM
      0  760c					      sta@RAM	Board,y	; and what's actually moving there
      1  760c		       99 79 fe 	      sta	[RAM]+Board,y
    536  760f		       a6 8b		      ldx	savedBank
    537  7611		       86 3f		      stx	SET_BANK
    538  7613		       60		      rts
    539  7614
    540  7614
    541  7614							;---------------------------------------------------------------------------------------------------
    542  7614
      0  7614					      DEF	GetBoard
      1  7614				   SLOT_GetBoard SET	_BANK_SLOT
      2  7614				   BANK_GetBoard SET	SLOT_GetBoard + _CURRENT_BANK
      3  7614				   GetBoard
      4  7614				   TEMPORARY_VAR SET	Overlay
      5  7614				   TEMPORARY_OFFSET SET	0
      6  7614				   VAR_BOUNDARY_GetBoard SET	TEMPORARY_OFFSET
      7  7614				   FUNCTION_NAME SET	GetBoard
    544  7614		       a9 cf		      lda	#RAMBANK_BOARD
    545  7616		       85 3e		      sta	SET_BANK_RAM
    546  7618		       b9 79 fc 	      lda	Board,y
    547  761b		       a4 8b		      ldy	savedBank
    548  761d		       84 3f		      sty	SET_BANK
    549  761f		       60		      rts
    550  7620
    551  7620							;---------------------------------------------------------------------------------------------------
    552  7620
    553  7620
    554  7620							;---------------------------------------------------------------------------------------------------
    555  7620
    556  7620					      IF	ENPASSANT_ENABLED
    557  7620
      0  7620					      DEF	EnPassantCheck
      1  7620				   SLOT_EnPassantCheck SET	_BANK_SLOT
      2  7620				   BANK_EnPassantCheck SET	SLOT_EnPassantCheck + _CURRENT_BANK
      3  7620				   EnPassantCheck
      4  7620				   TEMPORARY_VAR SET	Overlay
      5  7620				   TEMPORARY_OFFSET SET	0
      6  7620				   VAR_BOUNDARY_EnPassantCheck SET	TEMPORARY_OFFSET
      7  7620				   FUNCTION_NAME SET	EnPassantCheck
    559  7620					      SUBROUTINE
    560  7620
      0  7620					      REFER	MakeMove
      1  7620					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  7620				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  7620					      ENDIF
      0  7620					      REFER	aiSpecialMoveFixup
      1  7620				  -	      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  7620				  -TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  7620					      ENDIF
      0  7620					      VEND	EnPassantCheck
      1  7620				  -	      IFNCONST	EnPassantCheck
      2  7620				  -	      ECHO	"Incorrect VEND label", EnPassantCheck
      3  7620				  -	      ERR
      4  7620					      ENDIF
      5  7620		       00 b0	   VAREND_EnPassantCheck =	TEMPORARY_VAR
    564  7620
    565  7620							; {
    566  7620							; With en-passant flag, it is essentially dual-use.
    567  7620							; First, it marks if the move is *involved* somehow in an en-passant
    568  7620							; if the piece has MOVED already, then it's an en-passant capture
    569  7620							; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
    570  7620
    571  7620		       a4 94		      ldy	enPassantPawn	; save from previous side move
    572  7622
    573  7622		       a2 00		      ldx	#0	; (probably) NO en-passant this time
    574  7624		       a5 97		      lda	fromPiece
    575  7626		       29 60		      and	#FLAG_ENPASSANT|FLAG_MOVED
    576  7628		       c9 20		      cmp	#FLAG_ENPASSANT
    577  762a		       d0 06		      bne	.noep	; HAS moved, or not en-passant
    578  762c
    579  762c		       45 97		      eor	fromPiece	; clear FLAG_ENPASSANT
    580  762e		       85 97		      sta	fromPiece
    581  7630
    582  7630		       a6 85		      ldx	fromX12	; this IS an en-passantable opening, so record the square
    583  7632		       86 94	   .noep      stx	enPassantPawn	; capturable square for en-passant move (or none)
    584  7634
    585  7634							; }
    586  7634
    587  7634
    588  7634							; Check to see if we are doing an actual en-passant capture...
    589  7634
    590  7634							; NOTE: If using test boards for debugging, the FLAG_MOVED flag is IMPORTANT
    591  7634							;  as the en-passant will fail if the taking piece does not have this flag set correctly
    592  7634
    593  7634		       a5 97		      lda	fromPiece
    594  7636		       29 20		      and	#FLAG_ENPASSANT
    595  7638		       f0 10		      beq	.notEnPassant	; not an en-passant, or it's enpassant by a MOVED piece
    596  763a
    597  763a
    598  763a							; {
    599  763a
    600  763a							; Here we are the aggressor and we need to take the pawn 'en passant' fashion
    601  763a							; y = the square containing the pawn to capture (i.e., previous value of 'enPassantPawn')
    602  763a
    603  763a							; Remove the pawn from the board and piecelist, and undraw
    604  763a
    605  763a		       84 80		      sty	squareToDraw
    606  763c		       20 98 f0 	      jsr	CopySinglePiece	;@0	      ; undraw captured pawn
    607  763f
    608  763f		       a9 90		      lda	#RAMBANK_BANK_EVAL
    609  7641		       85 3e		      sta	SET_BANK_RAM
    610  7643		       85 8b		      sta	savedBank
    611  7645
    612  7645		       a4 87		      ldy	originX12	; taken pawn's square
    613  7647		       20 f5 f5 	      jsr	EnPassantRemovePiece
    614  764a
    615  764a				   .notEnPassant
    616  764a							; }
    617  764a
    618  764a		       60		      rts
    619  764b
    620  764b					      ENDIF
    621  764b
    622  764b
    623  764b							;---------------------------------------------------------------------------------------------------
    624  764b
      0  764b					      CHECK_BANK_SIZE	"TWO"
      1  764b		       02 4b	   .TEMP      =	* - _BANK_START
 TWO (1K) SIZE =  $24b , FREE= $1b5
      2  764b					      ECHO	"TWO", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  764b				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  764b				  -	      ECHO	"BANK OVERFLOW @ ", "TWO", " size=", * - ORIGIN
      5  764b				  -	      ERR
      6  764b					      ENDIF
    626  764b
    627  764b							;---------------------------------------------------------------------------------------------------
    628  764b							;EOF
------- FILE ./chess.asm
------- FILE PIECE_HANDLER@1#1.asm LEVEL 2 PASS 4
      0  764b					      include	"PIECE_HANDLER@1#1.asm"
      0  764b					      SLOT	1
      1  764b				  -	      IF	(1 < 0) || (1 > 3)
      2  764b				  -	      ECHO	"Illegal bank address/segment location", 1
      3  764b				  -	      ERR
      4  764b					      ENDIF
      5  764b				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  764b				   _BANK_SLOT SET	1 * 64
      0  764b					      NEWBANK	PIECE_HANDLER_1
      1  7acc ????				      SEG	PIECE_HANDLER_1
      2  7800					      ORG	_ORIGIN
      3  7800					      RORG	_BANK_ADDRESS_ORIGIN
      4  7800				   _BANK_START SET	*
      5  7800				   PIECE_HANDLER_1_START SET	*
      6  7800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7800				   PIECE_HANDLER_1 SET	_BANK_SLOT + _CURRENT_BANK
      8  7800				   _ORIGIN    SET	_ORIGIN + 1024
      3  7800
------- FILE PIECE_PAWN.asm LEVEL 3 PASS 4
      0  7800					      include	"PIECE_PAWN.asm"
      1  7800							; Copyright (C)2020 Andrew Davie
      2  7800							; Pawn move handlers
      3  7800
      4  7800							;---------------------------------------------------------------------------------------------------
      5  7800							; WHITE PAWN
      6  7800							;---------------------------------------------------------------------------------------------------
      7  7800
      8  7800		       00 28	   WHITE_HOME_ROW =	40	; < this, on home row
      9  7800		       00 52	   BLACK_HOME_ROW =	82	; >= this, on home row
     10  7800
     11  7800							;---------------------------------------------------------------------------------------------------
     12  7800
     13  7800					      MAC	en_passant
     14  7800					      SUBROUTINE
     15  7800							; {1} = _LEFT or _RIGHT
     16  7800
     17  7800					      ldx	currentSquare
     18  7800					      ldy	ValidSquare+{1},x
     19  7800					      cpy	enPassantPawn
     20  7800					      bne	.invalid
     21  7800					      ldy	ValidSquare+{1}+{2},x	; en-passant endpoint must be blank
     22  7800					      lda	Board,y
     23  7800					      bne	.invalid
     24  7800					      jsr	AddMove	; the MOVE will need to deal with the details of en-passant??
     25  7800				   .invalid
     26  7800					      ENDM
     27  7800
     28  7800							;---------------------------------------------------------------------------------------------------
     29  7800
     30  7800					      MAC	promote_pawn
     31  7800							;SUBROUTINE
     32  7800
     33  7800							;{1} = BLACK or WHITE
     34  7800
     35  7800
     36  7800					      sty	__temp
     37  7800					      lda	#{1}|QUEEN
     38  7800					      sta	currentPiece
     39  7800					      jsr	AddMove
     40  7800
     41  7800					      lda	#{1}|ROOK
     42  7800					      sta	currentPiece
     43  7800					      ldy	__temp
     44  7800					      jsr	AddMove
     45  7800
     46  7800					      lda	#{1}|BISHOP
     47  7800					      sta	currentPiece
     48  7800					      ldy	__temp
     49  7800					      jsr	AddMove
     50  7800
     51  7800					      lda	#{1}|KNIGHT
     52  7800					      sta	currentPiece
     53  7800					      ldy	__temp
     54  7800					      jsr	AddMove
     55  7800
     56  7800					      IF	{1} = WHITE
     57  7800					      lda	#WHITE|WP
     58  7800					      ENDIF
     59  7800					      IF	{1} = BLACK
     60  7800					      lda	#BLACK|BP
     61  7800					      ENDIF
     62  7800					      sta	currentPiece
     63  7800					      ENDM
     64  7800
     65  7800							;---------------------------------------------------------------------------------------------------
     66  7800
     67  7800					      MAC	move_or_promote_pawn
     68  7800							;SUBROUTINE
     69  7800							; {1} = BLACK or WHITE
     70  7800
     71  7800					      IF	{1} = WHITE
     72  7800					      cpy	#90	; last rank?
     73  7800					      bcc	.standard
     74  7800					      jsr	PromoteWhitePawn
     75  7800					      jmp	.pMoved
     76  7800					      ENDIF
     77  7800
     78  7800					      IF	{1} = BLACK
     79  7800					      cpy	#30	; last rank?
     80  7800					      bcs	.standard
     81  7800					      jsr	PromoteBlackPawn
     82  7800					      jmp	.pMoved
     83  7800					      ENDIF
     84  7800
     85  7800				   .standard  jsr	AddMove	; add +1UP move
     86  7800				   .pMoved
     87  7800
     88  7800					      ENDM
     89  7800
     90  7800							;---------------------------------------------------------------------------------------------------
     91  7800
     92  7800					      MAC	take
     93  7800							;SUBROUTINE
     94  7800							; {1} = capture square offset
     95  7800
     96  7800					      ldx	currentSquare
     97  7800					      ldy	ValidSquare+{1},x
     98  7800					      bmi	.invalid2
     99  7800					      lda	Board,y
    100  7800					      beq	.invalid2	; square empty
    101  7800					      sta	capture
    102  7800					      eor	currentPiece
    103  7800					      bpl	.invalid	; same colour
    104  7800
    105  7800					      MOVE_OR_PROMOTE_PAWN	{2}
    106  7800
    107  7800					      jmp	.invalid2
    108  7800				   .invalid   inc	protecting
    109  7800				   .invalid2
    110  7800					      ENDM
    111  7800
    112  7800							;---------------------------------------------------------------------------------------------------
    113  7800
      0  7800					      DEF	PromoteWhitePawn
      1  7800				   SLOT_PromoteWhitePawn SET	_BANK_SLOT
      2  7800				   BANK_PromoteWhitePawn SET	SLOT_PromoteWhitePawn + _CURRENT_BANK
      3  7800				   PromoteWhitePawn
      4  7800				   TEMPORARY_VAR SET	Overlay
      5  7800				   TEMPORARY_OFFSET SET	0
      6  7800				   VAR_BOUNDARY_PromoteWhitePawn SET	TEMPORARY_OFFSET
      7  7800				   FUNCTION_NAME SET	PromoteWhitePawn
    115  7800					      SUBROUTINE
    116  7800
      0  7800					      REFER	Handle_WHITE_PAWN
      1  7800					      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  7800				   TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  7800					      ENDIF
      0  7800					      VAR	__temp, 1
      1  7800		       00 b3	   __temp     =	TEMPORARY_VAR
      2  7800				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7800
      4  7800				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7800				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7800				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7800					      ENDIF
      8  7800				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7800				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  7800				  -	      ERR
     11  7800					      ENDIF
     12  7800					      LIST	ON
      0  7800					      VEND	PromoteWhitePawn
      1  7800				  -	      IFNCONST	PromoteWhitePawn
      2  7800				  -	      ECHO	"Incorrect VEND label", PromoteWhitePawn
      3  7800				  -	      ERR
      4  7800					      ENDIF
      5  7800		       00 b4	   VAREND_PromoteWhitePawn =	TEMPORARY_VAR
    120  7800
      0  7800					      PROMOTE_PAWN	WHITE
      1  7800
      2  7800
      3  7800
      4  7800
      5  7800
      6  7800		       84 b3		      sty	__temp
      7  7802		       a9 06		      lda	#WHITE|QUEEN
      8  7804		       85 92		      sta	currentPiece
      9  7806		       20 20 f5 	      jsr	AddMove
     10  7809
     11  7809		       a9 05		      lda	#WHITE|ROOK
     12  780b		       85 92		      sta	currentPiece
     13  780d		       a4 b3		      ldy	__temp
     14  780f		       20 20 f5 	      jsr	AddMove
     15  7812
     16  7812		       a9 04		      lda	#WHITE|BISHOP
     17  7814		       85 92		      sta	currentPiece
     18  7816		       a4 b3		      ldy	__temp
     19  7818		       20 20 f5 	      jsr	AddMove
     20  781b
     21  781b		       a9 03		      lda	#WHITE|KNIGHT
     22  781d		       85 92		      sta	currentPiece
     23  781f		       a4 b3		      ldy	__temp
     24  7821		       20 20 f5 	      jsr	AddMove
     25  7824
     26  7824					      IF	WHITE = WHITE
     27  7824		       a9 01		      lda	#WHITE|WP
     28  7826					      ENDIF
     29  7826				  -	      IF	WHITE = BLACK
     30  7826				  -	      lda	#BLACK|BP
     31  7826					      ENDIF
     32  7826		       85 92		      sta	currentPiece
    122  7828		       60		      rts
    123  7829
    124  7829							;---------------------------------------------------------------------------------------------------
    125  7829
      0  7829					      DEF	Handle_WHITE_PAWN
      1  7829				   SLOT_Handle_WHITE_PAWN SET	_BANK_SLOT
      2  7829				   BANK_Handle_WHITE_PAWN SET	SLOT_Handle_WHITE_PAWN + _CURRENT_BANK
      3  7829				   Handle_WHITE_PAWN
      4  7829				   TEMPORARY_VAR SET	Overlay
      5  7829				   TEMPORARY_OFFSET SET	0
      6  7829				   VAR_BOUNDARY_Handle_WHITE_PAWN SET	TEMPORARY_OFFSET
      7  7829				   FUNCTION_NAME SET	Handle_WHITE_PAWN
    127  7829					      SUBROUTINE
    128  7829
      0  7829					      REFER	GenerateAllMoves
      1  7829					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  7829				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  7829					      ENDIF
      0  7829					      VEND	Handle_WHITE_PAWN
      1  7829				  -	      IFNCONST	Handle_WHITE_PAWN
      2  7829				  -	      ECHO	"Incorrect VEND label", Handle_WHITE_PAWN
      3  7829				  -	      ERR
      4  7829					      ENDIF
      5  7829		       00 b3	   VAREND_Handle_WHITE_PAWN =	TEMPORARY_VAR
    131  7829
    132  7829		       bc 1f fc 	      ldy	ValidSquare+_UP,x	; square above must be blank (WILL NOT EVER be off-board!)
    133  782c		       b9 79 fc 	      lda	Board,y
    134  782f		       d0 26		      bne	.pMoved	; occupied
    135  7831		       85 9e		      sta	capture
    136  7833
    137  7833							; we may need to promote the pawn
    138  7833							; All possibilites (Q/R/B/N) are added as individual moves
    139  7833
      0  7833					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  7833
      2  7833
      3  7833
      4  7833					      IF	WHITE = WHITE
      5  7833		       c0 5a		      cpy	#90
      6  7835		       90 06		      bcc	.standard
      7  7837		       20 00 f4 	      jsr	PromoteWhitePawn
      8  783a		       4c 40 f4 	      jmp	.pMoved
      9  783d					      ENDIF
     10  783d
     11  783d				  -	      IF	WHITE = BLACK
     12  783d				  -	      cpy	#30
     13  783d				  -	      bcs	.standard
     14  783d				  -	      jsr	PromoteBlackPawn
     15  783d				  -	      jmp	.pMoved
     16  783d					      ENDIF
     17  783d
     18  783d		       20 20 f5    .standard  jsr	AddMove
     19  7840				   .pMoved
     20  7840
    141  7840
    142  7840							; the +2 move off the home rank...
    143  7840
    144  7840		       a6 93		      ldx	currentSquare
    145  7842		       e0 28		      cpx	#WHITE_HOME_ROW
    146  7844		       b0 11		      bcs	.pMoved	; pawn has moved so can't do +2
    147  7846		       bc 29 fc 	      ldy	ValidSquare+_UP+_UP,x	; WILL be a valid square
    148  7849		       b9 79 fc 	      lda	Board,y
    149  784c		       d0 09		      bne	.pMoved	; destination square occupied
    150  784e
    151  784e		       a5 92		      lda	currentPiece
    152  7850		       09 20		      ora	#FLAG_ENPASSANT
    153  7852		       85 92		      sta	currentPiece	; GENERATE en-passant opportunity
    154  7854
    155  7854		       20 20 f5 	      jsr	AddMove	; add the +2UP move off home row
    156  7857
    157  7857				   .pMoved
    158  7857
    159  7857							; regular captures...
    160  7857
      0  7857					      TAKE	_UP+_LEFT, WHITE
      1  7857
      2  7857
      3  7857
      4  7857		       a6 93		      ldx	currentSquare
      5  7859		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      6  785c		       30 1d		      bmi	.invalid2
      7  785e		       b9 79 fc 	      lda	Board,y
      8  7861		       f0 18		      beq	.invalid2
      9  7863		       85 9e		      sta	capture
     10  7865		       45 92		      eor	currentPiece
     11  7867		       10 10		      bpl	.invalid
     12  7869
      0  7869					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  7869
      2  7869
      3  7869
      4  7869					      IF	WHITE = WHITE
      5  7869		       c0 5a		      cpy	#90
      6  786b		       90 06		      bcc	.standard
      7  786d		       20 00 f4 	      jsr	PromoteWhitePawn
      8  7870		       4c 76 f4 	      jmp	.pMoved
      9  7873					      ENDIF
     10  7873
     11  7873				  -	      IF	WHITE = BLACK
     12  7873				  -	      cpy	#30
     13  7873				  -	      bcs	.standard
     14  7873				  -	      jsr	PromoteBlackPawn
     15  7873				  -	      jmp	.pMoved
     16  7873					      ENDIF
     17  7873
     18  7873		       20 20 f5    .standard  jsr	AddMove
     19  7876				   .pMoved
     20  7876
     14  7876
     15  7876		       4c 7b f4 	      jmp	.invalid2
     16  7879		       e6 a0	   .invalid   inc	protecting
     17  787b				   .invalid2
      0  787b					      TAKE	_UP+_RIGHT, WHITE
      1  787b
      2  787b
      3  787b
      4  787b		       a6 93		      ldx	currentSquare
      5  787d		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      6  7880		       30 1d		      bmi	.invalid2
      7  7882		       b9 79 fc 	      lda	Board,y
      8  7885		       f0 18		      beq	.invalid2
      9  7887		       85 9e		      sta	capture
     10  7889		       45 92		      eor	currentPiece
     11  788b		       10 10		      bpl	.invalid
     12  788d
      0  788d					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  788d
      2  788d
      3  788d
      4  788d					      IF	WHITE = WHITE
      5  788d		       c0 5a		      cpy	#90
      6  788f		       90 06		      bcc	.standard
      7  7891		       20 00 f4 	      jsr	PromoteWhitePawn
      8  7894		       4c 9a f4 	      jmp	.pMoved
      9  7897					      ENDIF
     10  7897
     11  7897				  -	      IF	WHITE = BLACK
     12  7897				  -	      cpy	#30
     13  7897				  -	      bcs	.standard
     14  7897				  -	      jsr	PromoteBlackPawn
     15  7897				  -	      jmp	.pMoved
     16  7897					      ENDIF
     17  7897
     18  7897		       20 20 f5    .standard  jsr	AddMove
     19  789a				   .pMoved
     20  789a
     14  789a
     15  789a		       4c 9f f4 	      jmp	.invalid2
     16  789d		       e6 a0	   .invalid   inc	protecting
     17  789f				   .invalid2
    163  789f
    164  789f
    165  789f					      IF	ENPASSANT_ENABLED
    166  789f							; en-passant captures...
    167  789f
    168  789f		       a5 94		      lda	enPassantPawn
    169  78a1		       f0 2e		      beq	.noEnPassant	; previous move (opponent) enpassant square?
    170  78a3
    171  78a3		       a5 92		      lda	currentPiece
    172  78a5		       09 20		      ora	#FLAG_ENPASSANT
    173  78a7		       85 92		      sta	currentPiece	; CONSUME en-passant opportunity
    174  78a9
      0  78a9					      EN_PASSANT	_LEFT, _UP
      1  78a9					      SUBROUTINE
      2  78a9
      3  78a9
      4  78a9		       a6 93		      ldx	currentSquare
      5  78ab		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      6  78ae		       c4 94		      cpy	enPassantPawn
      7  78b0		       d0 0b		      bne	.invalid
      8  78b2		       bc 1e fc 	      ldy	ValidSquare+_LEFT+_UP,x
      9  78b5		       b9 79 fc 	      lda	Board,y
     10  78b8		       d0 03		      bne	.invalid
     11  78ba		       20 20 f5 	      jsr	AddMove
     12  78bd				   .invalid
      0  78bd					      EN_PASSANT	_RIGHT, _UP
      1  78bd					      SUBROUTINE
      2  78bd
      3  78bd
      4  78bd		       a6 93		      ldx	currentSquare
      5  78bf		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      6  78c2		       c4 94		      cpy	enPassantPawn
      7  78c4		       d0 0b		      bne	.invalid
      8  78c6		       bc 20 fc 	      ldy	ValidSquare+_RIGHT+_UP,x
      9  78c9		       b9 79 fc 	      lda	Board,y
     10  78cc		       d0 03		      bne	.invalid
     11  78ce		       20 20 f5 	      jsr	AddMove
     12  78d1				   .invalid
    177  78d1
    178  78d1				   .noEnPassant
    179  78d1					      ENDIF
    180  78d1
    181  78d1		       4c 8c f1 	      jmp	MoveReturn
    182  78d4
    183  78d4
    184  78d4							;---------------------------------------------------------------------------------------------------
    185  78d4							; BLACK PAWN
    186  78d4							;---------------------------------------------------------------------------------------------------
    187  78d4
      0  78d4					      DEF	PromoteBlackPawn
      1  78d4				   SLOT_PromoteBlackPawn SET	_BANK_SLOT
      2  78d4				   BANK_PromoteBlackPawn SET	SLOT_PromoteBlackPawn + _CURRENT_BANK
      3  78d4				   PromoteBlackPawn
      4  78d4				   TEMPORARY_VAR SET	Overlay
      5  78d4				   TEMPORARY_OFFSET SET	0
      6  78d4				   VAR_BOUNDARY_PromoteBlackPawn SET	TEMPORARY_OFFSET
      7  78d4				   FUNCTION_NAME SET	PromoteBlackPawn
    189  78d4					      SUBROUTINE
    190  78d4
      0  78d4					      REFER	Handle_BLACK_PAWN
      1  78d4					      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  78d4				   TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  78d4					      ENDIF
      0  78d4					      VAR	__temp, 1
      1  78d4		       00 b3	   __temp     =	TEMPORARY_VAR
      2  78d4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  78d4
      4  78d4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  78d4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  78d4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  78d4					      ENDIF
      8  78d4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  78d4				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  78d4				  -	      ERR
     11  78d4					      ENDIF
     12  78d4					      LIST	ON
      0  78d4					      VEND	PromoteBlackPawn
      1  78d4				  -	      IFNCONST	PromoteBlackPawn
      2  78d4				  -	      ECHO	"Incorrect VEND label", PromoteBlackPawn
      3  78d4				  -	      ERR
      4  78d4					      ENDIF
      5  78d4		       00 b4	   VAREND_PromoteBlackPawn =	TEMPORARY_VAR
    194  78d4
      0  78d4					      PROMOTE_PAWN	BLACK
      1  78d4
      2  78d4
      3  78d4
      4  78d4
      5  78d4
      6  78d4		       84 b3		      sty	__temp
      7  78d6		       a9 86		      lda	#BLACK|QUEEN
      8  78d8		       85 92		      sta	currentPiece
      9  78da		       20 20 f5 	      jsr	AddMove
     10  78dd
     11  78dd		       a9 85		      lda	#BLACK|ROOK
     12  78df		       85 92		      sta	currentPiece
     13  78e1		       a4 b3		      ldy	__temp
     14  78e3		       20 20 f5 	      jsr	AddMove
     15  78e6
     16  78e6		       a9 84		      lda	#BLACK|BISHOP
     17  78e8		       85 92		      sta	currentPiece
     18  78ea		       a4 b3		      ldy	__temp
     19  78ec		       20 20 f5 	      jsr	AddMove
     20  78ef
     21  78ef		       a9 83		      lda	#BLACK|KNIGHT
     22  78f1		       85 92		      sta	currentPiece
     23  78f3		       a4 b3		      ldy	__temp
     24  78f5		       20 20 f5 	      jsr	AddMove
     25  78f8
     26  78f8				  -	      IF	BLACK = WHITE
     27  78f8				  -	      lda	#WHITE|WP
     28  78f8					      ENDIF
     29  78f8					      IF	BLACK = BLACK
     30  78f8		       a9 82		      lda	#BLACK|BP
     31  78fa					      ENDIF
     32  78fa		       85 92		      sta	currentPiece
    196  78fc		       60		      rts
    197  78fd
      0  78fd					      DEF	Handle_BLACK_PAWN
      1  78fd				   SLOT_Handle_BLACK_PAWN SET	_BANK_SLOT
      2  78fd				   BANK_Handle_BLACK_PAWN SET	SLOT_Handle_BLACK_PAWN + _CURRENT_BANK
      3  78fd				   Handle_BLACK_PAWN
      4  78fd				   TEMPORARY_VAR SET	Overlay
      5  78fd				   TEMPORARY_OFFSET SET	0
      6  78fd				   VAR_BOUNDARY_Handle_BLACK_PAWN SET	TEMPORARY_OFFSET
      7  78fd				   FUNCTION_NAME SET	Handle_BLACK_PAWN
    199  78fd					      SUBROUTINE
    200  78fd
      0  78fd					      REFER	GenerateAllMoves
      1  78fd					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  78fd				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  78fd					      ENDIF
      0  78fd					      VEND	Handle_BLACK_PAWN
      1  78fd				  -	      IFNCONST	Handle_BLACK_PAWN
      2  78fd				  -	      ECHO	"Incorrect VEND label", Handle_BLACK_PAWN
      3  78fd				  -	      ERR
      4  78fd					      ENDIF
      5  78fd		       00 b3	   VAREND_Handle_BLACK_PAWN =	TEMPORARY_VAR
    203  78fd
    204  78fd		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x	; square below must be blank (WILL NOT EVER be off-board!)
    205  7900		       b9 79 fc 	      lda	Board,y
    206  7903		       d0 26		      bne	.pMoved	; occupied
    207  7905		       85 9e		      sta	capture
    208  7907
    209  7907							; we may need to promote the pawn
    210  7907							; All possibilites (Q/R/B/N) are added as individual moves
    211  7907
      0  7907					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  7907
      2  7907
      3  7907
      4  7907				  -	      IF	BLACK = WHITE
      5  7907				  -	      cpy	#90
      6  7907				  -	      bcc	.standard
      7  7907				  -	      jsr	PromoteWhitePawn
      8  7907				  -	      jmp	.pMoved
      9  7907					      ENDIF
     10  7907
     11  7907					      IF	BLACK = BLACK
     12  7907		       c0 1e		      cpy	#30
     13  7909		       b0 06		      bcs	.standard
     14  790b		       20 d4 f4 	      jsr	PromoteBlackPawn
     15  790e		       4c 14 f5 	      jmp	.pMoved
     16  7911					      ENDIF
     17  7911
     18  7911		       20 20 f5    .standard  jsr	AddMove
     19  7914				   .pMoved
     20  7914
    213  7914
    214  7914							; the +2 move off the home rank...
    215  7914
    216  7914		       a6 93		      ldx	currentSquare
    217  7916		       e0 52		      cpx	#BLACK_HOME_ROW
    218  7918		       90 11		      bcc	.pMoved	; pawn has moved so can't do +2
    219  791a
    220  791a
    221  791a		       bc 01 fc 	      ldy	ValidSquare+_DOWN+_DOWN,x	; WILL be a valid square
    222  791d		       b9 79 fc 	      lda	Board,y
    223  7920		       d0 09		      bne	.pMoved	; destination square occupied
    224  7922
    225  7922		       a5 92		      lda	currentPiece
    226  7924		       09 20		      ora	#FLAG_ENPASSANT
    227  7926		       85 92		      sta	currentPiece	; CAN en-passant
    228  7928
    229  7928		       20 20 f5 	      jsr	AddMove	; add the +2DOWN move off home row
    230  792b
    231  792b				   .pMoved
    232  792b
    233  792b							; regular captures... (with promotion)
    234  792b
      0  792b					      TAKE	_DOWN+_LEFT, BLACK
      1  792b
      2  792b
      3  792b
      4  792b		       a6 93		      ldx	currentSquare
      5  792d		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      6  7930		       30 1d		      bmi	.invalid2
      7  7932		       b9 79 fc 	      lda	Board,y
      8  7935		       f0 18		      beq	.invalid2
      9  7937		       85 9e		      sta	capture
     10  7939		       45 92		      eor	currentPiece
     11  793b		       10 10		      bpl	.invalid
     12  793d
      0  793d					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  793d
      2  793d
      3  793d
      4  793d				  -	      IF	BLACK = WHITE
      5  793d				  -	      cpy	#90
      6  793d				  -	      bcc	.standard
      7  793d				  -	      jsr	PromoteWhitePawn
      8  793d				  -	      jmp	.pMoved
      9  793d					      ENDIF
     10  793d
     11  793d					      IF	BLACK = BLACK
     12  793d		       c0 1e		      cpy	#30
     13  793f		       b0 06		      bcs	.standard
     14  7941		       20 d4 f4 	      jsr	PromoteBlackPawn
     15  7944		       4c 4a f5 	      jmp	.pMoved
     16  7947					      ENDIF
     17  7947
     18  7947		       20 20 f5    .standard  jsr	AddMove
     19  794a				   .pMoved
     20  794a
     14  794a
     15  794a		       4c 4f f5 	      jmp	.invalid2
     16  794d		       e6 a0	   .invalid   inc	protecting
     17  794f				   .invalid2
      0  794f					      TAKE	_DOWN+_RIGHT, BLACK
      1  794f
      2  794f
      3  794f
      4  794f		       a6 93		      ldx	currentSquare
      5  7951		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      6  7954		       30 1d		      bmi	.invalid2
      7  7956		       b9 79 fc 	      lda	Board,y
      8  7959		       f0 18		      beq	.invalid2
      9  795b		       85 9e		      sta	capture
     10  795d		       45 92		      eor	currentPiece
     11  795f		       10 10		      bpl	.invalid
     12  7961
      0  7961					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  7961
      2  7961
      3  7961
      4  7961				  -	      IF	BLACK = WHITE
      5  7961				  -	      cpy	#90
      6  7961				  -	      bcc	.standard
      7  7961				  -	      jsr	PromoteWhitePawn
      8  7961				  -	      jmp	.pMoved
      9  7961					      ENDIF
     10  7961
     11  7961					      IF	BLACK = BLACK
     12  7961		       c0 1e		      cpy	#30
     13  7963		       b0 06		      bcs	.standard
     14  7965		       20 d4 f4 	      jsr	PromoteBlackPawn
     15  7968		       4c 6e f5 	      jmp	.pMoved
     16  796b					      ENDIF
     17  796b
     18  796b		       20 20 f5    .standard  jsr	AddMove
     19  796e				   .pMoved
     20  796e
     14  796e
     15  796e		       4c 73 f5 	      jmp	.invalid2
     16  7971		       e6 a0	   .invalid   inc	protecting
     17  7973				   .invalid2
    237  7973
    238  7973
    239  7973					      IF	ENPASSANT_ENABLED
    240  7973							; en-passant captures...
    241  7973
    242  7973		       a5 94		      lda	enPassantPawn
    243  7975		       f0 2e		      beq	.noEnPassant	; was last move en-passantable?
    244  7977
    245  7977		       a5 92		      lda	currentPiece
    246  7979		       09 20		      ora	#FLAG_ENPASSANT
    247  797b		       85 92		      sta	currentPiece	; any en-passant move added will have flag set
    248  797d
      0  797d					      EN_PASSANT	_LEFT, _DOWN
      1  797d					      SUBROUTINE
      2  797d
      3  797d
      4  797d		       a6 93		      ldx	currentSquare
      5  797f		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      6  7982		       c4 94		      cpy	enPassantPawn
      7  7984		       d0 0b		      bne	.invalid
      8  7986		       bc 0a fc 	      ldy	ValidSquare+_LEFT+_DOWN,x
      9  7989		       b9 79 fc 	      lda	Board,y
     10  798c		       d0 03		      bne	.invalid
     11  798e		       20 20 f5 	      jsr	AddMove
     12  7991				   .invalid
      0  7991					      EN_PASSANT	_RIGHT, _DOWN
      1  7991					      SUBROUTINE
      2  7991
      3  7991
      4  7991		       a6 93		      ldx	currentSquare
      5  7993		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      6  7996		       c4 94		      cpy	enPassantPawn
      7  7998		       d0 0b		      bne	.invalid
      8  799a		       bc 0c fc 	      ldy	ValidSquare+_RIGHT+_DOWN,x
      9  799d		       b9 79 fc 	      lda	Board,y
     10  79a0		       d0 03		      bne	.invalid
     11  79a2		       20 20 f5 	      jsr	AddMove
     12  79a5				   .invalid
    251  79a5
    252  79a5				   .noEnPassant
    253  79a5					      ENDIF
    254  79a5
    255  79a5		       4c 8c f1 	      jmp	MoveReturn
    256  79a8
    257  79a8							; EOF
------- FILE PIECE_HANDLER@1#1.asm
------- FILE PIECE_KNIGHT.asm LEVEL 3 PASS 4
      0  79a8					      include	"PIECE_KNIGHT.asm"
      1  79a8							; Copyright (C)2020 Andrew Davie
      2  79a8							; Knight move handler
      3  79a8
      4  79a8							;---------------------------------------------------------------------------------------------------
      5  79a8							; KNIGHT
      6  79a8							;---------------------------------------------------------------------------------------------------
      7  79a8
      0  79a8					      DEF	Handle_KNIGHT
      1  79a8				   SLOT_Handle_KNIGHT SET	_BANK_SLOT
      2  79a8				   BANK_Handle_KNIGHT SET	SLOT_Handle_KNIGHT + _CURRENT_BANK
      3  79a8				   Handle_KNIGHT
      4  79a8				   TEMPORARY_VAR SET	Overlay
      5  79a8				   TEMPORARY_OFFSET SET	0
      6  79a8				   VAR_BOUNDARY_Handle_KNIGHT SET	TEMPORARY_OFFSET
      7  79a8				   FUNCTION_NAME SET	Handle_KNIGHT
      9  79a8					      SUBROUTINE
     10  79a8
      0  79a8					      REFER	GenerateAllMoves
      1  79a8					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  79a8				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  79a8					      ENDIF
      0  79a8					      VEND	Handle_KNIGHT
      1  79a8				  -	      IFNCONST	Handle_KNIGHT
      2  79a8				  -	      ECHO	"Incorrect VEND label", Handle_KNIGHT
      3  79a8				  -	      ERR
      4  79a8					      ENDIF
      5  79a8		       00 b3	   VAREND_Handle_KNIGHT =	TEMPORARY_VAR
     13  79a8
     14  79a8							; x = currentSquare (square the piece is on)
     15  79a8							; currentPiece (with flags/colour attached)
     16  79a8
      0  79a8					      MOVE_TO	_DOWN+_DOWN+_LEFT
      1  79a8					      SUBROUTINE
      2  79a8		       bc 00 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_LEFT,x
      3  79ab		       30 0e		      bmi	.invalid
      4  79ad		       b9 79 fc 	      lda	Board,y
      5  79b0		       85 9e		      sta	capture
      6  79b2		       f0 04		      beq	.squareEmpty
      7  79b4		       45 92		      eor	currentPiece
      8  79b6		       10 03		      bpl	.invalid
      9  79b8		       20 20 f5    .squareEmpty jsr	AddMove
     10  79bb				   .invalid
      0  79bb					      MOVE_TO_X	_DOWN+_DOWN+_RIGHT
      1  79bb		       a6 93		      ldx	currentSquare
      0  79bd					      MOVE_TO	_DOWN+_DOWN+_RIGHT
      1  79bd					      SUBROUTINE
      2  79bd		       bc 02 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_RIGHT,x
      3  79c0		       30 0e		      bmi	.invalid
      4  79c2		       b9 79 fc 	      lda	Board,y
      5  79c5		       85 9e		      sta	capture
      6  79c7		       f0 04		      beq	.squareEmpty
      7  79c9		       45 92		      eor	currentPiece
      8  79cb		       10 03		      bpl	.invalid
      9  79cd		       20 20 f5    .squareEmpty jsr	AddMove
     10  79d0				   .invalid
      0  79d0					      MOVE_TO_X	_UP+_UP+_LEFT
      1  79d0		       a6 93		      ldx	currentSquare
      0  79d2					      MOVE_TO	_UP+_UP+_LEFT
      1  79d2					      SUBROUTINE
      2  79d2		       bc 28 fc 	      ldy	ValidSquare+_UP+_UP+_LEFT,x
      3  79d5		       30 0e		      bmi	.invalid
      4  79d7		       b9 79 fc 	      lda	Board,y
      5  79da		       85 9e		      sta	capture
      6  79dc		       f0 04		      beq	.squareEmpty
      7  79de		       45 92		      eor	currentPiece
      8  79e0		       10 03		      bpl	.invalid
      9  79e2		       20 20 f5    .squareEmpty jsr	AddMove
     10  79e5				   .invalid
      0  79e5					      MOVE_TO_X	_UP+_UP+_RIGHT
      1  79e5		       a6 93		      ldx	currentSquare
      0  79e7					      MOVE_TO	_UP+_UP+_RIGHT
      1  79e7					      SUBROUTINE
      2  79e7		       bc 2a fc 	      ldy	ValidSquare+_UP+_UP+_RIGHT,x
      3  79ea		       30 0e		      bmi	.invalid
      4  79ec		       b9 79 fc 	      lda	Board,y
      5  79ef		       85 9e		      sta	capture
      6  79f1		       f0 04		      beq	.squareEmpty
      7  79f3		       45 92		      eor	currentPiece
      8  79f5		       10 03		      bpl	.invalid
      9  79f7		       20 20 f5    .squareEmpty jsr	AddMove
     10  79fa				   .invalid
     21  79fa
      0  79fa					      MOVE_TO_X	_DOWN+_LEFT+_LEFT
      1  79fa		       a6 93		      ldx	currentSquare
      0  79fc					      MOVE_TO	_DOWN+_LEFT+_LEFT
      1  79fc					      SUBROUTINE
      2  79fc		       bc 09 fc 	      ldy	ValidSquare+_DOWN+_LEFT+_LEFT,x
      3  79ff		       30 0e		      bmi	.invalid
      4  7a01		       b9 79 fc 	      lda	Board,y
      5  7a04		       85 9e		      sta	capture
      6  7a06		       f0 04		      beq	.squareEmpty
      7  7a08		       45 92		      eor	currentPiece
      8  7a0a		       10 03		      bpl	.invalid
      9  7a0c		       20 20 f5    .squareEmpty jsr	AddMove
     10  7a0f				   .invalid
      0  7a0f					      MOVE_TO_X	_DOWN+_RIGHT+_RIGHT
      1  7a0f		       a6 93		      ldx	currentSquare
      0  7a11					      MOVE_TO	_DOWN+_RIGHT+_RIGHT
      1  7a11					      SUBROUTINE
      2  7a11		       bc 0d fc 	      ldy	ValidSquare+_DOWN+_RIGHT+_RIGHT,x
      3  7a14		       30 0e		      bmi	.invalid
      4  7a16		       b9 79 fc 	      lda	Board,y
      5  7a19		       85 9e		      sta	capture
      6  7a1b		       f0 04		      beq	.squareEmpty
      7  7a1d		       45 92		      eor	currentPiece
      8  7a1f		       10 03		      bpl	.invalid
      9  7a21		       20 20 f5    .squareEmpty jsr	AddMove
     10  7a24				   .invalid
      0  7a24					      MOVE_TO_X	_UP+_LEFT+_LEFT
      1  7a24		       a6 93		      ldx	currentSquare
      0  7a26					      MOVE_TO	_UP+_LEFT+_LEFT
      1  7a26					      SUBROUTINE
      2  7a26		       bc 1d fc 	      ldy	ValidSquare+_UP+_LEFT+_LEFT,x
      3  7a29		       30 0e		      bmi	.invalid
      4  7a2b		       b9 79 fc 	      lda	Board,y
      5  7a2e		       85 9e		      sta	capture
      6  7a30		       f0 04		      beq	.squareEmpty
      7  7a32		       45 92		      eor	currentPiece
      8  7a34		       10 03		      bpl	.invalid
      9  7a36		       20 20 f5    .squareEmpty jsr	AddMove
     10  7a39				   .invalid
      0  7a39					      MOVE_TO_X	_UP+_RIGHT+_RIGHT
      1  7a39		       a6 93		      ldx	currentSquare
      0  7a3b					      MOVE_TO	_UP+_RIGHT+_RIGHT
      1  7a3b					      SUBROUTINE
      2  7a3b		       bc 21 fc 	      ldy	ValidSquare+_UP+_RIGHT+_RIGHT,x
      3  7a3e		       30 0e		      bmi	.invalid
      4  7a40		       b9 79 fc 	      lda	Board,y
      5  7a43		       85 9e		      sta	capture
      6  7a45		       f0 04		      beq	.squareEmpty
      7  7a47		       45 92		      eor	currentPiece
      8  7a49		       10 03		      bpl	.invalid
      9  7a4b		       20 20 f5    .squareEmpty jsr	AddMove
     10  7a4e				   .invalid
     26  7a4e
     27  7a4e		       4c 8c f1 	      jmp	MoveReturn
     28  7a51
     29  7a51							; EOF
------- FILE PIECE_HANDLER@1#1.asm
------- FILE PIECE_BISHOP.asm LEVEL 3 PASS 4
      0  7a51					      include	"PIECE_BISHOP.asm"
      1  7a51							; Copyright (C)2020 Andrew Davie
      2  7a51
      3  7a51							;---------------------------------------------------------------------------------------------------
      4  7a51							; BISHOP
      5  7a51							;---------------------------------------------------------------------------------------------------
      6  7a51
      0  7a51					      DEF	Handle_BISHOP
      1  7a51				   SLOT_Handle_BISHOP SET	_BANK_SLOT
      2  7a51				   BANK_Handle_BISHOP SET	SLOT_Handle_BISHOP + _CURRENT_BANK
      3  7a51				   Handle_BISHOP
      4  7a51				   TEMPORARY_VAR SET	Overlay
      5  7a51				   TEMPORARY_OFFSET SET	0
      6  7a51				   VAR_BOUNDARY_Handle_BISHOP SET	TEMPORARY_OFFSET
      7  7a51				   FUNCTION_NAME SET	Handle_BISHOP
      8  7a51					      SUBROUTINE
      9  7a51
      0  7a51					      REFER	GenerateAllMoves
      1  7a51					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  7a51				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  7a51					      ENDIF
      0  7a51					      VEND	Handle_BISHOP
      1  7a51				  -	      IFNCONST	Handle_BISHOP
      2  7a51				  -	      ECHO	"Incorrect VEND label", Handle_BISHOP
      3  7a51				  -	      ERR
      4  7a51					      ENDIF
      5  7a51		       00 b3	   VAREND_Handle_BISHOP =	TEMPORARY_VAR
     12  7a51
     13  7a51							; x = currentSquare (square the piece is on)
     14  7a51							; currentPiece (with flags/colour attached)
     15  7a51
      0  7a51					      MOVE_TOWARDS	_DOWN+_LEFT
      1  7a51					      SUBROUTINE
      2  7a51
      3  7a51
      4  7a51
      5  7a51		       a9 00		      lda	#0
      6  7a53		       85 9e		      sta	capture
      7  7a55
      8  7a55		       a6 93		      ldx	currentSquare
      9  7a57		       d0 03		      bne	.project
     10  7a59
     11  7a59		       20 f9 f4    .empty     jsr	AddMoveSlider
     12  7a5c		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  7a5f		       30 0e		      bmi	.invalid
     14  7a61		       b9 79 fc 	      lda	Board,y
     15  7a64		       f0 f3		      beq	.empty
     16  7a66		       85 9e		      sta	capture
     17  7a68		       45 92		      eor	currentPiece
     18  7a6a		       10 03		      bpl	.invalid
     19  7a6c		       20 20 f5 	      jsr	AddMove
     20  7a6f
     21  7a6f				   .invalid
      0  7a6f					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  7a6f					      SUBROUTINE
      2  7a6f
      3  7a6f
      4  7a6f
      5  7a6f		       a9 00		      lda	#0
      6  7a71		       85 9e		      sta	capture
      7  7a73
      8  7a73		       a6 93		      ldx	currentSquare
      9  7a75		       d0 03		      bne	.project
     10  7a77
     11  7a77		       20 f9 f4    .empty     jsr	AddMoveSlider
     12  7a7a		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  7a7d		       30 0e		      bmi	.invalid
     14  7a7f		       b9 79 fc 	      lda	Board,y
     15  7a82		       f0 f3		      beq	.empty
     16  7a84		       85 9e		      sta	capture
     17  7a86		       45 92		      eor	currentPiece
     18  7a88		       10 03		      bpl	.invalid
     19  7a8a		       20 20 f5 	      jsr	AddMove
     20  7a8d
     21  7a8d				   .invalid
      0  7a8d					      MOVE_TOWARDS	_UP+_LEFT
      1  7a8d					      SUBROUTINE
      2  7a8d
      3  7a8d
      4  7a8d
      5  7a8d		       a9 00		      lda	#0
      6  7a8f		       85 9e		      sta	capture
      7  7a91
      8  7a91		       a6 93		      ldx	currentSquare
      9  7a93		       d0 03		      bne	.project
     10  7a95
     11  7a95		       20 f9 f4    .empty     jsr	AddMoveSlider
     12  7a98		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  7a9b		       30 0e		      bmi	.invalid
     14  7a9d		       b9 79 fc 	      lda	Board,y
     15  7aa0		       f0 f3		      beq	.empty
     16  7aa2		       85 9e		      sta	capture
     17  7aa4		       45 92		      eor	currentPiece
     18  7aa6		       10 03		      bpl	.invalid
     19  7aa8		       20 20 f5 	      jsr	AddMove
     20  7aab
     21  7aab				   .invalid
      0  7aab					      MOVE_TOWARDS	_UP+_RIGHT
      1  7aab					      SUBROUTINE
      2  7aab
      3  7aab
      4  7aab
      5  7aab		       a9 00		      lda	#0
      6  7aad		       85 9e		      sta	capture
      7  7aaf
      8  7aaf		       a6 93		      ldx	currentSquare
      9  7ab1		       d0 03		      bne	.project
     10  7ab3
     11  7ab3		       20 f9 f4    .empty     jsr	AddMoveSlider
     12  7ab6		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  7ab9		       30 0e		      bmi	.invalid
     14  7abb		       b9 79 fc 	      lda	Board,y
     15  7abe		       f0 f3		      beq	.empty
     16  7ac0		       85 9e		      sta	capture
     17  7ac2		       45 92		      eor	currentPiece
     18  7ac4		       10 03		      bpl	.invalid
     19  7ac6		       20 20 f5 	      jsr	AddMove
     20  7ac9
     21  7ac9				   .invalid
     20  7ac9
     21  7ac9		       4c 8c f1 	      jmp	MoveReturn
     22  7acc
     23  7acc							;---------------------------------------------------------------------------------------------------
     24  7acc							; EOF
------- FILE PIECE_HANDLER@1#1.asm
      7  7acc
      8  7acc							;---------------------------------------------------------------------------------------------------
      9  7acc
      0  7acc					      CHECK_BANK_SIZE	"PIECE_HANDLER_1"
      1  7acc		       02 cc	   .TEMP      =	* - _BANK_START
 PIECE_HANDLER_1 (1K) SIZE =  $2cc , FREE= $134
      2  7acc					      ECHO	"PIECE_HANDLER_1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  7acc				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  7acc				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_HANDLER_1", " size=", * - ORIGIN
      5  7acc				  -	      ERR
      6  7acc					      ENDIF
     11  7acc
     12  7acc							;---------------------------------------------------------------------------------------------------
     13  7acc							; EOF
------- FILE ./chess.asm
------- FILE PIECE_HANDLER@1#2.asm LEVEL 2 PASS 4
      0  7acc					      include	"PIECE_HANDLER@1#2.asm"
      0  7acc					      SLOT	1
      1  7acc				  -	      IF	(1 < 0) || (1 > 3)
      2  7acc				  -	      ECHO	"Illegal bank address/segment location", 1
      3  7acc				  -	      ERR
      4  7acc					      ENDIF
      5  7acc				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  7acc				   _BANK_SLOT SET	1 * 64
      0  7acc					      NEWBANK	PIECE_HANDLER_2
      1  7e5c ????				      SEG	PIECE_HANDLER_2
      2  7c00					      ORG	_ORIGIN
      3  7c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  7c00				   _BANK_START SET	*
      5  7c00				   PIECE_HANDLER_2_START SET	*
      6  7c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7c00				   PIECE_HANDLER_2 SET	_BANK_SLOT + _CURRENT_BANK
      8  7c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  7c00
------- FILE PIECE_ROOK.asm LEVEL 3 PASS 4
      0  7c00					      include	"PIECE_ROOK.asm"
      1  7c00							; Copyright (C)2020 Andrew Davie
      2  7c00							; Rook move handler
      3  7c00
      4  7c00							;---------------------------------------------------------------------------------------------------
      5  7c00							; ROOK
      6  7c00							;---------------------------------------------------------------------------------------------------
      7  7c00
      0  7c00					      DEF	Handle_ROOK
      1  7c00				   SLOT_Handle_ROOK SET	_BANK_SLOT
      2  7c00				   BANK_Handle_ROOK SET	SLOT_Handle_ROOK + _CURRENT_BANK
      3  7c00				   Handle_ROOK
      4  7c00				   TEMPORARY_VAR SET	Overlay
      5  7c00				   TEMPORARY_OFFSET SET	0
      6  7c00				   VAR_BOUNDARY_Handle_ROOK SET	TEMPORARY_OFFSET
      7  7c00				   FUNCTION_NAME SET	Handle_ROOK
      9  7c00					      SUBROUTINE
     10  7c00
      0  7c00					      REFER	GenerateAllMoves
      1  7c00					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  7c00				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  7c00					      ENDIF
      0  7c00					      VEND	Handle_ROOK
      1  7c00				  -	      IFNCONST	Handle_ROOK
      2  7c00				  -	      ECHO	"Incorrect VEND label", Handle_ROOK
      3  7c00				  -	      ERR
      4  7c00					      ENDIF
      5  7c00		       00 b3	   VAREND_Handle_ROOK =	TEMPORARY_VAR
     13  7c00
     14  7c00							; Pass...
     15  7c00							; x = currentSquare (square the piece is on)
     16  7c00							; currentPiece (with flags/colour attached)
     17  7c00
      0  7c00					      MOVE_TOWARDS	_DOWN
      1  7c00					      SUBROUTINE
      2  7c00
      3  7c00
      4  7c00
      5  7c00		       a9 00		      lda	#0
      6  7c02		       85 9e		      sta	capture
      7  7c04
      8  7c04		       a6 93		      ldx	currentSquare
      9  7c06		       d0 03		      bne	.project
     10  7c08
     11  7c08		       20 f9 f4    .empty     jsr	AddMoveSlider
     12  7c0b		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  7c0e		       30 0e		      bmi	.invalid
     14  7c10		       b9 79 fc 	      lda	Board,y
     15  7c13		       f0 f3		      beq	.empty
     16  7c15		       85 9e		      sta	capture
     17  7c17		       45 92		      eor	currentPiece
     18  7c19		       10 03		      bpl	.invalid
     19  7c1b		       20 20 f5 	      jsr	AddMove
     20  7c1e
     21  7c1e				   .invalid
      0  7c1e					      MOVE_TOWARDS	_RIGHT
      1  7c1e					      SUBROUTINE
      2  7c1e
      3  7c1e
      4  7c1e
      5  7c1e		       a9 00		      lda	#0
      6  7c20		       85 9e		      sta	capture
      7  7c22
      8  7c22		       a6 93		      ldx	currentSquare
      9  7c24		       d0 03		      bne	.project
     10  7c26
     11  7c26		       20 f9 f4    .empty     jsr	AddMoveSlider
     12  7c29		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  7c2c		       30 0e		      bmi	.invalid
     14  7c2e		       b9 79 fc 	      lda	Board,y
     15  7c31		       f0 f3		      beq	.empty
     16  7c33		       85 9e		      sta	capture
     17  7c35		       45 92		      eor	currentPiece
     18  7c37		       10 03		      bpl	.invalid
     19  7c39		       20 20 f5 	      jsr	AddMove
     20  7c3c
     21  7c3c				   .invalid
      0  7c3c					      MOVE_TOWARDS	_UP
      1  7c3c					      SUBROUTINE
      2  7c3c
      3  7c3c
      4  7c3c
      5  7c3c		       a9 00		      lda	#0
      6  7c3e		       85 9e		      sta	capture
      7  7c40
      8  7c40		       a6 93		      ldx	currentSquare
      9  7c42		       d0 03		      bne	.project
     10  7c44
     11  7c44		       20 f9 f4    .empty     jsr	AddMoveSlider
     12  7c47		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  7c4a		       30 0e		      bmi	.invalid
     14  7c4c		       b9 79 fc 	      lda	Board,y
     15  7c4f		       f0 f3		      beq	.empty
     16  7c51		       85 9e		      sta	capture
     17  7c53		       45 92		      eor	currentPiece
     18  7c55		       10 03		      bpl	.invalid
     19  7c57		       20 20 f5 	      jsr	AddMove
     20  7c5a
     21  7c5a				   .invalid
      0  7c5a					      MOVE_TOWARDS	_LEFT
      1  7c5a					      SUBROUTINE
      2  7c5a
      3  7c5a
      4  7c5a
      5  7c5a		       a9 00		      lda	#0
      6  7c5c		       85 9e		      sta	capture
      7  7c5e
      8  7c5e		       a6 93		      ldx	currentSquare
      9  7c60		       d0 03		      bne	.project
     10  7c62
     11  7c62		       20 f9 f4    .empty     jsr	AddMoveSlider
     12  7c65		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  7c68		       30 0e		      bmi	.invalid
     14  7c6a		       b9 79 fc 	      lda	Board,y
     15  7c6d		       f0 f3		      beq	.empty
     16  7c6f		       85 9e		      sta	capture
     17  7c71		       45 92		      eor	currentPiece
     18  7c73		       10 03		      bpl	.invalid
     19  7c75		       20 20 f5 	      jsr	AddMove
     20  7c78
     21  7c78				   .invalid
     22  7c78
     23  7c78		       4c 8c f1 	      jmp	MoveReturn
     24  7c7b
     25  7c7b							;---------------------------------------------------------------------------------------------------
     26  7c7b							; EOF
------- FILE PIECE_HANDLER@1#2.asm
------- FILE PIECE_QUEEN.asm LEVEL 3 PASS 4
      0  7c7b					      include	"PIECE_QUEEN.asm"
      1  7c7b							; Copyright (C)2020 Andrew Davie
      2  7c7b
      3  7c7b							;---------------------------------------------------------------------------------------------------
      4  7c7b							; QUEEN
      5  7c7b							;---------------------------------------------------------------------------------------------------
      6  7c7b
      0  7c7b					      DEF	Handle_QUEEN
      1  7c7b				   SLOT_Handle_QUEEN SET	_BANK_SLOT
      2  7c7b				   BANK_Handle_QUEEN SET	SLOT_Handle_QUEEN + _CURRENT_BANK
      3  7c7b				   Handle_QUEEN
      4  7c7b				   TEMPORARY_VAR SET	Overlay
      5  7c7b				   TEMPORARY_OFFSET SET	0
      6  7c7b				   VAR_BOUNDARY_Handle_QUEEN SET	TEMPORARY_OFFSET
      7  7c7b				   FUNCTION_NAME SET	Handle_QUEEN
      8  7c7b					      SUBROUTINE
      9  7c7b
      0  7c7b					      REFER	GenerateAllMoves
      1  7c7b					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  7c7b				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  7c7b					      ENDIF
      0  7c7b					      VEND	Handle_QUEEN
      1  7c7b				  -	      IFNCONST	Handle_QUEEN
      2  7c7b				  -	      ECHO	"Incorrect VEND label", Handle_QUEEN
      3  7c7b				  -	      ERR
      4  7c7b					      ENDIF
      5  7c7b		       00 b3	   VAREND_Handle_QUEEN =	TEMPORARY_VAR
     12  7c7b
     13  7c7b							; Pass...
     14  7c7b							; x = currentSquare (square the piece is on)
     15  7c7b							; currentPiece (with flags/colour attached)
     16  7c7b
      0  7c7b					      MOVE_TOWARDS	_DOWN+_LEFT
      1  7c7b					      SUBROUTINE
      2  7c7b
      3  7c7b
      4  7c7b
      5  7c7b		       a9 00		      lda	#0
      6  7c7d		       85 9e		      sta	capture
      7  7c7f
      8  7c7f		       a6 93		      ldx	currentSquare
      9  7c81		       d0 03		      bne	.project
     10  7c83
     11  7c83		       20 f9 f4    .empty     jsr	AddMoveSlider
     12  7c86		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  7c89		       30 0e		      bmi	.invalid
     14  7c8b		       b9 79 fc 	      lda	Board,y
     15  7c8e		       f0 f3		      beq	.empty
     16  7c90		       85 9e		      sta	capture
     17  7c92		       45 92		      eor	currentPiece
     18  7c94		       10 03		      bpl	.invalid
     19  7c96		       20 20 f5 	      jsr	AddMove
     20  7c99
     21  7c99				   .invalid
      0  7c99					      MOVE_TOWARDS	_DOWN
      1  7c99					      SUBROUTINE
      2  7c99
      3  7c99
      4  7c99
      5  7c99		       a9 00		      lda	#0
      6  7c9b		       85 9e		      sta	capture
      7  7c9d
      8  7c9d		       a6 93		      ldx	currentSquare
      9  7c9f		       d0 03		      bne	.project
     10  7ca1
     11  7ca1		       20 f9 f4    .empty     jsr	AddMoveSlider
     12  7ca4		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  7ca7		       30 0e		      bmi	.invalid
     14  7ca9		       b9 79 fc 	      lda	Board,y
     15  7cac		       f0 f3		      beq	.empty
     16  7cae		       85 9e		      sta	capture
     17  7cb0		       45 92		      eor	currentPiece
     18  7cb2		       10 03		      bpl	.invalid
     19  7cb4		       20 20 f5 	      jsr	AddMove
     20  7cb7
     21  7cb7				   .invalid
      0  7cb7					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  7cb7					      SUBROUTINE
      2  7cb7
      3  7cb7
      4  7cb7
      5  7cb7		       a9 00		      lda	#0
      6  7cb9		       85 9e		      sta	capture
      7  7cbb
      8  7cbb		       a6 93		      ldx	currentSquare
      9  7cbd		       d0 03		      bne	.project
     10  7cbf
     11  7cbf		       20 f9 f4    .empty     jsr	AddMoveSlider
     12  7cc2		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  7cc5		       30 0e		      bmi	.invalid
     14  7cc7		       b9 79 fc 	      lda	Board,y
     15  7cca		       f0 f3		      beq	.empty
     16  7ccc		       85 9e		      sta	capture
     17  7cce		       45 92		      eor	currentPiece
     18  7cd0		       10 03		      bpl	.invalid
     19  7cd2		       20 20 f5 	      jsr	AddMove
     20  7cd5
     21  7cd5				   .invalid
      0  7cd5					      MOVE_TOWARDS	_RIGHT
      1  7cd5					      SUBROUTINE
      2  7cd5
      3  7cd5
      4  7cd5
      5  7cd5		       a9 00		      lda	#0
      6  7cd7		       85 9e		      sta	capture
      7  7cd9
      8  7cd9		       a6 93		      ldx	currentSquare
      9  7cdb		       d0 03		      bne	.project
     10  7cdd
     11  7cdd		       20 f9 f4    .empty     jsr	AddMoveSlider
     12  7ce0		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  7ce3		       30 0e		      bmi	.invalid
     14  7ce5		       b9 79 fc 	      lda	Board,y
     15  7ce8		       f0 f3		      beq	.empty
     16  7cea		       85 9e		      sta	capture
     17  7cec		       45 92		      eor	currentPiece
     18  7cee		       10 03		      bpl	.invalid
     19  7cf0		       20 20 f5 	      jsr	AddMove
     20  7cf3
     21  7cf3				   .invalid
      0  7cf3					      MOVE_TOWARDS	_UP+_RIGHT
      1  7cf3					      SUBROUTINE
      2  7cf3
      3  7cf3
      4  7cf3
      5  7cf3		       a9 00		      lda	#0
      6  7cf5		       85 9e		      sta	capture
      7  7cf7
      8  7cf7		       a6 93		      ldx	currentSquare
      9  7cf9		       d0 03		      bne	.project
     10  7cfb
     11  7cfb		       20 f9 f4    .empty     jsr	AddMoveSlider
     12  7cfe		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  7d01		       30 0e		      bmi	.invalid
     14  7d03		       b9 79 fc 	      lda	Board,y
     15  7d06		       f0 f3		      beq	.empty
     16  7d08		       85 9e		      sta	capture
     17  7d0a		       45 92		      eor	currentPiece
     18  7d0c		       10 03		      bpl	.invalid
     19  7d0e		       20 20 f5 	      jsr	AddMove
     20  7d11
     21  7d11				   .invalid
      0  7d11					      MOVE_TOWARDS	_UP
      1  7d11					      SUBROUTINE
      2  7d11
      3  7d11
      4  7d11
      5  7d11		       a9 00		      lda	#0
      6  7d13		       85 9e		      sta	capture
      7  7d15
      8  7d15		       a6 93		      ldx	currentSquare
      9  7d17		       d0 03		      bne	.project
     10  7d19
     11  7d19		       20 f9 f4    .empty     jsr	AddMoveSlider
     12  7d1c		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  7d1f		       30 0e		      bmi	.invalid
     14  7d21		       b9 79 fc 	      lda	Board,y
     15  7d24		       f0 f3		      beq	.empty
     16  7d26		       85 9e		      sta	capture
     17  7d28		       45 92		      eor	currentPiece
     18  7d2a		       10 03		      bpl	.invalid
     19  7d2c		       20 20 f5 	      jsr	AddMove
     20  7d2f
     21  7d2f				   .invalid
      0  7d2f					      MOVE_TOWARDS	_UP+_LEFT
      1  7d2f					      SUBROUTINE
      2  7d2f
      3  7d2f
      4  7d2f
      5  7d2f		       a9 00		      lda	#0
      6  7d31		       85 9e		      sta	capture
      7  7d33
      8  7d33		       a6 93		      ldx	currentSquare
      9  7d35		       d0 03		      bne	.project
     10  7d37
     11  7d37		       20 f9 f4    .empty     jsr	AddMoveSlider
     12  7d3a		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  7d3d		       30 0e		      bmi	.invalid
     14  7d3f		       b9 79 fc 	      lda	Board,y
     15  7d42		       f0 f3		      beq	.empty
     16  7d44		       85 9e		      sta	capture
     17  7d46		       45 92		      eor	currentPiece
     18  7d48		       10 03		      bpl	.invalid
     19  7d4a		       20 20 f5 	      jsr	AddMove
     20  7d4d
     21  7d4d				   .invalid
      0  7d4d					      MOVE_TOWARDS	_LEFT
      1  7d4d					      SUBROUTINE
      2  7d4d
      3  7d4d
      4  7d4d
      5  7d4d		       a9 00		      lda	#0
      6  7d4f		       85 9e		      sta	capture
      7  7d51
      8  7d51		       a6 93		      ldx	currentSquare
      9  7d53		       d0 03		      bne	.project
     10  7d55
     11  7d55		       20 f9 f4    .empty     jsr	AddMoveSlider
     12  7d58		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  7d5b		       30 0e		      bmi	.invalid
     14  7d5d		       b9 79 fc 	      lda	Board,y
     15  7d60		       f0 f3		      beq	.empty
     16  7d62		       85 9e		      sta	capture
     17  7d64		       45 92		      eor	currentPiece
     18  7d66		       10 03		      bpl	.invalid
     19  7d68		       20 20 f5 	      jsr	AddMove
     20  7d6b
     21  7d6b				   .invalid
     25  7d6b
     26  7d6b		       4c 8c f1 	      jmp	MoveReturn
     27  7d6e
     28  7d6e							; EOF
------- FILE PIECE_HANDLER@1#2.asm
------- FILE PIECE_KING.asm LEVEL 3 PASS 4
      0  7d6e					      include	"PIECE_KING.asm"
      1  7d6e							; Copyright (C)2020 Andrew Davie
      2  7d6e
      3  7d6e							;---------------------------------------------------------------------------------------------------
      4  7d6e							; KING
      5  7d6e							; This is the move handler for a KING
      6  7d6e							; "Check" is detected in the next ply of the search.
      7  7d6e
      8  7d6e
      9  7d6e							;---------------------------------------------------------------------------------------------------
     10  7d6e
     11  7d6e							; MACRO - Castling
     12  7d6e
     13  7d6e		       00 03	   KINGSIDE   =	3
     14  7d6e		       ff ff ff fc QUEENSIDE  =	-4
     15  7d6e
     16  7d6e					      MAC	castle
     17  7d6e							; {1} = "KINGSIDE" or "QUEENSIDE"
     18  7d6e
     19  7d6e					      ldx	currentSquare
     20  7d6e					      lda	Board+{1},x	; kingside/queenside R position
     21  7d6e					      and	#PIECE_MASK|FLAG_MOVED
     22  7d6e					      cmp	#ROOK
     23  7d6e					      bne	.noCastle	; not a R that hasn't moved
     24  7d6e
     25  7d6e							; It's a R and it *HAS* to be correct colour because it hasn't moved!
     26  7d6e							; AND the K hasn't moved (earlier check), so check for vacant squares between K and R
     27  7d6e
     28  7d6e					      IF	{1} = QUEENSIDE
     29  7d6e					      lda	Board-3,x	; N pos
     30  7d6e					      ora	Board-2,x	; B pos
     31  7d6e					      ora	Board-1,x	; Q pos
     32  7d6e					      bne	.noCastle	; not vacant?
     33  7d6e
     34  7d6e					      ENDIF
     35  7d6e
     36  7d6e					      IF	{1} = KINGSIDE
     37  7d6e					      lda	Board+2,x	; N pos
     38  7d6e					      ora	Board+1,x	; B pos
     39  7d6e					      bne	.noCastle	; not vacant?
     40  7d6e					      ENDIF
     41  7d6e
     42  7d6e							; appropriate N/B/(Q) squares are vacant so we proceed...
     43  7d6e
     44  7d6e							; FINALLY -- king can castle
     45  7d6e							; note: when we actually DO the move we MUST insert "Phantom" kings onto the board over the
     46  7d6e							; squares the king traverses so that "check" (and thus illegal moves) can be detected on the
     47  7d6e							; next move. Castling will be detected by K moving > 1 square. (TODO: FIX?? not CASTLE flag??)
     48  7d6e
     49  7d6e					      lda	currentPiece
     50  7d6e					      ora	#FLAG_CASTLE	; flag it's a castling move
     51  7d6e					      sta	currentPiece
     52  7d6e
     53  7d6e					      IF	{1} = KINGSIDE
     54  7d6e					      ldy	ValidSquare+2,x
     55  7d6e					      ENDIF
     56  7d6e
     57  7d6e					      IF	{1} = QUEENSIDE
     58  7d6e					      ldy	ValidSquare-2,x
     59  7d6e					      ENDIF
     60  7d6e
     61  7d6e					      jsr	AddMove	; 57
     62  7d6e
     63  7d6e				   .noCastle
     64  7d6e					      ENDM
     65  7d6e
     66  7d6e
     67  7d6e							;---------------------------------------------------------------------------------------------------
     68  7d6e
      0  7d6e					      DEF	Handle_KING
      1  7d6e				   SLOT_Handle_KING SET	_BANK_SLOT
      2  7d6e				   BANK_Handle_KING SET	SLOT_Handle_KING + _CURRENT_BANK
      3  7d6e				   Handle_KING
      4  7d6e				   TEMPORARY_VAR SET	Overlay
      5  7d6e				   TEMPORARY_OFFSET SET	0
      6  7d6e				   VAR_BOUNDARY_Handle_KING SET	TEMPORARY_OFFSET
      7  7d6e				   FUNCTION_NAME SET	Handle_KING
     70  7d6e					      SUBROUTINE
     71  7d6e
      0  7d6e					      REFER	GenerateAllMoves
      1  7d6e					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  7d6e				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  7d6e					      ENDIF
      0  7d6e					      VEND	Handle_KING
      1  7d6e				  -	      IFNCONST	Handle_KING
      2  7d6e				  -	      ECHO	"Incorrect VEND label", Handle_KING
      3  7d6e				  -	      ERR
      4  7d6e					      ENDIF
      5  7d6e		       00 b3	   VAREND_Handle_KING =	TEMPORARY_VAR
     74  7d6e
     75  7d6e							; x = currentSquare (square the KING is on)
     76  7d6e							; currentPiece (KING of course, but with flags/colour attached)
     77  7d6e
      0  7d6e					      MOVE_TO	_DOWN+_LEFT
      1  7d6e					      SUBROUTINE
      2  7d6e		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      3  7d71		       30 0e		      bmi	.invalid
      4  7d73		       b9 79 fc 	      lda	Board,y
      5  7d76		       85 9e		      sta	capture
      6  7d78		       f0 04		      beq	.squareEmpty
      7  7d7a		       45 92		      eor	currentPiece
      8  7d7c		       10 03		      bpl	.invalid
      9  7d7e		       20 20 f5    .squareEmpty jsr	AddMove
     10  7d81				   .invalid
      0  7d81					      MOVE_TO_X	_DOWN
      1  7d81		       a6 93		      ldx	currentSquare
      0  7d83					      MOVE_TO	_DOWN
      1  7d83					      SUBROUTINE
      2  7d83		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x
      3  7d86		       30 0e		      bmi	.invalid
      4  7d88		       b9 79 fc 	      lda	Board,y
      5  7d8b		       85 9e		      sta	capture
      6  7d8d		       f0 04		      beq	.squareEmpty
      7  7d8f		       45 92		      eor	currentPiece
      8  7d91		       10 03		      bpl	.invalid
      9  7d93		       20 20 f5    .squareEmpty jsr	AddMove
     10  7d96				   .invalid
      0  7d96					      MOVE_TO_X	_DOWN+_RIGHT
      1  7d96		       a6 93		      ldx	currentSquare
      0  7d98					      MOVE_TO	_DOWN+_RIGHT
      1  7d98					      SUBROUTINE
      2  7d98		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      3  7d9b		       30 0e		      bmi	.invalid
      4  7d9d		       b9 79 fc 	      lda	Board,y
      5  7da0		       85 9e		      sta	capture
      6  7da2		       f0 04		      beq	.squareEmpty
      7  7da4		       45 92		      eor	currentPiece
      8  7da6		       10 03		      bpl	.invalid
      9  7da8		       20 20 f5    .squareEmpty jsr	AddMove
     10  7dab				   .invalid
      0  7dab					      MOVE_TO_X	_RIGHT
      1  7dab		       a6 93		      ldx	currentSquare
      0  7dad					      MOVE_TO	_RIGHT
      1  7dad					      SUBROUTINE
      2  7dad		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      3  7db0		       30 0e		      bmi	.invalid
      4  7db2		       b9 79 fc 	      lda	Board,y
      5  7db5		       85 9e		      sta	capture
      6  7db7		       f0 04		      beq	.squareEmpty
      7  7db9		       45 92		      eor	currentPiece
      8  7dbb		       10 03		      bpl	.invalid
      9  7dbd		       20 20 f5    .squareEmpty jsr	AddMove
     10  7dc0				   .invalid
      0  7dc0					      MOVE_TO_X	_UP+_RIGHT
      1  7dc0		       a6 93		      ldx	currentSquare
      0  7dc2					      MOVE_TO	_UP+_RIGHT
      1  7dc2					      SUBROUTINE
      2  7dc2		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      3  7dc5		       30 0e		      bmi	.invalid
      4  7dc7		       b9 79 fc 	      lda	Board,y
      5  7dca		       85 9e		      sta	capture
      6  7dcc		       f0 04		      beq	.squareEmpty
      7  7dce		       45 92		      eor	currentPiece
      8  7dd0		       10 03		      bpl	.invalid
      9  7dd2		       20 20 f5    .squareEmpty jsr	AddMove
     10  7dd5				   .invalid
      0  7dd5					      MOVE_TO_X	_UP
      1  7dd5		       a6 93		      ldx	currentSquare
      0  7dd7					      MOVE_TO	_UP
      1  7dd7					      SUBROUTINE
      2  7dd7		       bc 1f fc 	      ldy	ValidSquare+_UP,x
      3  7dda		       30 0e		      bmi	.invalid
      4  7ddc		       b9 79 fc 	      lda	Board,y
      5  7ddf		       85 9e		      sta	capture
      6  7de1		       f0 04		      beq	.squareEmpty
      7  7de3		       45 92		      eor	currentPiece
      8  7de5		       10 03		      bpl	.invalid
      9  7de7		       20 20 f5    .squareEmpty jsr	AddMove
     10  7dea				   .invalid
      0  7dea					      MOVE_TO_X	_UP+_LEFT
      1  7dea		       a6 93		      ldx	currentSquare
      0  7dec					      MOVE_TO	_UP+_LEFT
      1  7dec					      SUBROUTINE
      2  7dec		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      3  7def		       30 0e		      bmi	.invalid
      4  7df1		       b9 79 fc 	      lda	Board,y
      5  7df4		       85 9e		      sta	capture
      6  7df6		       f0 04		      beq	.squareEmpty
      7  7df8		       45 92		      eor	currentPiece
      8  7dfa		       10 03		      bpl	.invalid
      9  7dfc		       20 20 f5    .squareEmpty jsr	AddMove
     10  7dff				   .invalid
      0  7dff					      MOVE_TO_X	_LEFT
      1  7dff		       a6 93		      ldx	currentSquare
      0  7e01					      MOVE_TO	_LEFT
      1  7e01					      SUBROUTINE
      2  7e01		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      3  7e04		       30 0e		      bmi	.invalid
      4  7e06		       b9 79 fc 	      lda	Board,y
      5  7e09		       85 9e		      sta	capture
      6  7e0b		       f0 04		      beq	.squareEmpty
      7  7e0d		       45 92		      eor	currentPiece
      8  7e0f		       10 03		      bpl	.invalid
      9  7e11		       20 20 f5    .squareEmpty jsr	AddMove
     10  7e14				   .invalid
     86  7e14
     87  7e14							;IF CASTLING_ENABLED
     88  7e14
     89  7e14		       24 92		      bit	currentPiece
     90  7e16		       70 41		      bvs	.exit	; king has moved, so no castling
     91  7e18
      0  7e18					      CASTLE	KINGSIDE
      1  7e18
      2  7e18
      3  7e18		       a6 93		      ldx	currentSquare
      4  7e1a		       bd 7c fc 	      lda	Board+KINGSIDE,x
      5  7e1d		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  7e1f		       c9 05		      cmp	#ROOK
      7  7e21		       d0 14		      bne	.noCastle
      8  7e23
      9  7e23
     10  7e23
     11  7e23
     12  7e23				  -	      IF	KINGSIDE = QUEENSIDE
     13  7e23				  -	      lda	Board-3,x
     14  7e23				  -	      ora	Board-2,x
     15  7e23				  -	      ora	Board-1,x
     16  7e23				  -	      bne	.noCastle
     17  7e23				  -
     18  7e23					      ENDIF
     19  7e23
     20  7e23					      IF	KINGSIDE = KINGSIDE
     21  7e23		       bd 7b fc 	      lda	Board+2,x
     22  7e26		       1d 7a fc 	      ora	Board+1,x
     23  7e29		       d0 0c		      bne	.noCastle
     24  7e2b					      ENDIF
     25  7e2b
     26  7e2b
     27  7e2b
     28  7e2b
     29  7e2b
     30  7e2b
     31  7e2b
     32  7e2b
     33  7e2b		       a5 92		      lda	currentPiece
     34  7e2d		       09 10		      ora	#FLAG_CASTLE
     35  7e2f		       85 92		      sta	currentPiece
     36  7e31
     37  7e31					      IF	KINGSIDE = KINGSIDE
     38  7e31		       bc 17 fc 	      ldy	ValidSquare+2,x
     39  7e34					      ENDIF
     40  7e34
     41  7e34				  -	      IF	KINGSIDE = QUEENSIDE
     42  7e34				  -	      ldy	ValidSquare-2,x
     43  7e34					      ENDIF
     44  7e34
     45  7e34		       20 20 f5 	      jsr	AddMove
     46  7e37
     47  7e37				   .noCastle
      0  7e37					      CASTLE	QUEENSIDE
      1  7e37
      2  7e37
      3  7e37		       a6 93		      ldx	currentSquare
      4  7e39		       bd 75 fc 	      lda	Board+QUEENSIDE,x
      5  7e3c		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  7e3e		       c9 05		      cmp	#ROOK
      7  7e40		       d0 17		      bne	.noCastle
      8  7e42
      9  7e42
     10  7e42
     11  7e42
     12  7e42					      IF	QUEENSIDE = QUEENSIDE
     13  7e42		       bd 76 fc 	      lda	Board-3,x
     14  7e45		       1d 77 fc 	      ora	Board-2,x
     15  7e48		       1d 78 fc 	      ora	Board-1,x
     16  7e4b		       d0 0c		      bne	.noCastle
     17  7e4d
     18  7e4d					      ENDIF
     19  7e4d
     20  7e4d				  -	      IF	QUEENSIDE = KINGSIDE
     21  7e4d				  -	      lda	Board+2,x
     22  7e4d				  -	      ora	Board+1,x
     23  7e4d				  -	      bne	.noCastle
     24  7e4d					      ENDIF
     25  7e4d
     26  7e4d
     27  7e4d
     28  7e4d
     29  7e4d
     30  7e4d
     31  7e4d
     32  7e4d
     33  7e4d		       a5 92		      lda	currentPiece
     34  7e4f		       09 10		      ora	#FLAG_CASTLE
     35  7e51		       85 92		      sta	currentPiece
     36  7e53
     37  7e53				  -	      IF	QUEENSIDE = KINGSIDE
     38  7e53				  -	      ldy	ValidSquare+2,x
     39  7e53					      ENDIF
     40  7e53
     41  7e53					      IF	QUEENSIDE = QUEENSIDE
     42  7e53		       bc 13 fc 	      ldy	ValidSquare-2,x
     43  7e56					      ENDIF
     44  7e56
     45  7e56		       20 20 f5 	      jsr	AddMove
     46  7e59
     47  7e59				   .noCastle
     94  7e59
     95  7e59							;ENDIF
     96  7e59
     97  7e59		       4c 8c f1    .exit      jmp	MoveReturn
     98  7e5c
     99  7e5c							;---------------------------------------------------------------------------------------------------
    100  7e5c							; EOF
------- FILE PIECE_HANDLER@1#2.asm
      7  7e5c
      8  7e5c							;---------------------------------------------------------------------------------------------------
      9  7e5c
      0  7e5c					      CHECK_BANK_SIZE	"PIECE_HANDLER_2"
      1  7e5c		       02 5c	   .TEMP      =	* - _BANK_START
 PIECE_HANDLER_2 (1K) SIZE =  $25c , FREE= $1a4
      2  7e5c					      ECHO	"PIECE_HANDLER_2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  7e5c				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  7e5c				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_HANDLER_2", " size=", * - ORIGIN
      5  7e5c				  -	      ERR
      6  7e5c					      ENDIF
     11  7e5c
     12  7e5c							;---------------------------------------------------------------------------------------------------
     13  7e5c							; EOF
------- FILE ./chess.asm
------- FILE BANK_3.asm LEVEL 2 PASS 4
      0  7e5c					      include	"BANK_3.asm"
      1  7e5c							; Chess
      2  7e5c							; Copyright (c) 2019-2020 Andrew Davie
      3  7e5c							; andrew@taswegian.com
      4  7e5c
      0  7e5c					      SLOT	1	; this code assembles for bank #1
      1  7e5c				  -	      IF	(1 < 0) || (1 > 3)
      2  7e5c				  -	      ECHO	"Illegal bank address/segment location", 1
      3  7e5c				  -	      ERR
      4  7e5c					      ENDIF
      5  7e5c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  7e5c				   _BANK_SLOT SET	1 * 64
      0  7e5c					      NEWBANK	THREE
      1  8400 ????				      SEG	THREE
      2  8000					      ORG	_ORIGIN
      3  8000					      RORG	_BANK_ADDRESS_ORIGIN
      4  8000				   _BANK_START SET	*
      5  8000				   THREE_START SET	*
      6  8000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  8000				   THREE      SET	_BANK_SLOT + _CURRENT_BANK
      8  8000				   _ORIGIN    SET	_ORIGIN + 1024
      7  8000
      8  8000		       00 00 00 00*	      ds	1024
      9  8400
     10  8400
     11  8400							; EOF
------- FILE ./chess.asm
    637  8400
    638  8400							;---------------------------------------------------------------------------------------------------
    639  8400							;EOF
