------- FILE ./chess.asm LEVEL 1 PASS 4
      1  8400 ????						; Chess
      2  8400 ????						; Atari 2600 Chess display system
      3  8400 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  8400 ????						; andrew@taswegian.com
      5  8400 ????
      6  8400 ????
      7  8400 ????	       00 40	   TIA_BASE_ADDRESS =	$40
      8  8400 ????
      9  8400 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 4
      0  8400 ????				      include	"vcs.h"
      1  8400 ????						; VCS.H
      2  8400 ????						; Version 1.05, 13/November/2003
      3  8400 ????
      4  8400 ????	       00 69	   VERSION_VCS =	105
      5  8400 ????
      6  8400 ????						; This file defines hardware registers and memory mapping for the
      7  8400 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  8400 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  8400 ????						; available at at http://www.atari2600.org/dasm
     10  8400 ????						;
     11  8400 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  8400 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  8400 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  8400 ????						; with your views.  Please contribute, if you think you can improve this
     15  8400 ????						; file!
     16  8400 ????						;
     17  8400 ????						; Latest Revisions...
     18  8400 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  8400 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  8400 ????						;			    This will allow conditional code to verify VCS.H being
     21  8400 ????						;			    used for code assembly.
     22  8400 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  8400 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  8400 ????						;			 mirrored reading/writing differences.	This is more a
     25  8400 ????						;			 readability issue, and binary compatibility with disassembled
     26  8400 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  8400 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  8400 ????						;			 which was broken by the use of segments in this file, as
     29  8400 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  8400 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  8400 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  8400 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  8400 ????						;						   it is safe to leave it undefined, and the base address will
     34  8400 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  8400 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  8400 ????						;			  - register definitions are now generated through assignment
     37  8400 ????						;			    in uninitialised segments.	This allows a changeable base
     38  8400 ????						;			    address architecture.
     39  8400 ????						; 1.0	22/MAR/2003		Initial release
     40  8400 ????
     41  8400 ????
     42  8400 ????						;-------------------------------------------------------------------------------
     43  8400 ????
     44  8400 ????						; TIA_BASE_ADDRESS
     45  8400 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  8400 ????						; Normally 0, the base address should (externally, before including this file)
     47  8400 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  8400 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  8400 ????						; < $40 as a bankswitch.
     50  8400 ????
     51  8400 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  8400 ????			  -TIA_BASE_ADDRESS =	0
     53  8400 ????				      ENDIF
     54  8400 ????
     55  8400 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  8400 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  8400 ????						; *OR* by declaring the label before including this file, eg:
     58  8400 ????						; TIA_BASE_ADDRESS = $40
     59  8400 ????						;   include "vcs.h"
     60  8400 ????
     61  8400 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  8400 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  8400 ????						; for the mirrored ROM hardware registers.
     64  8400 ????
     65  8400 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  8400 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  8400 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  8400 ????
     69  8400 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  8400 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  8400 ????				      ENDIF
     72  8400 ????
     73  8400 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  8400 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  8400 ????				      ENDIF
     76  8400 ????
     77  8400 ????						;-------------------------------------------------------------------------------
     78  8400 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE macro.h LEVEL 2 PASS 4
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE piece_defines.h LEVEL 2 PASS 4
      0  0000 ????				      include	"piece_defines.h"
      1  0000 ????						; Copyright (C)2020 Andrew Davie
      2  0000 ????
      3  0000 ????	       00 80	   BLACK      =	128
      4  0000 ????	       00 00	   WHITE      =	0
      5  0000 ????
      6  0000 ????	       00 80	   FLAG_COLOUR =	128	; mask
      7  0000 ????	       00 40	   FLAG_MOVED =	64	; mark ALL pieces when moved. Used for castling
      8  0000 ????						; but maybe useful for evaluation of development
      9  0000 ????	       00 20	   FLAG_ENPASSANT =	32
     10  0000 ????	       00 10	   FLAG_CASTLE =	16
     11  0000 ????
     12  0000 ????						;---------------------------------------------------------------------------------------------------
     13  0000 ????						; DEFINE THE PIECES
     14  0000 ????						; ID lives in bits 0-2
     15  0000 ????
     16  0000 ????	       00 00	   BLANK      =	0
     17  0000 ????	       00 00	   ███  =	BLANK
     18  0000 ????
     19  0000 ????	       00 01	   WPAWN      =	1
     20  0000 ????	       00 01	   WP	      =	WPAWN
     21  0000 ????	       00 02	   BPAWN      =	2
     22  0000 ????	       00 02	   BP	      =	BPAWN
     23  0000 ????	       00 03	   KNIGHT     =	3
     24  0000 ????	       00 03	   N	      =	KNIGHT
     25  0000 ????	       00 04	   BISHOP     =	4
     26  0000 ????	       00 04	   B	      =	BISHOP
     27  0000 ????	       00 05	   ROOK       =	5
     28  0000 ????	       00 05	   R	      =	ROOK
     29  0000 ????	       00 06	   QUEEN      =	6
     30  0000 ????	       00 06	   Q	      =	QUEEN
     31  0000 ????	       00 07	   KING       =	7
     32  0000 ????	       00 07	   K	      =	KING
     33  0000 ????
     34  0000 ????	       00 0f	   PIECE_MASK =	15	; trim off the flags leaving just piece ID
     35  0000 ????
     36  0000 ????						;---------------------------------------------------------------------------------------------------
     37  0000 ????
     38  0000 ????						; Movements
     39  0000 ????
     40  0000 ????	       00 0a	   _UP	      =	10	; up
     41  0000 ????	       ff ff ff ff _LEFT      =	-1	; left
     42  0000 ????	       ff ff ff f6 _DOWN      =	-10	; down
     43  0000 ????	       00 01	   _RIGHT     =	1	; right
     44  0000 ????
     45  0000 ????						; EOF
------- FILE ./chess.asm
     13  0000 ????
     14  0000 ????	       00 00	   VERBOSE    =	0	; set to 1 for compile messages
     15  0000 ????
     16  0000 ????			   ORIGIN     SET	0
     17  0000 ????			   ORIGIN_RAM SET	0
     18  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	segtime_c
     89  0000 ????			   {1}	      SET	({2}+32)/64 + 2
     90  0000 ????			   TEST_{1}   =	0
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????						; Pathways
     94  0000 ????						; StealPart3, not enough time for SCD_SLOW --> 79✅
     95  0000 ????						; if QuickDraw does immediate exit, 58✅
     96  0000 ????
     97  0000 ????						;---------------------------------------------------------------------------------------------------
     98  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_MINIMUM_TIMESLICE, 54	;✅ abort time maximum requirement for timeslice
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	(54+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    100  0000 ????
    101  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    102  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    103  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    104  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    105  0000 ????						; uses ...
    106  0000 ????
    107  0000 ????
    108  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    109  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    110  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    111  0000 ????
    112  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    113  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    114  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,22	;18 ;12	  ;NFI
      1  0000 ????			   SEGTIME_MAN SET	22
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
------- FILE ./chess.asm
     20  0000 ????
     21  0000 ????
     22  0000 ????	       00 00	   _FIRST_BANK =	0	; 3E+ 1st bank holds reset vectors
     23  0000 ????
     24  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     25  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     26  0000 ????						;FIXED_BANK		 = 15 * 2048	       ; ->> 32K
     27  0000 ????						;FIXED_BANK		 = 31 * 2048	       ; ->> 64K
     28  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     29  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     30  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     31  0000 ????
     32  0000 ????	       00 01	   YES	      =	1
     33  0000 ????	       00 00	   NO	      =	0
     34  0000 ????
     35  0000 ????	       70 00	   INFINITY   =	$7000	;32767
     36  0000 ????
     37  0000 ????
     38  0000 ????						; assemble diagnostics. Remove for release.
     39  0000 ????
     40  0000 ????	       00 00	   TEST_POSITION =	0	; 0=normal, 1 = setup test position
     41  0000 ????	       00 00	   DIAGNOSTICS =	0
     42  0000 ????	       00 01	   QUIESCENCE =	1
     43  0000 ????	       00 00	   ASSERTS    =	0
     44  0000 ????	       00 00	   PVSP       =	0	; player versus player =1
     45  0000 ????	       00 00	   ENPASSANT_ENABLED =	0
     46  0000 ????	       00 01	   CASTLING_ENABLED =	1
     47  0000 ????
     48  0000 ????	       00 03	   SEARCH_DEPTH =	3
     49  0000 ????	       00 04	   QUIESCE_EXTRA_DEPTH =	4
     50  0000 ????
     51  0000 ????
     52  0000 ????	       00 07	   PLY_BANKS  =	SEARCH_DEPTH + QUIESCE_EXTRA_DEPTH
     53  0000 ????	       00 07	   MAX_PLY_DEPTH_BANK =	PLY_BANKS	;TODO -- RAMBANK_PLY + PLY_BANKS
     54  0000 ????
     55  0000 ????						;IF RAMBANK_PLY + MAX_PLY_DEPTH_BANK > 31
     56  0000 ????						;    ERR "Not enough RAM for PLY banks"
     57  0000 ????						;ENDIF
     58  0000 ????
     59  0000 ????
     60  0000 ????
     61  0000 ????
     62  0000 ????	       00 80	   SWAP_SIDE  =	128	;TODO + (RAMBANK_PLY ^ (RAMBANK_PLY+1))
     63  0000 ????
     64  0000 ????
     65  0000 ????
     66  0000 ????						; DELAYS
     67  0000 ????
     68  0000 ????	       00 0a	   READY_TO_MOVE_FLASH =	10
     69  0000 ????
     70  0000 ????						;===================================
     71  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     72  0000 ????						;===================================
     73  0000 ????
     74  0000 ????						;-------------------------------------------------------------------------------
     75  0000 ????						; The following are optional YES/NO depending on phase of the moon
     76  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     77  0000 ????						;-------------------------------------------------------------------------------
     78  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     79  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     80  0000 ????			  -	      IF	FINAL_VERSION = YES
     81  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     82  0000 ????				      ENDIF
     83  0000 ????
     84  0000 ????						;-------------------------------------------------------------------------------
     85  0000 ????
     86  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     87  0000 ????
     88  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
     89  0000 ????
     90  0000 ????						;------------------------------------------------------------------------------
     91  0000 ????
     92  0000 ????	       00 01	   PLUSCART   =	YES
     93  0000 ????
     94  0000 ????						;------------------------------------------------------------------------------
     95  0000 ????
     96  0000 ????
     97  0000 ????	       00 08	   CHESSBOARD_ROWS =	8	; number of ROWS of chessboard
     98  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
     99  0000 ????	       00 48	   PIECE_SHAPE_SIZE =	72	; 3 PF bytes x 24 scanlines
    100  0000 ????
    101  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    102  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    103  0000 ????
    104  0000 ????
    105  0000 ????	       04 00	   RAM_SIZE   =	$400	; address space for write AND read
    106  0000 ????	       02 00	   RAM_WRITE  =	$200	; add this to RAM address when doing writes
    107  0000 ????	       02 00	   RAM	      =	RAM_WRITE
    108  0000 ????
    109  0000 ????	       04 00	   _ROM_BANK_SIZE =	$400
    110  0000 ????	       02 00	   _RAM_BANK_SIZE =	$200
    111  0000 ????
    112  0000 ????
    113  0000 ????						; Platform constants:
    114  0000 ????	       00 02	   PAL	      =	%10
    115  0000 ????	       00 02	   PAL_50     =	PAL|0
    116  0000 ????	       00 03	   PAL_60     =	PAL|1
    117  0000 ????
    118  0000 ????
    119  0000 ????				      IF	L276
    120  0000 ????	       00 30	   VBLANK_TIM_NTSC =	48	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    121  0000 ????			  -	      ELSE
    122  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    123  0000 ????				      ENDIF
    124  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    125  0000 ????
    126  0000 ????				      IF	L276
    127  0000 ????	       00 23	   OVERSCAN_TIM_NTSC =	35	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    128  0000 ????			  -	      ELSE
    129  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    130  0000 ????				      ENDIF
    131  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    132  0000 ????
    133  0000 ????				      IF	L276
    134  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    135  0000 ????			  -	      ELSE
    136  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    137  0000 ????				      ENDIF
    138  0000 ????	       01 38	   SCANLINES_PAL =	312
    139  0000 ????
    140  0000 ????
    141  0000 ????	       00 2e	   TIME_PART_2 =	46
    142  0000 ????	       00 2e	   TIME_PART_1 =	46
    143  0000 ????
    144  0000 ????
    145  0000 ????	       00 00	   SLOT0      =	0
    146  0000 ????	       00 40	   SLOT1      =	64
    147  0000 ????	       00 80	   SLOT2      =	128
    148  0000 ????	       00 c0	   SLOT3      =	192
    149  0000 ????
    150  0000 ????						;------------------------------------------------------------------------------
    151  0000 ????						; MACRO definitions
    152  0000 ????
    153  0000 ????
    154  0000 ????
    155  0000 ????				      MAC	newbank
    156  0000 ????				      SEG	{1}
    157  0000 ????				      ORG	_ORIGIN
    158  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    159  0000 ????			   _BANK_START SET	*
    160  0000 ????			   {1}_START  SET	*
    161  0000 ????			   _CURRENT_BANK SET	_ORIGIN/1024
    162  0000 ????			   {1}	      SET	_BANK_SLOT + _CURRENT_BANK
    163  0000 ????			   _ORIGIN    SET	_ORIGIN + 1024
    164  0000 ????				      ENDM		; bank name
    165  0000 ????
    166  0000 ????						;	      MAC DEFINE_1K_SEGMENT ; {seg name}
    167  0000 ????						;		  ALIGN $400
    168  0000 ????						;SEGMENT_{1}	  SET *
    169  0000 ????						;BANK_{1}	  SET _CURRENT_BANK
    170  0000 ????						;	      ENDM
    171  0000 ????
    172  0000 ????				      MAC	check_bank_size
    173  0000 ????			   .TEMP      =	* - _BANK_START
    174  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
    175  0000 ????				      IF	( .TEMP ) > _ROM_BANK_SIZE
    176  0000 ????				      ECHO	"BANK OVERFLOW @ ", {1}, " size=", * - ORIGIN
    177  0000 ????				      ERR
    178  0000 ????				      ENDIF
    179  0000 ????				      ENDM		; name
    180  0000 ????
    181  0000 ????				      MAC	check_ram_bank_size
    182  0000 ????			   .TEMP      =	* - _BANK_START
    183  0000 ????				      ECHO	{1}, "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
    184  0000 ????				      IF	( .TEMP ) > _RAM_BANK_SIZE
    185  0000 ????				      ECHO	"BANK OVERFLOW @ ", {1}, " size=", * - ORIGIN
    186  0000 ????				      ERR
    187  0000 ????				      ENDIF
    188  0000 ????				      ENDM		; name
    189  0000 ????
    190  0000 ????						;---------------------------------------------------------------------------------------------------
    191  0000 ????
    192  0000 ????						; Macro inserts a page break if the object would overlap a page
    193  0000 ????
    194  0000 ????				      MAC	optional_pagebreak
    195  0000 ????				      LIST	OFF
    196  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    197  0000 ????			   EARLY_LOCATION SET	*
    198  0000 ????				      ALIGN	256
    199  0000 ????				      IF	VERBOSE=1
    200  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR", {1}
    201  0000 ????				      ECHO	"REQUESTED SIZE =", {2}
    202  0000 ????				      ECHO	"WASTED SPACE =", *-EARLY_LOCATION
    203  0000 ????				      ECHO	"PAGEBREAK LOCATION =", *
    204  0000 ????				      ENDIF
    205  0000 ????				      ENDIF
    206  0000 ????				      LIST	ON
    207  0000 ????				      ENDM		; { string, size }
    208  0000 ????
    209  0000 ????
    210  0000 ????				      MAC	check_page_crossing
    211  0000 ????				      LIST	OFF
    212  0000 ????				      IF	( >BLOCK_END != >BLOCK_START )
    213  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    214  0000 ????				      ENDIF
    215  0000 ????				      LIST	ON
    216  0000 ????				      ENDM
    217  0000 ????
    218  0000 ????				      MAC	checkpage
    219  0000 ????				      LIST	OFF
    220  0000 ????				      IF	>. != >{1}
    221  0000 ????				      ECHO	""
    222  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    223  0000 ????				      ECHO	""
    224  0000 ????				      ERR
    225  0000 ????				      ENDIF
    226  0000 ????				      LIST	ON
    227  0000 ????				      ENDM
    228  0000 ????
    229  0000 ????				      MAC	checkpagex
    230  0000 ????				      LIST	OFF
    231  0000 ????				      IF	>. != >{1}
    232  0000 ????				      ECHO	""
    233  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    234  0000 ????				      ECHO	{2}
    235  0000 ????				      ECHO	""
    236  0000 ????				      ERR
    237  0000 ????				      ENDIF
    238  0000 ????				      LIST	ON
    239  0000 ????				      ENDM
    240  0000 ????
    241  0000 ????						;---------------------------------------------------------------------------------------------------
    242  0000 ????
    243  0000 ????						; Defines a variable of the given size, making sure it doesn't cross a page
    244  0000 ????				      MAC	variable
    245  0000 ????				      OPTIONAL_PAGEBREAK	"Variable", {2}
    246  0000 ????			   {1}	      ds	{2}
    247  0000 ????				      ENDM		; {name, size}
    248  0000 ????
    249  0000 ????
    250  0000 ????						;---------------------------------------------------------------------------------------------------
    251  0000 ????
    252  0000 ????				      MAC	def
    253  0000 ????			   SLOT_{1}   SET	_BANK_SLOT
    254  0000 ????			   BANK_{1}   SET	SLOT_{1} + _CURRENT_BANK	; bank in which this subroutine resides
    255  0000 ????			   {1}			; entry point
    256  0000 ????			   TEMPORARY_VAR SET	Overlay
    257  0000 ????			   TEMPORARY_OFFSET SET	0
    258  0000 ????			   VAR_BOUNDARY_{1} SET	TEMPORARY_OFFSET
    259  0000 ????			   FUNCTION_NAME SET	{1}
    260  0000 ????				      ENDM		; name of subroutine
    261  0000 ????
    262  0000 ????
    263  0000 ????						;---------------------------------------------------------------------------------------------------
    264  0000 ????
    265  0000 ????				      MAC	allocate
    266  0000 ????				      OPTIONAL_PAGEBREAK	"Table", {2}
    267  0000 ????				      DEF	{1}
    268  0000 ????				      ENDM
    269  0000 ????
    270  0000 ????						;---------------------------------------------------------------------------------------------------
    271  0000 ????
    272  0000 ????				      MAC	slot
    273  0000 ????				      IF	({1} < 0) || ({1} > 3)
    274  0000 ????				      ECHO	"Illegal bank address/segment location", {1}
    275  0000 ????				      ERR
    276  0000 ????				      ENDIF
    277  0000 ????			   _BANK_ADDRESS_ORIGIN SET	$F000 + ({1} * _ROM_BANK_SIZE)
    278  0000 ????			   _BANK_SLOT SET	{1} * 64	; D7/D6 selector
    279  0000 ????				      ENDM		; {1}
    280  0000 ????
    281  0000 ????
    282  0000 ????						;---------------------------------------------------------------------------------------------------
    283  0000 ????
    284  0000 ????				      MAC	negeval
    285  0000 ????
    286  0000 ????				      sec
    287  0000 ????				      lda	#0
    288  0000 ????				      sbc	Evaluation
    289  0000 ????				      sta	Evaluation
    290  0000 ????				      lda	#0
    291  0000 ????				      sbc	Evaluation+1
    292  0000 ????				      sta	Evaluation+1
    293  0000 ????				      ENDM
    294  0000 ????
    295  0000 ????
    296  0000 ????				      MAC	swap
    297  0000 ????				      lda	sideToMove
    298  0000 ????				      eor	#SWAP_SIDE
    299  0000 ????				      sta	sideToMove
    300  0000 ????				      ENDM
    301  0000 ????
    302  0000 ????
    303  0000 ????						;---------------------------------------------------------------------------------------------------
    304  0000 ????
    305  0000 ????			   TEMPORARY_OFFSET SET	0
    306  0000 ????
    307  0000 ????
    308  0000 ????				      MAC	vend
    309  0000 ????				      IFNCONST	{1}
    310  0000 ????				      ECHO	"Incorrect VEND label", {1}
    311  0000 ????				      ERR
    312  0000 ????				      ENDIF
    313  0000 ????			   VAREND_{1} =	TEMPORARY_VAR
    314  0000 ????				      ENDM		; {1}
    315  0000 ????
    316  0000 ????
    317  0000 ????				      MAC	refer
    318  0000 ????				      IF	VAREND_{1} > TEMPORARY_VAR
    319  0000 ????			   TEMPORARY_VAR SET	VAREND_{1}
    320  0000 ????				      ENDIF
    321  0000 ????				      ENDM		; {1}
    322  0000 ????
    323  0000 ????
    324  0000 ????
    325  0000 ????						; Define a temporary variable for use in a subroutine
    326  0000 ????						; Will allocate appropriate bytes, and also check for overflow of the available overlay buffer
    327  0000 ????
    328  0000 ????				      MAC	var
    329  0000 ????			   {1}	      =	TEMPORARY_VAR
    330  0000 ????			   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + {2}
    331  0000 ????
    332  0000 ????			   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
    333  0000 ????				      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
    334  0000 ????			   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
    335  0000 ????				      ENDIF
    336  0000 ????				      IF	OVERLAY_DELTA > OVERLAY_SIZE
    337  0000 ????				      ECHO	"Temporary Variable", {1}, "overflow!"
    338  0000 ????				      ERR
    339  0000 ????				      ENDIF
    340  0000 ????				      LIST	ON
    341  0000 ????				      ENDM		; { name, size }
    342  0000 ????
    343  0000 ????
    344  0000 ????						;---------------------------------------------------------------------------------------------------
    345  0000 ????
    346  0000 ????				      MAC	tag
    347  0000 ????						; {0}
    348  0000 ????				      ENDM		; {ident/tag}
    349  0000 ????
    350  0000 ????						;---------------------------------------------------------------------------------------------------
    351  0000 ????
    352  0000 ????				      MAC	sta@ram
    353  0000 ????				      sta	[RAM]+{0}
    354  0000 ????				      ENDM		;{}
    355  0000 ????
    356  0000 ????				      MAC	stx@ram
    357  0000 ????				      stx	[RAM]+{0}
    358  0000 ????				      ENDM
    359  0000 ????
    360  0000 ????				      MAC	sty@ram
    361  0000 ????				      sty	[RAM]+{0}
    362  0000 ????				      ENDM
    363  0000 ????
    364  0000 ????				      MAC	sta@ply
    365  0000 ????				      sta	[RAM]+{0}
    366  0000 ????				      ENDM		;{}
    367  0000 ????
    368  0000 ????				      MAC	stx@ply
    369  0000 ????				      stx	[RAM]+{0}
    370  0000 ????				      ENDM
    371  0000 ????
    372  0000 ????				      MAC	sty@ply
    373  0000 ????				      sty	[RAM]+{0}
    374  0000 ????				      ENDM
    375  0000 ????
    376  0000 ????
    377  0000 ????				      MAC	lda@ram
    378  0000 ????				      lda	{0}
    379  0000 ????				      ENDM		;{}
    380  0000 ????
    381  0000 ????				      MAC	ldx@ram
    382  0000 ????				      ldx	{0}
    383  0000 ????				      ENDM		;{}
    384  0000 ????
    385  0000 ????				      MAC	ldy@ram
    386  0000 ????				      ldy	{0}
    387  0000 ????				      ENDM		;{}
    388  0000 ????
    389  0000 ????
    390  0000 ????				      MAC	lda@ply
    391  0000 ????				      lda	{0}
    392  0000 ????				      ENDM		;{}
    393  0000 ????
    394  0000 ????				      MAC	ldx@ply
    395  0000 ????				      ldx	{0}
    396  0000 ????				      ENDM		;{}
    397  0000 ????
    398  0000 ????				      MAC	ldy@ply
    399  0000 ????				      ldy	{0}
    400  0000 ????				      ENDM		;{}
    401  0000 ????
    402  0000 ????
    403  0000 ????				      MAC	adc@ply
    404  0000 ????				      adc	{0}
    405  0000 ????				      ENDM		;{}
    406  0000 ????
    407  0000 ????				      MAC	sbc@ply
    408  0000 ????				      sbc	{0}
    409  0000 ????				      ENDM		;{}
    410  0000 ????
    411  0000 ????				      MAC	cmp@ply
    412  0000 ????				      cmp	{0}
    413  0000 ????				      ENDM		;{}
    414  0000 ????
    415  0000 ????						;---------------------------------------------------------------------------------------------------
    416  0000 ????
    417  0000 ????				      MAC	newrambank
    418  0000 ????						; {1}	     bank name
    419  0000 ????						; {2}	     RAM bank number
    420  0000 ????
    421  0000 ????				      SEG.U	{1}
    422  0000 ????				      ORG	ORIGIN_RAM
    423  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    424  0000 ????			   _BANK_START SET	*
    425  0000 ????			   RAMBANK_{1} SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
    426  0000 ????			   _CURRENT_RAMBANK SET	RAMBANK_{1}
    427  0000 ????			   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    428  0000 ????				      ENDM		; bank name
    429  0000 ????
    430  0000 ????						;---------------------------------------------------------------------------------------------------
    431  0000 ????
    432  0000 ????				      MAC	resync
    433  0000 ????						; resync screen, X and Y == 0 afterwards
    434  0000 ????				      lda	#%10	; make sure VBLANK is ON
    435  0000 ????				      sta	VBLANK
    436  0000 ????
    437  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    438  0000 ????			   .loopResync
    439  0000 ????				      VERTICAL_SYNC
    440  0000 ????
    441  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    442  0000 ????				      lda	Platform
    443  0000 ????				      eor	#PAL_50	; PAL-50?
    444  0000 ????				      bne	.ntsc
    445  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    446  0000 ????			   .ntsc
    447  0000 ????			   .loopWait
    448  0000 ????				      sta	WSYNC
    449  0000 ????				      sta	WSYNC
    450  0000 ????				      dey
    451  0000 ????				      bne	.loopWait
    452  0000 ????				      dex
    453  0000 ????				      bne	.loopResync
    454  0000 ????				      ENDM
    455  0000 ????
    456  0000 ????				      MAC	set_platform
    457  0000 ????						; 00 = NTSC
    458  0000 ????						; 01 = NTSC
    459  0000 ????						; 10 = PAL-50
    460  0000 ????						; 11 = PAL-60
    461  0000 ????				      lda	SWCHB
    462  0000 ????				      rol
    463  0000 ????				      rol
    464  0000 ????				      rol
    465  0000 ????				      and	#%11
    466  0000 ????				      eor	#PAL
    467  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    468  0000 ????				      ENDM
    469  0000 ????
    470  0000 ????
    471  0000 ????						;---------------------------------------------------------------------------------------------------
    472  0000 ????
    473  0000 ????						;    MAC JSROM_SAFE ; {routine}
    474  0000 ????						;    ; Saves bank of routine to variable for later restore.
    475  0000 ????						;    ; Switches to the bank and does a JSR to the routine.
    476  0000 ????
    477  0000 ????						;		  lda #BANK_{1}
    478  0000 ????						;		  sta savedBank
    479  0000 ????						;		  sta SET_BANK
    480  0000 ????						;		  jsr {1}
    481  0000 ????						;    ENDM
    482  0000 ????
    483  0000 ????
    484  0000 ????						;    MAC JSROM ; {routine}
    485  0000 ????
    486  0000 ????						;		  lda #BANK_{1}
    487  0000 ????						;		  sta SET_BANK
    488  0000 ????						;		  jsr {1}
    489  0000 ????						;    ENDM
    490  0000 ????
    491  0000 ????
    492  0000 ????						;    MAC JSRAM
    493  0000 ????						;		  lda #BANK_{1}
    494  0000 ????						;		  sta SET_BANK_RAM
    495  0000 ????						;		  jsr {1}
    496  0000 ????						;    ENDM
    497  0000 ????
    498  0000 ????
    499  0000 ????
    500  0000 ????				      MAC	timecheck
    501  0000 ????				      lda	INTIM
    502  0000 ????				      cmp	#SPEEDOF_{1}
    503  0000 ????				      bcc	{2}
    504  0000 ????				      ENDM		; {ident}, {branch if out of time}
    505  0000 ????
    506  0000 ????
    507  0000 ????				      MAC	timing
    508  0000 ????			   SPEEDOF_{1} =	({2}/64) + 1
    509  0000 ????				      ENDM		; {label}, {cycles}
    510  0000 ????
    511  0000 ????
    512  0000 ????						;---------------------------------------------------------------------------------------------------
    513  0000 ????
    514  0000 ????						; Failsafe call of function in another bank
    515  0000 ????						; This will check the slot #s for current, call to make sure they're not the same!
    516  0000 ????
    517  0000 ????				      MAC	call
    518  0000 ????				      IF	SLOT_{1} == _BANK_SLOT
    519  0000 ????				      ECHO	"ERROR: Incompatible call to function requiring same slot..."
    520  0000 ????				      ECHO	"Cannot switch bank in use for", {0}
    521  0000 ????				      ERR
    522  0000 ????				      ENDIF
    523  0000 ????				      lda	#BANK_{1}
    524  0000 ????				      sta	SET_BANK
    525  0000 ????				      jsr	{1}
    526  0000 ????				      ENDM		; function name
    527  0000 ????
    528  0000 ????
    529  0000 ????
    530  0000 ????						;---------------------------------------------------------------------------------------------------
    531  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						; Chess
      2  0000 ????						; Atari 2600 Chess display system
      3  0000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  0000 ????						; andrew@taswegian.com
      5  0000 ????
      6 U00f9 ????				      SEG.U	variables
      7 U0080					      ORG	$80
      8 U0080
      9 U0080		       00	   squareToDraw ds	1
     10 U0081		       00	   rnd	      ds	1	; random
     11 U0082		       00	   drawDelay  ds	1
     12 U0083		       00	   lastSquareX12 ds	1
     13 U0084
     14 U0084		       00	   drawCount  ds	1
     15 U0085		       00	   fromX12    ds	1
     16 U0086		       00	   toX12      ds	1
     17 U0087		       00	   originX12  ds	1
     18 U0088
     19 U0088		       00	   cursorX12  ds	1
     20 U0089
     21 U0089		       00	   mdelay     ds	1
     22 U008a		       00	   ccur       ds	1
     23 U008b		       00	   aiState    ds	1	; state
     24 U008c		       00	   aiFlashDelay ds	1
     25 U008d
     26 U008d		       00	   aiMoveIndex ds	1
     27 U008e
     28 U008e		       00	   aiFlashPhase ds	1
     29 U008f
     30 U008f		       00 00	   Evaluation ds	2	; tracks value of the board position
     31 U0091
     32 U0091		       00	   currentPiece ds	1
     33 U0092		       00	   currentSquare ds	1
     34 U0093		       00	   enPassantPawn ds	1	; TODO - this belongs in PLY bank
     35 U0094		       00	   currentPly ds	1
     36 U0095
     37 U0095		       00	   sideToMove ds	1	; d7 == side, 0=white, 128 = black
     38 U0096		       00	   fromPiece  ds	1
     39 U0097		       00	   lastPiece  ds	1
     40 U0098		       00	   previousPiece ds	1
     41 U0099
     42 U0099		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     43 U009a		       00 00	   speech_addr ds	2
     44 U009c		       00	   bg	      ds	1
     45 U009d
     46 U009d		       00	   capture    ds	1
     47 U009e
     48 U009e				  -	      IF	DIAGNOSTICS
     49 U009e				  -positionCount ds	3
     50 U009e					      ENDIF
     51 U009e
     52 U009e							;maxPly			  ds 1
     53 U009e		       00	   flagCheck  ds	1	; -1 = no, #KING = yes
     54 U009f		       00	   protecting ds	1
     55 U00a0		       00	   randomness ds	1
------- FILE ./chess.asm
------- FILE overlays.asm LEVEL 2 PASS 4
      0 U00a1					      include	"overlays.asm"
      1 U00a1							; Chess
      2 U00a1							; Atari 2600 Chess display system
      3 U00a1							; Copyright (c) 2019-2020 Andrew Davie
      4 U00a1							; andrew@taswegian.com
      5 U00a1
      6 U00a1							;---------------------------------------------------------------------------------------------------
      7 U00a1							; OVERLAYS!
      8 U00a1							; These variables are overlays, and should be managed with care
      9 U00a1							; They co-exist (each "OVERLAY" starts at the zero-page variable "Overlay"
     10 U00a1							; and thus, overlays cannot be used at the same time (that is, you cannot
     11 U00a1							; use a variable in overlay #1 while at the same time using a variable in
     12 U00a1							; overlay #2
     13 U00a1
     14 U00a1							; for clarity, prefix ALL overlay variables with double-underscore (__)
     15 U00a1
     16 U00a1							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
     17 U00a1							; ensure this by using the VALIDATE_OVERLAY macro
     18 U00a1							;---------------------------------------------------------------------------------------------------
     19 U00a1
     20 U00a1					      MAC	overlay
     21 U00a1				   OVERLAY_NAME SET	{1}
     22 U00a1					      SEG.U	OVERLAY_{1}
     23 U00a1					      org	Overlay
     24 U00a1					      ENDM		; {name}
     25 U00a1
     26 U00a1							;---------------------------------------------------------------------------------------------------
     27 U00a1
     28 U00a1					      MAC	validate_overlay
     29 U00a1					      LIST	OFF
     30 U00a1				   OVERLAY_DELTA SET	* - Overlay
     31 U00a1					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
     32 U00a1				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
     33 U00a1					      ENDIF
     34 U00a1					      IF	OVERLAY_DELTA > OVERLAY_SIZE
     35 U00a1					      ECHO	"Overlay", OVERLAY_NAME, "is too big!"
     36 U00a1					      ECHO	"REQUIRED SIZE =", OVERLAY_DELTA
     37 U00a1					      ERR
     38 U00a1					      ENDIF
     39 U00a1					      LIST	ON
     40 U00a1					      ECHO	OVERLAY_NAME, "-", OVERLAY_SIZE - ( * - Overlay ), "bytes available"
     41 U00a1					      ENDM
     42 U00a1
     43 U00a1							;---------------------------------------------------------------------------------------------------
     44 U00a1
     45 U00a1				   OVERLAY_SIZE SET	$4C	; maximum size
     46 U00a1				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	0
     47 U00a1
     48 U00a1
     49 U00a1							; This overlay variable is used for the overlay variables.  That's OK.
     50 U00a1							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
     51 U00a1							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
     52 U00a1							; (especially the latter ones) are only used in rare occasions.
     53 U00a1
     54 U00a1							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
     55 U00a1							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
     56 U00a1
      0 U00a1					      DEF	Overlay
      1 U00a1				   SLOT_Overlay SET	_BANK_SLOT
      2 U00a1				   BANK_Overlay SET	SLOT_Overlay + _CURRENT_BANK
      3 U00a1				   Overlay
      4 U00a1				   TEMPORARY_VAR SET	Overlay
      5 U00a1				   TEMPORARY_OFFSET SET	0
      6 U00a1				   VAR_BOUNDARY_Overlay SET	TEMPORARY_OFFSET
      7 U00a1				   FUNCTION_NAME SET	Overlay
     58 U00a1		       00 00 00 00*	      ds	OVERLAY_SIZE	;--> overlay (share) variables
     59 U00ed				   END_OF_OVERLAY
     60 U00ed
     61 U00ed							;---------------------------------------------------------------------------------------------------
     62 U00ed							; And now... the overlays....
     63 U00ed
 ---- OVERLAYS ( $4c bytes ) ----
     64 U00ed					      ECHO	"---- OVERLAYS (", OVERLAY_SIZE, "bytes ) ----"
     65 U00ed
     66 U00ed							;---------------------------------------------------------------------------------------------------
     67 U00ed
     68 U00ed							; Some overlays are used across multiple routines/calls, and they will need to be defined
     69 U00ed							; "globally" in this file.
     70 U00ed
      0 U00ed					      VAR	__pieceShapeBuffer, PIECE_SHAPE_SIZE
      1 U00ed		       00 a1	   __pieceShapeBuffer =	TEMPORARY_VAR
      2 U00ed				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + PIECE_SHAPE_SIZE
      3 U00ed
      4 U00ed				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00ed					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00ed				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00ed					      ENDIF
      8 U00ed				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00ed				  -	      ECHO	"Temporary Variable", __pieceShapeBuffer, "overflow!"
     10 U00ed				  -	      ERR
     11 U00ed					      ENDIF
     12 U00ed					      LIST	ON
      0 U00ed					      VAR	__ptr, 2
      1 U00ed		       00 e9	   __ptr      =	TEMPORARY_VAR
      2 U00ed				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3 U00ed
      4 U00ed				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00ed					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00ed				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00ed					      ENDIF
      8 U00ed				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00ed				  -	      ECHO	"Temporary Variable", __ptr, "overflow!"
     10 U00ed				  -	      ERR
     11 U00ed					      ENDIF
     12 U00ed					      LIST	ON
      0 U00ed					      VAR	__ptr2, 2
      1 U00ed		       00 eb	   __ptr2     =	TEMPORARY_VAR
      2 U00ed				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3 U00ed
      4 U00ed				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00ed					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00ed				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00ed					      ENDIF
      8 U00ed				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00ed				  -	      ECHO	"Temporary Variable", __ptr2, "overflow!"
     10 U00ed				  -	      ERR
     11 U00ed					      ENDIF
     12 U00ed					      LIST	ON
     74 U00ed
     75 U00ed							;---------------------------------------------------------------------------------------------------
     76 U00ed
     77 U00ed
     78 U00ed					      ORG	END_OF_OVERLAY
 ---- END OF OVERLAYS ----
     79 U00ed					      ECHO	"---- END OF OVERLAYS ----"
 MAXIMUM OVERLAY SIZE NEEDED =  $4c
     80 U00ed					      ECHO	"MAXIMUM OVERLAY SIZE NEEDED = ", MAXIMUM_REQUIRED_OVERLAY_SIZE
     81 U00ed
     82 U00ed							;EOF
------- FILE ./chess.asm
------- FILE stack.asm LEVEL 2 PASS 4
      0 U00ed					      include	"stack.asm"
      1 U00ed							; Chess
      2 U00ed							; Atari 2600 Chess display system
      3 U00ed							; Copyright (c) 2019-2020 Andrew Davie
      4 U00ed							; andrew@taswegian.com
      5 U00ed
      6 U00ed
      7 U00ed		       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
      8 U00ed
      9 U00ed		       00 00 00 00*	      ds	RESERVED_FOR_STACK
     10 U00f9
     11 U00f9							; WARNING/NOTE - the alphabeta search violates the above size constraints
     12 U00f9							; HOWEVER, the "OVERLAY" segment is beneath this, and will be stomped, depending on # plys
     13 U00f9							;  but since overlay is not generally stressed during alphabeta, we're good.
------- FILE ./chess.asm
    535 U00f9
 FREE BYTES IN ZERO PAGE =  $6
    536 U00f9					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    537 U00f9				  -	      IF	* > $FF
    538 U00f9				  -	      ERR	"Zero Page overflow!"
    539 U00f9					      ENDIF
    540 U00f9
    541 U00f9							;------------------------------------------------------------------------------
    542 U00f9							;##############################################################################
    543 U00f9							;------------------------------------------------------------------------------
    544 U00f9
    545 U00f9							; NOW THE VERY INTERESTING '3E' RAM BANKS
    546 U00f9							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 512 bytes TOTAL ACCESSIBLE
    547 U00f9							; IN A 1K MEMORY SPACE
    548 U00f9
      0 U00f9					      SLOT	0
      1 U00f9				  -	      IF	(0 < 0) || (0 > 3)
      2 U00f9				  -	      ECHO	"Illegal bank address/segment location", 0
      3 U00f9				  -	      ERR
      4 U00f9					      ENDIF
      5 U00f9				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      6 U00f9				   _BANK_SLOT SET	0 * 64
      0 U00f9					      NEWRAMBANK	CHESS_BOARD_ROW
      1 U00f9
      2 U00f9
      3 U00f9
      4 U0000 ????				      SEG.U	CHESS_BOARD_ROW
      5 U0000					      ORG	ORIGIN_RAM
      6 U0000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0000				   _BANK_START SET	*
      8 U0000				   RAMBANK_CHESS_BOARD_ROW SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0000				   _CURRENT_RAMBANK SET	RAMBANK_CHESS_BOARD_ROW
     10 U0000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U0000					      REPEAT	(CHESSBOARD_ROWS) - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U0000
      2 U0000
      3 U0000
      4 U1c00 ????				      SEG.U	.DUMMY
      5 U0400					      ORG	ORIGIN_RAM
      6 U0400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0400				   _BANK_START SET	*
      8 U0400				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400
      2 U0400
      3 U0400
      4 U0400					      SEG.U	.DUMMY
      5 U0800					      ORG	ORIGIN_RAM
      6 U0800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0800				   _BANK_START SET	*
      8 U0800				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800
      2 U0800
      3 U0800
      4 U0800					      SEG.U	.DUMMY
      5 U0c00					      ORG	ORIGIN_RAM
      6 U0c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0c00				   _BANK_START SET	*
      8 U0c00				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00
      2 U0c00
      3 U0c00
      4 U0c00					      SEG.U	.DUMMY
      5 U1000					      ORG	ORIGIN_RAM
      6 U1000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1000				   _BANK_START SET	*
      8 U1000				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000
      2 U1000
      3 U1000
      4 U1000					      SEG.U	.DUMMY
      5 U1400					      ORG	ORIGIN_RAM
      6 U1400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1400				   _BANK_START SET	*
      8 U1400				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400
      2 U1400
      3 U1400
      4 U1400					      SEG.U	.DUMMY
      5 U1800					      ORG	ORIGIN_RAM
      6 U1800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1800				   _BANK_START SET	*
      8 U1800				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    551 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800
      2 U1800
      3 U1800
      4 U1800					      SEG.U	.DUMMY
      5 U1c00					      ORG	ORIGIN_RAM
      6 U1c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1c00				   _BANK_START SET	*
      8 U1c00				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    553 U1c00					      REPEND
    554 U1c00
    555 U1c00							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    556 U1c00							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    557 U1c00							; The variable definitions are also in that ROM bank (even though they're RAM :)
    558 U1c00
    559 U1c00							; Now we have the actual graphics data for each of the rows.  This consists of an
    560 U1c00							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    561 U1c00							; character shapes are masked/copied. The depth of the character shapes may be
    562 U1c00							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    563 U1c00							; a multiple of 3, so that the RGB scanlines match at character joins.
    564 U1c00
    565 U1c00							; We have one bank for each chessboard row.  These banks are duplicates of the above,
    566 U1c00							; accessed via the above labels but with the appropriate bank switched in.
    567 U1c00
    568 U1c00							;---------------------------------------------------------------------------------------------------
    569 U1c00
    570 U1c00
    571 U1c00		       00 fe	   RND_EOR_VAL =	$FE	;B4
    572 U1c00
    573 U1c00					      MAC	next_random
    574 U1c00					      lda	rnd
    575 U1c00					      lsr
    576 U1c00					      bcc	.skipEOR
    577 U1c00					      eor	#RND_EOR_VAL
    578 U1c00				   .skipEOR   sta	rnd
    579 U1c00					      ENDM
    580 U1c00
    581 U1c00							;--------------------------------------------------------------------------------
    582 U1c00
    583 U1c00					      MAC	phase
    584 U1c00					      lda	#{1}
    585 U1c00					      sta	aiState
    586 U1c00					      ENDM		;#
    587 U1c00
    588 U1c00
    589 U1c00							;--------------------------------------------------------------------------------
    590 U1c00
    591 U1c00					      MAC	common_vars_alphabeta
    592 U1c00
    593 U1c00					      VAR	__thinkbar, 1
    594 U1c00					      VAR	__toggle, 1
    595 U1c00
    596 U1c00					      VAR	__bestMove, 1
    597 U1c00					      VAR	__alpha, 2
    598 U1c00					      VAR	__beta, 2
    599 U1c00					      VAR	__negaMax, 2
    600 U1c00					      VAR	__value, 2
    601 U1c00
    602 U1c00					      VAR	__quiesceCapOnly, 1
    603 U1c00
    604 U1c00					      ENDM
    605 U1c00
    606 U1c00
    607 U1c00							;---------------------------------------------------------------------------------------------------
    608 U1c00
------- FILE BANK_FIRST@0.asm LEVEL 2 PASS 4
      0 U1c00					      include	"BANK_FIRST@0.asm"	; MUST be first in ROM - contains reset vectors
      1 U1c00							; Chess
      2 U1c00							; Copyright (c) 2019-2020 Andrew Davie
      3 U1c00							; andrew@taswegian.com
      4 U1c00
      5 U1c00
      6 U1c00							; SLOT0 - screen draw, state machine dispatcher
      7 U1c00							; SLOT1 - anything
      8 U1c00							; SLOT2 - moves/ply
      9 U1c00							; SLOT3 - board
     10 U1c00
     11 U1c00
     12 U1c00
     13 U1c00
     14 U1c00
     15 U1c00
      0 U1c00					      SLOT	0
      1 U1c00				  -	      IF	(0 < 0) || (0 > 3)
      2 U1c00				  -	      ECHO	"Illegal bank address/segment location", 0
      3 U1c00				  -	      ERR
      4 U1c00					      ENDIF
      5 U1c00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      6 U1c00				   _BANK_SLOT SET	0 * 64
     17 U1c00
     18 U1c00							;---------------------------------------------------------------------------------------------------
     19 U1c00							;#########################################  FIXED BANK  ############################################
     20 U1c00							;---------------------------------------------------------------------------------------------------
     21 U1c00
     22 U1c00				   _ORIGIN    SET	_FIRST_BANK
     23 U1c00
      0 U1c00					      NEWBANK	THE_FIRST_BANK
      1  0332 ????				      SEG	THE_FIRST_BANK
      2  0000					      ORG	_ORIGIN
      3  0000					      RORG	_BANK_ADDRESS_ORIGIN
      4  0000				   _BANK_START SET	*
      5  0000				   THE_FIRST_BANK_START SET	*
      6  0000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0000				   THE_FIRST_BANK SET	_BANK_SLOT + _CURRENT_BANK
      8  0000				   _ORIGIN    SET	_ORIGIN + 1024
     25  0000					      RORG	$f000
     26  0000
     27  0000							;---------------------------------------------------------------------------------------------------
     28  0000
      0  0000					      DEF	StartupBankReset
      1  0000				   SLOT_StartupBankReset SET	_BANK_SLOT
      2  0000				   BANK_StartupBankReset SET	SLOT_StartupBankReset + _CURRENT_BANK
      3  0000				   StartupBankReset
      4  0000				   TEMPORARY_VAR SET	Overlay
      5  0000				   TEMPORARY_OFFSET SET	0
      6  0000				   VAR_BOUNDARY_StartupBankReset SET	TEMPORARY_OFFSET
      7  0000				   FUNCTION_NAME SET	StartupBankReset
     30  0000					      SUBROUTINE
     31  0000
      0  0000					      VEND	StartupBankReset
      1  0000				  -	      IFNCONST	StartupBankReset
      2  0000				  -	      ECHO	"Incorrect VEND label", StartupBankReset
      3  0000				  -	      ERR
      4  0000					      ENDIF
      5  0000		       00 a1	   VAREND_StartupBankReset =	TEMPORARY_VAR
     33  0000
     34  0000							; On startup, 3E+ switches banks 0 and 3 to the 1st ROM bank (1K), from which the reset
     35  0000							; vector is obtained from bank 0 (+$FFC). Chess3E+ (maybe) will leave this bank (3) alone
     36  0000							; so that a system reset will always have the reset vectors available at FFFC, where expected
     37  0000
     38  0000		       a2 ff		      ldx	#$FF
     39  0002		       9a		      txs
     40  0003
      0  0003					      CALL	CartInit
      1  0003				  -	      IF	SLOT_CartInit == _BANK_SLOT
      2  0003				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0003				  -	      ECHO	"Cannot switch bank in use for", CartInit
      4  0003				  -	      ERR
      5  0003					      ENDIF
      6  0003		       a9 41		      lda	#BANK_CartInit
      7  0005		       85 3f		      sta	SET_BANK
      8  0007		       20 00 f4 	      jsr	CartInit
      0  000a					      CALL	SetupBanks
      1  000a				  -	      IF	SLOT_SetupBanks == _BANK_SLOT
      2  000a				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  000a				  -	      ECHO	"Cannot switch bank in use for", SetupBanks
      4  000a				  -	      ERR
      5  000a					      ENDIF
      6  000a		       a9 41		      lda	#BANK_SetupBanks
      7  000c		       85 3f		      sta	SET_BANK
      8  000e		       20 3a f4 	      jsr	SetupBanks
      0  0011					      CALL	InitialisePieceSquares
      1  0011				  -	      IF	SLOT_InitialisePieceSquares == _BANK_SLOT
      2  0011				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0011				  -	      ECHO	"Cannot switch bank in use for", InitialisePieceSquares
      4  0011				  -	      ERR
      5  0011					      ENDIF
      6  0011		       a9 41		      lda	#BANK_InitialisePieceSquares
      7  0013		       85 3f		      sta	SET_BANK
      8  0015		       20 9a f4 	      jsr	InitialisePieceSquares
     44  0018		       20 d1 f1 	      jsr	ListPlayerMoves	;@0
     45  001b
     46  001b
     47  001b				   .StartFrame
     48  001b
     49  001b
     50  001b							; START OF FRAME
     51  001b
     52  001b		       a9 0e		      lda	#%1110	; VSYNC ON
     53  001d		       85 42	   .loopVSync3 sta	WSYNC
     54  001f		       85 40		      sta	VSYNC
     55  0021		       4a		      lsr
     56  0022		       d0 f9		      bne	.loopVSync3	; branch until VYSNC has been reset
     57  0024
     58  0024		       85 41		      sta	VBLANK
     59  0026
     60  0026		       a0 2e		      ldy	#TIME_PART_1
     61  0028		       8c 96 02 	      sty	TIM64T
     62  002b
     63  002b							; LOTS OF PROCESSING TIME - USE IT
     64  002b
     65  002b
     66  002b
     67  002b		       20 59 f1 	      jsr	AiStateMachine
     68  002e
     69  002e				  -	      IF	ASSERTS
     70  002e				  -			; Catch timer expired already
     71  002e				  -			;		      bit TIMINT
     72  002e				  -			;.whoops	      bmi .whoops
     73  002e					      ENDIF
     74  002e
     75  002e
     76  002e		       2c 85 02    .wait      bit	TIMINT
     77  0031		       10 fb		      bpl	.wait
     78  0033
     79  0033
     80  0033							; START OF VISIBLE SCANLINES
     81  0033
     82  0033
      0  0033					      CALL	longD
      1  0033				  -	      IF	SLOT_longD == _BANK_SLOT
      2  0033				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0033				  -	      ECHO	"Cannot switch bank in use for", longD
      4  0033				  -	      ERR
      5  0033					      ENDIF
      6  0033		       a9 93		      lda	#BANK_longD
      7  0035		       85 3f		      sta	SET_BANK
      8  0037		       20 14 f8 	      jsr	longD
     84  003a
     85  003a
     86  003a		       a2 80		      ldx	#SLOT_DrawRow	; + BANK_DrawRow
     87  003c		       86 3e		      stx	SET_BANK_RAM
     88  003e		       20 03 f9 	      jsr	DrawRow	; draw the ENTIRE visible screen!
     89  0041
      0  0041					      CALL	tidySc
      1  0041				  -	      IF	SLOT_tidySc == _BANK_SLOT
      2  0041				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0041				  -	      ECHO	"Cannot switch bank in use for", tidySc
      4  0041				  -	      ERR
      5  0041					      ENDIF
      6  0041		       a9 93		      lda	#BANK_tidySc
      7  0043		       85 3f		      sta	SET_BANK
      8  0045		       20 00 f8 	      jsr	tidySc
     91  0048
     92  0048		       20 59 f1 	      jsr	AiStateMachine
     93  004b
     94  004b		       ad 84 02 	      lda	INTIM
     95  004e		       c9 14		      cmp	#20
     96  0050		       90 24		      bcc	.notnow
     97  0052
     98  0052							;CALL GameSpeak
      0  0052					      CALL	PositionSprites
      1  0052				  -	      IF	SLOT_PositionSprites == _BANK_SLOT
      2  0052				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0052				  -	      ECHO	"Cannot switch bank in use for", PositionSprites
      4  0052				  -	      ERR
      5  0052					      ENDIF
      6  0052		       a9 48		      lda	#BANK_PositionSprites
      7  0054		       85 3f		      sta	SET_BANK
      8  0056		       20 00 f6 	      jsr	PositionSprites
    100  0059
    101  0059
    102  0059					      IF	1
    103  0059							; "draw" sprite shapes into row banks
    104  0059
    105  0059		       a2 07		      ldx	#7
    106  005b		       8a	   zapem      txa
    107  005c		       18		      clc
    108  005d		       69 80		      adc	#SLOT_DrawRow
    109  005f		       85 3e		      sta	SET_BANK_RAM
      0  0061					      CALL	WriteBlank	;@3
      1  0061				  -	      IF	SLOT_WriteBlank == _BANK_SLOT
      2  0061				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0061				  -	      ECHO	"Cannot switch bank in use for", WriteBlank
      4  0061				  -	      ERR
      5  0061					      ENDIF
      6  0061		       a9 c3		      lda	#BANK_WriteBlank
      7  0063		       85 3f		      sta	SET_BANK
      8  0065		       20 0b fc 	      jsr	WriteBlank
    111  0068		       ca		      dex
    112  0069		       10 f0		      bpl	zapem
    113  006b
    114  006b		       a9 c3		      lda	#BANK_WriteCursor
    115  006d		       85 3f		      sta	SET_BANK
      0  006f					      CALL	WriteCursor	;@3
      1  006f				  -	      IF	SLOT_WriteCursor == _BANK_SLOT
      2  006f				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  006f				  -	      ECHO	"Cannot switch bank in use for", WriteCursor
      4  006f				  -	      ERR
      5  006f					      ENDIF
      6  006f		       a9 c3		      lda	#BANK_WriteCursor
      7  0071		       85 3f		      sta	SET_BANK
      8  0073		       20 34 fc 	      jsr	WriteCursor
    117  0076					      ENDIF
    118  0076
    119  0076				   .notnow
    120  0076
    121  0076		       2c 85 02    .waitTime  bit	TIMINT
    122  0079		       10 fb		      bpl	.waitTime
    123  007b
    124  007b		       4c 1b f0 	      jmp	.StartFrame
    125  007e
    126  007e
    127  007e							;---------------------------------------------------------------------------------------------------
    128  007e
      0  007e					      DEF	ThinkBar
      1  007e				   SLOT_ThinkBar SET	_BANK_SLOT
      2  007e				   BANK_ThinkBar SET	SLOT_ThinkBar + _CURRENT_BANK
      3  007e				   ThinkBar
      4  007e				   TEMPORARY_VAR SET	Overlay
      5  007e				   TEMPORARY_OFFSET SET	0
      6  007e				   VAR_BOUNDARY_ThinkBar SET	TEMPORARY_OFFSET
      7  007e				   FUNCTION_NAME SET	ThinkBar
    130  007e					      SUBROUTINE
    131  007e
    132  007e				  -	      IF	DIAGNOSTICS
    133  007e				  -
    134  007e				  -	      inc	positionCount
    135  007e				  -	      bne	.p1
    136  007e				  -	      inc	positionCount+1
    137  007e				  -	      bne	.p1
    138  007e				  -	      inc	positionCount+2
    139  007e				  -.p1
    140  007e					      ENDIF
    141  007e
    142  007e							; The 'thinkbar' pattern...
    143  007e
    144  007e		       a9 00		      lda	#0
    145  0080		       a4 4c		      ldy	INPT4
    146  0082		       30 0a		      bmi	.doThink
    147  0084
    148  0084		       e6 a1		      inc	__thinkbar
    149  0086		       a5 a1		      lda	__thinkbar
    150  0088		       29 0f		      and	#15
    151  008a		       a8		      tay
    152  008b		       b9 93 f0 	      lda	SynapsePattern,y
    153  008e
    154  008e		       85 4f	   .doThink   sta	PF2
    155  0090		       85 4e		      sta	PF1
    156  0092		       60		      rts
    157  0093
    158  0093
    159  0093
    160  0093				   SynapsePattern
    161  0093
    162  0093		       c1		      .byte.b	%11000001
    163  0094		       60		      .byte.b	%01100000
    164  0095		       30		      .byte.b	%00110000
    165  0096		       18		      .byte.b	%00011000
    166  0097		       0c		      .byte.b	%00001100
    167  0098		       06		      .byte.b	%00000110
    168  0099		       83		      .byte.b	%10000011
    169  009a		       c1		      .byte.b	%11000001
    170  009b
    171  009b		       83		      .byte.b	%10000011
    172  009c		       06		      .byte.b	%00000110
    173  009d		       0c		      .byte.b	%00001100
    174  009e		       18		      .byte.b	%00011000
    175  009f		       30		      .byte.b	%00110000
    176  00a0		       60		      .byte.b	%01100000
    177  00a1		       c1		      .byte.b	%11000001
    178  00a2		       83		      .byte.b	%10000011
    179  00a3
    180  00a3
    181  00a3							;---------------------------------------------------------------------------------------------------
    182  00a3
      0  00a3					      DEF	CopySinglePiece	;@0 - uses @2
      1  00a3				   SLOT_CopySinglePiece SET	_BANK_SLOT
      2  00a3				   BANK_CopySinglePiece SET	SLOT_CopySinglePiece + _CURRENT_BANK
      3  00a3				   CopySinglePiece
      4  00a3				   TEMPORARY_VAR SET	Overlay
      5  00a3				   TEMPORARY_OFFSET SET	0
      6  00a3				   VAR_BOUNDARY_CopySinglePiece SET	TEMPORARY_OFFSET
      7  00a3				   FUNCTION_NAME SET	CopySinglePiece
    184  00a3					      SUBROUTINE
      0  00a3					      TIMING	COPYSINGLEPIECE, (2600)
      1  00a3		       00 29	   SPEEDOF_COPYSINGLEPIECE =	((2600)/64) + 1
    186  00a3
      0  00a3					      REFER	aiDrawEntireBoard
      1  00a3				  -	      IF	VAREND_aiDrawEntireBoard > TEMPORARY_VAR
      2  00a3				  -TEMPORARY_VAR SET	VAREND_aiDrawEntireBoard
      3  00a3					      ENDIF
      0  00a3					      REFER	aiSpecialMoveFixup
      1  00a3					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  00a3				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  00a3					      ENDIF
      0  00a3					      REFER	aiWriteStartPieceBlank
      1  00a3				  -	      IF	VAREND_aiWriteStartPieceBlank > TEMPORARY_VAR
      2  00a3				  -TEMPORARY_VAR SET	VAREND_aiWriteStartPieceBlank
      3  00a3					      ENDIF
      0  00a3					      REFER	aiDrawPart2
      1  00a3				  -	      IF	VAREND_aiDrawPart2 > TEMPORARY_VAR
      2  00a3				  -TEMPORARY_VAR SET	VAREND_aiDrawPart2
      3  00a3					      ENDIF
      0  00a3					      REFER	aiMarchB
      1  00a3				  -	      IF	VAREND_aiMarchB > TEMPORARY_VAR
      2  00a3				  -TEMPORARY_VAR SET	VAREND_aiMarchB
      3  00a3					      ENDIF
      0  00a3					      REFER	aiFinalFlash
      1  00a3				  -	      IF	VAREND_aiFinalFlash > TEMPORARY_VAR
      2  00a3				  -TEMPORARY_VAR SET	VAREND_aiFinalFlash
      3  00a3					      ENDIF
      0  00a3					      REFER	showMoveCaptures
      1  00a3				  -	      IF	VAREND_showMoveCaptures > TEMPORARY_VAR
      2  00a3				  -TEMPORARY_VAR SET	VAREND_showMoveCaptures
      3  00a3					      ENDIF
      0  00a3					      REFER	aiMarchToTargetA
      1  00a3				  -	      IF	VAREND_aiMarchToTargetA > TEMPORARY_VAR
      2  00a3				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetA
      3  00a3					      ENDIF
      0  00a3					      REFER	aiMarchB2
      1  00a3				  -	      IF	VAREND_aiMarchB2 > TEMPORARY_VAR
      2  00a3				  -TEMPORARY_VAR SET	VAREND_aiMarchB2
      3  00a3					      ENDIF
      0  00a3					      REFER	aiMarchToTargetB
      1  00a3				  -	      IF	VAREND_aiMarchToTargetB > TEMPORARY_VAR
      2  00a3				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetB
      3  00a3					      ENDIF
      0  00a3					      REFER	aiSelectDestinationSquare
      1  00a3				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  00a3				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  00a3					      ENDIF
      0  00a3					      REFER	aiPromotePawnStart
      1  00a3				  -	      IF	VAREND_aiPromotePawnStart > TEMPORARY_VAR
      2  00a3				  -TEMPORARY_VAR SET	VAREND_aiPromotePawnStart
      3  00a3					      ENDIF
      0  00a3					      REFER	aiChoosePromotePiece
      1  00a3				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  00a3				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  00a3					      ENDIF
      0  00a3					      VEND	CopySinglePiece
      1  00a3				  -	      IFNCONST	CopySinglePiece
      2  00a3				  -	      ECHO	"Incorrect VEND label", CopySinglePiece
      3  00a3				  -	      ERR
      4  00a3					      ENDIF
      5  00a3		       00 ad	   VAREND_CopySinglePiece =	TEMPORARY_VAR
    201  00a3
    202  00a3							; WARNING: CANNOT USE VAR/OVERLAY IN ANY ROUTINE CALLING THIS!!
    203  00a3							; ALSO CAN'T USE IN THIS ROUTINE
    204  00a3							; This routine will STOMP on those vars due to __pieceShapeBuffer occupying whole overlay
    205  00a3							; @2150 max
    206  00a3							; = 33 TIM64T
    207  00a3
    208  00a3							; Board is [SLOT3]
    209  00a3
    210  00a3
      0  00a3					      CALL	CopySetup	;@2
      1  00a3				  -	      IF	SLOT_CopySetup == _BANK_SLOT
      2  00a3				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  00a3				  -	      ECHO	"Cannot switch bank in use for", CopySetup
      4  00a3				  -	      ERR
      5  00a3					      ENDIF
      6  00a3		       a9 93		      lda	#BANK_CopySetup
      7  00a5		       85 3f		      sta	SET_BANK
      8  00a7		       20 58 f8 	      jsr	CopySetup
    212  00aa
    213  00aa
      0  00aa					      DEF	InterceptMarkerCopy
      1  00aa				   SLOT_InterceptMarkerCopy SET	_BANK_SLOT
      2  00aa				   BANK_InterceptMarkerCopy SET	SLOT_InterceptMarkerCopy + _CURRENT_BANK
      3  00aa				   InterceptMarkerCopy
      4  00aa				   TEMPORARY_VAR SET	Overlay
      5  00aa				   TEMPORARY_OFFSET SET	0
      6  00aa				   VAR_BOUNDARY_InterceptMarkerCopy SET	TEMPORARY_OFFSET
      7  00aa				   FUNCTION_NAME SET	InterceptMarkerCopy
    215  00aa					      SUBROUTINE
    216  00aa
    217  00aa
    218  00aa							; Copy a piece shape (3 PF bytes wide x 24 lines) to the RAM buffer
    219  00aa							; y = piece index
    220  00aa
    221  00aa		       a9 93		      lda	#BANK_PIECE_VECTOR_BANK
    222  00ac		       85 3f		      sta	SET_BANK	;@2
    223  00ae
    224  00ae		       b9 a3 f8 	      lda	PIECE_VECTOR_LO,y
    225  00b1		       85 e9		      sta	__ptr
    226  00b3		       b9 33 f9 	      lda	PIECE_VECTOR_HI,y
    227  00b6		       85 ea		      sta	__ptr+1
    228  00b8		       b9 c3 f9 	      lda	PIECE_VECTOR_BANK,y
    229  00bb		       85 3f		      sta	SET_BANK	;@2
    230  00bd
    231  00bd		       a0 47		      ldy	#PIECE_SHAPE_SIZE-1
    232  00bf		       b1 e9	   .copy      lda	(__ptr),y
    233  00c1		       99 a1 00 	      sta	__pieceShapeBuffer,y
    234  00c4		       88		      dey
    235  00c5		       10 f8		      bpl	.copy
    236  00c7
    237  00c7		       a5 80		      lda	squareToDraw
    238  00c9		       38		      sec
    239  00ca		       a2 0a		      ldx	#10
    240  00cc		       e9 0a	   .sub10     sbc	#10
    241  00ce		       ca		      dex
    242  00cf		       b0 fb		      bcs	.sub10
    243  00d1
    244  00d1		       69 08		      adc	#8
    245  00d3		       c9 04		      cmp	#4	; CS = right side of screen
    246  00d5
    247  00d5		       8a		      txa
    248  00d6		       09 80		      ora	#[SLOT2]
    249  00d8		       85 3e		      sta	SET_BANK_RAM	;@2		 ; bank row
    250  00da
    251  00da		       20 ce f2 	      jsr	CopyPieceToRowBitmap	;@3
    252  00dd		       60		      rts
    253  00de
    254  00de
    255  00de							;---------------------------------------------------------------------------------------------------
    256  00de
    257  00de				   P	      SET	0
    258  00de					      MAC	ain
    259  00de				   AI_{1}     SET	P
    260  00de				   P	      SET	P+1
    261  00de					      ENDM
    262  00de
    263  00de					      MAC	lo
    264  00de					      .byte	<ai{1}
    265  00de					      ENDM
    266  00de
    267  00de					      MAC	hi
    268  00de					      .byte	>ai{1}
    269  00de					      ENDM
    270  00de
    271  00de					      MAC	bk
    272  00de					      .byte	BANK_ai{1}
    273  00de					      ENDM
    274  00de
    275  00de
    276  00de		       00 28	   ONCEPERFRAME =	40
    277  00de
    278  00de					      MAC	tabdef
    279  00de
    280  00de					      {1}	FlashComputerMove	; 0
    281  00de					      {1}	BeginSelectMovePhase	; 1
    282  00de					      {1}	SelectStartSquare	; 2
    283  00de					      {1}	StartSquareSelected	; 3
    284  00de					      {1}	DrawMoves	; 4
    285  00de					      {1}	ShowMoveCaptures	; 5
    286  00de					      {1}	SlowFlash	; 6
    287  00de					      {1}	UnDrawTargetSquares	; 7
    288  00de					      {1}	SelectDestinationSquare	; 8
    289  00de					      {1}	Quiescent	; 9
    290  00de					      {1}	ReselectDebounce	; 10
    291  00de					      {1}	StartMoveGen	; 11
    292  00de					      {1}	StepMoveGen	; 12
    293  00de					      {1}	StartClearBoard	; 13
    294  00de					      {1}	ClearEachRow	; 14
    295  00de					      {1}	DrawEntireBoard	; 15
    296  00de					      {1}	DrawPart2	; 16
    297  00de					      {1}	DrawPart3	; 17
    298  00de					      {1}	GenerateMoves	; 18
    299  00de					      {1}	ComputerMove	; 19
    300  00de					      {1}	MoveIsSelected	; 20
    301  00de					      {1}	WriteStartPieceBlank	; 21
    302  00de					      {1}	MarchToTargetA	; 22
    303  00de					      {1}	MarchA2	; 23
    304  00de					      {1}	MarchB	; 24
    305  00de					      {1}	MarchToTargetB	; 25
    306  00de					      {1}	MarchB2	; 26
    307  00de					      {1}	FinalFlash	; 27
    308  00de					      {1}	SpecialMoveFixup	; 28
    309  00de					      {1}	InCheckBackup	; 29
    310  00de					      {1}	InCheckDelay	; 30
    311  00de					      {1}	PromotePawnStart	; 31
    312  00de					      {1}	RollPromotionPiece	; 32
    313  00de					      {1}	ChoosePromotePiece	; 33
    314  00de					      {1}	ChooseDebounce	; 34
    315  00de					      {1}	CheckMate	; 35
    316  00de					      {1}	Draw	; 36
    317  00de					      {1}	DelayAfterMove	; 37
    318  00de					      {1}	DelayAfterMove2	; 38
    319  00de					      {1}	DelayAfterPlaced	; 39
    320  00de					      {1}	DelayAfterPlaced2	; 40
    321  00de
    322  00de					      ENDM		; {1} = macro to use
    323  00de
      0  00de					      TABDEF	AIN
      1  00de
      0  00de					      AIN	FlashComputerMove
      1  00de				   AI_FlashComputerMove SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	BeginSelectMovePhase
      1  00de				   AI_BeginSelectMovePhase SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	SelectStartSquare
      1  00de				   AI_SelectStartSquare SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	StartSquareSelected
      1  00de				   AI_StartSquareSelected SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	DrawMoves
      1  00de				   AI_DrawMoves SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	ShowMoveCaptures
      1  00de				   AI_ShowMoveCaptures SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	SlowFlash
      1  00de				   AI_SlowFlash SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	UnDrawTargetSquares
      1  00de				   AI_UnDrawTargetSquares SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	SelectDestinationSquare
      1  00de				   AI_SelectDestinationSquare SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	Quiescent
      1  00de				   AI_Quiescent SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	ReselectDebounce
      1  00de				   AI_ReselectDebounce SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	StartMoveGen
      1  00de				   AI_StartMoveGen SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	StepMoveGen
      1  00de				   AI_StepMoveGen SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	StartClearBoard
      1  00de				   AI_StartClearBoard SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	ClearEachRow
      1  00de				   AI_ClearEachRow SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	DrawEntireBoard
      1  00de				   AI_DrawEntireBoard SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	DrawPart2
      1  00de				   AI_DrawPart2 SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	DrawPart3
      1  00de				   AI_DrawPart3 SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	GenerateMoves
      1  00de				   AI_GenerateMoves SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	ComputerMove
      1  00de				   AI_ComputerMove SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	MoveIsSelected
      1  00de				   AI_MoveIsSelected SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	WriteStartPieceBlank
      1  00de				   AI_WriteStartPieceBlank SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	MarchToTargetA
      1  00de				   AI_MarchToTargetA SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	MarchA2
      1  00de				   AI_MarchA2 SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	MarchB
      1  00de				   AI_MarchB  SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	MarchToTargetB
      1  00de				   AI_MarchToTargetB SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	MarchB2
      1  00de				   AI_MarchB2 SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	FinalFlash
      1  00de				   AI_FinalFlash SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	SpecialMoveFixup
      1  00de				   AI_SpecialMoveFixup SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	InCheckBackup
      1  00de				   AI_InCheckBackup SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	InCheckDelay
      1  00de				   AI_InCheckDelay SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	PromotePawnStart
      1  00de				   AI_PromotePawnStart SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	RollPromotionPiece
      1  00de				   AI_RollPromotionPiece SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	ChoosePromotePiece
      1  00de				   AI_ChoosePromotePiece SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	ChooseDebounce
      1  00de				   AI_ChooseDebounce SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	CheckMate
      1  00de				   AI_CheckMate SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	Draw
      1  00de				   AI_Draw    SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	DelayAfterMove
      1  00de				   AI_DelayAfterMove SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	DelayAfterMove2
      1  00de				   AI_DelayAfterMove2 SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	DelayAfterPlaced
      1  00de				   AI_DelayAfterPlaced SET	P
      2  00de				   P	      SET	P+1
      0  00de					      AIN	DelayAfterPlaced2
      1  00de				   AI_DelayAfterPlaced2 SET	P
      2  00de				   P	      SET	P+1
     43  00de
    325  00de
      0  00de					      DEF	AiVectorLO
      1  00de				   SLOT_AiVectorLO SET	_BANK_SLOT
      2  00de				   BANK_AiVectorLO SET	SLOT_AiVectorLO + _CURRENT_BANK
      3  00de				   AiVectorLO
      4  00de				   TEMPORARY_VAR SET	Overlay
      5  00de				   TEMPORARY_OFFSET SET	0
      6  00de				   VAR_BOUNDARY_AiVectorLO SET	TEMPORARY_OFFSET
      7  00de				   FUNCTION_NAME SET	AiVectorLO
      0  00de					      TABDEF	LO
      1  00de
      0  00de					      LO	FlashComputerMove
      1  00de		       3a		      .byte.b	<aiFlashComputerMove
      0  00df					      LO	BeginSelectMovePhase
      1  00df		       1d		      .byte.b	<aiBeginSelectMovePhase
      0  00e0					      LO	SelectStartSquare
      1  00e0		       62		      .byte.b	<aiSelectStartSquare
      0  00e1					      LO	StartSquareSelected
      1  00e1		       e2		      .byte.b	<aiStartSquareSelected
      0  00e2					      LO	DrawMoves
      1  00e2		       fd		      .byte.b	<aiDrawMoves
      0  00e3					      LO	ShowMoveCaptures
      1  00e3		       e4		      .byte.b	<aiShowMoveCaptures
      0  00e4					      LO	SlowFlash
      1  00e4		       06		      .byte.b	<aiSlowFlash
      0  00e5					      LO	UnDrawTargetSquares
      1  00e5		       be		      .byte.b	<aiUnDrawTargetSquares
      0  00e6					      LO	SelectDestinationSquare
      1  00e6		       5d		      .byte.b	<aiSelectDestinationSquare
      0  00e7					      LO	Quiescent
      1  00e7		       bf		      .byte.b	<aiQuiescent
      0  00e8					      LO	ReselectDebounce
      1  00e8		       b6		      .byte.b	<aiReselectDebounce
      0  00e9					      LO	StartMoveGen
      1  00e9		       00		      .byte.b	<aiStartMoveGen
      0  00ea					      LO	StepMoveGen
      1  00ea		       fc		      .byte.b	<aiStepMoveGen
      0  00eb					      LO	StartClearBoard
      1  00eb		       28		      .byte.b	<aiStartClearBoard
      0  00ec					      LO	ClearEachRow
      1  00ec		       35		      .byte.b	<aiClearEachRow
      0  00ed					      LO	DrawEntireBoard
      1  00ed		       7c		      .byte.b	<aiDrawEntireBoard
      0  00ee					      LO	DrawPart2
      1  00ee		       00		      .byte.b	<aiDrawPart2
      0  00ef					      LO	DrawPart3
      1  00ef		       03		      .byte.b	<aiDrawPart3
      0  00f0					      LO	GenerateMoves
      1  00f0		       ea		      .byte.b	<aiGenerateMoves
      0  00f1					      LO	ComputerMove
      1  00f1		       27		      .byte.b	<aiComputerMove
      0  00f2					      LO	MoveIsSelected
      1  00f2		       42		      .byte.b	<aiMoveIsSelected
      0  00f3					      LO	WriteStartPieceBlank
      1  00f3		       86		      .byte.b	<aiWriteStartPieceBlank
      0  00f4					      LO	MarchToTargetA
      1  00f4		       38		      .byte.b	<aiMarchToTargetA
      0  00f5					      LO	MarchA2
      1  00f5		       2d		      .byte.b	<aiMarchA2
      0  00f6					      LO	MarchB
      1  00f6		       1d		      .byte.b	<aiMarchB
      0  00f7					      LO	MarchToTargetB
      1  00f7		       ab		      .byte.b	<aiMarchToTargetB
      0  00f8					      LO	MarchB2
      1  00f8		       5a		      .byte.b	<aiMarchB2
      0  00f9					      LO	FinalFlash
      1  00f9		       87		      .byte.b	<aiFinalFlash
      0  00fa					      LO	SpecialMoveFixup
      1  00fa		       64		      .byte.b	<aiSpecialMoveFixup
      0  00fb					      LO	InCheckBackup
      1  00fb		       05		      .byte.b	<aiInCheckBackup
      0  00fc					      LO	InCheckDelay
      1  00fc		       10		      .byte.b	<aiInCheckDelay
      0  00fd					      LO	PromotePawnStart
      1  00fd		       c6		      .byte.b	<aiPromotePawnStart
      0  00fe					      LO	RollPromotionPiece
      1  00fe		       e7		      .byte.b	<aiRollPromotionPiece
      0  00ff					      LO	ChoosePromotePiece
      1  00ff		       00		      .byte.b	<aiChoosePromotePiece
      0  0100					      LO	ChooseDebounce
      1  0100		       6f		      .byte.b	<aiChooseDebounce
      0  0101					      LO	CheckMate
      1  0101		       32		      .byte.b	<aiCheckMate
      0  0102					      LO	Draw
      1  0102		       2d		      .byte.b	<aiDraw
      0  0103					      LO	DelayAfterMove
      1  0103		       81		      .byte.b	<aiDelayAfterMove
      0  0104					      LO	DelayAfterMove2
      1  0104		       8a		      .byte.b	<aiDelayAfterMove2
      0  0105					      LO	DelayAfterPlaced
      1  0105		       93		      .byte.b	<aiDelayAfterPlaced
      0  0106					      LO	DelayAfterPlaced2
      1  0106		       a2		      .byte.b	<aiDelayAfterPlaced2
     43  0107
    328  0107
      0  0107					      DEF	AiVectorHI
      1  0107				   SLOT_AiVectorHI SET	_BANK_SLOT
      2  0107				   BANK_AiVectorHI SET	SLOT_AiVectorHI + _CURRENT_BANK
      3  0107				   AiVectorHI
      4  0107				   TEMPORARY_VAR SET	Overlay
      5  0107				   TEMPORARY_OFFSET SET	0
      6  0107				   VAR_BOUNDARY_AiVectorHI SET	TEMPORARY_OFFSET
      7  0107				   FUNCTION_NAME SET	AiVectorHI
      0  0107					      TABDEF	HI
      1  0107
      0  0107					      HI	FlashComputerMove
      1  0107		       f4		      .byte.b	>aiFlashComputerMove
      0  0108					      HI	BeginSelectMovePhase
      1  0108		       f4		      .byte.b	>aiBeginSelectMovePhase
      0  0109					      HI	SelectStartSquare
      1  0109		       f4		      .byte.b	>aiSelectStartSquare
      0  010a					      HI	StartSquareSelected
      1  010a		       f4		      .byte.b	>aiStartSquareSelected
      0  010b					      HI	DrawMoves
      1  010b		       f4		      .byte.b	>aiDrawMoves
      0  010c					      HI	ShowMoveCaptures
      1  010c		       f5		      .byte.b	>aiShowMoveCaptures
      0  010d					      HI	SlowFlash
      1  010d		       f6		      .byte.b	>aiSlowFlash
      0  010e					      HI	UnDrawTargetSquares
      1  010e		       f5		      .byte.b	>aiUnDrawTargetSquares
      0  010f					      HI	SelectDestinationSquare
      1  010f		       f6		      .byte.b	>aiSelectDestinationSquare
      0  0110					      HI	Quiescent
      1  0110		       f6		      .byte.b	>aiQuiescent
      0  0111					      HI	ReselectDebounce
      1  0111		       f6		      .byte.b	>aiReselectDebounce
      0  0112					      HI	StartMoveGen
      1  0112		       f4		      .byte.b	>aiStartMoveGen
      0  0113					      HI	StepMoveGen
      1  0113		       f4		      .byte.b	>aiStepMoveGen
      0  0114					      HI	StartClearBoard
      1  0114		       f8		      .byte.b	>aiStartClearBoard
      0  0115					      HI	ClearEachRow
      1  0115		       f8		      .byte.b	>aiClearEachRow
      0  0116					      HI	DrawEntireBoard
      1  0116		       f4		      .byte.b	>aiDrawEntireBoard
      0  0117					      HI	DrawPart2
      1  0117		       f4		      .byte.b	>aiDrawPart2
      0  0118					      HI	DrawPart3
      1  0118		       f4		      .byte.b	>aiDrawPart3
      0  0119					      HI	GenerateMoves
      1  0119		       f4		      .byte.b	>aiGenerateMoves
      0  011a					      HI	ComputerMove
      1  011a		       f4		      .byte.b	>aiComputerMove
      0  011b					      HI	MoveIsSelected
      1  011b		       f8		      .byte.b	>aiMoveIsSelected
      0  011c					      HI	WriteStartPieceBlank
      1  011c		       f7		      .byte.b	>aiWriteStartPieceBlank
      0  011d					      HI	MarchToTargetA
      1  011d		       f6		      .byte.b	>aiMarchToTargetA
      0  011e					      HI	MarchA2
      1  011e		       f7		      .byte.b	>aiMarchA2
      0  011f					      HI	MarchB
      1  011f		       f4		      .byte.b	>aiMarchB
      0  0120					      HI	MarchToTargetB
      1  0120		       f4		      .byte.b	>aiMarchToTargetB
      0  0121					      HI	MarchB2
      1  0121		       f7		      .byte.b	>aiMarchB2
      0  0122					      HI	FinalFlash
      1  0122		       f6		      .byte.b	>aiFinalFlash
      0  0123					      HI	SpecialMoveFixup
      1  0123		       f4		      .byte.b	>aiSpecialMoveFixup
      0  0124					      HI	InCheckBackup
      1  0124		       f4		      .byte.b	>aiInCheckBackup
      0  0125					      HI	InCheckDelay
      1  0125		       f4		      .byte.b	>aiInCheckDelay
      0  0126					      HI	PromotePawnStart
      1  0126		       f4		      .byte.b	>aiPromotePawnStart
      0  0127					      HI	RollPromotionPiece
      1  0127		       f6		      .byte.b	>aiRollPromotionPiece
      0  0128					      HI	ChoosePromotePiece
      1  0128		       f4		      .byte.b	>aiChoosePromotePiece
      0  0129					      HI	ChooseDebounce
      1  0129		       f4		      .byte.b	>aiChooseDebounce
      0  012a					      HI	CheckMate
      1  012a		       f4		      .byte.b	>aiCheckMate
      0  012b					      HI	Draw
      1  012b		       f4		      .byte.b	>aiDraw
      0  012c					      HI	DelayAfterMove
      1  012c		       f4		      .byte.b	>aiDelayAfterMove
      0  012d					      HI	DelayAfterMove2
      1  012d		       f4		      .byte.b	>aiDelayAfterMove2
      0  012e					      HI	DelayAfterPlaced
      1  012e		       f4		      .byte.b	>aiDelayAfterPlaced
      0  012f					      HI	DelayAfterPlaced2
      1  012f		       f4		      .byte.b	>aiDelayAfterPlaced2
     43  0130
    331  0130
      0  0130					      DEF	AiVectorBANK
      1  0130				   SLOT_AiVectorBANK SET	_BANK_SLOT
      2  0130				   BANK_AiVectorBANK SET	SLOT_AiVectorBANK + _CURRENT_BANK
      3  0130				   AiVectorBANK
      4  0130				   TEMPORARY_VAR SET	Overlay
      5  0130				   TEMPORARY_OFFSET SET	0
      6  0130				   VAR_BOUNDARY_AiVectorBANK SET	TEMPORARY_OFFSET
      7  0130				   FUNCTION_NAME SET	AiVectorBANK
      0  0130					      TABDEF	BK
      1  0130
      0  0130					      BK	FlashComputerMove
      1  0130		       47		      .byte.b	BANK_aiFlashComputerMove
      0  0131					      BK	BeginSelectMovePhase
      1  0131		       47		      .byte.b	BANK_aiBeginSelectMovePhase
      0  0132					      BK	SelectStartSquare
      1  0132		       47		      .byte.b	BANK_aiSelectStartSquare
      0  0133					      BK	StartSquareSelected
      1  0133		       47		      .byte.b	BANK_aiStartSquareSelected
      0  0134					      BK	DrawMoves
      1  0134		       47		      .byte.b	BANK_aiDrawMoves
      0  0135					      BK	ShowMoveCaptures
      1  0135		       47		      .byte.b	BANK_aiShowMoveCaptures
      0  0136					      BK	SlowFlash
      1  0136		       47		      .byte.b	BANK_aiSlowFlash
      0  0137					      BK	UnDrawTargetSquares
      1  0137		       47		      .byte.b	BANK_aiUnDrawTargetSquares
      0  0138					      BK	SelectDestinationSquare
      1  0138		       47		      .byte.b	BANK_aiSelectDestinationSquare
      0  0139					      BK	Quiescent
      1  0139		       47		      .byte.b	BANK_aiQuiescent
      0  013a					      BK	ReselectDebounce
      1  013a		       47		      .byte.b	BANK_aiReselectDebounce
      0  013b					      BK	StartMoveGen
      1  013b		       47		      .byte.b	BANK_aiStartMoveGen
      0  013c					      BK	StepMoveGen
      1  013c		       48		      .byte.b	BANK_aiStepMoveGen
      0  013d					      BK	StartClearBoard
      1  013d		       93		      .byte.b	BANK_aiStartClearBoard
      0  013e					      BK	ClearEachRow
      1  013e		       93		      .byte.b	BANK_aiClearEachRow
      0  013f					      BK	DrawEntireBoard
      1  013f		       5c		      .byte.b	BANK_aiDrawEntireBoard
      0  0140					      BK	DrawPart2
      1  0140		       54		      .byte.b	BANK_aiDrawPart2
      0  0141					      BK	DrawPart3
      1  0141		       54		      .byte.b	BANK_aiDrawPart3
      0  0142					      BK	GenerateMoves
      1  0142		       48		      .byte.b	BANK_aiGenerateMoves
      0  0143					      BK	ComputerMove
      1  0143		       5c		      .byte.b	BANK_aiComputerMove
      0  0144					      BK	MoveIsSelected
      1  0144		       93		      .byte.b	BANK_aiMoveIsSelected
      0  0145					      BK	WriteStartPieceBlank
      1  0145		       47		      .byte.b	BANK_aiWriteStartPieceBlank
      0  0146					      BK	MarchToTargetA
      1  0146		       48		      .byte.b	BANK_aiMarchToTargetA
      0  0147					      BK	MarchA2
      1  0147		       47		      .byte.b	BANK_aiMarchA2
      0  0148					      BK	MarchB
      1  0148		       54		      .byte.b	BANK_aiMarchB
      0  0149					      BK	MarchToTargetB
      1  0149		       48		      .byte.b	BANK_aiMarchToTargetB
      0  014a					      BK	MarchB2
      1  014a		       47		      .byte.b	BANK_aiMarchB2
      0  014b					      BK	FinalFlash
      1  014b		       48		      .byte.b	BANK_aiFinalFlash
      0  014c					      BK	SpecialMoveFixup
      1  014c		       5c		      .byte.b	BANK_aiSpecialMoveFixup
      0  014d					      BK	InCheckBackup
      1  014d		       47		      .byte.b	BANK_aiInCheckBackup
      0  014e					      BK	InCheckDelay
      1  014e		       47		      .byte.b	BANK_aiInCheckDelay
      0  014f					      BK	PromotePawnStart
      1  014f		       48		      .byte.b	BANK_aiPromotePawnStart
      0  0150					      BK	RollPromotionPiece
      1  0150		       47		      .byte.b	BANK_aiRollPromotionPiece
      0  0151					      BK	ChoosePromotePiece
      1  0151		       48		      .byte.b	BANK_aiChoosePromotePiece
      0  0152					      BK	ChooseDebounce
      1  0152		       48		      .byte.b	BANK_aiChooseDebounce
      0  0153					      BK	CheckMate
      1  0153		       54		      .byte.b	BANK_aiCheckMate
      0  0154					      BK	Draw
      1  0154		       54		      .byte.b	BANK_aiDraw
      0  0155					      BK	DelayAfterMove
      1  0155		       48		      .byte.b	BANK_aiDelayAfterMove
      0  0156					      BK	DelayAfterMove2
      1  0156		       48		      .byte.b	BANK_aiDelayAfterMove2
      0  0157					      BK	DelayAfterPlaced
      1  0157		       48		      .byte.b	BANK_aiDelayAfterPlaced
      0  0158					      BK	DelayAfterPlaced2
      1  0158		       48		      .byte.b	BANK_aiDelayAfterPlaced2
     43  0159
    334  0159
    335  0159
    336  0159							;---------------------------------------------------------------------------------------------------
    337  0159
      0  0159					      DEF	AiStateMachine
      1  0159				   SLOT_AiStateMachine SET	_BANK_SLOT
      2  0159				   BANK_AiStateMachine SET	SLOT_AiStateMachine + _CURRENT_BANK
      3  0159				   AiStateMachine
      4  0159				   TEMPORARY_VAR SET	Overlay
      5  0159				   TEMPORARY_OFFSET SET	0
      6  0159				   VAR_BOUNDARY_AiStateMachine SET	TEMPORARY_OFFSET
      7  0159				   FUNCTION_NAME SET	AiStateMachine
    339  0159					      SUBROUTINE
    340  0159
      0  0159					      REFER	StartupBankReset
      1  0159				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0159				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0159					      ENDIF
      0  0159					      VEND	AiStateMachine
      1  0159				  -	      IFNCONST	AiStateMachine
      2  0159				  -	      ECHO	"Incorrect VEND label", AiStateMachine
      3  0159				  -	      ERR
      4  0159					      ENDIF
      5  0159		       00 a1	   VAREND_AiStateMachine =	TEMPORARY_VAR
    343  0159
    344  0159
    345  0159							; State machine vector setup - points to current routine to execute
    346  0159
    347  0159		       a6 8b		      ldx	aiState
    348  015b		       bd de f0 	      lda	AiVectorLO,x
    349  015e		       85 e9		      sta	__ptr
    350  0160		       bd 07 f1 	      lda	AiVectorHI,x
    351  0163		       85 ea		      sta	__ptr+1
    352  0165
    353  0165		       bd 30 f1 	      lda	AiVectorBANK,x
    354  0168		       85 3f		      sta	SET_BANK
    355  016a		       6c e9 00 	      jmp	(__ptr)	; NOTE: could branch back to squeeze cycles
    356  016d
    357  016d
    358  016d							;---------------------------------------------------------------------------------------------------
    359  016d
      0  016d					      DEF	GenerateAllMoves
      1  016d				   SLOT_GenerateAllMoves SET	_BANK_SLOT
      2  016d				   BANK_GenerateAllMoves SET	SLOT_GenerateAllMoves + _CURRENT_BANK
      3  016d				   GenerateAllMoves
      4  016d				   TEMPORARY_VAR SET	Overlay
      5  016d				   TEMPORARY_OFFSET SET	0
      6  016d				   VAR_BOUNDARY_GenerateAllMoves SET	TEMPORARY_OFFSET
      7  016d				   FUNCTION_NAME SET	GenerateAllMoves
    361  016d					      SUBROUTINE
    362  016d
      0  016d					      REFER	negaMax
      1  016d					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  016d				   TEMPORARY_VAR SET	VAREND_negaMax
      3  016d					      ENDIF
      0  016d					      REFER	quiesce
      1  016d				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  016d				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  016d					      ENDIF
      0  016d					      REFER	aiStepMoveGen
      1  016d				  -	      IF	VAREND_aiStepMoveGen > TEMPORARY_VAR
      2  016d				  -TEMPORARY_VAR SET	VAREND_aiStepMoveGen
      3  016d					      ENDIF
      0  016d					      REFER	aiGenerateMoves
      1  016d				  -	      IF	VAREND_aiGenerateMoves > TEMPORARY_VAR
      2  016d				  -TEMPORARY_VAR SET	VAREND_aiGenerateMoves
      3  016d					      ENDIF
      0  016d					      REFER	selectmove
      1  016d				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  016d				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  016d					      ENDIF
      0  016d					      VAR	__vector, 2
      1  016d		       00 ad	   __vector   =	TEMPORARY_VAR
      2  016d				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  016d
      4  016d				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  016d				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  016d				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  016d					      ENDIF
      8  016d				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  016d				  -	      ECHO	"Temporary Variable", __vector, "overflow!"
     10  016d				  -	      ERR
     11  016d					      ENDIF
     12  016d					      LIST	ON
      0  016d					      VAR	__masker, 2
      1  016d		       00 af	   __masker   =	TEMPORARY_VAR
      2  016d				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  016d
      4  016d				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  016d				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  016d				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  016d					      ENDIF
      8  016d				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  016d				  -	      ECHO	"Temporary Variable", __masker, "overflow!"
     10  016d				  -	      ERR
     11  016d					      ENDIF
     12  016d					      LIST	ON
      0  016d					      VAR	__pieceFilter, 1
      1  016d		       00 b1	   __pieceFilter =	TEMPORARY_VAR
      2  016d				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  016d
      4  016d				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  016d				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  016d				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  016d					      ENDIF
      8  016d				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  016d				  -	      ECHO	"Temporary Variable", __pieceFilter, "overflow!"
     10  016d				  -	      ERR
     11  016d					      ENDIF
     12  016d					      LIST	ON
      0  016d					      VEND	GenerateAllMoves
      1  016d				  -	      IFNCONST	GenerateAllMoves
      2  016d				  -	      ECHO	"Incorrect VEND label", GenerateAllMoves
      3  016d				  -	      ERR
      4  016d					      ENDIF
      5  016d		       00 b2	   VAREND_GenerateAllMoves =	TEMPORARY_VAR
    372  016d
    373  016d							; Do the move generation in two passes - pawns then pieces
    374  016d							; This is an effort to get the alphabeta pruning happening with major pieces handled first in list
    375  016d
    376  016d		       a5 94		      lda	currentPly
    377  016f		       85 3e		      sta	SET_BANK_RAM	;@2
    378  0171
    379  0171		       a9 44		      lda	#BANK_NewPlyInitialise
    380  0173		       85 3f		      sta	SET_BANK
    381  0175		       20 00 f4 	      jsr	NewPlyInitialise	;@1
    382  0178
    383  0178		       a9 08		      lda	#8	; pawns
    384  017a		       85 b1		      sta	__pieceFilter
    385  017c		       20 91 f1 	      jsr	MoveGenX
    386  017f		       a9 63		      lda	#99
    387  0181		       85 92		      sta	currentSquare
    388  0183		       a9 00		      lda	#0
    389  0185		       85 b1		      sta	__pieceFilter
    390  0187		       20 91 f1 	      jsr	MoveGenX
    391  018a
    392  018a		       a9 44		      lda	#BANK_Sort
    393  018c		       85 3f		      sta	SET_BANK
    394  018e		       4c 18 f4 	      jmp	Sort	;@1
    395  0191
    396  0191
    397  0191
      0  0191					      DEF	MoveGenX
      1  0191				   SLOT_MoveGenX SET	_BANK_SLOT
      2  0191				   BANK_MoveGenX SET	SLOT_MoveGenX + _CURRENT_BANK
      3  0191				   MoveGenX
      4  0191				   TEMPORARY_VAR SET	Overlay
      5  0191				   TEMPORARY_OFFSET SET	0
      6  0191				   VAR_BOUNDARY_MoveGenX SET	TEMPORARY_OFFSET
      7  0191				   FUNCTION_NAME SET	MoveGenX
    399  0191					      SUBROUTINE
    400  0191
    401  0191		       a9 cf		      lda	#RAMBANK_BOARD
    402  0193		       85 3e		      sta	SET_BANK_RAM	;@3		 ; should be hardwired forever, right?
    403  0195
    404  0195		       a2 64		      ldx	#100
    405  0197		       d0 02		      bne	.next
    406  0199
      0  0199					      DEF	MoveReturn
      1  0199				   SLOT_MoveReturn SET	_BANK_SLOT
      2  0199				   BANK_MoveReturn SET	SLOT_MoveReturn + _CURRENT_BANK
      3  0199				   MoveReturn
      4  0199				   TEMPORARY_VAR SET	Overlay
      5  0199				   TEMPORARY_OFFSET SET	0
      6  0199				   VAR_BOUNDARY_MoveReturn SET	TEMPORARY_OFFSET
      7  0199				   FUNCTION_NAME SET	MoveReturn
    408  0199
    409  0199		       a6 92		      ldx	currentSquare
    410  019b		       ca	   .next      dex
    411  019c		       e0 16		      cpx	#22
    412  019e		       90 30		      bcc	.exit
    413  01a0
    414  01a0		       bd 79 fc 	      lda	Board,x
    415  01a3		       f0 f6		      beq	.next
    416  01a5		       c9 ff		      cmp	#-1
    417  01a7		       f0 f2		      beq	.next
    418  01a9		       45 95		      eor	sideToMove
    419  01ab		       30 ee		      bmi	.next
    420  01ad
    421  01ad		       86 92		      stx	currentSquare
    422  01af
    423  01af		       45 95		      eor	sideToMove
    424  01b1		       29 ef		      and	#~FLAG_CASTLE	; todo: better part of the move, mmh?
    425  01b3		       85 91		      sta	currentPiece
    426  01b5		       29 0f		      and	#PIECE_MASK
    427  01b7		       05 b1		      ora	__pieceFilter
    428  01b9		       a8		      tay
    429  01ba
    430  01ba		       a9 5a		      lda	#BANK_HandlerVectorLO
    431  01bc		       85 3f		      sta	SET_BANK
    432  01be
    433  01be		       b9 10 f4 	      lda	HandlerVectorHI,y
    434  01c1		       85 ae		      sta	__vector+1
    435  01c3		       b9 00 f4 	      lda	HandlerVectorLO,y
    436  01c6		       85 ad		      sta	__vector
    437  01c8
    438  01c8		       b9 20 f4 	      lda	HandlerVectorBANK,y
    439  01cb		       85 3f		      sta	SET_BANK	;@1
    440  01cd
    441  01cd		       6c ad 00 	      jmp	(__vector)
    442  01d0
    443  01d0
    444  01d0
    445  01d0				   .exit
    446  01d0		       60		      rts
    447  01d1
    448  01d1
    449  01d1							;---------------------------------------------------------------------------------------------------
    450  01d1
      0  01d1					      DEF	ListPlayerMoves
      1  01d1				   SLOT_ListPlayerMoves SET	_BANK_SLOT
      2  01d1				   BANK_ListPlayerMoves SET	SLOT_ListPlayerMoves + _CURRENT_BANK
      3  01d1				   ListPlayerMoves
      4  01d1				   TEMPORARY_VAR SET	Overlay
      5  01d1				   TEMPORARY_OFFSET SET	0
      6  01d1				   VAR_BOUNDARY_ListPlayerMoves SET	TEMPORARY_OFFSET
      7  01d1				   FUNCTION_NAME SET	ListPlayerMoves
    452  01d1					      SUBROUTINE
    453  01d1
    454  01d1
    455  01d1		       a9 00		      lda	#0
    456  01d3		       85 ac		      sta	__quiesceCapOnly	; gen ALL moves
    457  01d5
    458  01d5		       a9 89		      lda	#RAMBANK_PLY+1
    459  01d7		       85 94		      sta	currentPly
    460  01d9		       20 6d f1 	      jsr	GenerateAllMoves
    461  01dc
      0  01dc					      ldx@PLY	moveIndex
      1  01dc		       ae d0 f9 	      ldx	moveIndex
      0  01df				   .scan      stx@PLY	movePtr
      1  01df		       8e d1 fb 	      stx	[RAM]+movePtr
    464  01e2
      0  01e2					      CALL	MakeMove	;@1
      1  01e2				  -	      IF	SLOT_MakeMove == _BANK_SLOT
      2  01e2				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  01e2				  -	      ECHO	"Cannot switch bank in use for", MakeMove
      4  01e2				  -	      ERR
      5  01e2					      ENDIF
      6  01e2		       a9 41		      lda	#BANK_MakeMove
      7  01e4		       85 3f		      sta	SET_BANK
      8  01e6		       20 64 f6 	      jsr	MakeMove
    466  01e9
    467  01e9		       e6 94		      inc	currentPly
    468  01eb		       20 6d f1 	      jsr	GenerateAllMoves
    469  01ee
    470  01ee		       c6 94		      dec	currentPly
    471  01f0		       a5 94		      lda	currentPly
    472  01f2		       85 3e		      sta	SET_BANK_RAM	;@2
    473  01f4
    474  01f4		       20 32 f2 	      jsr	unmakeMove
    475  01f7
    476  01f7		       a5 94		      lda	currentPly
    477  01f9		       85 3e		      sta	SET_BANK_RAM	;@2
    478  01fb
    479  01fb		       a5 9e		      lda	flagCheck
    480  01fd		       f0 08		      beq	.next
    481  01ff
      0  01ff					      ldx@PLY	movePtr
      1  01ff		       ae d1 f9 	      ldx	movePtr
    483  0202		       a9 00		      lda	#0
      0  0204					      sta@PLY	MoveFrom,x	; invalidate move (still in check!)
      1  0204		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
    485  0207
      0  0207				   .next      ldx@PLY	movePtr
      1  0207		       ae d1 f9 	      ldx	movePtr
    487  020a		       ca		      dex
    488  020b		       10 d2		      bpl	.scan
    489  020d
    490  020d		       60		      rts
    491  020e
    492  020e
    493  020e							;---------------------------------------------------------------------------------------------------
    494  020e
      0  020e					      DEF	AddMove
      1  020e				   SLOT_AddMove SET	_BANK_SLOT
      2  020e				   BANK_AddMove SET	SLOT_AddMove + _CURRENT_BANK
      3  020e				   AddMove
      4  020e				   TEMPORARY_VAR SET	Overlay
      5  020e				   TEMPORARY_OFFSET SET	0
      6  020e				   VAR_BOUNDARY_AddMove SET	TEMPORARY_OFFSET
      7  020e				   FUNCTION_NAME SET	AddMove
    496  020e					      SUBROUTINE
    497  020e
      0  020e					      VEND	AddMove
      1  020e				  -	      IFNCONST	AddMove
      2  020e				  -	      ECHO	"Incorrect VEND label", AddMove
      3  020e				  -	      ERR
      4  020e					      ENDIF
      5  020e		       00 a1	   VAREND_AddMove =	TEMPORARY_VAR
    499  020e
    500  020e							; add square in y register to movelist as destination (X12 format)
    501  020e							; [y]		     to square (X12)
    502  020e							; currentSquare     from square (X12)
    503  020e							; currentPiece      piece.
    504  020e							;   ENPASSANT flag set if pawn double-moving off opening rank
    505  020e							; capture	     captured piece
    506  020e
    507  020e		       a5 9d		      lda	capture
    508  0210		       d0 04		      bne	.always
    509  0212		       a5 ac		      lda	__quiesceCapOnly
    510  0214		       d0 1a		      bne	.abort
    511  0216
    512  0216		       98	   .always    tya
    513  0217
      0  0217					      ldy@PLY	moveIndex
      1  0217		       ac d0 f9 	      ldy	moveIndex
    515  021a		       c8		      iny
      0  021b					      sty@PLY	moveIndex
      1  021b		       8c d0 fb 	      sty	[RAM]+moveIndex
    517  021e
      0  021e					      sta@PLY	MoveTo,y
      1  021e		       99 64 fa 	      sta	[RAM]+MoveTo,y
    519  0221		       a5 92		      lda	currentSquare
      0  0223					      sta@PLY	MoveFrom,y
      1  0223		       99 00 fa 	      sta	[RAM]+MoveFrom,y
    521  0226		       a5 91		      lda	currentPiece
      0  0228					      sta@PLY	MovePiece,y
      1  0228		       99 00 fb 	      sta	[RAM]+MovePiece,y
    523  022b		       a5 9d		      lda	capture
      0  022d					      sta@PLY	MoveCapture,y
      1  022d		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    525  0230
    526  0230		       60	   .abort     rts
    527  0231
    528  0231							;---------------------------------------------------------------------------------------------------
    529  0231
      0  0231					      DEF	debug
      1  0231				   SLOT_debug SET	_BANK_SLOT
      2  0231				   BANK_debug SET	SLOT_debug + _CURRENT_BANK
      3  0231				   debug
      4  0231				   TEMPORARY_VAR SET	Overlay
      5  0231				   TEMPORARY_OFFSET SET	0
      6  0231				   VAR_BOUNDARY_debug SET	TEMPORARY_OFFSET
      7  0231				   FUNCTION_NAME SET	debug
    531  0231					      SUBROUTINE
    532  0231		       60		      rts
    533  0232
    534  0232
    535  0232							;---------------------------------------------------------------------------------------------------
    536  0232
      0  0232					      DEF	unmakeMove
      1  0232				   SLOT_unmakeMove SET	_BANK_SLOT
      2  0232				   BANK_unmakeMove SET	SLOT_unmakeMove + _CURRENT_BANK
      3  0232				   unmakeMove
      4  0232				   TEMPORARY_VAR SET	Overlay
      5  0232				   TEMPORARY_OFFSET SET	0
      6  0232				   VAR_BOUNDARY_unmakeMove SET	TEMPORARY_OFFSET
      7  0232				   FUNCTION_NAME SET	unmakeMove
    538  0232					      SUBROUTINE
    539  0232
      0  0232					      REFER	negaMax
      1  0232					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0232				   TEMPORARY_VAR SET	VAREND_negaMax
      3  0232					      ENDIF
      0  0232					      VAR	__unmake_capture, 1
      1  0232		       00 ad	   __unmake_capture =	TEMPORARY_VAR
      2  0232				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0232
      4  0232				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0232				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0232				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0232					      ENDIF
      8  0232				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0232				  -	      ECHO	"Temporary Variable", __unmake_capture, "overflow!"
     10  0232				  -	      ERR
     11  0232					      ENDIF
     12  0232					      LIST	ON
      0  0232					      VAR	__secondaryBlank, 1
      1  0232		       00 ae	   __secondaryBlank =	TEMPORARY_VAR
      2  0232				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0232
      4  0232				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0232				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0232				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0232					      ENDIF
      8  0232				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0232				  -	      ECHO	"Temporary Variable", __secondaryBlank, "overflow!"
     10  0232				  -	      ERR
     11  0232					      ENDIF
     12  0232					      LIST	ON
      0  0232					      VEND	unmakeMove
      1  0232				  -	      IFNCONST	unmakeMove
      2  0232				  -	      ECHO	"Incorrect VEND label", unmakeMove
      3  0232				  -	      ERR
      4  0232					      ENDIF
      5  0232		       00 af	   VAREND_unmakeMove =	TEMPORARY_VAR
    544  0232
    545  0232							; restore the board evaluation to what it was at the start of this ply
    546  0232							; TODO: note: moved flag seems wrong on restoration
    547  0232
    548  0232		       a5 94		      lda	currentPly
    549  0234		       85 3e		      sta	SET_BANK_RAM	;@2
    550  0236
      0  0236					      lda@PLY	savedEvaluation
      1  0236		       ad c8 f9 	      lda	savedEvaluation
    552  0239		       85 8f		      sta	Evaluation
      0  023b					      lda@PLY	savedEvaluation+1
      1  023b		       ad c9 f9 	      lda	savedEvaluation+1
    554  023e		       85 90		      sta	Evaluation+1
    555  0240
    556  0240		       ae d1 f9 	      ldx	movePtr
      0  0243					      lda@PLY	MoveFrom,x
      1  0243		       bd 00 f8 	      lda	MoveFrom,x
    558  0246		       85 85		      sta	fromX12
      0  0248					      ldy@PLY	MoveTo,x
      1  0248		       bc 64 f8 	      ldy	MoveTo,x
    560  024b
      0  024b					      lda@PLY	restorePiece
      1  024b		       ad da f9 	      lda	restorePiece
    562  024e		       48		      pha
      0  024f					      lda@PLY	capturedPiece
      1  024f		       ad cb f9 	      lda	capturedPiece
    564  0252
    565  0252		       a2 cf		      ldx	#RAMBANK_BOARD
    566  0254		       86 3e		      stx	SET_BANK_RAM	;@3
      0  0256					      sta@RAM	Board,y
      1  0256		       99 79 fe 	      sta	[RAM]+Board,y
    568  0259		       a4 85		      ldy	fromX12
    569  025b		       68		      pla
      0  025c					      sta@RAM	Board,y
      1  025c		       99 79 fe 	      sta	[RAM]+Board,y
    571  025f
    572  025f
    573  025f							;lda currentPly
    574  025f							;sta SET_BANK_RAM
    575  025f
    576  025f							; See if there are any 'secondary' pieces that moved
    577  025f							; here we're dealing with reverting a castling or enPassant move
    578  025f
      0  025f					      lda@PLY	secondaryPiece
      1  025f		       ad cd f9 	      lda	secondaryPiece
    580  0262		       f0 12		      beq	.noSecondary
      0  0264					      ldy@PLY	secondaryBlank
      1  0264		       ac cf f9 	      ldy	secondaryBlank
    582  0267		       84 ae		      sty	__secondaryBlank
      0  0269					      ldy@PLY	secondarySquare
      1  0269		       ac ce f9 	      ldy	secondarySquare
      0  026c					      sta@RAM	Board,y	; put piece back
      1  026c		       99 79 fe 	      sta	[RAM]+Board,y
    585  026f
    586  026f		       a4 ae		      ldy	__secondaryBlank
    587  0271		       a9 00		      lda	#0
      0  0273					      sta@RAM	Board,y	; blank piece origin
      1  0273		       99 79 fe 	      sta	[RAM]+Board,y
    589  0276
    590  0276
    591  0276				   .noSecondary
      0  0276					      SWAP
      1  0276		       a5 95		      lda	sideToMove
      2  0278		       49 80		      eor	#SWAP_SIDE
      3  027a		       85 95		      sta	sideToMove
    593  027c		       60		      rts
    594  027d
    595  027d
    596  027d							;---------------------------------------------------------------------------------------------------
    597  027d
      0  027d					      DEF	showMoveCaptures
      1  027d				   SLOT_showMoveCaptures SET	_BANK_SLOT
      2  027d				   BANK_showMoveCaptures SET	SLOT_showMoveCaptures + _CURRENT_BANK
      3  027d				   showMoveCaptures
      4  027d				   TEMPORARY_VAR SET	Overlay
      5  027d				   TEMPORARY_OFFSET SET	0
      6  027d				   VAR_BOUNDARY_showMoveCaptures SET	TEMPORARY_OFFSET
      7  027d				   FUNCTION_NAME SET	showMoveCaptures
    599  027d					      SUBROUTINE
    600  027d
      0  027d					      REFER	aiShowMoveCaptures
      1  027d				  -	      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  027d				  -TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  027d					      ENDIF
    602  027d
      0  027d					      VAR	__toSquareX12, 1
      1  027d		       00 a1	   __toSquareX12 =	TEMPORARY_VAR
      2  027d				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  027d
      4  027d				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  027d				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  027d				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  027d					      ENDIF
      8  027d				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  027d				  -	      ECHO	"Temporary Variable", __toSquareX12, "overflow!"
     10  027d				  -	      ERR
     11  027d					      ENDIF
     12  027d					      LIST	ON
      0  027d					      VAR	__fromPiece, 1
      1  027d		       00 a2	   __fromPiece =	TEMPORARY_VAR
      2  027d				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  027d
      4  027d				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  027d				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  027d				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  027d					      ENDIF
      8  027d				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  027d				  -	      ECHO	"Temporary Variable", __fromPiece, "overflow!"
     10  027d				  -	      ERR
     11  027d					      ENDIF
     12  027d					      LIST	ON
      0  027d					      VAR	__aiMoveIndex, 1
      1  027d		       00 a3	   __aiMoveIndex =	TEMPORARY_VAR
      2  027d				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  027d
      4  027d				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  027d				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  027d				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  027d					      ENDIF
      8  027d				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  027d				  -	      ECHO	"Temporary Variable", __aiMoveIndex, "overflow!"
     10  027d				  -	      ERR
     11  027d					      ENDIF
     12  027d					      LIST	ON
    606  027d
      0  027d					      VEND	showMoveCaptures
      1  027d				  -	      IFNCONST	showMoveCaptures
      2  027d				  -	      ECHO	"Incorrect VEND label", showMoveCaptures
      3  027d				  -	      ERR
      4  027d					      ENDIF
      5  027d		       00 a4	   VAREND_showMoveCaptures =	TEMPORARY_VAR
    608  027d
    609  027d							; place a marker on the board for any square matching the piece
    610  027d							; EXCEPT for squares which are occupied (we'll flash those later)
    611  027d							; x = movelist item # being checked
    612  027d
    613  027d
    614  027d		       a6 8d	   .next      ldx	aiMoveIndex
    615  027f		       86 a3		      stx	__aiMoveIndex
    616  0281		       30 4a		      bmi	.skip	; no moves in list
    617  0283
    618  0283		       ad 84 02 	      lda	INTIM
    619  0286		       c9 14		      cmp	#20
    620  0288		       90 43		      bcc	.skip
    621  028a
    622  028a		       c6 8d		      dec	aiMoveIndex
    623  028c
    624  028c		       a9 89		      lda	#RAMBANK_PLY+1
    625  028e		       85 3e		      sta	SET_BANK_RAM
      0  0290					      lda@PLY	MoveFrom,x
      1  0290		       bd 00 f8 	      lda	MoveFrom,x
    627  0293		       c5 85		      cmp	fromX12
    628  0295		       d0 e6		      bne	.next
    629  0297
      0  0297					      lda@PLY	MoveTo,x
      1  0297		       bd 64 f8 	      lda	MoveTo,x
    631  029a		       85 a1		      sta	__toSquareX12
    632  029c		       a8		      tay
    633  029d
    634  029d		       a9 cf		      lda	#RAMBANK_BOARD
    635  029f		       85 3e		      sta	SET_BANK_RAM	;@3
    636  02a1		       b9 79 fc 	      lda	Board,y
    637  02a4		       29 0f		      and	#PIECE_MASK
    638  02a6		       f0 d5		      beq	.next
    639  02a8
    640  02a8							; There's something on the board at destination, so it's a capture
    641  02a8							; Let's see if we are doing a pawn promote...
    642  02a8
    643  02a8		       a4 85		      ldy	fromX12
    644  02aa
    645  02aa		       a9 cf		      lda	#RAMBANK_BOARD
    646  02ac		       85 3e		      sta	SET_BANK_RAM	;@3
    647  02ae		       b9 79 fc 	      lda	Board,y
    648  02b1		       85 a2		      sta	__fromPiece
    649  02b3
    650  02b3		       a9 89		      lda	#RAMBANK_PLY+1
    651  02b5		       85 3e		      sta	SET_BANK_RAM
      0  02b7					      lda@PLY	MovePiece,x
      1  02b7		       bd 00 f9 	      lda	MovePiece,x
    653  02ba		       45 a2		      eor	__fromPiece
    654  02bc		       29 0f		      and	#PIECE_MASK
    655  02be		       f0 06		      beq	.legit	; from == to, so not a promote
    656  02c0
    657  02c0							; Have detected a promotion duplicate - skip all 3 of them
    658  02c0
    659  02c0		       c6 8d		      dec	aiMoveIndex	; skip "KBRQ" promotes
    660  02c2		       c6 8d		      dec	aiMoveIndex
    661  02c4		       c6 8d		      dec	aiMoveIndex
    662  02c6
    663  02c6				   .legit
    664  02c6
    665  02c6							;TIMECHECK COPYSINGLEPIECE, restoreIndex     ; not enough time to draw
    666  02c6
    667  02c6		       a5 a1		      lda	__toSquareX12
    668  02c8		       85 80		      sta	squareToDraw
    669  02ca
    670  02ca		       20 a3 f0 	      jsr	CopySinglePiece	;@0
    671  02cd
    672  02cd		       60	   .skip      rts
    673  02ce
    674  02ce
    675  02ce							;---------------------------------------------------------------------------------------------------
    676  02ce
      0  02ce					      DEF	CopyPieceToRowBitmap	;@3
      1  02ce				   SLOT_CopyPieceToRowBitmap SET	_BANK_SLOT
      2  02ce				   BANK_CopyPieceToRowBitmap SET	SLOT_CopyPieceToRowBitmap + _CURRENT_BANK
      3  02ce				   CopyPieceToRowBitmap
      4  02ce				   TEMPORARY_VAR SET	Overlay
      5  02ce				   TEMPORARY_OFFSET SET	0
      6  02ce				   VAR_BOUNDARY_CopyPieceToRowBitmap SET	TEMPORARY_OFFSET
      7  02ce				   FUNCTION_NAME SET	CopyPieceToRowBitmap
    678  02ce					      SUBROUTINE
    679  02ce
    680  02ce							;REFER CopySinglePiece 	  ; special-case due to 'intercept'
      0  02ce					      VEND	CopyPieceToRowBitmap
      1  02ce				  -	      IFNCONST	CopyPieceToRowBitmap
      2  02ce				  -	      ECHO	"Incorrect VEND label", CopyPieceToRowBitmap
      3  02ce				  -	      ERR
      4  02ce					      ENDIF
      5  02ce		       00 a1	   VAREND_CopyPieceToRowBitmap =	TEMPORARY_VAR
    682  02ce
    683  02ce		       a0 11		      ldy	#17
    684  02d0		       b0 30		      bcs	.rightSide
    685  02d2
    686  02d2		       b9 a1 00    .copyPiece lda	__pieceShapeBuffer,y
    687  02d5		       f0 06		      beq	.blank1
    688  02d7		       59 00 f8 	      eor	ChessBitmap,y
      0  02da					      sta@RAM	ChessBitmap,y
      1  02da		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
    690  02dd
    691  02dd		       b9 b3 00    .blank1    lda	__pieceShapeBuffer+18,y
    692  02e0		       f0 06		      beq	.blank2
    693  02e2		       59 12 f8 	      eor	ChessBitmap+18,y
      0  02e5					      sta@RAM	ChessBitmap+18,y
      1  02e5		       99 12 fa 	      sta	[RAM]+ChessBitmap+18,y
    695  02e8
    696  02e8		       b9 c5 00    .blank2    lda	__pieceShapeBuffer+36,y
    697  02eb		       f0 06		      beq	.blank3
    698  02ed		       59 24 f8 	      eor	ChessBitmap+36,y
      0  02f0					      sta@RAM	ChessBitmap+36,y
      1  02f0		       99 24 fa 	      sta	[RAM]+ChessBitmap+36,y
    700  02f3
    701  02f3		       b9 d7 00    .blank3    lda	__pieceShapeBuffer+54,y
    702  02f6		       f0 06		      beq	.blank4
    703  02f8		       59 36 f8 	      eor	ChessBitmap+54,y
      0  02fb					      sta@RAM	ChessBitmap+54,y
      1  02fb		       99 36 fa 	      sta	[RAM]+ChessBitmap+54,y
    705  02fe
    706  02fe		       88	   .blank4    dey
    707  02ff		       10 d1		      bpl	.copyPiece
    708  0301		       60		      rts
    709  0302
    710  0302				   .rightSide
    711  0302
    712  0302					      SUBROUTINE
    713  0302
    714  0302		       b9 a1 00    .copyPieceR lda	__pieceShapeBuffer,y
    715  0305		       f0 06		      beq	.blank1
    716  0307		       59 48 f8 	      eor	ChessBitmap+72,y
      0  030a					      sta@RAM	ChessBitmap+72,y
      1  030a		       99 48 fa 	      sta	[RAM]+ChessBitmap+72,y
    718  030d
    719  030d		       b9 b3 00    .blank1    lda	__pieceShapeBuffer+18,y
    720  0310		       f0 06		      beq	.blank2
    721  0312		       59 5a f8 	      eor	ChessBitmap+72+18,y
      0  0315					      sta@RAM	ChessBitmap+72+18,y
      1  0315		       99 5a fa 	      sta	[RAM]+ChessBitmap+72+18,y
    723  0318
    724  0318		       b9 c5 00    .blank2    lda	__pieceShapeBuffer+36,y
    725  031b		       f0 06		      beq	.blank3
    726  031d		       59 6c f8 	      eor	ChessBitmap+72+36,y
      0  0320					      sta@RAM	ChessBitmap+72+36,y
      1  0320		       99 6c fa 	      sta	[RAM]+ChessBitmap+72+36,y
    728  0323
    729  0323		       b9 d7 00    .blank3    lda	__pieceShapeBuffer+54,y
    730  0326		       f0 06		      beq	.blank4
    731  0328		       59 7e f8 	      eor	ChessBitmap+72+54,y
      0  032b					      sta@RAM	ChessBitmap+72+54,y
      1  032b		       99 7e fa 	      sta	[RAM]+ChessBitmap+72+54,y
    733  032e
    734  032e		       88	   .blank4    dey
    735  032f		       10 d1		      bpl	.copyPieceR
    736  0331		       60		      rts
    737  0332
    738  0332							;---------------------------------------------------------------------------------------------------
    739  0332
 FREE BYTES IN STARTUP BANK =  $ca
    740  0332					      ECHO	"FREE BYTES IN STARTUP BANK = ", $F3FC - *
    741  0332
    742  0332							;---------------------------------------------------------------------------------------------------
    743  0332							; The reset vectors
    744  0332							; these must live in the first 1K bank of the ROM
    745  0332
    746  0400 ????				      SEG	StartupInterruptVectors
    747  03fc					      ORG	_FIRST_BANK + $3FC
    748  03fc
    749  03fc		       00 f0		      .word.w	StartupBankReset	; RESET
    750  03fe		       00 f0		      .word.w	StartupBankReset	; IRQ	      (not used)
    751  0400
    752  0400							;---------------------------------------------------------------------------------------------------
    753  0400
    754  0400
    755  0400							; EOF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@1#1.asm LEVEL 2 PASS 4
      0  0400					      include	"BANK_GENERIC@1#1.asm"
      1  0400							; Chess
      2  0400							; Copyright (c) 2019-2020 Andrew Davie
      3  0400							; andrew@taswegian.com
      4  0400
      0  0400					      SLOT	1	; which bank this code switches to
      1  0400				  -	      IF	(1 < 0) || (1 > 3)
      2  0400				  -	      ECHO	"Illegal bank address/segment location", 1
      3  0400				  -	      ERR
      4  0400					      ENDIF
      5  0400				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  0400				   _BANK_SLOT SET	1 * 64
      0  0400					      NEWBANK	ONE
      1  0717 ????				      SEG	ONE
      2  0400					      ORG	_ORIGIN
      3  0400					      RORG	_BANK_ADDRESS_ORIGIN
      4  0400				   _BANK_START SET	*
      5  0400				   ONE_START  SET	*
      6  0400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0400				   ONE	      SET	_BANK_SLOT + _CURRENT_BANK
      8  0400				   _ORIGIN    SET	_ORIGIN + 1024
      7  0400
      8  0400
      9  0400							;---------------------------------------------------------------------------------------------------
     10  0400							; ... the above is a (potentially) RAM-copied section -- the following is ROM-only.  Note that
     11  0400							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     12  0400							; bank finishes.  Just continue on from where it left off...
     13  0400							;---------------------------------------------------------------------------------------------------
     14  0400
      0  0400					      DEF	CartInit
      1  0400				   SLOT_CartInit SET	_BANK_SLOT
      2  0400				   BANK_CartInit SET	SLOT_CartInit + _CURRENT_BANK
      3  0400				   CartInit
      4  0400				   TEMPORARY_VAR SET	Overlay
      5  0400				   TEMPORARY_OFFSET SET	0
      6  0400				   VAR_BOUNDARY_CartInit SET	TEMPORARY_OFFSET
      7  0400				   FUNCTION_NAME SET	CartInit
     16  0400					      SUBROUTINE
     17  0400
      0  0400					      REFER	StartupBankReset
      1  0400				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0400				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0400					      ENDIF
      0  0400					      VEND	CartInit
      1  0400				  -	      IFNCONST	CartInit
      2  0400				  -	      ECHO	"Incorrect VEND label", CartInit
      3  0400				  -	      ERR
      4  0400					      ENDIF
      5  0400		       00 a1	   VAREND_CartInit =	TEMPORARY_VAR
     20  0400
     21  0400		       78		      sei
     22  0401		       d8		      cld
     23  0402							; See if we can come up with something 'random' for startup
     24  0402
     25  0402		       ac 84 02 	      ldy	INTIM
     26  0405		       d0 02		      bne	.toR
     27  0407		       a0 9a		      ldy	#$9A
     28  0409		       84 81	   .toR       sty	rnd
     29  040b
     30  040b		       a9 ff		      lda	#255
     31  040d		       85 a0		      sta	randomness
     32  040f
     33  040f		       a9 00		      lda	#0
     34  0411		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     35  0414		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     36  0417		       85 6b		      sta	HMCLR
     37  0419
     38  0419							; cleanup remains of title screen
     39  0419		       85 5b		      sta	GRP0
     40  041b		       85 5c		      sta	GRP1
     41  041d
     42  041d		       a9 10		      lda	#%00010000	; double width missile, double width player
     43  041f		       85 44		      sta	NUSIZ0
     44  0421		       85 45		      sta	NUSIZ1
     45  0423
     46  0423		       a9 04		      lda	#%100	; players/missiles BEHIND BG
     47  0425		       85 4a		      sta	CTRLPF
     48  0427		       a9 07		      lda	#%111
     49  0429		       85 44		      sta	NUSIZ0
     50  042b		       85 45		      sta	NUSIZ1	; quad-width
     51  042d
     52  042d		       a9 04		      lda	#%00000100
     53  042f		       85 4a		      sta	CTRLPF
     54  0431		       a9 00		      lda	#BACKGCOL
     55  0433		       85 49		      sta	COLUBK
     56  0435
     57  0435
     58  0435		       a9 00		      lda	#WHITE	;tmp+RAMBANK_PLY
     59  0437		       85 95		      sta	sideToMove
     60  0439
     61  0439		       60		      rts
     62  043a
     63  043a
     64  043a							;---------------------------------------------------------------------------------------------------
     65  043a
      0  043a					      DEF	SetupBanks
      1  043a				   SLOT_SetupBanks SET	_BANK_SLOT
      2  043a				   BANK_SetupBanks SET	SLOT_SetupBanks + _CURRENT_BANK
      3  043a				   SetupBanks
      4  043a				   TEMPORARY_VAR SET	Overlay
      5  043a				   TEMPORARY_OFFSET SET	0
      6  043a				   VAR_BOUNDARY_SetupBanks SET	TEMPORARY_OFFSET
      7  043a				   FUNCTION_NAME SET	SetupBanks
     67  043a					      SUBROUTINE
     68  043a
     69  043a							; Move a copy of the row bank template to the first 8 banks of RAM
     70  043a							; and then terminate the draw subroutine by substituting in a RTS on the last one
     71  043a
      0  043a					      REFER	StartupBankReset
      1  043a				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  043a				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  043a					      ENDIF
      0  043a					      VAR	__plyBank, 1
      1  043a		       00 a1	   __plyBank  =	TEMPORARY_VAR
      2  043a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  043a
      4  043a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  043a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  043a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  043a					      ENDIF
      8  043a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  043a				  -	      ECHO	"Temporary Variable", __plyBank, "overflow!"
     10  043a				  -	      ERR
     11  043a					      ENDIF
     12  043a					      LIST	ON
      0  043a					      VEND	SetupBanks
      1  043a				  -	      IFNCONST	SetupBanks
      2  043a				  -	      ECHO	"Incorrect VEND label", SetupBanks
      3  043a				  -	      ERR
      4  043a					      ENDIF
      5  043a		       00 a2	   VAREND_SetupBanks =	TEMPORARY_VAR
     75  043a
     76  043a							; Copy the bitmap shadow into the first 8 RAM banks via x(SLOT3)-->y(SLOT2)
     77  043a
     78  043a				   .ROWBANK   SET	0
     79  043a					      REPEAT	8
     80  043a		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  043c		       a0 c0		      ldy	#[SLOT3] + .ROWBANK
     82  043e		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     83  043e				   .ROWBANK   SET	.ROWBANK+1
     79  043e					      REPEND
     80  0441		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  0443		       a0 c1		      ldy	#[SLOT3] + .ROWBANK
     82  0445		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     83  0445				   .ROWBANK   SET	.ROWBANK+1
     79  0445					      REPEND
     80  0448		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  044a		       a0 c2		      ldy	#[SLOT3] + .ROWBANK
     82  044c		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     83  044c				   .ROWBANK   SET	.ROWBANK+1
     79  044c					      REPEND
     80  044f		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  0451		       a0 c3		      ldy	#[SLOT3] + .ROWBANK
     82  0453		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     83  0453				   .ROWBANK   SET	.ROWBANK+1
     79  0453					      REPEND
     80  0456		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  0458		       a0 c4		      ldy	#[SLOT3] + .ROWBANK
     82  045a		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     83  045a				   .ROWBANK   SET	.ROWBANK+1
     79  045a					      REPEND
     80  045d		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  045f		       a0 c5		      ldy	#[SLOT3] + .ROWBANK
     82  0461		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     83  0461				   .ROWBANK   SET	.ROWBANK+1
     79  0461					      REPEND
     80  0464		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  0466		       a0 c6		      ldy	#[SLOT3] + .ROWBANK
     82  0468		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     83  0468				   .ROWBANK   SET	.ROWBANK+1
     79  0468					      REPEND
     80  046b		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  046d		       a0 c7		      ldy	#[SLOT3] + .ROWBANK
     82  046f		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     83  046f				   .ROWBANK   SET	.ROWBANK+1
     84  0472					      REPEND
     85  0472
     86  0472
     87  0472							; Patch the final row's "loop" to a RTS
     88  0472
     89  0472		       a2 87		      ldx	#[SLOT2] + 7	; last ROW BITMAP bank
     90  0474		       86 3e		      stx	SET_BANK_RAM
     91  0476		       a9 60		      lda	#$60	; "rts"
      0  0478					      sta@RAM	SELFMOD_RTS_ON_LAST_ROW
      1  0478		       8d 00 fb 	      sta	[RAM]+SELFMOD_RTS_ON_LAST_ROW
     93  047b
     94  047b
     95  047b
     96  047b							; copy the BOARD/MOVES bank
     97  047b
     98  047b		       a2 85		      ldx	#SHADOW_BOARD
     99  047d		       a0 cf		      ldy	#RAMBANK_BOARD
    100  047f		       20 83 f4 	      jsr	CopyShadowROMtoRAM	; this auto-initialises Board too
    101  0482
    102  0482
    103  0482							; copy the PLY banks
    104  0482							; If there's no content (only variable decs) then we don't really need to do this.
    105  0482
    106  0482							;.PLY SET 0
    107  0482							;    REPEAT PLY_BANKS
    108  0482
    109  0482							;		      ldx #SHADOW_PLY
    110  0482							;		      ldy #RAMBANK_PLY + .PLY
    111  0482							;jsr CopyShadowROMtoRAM
    112  0482							;.PLY SET .PLY + 1
    113  0482							;    REPEND
    114  0482
    115  0482							; copy the evaluation code/tables
    116  0482							; 3E+ moved from RAM to ROM
    117  0482
    118  0482							;		      ldx #[SLOT2] + SHADOW_EVAL
    119  0482							;		      ldy #[SLOT3] + EVAL
    120  0482							;		      jsr CopyShadowROMtoRAM
    121  0482
    122  0482
    123  0482							;		      ldy #RAMBANK_RAM_PIECELIST
    124  0482							;		      ldx #ROM_PIECELIST
    125  0482							;		      jsr CopyShadowROMtoRAM
    126  0482
    127  0482		       60		      rts
    128  0483
    129  0483
    130  0483							;---------------------------------------------------------------------------------------------------
    131  0483
      0  0483					      DEF	CopyShadowROMtoRAM
      1  0483				   SLOT_CopyShadowROMtoRAM SET	_BANK_SLOT
      2  0483				   BANK_CopyShadowROMtoRAM SET	SLOT_CopyShadowROMtoRAM + _CURRENT_BANK
      3  0483				   CopyShadowROMtoRAM
      4  0483				   TEMPORARY_VAR SET	Overlay
      5  0483				   TEMPORARY_OFFSET SET	0
      6  0483				   VAR_BOUNDARY_CopyShadowROMtoRAM SET	TEMPORARY_OFFSET
      7  0483				   FUNCTION_NAME SET	CopyShadowROMtoRAM
    133  0483					      SUBROUTINE
    134  0483
      0  0483					      REFER	SetupBanks
      1  0483					      IF	VAREND_SetupBanks > TEMPORARY_VAR
      2  0483				   TEMPORARY_VAR SET	VAREND_SetupBanks
      3  0483					      ENDIF
      0  0483					      VEND	CopyShadowROMtoRAM
      1  0483				  -	      IFNCONST	CopyShadowROMtoRAM
      2  0483				  -	      ECHO	"Incorrect VEND label", CopyShadowROMtoRAM
      3  0483				  -	      ERR
      4  0483					      ENDIF
      5  0483		       00 a2	   VAREND_CopyShadowROMtoRAM =	TEMPORARY_VAR
    137  0483
    138  0483							; Copy a whole ROM SHADOW into a destination RAM 512 byte bank
    139  0483							; used to setup callable RAM code from ROM templates
    140  0483
    141  0483							; x = source ROM bank
    142  0483							; y = destination RAM bank (preserved)
    143  0483
    144  0483		       86 3f		      stx	SET_BANK
    145  0485		       84 3e		      sty	SET_BANK_RAM
    146  0487
    147  0487		       a2 00		      ldx	#0
    148  0489		       bd 00 f8    .copyPage  lda	$F800,x
      0  048c					      sta@RAM	$FC00,x
      1  048c		       9d 00 fe 	      sta	[RAM]+$FC00,x
    150  048f		       bd 00 f9 	      lda	$F900,x
      0  0492					      sta@RAM	$FD00,x
      1  0492		       9d 00 ff 	      sta	[RAM]+$FD00,x
    152  0495		       ca		      dex
    153  0496		       d0 f1		      bne	.copyPage
    154  0498		       60		      rts
    155  0499
    156  0499
    157  0499							;---------------------------------------------------------------------------------------------------
    158  0499
      0  0499					      DEF	CallClear
      1  0499				   SLOT_CallClear SET	_BANK_SLOT
      2  0499				   BANK_CallClear SET	SLOT_CallClear + _CURRENT_BANK
      3  0499				   CallClear
      4  0499				   TEMPORARY_VAR SET	Overlay
      5  0499				   TEMPORARY_OFFSET SET	0
      6  0499				   VAR_BOUNDARY_CallClear SET	TEMPORARY_OFFSET
      7  0499				   FUNCTION_NAME SET	CallClear
    160  0499					      SUBROUTINE
    161  0499
    162  0499				  -	      IF	0
    163  0499				  -	      REFER	aiClearEachRow
    164  0499					      ENDIF
      0  0499					      VEND	CallClear
      1  0499				  -	      IFNCONST	CallClear
      2  0499				  -	      ECHO	"Incorrect VEND label", CallClear
      3  0499				  -	      ERR
      4  0499					      ENDIF
      5  0499		       00 a1	   VAREND_CallClear =	TEMPORARY_VAR
    166  0499
    167  0499				  -	      IF	0
    168  0499				  -			; No transient variable dependencies/calls
    169  0499				  -
    170  0499				  -	      sty	SET_BANK_RAM
    171  0499				  -	      jsr	ClearRowBitmap
    172  0499					      ENDIF
    173  0499		       60		      rts
    174  049a
    175  049a
    176  049a							;---------------------------------------------------------------------------------------------------
    177  049a
      0  049a					      DEF	InitialisePieceSquares
      1  049a				   SLOT_InitialisePieceSquares SET	_BANK_SLOT
      2  049a				   BANK_InitialisePieceSquares SET	SLOT_InitialisePieceSquares + _CURRENT_BANK
      3  049a				   InitialisePieceSquares
      4  049a				   TEMPORARY_VAR SET	Overlay
      5  049a				   TEMPORARY_OFFSET SET	0
      6  049a				   VAR_BOUNDARY_InitialisePieceSquares SET	TEMPORARY_OFFSET
      7  049a				   FUNCTION_NAME SET	InitialisePieceSquares
    179  049a					      SUBROUTINE
    180  049a
      0  049a					      REFER	StartupBankReset
      1  049a				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  049a				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  049a					      ENDIF
      0  049a					      VAR	__initPiece, 1
      1  049a		       00 a1	   __initPiece =	TEMPORARY_VAR
      2  049a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  049a
      4  049a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  049a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  049a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  049a					      ENDIF
      8  049a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  049a				  -	      ECHO	"Temporary Variable", __initPiece, "overflow!"
     10  049a				  -	      ERR
     11  049a					      ENDIF
     12  049a					      LIST	ON
      0  049a					      VAR	__initSquare, 1
      1  049a		       00 a2	   __initSquare =	TEMPORARY_VAR
      2  049a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  049a
      4  049a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  049a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  049a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  049a					      ENDIF
      8  049a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  049a				  -	      ECHO	"Temporary Variable", __initSquare, "overflow!"
     10  049a				  -	      ERR
     11  049a					      ENDIF
     12  049a					      LIST	ON
      0  049a					      VAR	__initListPtr, 1
      1  049a		       00 a3	   __initListPtr =	TEMPORARY_VAR
      2  049a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  049a
      4  049a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  049a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  049a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  049a					      ENDIF
      8  049a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  049a				  -	      ECHO	"Temporary Variable", __initListPtr, "overflow!"
     10  049a				  -	      ERR
     11  049a					      ENDIF
     12  049a					      LIST	ON
      0  049a					      VEND	InitialisePieceSquares
      1  049a				  -	      IFNCONST	InitialisePieceSquares
      2  049a				  -	      ECHO	"Incorrect VEND label", InitialisePieceSquares
      3  049a				  -	      ERR
      4  049a					      ENDIF
      5  049a		       00 a4	   VAREND_InitialisePieceSquares =	TEMPORARY_VAR
    186  049a
    187  049a							;---------------------------------------------------------------------------------------------------
    188  049a
      0  049a					      DEF	InitPieceLists
      1  049a				   SLOT_InitPieceLists SET	_BANK_SLOT
      2  049a				   BANK_InitPieceLists SET	SLOT_InitPieceLists + _CURRENT_BANK
      3  049a				   InitPieceLists
      4  049a				   TEMPORARY_VAR SET	Overlay
      5  049a				   TEMPORARY_OFFSET SET	0
      6  049a				   VAR_BOUNDARY_InitPieceLists SET	TEMPORARY_OFFSET
      7  049a				   FUNCTION_NAME SET	InitPieceLists
    190  049a					      SUBROUTINE
    191  049a
      0  049a					      REFER	InitialisePieceSquares
      1  049a					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  049a				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  049a					      ENDIF
      0  049a					      VEND	InitPieceLists
      1  049a				  -	      IFNCONST	InitPieceLists
      2  049a				  -	      ECHO	"Incorrect VEND label", InitPieceLists
      3  049a				  -	      ERR
      4  049a					      ENDIF
      5  049a		       00 a4	   VAREND_InitPieceLists =	TEMPORARY_VAR
    194  049a
    195  049a
    196  049a		       a9 00		      lda	#0
    197  049c		       85 8f		      sta	Evaluation
    198  049e		       85 90		      sta	Evaluation+1	; tracks CURRENT value of everything (signed 16-bit)
    199  04a0		       85 93		      sta	enPassantPawn	; no en-passant
    200  04a2
    201  04a2
      0  04a2					      PHASE	AI_StartClearBoard
      1  04a2		       a9 0d		      lda	#AI_StartClearBoard
      2  04a4		       85 8b		      sta	aiState
    203  04a6
    204  04a6		       a2 00		      ldx	#0
    205  04a8				   .fillPieceLists
    206  04a8
    207  04a8
    208  04a8		       bd f2 f4 	      lda	InitPieceList,x	; colour/-1
    209  04ab		       f0 44		      beq	.exit
    210  04ad		       85 a1		      sta	__originalPiece	; type
    211  04af		       bc f3 f4 	      ldy	InitPieceList+1,x	; square
    212  04b2		       84 a2		      sty	__initSquare
    213  04b4
    214  04b4		       a9 cf		      lda	#RAMBANK_BOARD
    215  04b6		       85 3e		      sta	SET_BANK_RAM
    216  04b8		       a5 a1		      lda	__originalPiece
      0  04ba					      sta@RAM	Board,y
      1  04ba		       99 79 fe 	      sta	[RAM]+Board,y
    218  04bd		       10 0d		      bpl	.white
    219  04bf
      0  04bf					      NEGEVAL
      1  04bf
      2  04bf		       38		      sec
      3  04c0		       a9 00		      lda	#0
      4  04c2		       e5 8f		      sbc	Evaluation
      5  04c4		       85 8f		      sta	Evaluation
      6  04c6		       a9 00		      lda	#0
      7  04c8		       e5 90		      sbc	Evaluation+1
      8  04ca		       85 90		      sta	Evaluation+1
    221  04cc				   .white
    222  04cc
    223  04cc							; Add the material value of the piece to the evaluation
    224  04cc
    225  04cc		       a5 a1		      lda	__originalPiece
    226  04ce		       20 da f5 	      jsr	AddPieceMaterialValue
    227  04d1
    228  04d1		       86 a3		      stx	__initListPtr
    229  04d3
    230  04d3							; add the positional value of the piece to the evaluation
    231  04d3
    232  04d3		       a4 a2		      ldy	__initSquare
    233  04d5		       a5 a1		      lda	__originalPiece
    234  04d7		       20 93 f5 	      jsr	AddPiecePositionValue
    235  04da
    236  04da		       a5 a1		      lda	__originalPiece	; type/colour
    237  04dc		       10 0d		      bpl	.white2
      0  04de					      NEGEVAL
      1  04de
      2  04de		       38		      sec
      3  04df		       a9 00		      lda	#0
      4  04e1		       e5 8f		      sbc	Evaluation
      5  04e3		       85 8f		      sta	Evaluation
      6  04e5		       a9 00		      lda	#0
      7  04e7		       e5 90		      sbc	Evaluation+1
      8  04e9		       85 90		      sta	Evaluation+1
    239  04eb				   .white2
    240  04eb
    241  04eb		       a6 a3		      ldx	__initListPtr
    242  04ed		       e8		      inx
    243  04ee		       e8		      inx
    244  04ef		       10 b7		      bpl	.fillPieceLists
    245  04f1
    246  04f1				   .exit
    247  04f1		       60		      rts
    248  04f2
    249  04f2
    250  04f2				   InitPieceList
    251  04f2
    252  04f2
    253  04f2					      IF	!TEST_POSITION
    254  04f2
    255  04f2		       06 19		      .byte.b	WHITE|Q, 25
    256  04f4		       04 18		      .byte.b	WHITE|B, 24
    257  04f6		       04 1b		      .byte.b	WHITE|B, 27
    258  04f8		       05 16		      .byte.b	WHITE|R, 22
    259  04fa		       05 1d		      .byte.b	WHITE|R, 29
    260  04fc		       03 17		      .byte.b	WHITE|N, 23
    261  04fe		       03 1c		      .byte.b	WHITE|N, 28
    262  0500
    263  0500		       01 23		      .byte.b	WHITE|WP, 35
    264  0502		       01 24		      .byte.b	WHITE|WP, 36
    265  0504		       01 22		      .byte.b	WHITE|WP, 34
    266  0506		       01 25		      .byte.b	WHITE|WP, 37
    267  0508		       01 21		      .byte.b	WHITE|WP, 33
    268  050a		       01 26		      .byte.b	WHITE|WP, 38
    269  050c		       01 20		      .byte.b	WHITE|WP, 32
    270  050e		       01 27		      .byte.b	WHITE|WP, 39
    271  0510
    272  0510		       07 1a		      .byte.b	WHITE|K, 26
    273  0512
    274  0512		       86 5f		      .byte.b	BLACK|Q, 95
    275  0514		       84 5e		      .byte.b	BLACK|B, 94
    276  0516		       84 61		      .byte.b	BLACK|B, 97
    277  0518		       85 5c		      .byte.b	BLACK|R, 92
    278  051a		       85 63		      .byte.b	BLACK|R, 99
    279  051c		       83 5d		      .byte.b	BLACK|N, 93
    280  051e		       83 62		      .byte.b	BLACK|N, 98
    281  0520
    282  0520		       82 55		      .byte.b	BLACK|BP, 85
    283  0522		       82 56		      .byte.b	BLACK|BP, 86
    284  0524		       82 54		      .byte.b	BLACK|BP, 84
    285  0526		       82 57		      .byte.b	BLACK|BP, 87
    286  0528		       82 53		      .byte.b	BLACK|BP, 83
    287  052a		       82 58		      .byte.b	BLACK|BP, 88
    288  052c		       82 52		      .byte.b	BLACK|BP, 82
    289  052e		       82 59		      .byte.b	BLACK|BP, 89
    290  0530
    291  0530		       87 60		      .byte.b	BLACK|K, 96
    292  0532
    293  0532		       00		      .byte.b	0	;end
    294  0533
    295  0533				  -	      ELSE		; test position...
    296  0533				  -
    297  0533				  -
    298  0533				  -	      IF	0
    299  0533				  -
    300  0533				  -	      .byte	WHITE|K, 28
    301  0533				  -	      .byte	WHITE|WP, 37
    302  0533				  -	      .byte	WHITE|WP, 38
    303  0533				  -	      .byte	WHITE|WP, 53
    304  0533				  -	      .byte	WHITE|WP, 49
    305  0533				  -	      .byte	WHITE|WP, 32
    306  0533				  -	      .byte	WHITE|R, 27
    307  0533				  -	      .byte	WHITE|B, 46
    308  0533				  -	      .byte	WHITE|R, 54
    309  0533				  -
    310  0533				  -	      .byte	BLACK|BP, 56
    311  0533				  -	      .byte	BLACK|BP, 87
    312  0533				  -	      .byte	BLACK|BP, 88
    313  0533				  -	      .byte	BLACK|BP, 89
    314  0533				  -	      .byte	BLACK|BP, 84
    315  0533				  -	      .byte	BLACK|B, 66
    316  0533				  -	      .byte	BLACK|R, 69
    317  0533				  -	      .byte	BLACK|K, 98
    318  0533				  -
    319  0533				  -	      .byte	BLACK|R, 92
    320  0533				  -
    321  0533				  -
    322  0533				  -
    323  0533				  -	      ENDIF
    324  0533				  -
    325  0533				  -
    326  0533				  -	      IF	0
    327  0533				  -			; En passant test
    328  0533				  -
    329  0533				  -	      .byte	BLACK|BP, 88
    330  0533				  -	      .byte	BLACK|BP, 86
    331  0533				  -
    332  0533				  -	      .byte	WHITE|WP, 67
    333  0533				  -	      .byte	WHITE|K, 52
    334  0533				  -
    335  0533				  -
    336  0533				  -	      ENDIF
    337  0533				  -
    338  0533				  -
    339  0533				  -
    340  0533				  -
    341  0533				  -	      IF	1
    342  0533				  -
    343  0533				  -
    344  0533				  -			;.byte BLACK|R, 97
    345  0533				  -	      .byte	BLACK|K, 98
    346  0533				  -	      .byte	BLACK|BP, 87
    347  0533				  -	      .byte	BLACK|BP, 88
    348  0533				  -	      .byte	BLACK|BP, 89
    349  0533				  -			;    .byte BLACK|B, 76
    350  0533				  -
    351  0533				  -
    352  0533				  -	      .byte	WHITE|R,28
    353  0533				  -	      .byte	WHITE|Q,58
    354  0533				  -			;   .byte WHITE|N,65
    355  0533				  -	      ENDIF
    356  0533				  -
    357  0533				  -	      IF	0
    358  0533				  -			;.byte WHITE|WP, 56
    359  0533				  -
    360  0533				  -
    361  0533				  -	      .byte	BLACK|K, 98
    362  0533				  -
    363  0533				  -
    364  0533				  -	      .byte	WHITE|R,29
    365  0533				  -	      .byte	WHITE|Q,49
    366  0533				  -	      .byte	WHITE|N,65
    367  0533				  -	      ENDIF
    368  0533				  -	      .byte	0	;end
    369  0533				  -
    370  0533					      ENDIF
    371  0533
    372  0533
    373  0533							;---------------------------------------------------------------------------------------------------
    374  0533
      0  0533					      DEF	AdjustMaterialPositionalValue
      1  0533				   SLOT_AdjustMaterialPositionalValue SET	_BANK_SLOT
      2  0533				   BANK_AdjustMaterialPositionalValue SET	SLOT_AdjustMaterialPositionalValue + _CURRENT_BANK
      3  0533				   AdjustMaterialPositionalValue
      4  0533				   TEMPORARY_VAR SET	Overlay
      5  0533				   TEMPORARY_OFFSET SET	0
      6  0533				   VAR_BOUNDARY_AdjustMaterialPositionalValue SET	TEMPORARY_OFFSET
      7  0533				   FUNCTION_NAME SET	AdjustMaterialPositionalValue
    376  0533					      SUBROUTINE
    377  0533
    378  0533							; A move is about to be made, so  adjust material and positional values based on from/to and
    379  0533							; capture.
    380  0533
    381  0533							; First, nominate referencing subroutines so that local variables can be adjusted properly
    382  0533
    383  0533							;TODO REFER negaMax
    384  0533							;TODO REFER MakeMove
    385  0533							;TODO REFER aiMoveIsSelected
      0  0533					      VAR	__originalPiece, 1
      1  0533		       00 a1	   __originalPiece =	TEMPORARY_VAR
      2  0533				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0533
      4  0533				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0533				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0533				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0533					      ENDIF
      8  0533				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0533				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  0533				  -	      ERR
     11  0533					      ENDIF
     12  0533					      LIST	ON
      0  0533					      VAR	__capturedPiece, 1
      1  0533		       00 a2	   __capturedPiece =	TEMPORARY_VAR
      2  0533				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0533
      4  0533				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0533				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0533				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0533					      ENDIF
      8  0533				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0533				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  0533				  -	      ERR
     11  0533					      ENDIF
     12  0533					      LIST	ON
      0  0533					      VEND	AdjustMaterialPositionalValue
      1  0533				  -	      IFNCONST	AdjustMaterialPositionalValue
      2  0533				  -	      ECHO	"Incorrect VEND label", AdjustMaterialPositionalValue
      3  0533				  -	      ERR
      4  0533					      ENDIF
      5  0533		       00 a3	   VAREND_AdjustMaterialPositionalValue =	TEMPORARY_VAR
    389  0533
    390  0533							; fromPiece	 piece doing the move (promoted type)
    391  0533							; fromX12	 current square
    392  0533							; originX12	 starting square
    393  0533							; toX12	 ending square
    394  0533
    395  0533
    396  0533							; get the piece types from the board
    397  0533
    398  0533		       a9 cf		      lda	#RAMBANK_BOARD
    399  0535		       85 3e		      sta	SET_BANK_RAM	;@3
    400  0537		       a4 87		      ldy	originX12
    401  0539		       b9 79 fc 	      lda	Board,y
    402  053c		       85 a1		      sta	__originalPiece
    403  053e		       a4 86		      ldy	toX12
    404  0540		       b9 79 fc 	      lda	Board,y
    405  0543		       85 a2		      sta	__capturedPiece
    406  0545
    407  0545							; {
    408  0545							;   adjust the positional value  (originX12 --> fromX12)
    409  0545
    410  0545		       a9 d0		      lda	#RAMBANK_BANK_EVAL
    411  0547		       85 3e		      sta	SET_BANK_RAM	;@3
    412  0549
    413  0549
    414  0549							;ldy toX12			 ; already loaded
    415  0549		       a5 96		      lda	fromPiece
    416  054b		       20 93 f5 	      jsr	AddPiecePositionValue	; add pos value for new position
    417  054e
    418  054e
    419  054e		       a5 a1		      lda	__originalPiece
    420  0550		       45 96		      eor	fromPiece	; the new piece
    421  0552		       29 0f		      and	#PIECE_MASK
    422  0554		       f0 05		      beq	.same1	; unchanged, so skip
    423  0556
    424  0556		       a5 96		      lda	fromPiece	; new piece
    425  0558		       20 da f5 	      jsr	AddPieceMaterialValue
    426  055b
    427  055b				   .same1
    428  055b
    429  055b							; and now the 'subtracts'
    430  055b
      0  055b					      NEGEVAL
      1  055b
      2  055b		       38		      sec
      3  055c		       a9 00		      lda	#0
      4  055e		       e5 8f		      sbc	Evaluation
      5  0560		       85 8f		      sta	Evaluation
      6  0562		       a9 00		      lda	#0
      7  0564		       e5 90		      sbc	Evaluation+1
      8  0566		       85 90		      sta	Evaluation+1
    432  0568
    433  0568		       a4 87		      ldy	originX12
    434  056a		       a5 a1		      lda	__originalPiece
    435  056c		       20 93 f5 	      jsr	AddPiecePositionValue	; remove pos value for original position
    436  056f
    437  056f
    438  056f		       a5 a1		      lda	__originalPiece
    439  0571		       45 96		      eor	fromPiece	; the new piece
    440  0573		       29 0f		      and	#PIECE_MASK
    441  0575		       f0 05		      beq	.same2	; unchanged, so skip
    442  0577
    443  0577		       a5 a1		      lda	__originalPiece
    444  0579		       20 da f5 	      jsr	AddPieceMaterialValue	; remove material for original type
    445  057c				   .same2
    446  057c
      0  057c					      NEGEVAL
      1  057c
      2  057c		       38		      sec
      3  057d		       a9 00		      lda	#0
      4  057f		       e5 8f		      sbc	Evaluation
      5  0581		       85 8f		      sta	Evaluation
      6  0583		       a9 00		      lda	#0
      7  0585		       e5 90		      sbc	Evaluation+1
      8  0587		       85 90		      sta	Evaluation+1
    448  0589
    449  0589							; If there's a capture, we adjust the material value
    450  0589
    451  0589							;		      lda __capturedPiece
    452  0589							;		      eor __originalPiece
    453  0589							;		      bpl .noCapture		      ; special-case capture rook castling onto king
    454  0589
    455  0589
    456  0589		       a5 a2		      lda	__capturedPiece
    457  058b		       29 0f		      and	#PIECE_MASK
    458  058d		       f0 03		      beq	.noCapture
    459  058f		       20 da f5 	      jsr	AddPieceMaterialValue	; -other colour = + my colour!
    460  0592				   .noCapture
    461  0592
    462  0592							; }
    463  0592		       60		      rts
    464  0593
    465  0593
    466  0593							;---------------------------------------------------------------------------------------------------
    467  0593
      0  0593					      DEF	AddPiecePositionValue
      1  0593				   SLOT_AddPiecePositionValue SET	_BANK_SLOT
      2  0593				   BANK_AddPiecePositionValue SET	SLOT_AddPiecePositionValue + _CURRENT_BANK
      3  0593				   AddPiecePositionValue
      4  0593				   TEMPORARY_VAR SET	Overlay
      5  0593				   TEMPORARY_OFFSET SET	0
      6  0593				   VAR_BOUNDARY_AddPiecePositionValue SET	TEMPORARY_OFFSET
      7  0593				   FUNCTION_NAME SET	AddPiecePositionValue
    469  0593					      SUBROUTINE
    470  0593
      0  0593					      REFER	AdjustMaterialPositionalValue
      1  0593					      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  0593				   TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  0593					      ENDIF
      0  0593					      REFER	EnPassantRemovePiece
      1  0593				  -	      IF	VAREND_EnPassantRemovePiece > TEMPORARY_VAR
      2  0593				  -TEMPORARY_VAR SET	VAREND_EnPassantRemovePiece
      3  0593					      ENDIF
      0  0593					      REFER	InitPieceLists
      1  0593					      IF	VAREND_InitPieceLists > TEMPORARY_VAR
      2  0593				   TEMPORARY_VAR SET	VAREND_InitPieceLists
      3  0593					      ENDIF
      0  0593					      REFER	negaMax
      1  0593					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0593				   TEMPORARY_VAR SET	VAREND_negaMax
      3  0593					      ENDIF
      0  0593					      REFER	quiesce
      1  0593				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  0593				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  0593					      ENDIF
    476  0593
      0  0593					      VAR	__valPtr, 2
      1  0593		       00 ad	   __valPtr   =	TEMPORARY_VAR
      2  0593				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0593
      4  0593				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0593				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0593				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0593					      ENDIF
      8  0593				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0593				  -	      ECHO	"Temporary Variable", __valPtr, "overflow!"
     10  0593				  -	      ERR
     11  0593					      ENDIF
     12  0593					      LIST	ON
      0  0593					      VAR	__valHi, 1
      1  0593		       00 af	   __valHi    =	TEMPORARY_VAR
      2  0593				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0593
      4  0593				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0593				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0593				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0593					      ENDIF
      8  0593				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0593				  -	      ECHO	"Temporary Variable", __valHi, "overflow!"
     10  0593				  -	      ERR
     11  0593					      ENDIF
     12  0593					      LIST	ON
      0  0593					      VEND	AddPiecePositionValue
      1  0593				  -	      IFNCONST	AddPiecePositionValue
      2  0593				  -	      ECHO	"Incorrect VEND label", AddPiecePositionValue
      3  0593				  -	      ERR
      4  0593					      ENDIF
      5  0593		       00 b0	   VAREND_AddPiecePositionValue =	TEMPORARY_VAR
    480  0593
    481  0593
    482  0593							; adds value of square piece is on to the evaluation
    483  0593							; note to do the subtraction as -( -x + val) == x - val
    484  0593
    485  0593							; y = square
    486  0593							; a = piece type (+flags)
    487  0593
    488  0593
    489  0593
    490  0593		       c9 80		      cmp	#128	; black = CS
    491  0595		       29 0f		      and	#PIECE_MASK
    492  0597		       aa		      tax
    493  0598
    494  0598		       a9 c6		      lda	#EVAL
    495  059a		       85 3f		      sta	SET_BANK	;@3
    496  059c
    497  059c							; black pieces flip rows so we can use the same eval tables
    498  059c
    499  059c		       98		      tya
    500  059d		       90 03		      bcc	.white
    501  059f		       b9 00 f6 	      lda	FlipSquareIndex,y
    502  05a2							;clc
    503  05a2				   .white
    504  05a2		       7d 10 fc 	      adc	PosValVecLO,x
    505  05a5		       85 ad		      sta	__valPtr
    506  05a7		       bd 18 fc 	      lda	PosValVecHI,x
    507  05aa		       69 00		      adc	#0
    508  05ac		       85 ae		      sta	__valPtr+1
    509  05ae
    510  05ae		       a0 00		      ldy	#0
    511  05b0		       84 af		      sty	__valHi
    512  05b2		       b1 ad		      lda	(__valPtr),y
    513  05b4		       10 02		      bpl	.sum
    514  05b6		       c6 af		      dec	__valHi
    515  05b8
    516  05b8		       18	   .sum       clc
    517  05b9		       65 8f		      adc	Evaluation
    518  05bb		       85 8f		      sta	Evaluation
    519  05bd		       a5 90		      lda	Evaluation+1
    520  05bf		       65 af		      adc	__valHi
    521  05c1		       85 90		      sta	Evaluation+1
    522  05c3		       60		      rts
    523  05c4
    524  05c4
    525  05c4							;---------------------------------------------------------------------------------------------------
    526  05c4
      0  05c4					      DEF	EnPassantRemovePiece
      1  05c4				   SLOT_EnPassantRemovePiece SET	_BANK_SLOT
      2  05c4				   BANK_EnPassantRemovePiece SET	SLOT_EnPassantRemovePiece + _CURRENT_BANK
      3  05c4				   EnPassantRemovePiece
      4  05c4				   TEMPORARY_VAR SET	Overlay
      5  05c4				   TEMPORARY_OFFSET SET	0
      6  05c4				   VAR_BOUNDARY_EnPassantRemovePiece SET	TEMPORARY_OFFSET
      7  05c4				   FUNCTION_NAME SET	EnPassantRemovePiece
    528  05c4					      SUBROUTINE
    529  05c4
    530  05c4							;TODO REFER MakeMove
    531  05c4				  -	      IF	ENPASSANT_ENABLED
    532  05c4				  -	      REFER	EnPassantCheck
    533  05c4					      ENDIF
      0  05c4					      VAR	__y, 1
      1  05c4		       00 a1	   __y	      =	TEMPORARY_VAR
      2  05c4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  05c4
      4  05c4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05c4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05c4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05c4					      ENDIF
      8  05c4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  05c4				  -	      ECHO	"Temporary Variable", __y, "overflow!"
     10  05c4				  -	      ERR
     11  05c4					      ENDIF
     12  05c4					      LIST	ON
      0  05c4					      VAR	__col, 1
      1  05c4		       00 a2	   __col      =	TEMPORARY_VAR
      2  05c4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  05c4
      4  05c4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05c4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05c4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05c4					      ENDIF
      8  05c4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  05c4				  -	      ECHO	"Temporary Variable", __col, "overflow!"
     10  05c4				  -	      ERR
     11  05c4					      ENDIF
     12  05c4					      LIST	ON
      0  05c4					      VEND	EnPassantRemovePiece
      1  05c4				  -	      IFNCONST	EnPassantRemovePiece
      2  05c4				  -	      ECHO	"Incorrect VEND label", EnPassantRemovePiece
      3  05c4				  -	      ERR
      4  05c4					      ENDIF
      5  05c4		       00 a3	   VAREND_EnPassantRemovePiece =	TEMPORARY_VAR
    537  05c4
    538  05c4
    539  05c4							; Based on piece square, adjust material and position value with piece deleted
    540  05c4							; y = piece square
    541  05c4
    542  05c4		       84 a1		      sty	__y
    543  05c6
    544  05c6		       a9 cf		      lda	#RAMBANK_BOARD
    545  05c8		       85 3e		      sta	SET_BANK_RAM	;@3
    546  05ca		       b9 79 fc 	      lda	Board,y
    547  05cd		       85 a2		      sta	__col
    548  05cf		       20 da f5 	      jsr	AddPieceMaterialValue	; adding for opponent = taking
    549  05d2
    550  05d2		       a5 a2		      lda	__col
    551  05d4		       a4 a1		      ldy	__y
    552  05d6		       20 93 f5 	      jsr	AddPiecePositionValue	; adding for opponent = taking
    553  05d9
    554  05d9		       60		      rts
    555  05da
    556  05da
    557  05da							;---------------------------------------------------------------------------------------------------
    558  05da
      0  05da					      DEF	AddPieceMaterialValue
      1  05da				   SLOT_AddPieceMaterialValue SET	_BANK_SLOT
      2  05da				   BANK_AddPieceMaterialValue SET	SLOT_AddPieceMaterialValue + _CURRENT_BANK
      3  05da				   AddPieceMaterialValue
      4  05da				   TEMPORARY_VAR SET	Overlay
      5  05da				   TEMPORARY_OFFSET SET	0
      6  05da				   VAR_BOUNDARY_AddPieceMaterialValue SET	TEMPORARY_OFFSET
      7  05da				   FUNCTION_NAME SET	AddPieceMaterialValue
    560  05da					      SUBROUTINE
    561  05da
      0  05da					      REFER	AdjustMaterialPositionalValue
      1  05da					      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  05da				   TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  05da					      ENDIF
      0  05da					      REFER	InitialisePieceSquares
      1  05da					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  05da				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  05da					      ENDIF
      0  05da					      REFER	EnPassantRemovePiece
      1  05da				  -	      IF	VAREND_EnPassantRemovePiece > TEMPORARY_VAR
      2  05da				  -TEMPORARY_VAR SET	VAREND_EnPassantRemovePiece
      3  05da					      ENDIF
      0  05da					      REFER	InitPieceLists
      1  05da				  -	      IF	VAREND_InitPieceLists > TEMPORARY_VAR
      2  05da				  -TEMPORARY_VAR SET	VAREND_InitPieceLists
      3  05da					      ENDIF
      0  05da					      VEND	AddPieceMaterialValue
      1  05da				  -	      IFNCONST	AddPieceMaterialValue
      2  05da				  -	      ECHO	"Incorrect VEND label", AddPieceMaterialValue
      3  05da				  -	      ERR
      4  05da					      ENDIF
      5  05da		       00 a4	   VAREND_AddPieceMaterialValue =	TEMPORARY_VAR
    567  05da
    568  05da							; Adjust the material score based on the piece
    569  05da							; a = piece type + flags
    570  05da
    571  05da		       29 0f		      and	#PIECE_MASK
    572  05dc		       a8		      tay
    573  05dd
    574  05dd		       a9 c6		      lda	#EVAL
    575  05df		       85 3f		      sta	SET_BANK	;@3
    576  05e1
    577  05e1		       18		      clc
    578  05e2		       b9 00 fc 	      lda	PieceValueLO,y
    579  05e5		       65 8f		      adc	Evaluation
    580  05e7		       85 8f		      sta	Evaluation
    581  05e9		       b9 08 fc 	      lda	PieceValueHI,y
    582  05ec		       65 90		      adc	Evaluation+1
    583  05ee		       85 90		      sta	Evaluation+1
    584  05f0		       60		      rts
    585  05f1
    586  05f1
    587  05f1
    588  05f1
    589  05f1				  -	      IF	0
    590  05f1				  -	      DEF	IncVal
    591  05f1				  -	      SUBROUTINE
    592  05f1				  -
    593  05f1				  -	      ldx	#99
    594  05f1				  -.higher    clc
    595  05f1				  -	      lda@RAM	PositionalValue_PAWN_BLACK,x
    596  05f1				  -	      adc	#10
    597  05f1				  -	      cmp	#$7F
    598  05f1				  -	      bcc	.norm
    599  05f1				  -	      lda	#$7f
    600  05f1				  -.norm      sta@RAM	PositionalValue_PAWN_BLACK,x
    601  05f1				  -	      dex
    602  05f1				  -	      bpl	.higher
    603  05f1				  -	      rts
    604  05f1					      ENDIF
    605  05f1							;---------------------------------------------------------------------------------------------------
    606  05f1
      0  05f1					      ALLOCATE	FlipSquareIndex, 100
      0  05f1					      OPTIONAL_PAGEBREAK	"Table", 100
     12  0600					      LIST	ON
      0  0600					      DEF	FlipSquareIndex
      1  0600				   SLOT_FlipSquareIndex SET	_BANK_SLOT
      2  0600				   BANK_FlipSquareIndex SET	SLOT_FlipSquareIndex + _CURRENT_BANK
      3  0600				   FlipSquareIndex
      4  0600				   TEMPORARY_VAR SET	Overlay
      5  0600				   TEMPORARY_OFFSET SET	0
      6  0600				   VAR_BOUNDARY_FlipSquareIndex SET	TEMPORARY_OFFSET
      7  0600				   FUNCTION_NAME SET	FlipSquareIndex
    608  0600
    609  0600		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    610  060a		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    611  0614
    612  0614				   .SQBASE    SET	90-1
    613  0614					      REPEAT	8
    614  0614		       00 00		      .byte.b	0,0
    615  0614				   .SQX       SET	2
    616  0616					      REPEAT	8
    617  0616		       5b		      .byte.b	(.SQBASE+.SQX)
    618  0616				   .SQX       SET	.SQX + 1
    616  0616					      REPEND
    617  0617		       5c		      .byte.b	(.SQBASE+.SQX)
    618  0617				   .SQX       SET	.SQX + 1
    616  0617					      REPEND
    617  0618		       5d		      .byte.b	(.SQBASE+.SQX)
    618  0618				   .SQX       SET	.SQX + 1
    616  0618					      REPEND
    617  0619		       5e		      .byte.b	(.SQBASE+.SQX)
    618  0619				   .SQX       SET	.SQX + 1
    616  0619					      REPEND
    617  061a		       5f		      .byte.b	(.SQBASE+.SQX)
    618  061a				   .SQX       SET	.SQX + 1
    616  061a					      REPEND
    617  061b		       60		      .byte.b	(.SQBASE+.SQX)
    618  061b				   .SQX       SET	.SQX + 1
    616  061b					      REPEND
    617  061c		       61		      .byte.b	(.SQBASE+.SQX)
    618  061c				   .SQX       SET	.SQX + 1
    616  061c					      REPEND
    617  061d		       62		      .byte.b	(.SQBASE+.SQX)
    618  061d				   .SQX       SET	.SQX + 1
    619  061e					      REPEND
    620  061e				   .SQBASE    SET	.SQBASE - 10
    613  061e					      REPEND
    614  061e		       00 00		      .byte.b	0,0
    615  061e				   .SQX       SET	2
    616  0620					      REPEAT	8
    617  0620		       51		      .byte.b	(.SQBASE+.SQX)
    618  0620				   .SQX       SET	.SQX + 1
    616  0620					      REPEND
    617  0621		       52		      .byte.b	(.SQBASE+.SQX)
    618  0621				   .SQX       SET	.SQX + 1
    616  0621					      REPEND
    617  0622		       53		      .byte.b	(.SQBASE+.SQX)
    618  0622				   .SQX       SET	.SQX + 1
    616  0622					      REPEND
    617  0623		       54		      .byte.b	(.SQBASE+.SQX)
    618  0623				   .SQX       SET	.SQX + 1
    616  0623					      REPEND
    617  0624		       55		      .byte.b	(.SQBASE+.SQX)
    618  0624				   .SQX       SET	.SQX + 1
    616  0624					      REPEND
    617  0625		       56		      .byte.b	(.SQBASE+.SQX)
    618  0625				   .SQX       SET	.SQX + 1
    616  0625					      REPEND
    617  0626		       57		      .byte.b	(.SQBASE+.SQX)
    618  0626				   .SQX       SET	.SQX + 1
    616  0626					      REPEND
    617  0627		       58		      .byte.b	(.SQBASE+.SQX)
    618  0627				   .SQX       SET	.SQX + 1
    619  0628					      REPEND
    620  0628				   .SQBASE    SET	.SQBASE - 10
    613  0628					      REPEND
    614  0628		       00 00		      .byte.b	0,0
    615  0628				   .SQX       SET	2
    616  062a					      REPEAT	8
    617  062a		       47		      .byte.b	(.SQBASE+.SQX)
    618  062a				   .SQX       SET	.SQX + 1
    616  062a					      REPEND
    617  062b		       48		      .byte.b	(.SQBASE+.SQX)
    618  062b				   .SQX       SET	.SQX + 1
    616  062b					      REPEND
    617  062c		       49		      .byte.b	(.SQBASE+.SQX)
    618  062c				   .SQX       SET	.SQX + 1
    616  062c					      REPEND
    617  062d		       4a		      .byte.b	(.SQBASE+.SQX)
    618  062d				   .SQX       SET	.SQX + 1
    616  062d					      REPEND
    617  062e		       4b		      .byte.b	(.SQBASE+.SQX)
    618  062e				   .SQX       SET	.SQX + 1
    616  062e					      REPEND
    617  062f		       4c		      .byte.b	(.SQBASE+.SQX)
    618  062f				   .SQX       SET	.SQX + 1
    616  062f					      REPEND
    617  0630		       4d		      .byte.b	(.SQBASE+.SQX)
    618  0630				   .SQX       SET	.SQX + 1
    616  0630					      REPEND
    617  0631		       4e		      .byte.b	(.SQBASE+.SQX)
    618  0631				   .SQX       SET	.SQX + 1
    619  0632					      REPEND
    620  0632				   .SQBASE    SET	.SQBASE - 10
    613  0632					      REPEND
    614  0632		       00 00		      .byte.b	0,0
    615  0632				   .SQX       SET	2
    616  0634					      REPEAT	8
    617  0634		       3d		      .byte.b	(.SQBASE+.SQX)
    618  0634				   .SQX       SET	.SQX + 1
    616  0634					      REPEND
    617  0635		       3e		      .byte.b	(.SQBASE+.SQX)
    618  0635				   .SQX       SET	.SQX + 1
    616  0635					      REPEND
    617  0636		       3f		      .byte.b	(.SQBASE+.SQX)
    618  0636				   .SQX       SET	.SQX + 1
    616  0636					      REPEND
    617  0637		       40		      .byte.b	(.SQBASE+.SQX)
    618  0637				   .SQX       SET	.SQX + 1
    616  0637					      REPEND
    617  0638		       41		      .byte.b	(.SQBASE+.SQX)
    618  0638				   .SQX       SET	.SQX + 1
    616  0638					      REPEND
    617  0639		       42		      .byte.b	(.SQBASE+.SQX)
    618  0639				   .SQX       SET	.SQX + 1
    616  0639					      REPEND
    617  063a		       43		      .byte.b	(.SQBASE+.SQX)
    618  063a				   .SQX       SET	.SQX + 1
    616  063a					      REPEND
    617  063b		       44		      .byte.b	(.SQBASE+.SQX)
    618  063b				   .SQX       SET	.SQX + 1
    619  063c					      REPEND
    620  063c				   .SQBASE    SET	.SQBASE - 10
    613  063c					      REPEND
    614  063c		       00 00		      .byte.b	0,0
    615  063c				   .SQX       SET	2
    616  063e					      REPEAT	8
    617  063e		       33		      .byte.b	(.SQBASE+.SQX)
    618  063e				   .SQX       SET	.SQX + 1
    616  063e					      REPEND
    617  063f		       34		      .byte.b	(.SQBASE+.SQX)
    618  063f				   .SQX       SET	.SQX + 1
    616  063f					      REPEND
    617  0640		       35		      .byte.b	(.SQBASE+.SQX)
    618  0640				   .SQX       SET	.SQX + 1
    616  0640					      REPEND
    617  0641		       36		      .byte.b	(.SQBASE+.SQX)
    618  0641				   .SQX       SET	.SQX + 1
    616  0641					      REPEND
    617  0642		       37		      .byte.b	(.SQBASE+.SQX)
    618  0642				   .SQX       SET	.SQX + 1
    616  0642					      REPEND
    617  0643		       38		      .byte.b	(.SQBASE+.SQX)
    618  0643				   .SQX       SET	.SQX + 1
    616  0643					      REPEND
    617  0644		       39		      .byte.b	(.SQBASE+.SQX)
    618  0644				   .SQX       SET	.SQX + 1
    616  0644					      REPEND
    617  0645		       3a		      .byte.b	(.SQBASE+.SQX)
    618  0645				   .SQX       SET	.SQX + 1
    619  0646					      REPEND
    620  0646				   .SQBASE    SET	.SQBASE - 10
    613  0646					      REPEND
    614  0646		       00 00		      .byte.b	0,0
    615  0646				   .SQX       SET	2
    616  0648					      REPEAT	8
    617  0648		       29		      .byte.b	(.SQBASE+.SQX)
    618  0648				   .SQX       SET	.SQX + 1
    616  0648					      REPEND
    617  0649		       2a		      .byte.b	(.SQBASE+.SQX)
    618  0649				   .SQX       SET	.SQX + 1
    616  0649					      REPEND
    617  064a		       2b		      .byte.b	(.SQBASE+.SQX)
    618  064a				   .SQX       SET	.SQX + 1
    616  064a					      REPEND
    617  064b		       2c		      .byte.b	(.SQBASE+.SQX)
    618  064b				   .SQX       SET	.SQX + 1
    616  064b					      REPEND
    617  064c		       2d		      .byte.b	(.SQBASE+.SQX)
    618  064c				   .SQX       SET	.SQX + 1
    616  064c					      REPEND
    617  064d		       2e		      .byte.b	(.SQBASE+.SQX)
    618  064d				   .SQX       SET	.SQX + 1
    616  064d					      REPEND
    617  064e		       2f		      .byte.b	(.SQBASE+.SQX)
    618  064e				   .SQX       SET	.SQX + 1
    616  064e					      REPEND
    617  064f		       30		      .byte.b	(.SQBASE+.SQX)
    618  064f				   .SQX       SET	.SQX + 1
    619  0650					      REPEND
    620  0650				   .SQBASE    SET	.SQBASE - 10
    613  0650					      REPEND
    614  0650		       00 00		      .byte.b	0,0
    615  0650				   .SQX       SET	2
    616  0652					      REPEAT	8
    617  0652		       1f		      .byte.b	(.SQBASE+.SQX)
    618  0652				   .SQX       SET	.SQX + 1
    616  0652					      REPEND
    617  0653		       20		      .byte.b	(.SQBASE+.SQX)
    618  0653				   .SQX       SET	.SQX + 1
    616  0653					      REPEND
    617  0654		       21		      .byte.b	(.SQBASE+.SQX)
    618  0654				   .SQX       SET	.SQX + 1
    616  0654					      REPEND
    617  0655		       22		      .byte.b	(.SQBASE+.SQX)
    618  0655				   .SQX       SET	.SQX + 1
    616  0655					      REPEND
    617  0656		       23		      .byte.b	(.SQBASE+.SQX)
    618  0656				   .SQX       SET	.SQX + 1
    616  0656					      REPEND
    617  0657		       24		      .byte.b	(.SQBASE+.SQX)
    618  0657				   .SQX       SET	.SQX + 1
    616  0657					      REPEND
    617  0658		       25		      .byte.b	(.SQBASE+.SQX)
    618  0658				   .SQX       SET	.SQX + 1
    616  0658					      REPEND
    617  0659		       26		      .byte.b	(.SQBASE+.SQX)
    618  0659				   .SQX       SET	.SQX + 1
    619  065a					      REPEND
    620  065a				   .SQBASE    SET	.SQBASE - 10
    613  065a					      REPEND
    614  065a		       00 00		      .byte.b	0,0
    615  065a				   .SQX       SET	2
    616  065c					      REPEAT	8
    617  065c		       15		      .byte.b	(.SQBASE+.SQX)
    618  065c				   .SQX       SET	.SQX + 1
    616  065c					      REPEND
    617  065d		       16		      .byte.b	(.SQBASE+.SQX)
    618  065d				   .SQX       SET	.SQX + 1
    616  065d					      REPEND
    617  065e		       17		      .byte.b	(.SQBASE+.SQX)
    618  065e				   .SQX       SET	.SQX + 1
    616  065e					      REPEND
    617  065f		       18		      .byte.b	(.SQBASE+.SQX)
    618  065f				   .SQX       SET	.SQX + 1
    616  065f					      REPEND
    617  0660		       19		      .byte.b	(.SQBASE+.SQX)
    618  0660				   .SQX       SET	.SQX + 1
    616  0660					      REPEND
    617  0661		       1a		      .byte.b	(.SQBASE+.SQX)
    618  0661				   .SQX       SET	.SQX + 1
    616  0661					      REPEND
    617  0662		       1b		      .byte.b	(.SQBASE+.SQX)
    618  0662				   .SQX       SET	.SQX + 1
    616  0662					      REPEND
    617  0663		       1c		      .byte.b	(.SQBASE+.SQX)
    618  0663				   .SQX       SET	.SQX + 1
    619  0664					      REPEND
    620  0664				   .SQBASE    SET	.SQBASE - 10
    621  0664					      REPEND
    622  0664
    623  0664
    624  0664							;---------------------------------------------------------------------------------------------------
    625  0664
      0  0664					      DEF	MakeMove
      1  0664				   SLOT_MakeMove SET	_BANK_SLOT
      2  0664				   BANK_MakeMove SET	SLOT_MakeMove + _CURRENT_BANK
      3  0664				   MakeMove
      4  0664				   TEMPORARY_VAR SET	Overlay
      5  0664				   TEMPORARY_OFFSET SET	0
      6  0664				   VAR_BOUNDARY_MakeMove SET	TEMPORARY_OFFSET
      7  0664				   FUNCTION_NAME SET	MakeMove
    627  0664					      SUBROUTINE
    628  0664
      0  0664					      REFER	negaMax
      1  0664					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0664				   TEMPORARY_VAR SET	VAREND_negaMax
      3  0664					      ENDIF
      0  0664					      VAR	__capture, 1
      1  0664		       00 ad	   __capture  =	TEMPORARY_VAR
      2  0664				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0664
      4  0664				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0664				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0664				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0664					      ENDIF
      8  0664				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0664				  -	      ECHO	"Temporary Variable", __capture, "overflow!"
     10  0664				  -	      ERR
     11  0664					      ENDIF
     12  0664					      LIST	ON
      0  0664					      VAR	__restore, 1
      1  0664		       00 ae	   __restore  =	TEMPORARY_VAR
      2  0664				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0664
      4  0664				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0664				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0664				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0664					      ENDIF
      8  0664				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0664				  -	      ECHO	"Temporary Variable", __restore, "overflow!"
     10  0664				  -	      ERR
     11  0664					      ENDIF
     12  0664					      LIST	ON
      0  0664					      VEND	MakeMove
      1  0664				  -	      IFNCONST	MakeMove
      2  0664				  -	      ECHO	"Incorrect VEND label", MakeMove
      3  0664				  -	      ERR
      4  0664					      ENDIF
      5  0664		       00 af	   VAREND_MakeMove =	TEMPORARY_VAR
    633  0664
    634  0664							; Do a move without any GUI stuff
    635  0664							; This function is ALWAYS paired with "unmakeMove" - a call to both will leave board
    636  0664							; and all relevant flags in original state. This is NOT used for the visible move on the
    637  0664							; screen.
    638  0664
    639  0664
    640  0664							; fromPiece	 piece doing the move
    641  0664							; fromX12	 current square X12
    642  0664							; originX12	 starting square X12
    643  0664							; toX12	 ending square X12
    644  0664
    645  0664							; BANK:SLOT2 = currentPly
    646  0664
    647  0664
    648  0664							; There are potentially "two" moves, with the following
    649  0664							; a) Castling, moving both rook and king
    650  0664							; b) en-Passant, capturing pawn on "odd" square
    651  0664							; These both set "secondary" movers which are used for restoring during unmakeMove
    652  0664
    653  0664		       a9 00		      lda	#0
      0  0666					      sta@PLY	secondaryPiece
      1  0666		       8d cd fb 	      sta	[RAM]+secondaryPiece
    655  0669
      0  0669					      ldx@PLY	movePtr
      1  0669		       ae d1 f9 	      ldx	movePtr
      0  066c					      lda@PLY	MoveFrom,x
      1  066c		       bd 00 f8 	      lda	MoveFrom,x
    658  066f		       85 85		      sta	fromX12
    659  0671		       85 87		      sta	originX12
      0  0673					      lda@PLY	MoveTo,x
      1  0673		       bd 64 f8 	      lda	MoveTo,x
    661  0676		       85 86		      sta	toX12
      0  0678					      lda@PLY	MovePiece,x
      1  0678		       bd 00 f9 	      lda	MovePiece,x
    663  067b		       85 96		      sta	fromPiece
    664  067d
    665  067d		       20 33 f5    .move      jsr	AdjustMaterialPositionalValue
    666  0680
    667  0680							; Modify the board
    668  0680
    669  0680		       a0 cf		      ldy	#RAMBANK_BOARD
    670  0682		       84 3e		      sty	SET_BANK_RAM	;@3
    671  0684		       a4 87		      ldy	originX12
      0  0686					      lda@RAM	Board,y
      1  0686		       b9 79 fc 	      lda	Board,y
    673  0689		       85 ae		      sta	__restore
    674  068b		       a9 00		      lda	#0
      0  068d					      sta@RAM	Board,y
      1  068d		       99 79 fe 	      sta	[RAM]+Board,y
    676  0690		       a4 86		      ldy	toX12
      0  0692					      lda@RAM	Board,y
      1  0692		       b9 79 fc 	      lda	Board,y
    678  0695		       85 ad		      sta	__capture
    679  0697		       a5 96		      lda	fromPiece
    680  0699		       29 8f		      and	#PIECE_MASK|FLAG_COLOUR
    681  069b		       09 40		      ora	#FLAG_MOVED
      0  069d					      sta@RAM	Board,y
      1  069d		       99 79 fe 	      sta	[RAM]+Board,y
    683  06a0
    684  06a0		       a5 94		      lda	currentPly
    685  06a2		       85 3e		      sta	SET_BANK_RAM	;@2
    686  06a4		       a5 ad		      lda	__capture
      0  06a6					      sta@PLY	capturedPiece
      1  06a6		       8d cb fb 	      sta	[RAM]+capturedPiece
    688  06a9		       a5 ae		      lda	__restore
      0  06ab					      sta@PLY	restorePiece
      1  06ab		       8d da fb 	      sta	[RAM]+restorePiece
    690  06ae
    691  06ae					      IF	CASTLING_ENABLED
    692  06ae
    693  06ae							; If the FROM piece has the castle bit set (i.e., it's a king that's just moved 2 squares)
    694  06ae							; then we find the appropriate ROOK, set the secondary piece "undo" information, and then
    695  06ae							; redo the moving code (for the rook, this time).
    696  06ae
    697  06ae		       20 e4 f6 	      jsr	GenCastleMoveForRook
    698  06b1		       b0 ca		      bcs	.move	; move the rook!
    699  06b3					      ENDIF
    700  06b3
    701  06b3
    702  06b3				  -	      IF	ENPASSANT_ENABLED
    703  06b3				  -	      jsr	EnPassantCheck
    704  06b3				  -	      beq	.notEnPassant
    705  06b3				  -	      jsr	EnPassantRemovePiece	; y = origin X12
    706  06b3				  -.notEnPassant
    707  06b3					      ENDIF
    708  06b3
    709  06b3							; Swap over sides
    710  06b3
      0  06b3					      NEGEVAL
      1  06b3
      2  06b3		       38		      sec
      3  06b4		       a9 00		      lda	#0
      4  06b6		       e5 8f		      sbc	Evaluation
      5  06b8		       85 8f		      sta	Evaluation
      6  06ba		       a9 00		      lda	#0
      7  06bc		       e5 90		      sbc	Evaluation+1
      8  06be		       85 90		      sta	Evaluation+1
      0  06c0					      SWAP
      1  06c0		       a5 95		      lda	sideToMove
      2  06c2		       49 80		      eor	#SWAP_SIDE
      3  06c4		       85 95		      sta	sideToMove
    713  06c6		       60		      rts
    714  06c7
    715  06c7							;---------------------------------------------------------------------------------------------------
    716  06c7
      0  06c7					      DEF	CastleFixupDraw
      1  06c7				   SLOT_CastleFixupDraw SET	_BANK_SLOT
      2  06c7				   BANK_CastleFixupDraw SET	SLOT_CastleFixupDraw + _CURRENT_BANK
      3  06c7				   CastleFixupDraw
      4  06c7				   TEMPORARY_VAR SET	Overlay
      5  06c7				   TEMPORARY_OFFSET SET	0
      6  06c7				   VAR_BOUNDARY_CastleFixupDraw SET	TEMPORARY_OFFSET
      7  06c7				   FUNCTION_NAME SET	CastleFixupDraw
    718  06c7					      SUBROUTINE
    719  06c7
      0  06c7					      REFER	aiSpecialMoveFixup
      1  06c7					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  06c7				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  06c7					      ENDIF
      0  06c7					      VEND	CastleFixupDraw
      1  06c7				  -	      IFNCONST	CastleFixupDraw
      2  06c7				  -	      ECHO	"Incorrect VEND label", CastleFixupDraw
      3  06c7				  -	      ERR
      4  06c7					      ENDIF
      5  06c7		       00 ad	   VAREND_CastleFixupDraw =	TEMPORARY_VAR
    722  06c7
    723  06c7							; fixup any castling issues
    724  06c7							; at this point the king has finished his two-square march
    725  06c7							; based on the finish square, we determine which rook we're interacting with
    726  06c7							; and generate a 'move' for the rook to position on the other side of the king
    727  06c7
    728  06c7
    729  06c7					      IF	CASTLING_ENABLED
    730  06c7		       20 e4 f6 	      jsr	GenCastleMoveForRook
    731  06ca		       b0 07		      bcs	.phase
    732  06cc					      ENDIF
    733  06cc
      0  06cc					      SWAP
      1  06cc		       a5 95		      lda	sideToMove
      2  06ce		       49 80		      eor	#SWAP_SIDE
      3  06d0		       85 95		      sta	sideToMove
    735  06d2		       60		      rts
    736  06d3
    737  06d3				   .phase
    738  06d3
    739  06d3							; in this siutation (castle, rook moving) we do not change sides yet!
    740  06d3
      0  06d3					      PHASE	AI_MoveIsSelected
      1  06d3		       a9 14		      lda	#AI_MoveIsSelected
      2  06d5		       85 8b		      sta	aiState
    742  06d7		       60		      rts
    743  06d8
    744  06d8
    745  06d8
    746  06d8		       18 1c 5e 62 KSquare    .byte.b	24,28,94,98
    747  06dc		       16 1d 5c 63 RSquareStart .byte.b	22,29,92,99
    748  06e0		       19 1b 5f 61 RSquareEnd .byte.b	25,27,95,97
    749  06e4
    750  06e4
    751  06e4							;---------------------------------------------------------------------------------------------------
    752  06e4
      0  06e4					      DEF	GenCastleMoveForRook
      1  06e4				   SLOT_GenCastleMoveForRook SET	_BANK_SLOT
      2  06e4				   BANK_GenCastleMoveForRook SET	SLOT_GenCastleMoveForRook + _CURRENT_BANK
      3  06e4				   GenCastleMoveForRook
      4  06e4				   TEMPORARY_VAR SET	Overlay
      5  06e4				   TEMPORARY_OFFSET SET	0
      6  06e4				   VAR_BOUNDARY_GenCastleMoveForRook SET	TEMPORARY_OFFSET
      7  06e4				   FUNCTION_NAME SET	GenCastleMoveForRook
    754  06e4					      SUBROUTINE
    755  06e4
      0  06e4					      REFER	MakeMove
      1  06e4					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  06e4				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  06e4					      ENDIF
      0  06e4					      REFER	CastleFixupDraw
      1  06e4				  -	      IF	VAREND_CastleFixupDraw > TEMPORARY_VAR
      2  06e4				  -TEMPORARY_VAR SET	VAREND_CastleFixupDraw
      3  06e4					      ENDIF
      0  06e4					      VEND	GenCastleMoveForRook
      1  06e4				  -	      IFNCONST	GenCastleMoveForRook
      2  06e4				  -	      ECHO	"Incorrect VEND label", GenCastleMoveForRook
      3  06e4				  -	      ERR
      4  06e4					      ENDIF
      5  06e4		       00 af	   VAREND_GenCastleMoveForRook =	TEMPORARY_VAR
    759  06e4
    760  06e4		       18		      clc
    761  06e5
    762  06e5		       a5 96		      lda	fromPiece
    763  06e7		       29 10		      and	#FLAG_CASTLE
    764  06e9		       f0 2b		      beq	.exit	; NOT involved in castle!
    765  06eb
    766  06eb		       a2 04		      ldx	#4
    767  06ed		       a5 85		      lda	fromX12	; *destination*
    768  06ef		       18	   .findCast  clc
    769  06f0		       ca		      dex
    770  06f1		       30 23		      bmi	.exit
    771  06f3		       dd d8 f6 	      cmp	KSquare,x
    772  06f6		       d0 f7		      bne	.findCast
    773  06f8
    774  06f8		       bd e0 f6 	      lda	RSquareEnd,x
    775  06fb		       85 86		      sta	toX12
      0  06fd					      sta@PLY	secondaryBlank
      1  06fd		       8d cf fb 	      sta	[RAM]+secondaryBlank
    777  0700		       bc dc f6 	      ldy	RSquareStart,x
    778  0703		       84 85		      sty	fromX12
    779  0705		       84 87		      sty	originX12
      0  0707					      sty@PLY	secondarySquare
      1  0707		       8c ce fb 	      sty	[RAM]+secondarySquare
    781  070a
    782  070a		       a5 96		      lda	fromPiece
    783  070c		       29 80		      and	#128	; colour bit
    784  070e		       09 05		      ora	#ROOK	; preserve colour
    785  0710		       85 96		      sta	fromPiece
      0  0712					      sta@PLY	secondaryPiece
      1  0712		       8d cd fb 	      sta	[RAM]+secondaryPiece
    787  0715
    788  0715		       38		      sec
    789  0716		       60	   .exit      rts
    790  0717
    791  0717
    792  0717							;---------------------------------------------------------------------------------------------------
    793  0717
      0  0717					      CHECK_BANK_SIZE	"BANK_GENERIC@1#1"
      1  0717		       03 17	   .TEMP      =	* - _BANK_START
 BANK_GENERIC@1#1 (1K) SIZE =  $317 , FREE= $e9
      2  0717					      ECHO	"BANK_GENERIC@1#1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  0717				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  0717				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC@1#1", " size=", * - ORIGIN
      5  0717				  -	      ERR
      6  0717					      ENDIF
    795  0717
    796  0717							;---------------------------------------------------------------------------------------------------
    797  0717							; EOF
------- FILE ./chess.asm
------- FILE BANK_ROM_SHADOW_SCREEN.asm LEVEL 2 PASS 4
      0  0717					      include	"BANK_ROM_SHADOW_SCREEN.asm"
      1  0717
      0  0717					      SLOT	2
      1  0717				  -	      IF	(2 < 0) || (2 > 3)
      2  0717				  -	      ECHO	"Illegal bank address/segment location", 2
      3  0717				  -	      ERR
      4  0717					      ENDIF
      5  0717				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  0717				   _BANK_SLOT SET	2 * 64
      0  0717					      NEWBANK	BITMAP
      1  09a6 ????				      SEG	BITMAP
      2  0800					      ORG	_ORIGIN
      3  0800					      RORG	_BANK_ADDRESS_ORIGIN
      4  0800				   _BANK_START SET	*
      5  0800				   BITMAP_START SET	*
      6  0800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0800				   BITMAP     SET	_BANK_SLOT + _CURRENT_BANK
      8  0800				   _ORIGIN    SET	_ORIGIN + 1024
      4  0800
      5  0800							; These equates allow revectoring (address offset) if the RAM slot is not the same as the SHADOW slot
      6  0800
      7  0800		       f8 00	   ChessBitmap =	SHADOW_ChessBitmap
      8  0800
      9  0800		       f8 00	   ChessBitmap0 =	SHADOW_ChessBitmap0
     10  0800		       f8 18	   ChessBitmap1 =	SHADOW_ChessBitmap1
     11  0800		       f8 30	   ChessBitmap2 =	SHADOW_ChessBitmap2
     12  0800		       f8 48	   ChessBitmap3 =	SHADOW_ChessBitmap3
     13  0800		       f8 60	   ChessBitmap4 =	SHADOW_ChessBitmap4
     14  0800		       f8 78	   ChessBitmap5 =	SHADOW_ChessBitmap5
     15  0800
     16  0800							; Template bank for a SINGLE ROW of the chessboard display.
     17  0800							; There are 8x of these.
     18  0800							; The bank contains the definition of the bitmap, and also the code to draw the bitmap
     19  0800							; The bank is copied from ROM into RAM at startup.
     20  0800							; The draw switches between consecutive row banks, with the last returning
     21  0800							; we effectively have 1K
     22  0800							;---------------------------------------------------------------------------------------------------
     23  0800
     24  0800		       00 84	   COLOUR_LINE_1 =	$84
     25  0800		       00 36	   COLOUR_LINE_2 =	$36
     26  0800		       00 28	   COLOUR_LINE_3 =	$28
     27  0800		       00 00	   BACKGCOL   =	$00
     28  0800
     29  0800
     30  0800		       00 90	   ROW_BITMAP_SIZE =	6 * 24	; PF0/PF1/PF2/(PF0)/(PF1)/(PF2) x 8 ICC pixels
     31  0800
     32  0800
      0  0800					      ALLOCATE	SHADOW_ChessBitmap, ROW_BITMAP_SIZE
      0  0800					      OPTIONAL_PAGEBREAK	"Table", ROW_BITMAP_SIZE
     12  0800					      LIST	ON
      0  0800					      DEF	SHADOW_ChessBitmap
      1  0800				   SLOT_SHADOW_ChessBitmap SET	_BANK_SLOT
      2  0800				   BANK_SHADOW_ChessBitmap SET	SLOT_SHADOW_ChessBitmap + _CURRENT_BANK
      3  0800				   SHADOW_ChessBitmap
      4  0800				   TEMPORARY_VAR SET	Overlay
      5  0800				   TEMPORARY_OFFSET SET	0
      6  0800				   VAR_BOUNDARY_SHADOW_ChessBitmap SET	TEMPORARY_OFFSET
      7  0800				   FUNCTION_NAME SET	SHADOW_ChessBitmap
     34  0800		       00 00 00 00*SHADOW_ChessBitmap0 ds	24
     35  0818		       00 00 00 00*SHADOW_ChessBitmap1 ds	24
     36  0830		       00 00 00 00*SHADOW_ChessBitmap2 ds	24
     37  0848		       00 00 00 00*SHADOW_ChessBitmap3 ds	24
     38  0860		       00 00 00 00*SHADOW_ChessBitmap4 ds	24
     39  0878		       00 00 00 00*SHADOW_ChessBitmap5 ds	24
     40  0890
      0  0890					      ALLOCATE	BlankSprite, 8
      0  0890					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0890					      LIST	ON
      0  0890					      DEF	BlankSprite
      1  0890				   SLOT_BlankSprite SET	_BANK_SLOT
      2  0890				   BANK_BlankSprite SET	SLOT_BlankSprite + _CURRENT_BANK
      3  0890				   BlankSprite
      4  0890				   TEMPORARY_VAR SET	Overlay
      5  0890				   TEMPORARY_OFFSET SET	0
      6  0890				   VAR_BOUNDARY_BlankSprite SET	TEMPORARY_OFFSET
      7  0890				   FUNCTION_NAME SET	BlankSprite
     42  0890		       00 00 00 00*	      ds	8, 0
     43  0898
      0  0898					      ALLOCATE	SpriteBuffer, 8
      0  0898					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0898					      LIST	ON
      0  0898					      DEF	SpriteBuffer
      1  0898				   SLOT_SpriteBuffer SET	_BANK_SLOT
      2  0898				   BANK_SpriteBuffer SET	SLOT_SpriteBuffer + _CURRENT_BANK
      3  0898				   SpriteBuffer
      4  0898				   TEMPORARY_VAR SET	Overlay
      5  0898				   TEMPORARY_OFFSET SET	0
      6  0898				   VAR_BOUNDARY_SpriteBuffer SET	TEMPORARY_OFFSET
      7  0898				   FUNCTION_NAME SET	SpriteBuffer
     45  0898				   SpriteBuffer2
     46  0898		       f8		      .byte.b	%11111000
     47  0899		       f8		      .byte.b	%11111000
     48  089a		       f8		      .byte.b	%11111000
     49  089b		       f8		      .byte.b	%11111000
     50  089c		       f8		      .byte.b	%11111000
     51  089d		       f8		      .byte.b	%11111000
     52  089e		       f8		      .byte.b	%11111000
     53  089f		       f8		      .byte.b	%11111000
     54  08a0
     55  08a0				  -	      IF	0
     56  08a0				  -	      ALLOCATE	BackupBitmap, ROW_BITMAP_SIZE
     57  08a0				  -	      ds	ROW_BITMAP_SIZE, 0
     58  08a0					      ENDIF
     59  08a0
     60  08a0							;---------------------------------------------------------------------------------------------------
     61  08a0
     62  0900		       00 00 00 00*	      ALIGN	256
     63  0900					      SUBROUTINE
     64  0900
      0  0900					      REFER	StartupBankReset
      1  0900				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0900				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0900					      ENDIF
     66  0900				   __dummy
      0  0900					      VEND	__dummy
      1  0900				  -	      IFNCONST	__dummy
      2  0900				  -	      ECHO	"Incorrect VEND label", __dummy
      3  0900				  -	      ERR
      4  0900					      ENDIF
      5  0900		       00 a1	   VAREND___dummy =	TEMPORARY_VAR
     68  0900
     69  0900							; x = row # (and bank#)
     70  0900
     71  0900				   .endline
     72  0900
     73  0900							;@59
     74  0900
     75  0900							; The following 'inx' is replaced in the LAST row bank with a 'RTS', thus ending the draw loop
     76  0900							; Note that the other 7 row banks are unmodified (keeping the 'inx')
     77  0900				   SELFMOD_RTS_ON_LAST_ROW
     78  0900
     79  0900		       e8		      inx		; 2
     80  0901		       86 3e		      stx	SET_BANK_RAM	; 3 @64     BANK switch to next row
     81  0903
      0  0903					      DEF	DrawRow
      1  0903				   SLOT_DrawRow SET	_BANK_SLOT
      2  0903				   BANK_DrawRow SET	SLOT_DrawRow + _CURRENT_BANK
      3  0903				   DrawRow
      4  0903				   TEMPORARY_VAR SET	Overlay
      5  0903				   TEMPORARY_OFFSET SET	0
      6  0903				   VAR_BOUNDARY_DrawRow SET	TEMPORARY_OFFSET
      7  0903				   FUNCTION_NAME SET	DrawRow
     83  0903
     84  0903							;@64
     85  0903		       a0 07		      ldy	#7	; 2
     86  0905		       10 3b		      bpl	.dl2	; 3   (must be 69 here)
     87  0907
     88  0907							;@58...
     89  0907
     90  0907				   .l3
     91  0907
     92  0907		       b9 a8 f8    SMSPRITE16_0 lda	SpriteBuffer+16,y	; 4
     93  090a		       85 5b		      sta	GRP0	; 3
     94  090c		       b9 a8 f8    SMSPRITE16_1 lda	SpriteBuffer2+16,y	; 4
     95  090f		       85 5c		      sta	GRP1	; 3
     96  0911
     97  0911							;@-4
     98  0911
     99  0911		       a9 84		      lda	#COLOUR_LINE_1	;#$94			  ; 2
    100  0913		       85 48		      sta	COLUPF	; 3 @1
    101  0915
    102  0915		       b9 10 f8 	      lda	ChessBitmap0+16,y	; 4
    103  0918		       85 4d		      sta	PF0	; 3
    104  091a		       b9 28 f8 	      lda	ChessBitmap1+16,y	; 4
    105  091d		       85 4e		      sta	PF1	; 3
    106  091f		       b9 40 f8 	      lda	ChessBitmap2+16,y	; 4
    107  0922		       85 4f		      sta	PF2	; 3 @22
    108  0924
      0  0924					      SLEEP	6	; 6 @28
      1  0924				   .CYCLES    SET	6
      2  0924
      3  0924				  -	      IF	.CYCLES < 2
      4  0924				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0924				  -	      ERR
      6  0924					      ENDIF
      7  0924
      8  0924				  -	      IF	.CYCLES & 1
      9  0924				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0924				  -	      nop	0
     11  0924				  -	      ELSE
     12  0924				  -	      bit	VSYNC
     13  0924				  -	      ENDIF
     14  0924				  -.CYCLES    SET	.CYCLES - 3
     15  0924					      ENDIF
     16  0924
     17  0924					      REPEAT	.CYCLES / 2
     18  0924		       ea		      nop
     17  0924					      REPEND
     18  0925		       ea		      nop
     17  0925					      REPEND
     18  0926		       ea		      nop
     19  0927					      REPEND
    110  0927
    111  0927		       b9 58 f8 	      lda	ChessBitmap3+16,y	; 4
    112  092a		       85 4d		      sta	PF0	; 3
    113  092c		       b9 70 f8 	      lda	ChessBitmap4+16,y	; 4
    114  092f		       85 4e		      sta	PF1	; 3
    115  0931		       b9 88 f8 	      lda	ChessBitmap5+16,y	; 4
    116  0934		       8d 4f 00 	      sta.w	PF2	; 4 @50
    117  0937
      0  0937					      SLEEP	4	; 4
      1  0937				   .CYCLES    SET	4
      2  0937
      3  0937				  -	      IF	.CYCLES < 2
      4  0937				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0937				  -	      ERR
      6  0937					      ENDIF
      7  0937
      8  0937				  -	      IF	.CYCLES & 1
      9  0937				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0937				  -	      nop	0
     11  0937				  -	      ELSE
     12  0937				  -	      bit	VSYNC
     13  0937				  -	      ENDIF
     14  0937				  -.CYCLES    SET	.CYCLES - 3
     15  0937					      ENDIF
     16  0937
     17  0937					      REPEAT	.CYCLES / 2
     18  0937		       ea		      nop
     17  0937					      REPEND
     18  0938		       ea		      nop
     19  0939					      REPEND
    119  0939
    120  0939		       88		      dey		; 2
    121  093a		       30 c4		      bmi	.endline	; 2 (3)
    122  093c
    123  093c							;@57
    124  093c				   .drawLine
    125  093c
      0  093c					      SLEEP	11
      1  093c				   .CYCLES    SET	11
      2  093c
      3  093c				  -	      IF	.CYCLES < 2
      4  093c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  093c				  -	      ERR
      6  093c					      ENDIF
      7  093c
      8  093c					      IF	.CYCLES & 1
      9  093c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  093c		       04 00		      nop	0
     11  093e				  -	      ELSE
     12  093e				  -	      bit	VSYNC
     13  093e					      ENDIF
     14  093e				   .CYCLES    SET	.CYCLES - 3
     15  093e					      ENDIF
     16  093e
     17  093e					      REPEAT	.CYCLES / 2
     18  093e		       ea		      nop
     17  093e					      REPEND
     18  093f		       ea		      nop
     17  093f					      REPEND
     18  0940		       ea		      nop
     17  0940					      REPEND
     18  0941		       ea		      nop
     19  0942					      REPEND
    127  0942
    128  0942				   .dl2
    129  0942		       b9 98 f8    SMSPRITE0_0 lda	SpriteBuffer,y	; 4
    130  0945		       85 5b		      sta	GRP0	; 3
    131  0947		       b9 98 f8    SMSPRITE0_1 lda	SpriteBuffer2,y	; 4
    132  094a		       85 5c		      sta	GRP1	; 3
    133  094c
    134  094c							;@7
    135  094c
    136  094c		       a9 36		      lda	#COLOUR_LINE_2	;#$4A			  ; 2
    137  094e		       85 48		      sta	COLUPF	; 3 @12
    138  0950
    139  0950		       b9 00 f8 	      lda	ChessBitmap0,y	; 4
    140  0953		       85 4d		      sta	PF0	; 3
    141  0955		       b9 18 f8 	      lda	ChessBitmap1,y	; 4
    142  0958		       85 4e		      sta	PF1	; 3
    143  095a		       b9 30 f8 	      lda	ChessBitmap2,y	; 4
    144  095d		       85 4f		      sta	PF2	; 3 @33
    145  095f
      0  095f					      SLEEP	3	; 3 @36
      1  095f				   .CYCLES    SET	3
      2  095f
      3  095f				  -	      IF	.CYCLES < 2
      4  095f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  095f				  -	      ERR
      6  095f					      ENDIF
      7  095f
      8  095f					      IF	.CYCLES & 1
      9  095f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  095f		       04 00		      nop	0
     11  0961				  -	      ELSE
     12  0961				  -	      bit	VSYNC
     13  0961					      ENDIF
     14  0961				   .CYCLES    SET	.CYCLES - 3
     15  0961					      ENDIF
     16  0961
     17  0961				  -	      REPEAT	.CYCLES / 2
     18  0961				  -	      nop
     19  0961					      REPEND
    147  0961
    148  0961		       b9 48 f8 	      lda	ChessBitmap3,y	; 4
    149  0964		       85 4d		      sta	PF0	; 3
    150  0966		       b9 60 f8 	      lda	ChessBitmap4,y	; 4
    151  0969		       85 4e		      sta	PF1	; 3
    152  096b		       b9 78 f8 	      lda	ChessBitmap5,y	; 4
    153  096e		       85 4f		      sta	PF2	; 3 @57
    154  0970
      0  0970					      SLEEP	5
      1  0970				   .CYCLES    SET	5
      2  0970
      3  0970				  -	      IF	.CYCLES < 2
      4  0970				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0970				  -	      ERR
      6  0970					      ENDIF
      7  0970
      8  0970					      IF	.CYCLES & 1
      9  0970					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0970		       04 00		      nop	0
     11  0972				  -	      ELSE
     12  0972				  -	      bit	VSYNC
     13  0972					      ENDIF
     14  0972				   .CYCLES    SET	.CYCLES - 3
     15  0972					      ENDIF
     16  0972
     17  0972					      REPEAT	.CYCLES / 2
     18  0972		       ea		      nop
     19  0973					      REPEND
    156  0973
    157  0973		       b9 a0 f8    SMSPRITE8_0 lda	SpriteBuffer+8,y	; 4
    158  0976		       85 5b		      sta	GRP0	; 3
    159  0978		       b9 a0 f8    SMSPRITE8_1 lda	SpriteBuffer2+8,y	; 4
    160  097b		       85 5c		      sta	GRP1	; 3
    161  097d
    162  097d							;@0
    163  097d		       a9 28		      lda	#COLOUR_LINE_3	;#$28			  ; 2
    164  097f		       85 48		      sta	COLUPF	; 3 @5
    165  0981
    166  0981		       b9 08 f8 	      lda	ChessBitmap0+8,y	; 4
    167  0984		       85 4d		      sta	PF0	; 3
    168  0986		       b9 20 f8 	      lda	ChessBitmap1+8,y	; 4
    169  0989		       85 4e		      sta	PF1	; 3
    170  098b		       b9 38 f8 	      lda	ChessBitmap2+8,y	; 4
    171  098e		       85 4f		      sta	PF2	; 3 @26
    172  0990
      0  0990					      SLEEP	8	; 6 @34
      1  0990				   .CYCLES    SET	8
      2  0990
      3  0990				  -	      IF	.CYCLES < 2
      4  0990				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0990				  -	      ERR
      6  0990					      ENDIF
      7  0990
      8  0990				  -	      IF	.CYCLES & 1
      9  0990				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0990				  -	      nop	0
     11  0990				  -	      ELSE
     12  0990				  -	      bit	VSYNC
     13  0990				  -	      ENDIF
     14  0990				  -.CYCLES    SET	.CYCLES - 3
     15  0990					      ENDIF
     16  0990
     17  0990					      REPEAT	.CYCLES / 2
     18  0990		       ea		      nop
     17  0990					      REPEND
     18  0991		       ea		      nop
     17  0991					      REPEND
     18  0992		       ea		      nop
     17  0992					      REPEND
     18  0993		       ea		      nop
     19  0994					      REPEND
    174  0994
    175  0994		       b9 50 f8 	      lda	ChessBitmap3+8,y	; 4
    176  0997		       85 4d		      sta	PF0	; 3
    177  0999		       b9 68 f8 	      lda	ChessBitmap4+8,y	; 4
    178  099c		       85 4e		      sta	PF1	; 3
    179  099e		       b9 80 f8 	      lda	ChessBitmap5+8,y	; 4
    180  09a1		       85 4f		      sta	PF2	; 3 @55
    181  09a3
    182  09a3		       4c 07 f9 	      jmp	.l3	; 3 @58
    183  09a6
    184  09a6
    185  09a6
    186  09a6							;---------------------------------------------------------------------------------------------------
    187  09a6
      0  09a6					      CHECK_RAM_BANK_SIZE	"ROM_SHADOW_SCREEN"
      1  09a6		       01 a6	   .TEMP      =	* - _BANK_START
 ROM_SHADOW_SCREEN (512 byte) SIZE =  $1a6 , FREE= $5a
      2  09a6					      ECHO	"ROM_SHADOW_SCREEN", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3  09a6				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  09a6				  -	      ECHO	"BANK OVERFLOW @ ", "ROM_SHADOW_SCREEN", " size=", * - ORIGIN
      5  09a6				  -	      ERR
      6  09a6					      ENDIF
    189  09a6
    190  09a6							;---------------------------------------------------------------------------------------------------
    191  09a6							;EOF
------- FILE ./chess.asm
------- FILE ROM_SCREEN@3.asm LEVEL 2 PASS 4
      0  09a6					      include	"ROM_SCREEN@3.asm"
      1  09a6
      0  09a6					      SLOT	3
      1  09a6				  -	      IF	(3 < 0) || (3 > 3)
      2  09a6				  -	      ECHO	"Illegal bank address/segment location", 3
      3  09a6				  -	      ERR
      4  09a6					      ENDIF
      5  09a6				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  09a6				   _BANK_SLOT SET	3 * 64
      0  09a6					      NEWBANK	BITMAP2
      1  0c5c ????				      SEG	BITMAP2
      2  0c00					      ORG	_ORIGIN
      3  0c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  0c00				   _BANK_START SET	*
      5  0c00				   BITMAP2_START SET	*
      6  0c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0c00				   BITMAP2    SET	_BANK_SLOT + _CURRENT_BANK
      8  0c00				   _ORIGIN    SET	_ORIGIN + 1024
      4  0c00
      5  0c00							;---------------------------------------------------------------------------------------------------
      6  0c00
      0  0c00					      DEF	ClearRowBitmap
      1  0c00				   SLOT_ClearRowBitmap SET	_BANK_SLOT
      2  0c00				   BANK_ClearRowBitmap SET	SLOT_ClearRowBitmap + _CURRENT_BANK
      3  0c00				   ClearRowBitmap
      4  0c00				   TEMPORARY_VAR SET	Overlay
      5  0c00				   TEMPORARY_OFFSET SET	0
      6  0c00				   VAR_BOUNDARY_ClearRowBitmap SET	TEMPORARY_OFFSET
      7  0c00				   FUNCTION_NAME SET	ClearRowBitmap
      8  0c00					      SUBROUTINE
      9  0c00
      0  0c00					      REFER	CallClear
      1  0c00				  -	      IF	VAREND_CallClear > TEMPORARY_VAR
      2  0c00				  -TEMPORARY_VAR SET	VAREND_CallClear
      3  0c00					      ENDIF
      0  0c00					      VEND	ClearRowBitmap
      1  0c00				  -	      IFNCONST	ClearRowBitmap
      2  0c00				  -	      ECHO	"Incorrect VEND label", ClearRowBitmap
      3  0c00				  -	      ERR
      4  0c00					      ENDIF
      5  0c00		       00 a1	   VAREND_ClearRowBitmap =	TEMPORARY_VAR
     12  0c00
     13  0c00							; No transient variable dependencies/calls
     14  0c00
     15  0c00		       a9 00		      lda	#0
     16  0c02		       a0 90		      ldy	#ROW_BITMAP_SIZE
      0  0c04				   .clearRow  sta@RAM	ChessBitmap-1,y
      1  0c04		       99 ff f9 	      sta	[RAM]+ChessBitmap-1,y
     18  0c07		       88		      dey
     19  0c08		       d0 fa		      bne	.clearRow
     20  0c0a		       60		      rts
     21  0c0b
     22  0c0b
     23  0c0b							;---------------------------------------------------------------------------------------------------
     24  0c0b
     25  0c0b
     26  0c0b							;---------------------------------------------------------------------------------------------------
     27  0c0b
     28  0c0b					      IF	1
      0  0c0b					      DEF	WriteBlank
      1  0c0b				   SLOT_WriteBlank SET	_BANK_SLOT
      2  0c0b				   BANK_WriteBlank SET	SLOT_WriteBlank + _CURRENT_BANK
      3  0c0b				   WriteBlank
      4  0c0b				   TEMPORARY_VAR SET	Overlay
      5  0c0b				   TEMPORARY_OFFSET SET	0
      6  0c0b				   VAR_BOUNDARY_WriteBlank SET	TEMPORARY_OFFSET
      7  0c0b				   FUNCTION_NAME SET	WriteBlank
     30  0c0b					      SUBROUTINE
     31  0c0b
      0  0c0b					      REFER	StartupBankReset
      1  0c0b				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0c0b				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0c0b					      ENDIF
      0  0c0b					      VEND	WriteBlank
      1  0c0b				  -	      IFNCONST	WriteBlank
      2  0c0b				  -	      ECHO	"Incorrect VEND label", WriteBlank
      3  0c0b				  -	      ERR
      4  0c0b					      ENDIF
      5  0c0b		       00 a1	   VAREND_WriteBlank =	TEMPORARY_VAR
     34  0c0b
     35  0c0b		       a9 90		      lda	#<BlankSprite
      0  0c0d					      sta@RAM	SMSPRITE0_0+1
      1  0c0d		       8d 43 fb 	      sta	[RAM]+SMSPRITE0_0+1
      0  0c10					      sta@RAM	SMSPRITE8_0+1
      1  0c10		       8d 74 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  0c13					      sta@RAM	SMSPRITE16_0+1
      1  0c13		       8d 08 fb 	      sta	[RAM]+SMSPRITE16_0+1
      0  0c16					      sta@RAM	SMSPRITE0_1+1
      1  0c16		       8d 48 fb 	      sta	[RAM]+SMSPRITE0_1+1
      0  0c19					      sta@RAM	SMSPRITE8_1+1
      1  0c19		       8d 79 fb 	      sta	[RAM]+SMSPRITE8_1+1
      0  0c1c					      sta@RAM	SMSPRITE16_1+1
      1  0c1c		       8d 0d fb 	      sta	[RAM]+SMSPRITE16_1+1
     42  0c1f
     43  0c1f		       a9 f8		      lda	#>BlankSprite
      0  0c21					      sta@RAM	SMSPRITE0_0+2
      1  0c21		       8d 44 fb 	      sta	[RAM]+SMSPRITE0_0+2
      0  0c24					      sta@RAM	SMSPRITE8_0+2
      1  0c24		       8d 75 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  0c27					      sta@RAM	SMSPRITE16_0+2
      1  0c27		       8d 09 fb 	      sta	[RAM]+SMSPRITE16_0+2
      0  0c2a					      sta@RAM	SMSPRITE0_1+2
      1  0c2a		       8d 49 fb 	      sta	[RAM]+SMSPRITE0_1+2
      0  0c2d					      sta@RAM	SMSPRITE8_1+2
      1  0c2d		       8d 7a fb 	      sta	[RAM]+SMSPRITE8_1+2
      0  0c30					      sta@RAM	SMSPRITE16_1+2
      1  0c30		       8d 0e fb 	      sta	[RAM]+SMSPRITE16_1+2
     50  0c33
     51  0c33		       60		      rts
     52  0c34					      ENDIF
     53  0c34
     54  0c34							;---------------------------------------------------------------------------------------------------
     55  0c34
     56  0c34					      IF	1
      0  0c34					      DEF	WriteCursor
      1  0c34				   SLOT_WriteCursor SET	_BANK_SLOT
      2  0c34				   BANK_WriteCursor SET	SLOT_WriteCursor + _CURRENT_BANK
      3  0c34				   WriteCursor
      4  0c34				   TEMPORARY_VAR SET	Overlay
      5  0c34				   TEMPORARY_OFFSET SET	0
      6  0c34				   VAR_BOUNDARY_WriteCursor SET	TEMPORARY_OFFSET
      7  0c34				   FUNCTION_NAME SET	WriteCursor
     58  0c34					      SUBROUTINE
     59  0c34
      0  0c34					      REFER	StartupBankReset
      1  0c34				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0c34				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0c34					      ENDIF
      0  0c34					      VEND	WriteCursor
      1  0c34				  -	      IFNCONST	WriteCursor
      2  0c34				  -	      ECHO	"Incorrect VEND label", WriteCursor
      3  0c34				  -	      ERR
      4  0c34					      ENDIF
      5  0c34		       00 a1	   VAREND_WriteCursor =	TEMPORARY_VAR
     62  0c34
     63  0c34		       38		      sec
     64  0c35		       a5 88		      lda	cursorX12
     65  0c37		       30 22		      bmi	.exit
     66  0c39		       a2 0a		      ldx	#10
     67  0c3b		       e9 0a	   .sub10     sbc	#10
     68  0c3d		       ca		      dex
     69  0c3e		       b0 fb		      bcs	.sub10
     70  0c40
     71  0c40		       8a		      txa
     72  0c41		       69 80		      adc	#SLOT_DrawRow	;cc implied
     73  0c43		       85 3e		      sta	SET_BANK_RAM
     74  0c45
     75  0c45		       a9 98		      lda	#<SpriteBuffer
      0  0c47					      sta@RAM	SMSPRITE0_0+1
      1  0c47		       8d 43 fb 	      sta	[RAM]+SMSPRITE0_0+1
      0  0c4a					      sta@RAM	SMSPRITE8_0+1
      1  0c4a		       8d 74 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  0c4d					      sta@RAM	SMSPRITE16_0+1
      1  0c4d		       8d 08 fb 	      sta	[RAM]+SMSPRITE16_0+1
     79  0c50		       a9 f8		      lda	#>SpriteBuffer
      0  0c52					      sta@RAM	SMSPRITE0_0+2
      1  0c52		       8d 44 fb 	      sta	[RAM]+SMSPRITE0_0+2
      0  0c55					      sta@RAM	SMSPRITE8_0+2
      1  0c55		       8d 75 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  0c58					      sta@RAM	SMSPRITE16_0+2
      1  0c58		       8d 09 fb 	      sta	[RAM]+SMSPRITE16_0+2
     83  0c5b
     84  0c5b		       60	   .exit      rts
     85  0c5c					      ENDIF
     86  0c5c
     87  0c5c
     88  0c5c							;---------------------------------------------------------------------------------------------------
     89  0c5c
     90  0c5c				  -	      IF	0
     91  0c5c				  -	      DEF	SaveBitmap
     92  0c5c				  -	      SUBROUTINE
     93  0c5c				  -
     94  0c5c				  -	      REFER	SAFE_BackupBitmaps
     95  0c5c				  -	      VEND	SaveBitmap
     96  0c5c				  -
     97  0c5c				  -	      ldy	#71
     98  0c5c				  -.fromTo    lda	ChessBitmap,y
     99  0c5c				  -	      sta@RAM	BackupBitmap,y
    100  0c5c				  -	      lda	ChessBitmap+72,y
    101  0c5c				  -	      sta@RAM	BackupBitmap+72,y
    102  0c5c				  -	      dey
    103  0c5c				  -	      bpl	.fromTo
    104  0c5c				  -	      rts
    105  0c5c					      ENDIF
    106  0c5c
    107  0c5c							;---------------------------------------------------------------------------------------------------
    108  0c5c
    109  0c5c				  -	      IF	0
    110  0c5c				  -
    111  0c5c				  -	      DEF	RestoreBitmap
    112  0c5c				  -	      SUBROUTINE
    113  0c5c				  -
    114  0c5c				  -	      VEND	RestoreBitmap
    115  0c5c				  -
    116  0c5c				  -	      ldy	#71
    117  0c5c				  -.fromTo    lda	BackupBitmap,y
    118  0c5c				  -	      sta@RAM	ChessBitmap,y
    119  0c5c				  -	      lda	BackupBitmap+72,y
    120  0c5c				  -	      sta@RAM	ChessBitmap+72,y
    121  0c5c				  -	      dey
    122  0c5c				  -	      bpl	.fromTo
    123  0c5c				  -	      rts
    124  0c5c					      ENDIF
    125  0c5c
    126  0c5c							;---------------------------------------------------------------------------------------------------
    127  0c5c
    128  0c5c				  -	      IF	0
    129  0c5c				  -
    130  0c5c				  -	      DEF	CopyTextToRowBitmap
    131  0c5c				  -	      SUBROUTINE
    132  0c5c				  -
    133  0c5c				  -	      VEND	CopyTextToRowBitmap
    134  0c5c				  -
    135  0c5c				  -			; An OR-draw, used for placing matricies/text onscreen
    136  0c5c				  -			; Similar to the EOR - first copy data into __pieceShapeBuffer, then call this function
    137  0c5c				  -			; The draw can be bracketed by "SaveBitmap" and "RestoreBitmap" to leave screen
    138  0c5c				  -			; in original state once text disappears
    139  0c5c				  -
    140  0c5c				  -	      ldy	#71
    141  0c5c				  -	      bcs	.rightSide
    142  0c5c				  -
    143  0c5c				  -.copy      lda	__pieceShapeBuffer,y
    144  0c5c				  -	      ora	ChessBitmap,y
    145  0c5c				  -	      sta@RAM	ChessBitmap,y
    146  0c5c				  -	      dey
    147  0c5c				  -	      bpl	.copy
    148  0c5c				  -
    149  0c5c				  -	      rts
    150  0c5c				  -
    151  0c5c				  -.rightSide
    152  0c5c				  -
    153  0c5c				  -	      SUBROUTINE
    154  0c5c				  -
    155  0c5c				  -.copy      lda	__pieceShapeBuffer,y
    156  0c5c				  -	      ora	ChessBitmap+72,y
    157  0c5c				  -	      sta@RAM	ChessBitmap+72,y
    158  0c5c				  -	      dey
    159  0c5c				  -	      bpl	.copy
    160  0c5c				  -
    161  0c5c				  -	      rts
    162  0c5c				  -
    163  0c5c					      ENDIF
    164  0c5c
    165  0c5c							;---------------------------------------------------------------------------------------------------
    166  0c5c
      0  0c5c					      CHECK_RAM_BANK_SIZE	"ROM_SHADOW_SCREEN"
      1  0c5c		       00 5c	   .TEMP      =	* - _BANK_START
 ROM_SHADOW_SCREEN (512 byte) SIZE =  $5c , FREE= $1a4
      2  0c5c					      ECHO	"ROM_SHADOW_SCREEN", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3  0c5c				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  0c5c				  -	      ECHO	"BANK OVERFLOW @ ", "ROM_SHADOW_SCREEN", " size=", * - ORIGIN
      5  0c5c				  -	      ERR
      6  0c5c					      ENDIF
    168  0c5c
    169  0c5c							;---------------------------------------------------------------------------------------------------
    170  0c5c							;EOF
------- FILE ./chess.asm
------- FILE BANK_PLY.asm LEVEL 2 PASS 4
      0  0c5c					      include	"BANK_PLY.asm"
      1  0c5c							; Copyright (C)2020 Andrew Davie
      2  0c5c							; andrew@taswegian.com
      3  0c5c
      0  0c5c					      SLOT	1
      1  0c5c				  -	      IF	(1 < 0) || (1 > 3)
      2  0c5c				  -	      ECHO	"Illegal bank address/segment location", 1
      3  0c5c				  -	      ERR
      4  0c5c					      ENDIF
      5  0c5c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  0c5c				   _BANK_SLOT SET	1 * 64
      0  0c5c					      NEWBANK	BANK_PLY	; ROM SHADOW
      1  1195 ????				      SEG	BANK_PLY
      2  1000					      ORG	_ORIGIN
      3  1000					      RORG	_BANK_ADDRESS_ORIGIN
      4  1000				   _BANK_START SET	*
      5  1000				   BANK_PLY_START SET	*
      6  1000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1000				   BANK_PLY   SET	_BANK_SLOT + _CURRENT_BANK
      8  1000				   _ORIGIN    SET	_ORIGIN + 1024
      6  1000
      7  1000
      8  1000							;---------------------------------------------------------------------------------------------------
      9  1000
      0  1000					      DEF	NewPlyInitialise
      1  1000				   SLOT_NewPlyInitialise SET	_BANK_SLOT
      2  1000				   BANK_NewPlyInitialise SET	SLOT_NewPlyInitialise + _CURRENT_BANK
      3  1000				   NewPlyInitialise
      4  1000				   TEMPORARY_VAR SET	Overlay
      5  1000				   TEMPORARY_OFFSET SET	0
      6  1000				   VAR_BOUNDARY_NewPlyInitialise SET	TEMPORARY_OFFSET
      7  1000				   FUNCTION_NAME SET	NewPlyInitialise
     11  1000					      SUBROUTINE
     12  1000
      0  1000					      REFER	GenerateAllMoves
      1  1000					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1000				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1000					      ENDIF
      0  1000					      REFER	negaMax
      1  1000				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  1000				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  1000					      ENDIF
      0  1000					      VEND	NewPlyInitialise
      1  1000				  -	      IFNCONST	NewPlyInitialise
      2  1000				  -	      ECHO	"Incorrect VEND label", NewPlyInitialise
      3  1000				  -	      ERR
      4  1000					      ENDIF
      5  1000		       00 b2	   VAREND_NewPlyInitialise =	TEMPORARY_VAR
     16  1000
     17  1000							; This MUST be called at the start of a new ply
     18  1000							; It initialises the movelist to empty
     19  1000							; x must be preserved
     20  1000
     21  1000							; note that 'alpha' and 'beta' are set externally!!
     22  1000
     23  1000		       a9 ff		      lda	#-1
      0  1002					      sta@PLY	moveIndex	; no valid moves
      1  1002		       8d d0 fb 	      sta	[RAM]+moveIndex
      0  1005					      sta@PLY	bestMove
      1  1005		       8d d2 fb 	      sta	[RAM]+bestMove
     26  1008
     27  1008		       a5 93		      lda	enPassantPawn	; flag/square from last actual move made
      0  100a					      sta@PLY	enPassantSquare	; used for backtracking, to reset the flag
      1  100a		       8d ca fb 	      sta	[RAM]+enPassantSquare
     29  100d
     30  100d
     31  100d							; The value of the material (signed, 16-bit) is restored to the saved value at the reversion
     32  100d							; of a move. It's quicker to restore than to re-sum. So we save the current evaluation at the
     33  100d							; start of each new ply.
     34  100d
     35  100d		       a5 8f		      lda	Evaluation
      0  100f					      sta@PLY	savedEvaluation
      1  100f		       8d c8 fb 	      sta	[RAM]+savedEvaluation
     37  1012		       a5 90		      lda	Evaluation+1
      0  1014					      sta@PLY	savedEvaluation+1
      1  1014		       8d c9 fb 	      sta	[RAM]+savedEvaluation+1
     39  1017
     40  1017		       60		      rts
     41  1018
     42  1018
     43  1018
     44  1018							;---------------------------------------------------------------------------------------------------
     45  1018
     46  1018					      MAC	xchg
     47  1018					      lda@PLY	{1},x
     48  1018					      sta	__xchg
     49  1018					      lda@PLY	{1},y
     50  1018					      sta@PLY	{1},x
     51  1018					      lda	__xchg
     52  1018					      sta@PLY	{1},y
     53  1018					      ENDM		;{name}
     54  1018
     55  1018
      0  1018					      DEF	Sort
      1  1018				   SLOT_Sort  SET	_BANK_SLOT
      2  1018				   BANK_Sort  SET	SLOT_Sort + _CURRENT_BANK
      3  1018				   Sort
      4  1018				   TEMPORARY_VAR SET	Overlay
      5  1018				   TEMPORARY_OFFSET SET	0
      6  1018				   VAR_BOUNDARY_Sort SET	TEMPORARY_OFFSET
      7  1018				   FUNCTION_NAME SET	Sort
     57  1018					      SUBROUTINE
     58  1018
      0  1018					      REFER	GenerateAllMoves
      1  1018					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1018				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1018					      ENDIF
      0  1018					      VAR	__xchg, 1
      1  1018		       00 b2	   __xchg     =	TEMPORARY_VAR
      2  1018				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1018
      4  1018				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1018				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1018				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1018					      ENDIF
      8  1018				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1018				  -	      ECHO	"Temporary Variable", __xchg, "overflow!"
     10  1018				  -	      ERR
     11  1018					      ENDIF
     12  1018					      LIST	ON
      0  1018					      VEND	Sort
      1  1018				  -	      IFNCONST	Sort
      2  1018				  -	      ECHO	"Incorrect VEND label", Sort
      3  1018				  -	      ERR
      4  1018					      ENDIF
      5  1018		       00 b3	   VAREND_Sort =	TEMPORARY_VAR
     62  1018
     63  1018		       a5 ac		      lda	__quiesceCapOnly
     64  101a		       30 51		      bmi	.exit	; only caps present so already sorted!
     65  101c
      0  101c					      ldx@PLY	moveIndex
      1  101c		       ae d0 f9 	      ldx	moveIndex
      0  101f					      ldy@PLY	moveIndex
      1  101f		       ac d0 f9 	      ldy	moveIndex
     68  1022		       88	   .next      dey
     69  1023		       30 48		      bmi	.exit
     70  1025
      0  1025					      lda@PLY	MoveCapture,y
      1  1025		       b9 64 f9 	      lda	MoveCapture,y
     72  1028		       f0 f8		      beq	.next
     73  102a
      0  102a					      XCHG	MoveFrom
      0  102a					      lda@PLY	MoveFrom,x
      1  102a		       bd 00 f8 	      lda	MoveFrom,x
      2  102d		       85 b2		      sta	__xchg
      0  102f					      lda@PLY	MoveFrom,y
      1  102f		       b9 00 f8 	      lda	MoveFrom,y
      0  1032					      sta@PLY	MoveFrom,x
      1  1032		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
      5  1035		       a5 b2		      lda	__xchg
      0  1037					      sta@PLY	MoveFrom,y
      1  1037		       99 00 fa 	      sta	[RAM]+MoveFrom,y
      0  103a					      XCHG	MoveTo
      0  103a					      lda@PLY	MoveTo,x
      1  103a		       bd 64 f8 	      lda	MoveTo,x
      2  103d		       85 b2		      sta	__xchg
      0  103f					      lda@PLY	MoveTo,y
      1  103f		       b9 64 f8 	      lda	MoveTo,y
      0  1042					      sta@PLY	MoveTo,x
      1  1042		       9d 64 fa 	      sta	[RAM]+MoveTo,x
      5  1045		       a5 b2		      lda	__xchg
      0  1047					      sta@PLY	MoveTo,y
      1  1047		       99 64 fa 	      sta	[RAM]+MoveTo,y
      0  104a					      XCHG	MovePiece
      0  104a					      lda@PLY	MovePiece,x
      1  104a		       bd 00 f9 	      lda	MovePiece,x
      2  104d		       85 b2		      sta	__xchg
      0  104f					      lda@PLY	MovePiece,y
      1  104f		       b9 00 f9 	      lda	MovePiece,y
      0  1052					      sta@PLY	MovePiece,x
      1  1052		       9d 00 fb 	      sta	[RAM]+MovePiece,x
      5  1055		       a5 b2		      lda	__xchg
      0  1057					      sta@PLY	MovePiece,y
      1  1057		       99 00 fb 	      sta	[RAM]+MovePiece,y
      0  105a					      XCHG	MoveCapture
      0  105a					      lda@PLY	MoveCapture,x
      1  105a		       bd 64 f9 	      lda	MoveCapture,x
      2  105d		       85 b2		      sta	__xchg
      0  105f					      lda@PLY	MoveCapture,y
      1  105f		       b9 64 f9 	      lda	MoveCapture,y
      0  1062					      sta@PLY	MoveCapture,x
      1  1062		       9d 64 fb 	      sta	[RAM]+MoveCapture,x
      5  1065		       a5 b2		      lda	__xchg
      0  1067					      sta@PLY	MoveCapture,y
      1  1067		       99 64 fb 	      sta	[RAM]+MoveCapture,y
     78  106a
     79  106a		       ca		      dex
     80  106b		       10 b5		      bpl	.next
     81  106d
     82  106d				   .exit
     83  106d
     84  106d
     85  106d
     86  106d
     87  106d							; Scan for capture of king
     88  106d
      0  106d					      ldx@PLY	moveIndex
      1  106d		       ae d0 f9 	      ldx	moveIndex
     90  1070
      0  1070				   .scanCheck lda@PLY	MoveCapture,x
      1  1070		       bd 64 f9 	      lda	MoveCapture,x
     92  1073		       f0 0b		      beq	.check	; since they're sorted with captures "first" we can exit
     93  1075		       29 0f		      and	#PIECE_MASK
     94  1077		       c9 07		      cmp	#KING
     95  1079		       f0 05		      beq	.check
     96  107b		       ca		      dex
     97  107c		       10 f2		      bpl	.scanCheck
     98  107e
     99  107e		       a9 00		      lda	#0
    100  1080		       85 9e	   .check     sta	flagCheck
    101  1082		       60		      rts
    102  1083
    103  1083
    104  1083							;---------------------------------------------------------------------------------------------------
    105  1083							; QUIESCE!
    106  1083
    107  1083							;int Quiesce( int alpha, int beta ) {
    108  1083							;    int stand_pat = Evaluate();
    109  1083							;    if( stand_pat >= beta )
    110  1083							;	  return beta;
    111  1083							;    if( alpha < stand_pat )
    112  1083							;	  alpha = stand_pat;
    113  1083
    114  1083							;    until( every_capture_has_been_examined )	{
    115  1083							;	  MakeCapture();
    116  1083							;	  score = -Quiesce( -beta, -alpha );
    117  1083							;	  TakeBackMove();
    118  1083
    119  1083							;	  if( score >= beta )
    120  1083							;	      return beta;
    121  1083							;	  if( score > alpha )
    122  1083							;	     alpha = score;
    123  1083							;    }
    124  1083							;    return alpha;
    125  1083							;}
    126  1083
    127  1083
      0  1083					      DEF	quiesce
      1  1083				   SLOT_quiesce SET	_BANK_SLOT
      2  1083				   BANK_quiesce SET	SLOT_quiesce + _CURRENT_BANK
      3  1083				   quiesce
      4  1083				   TEMPORARY_VAR SET	Overlay
      5  1083				   TEMPORARY_OFFSET SET	0
      6  1083				   VAR_BOUNDARY_quiesce SET	TEMPORARY_OFFSET
      7  1083				   FUNCTION_NAME SET	quiesce
    129  1083					      SUBROUTINE
    130  1083
    131  1083							; pass...
    132  1083							; x = depthleft
    133  1083							; SET_BANK_RAM      --> current ply
    134  1083							; __alpha[2] = param alpha
    135  1083							; __beta[2] = param beta
    136  1083
    137  1083
      0  1083					      COMMON_VARS_ALPHABETA
      1  1083
      0  1083					      VAR	__thinkbar, 1
      1  1083		       00 a1	   __thinkbar =	TEMPORARY_VAR
      2  1083				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1083
      4  1083				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1083				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1083				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1083					      ENDIF
      8  1083				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1083				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  1083				  -	      ERR
     11  1083					      ENDIF
     12  1083					      LIST	ON
      0  1083					      VAR	__toggle, 1
      1  1083		       00 a2	   __toggle   =	TEMPORARY_VAR
      2  1083				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1083
      4  1083				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1083				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1083				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1083					      ENDIF
      8  1083				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1083				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  1083				  -	      ERR
     11  1083					      ENDIF
     12  1083					      LIST	ON
      4  1083
      0  1083					      VAR	__bestMove, 1
      1  1083		       00 a3	   __bestMove =	TEMPORARY_VAR
      2  1083				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1083
      4  1083				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1083				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1083				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1083					      ENDIF
      8  1083				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1083				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  1083				  -	      ERR
     11  1083					      ENDIF
     12  1083					      LIST	ON
      0  1083					      VAR	__alpha, 2
      1  1083		       00 a4	   __alpha    =	TEMPORARY_VAR
      2  1083				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1083
      4  1083				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1083				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1083				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1083					      ENDIF
      8  1083				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1083				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  1083				  -	      ERR
     11  1083					      ENDIF
     12  1083					      LIST	ON
      0  1083					      VAR	__beta, 2
      1  1083		       00 a6	   __beta     =	TEMPORARY_VAR
      2  1083				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1083
      4  1083				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1083				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1083				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1083					      ENDIF
      8  1083				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1083				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  1083				  -	      ERR
     11  1083					      ENDIF
     12  1083					      LIST	ON
      0  1083					      VAR	__negaMax, 2
      1  1083		       00 a8	   __negaMax  =	TEMPORARY_VAR
      2  1083				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1083
      4  1083				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1083				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1083				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1083					      ENDIF
      8  1083				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1083				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  1083				  -	      ERR
     11  1083					      ENDIF
     12  1083					      LIST	ON
      0  1083					      VAR	__value, 2
      1  1083		       00 aa	   __value    =	TEMPORARY_VAR
      2  1083				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1083
      4  1083				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1083				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1083				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1083					      ENDIF
      8  1083				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1083				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  1083				  -	      ERR
     11  1083					      ENDIF
     12  1083					      LIST	ON
     10  1083
      0  1083					      VAR	__quiesceCapOnly, 1
      1  1083		       00 ac	   __quiesceCapOnly =	TEMPORARY_VAR
      2  1083				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1083
      4  1083				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1083				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1083				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1083					      ENDIF
      8  1083				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1083				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  1083				  -	      ERR
     11  1083					      ENDIF
     12  1083					      LIST	ON
     12  1083
      0  1083					      REFER	selectmove
      1  1083				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  1083				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  1083					      ENDIF
      0  1083					      REFER	negaMax
      1  1083				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  1083				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  1083					      ENDIF
      0  1083					      VEND	quiesce
      1  1083				  -	      IFNCONST	quiesce
      2  1083				  -	      ECHO	"Incorrect VEND label", quiesce
      3  1083				  -	      ERR
      4  1083					      ENDIF
      5  1083		       00 ad	   VAREND_quiesce =	TEMPORARY_VAR
    142  1083
    143  1083		       a5 94		      lda	currentPly
    144  1085		       c9 8e		      cmp	#RAMBANK_PLY + MAX_PLY_DEPTH_BANK -1
    145  1087		       b0 43		      bcs	.retBeta
    146  1089
    147  1089							; The 'thinkbar' pattern...
    148  1089
    149  1089		       a9 00		      lda	#0
    150  108b		       a4 4c		      ldy	INPT4
    151  108d		       30 14		      bmi	.doThink
    152  108f
    153  108f		       a5 a1		      lda	__thinkbar
    154  1091		       0a		      asl
    155  1092		       0a		      asl
    156  1093		       0a		      asl
    157  1094		       0a		      asl
    158  1095		       09 02		      ora	#2
    159  1097		       85 48		      sta	COLUPF
    160  1099
    161  1099		       e6 a1		      inc	__thinkbar
    162  109b		       a5 a1		      lda	__thinkbar
    163  109d		       29 0f		      and	#15
    164  109f		       a8		      tay
    165  10a0		       b9 85 f5 	      lda	SynapsePattern2,y
    166  10a3
    167  10a3		       85 4e	   .doThink   sta	PF1
    168  10a5		       85 4f		      sta	PF2
    169  10a7
    170  10a7							; ^
    171  10a7
    172  10a7		       a5 a6		      lda	__beta
      0  10a9					      sta@PLY	beta
      1  10a9		       8d d5 fb 	      sta	[RAM]+beta
    174  10ac		       a5 a7		      lda	__beta+1
      0  10ae					      sta@PLY	beta+1
      1  10ae		       8d d6 fb 	      sta	[RAM]+beta+1
    176  10b1
    177  10b1		       a5 a4		      lda	__alpha
      0  10b3					      sta@PLY	alpha
      1  10b3		       8d d3 fb 	      sta	[RAM]+alpha
    179  10b6		       a5 a5		      lda	__alpha+1
      0  10b8					      sta@PLY	alpha+1
      1  10b8		       8d d4 fb 	      sta	[RAM]+alpha+1
    181  10bb
    182  10bb
    183  10bb							;    int stand_pat = Evaluate();
    184  10bb							;    if( stand_pat >= beta )
    185  10bb							;	  return beta;
    186  10bb
    187  10bb		       38		      sec
    188  10bc		       a5 8f		      lda	Evaluation
      0  10be					      sbc@PLY	beta
      1  10be		       ed d5 f9 	      sbc	beta
    190  10c1		       a5 90		      lda	Evaluation+1
      0  10c3					      sbc@PLY	beta+1
      1  10c3		       ed d6 f9 	      sbc	beta+1
    192  10c6		       50 02		      bvc	.spat0
    193  10c8		       49 80		      eor	#$80
    194  10ca		       30 0b	   .spat0     bmi	.norb	;pl .retBeta			 ; branch if stand_pat >= beta
    195  10cc
    196  10cc		       ad d5 f9    .retBeta   lda	beta
    197  10cf		       85 a8		      sta	__negaMax
    198  10d1		       ad d6 f9 	      lda	beta+1
    199  10d4		       85 a9		      sta	__negaMax+1
    200  10d6
    201  10d6		       60	   .abort     rts
    202  10d7
    203  10d7				   .norb
    204  10d7
    205  10d7
    206  10d7							;    if( alpha < stand_pat )
    207  10d7							;	  alpha = stand_pat;
    208  10d7
    209  10d7		       38		      sec
    210  10d8		       ad d3 f9 	      lda	alpha
    211  10db		       e5 8f		      sbc	Evaluation
    212  10dd		       ad d4 f9 	      lda	alpha+1
    213  10e0		       e5 90		      sbc	Evaluation+1
    214  10e2		       50 02		      bvc	.spat1
    215  10e4		       49 80		      eor	#$80
    216  10e6		       10 0a	   .spat1     bpl	.alpha	; branch if alpha >= stand_pat
    217  10e8
    218  10e8							; alpha < stand_pat
    219  10e8
    220  10e8		       a5 8f		      lda	Evaluation
      0  10ea					      sta@PLY	alpha
      1  10ea		       8d d3 fb 	      sta	[RAM]+alpha
    222  10ed		       a5 90		      lda	Evaluation+1
      0  10ef					      sta@PLY	alpha+1
      1  10ef		       8d d4 fb 	      sta	[RAM]+alpha+1
    224  10f2
    225  10f2				   .alpha
    226  10f2		       20 6d f1 	      jsr	GenerateAllMoves
    227  10f5		       a5 9e		      lda	flagCheck
    228  10f7		       d0 dd		      bne	.abort	; pure abort
    229  10f9
      0  10f9					      ldx@PLY	moveIndex
      1  10f9		       ae d0 f9 	      ldx	moveIndex
    231  10fc		       30 76		      bmi	.exit
    232  10fe
      0  10fe				   .forChild  stx@PLY	movePtr
      1  10fe		       8e d1 fb 	      stx	[RAM]+movePtr
    234  1101
    235  1101							; The movelist has captures ONLY (ref: __quiesceCapOnly != 0)
    236  1101
    237  1101		       20 64 f6 	      jsr	MakeMove
    238  1104
    239  1104		       38		      sec
    240  1105		       a9 00		      lda	#0
      0  1107					      sbc@PLY	beta
      1  1107		       ed d5 f9 	      sbc	beta
    242  110a		       85 a4		      sta	__alpha
    243  110c		       a9 00		      lda	#0
      0  110e					      sbc@PLY	beta+1
      1  110e		       ed d6 f9 	      sbc	beta+1
    245  1111		       85 a5		      sta	__alpha+1
    246  1113
    247  1113		       38		      sec
    248  1114		       a9 00		      lda	#0
      0  1116					      sbc@PLY	alpha
      1  1116		       ed d3 f9 	      sbc	alpha
    250  1119		       85 a6		      sta	__beta
    251  111b		       a9 00		      lda	#0
      0  111d					      sbc@PLY	alpha+1
      1  111d		       ed d4 f9 	      sbc	alpha+1
    253  1120		       85 a7		      sta	__beta+1
    254  1122
    255  1122		       e6 94		      inc	currentPly
    256  1124		       a5 94		      lda	currentPly
    257  1126		       85 3e		      sta	SET_BANK_RAM	; self-switch
    258  1128
    259  1128		       20 83 f4 	      jsr	quiesce
    260  112b
    261  112b		       c6 94		      dec	currentPly
    262  112d							;lda currentPly
    263  112d							;sta SET_BANK_RAM
    264  112d
    265  112d		       20 32 f2 	      jsr	unmakeMove	;@0
    266  1130
    267  1130		       a5 9e		      lda	flagCheck	; don't consider moves which leave us in check
    268  1132		       d0 4b		      bne	.inCheck
    269  1134
    270  1134		       38		      sec
    271  1135							;lda #0			 ; already 0
    272  1135		       e5 a8		      sbc	__negaMax
    273  1137		       85 a8		      sta	__negaMax
    274  1139		       a9 00		      lda	#0
    275  113b		       e5 a9		      sbc	__negaMax+1
    276  113d		       85 a9		      sta	__negaMax+1	; -negaMax(...)
    277  113f
    278  113f
    279  113f
    280  113f							;	  if( score >= beta )
    281  113f							;	      return beta;
    282  113f
    283  113f
    284  113f		       38		      sec
    285  1140		       a5 a8		      lda	__negaMax
      0  1142					      sbc@PLY	beta
      1  1142		       ed d5 f9 	      sbc	beta
    287  1145		       a5 a9		      lda	__negaMax+1
      0  1147					      sbc@PLY	beta+1
      1  1147		       ed d6 f9 	      sbc	beta+1
    289  114a		       50 02		      bvc	.lab0
    290  114c		       49 80		      eor	#$80
    291  114e		       30 03	   .lab0      bmi	.nrb2	; .retBeta		       ; branch if score >= beta
    292  1150		       4c cc f4 	      jmp	.retBeta
    293  1153				   .nrb2
    294  1153
    295  1153							;	  if( score > alpha )
    296  1153							;	     alpha = score;
    297  1153							;    }
    298  1153
    299  1153		       38		      sec
      0  1154					      lda@PLY	alpha
      1  1154		       ad d3 f9 	      lda	alpha
    301  1157		       e5 a8		      sbc	__negaMax
      0  1159					      lda@PLY	alpha+1
      1  1159		       ad d4 f9 	      lda	alpha+1
    303  115c		       e5 a9		      sbc	__negaMax+1
    304  115e		       50 02		      bvc	.lab2
    305  1160		       49 80		      eor	#$80
    306  1162		       10 0a	   .lab2      bpl	.nextMove	; alpha >= score
    307  1164
    308  1164							; score > alpha
    309  1164
    310  1164		       a5 a8		      lda	__negaMax
      0  1166					      sta@PLY	alpha
      1  1166		       8d d3 fb 	      sta	[RAM]+alpha
    312  1169		       a5 a9		      lda	__negaMax+1
      0  116b					      sta@PLY	alpha+1
      1  116b		       8d d4 fb 	      sta	[RAM]+alpha+1
    314  116e
      0  116e				   .nextMove  ldx@PLY	movePtr
      1  116e		       ae d1 f9 	      ldx	movePtr
    316  1171		       ca		      dex
    317  1172		       10 8a		      bpl	.forChild
    318  1174
    319  1174							;    return alpha;
    320  1174
    321  1174				   .exit
      0  1174					      lda@PLY	alpha
      1  1174		       ad d3 f9 	      lda	alpha
    323  1177		       85 a8		      sta	__negaMax
      0  1179					      lda@PLY	alpha+1
      1  1179		       ad d4 f9 	      lda	alpha+1
    325  117c		       85 a9		      sta	__negaMax+1
    326  117e		       60		      rts
    327  117f
    328  117f		       a9 00	   .inCheck   lda	#0
    329  1181		       85 9e		      sta	flagCheck
    330  1183		       f0 e9		      beq	.nextMove
    331  1185
    332  1185
    333  1185
    334  1185				   SynapsePattern2
    335  1185
    336  1185		       c1		      .byte.b	%11000001
    337  1186		       60		      .byte.b	%01100000
    338  1187		       30		      .byte.b	%00110000
    339  1188		       18		      .byte.b	%00011000
    340  1189		       0c		      .byte.b	%00001100
    341  118a		       06		      .byte.b	%00000110
    342  118b		       83		      .byte.b	%10000011
    343  118c		       c1		      .byte.b	%11000001
    344  118d
    345  118d		       83		      .byte.b	%10000011
    346  118e		       06		      .byte.b	%00000110
    347  118f		       0c		      .byte.b	%00001100
    348  1190		       18		      .byte.b	%00011000
    349  1191		       30		      .byte.b	%00110000
    350  1192		       60		      .byte.b	%01100000
    351  1193		       c1		      .byte.b	%11000001
    352  1194		       83		      .byte.b	%10000011
    353  1195
    354  1195
    355  1195							;---------------------------------------------------------------------------------------------------
    356  1195
      0  1195					      CHECK_BANK_SIZE	"BANK_PLY"
      1  1195		       01 95	   .TEMP      =	* - _BANK_START
 BANK_PLY (1K) SIZE =  $195 , FREE= $26b
      2  1195					      ECHO	"BANK_PLY", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1195				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1195				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_PLY", " size=", * - ORIGIN
      5  1195				  -	      ERR
      6  1195					      ENDIF
    358  1195
    359  1195							;---------------------------------------------------------------------------------------------------
    360  1195							; EOF
------- FILE ./chess.asm
------- FILE SHADOW_PLY.asm LEVEL 2 PASS 4
      0  1195					      include	"SHADOW_PLY.asm"
      1  1195							; Chess
      2  1195							; Copyright (c) 2019-2020 Andrew Davie
      3  1195							; andrew@taswegian.com
      4  1195
      5  1195
      6  1195							;---------------------------------------------------------------------------------------------------
      7  1195							; Define the RAM banks
      8  1195							; A "PLY" bank represents all the data required on any single ply of the search tree.
      9  1195							; The banks are organised sequentially, PLY_BANKS of them starting at RAMBANK_PLY
     10  1195							; The startup code copies the ROM shadow into each of these PLY banks, and from then on
     11  1195							; they act as independant switchable banks usable for data on each ply during the search.
     12  1195							; A ply will hold the move list for that position
     13  1195
     14  1195
      0  1195					      SLOT	2
      1  1195				  -	      IF	(2 < 0) || (2 > 3)
      2  1195				  -	      ECHO	"Illegal bank address/segment location", 2
      3  1195				  -	      ERR
      4  1195					      ENDIF
      5  1195				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  1195				   _BANK_SLOT SET	2 * 64
      0  1195					      NEWRAMBANK	PLY	; RAM bank for holding the following ROM shadow
      1  1195
      2  1195
      3  1195
      4 U21de ????				      SEG.U	PLY
      5 U2000					      ORG	ORIGIN_RAM
      6 U2000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2000				   _BANK_START SET	*
      8 U2000				   RAMBANK_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2000				   _CURRENT_RAMBANK SET	RAMBANK_PLY
     10 U2000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U2000
     18 U2000							;---------------------------------------------------------------------------------------------------
     19 U2000
     20 U2000		       00 64	   MAX_MOVES  =	100	; big is good
     21 U2000
      0 U2000					      VARIABLE	MoveFrom, MAX_MOVES
      0 U2000					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2000					      LIST	ON
      2 U2000		       00 00 00 00*MoveFrom   ds	MAX_MOVES
      0 U2064					      VARIABLE	MoveTo, MAX_MOVES
      0 U2064					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2064					      LIST	ON
      2 U2064		       00 00 00 00*MoveTo     ds	MAX_MOVES
      0 U20c8					      VARIABLE	MovePiece, MAX_MOVES
      0 U20c8					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2100					      LIST	ON
      2 U2100		       00 00 00 00*MovePiece  ds	MAX_MOVES
      0 U2164					      VARIABLE	MoveCapture, MAX_MOVES
      0 U2164					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2164					      LIST	ON
      2 U2164		       00 00 00 00*MoveCapture ds	MAX_MOVES
     26 U21c8
     27 U21c8
     28 U21c8							;---------------------------------------------------------------------------------------------------
     29 U21c8
     30 U21c8							; The X12 square at which a pawn CAN be taken en-passant. Normally 0.
     31 U21c8							; This is set/cleared whenever a move is made. The flag is indicated in the move description.
     32 U21c8
      0 U21c8					      VARIABLE	savedEvaluation, 2	; THIS node's evaluation - used for reverting moves!
      0 U21c8					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21c8					      LIST	ON
      2 U21c8		       00 00	   savedEvaluation ds	2
      0 U21ca					      VARIABLE	enPassantSquare, 1
      0 U21ca					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21ca					      LIST	ON
      2 U21ca		       00	   enPassantSquare ds	1
      0 U21cb					      VARIABLE	capturedPiece, 1
      0 U21cb					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cb					      LIST	ON
      2 U21cb		       00	   capturedPiece ds	1
      0 U21cc					      VARIABLE	originalPiece, 1
      0 U21cc					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cc					      LIST	ON
      2 U21cc		       00	   originalPiece ds	1
      0 U21cd					      VARIABLE	secondaryPiece, 1	; original piece on secondary (castle, enpassant)
      0 U21cd					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cd					      LIST	ON
      2 U21cd		       00	   secondaryPiece ds	1
      0 U21ce					      VARIABLE	secondarySquare, 1	; original square of secondary piece
      0 U21ce					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21ce					      LIST	ON
      2 U21ce		       00	   secondarySquare ds	1
      0 U21cf					      VARIABLE	secondaryBlank, 1	; square to blank on secondary
      0 U21cf					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cf					      LIST	ON
      2 U21cf		       00	   secondaryBlank ds	1
      0 U21d0					      VARIABLE	moveIndex, 1	; points to first available 'slot' for move storage
      0 U21d0					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d0					      LIST	ON
      2 U21d0		       00	   moveIndex  ds	1
      0 U21d1					      VARIABLE	movePtr, 1
      0 U21d1					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d1					      LIST	ON
      2 U21d1		       00	   movePtr    ds	1
      0 U21d2					      VARIABLE	bestMove, 1
      0 U21d2					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d2					      LIST	ON
      2 U21d2		       00	   bestMove   ds	1
      0 U21d3					      VARIABLE	alpha, 2
      0 U21d3					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21d3					      LIST	ON
      2 U21d3		       00 00	   alpha      ds	2
      0 U21d5					      VARIABLE	beta, 2
      0 U21d5					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21d5					      LIST	ON
      2 U21d5		       00 00	   beta       ds	2
      0 U21d7					      VARIABLE	value, 2
      0 U21d7					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21d7					      LIST	ON
      2 U21d7		       00 00	   value      ds	2
      0 U21d9					      VARIABLE	depthLeft, 1
      0 U21d9					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d9					      LIST	ON
      2 U21d9		       00	   depthLeft  ds	1
      0 U21da					      VARIABLE	restorePiece, 1
      0 U21da					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21da					      LIST	ON
      2 U21da		       00	   restorePiece ds	1
      0 U21db					      VARIABLE	kingSquare, 3	; traversing squares for castle/check
      0 U21db					      OPTIONAL_PAGEBREAK	"Variable", 3
     12 U21db					      LIST	ON
      2 U21db		       00 00 00    kingSquare ds	3
     49 U21de
     50 U21de
      0 U21de					      CHECK_RAM_BANK_SIZE	"SHADOW_PLY"
      1 U21de		       01 de	   .TEMP      =	* - _BANK_START
 SHADOW_PLY (512 byte) SIZE =  $1de , FREE= $22
      2 U21de					      ECHO	"SHADOW_PLY", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3 U21de				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U21de				  -	      ECHO	"BANK OVERFLOW @ ", "SHADOW_PLY", " size=", * - ORIGIN
      5 U21de				  -	      ERR
      6 U21de					      ENDIF
     52 U21de
     53 U21de					      REPEAT	PLY_BANKS-1
      0 U21de					      NEWRAMBANK	.DUMMY_PLY
      1 U21de
      2 U21de
      3 U21de
      4 U3800 ????				      SEG.U	.DUMMY_PLY
      5 U2400					      ORG	ORIGIN_RAM
      6 U2400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2400				   _BANK_START SET	*
      8 U2400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U2400					      REPEND
      0 U2400					      NEWRAMBANK	.DUMMY_PLY
      1 U2400
      2 U2400
      3 U2400
      4 U2400					      SEG.U	.DUMMY_PLY
      5 U2800					      ORG	ORIGIN_RAM
      6 U2800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2800				   _BANK_START SET	*
      8 U2800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U2800					      REPEND
      0 U2800					      NEWRAMBANK	.DUMMY_PLY
      1 U2800
      2 U2800
      3 U2800
      4 U2800					      SEG.U	.DUMMY_PLY
      5 U2c00					      ORG	ORIGIN_RAM
      6 U2c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2c00				   _BANK_START SET	*
      8 U2c00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U2c00					      REPEND
      0 U2c00					      NEWRAMBANK	.DUMMY_PLY
      1 U2c00
      2 U2c00
      3 U2c00
      4 U2c00					      SEG.U	.DUMMY_PLY
      5 U3000					      ORG	ORIGIN_RAM
      6 U3000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3000				   _BANK_START SET	*
      8 U3000				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U3000					      REPEND
      0 U3000					      NEWRAMBANK	.DUMMY_PLY
      1 U3000
      2 U3000
      3 U3000
      4 U3000					      SEG.U	.DUMMY_PLY
      5 U3400					      ORG	ORIGIN_RAM
      6 U3400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3400				   _BANK_START SET	*
      8 U3400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U3400					      REPEND
      0 U3400					      NEWRAMBANK	.DUMMY_PLY
      1 U3400
      2 U3400
      3 U3400
      4 U3400					      SEG.U	.DUMMY_PLY
      5 U3800					      ORG	ORIGIN_RAM
      6 U3800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3800				   _BANK_START SET	*
      8 U3800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     55 U3800					      REPEND
     56 U3800
     57 U3800
     58 U3800							;---------------------------------------------------------------------------------------------------
     59 U3800							; EOF
------- FILE ./chess.asm
------- FILE SHADOW_BOARD.asm LEVEL 2 PASS 4
      0 U3800					      include	"SHADOW_BOARD.asm"
      1 U3800							; Copyright (C)2020 Andrew Davie
      2 U3800
      3 U3800
      4 U3800							;---------------------------------------------------------------------------------------------------
      0 U3800					      SLOT	3
      1 U3800				  -	      IF	(3 < 0) || (3 > 3)
      2 U3800				  -	      ECHO	"Illegal bank address/segment location", 3
      3 U3800				  -	      ERR
      4 U3800					      ENDIF
      5 U3800				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6 U3800				   _BANK_SLOT SET	3 * 64
      0 U3800					      NEWRAMBANK	BOARD	; RAM bank for holding the following ROM shadow
      1 U3800
      2 U3800
      3 U3800
      4 U3c00 ????				      SEG.U	BOARD
      5 U3c00					      ORG	ORIGIN_RAM
      6 U3c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3c00				   _BANK_START SET	*
      8 U3c00				   RAMBANK_BOARD SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3c00				   _CURRENT_RAMBANK SET	RAMBANK_BOARD
     10 U3c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      7 U3c00
      8 U3c00		       fc 15	   ValidSquare =	ShadowValidSquare + $400
      9 U3c00		       fc 79	   Board      =	ShadowBoard + $400
     10 U3c00
      0 U3c00					      SLOT	2
      1 U3c00				  -	      IF	(2 < 0) || (2 > 3)
      2 U3c00				  -	      ECHO	"Illegal bank address/segment location", 2
      3 U3c00				  -	      ERR
      4 U3c00					      ENDIF
      5 U3c00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6 U3c00				   _BANK_SLOT SET	2 * 64
      0 U3c00					      NEWBANK	SHADOW_BOARD	; copy the following bank to RAMBANK_BOARD
      1  14dd ????				      SEG	SHADOW_BOARD
      2  1400					      ORG	_ORIGIN
      3  1400					      RORG	_BANK_ADDRESS_ORIGIN
      4  1400				   _BANK_START SET	*
      5  1400				   SHADOW_BOARD_START SET	*
      6  1400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1400				   SHADOW_BOARD SET	_BANK_SLOT + _CURRENT_BANK
      8  1400				   _ORIGIN    SET	_ORIGIN + 1024
     13  1400
     14  1400							; Board is a 10 x 12 object which simplifies the generation of moves
     15  1400							; The squares marked '░░░' are illegal. The ("X12") index of each square is the left
     16  1400							; number + the bottom number. Bottom left legal square (AS VISIBLE ON SCREEN) is #22
     17  1400
     18  1400							;     X12 numbering
     19  1400							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     20  1400							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     21  1400							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     22  1400							; 90 ┃░░░┊░░░┊ 92┊ 93┊ 94┊ 95┊ 96┊ 97┊ 98┊ 99┃ 8 BLACK
     23  1400							; 80 ┃░░░┊░░░┊ 82┊ 83┊ 84┊ 85┊ 86┊ 87┊ 88┊ 89┃ 7 BLACK
     24  1400							; 70 ┃░░░┊░░░┊ 72┊ 73┊ 74┊ 75┊ 76┊ 77┊ 78┊ 79┃ 6
     25  1400							; 60 ┃░░░┊░░░┊ 62┊ 63┊ 64┊ 65┊ 66┊ 67┊ 68┊ 69┃ 5
     26  1400							; 50 ┃░░░┊░░░┊ 52┊ 53┊ 54┊ 55┊ 56┊ 57┊ 58┊ 59┃ 4
     27  1400							; 40 ┃░░░┊░░░┊ 42┊ 43┊ 44┊ 45┊ 46┊ 47┊ 48┊ 49┃ 3
     28  1400							; 30 ┃░░░┊░░░┊ 32┊ 33┊ 34┊ 35┊ 36┊ 37┊ 38┊ 39┃ 2 WHITE
     29  1400							; 20 ┃░░░┊░░░┊ 22┊ 23┊ 24┊ 25┊ 26┊ 27┊ 28┊ 29┃ 1 WHITE
     30  1400							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     31  1400							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     32  1400							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     33  1400							;	0   1	2   3	4   5	6   7	8   9
     34  1400							;		A   B	C   D	E   F	G   H
     35  1400
     36  1400							;     HEX X12
     37  1400							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     38  1400							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     39  1400							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     40  1400							; 90 ┃░░░┊░░░┊$5C┊$5D┊$5E┊$5F┊$60┊$61┊$62┊$63┃ 8
     41  1400							; 80 ┃░░░┊░░░┊$52┊$53┊$54┊$55┊$56┊$57┊$58┊$59┃ 7
     42  1400							; 70 ┃░░░┊░░░┊$48┊$49┊$4A┊$4B┊$4C┊$4D┊$4E┊$4F┃ 6
     43  1400							; 60 ┃░░░┊░░░┊$3E┊$3F┊$40┊$41┊$42┊$43┊$44┊$45┃ 5
     44  1400							; 50 ┃░░░┊░░░┊$34┊$35┊$36┊$37┊$38┊$39┊$3A┊$3B┃ 4
     45  1400							; 40 ┃░░░┊░░░┊$2A┊$2B┊$2C┊$2D┊$2E┊$2F┊$30┊$31┃ 3
     46  1400							; 30 ┃░░░┊░░░┊$20┊$21┊$22┊$23┊$24┊$25┊$26|$27┃ 2
     47  1400							; 20 ┃░░░┊░░░┊$16┊$17┊$18┊$19┊$1A┊$1B┊$1C┊$1D┃ 1
     48  1400							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     49  1400							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     50  1400							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     51  1400							;	0   1	2   3	4   5	6   7	8   9
     52  1400							;		A   B	C   D	E   F	G   H
     53  1400
     54  1400
     55  1400							; We put a short buffer before 'ValidSquare' when it is at the start of the bank, so that
     56  1400							; the move indexing (ie., "ValidSquare+{1},x" won't drop off the beginning of the bank
     57  1400							; and sause "segfaults". 21 is the max offset (a knight move). These spare bytes can
     58  1400							; be re-used for something else - we just need to guarantee there are 21 of them there
     59  1400
      0  1400					      ALLOCATE	Valid, 120 + 80 + 21
      0  1400					      OPTIONAL_PAGEBREAK	"Table", 120 + 80 + 21
     12  1400					      LIST	ON
      0  1400					      DEF	Valid
      1  1400				   SLOT_Valid SET	_BANK_SLOT
      2  1400				   BANK_Valid SET	SLOT_Valid + _CURRENT_BANK
      3  1400				   Valid
      4  1400				   TEMPORARY_VAR SET	Overlay
      5  1400				   TEMPORARY_OFFSET SET	0
      6  1400				   VAR_BOUNDARY_Valid SET	TEMPORARY_OFFSET
      7  1400				   FUNCTION_NAME SET	Valid
     61  1400		       00 00 00 00*	      ds	21	; so indexing of "ValidSquare-21,x" won't fail
     62  1415							; Note, we will never index INTO the above bytes - x will always be >= 21
     63  1415							; We just need to make sure that the actual indexing will not have an address before
     64  1415							; the index of outside the page.
     65  1415
      0  1415					      DEF	ShadowValidSquare
      1  1415				   SLOT_ShadowValidSquare SET	_BANK_SLOT
      2  1415				   BANK_ShadowValidSquare SET	SLOT_ShadowValidSquare + _CURRENT_BANK
      3  1415				   ShadowValidSquare
      4  1415				   TEMPORARY_VAR SET	Overlay
      5  1415				   TEMPORARY_OFFSET SET	0
      6  1415				   VAR_BOUNDARY_ShadowValidSquare SET	TEMPORARY_OFFSET
      7  1415				   FUNCTION_NAME SET	ShadowValidSquare
     67  1415
     68  1415
     69  1415							; Use this table to
     70  1415							;   a) Determine if a square is valid (-1 = NO)
     71  1415							;   b) Move pieces without addition.  e.g., "lda ValidSquareTable+10,x" will let you know
     72  1415							;	if a white pawn on square "x" can move "up" the board.
     73  1415
     74  1415		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     75  141f		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     76  1429		       ff ff 16 17*	      .byte.b	-1, -1, 22, 23, 24, 25, 26, 27, 28, 29
     77  1433		       ff ff 20 21*	      .byte.b	-1, -1, 32, 33, 34, 35, 36, 37, 38, 39
     78  143d		       ff ff 2a 2b*	      .byte.b	-1, -1, 42, 43, 44, 45, 46, 47, 48, 49
     79  1447		       ff ff 34 35*	      .byte.b	-1, -1, 52, 53, 54, 55, 56, 57, 58, 59
     80  1451		       ff ff 3e 3f*	      .byte.b	-1, -1, 62, 63, 64, 65, 66, 67, 68, 69
     81  145b		       ff ff 48 49*	      .byte.b	-1, -1, 72, 73, 74, 75, 76, 77, 78, 79
     82  1465		       ff ff 52 53*	      .byte.b	-1, -1, 82, 83, 84, 85, 86, 87, 88, 89
     83  146f		       ff ff 5c 5d*	      .byte.b	-1, -1, 92, 93, 94, 95, 96, 97, 98, 99	; CONTINUES...
     84  1479
      0  1479					      DEF	ShadowBoard
      1  1479				   SLOT_ShadowBoard SET	_BANK_SLOT
      2  1479				   BANK_ShadowBoard SET	SLOT_ShadowBoard + _CURRENT_BANK
      3  1479				   ShadowBoard
      4  1479				   TEMPORARY_VAR SET	Overlay
      5  1479				   TEMPORARY_OFFSET SET	0
      6  1479				   VAR_BOUNDARY_ShadowBoard SET	TEMPORARY_OFFSET
      7  1479				   FUNCTION_NAME SET	ShadowBoard
     86  1479
     87  1479							; A 10X10... we should never write using invalid square
     88  1479							; ON COPY TO RAM BANK, 'BOARD' SELF-INITIALISES TO THE FOLLOWING VALUES
     89  1479							; FROM THEN ON IT'S WRITEABLE (REMEMBER TO +RAM_WRITE) FOR MODIFICATIONS
     90  1479
     91  1479		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     92  1483		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     93  148d
     94  148d					      REPEAT	8
     95  148d		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  148d					      REPEND
     95  1497		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  1497					      REPEND
     95  14a1		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  14a1					      REPEND
     95  14ab		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  14ab					      REPEND
     95  14b5		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  14b5					      REPEND
     95  14bf		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  14bf					      REPEND
     95  14c9		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  14c9					      REPEND
     95  14d3		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     96  14dd					      REPEND
     97  14dd
     98  14dd							; DON'T OVERSTEP BOUNDS WHEN WRITING BOARD - MAXIMUM INDEX = 99
     99  14dd
    100  14dd
    101  14dd							;---------------------------------------------------------------------------------------------------
    102  14dd							; EOF
------- FILE ./chess.asm
------- FILE BANK_EVAL.asm LEVEL 2 PASS 4
      0  14dd					      include	"BANK_EVAL.asm"
      1  14dd
      0  14dd					      SLOT	3
      1  14dd				  -	      IF	(3 < 0) || (3 > 3)
      2  14dd				  -	      ECHO	"Illegal bank address/segment location", 3
      3  14dd				  -	      ERR
      4  14dd					      ENDIF
      5  14dd				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  14dd				   _BANK_SLOT SET	3 * 64
      3  14dd
      4  14dd
      0  14dd					      NEWRAMBANK	BANK_EVAL
      1  14dd
      2  14dd
      3  14dd
      4 U4000 ????				      SEG.U	BANK_EVAL
      5 U4000					      ORG	ORIGIN_RAM
      6 U4000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U4000				   _BANK_START SET	*
      8 U4000				   RAMBANK_BANK_EVAL SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U4000				   _CURRENT_RAMBANK SET	RAMBANK_BANK_EVAL
     10 U4000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U4000					      NEWBANK	EVAL
      1  1a50 ????				      SEG	EVAL
      2  1800					      ORG	_ORIGIN
      3  1800					      RORG	_BANK_ADDRESS_ORIGIN
      4  1800				   _BANK_START SET	*
      5  1800				   EVAL_START SET	*
      6  1800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1800				   EVAL       SET	_BANK_SLOT + _CURRENT_BANK
      8  1800				   _ORIGIN    SET	_ORIGIN + 1024
      7  1800
      8  1800
      9  1800							; see https://www.chessprogramming.org/Simplified_Evaluation_Function
     10  1800
     11  1800
     12  1800
     13  1800					      MAC	vequ
     14  1800				   VALUE_{1}  =	{2}
     15  1800					      ENDM
     16  1800
     17  1800					      MAC	lobyte
     18  1800					      .byte	<{2}
     19  1800					      ENDM
     20  1800
     21  1800					      MAC	hibyte
     22  1800					      .byte	>{2}
     23  1800					      ENDM
     24  1800
     25  1800
     26  1800					      MAC	valuetable
     27  1800					      {1}	BLANK, 0
     28  1800					      {1}	PAWN, 100	; white
     29  1800					      {1}	PAWN, 100	; black
     30  1800					      {1}	KNIGHT, 320
     31  1800					      {1}	BISHOP, 375
     32  1800					      {1}	ROOK, 575
     33  1800					      {1}	QUEEN, 900
     34  1800					      {1}	KING, 10000
     35  1800					      ENDM
     36  1800
     37  1800
      0  1800					      VALUETABLE	VEQU
      0  1800					      VEQU	BLANK, 0
      1  1800		       00 00	   VALUE_BLANK =	0
      0  1800					      VEQU	PAWN, 100
      1  1800		       00 64	   VALUE_PAWN =	100
      0  1800					      VEQU	PAWN, 100
      1  1800		       00 64	   VALUE_PAWN =	100
      0  1800					      VEQU	KNIGHT, 320
      1  1800		       01 40	   VALUE_KNIGHT =	320
      0  1800					      VEQU	BISHOP, 375
      1  1800		       01 77	   VALUE_BISHOP =	375
      0  1800					      VEQU	ROOK, 575
      1  1800		       02 3f	   VALUE_ROOK =	575
      0  1800					      VEQU	QUEEN, 900
      1  1800		       03 84	   VALUE_QUEEN =	900
      0  1800					      VEQU	KING, 10000
      1  1800		       27 10	   VALUE_KING =	10000
     39  1800
      0  1800					      DEF	PieceValueLO
      1  1800				   SLOT_PieceValueLO SET	_BANK_SLOT
      2  1800				   BANK_PieceValueLO SET	SLOT_PieceValueLO + _CURRENT_BANK
      3  1800				   PieceValueLO
      4  1800				   TEMPORARY_VAR SET	Overlay
      5  1800				   TEMPORARY_OFFSET SET	0
      6  1800				   VAR_BOUNDARY_PieceValueLO SET	TEMPORARY_OFFSET
      7  1800				   FUNCTION_NAME SET	PieceValueLO
      0  1800					      VALUETABLE	LOBYTE
      0  1800					      LOBYTE	BLANK, 0
      1  1800		       00		      .byte.b	<0
      0  1801					      LOBYTE	PAWN, 100
      1  1801		       64		      .byte.b	<100
      0  1802					      LOBYTE	PAWN, 100
      1  1802		       64		      .byte.b	<100
      0  1803					      LOBYTE	KNIGHT, 320
      1  1803		       40		      .byte.b	<320
      0  1804					      LOBYTE	BISHOP, 375
      1  1804		       77		      .byte.b	<375
      0  1805					      LOBYTE	ROOK, 575
      1  1805		       3f		      .byte.b	<575
      0  1806					      LOBYTE	QUEEN, 900
      1  1806		       84		      .byte.b	<900
      0  1807					      LOBYTE	KING, 10000
      1  1807		       10		      .byte.b	<10000
     42  1808
      0  1808					      DEF	PieceValueHI
      1  1808				   SLOT_PieceValueHI SET	_BANK_SLOT
      2  1808				   BANK_PieceValueHI SET	SLOT_PieceValueHI + _CURRENT_BANK
      3  1808				   PieceValueHI
      4  1808				   TEMPORARY_VAR SET	Overlay
      5  1808				   TEMPORARY_OFFSET SET	0
      6  1808				   VAR_BOUNDARY_PieceValueHI SET	TEMPORARY_OFFSET
      7  1808				   FUNCTION_NAME SET	PieceValueHI
      0  1808					      VALUETABLE	HIBYTE
      0  1808					      HIBYTE	BLANK, 0
      1  1808		       00		      .byte.b	>0
      0  1809					      HIBYTE	PAWN, 100
      1  1809		       00		      .byte.b	>100
      0  180a					      HIBYTE	PAWN, 100
      1  180a		       00		      .byte.b	>100
      0  180b					      HIBYTE	KNIGHT, 320
      1  180b		       01		      .byte.b	>320
      0  180c					      HIBYTE	BISHOP, 375
      1  180c		       01		      .byte.b	>375
      0  180d					      HIBYTE	ROOK, 575
      1  180d		       02		      .byte.b	>575
      0  180e					      HIBYTE	QUEEN, 900
      1  180e		       03		      .byte.b	>900
      0  180f					      HIBYTE	KING, 10000
      1  180f		       27		      .byte.b	>10000
     45  1810
     46  1810
     47  1810							;---------------------------------------------------------------------------------------------------
     48  1810							; Vectors to the position value tables for each piece
     49  1810
     50  1810					      MAC	posval
     51  1810					      .byte	0
     52  1810					      .byte	{1}(PositionalValue_PAWN - 22)
     53  1810					      .byte	{1}(PositionalValue_PAWN - 22)
     54  1810					      .byte	{1}(PositionalValue_KNIGHT - 22)
     55  1810					      .byte	{1}(PositionalValue_BISHOP - 22)
     56  1810					      .byte	{1}(PositionalValue_ROOK - 22)
     57  1810					      .byte	{1}(PositionalValue_QUEEN - 22)
     58  1810					      .byte	{1}(PositionalValue_KING_MIDGAME - 22)
     59  1810					      ENDM
     60  1810
      0  1810					      ALLOCATE	PosValVecLO, 8
      0  1810					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1810					      LIST	ON
      0  1810					      DEF	PosValVecLO
      1  1810				   SLOT_PosValVecLO SET	_BANK_SLOT
      2  1810				   BANK_PosValVecLO SET	SLOT_PosValVecLO + _CURRENT_BANK
      3  1810				   PosValVecLO
      4  1810				   TEMPORARY_VAR SET	Overlay
      5  1810				   TEMPORARY_OFFSET SET	0
      6  1810				   VAR_BOUNDARY_PosValVecLO SET	TEMPORARY_OFFSET
      7  1810				   FUNCTION_NAME SET	PosValVecLO
      0  1810					      POSVAL	<
      1  1810		       00		      .byte.b	0
      2  1811		       0a		      .byte.b	<(PositionalValue_PAWN - 22)
      3  1812		       0a		      .byte.b	<(PositionalValue_PAWN - 22)
      4  1813		       5a		      .byte.b	<(PositionalValue_KNIGHT - 22)
      5  1814		       aa		      .byte.b	<(PositionalValue_BISHOP - 22)
      6  1815		       fa		      .byte.b	<(PositionalValue_ROOK - 22)
      7  1816		       4a		      .byte.b	<(PositionalValue_QUEEN - 22)
      8  1817		       9a		      .byte.b	<(PositionalValue_KING_MIDGAME - 22)
      0  1818					      ALLOCATE	PosValVecHI, 8
      0  1818					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1818					      LIST	ON
      0  1818					      DEF	PosValVecHI
      1  1818				   SLOT_PosValVecHI SET	_BANK_SLOT
      2  1818				   BANK_PosValVecHI SET	SLOT_PosValVecHI + _CURRENT_BANK
      3  1818				   PosValVecHI
      4  1818				   TEMPORARY_VAR SET	Overlay
      5  1818				   TEMPORARY_OFFSET SET	0
      6  1818				   VAR_BOUNDARY_PosValVecHI SET	TEMPORARY_OFFSET
      7  1818				   FUNCTION_NAME SET	PosValVecHI
      0  1818					      POSVAL	>
      1  1818		       00		      .byte.b	0
      2  1819		       fc		      .byte.b	>(PositionalValue_PAWN - 22)
      3  181a		       fc		      .byte.b	>(PositionalValue_PAWN - 22)
      4  181b		       fc		      .byte.b	>(PositionalValue_KNIGHT - 22)
      5  181c		       fc		      .byte.b	>(PositionalValue_BISHOP - 22)
      6  181d		       fc		      .byte.b	>(PositionalValue_ROOK - 22)
      7  181e		       fd		      .byte.b	>(PositionalValue_QUEEN - 22)
      8  181f		       fd		      .byte.b	>(PositionalValue_KING_MIDGAME - 22)
     65  1820
     66  1820		       00 32	   BZ	      =	50
     67  1820
     68  1820					      MAC	pval
     69  1820					      .byte	BZ + {1}
     70  1820					      .byte	BZ + {2}
     71  1820					      .byte	BZ + {3}
     72  1820					      .byte	BZ + {4}
     73  1820					      .byte	BZ + {5}
     74  1820					      .byte	BZ + {6}
     75  1820					      .byte	BZ + {7}
     76  1820					      .byte	BZ + {8}
     77  1820					      .byte	BZ
     78  1820					      .byte	BZ
     79  1820					      ENDM		;{ 10 entries }
     80  1820
     81  1820							;---------------------------------------------------------------------------------------------------
     82  1820
     83  1820				   PositionalValue_PAWN
     84  1820
      0  1820					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  1820		       32		      .byte.b	BZ + 0
      2  1821		       32		      .byte.b	BZ + 0
      3  1822		       32		      .byte.b	BZ + 0
      4  1823		       32		      .byte.b	BZ + 0
      5  1824		       32		      .byte.b	BZ + 0
      6  1825		       32		      .byte.b	BZ + 0
      7  1826		       32		      .byte.b	BZ + 0
      8  1827		       32		      .byte.b	BZ + 0
      9  1828		       32		      .byte.b	BZ
     10  1829		       32		      .byte.b	BZ
      0  182a					      PVAL	15, 10, 0, -20, -20, 0, 10, 15
      1  182a		       41		      .byte.b	BZ + 15
      2  182b		       3c		      .byte.b	BZ + 10
      3  182c		       32		      .byte.b	BZ + 0
      4  182d		       1e		      .byte.b	BZ + -20
      5  182e		       1e		      .byte.b	BZ + -20
      6  182f		       32		      .byte.b	BZ + 0
      7  1830		       3c		      .byte.b	BZ + 10
      8  1831		       41		      .byte.b	BZ + 15
      9  1832		       32		      .byte.b	BZ
     10  1833		       32		      .byte.b	BZ
      0  1834					      PVAL	5, -5, -10, 0, 0, -10, -5, 5
      1  1834		       37		      .byte.b	BZ + 5
      2  1835		       2d		      .byte.b	BZ + -5
      3  1836		       28		      .byte.b	BZ + -10
      4  1837		       32		      .byte.b	BZ + 0
      5  1838		       32		      .byte.b	BZ + 0
      6  1839		       28		      .byte.b	BZ + -10
      7  183a		       2d		      .byte.b	BZ + -5
      8  183b		       37		      .byte.b	BZ + 5
      9  183c		       32		      .byte.b	BZ
     10  183d		       32		      .byte.b	BZ
      0  183e					      PVAL	0, 0, 0, 10, 40, 0, 0, 0
      1  183e		       32		      .byte.b	BZ + 0
      2  183f		       32		      .byte.b	BZ + 0
      3  1840		       32		      .byte.b	BZ + 0
      4  1841		       3c		      .byte.b	BZ + 10
      5  1842		       5a		      .byte.b	BZ + 40
      6  1843		       32		      .byte.b	BZ + 0
      7  1844		       32		      .byte.b	BZ + 0
      8  1845		       32		      .byte.b	BZ + 0
      9  1846		       32		      .byte.b	BZ
     10  1847		       32		      .byte.b	BZ
      0  1848					      PVAL	15, 15, 20, 20, 50, 20, 15, 15
      1  1848		       41		      .byte.b	BZ + 15
      2  1849		       41		      .byte.b	BZ + 15
      3  184a		       46		      .byte.b	BZ + 20
      4  184b		       46		      .byte.b	BZ + 20
      5  184c		       64		      .byte.b	BZ + 50
      6  184d		       46		      .byte.b	BZ + 20
      7  184e		       41		      .byte.b	BZ + 15
      8  184f		       41		      .byte.b	BZ + 15
      9  1850		       32		      .byte.b	BZ
     10  1851		       32		      .byte.b	BZ
      0  1852					      PVAL	30, 30, 40, 50, 50, 40, 30, 30
      1  1852		       50		      .byte.b	BZ + 30
      2  1853		       50		      .byte.b	BZ + 30
      3  1854		       5a		      .byte.b	BZ + 40
      4  1855		       64		      .byte.b	BZ + 50
      5  1856		       64		      .byte.b	BZ + 50
      6  1857		       5a		      .byte.b	BZ + 40
      7  1858		       50		      .byte.b	BZ + 30
      8  1859		       50		      .byte.b	BZ + 30
      9  185a		       32		      .byte.b	BZ
     10  185b		       32		      .byte.b	BZ
      0  185c					      PVAL	40, 50, 60, 70, 70, 60, 50, 40
      1  185c		       5a		      .byte.b	BZ + 40
      2  185d		       64		      .byte.b	BZ + 50
      3  185e		       6e		      .byte.b	BZ + 60
      4  185f		       78		      .byte.b	BZ + 70
      5  1860		       78		      .byte.b	BZ + 70
      6  1861		       6e		      .byte.b	BZ + 60
      7  1862		       64		      .byte.b	BZ + 50
      8  1863		       5a		      .byte.b	BZ + 40
      9  1864		       32		      .byte.b	BZ
     10  1865		       32		      .byte.b	BZ
      0  1866					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  1866		       32		      .byte.b	BZ + 0
      2  1867		       32		      .byte.b	BZ + 0
      3  1868		       32		      .byte.b	BZ + 0
      4  1869		       32		      .byte.b	BZ + 0
      5  186a		       32		      .byte.b	BZ + 0
      6  186b		       32		      .byte.b	BZ + 0
      7  186c		       32		      .byte.b	BZ + 0
      8  186d		       32		      .byte.b	BZ + 0
      9  186e		       32		      .byte.b	BZ
     10  186f		       32		      .byte.b	BZ
     93  1870
     94  1870							;---------------------------------------------------------------------------------------------------
     95  1870
     96  1870				   PositionalValue_KNIGHT
     97  1870
      0  1870					      PVAL	-50, -40, -30, -30, -30, -30, -40, -50
      1  1870		       00		      .byte.b	BZ + -50
      2  1871		       0a		      .byte.b	BZ + -40
      3  1872		       14		      .byte.b	BZ + -30
      4  1873		       14		      .byte.b	BZ + -30
      5  1874		       14		      .byte.b	BZ + -30
      6  1875		       14		      .byte.b	BZ + -30
      7  1876		       0a		      .byte.b	BZ + -40
      8  1877		       00		      .byte.b	BZ + -50
      9  1878		       32		      .byte.b	BZ
     10  1879		       32		      .byte.b	BZ
      0  187a					      PVAL	-40, -20, 0, 5, 5, 0, -20, -40
      1  187a		       0a		      .byte.b	BZ + -40
      2  187b		       1e		      .byte.b	BZ + -20
      3  187c		       32		      .byte.b	BZ + 0
      4  187d		       37		      .byte.b	BZ + 5
      5  187e		       37		      .byte.b	BZ + 5
      6  187f		       32		      .byte.b	BZ + 0
      7  1880		       1e		      .byte.b	BZ + -20
      8  1881		       0a		      .byte.b	BZ + -40
      9  1882		       32		      .byte.b	BZ
     10  1883		       32		      .byte.b	BZ
      0  1884					      PVAL	-30, 0, 20, 15, 15, 20, 0, -30
      1  1884		       14		      .byte.b	BZ + -30
      2  1885		       32		      .byte.b	BZ + 0
      3  1886		       46		      .byte.b	BZ + 20
      4  1887		       41		      .byte.b	BZ + 15
      5  1888		       41		      .byte.b	BZ + 15
      6  1889		       46		      .byte.b	BZ + 20
      7  188a		       32		      .byte.b	BZ + 0
      8  188b		       14		      .byte.b	BZ + -30
      9  188c		       32		      .byte.b	BZ
     10  188d		       32		      .byte.b	BZ
      0  188e					      PVAL	-30, 0, 15, 30, 30, 15, 0, -30
      1  188e		       14		      .byte.b	BZ + -30
      2  188f		       32		      .byte.b	BZ + 0
      3  1890		       41		      .byte.b	BZ + 15
      4  1891		       50		      .byte.b	BZ + 30
      5  1892		       50		      .byte.b	BZ + 30
      6  1893		       41		      .byte.b	BZ + 15
      7  1894		       32		      .byte.b	BZ + 0
      8  1895		       14		      .byte.b	BZ + -30
      9  1896		       32		      .byte.b	BZ
     10  1897		       32		      .byte.b	BZ
      0  1898					      PVAL	-30, 5, 15, 30, 30, 15, 5, -30
      1  1898		       14		      .byte.b	BZ + -30
      2  1899		       37		      .byte.b	BZ + 5
      3  189a		       41		      .byte.b	BZ + 15
      4  189b		       50		      .byte.b	BZ + 30
      5  189c		       50		      .byte.b	BZ + 30
      6  189d		       41		      .byte.b	BZ + 15
      7  189e		       37		      .byte.b	BZ + 5
      8  189f		       14		      .byte.b	BZ + -30
      9  18a0		       32		      .byte.b	BZ
     10  18a1		       32		      .byte.b	BZ
      0  18a2					      PVAL	-30, 0, 10, 15, 15, 10, 0, -30
      1  18a2		       14		      .byte.b	BZ + -30
      2  18a3		       32		      .byte.b	BZ + 0
      3  18a4		       3c		      .byte.b	BZ + 10
      4  18a5		       41		      .byte.b	BZ + 15
      5  18a6		       41		      .byte.b	BZ + 15
      6  18a7		       3c		      .byte.b	BZ + 10
      7  18a8		       32		      .byte.b	BZ + 0
      8  18a9		       14		      .byte.b	BZ + -30
      9  18aa		       32		      .byte.b	BZ
     10  18ab		       32		      .byte.b	BZ
      0  18ac					      PVAL	-40, -20, 30, 0, 0, 30, -20, -40
      1  18ac		       0a		      .byte.b	BZ + -40
      2  18ad		       1e		      .byte.b	BZ + -20
      3  18ae		       50		      .byte.b	BZ + 30
      4  18af		       32		      .byte.b	BZ + 0
      5  18b0		       32		      .byte.b	BZ + 0
      6  18b1		       50		      .byte.b	BZ + 30
      7  18b2		       1e		      .byte.b	BZ + -20
      8  18b3		       0a		      .byte.b	BZ + -40
      9  18b4		       32		      .byte.b	BZ
     10  18b5		       32		      .byte.b	BZ
      0  18b6					      PVAL	-50, -20, -30, -30, -30, -30, -20, -50
      1  18b6		       00		      .byte.b	BZ + -50
      2  18b7		       1e		      .byte.b	BZ + -20
      3  18b8		       14		      .byte.b	BZ + -30
      4  18b9		       14		      .byte.b	BZ + -30
      5  18ba		       14		      .byte.b	BZ + -30
      6  18bb		       14		      .byte.b	BZ + -30
      7  18bc		       1e		      .byte.b	BZ + -20
      8  18bd		       00		      .byte.b	BZ + -50
      9  18be		       32		      .byte.b	BZ
     10  18bf		       32		      .byte.b	BZ
    106  18c0
    107  18c0
    108  18c0							;---------------------------------------------------------------------------------------------------
    109  18c0
    110  18c0				   PositionalValue_BISHOP
    111  18c0
      0  18c0					      PVAL	-20, -10, -50, -10, -10, -50, -10, -20
      1  18c0		       1e		      .byte.b	BZ + -20
      2  18c1		       28		      .byte.b	BZ + -10
      3  18c2		       00		      .byte.b	BZ + -50
      4  18c3		       28		      .byte.b	BZ + -10
      5  18c4		       28		      .byte.b	BZ + -10
      6  18c5		       00		      .byte.b	BZ + -50
      7  18c6		       28		      .byte.b	BZ + -10
      8  18c7		       1e		      .byte.b	BZ + -20
      9  18c8		       32		      .byte.b	BZ
     10  18c9		       32		      .byte.b	BZ
      0  18ca					      PVAL	-10, 5, 0, 0, 0, 0, 5, -10
      1  18ca		       28		      .byte.b	BZ + -10
      2  18cb		       37		      .byte.b	BZ + 5
      3  18cc		       32		      .byte.b	BZ + 0
      4  18cd		       32		      .byte.b	BZ + 0
      5  18ce		       32		      .byte.b	BZ + 0
      6  18cf		       32		      .byte.b	BZ + 0
      7  18d0		       37		      .byte.b	BZ + 5
      8  18d1		       28		      .byte.b	BZ + -10
      9  18d2		       32		      .byte.b	BZ
     10  18d3		       32		      .byte.b	BZ
      0  18d4					      PVAL	-10, 10, 10, 10, 10, 10, 10, -10
      1  18d4		       28		      .byte.b	BZ + -10
      2  18d5		       3c		      .byte.b	BZ + 10
      3  18d6		       3c		      .byte.b	BZ + 10
      4  18d7		       3c		      .byte.b	BZ + 10
      5  18d8		       3c		      .byte.b	BZ + 10
      6  18d9		       3c		      .byte.b	BZ + 10
      7  18da		       3c		      .byte.b	BZ + 10
      8  18db		       28		      .byte.b	BZ + -10
      9  18dc		       32		      .byte.b	BZ
     10  18dd		       32		      .byte.b	BZ
      0  18de					      PVAL	-10, 0, 10, 20, 20, 10, 0, -10
      1  18de		       28		      .byte.b	BZ + -10
      2  18df		       32		      .byte.b	BZ + 0
      3  18e0		       3c		      .byte.b	BZ + 10
      4  18e1		       46		      .byte.b	BZ + 20
      5  18e2		       46		      .byte.b	BZ + 20
      6  18e3		       3c		      .byte.b	BZ + 10
      7  18e4		       32		      .byte.b	BZ + 0
      8  18e5		       28		      .byte.b	BZ + -10
      9  18e6		       32		      .byte.b	BZ
     10  18e7		       32		      .byte.b	BZ
      0  18e8					      PVAL	-10, 5, 5, 20, 20, 5, 5, -10
      1  18e8		       28		      .byte.b	BZ + -10
      2  18e9		       37		      .byte.b	BZ + 5
      3  18ea		       37		      .byte.b	BZ + 5
      4  18eb		       46		      .byte.b	BZ + 20
      5  18ec		       46		      .byte.b	BZ + 20
      6  18ed		       37		      .byte.b	BZ + 5
      7  18ee		       37		      .byte.b	BZ + 5
      8  18ef		       28		      .byte.b	BZ + -10
      9  18f0		       32		      .byte.b	BZ
     10  18f1		       32		      .byte.b	BZ
      0  18f2					      PVAL	-10, 0, 5, 10, 10, 5, 0, -10
      1  18f2		       28		      .byte.b	BZ + -10
      2  18f3		       32		      .byte.b	BZ + 0
      3  18f4		       37		      .byte.b	BZ + 5
      4  18f5		       3c		      .byte.b	BZ + 10
      5  18f6		       3c		      .byte.b	BZ + 10
      6  18f7		       37		      .byte.b	BZ + 5
      7  18f8		       32		      .byte.b	BZ + 0
      8  18f9		       28		      .byte.b	BZ + -10
      9  18fa		       32		      .byte.b	BZ
     10  18fb		       32		      .byte.b	BZ
      0  18fc					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      1  18fc		       28		      .byte.b	BZ + -10
      2  18fd		       32		      .byte.b	BZ + 0
      3  18fe		       32		      .byte.b	BZ + 0
      4  18ff		       32		      .byte.b	BZ + 0
      5  1900		       32		      .byte.b	BZ + 0
      6  1901		       32		      .byte.b	BZ + 0
      7  1902		       32		      .byte.b	BZ + 0
      8  1903		       28		      .byte.b	BZ + -10
      9  1904		       32		      .byte.b	BZ
     10  1905		       32		      .byte.b	BZ
      0  1906					      PVAL	-20, -10, -10, -10, -10, -10, -10, -20
      1  1906		       1e		      .byte.b	BZ + -20
      2  1907		       28		      .byte.b	BZ + -10
      3  1908		       28		      .byte.b	BZ + -10
      4  1909		       28		      .byte.b	BZ + -10
      5  190a		       28		      .byte.b	BZ + -10
      6  190b		       28		      .byte.b	BZ + -10
      7  190c		       28		      .byte.b	BZ + -10
      8  190d		       1e		      .byte.b	BZ + -20
      9  190e		       32		      .byte.b	BZ
     10  190f		       32		      .byte.b	BZ
    120  1910
    121  1910
    122  1910							;---------------------------------------------------------------------------------------------------
    123  1910
    124  1910				   PositionalValue_ROOK
    125  1910
      0  1910					      PVAL	-120, -10, 10, 25, 25, 10, -10, -200
      1  1910		       ba		      .byte.b	BZ + -120
      2  1911		       28		      .byte.b	BZ + -10
      3  1912		       3c		      .byte.b	BZ + 10
      4  1913		       4b		      .byte.b	BZ + 25
      5  1914		       4b		      .byte.b	BZ + 25
      6  1915		       3c		      .byte.b	BZ + 10
      7  1916		       28		      .byte.b	BZ + -10
      8  1917		       6a		      .byte.b	BZ + -200
      9  1918		       32		      .byte.b	BZ
     10  1919		       32		      .byte.b	BZ
      0  191a					      PVAL	-75, 0, 0, 0, 0, 0, 0, -200
      1  191a		       e7		      .byte.b	BZ + -75
      2  191b		       32		      .byte.b	BZ + 0
      3  191c		       32		      .byte.b	BZ + 0
      4  191d		       32		      .byte.b	BZ + 0
      5  191e		       32		      .byte.b	BZ + 0
      6  191f		       32		      .byte.b	BZ + 0
      7  1920		       32		      .byte.b	BZ + 0
      8  1921		       6a		      .byte.b	BZ + -200
      9  1922		       32		      .byte.b	BZ
     10  1923		       32		      .byte.b	BZ
      0  1924					      PVAL	-75, 0, 0, 0, 0, 0, 0, -150
      1  1924		       e7		      .byte.b	BZ + -75
      2  1925		       32		      .byte.b	BZ + 0
      3  1926		       32		      .byte.b	BZ + 0
      4  1927		       32		      .byte.b	BZ + 0
      5  1928		       32		      .byte.b	BZ + 0
      6  1929		       32		      .byte.b	BZ + 0
      7  192a		       32		      .byte.b	BZ + 0
      8  192b		       9c		      .byte.b	BZ + -150
      9  192c		       32		      .byte.b	BZ
     10  192d		       32		      .byte.b	BZ
      0  192e					      PVAL	-50, 0, 0, 0, 0, 0, 0, -100
      1  192e		       00		      .byte.b	BZ + -50
      2  192f		       32		      .byte.b	BZ + 0
      3  1930		       32		      .byte.b	BZ + 0
      4  1931		       32		      .byte.b	BZ + 0
      5  1932		       32		      .byte.b	BZ + 0
      6  1933		       32		      .byte.b	BZ + 0
      7  1934		       32		      .byte.b	BZ + 0
      8  1935		       ce		      .byte.b	BZ + -100
      9  1936		       32		      .byte.b	BZ
     10  1937		       32		      .byte.b	BZ
      0  1938					      PVAL	-5, 0, 0, 0, 0, 0, 0, -50
      1  1938		       2d		      .byte.b	BZ + -5
      2  1939		       32		      .byte.b	BZ + 0
      3  193a		       32		      .byte.b	BZ + 0
      4  193b		       32		      .byte.b	BZ + 0
      5  193c		       32		      .byte.b	BZ + 0
      6  193d		       32		      .byte.b	BZ + 0
      7  193e		       32		      .byte.b	BZ + 0
      8  193f		       00		      .byte.b	BZ + -50
      9  1940		       32		      .byte.b	BZ
     10  1941		       32		      .byte.b	BZ
      0  1942					      PVAL	-5, 0, 30, 30, 30, 30, 0, -5
      1  1942		       2d		      .byte.b	BZ + -5
      2  1943		       32		      .byte.b	BZ + 0
      3  1944		       50		      .byte.b	BZ + 30
      4  1945		       50		      .byte.b	BZ + 30
      5  1946		       50		      .byte.b	BZ + 30
      6  1947		       50		      .byte.b	BZ + 30
      7  1948		       32		      .byte.b	BZ + 0
      8  1949		       2d		      .byte.b	BZ + -5
      9  194a		       32		      .byte.b	BZ
     10  194b		       32		      .byte.b	BZ
      0  194c					      PVAL	5, 10, 50, 50, 50, 50, 10, 5
      1  194c		       37		      .byte.b	BZ + 5
      2  194d		       3c		      .byte.b	BZ + 10
      3  194e		       64		      .byte.b	BZ + 50
      4  194f		       64		      .byte.b	BZ + 50
      5  1950		       64		      .byte.b	BZ + 50
      6  1951		       64		      .byte.b	BZ + 50
      7  1952		       3c		      .byte.b	BZ + 10
      8  1953		       37		      .byte.b	BZ + 5
      9  1954		       32		      .byte.b	BZ
     10  1955		       32		      .byte.b	BZ
      0  1956					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  1956		       32		      .byte.b	BZ + 0
      2  1957		       32		      .byte.b	BZ + 0
      3  1958		       32		      .byte.b	BZ + 0
      4  1959		       32		      .byte.b	BZ + 0
      5  195a		       32		      .byte.b	BZ + 0
      6  195b		       32		      .byte.b	BZ + 0
      7  195c		       32		      .byte.b	BZ + 0
      8  195d		       32		      .byte.b	BZ + 0
      9  195e		       32		      .byte.b	BZ
     10  195f		       32		      .byte.b	BZ
    134  1960
    135  1960
    136  1960							;---------------------------------------------------------------------------------------------------
    137  1960
    138  1960				   PositionalValue_QUEEN
    139  1960
      0  1960					      PVAL	-20, -10, -5, -5, -5, -10, -10, -20
      1  1960		       1e		      .byte.b	BZ + -20
      2  1961		       28		      .byte.b	BZ + -10
      3  1962		       2d		      .byte.b	BZ + -5
      4  1963		       2d		      .byte.b	BZ + -5
      5  1964		       2d		      .byte.b	BZ + -5
      6  1965		       28		      .byte.b	BZ + -10
      7  1966		       28		      .byte.b	BZ + -10
      8  1967		       1e		      .byte.b	BZ + -20
      9  1968		       32		      .byte.b	BZ
     10  1969		       32		      .byte.b	BZ
      0  196a					      PVAL	-10, 0, 5, 0, 0, 0, 0, -10
      1  196a		       28		      .byte.b	BZ + -10
      2  196b		       32		      .byte.b	BZ + 0
      3  196c		       37		      .byte.b	BZ + 5
      4  196d		       32		      .byte.b	BZ + 0
      5  196e		       32		      .byte.b	BZ + 0
      6  196f		       32		      .byte.b	BZ + 0
      7  1970		       32		      .byte.b	BZ + 0
      8  1971		       28		      .byte.b	BZ + -10
      9  1972		       32		      .byte.b	BZ
     10  1973		       32		      .byte.b	BZ
      0  1974					      PVAL	-10, 5, 5, 5, 5, 25, 0, -10
      1  1974		       28		      .byte.b	BZ + -10
      2  1975		       37		      .byte.b	BZ + 5
      3  1976		       37		      .byte.b	BZ + 5
      4  1977		       37		      .byte.b	BZ + 5
      5  1978		       37		      .byte.b	BZ + 5
      6  1979		       4b		      .byte.b	BZ + 25
      7  197a		       32		      .byte.b	BZ + 0
      8  197b		       28		      .byte.b	BZ + -10
      9  197c		       32		      .byte.b	BZ
     10  197d		       32		      .byte.b	BZ
      0  197e					      PVAL	-10, 0, 5, 25, 25, 25, 0, -10
      1  197e		       28		      .byte.b	BZ + -10
      2  197f		       32		      .byte.b	BZ + 0
      3  1980		       37		      .byte.b	BZ + 5
      4  1981		       4b		      .byte.b	BZ + 25
      5  1982		       4b		      .byte.b	BZ + 25
      6  1983		       4b		      .byte.b	BZ + 25
      7  1984		       32		      .byte.b	BZ + 0
      8  1985		       28		      .byte.b	BZ + -10
      9  1986		       32		      .byte.b	BZ
     10  1987		       32		      .byte.b	BZ
      0  1988					      PVAL	-5, 0, 15, 55, 55, 55, 0, -5
      1  1988		       2d		      .byte.b	BZ + -5
      2  1989		       32		      .byte.b	BZ + 0
      3  198a		       41		      .byte.b	BZ + 15
      4  198b		       69		      .byte.b	BZ + 55
      5  198c		       69		      .byte.b	BZ + 55
      6  198d		       69		      .byte.b	BZ + 55
      7  198e		       32		      .byte.b	BZ + 0
      8  198f		       2d		      .byte.b	BZ + -5
      9  1990		       32		      .byte.b	BZ
     10  1991		       32		      .byte.b	BZ
      0  1992					      PVAL	-10, 0, 25, 75, 75, 75, 0, -10
      1  1992		       28		      .byte.b	BZ + -10
      2  1993		       32		      .byte.b	BZ + 0
      3  1994		       4b		      .byte.b	BZ + 25
      4  1995		       7d		      .byte.b	BZ + 75
      5  1996		       7d		      .byte.b	BZ + 75
      6  1997		       7d		      .byte.b	BZ + 75
      7  1998		       32		      .byte.b	BZ + 0
      8  1999		       28		      .byte.b	BZ + -10
      9  199a		       32		      .byte.b	BZ
     10  199b		       32		      .byte.b	BZ
      0  199c					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      1  199c		       28		      .byte.b	BZ + -10
      2  199d		       32		      .byte.b	BZ + 0
      3  199e		       32		      .byte.b	BZ + 0
      4  199f		       32		      .byte.b	BZ + 0
      5  19a0		       32		      .byte.b	BZ + 0
      6  19a1		       32		      .byte.b	BZ + 0
      7  19a2		       32		      .byte.b	BZ + 0
      8  19a3		       28		      .byte.b	BZ + -10
      9  19a4		       32		      .byte.b	BZ
     10  19a5		       32		      .byte.b	BZ
      0  19a6					      PVAL	-20, -10, -10, -5, -5, -10, -10, -20
      1  19a6		       1e		      .byte.b	BZ + -20
      2  19a7		       28		      .byte.b	BZ + -10
      3  19a8		       28		      .byte.b	BZ + -10
      4  19a9		       2d		      .byte.b	BZ + -5
      5  19aa		       2d		      .byte.b	BZ + -5
      6  19ab		       28		      .byte.b	BZ + -10
      7  19ac		       28		      .byte.b	BZ + -10
      8  19ad		       1e		      .byte.b	BZ + -20
      9  19ae		       32		      .byte.b	BZ
     10  19af		       32		      .byte.b	BZ
    148  19b0
    149  19b0
    150  19b0							;---------------------------------------------------------------------------------------------------
    151  19b0
    152  19b0				   PositionalValue_KING_MIDGAME
    153  19b0
      0  19b0					      PVAL	0, 0, 30, -20, 0, 10, 40, 10
      1  19b0		       32		      .byte.b	BZ + 0
      2  19b1		       32		      .byte.b	BZ + 0
      3  19b2		       50		      .byte.b	BZ + 30
      4  19b3		       1e		      .byte.b	BZ + -20
      5  19b4		       32		      .byte.b	BZ + 0
      6  19b5		       3c		      .byte.b	BZ + 10
      7  19b6		       5a		      .byte.b	BZ + 40
      8  19b7		       3c		      .byte.b	BZ + 10
      9  19b8		       32		      .byte.b	BZ
     10  19b9		       32		      .byte.b	BZ
      0  19ba					      PVAL	20, 20, 0, -10, -10, 0, 20, 20
      1  19ba		       46		      .byte.b	BZ + 20
      2  19bb		       46		      .byte.b	BZ + 20
      3  19bc		       32		      .byte.b	BZ + 0
      4  19bd		       28		      .byte.b	BZ + -10
      5  19be		       28		      .byte.b	BZ + -10
      6  19bf		       32		      .byte.b	BZ + 0
      7  19c0		       46		      .byte.b	BZ + 20
      8  19c1		       46		      .byte.b	BZ + 20
      9  19c2		       32		      .byte.b	BZ
     10  19c3		       32		      .byte.b	BZ
      0  19c4					      PVAL	-10, -20, -20, -20, -20, -20, -20, -10
      1  19c4		       28		      .byte.b	BZ + -10
      2  19c5		       1e		      .byte.b	BZ + -20
      3  19c6		       1e		      .byte.b	BZ + -20
      4  19c7		       1e		      .byte.b	BZ + -20
      5  19c8		       1e		      .byte.b	BZ + -20
      6  19c9		       1e		      .byte.b	BZ + -20
      7  19ca		       1e		      .byte.b	BZ + -20
      8  19cb		       28		      .byte.b	BZ + -10
      9  19cc		       32		      .byte.b	BZ
     10  19cd		       32		      .byte.b	BZ
      0  19ce					      PVAL	-20, -30, -30, -40, -40, -30, -30, -20
      1  19ce		       1e		      .byte.b	BZ + -20
      2  19cf		       14		      .byte.b	BZ + -30
      3  19d0		       14		      .byte.b	BZ + -30
      4  19d1		       0a		      .byte.b	BZ + -40
      5  19d2		       0a		      .byte.b	BZ + -40
      6  19d3		       14		      .byte.b	BZ + -30
      7  19d4		       14		      .byte.b	BZ + -30
      8  19d5		       1e		      .byte.b	BZ + -20
      9  19d6		       32		      .byte.b	BZ
     10  19d7		       32		      .byte.b	BZ
      0  19d8					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  19d8		       14		      .byte.b	BZ + -30
      2  19d9		       0a		      .byte.b	BZ + -40
      3  19da		       0a		      .byte.b	BZ + -40
      4  19db		       00		      .byte.b	BZ + -50
      5  19dc		       00		      .byte.b	BZ + -50
      6  19dd		       0a		      .byte.b	BZ + -40
      7  19de		       0a		      .byte.b	BZ + -40
      8  19df		       14		      .byte.b	BZ + -30
      9  19e0		       32		      .byte.b	BZ
     10  19e1		       32		      .byte.b	BZ
      0  19e2					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  19e2		       14		      .byte.b	BZ + -30
      2  19e3		       0a		      .byte.b	BZ + -40
      3  19e4		       0a		      .byte.b	BZ + -40
      4  19e5		       00		      .byte.b	BZ + -50
      5  19e6		       00		      .byte.b	BZ + -50
      6  19e7		       0a		      .byte.b	BZ + -40
      7  19e8		       0a		      .byte.b	BZ + -40
      8  19e9		       14		      .byte.b	BZ + -30
      9  19ea		       32		      .byte.b	BZ
     10  19eb		       32		      .byte.b	BZ
      0  19ec					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  19ec		       14		      .byte.b	BZ + -30
      2  19ed		       0a		      .byte.b	BZ + -40
      3  19ee		       0a		      .byte.b	BZ + -40
      4  19ef		       00		      .byte.b	BZ + -50
      5  19f0		       00		      .byte.b	BZ + -50
      6  19f1		       0a		      .byte.b	BZ + -40
      7  19f2		       0a		      .byte.b	BZ + -40
      8  19f3		       14		      .byte.b	BZ + -30
      9  19f4		       32		      .byte.b	BZ
     10  19f5		       32		      .byte.b	BZ
      0  19f6					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  19f6		       14		      .byte.b	BZ + -30
      2  19f7		       0a		      .byte.b	BZ + -40
      3  19f8		       0a		      .byte.b	BZ + -40
      4  19f9		       00		      .byte.b	BZ + -50
      5  19fa		       00		      .byte.b	BZ + -50
      6  19fb		       0a		      .byte.b	BZ + -40
      7  19fc		       0a		      .byte.b	BZ + -40
      8  19fd		       14		      .byte.b	BZ + -30
      9  19fe		       32		      .byte.b	BZ
     10  19ff		       32		      .byte.b	BZ
    162  1a00
    163  1a00
    164  1a00							;---------------------------------------------------------------------------------------------------
    165  1a00
    166  1a00				   PositionalValue_KING_ENDGAME
    167  1a00
      0  1a00					      PVAL	-50, -30, -30, -30, -30, -30, -30, -50
      1  1a00		       00		      .byte.b	BZ + -50
      2  1a01		       14		      .byte.b	BZ + -30
      3  1a02		       14		      .byte.b	BZ + -30
      4  1a03		       14		      .byte.b	BZ + -30
      5  1a04		       14		      .byte.b	BZ + -30
      6  1a05		       14		      .byte.b	BZ + -30
      7  1a06		       14		      .byte.b	BZ + -30
      8  1a07		       00		      .byte.b	BZ + -50
      9  1a08		       32		      .byte.b	BZ
     10  1a09		       32		      .byte.b	BZ
      0  1a0a					      PVAL	-30, -30, 0, 0, 0, 0, -30, -30
      1  1a0a		       14		      .byte.b	BZ + -30
      2  1a0b		       14		      .byte.b	BZ + -30
      3  1a0c		       32		      .byte.b	BZ + 0
      4  1a0d		       32		      .byte.b	BZ + 0
      5  1a0e		       32		      .byte.b	BZ + 0
      6  1a0f		       32		      .byte.b	BZ + 0
      7  1a10		       14		      .byte.b	BZ + -30
      8  1a11		       14		      .byte.b	BZ + -30
      9  1a12		       32		      .byte.b	BZ
     10  1a13		       32		      .byte.b	BZ
      0  1a14					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      1  1a14		       14		      .byte.b	BZ + -30
      2  1a15		       28		      .byte.b	BZ + -10
      3  1a16		       46		      .byte.b	BZ + 20
      4  1a17		       50		      .byte.b	BZ + 30
      5  1a18		       50		      .byte.b	BZ + 30
      6  1a19		       46		      .byte.b	BZ + 20
      7  1a1a		       28		      .byte.b	BZ + -10
      8  1a1b		       14		      .byte.b	BZ + -30
      9  1a1c		       32		      .byte.b	BZ
     10  1a1d		       32		      .byte.b	BZ
      0  1a1e					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      1  1a1e		       14		      .byte.b	BZ + -30
      2  1a1f		       28		      .byte.b	BZ + -10
      3  1a20		       50		      .byte.b	BZ + 30
      4  1a21		       5a		      .byte.b	BZ + 40
      5  1a22		       5a		      .byte.b	BZ + 40
      6  1a23		       50		      .byte.b	BZ + 30
      7  1a24		       28		      .byte.b	BZ + -10
      8  1a25		       14		      .byte.b	BZ + -30
      9  1a26		       32		      .byte.b	BZ
     10  1a27		       32		      .byte.b	BZ
      0  1a28					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      1  1a28		       14		      .byte.b	BZ + -30
      2  1a29		       28		      .byte.b	BZ + -10
      3  1a2a		       50		      .byte.b	BZ + 30
      4  1a2b		       5a		      .byte.b	BZ + 40
      5  1a2c		       5a		      .byte.b	BZ + 40
      6  1a2d		       50		      .byte.b	BZ + 30
      7  1a2e		       28		      .byte.b	BZ + -10
      8  1a2f		       14		      .byte.b	BZ + -30
      9  1a30		       32		      .byte.b	BZ
     10  1a31		       32		      .byte.b	BZ
      0  1a32					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      1  1a32		       14		      .byte.b	BZ + -30
      2  1a33		       28		      .byte.b	BZ + -10
      3  1a34		       46		      .byte.b	BZ + 20
      4  1a35		       50		      .byte.b	BZ + 30
      5  1a36		       50		      .byte.b	BZ + 30
      6  1a37		       46		      .byte.b	BZ + 20
      7  1a38		       28		      .byte.b	BZ + -10
      8  1a39		       14		      .byte.b	BZ + -30
      9  1a3a		       32		      .byte.b	BZ
     10  1a3b		       32		      .byte.b	BZ
      0  1a3c					      PVAL	-30, -20, -10, 0, 0, -10, -20, -30
      1  1a3c		       14		      .byte.b	BZ + -30
      2  1a3d		       1e		      .byte.b	BZ + -20
      3  1a3e		       28		      .byte.b	BZ + -10
      4  1a3f		       32		      .byte.b	BZ + 0
      5  1a40		       32		      .byte.b	BZ + 0
      6  1a41		       28		      .byte.b	BZ + -10
      7  1a42		       1e		      .byte.b	BZ + -20
      8  1a43		       14		      .byte.b	BZ + -30
      9  1a44		       32		      .byte.b	BZ
     10  1a45		       32		      .byte.b	BZ
      0  1a46					      PVAL	-50, -40, -30, -20,- 20, -30, -40, -50
      1  1a46		       00		      .byte.b	BZ + -50
      2  1a47		       0a		      .byte.b	BZ + -40
      3  1a48		       14		      .byte.b	BZ + -30
      4  1a49		       1e		      .byte.b	BZ + -20
      5  1a4a		       1e		      .byte.b	BZ + - 20
      6  1a4b		       14		      .byte.b	BZ + -30
      7  1a4c		       0a		      .byte.b	BZ + -40
      8  1a4d		       00		      .byte.b	BZ + -50
      9  1a4e		       32		      .byte.b	BZ
     10  1a4f		       32		      .byte.b	BZ
    176  1a50
    177  1a50
      0  1a50					      CHECK_BANK_SIZE	"BANK_EVAL"
      1  1a50		       02 50	   .TEMP      =	* - _BANK_START
 BANK_EVAL (1K) SIZE =  $250 , FREE= $1b0
      2  1a50					      ECHO	"BANK_EVAL", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1a50				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1a50				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_EVAL", " size=", * - ORIGIN
      5  1a50				  -	      ERR
      6  1a50					      ENDIF
    179  1a50
    180  1a50							;---------------------------------------------------------------------------------------------------
    181  1a50							; EOF
------- FILE ./chess.asm
------- FILE BANK_StateMachine@1#1.asm LEVEL 2 PASS 4
      0  1a50					      include	"BANK_StateMachine@1#1.asm"
      0  1a50					      SLOT	1
      1  1a50				  -	      IF	(1 < 0) || (1 > 3)
      2  1a50				  -	      ECHO	"Illegal bank address/segment location", 1
      3  1a50				  -	      ERR
      4  1a50					      ENDIF
      5  1a50				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  1a50				   _BANK_SLOT SET	1 * 64
      0  1a50					      NEWBANK	STATEMACHINE
      1  1faf ????				      SEG	STATEMACHINE
      2  1c00					      ORG	_ORIGIN
      3  1c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  1c00				   _BANK_START SET	*
      5  1c00				   STATEMACHINE_START SET	*
      6  1c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1c00				   STATEMACHINE SET	_BANK_SLOT + _CURRENT_BANK
      8  1c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  1c00
      4  1c00
      5  1c00							; Banks holding data (ply 0 doubles as WHITE, and ply 1 as BLACK)
      6  1c00
      7  1c00
      8  1c00		       00 10	   CURSOR_MOVE_SPEED =	16
      9  1c00		       00 14	   CAP_SPEED  =	20
     10  1c00		       00 28	   HOLD_DELAY =	40
     11  1c00
     12  1c00
     13  1c00							;---------------------------------------------------------------------------------------------------
     14  1c00
     15  1c00
     16  1c00							;---------------------------------------------------------------------------------------------------
     17  1c00
      0  1c00					      DEF	aiStartMoveGen
      1  1c00				   SLOT_aiStartMoveGen SET	_BANK_SLOT
      2  1c00				   BANK_aiStartMoveGen SET	SLOT_aiStartMoveGen + _CURRENT_BANK
      3  1c00				   aiStartMoveGen
      4  1c00				   TEMPORARY_VAR SET	Overlay
      5  1c00				   TEMPORARY_OFFSET SET	0
      6  1c00				   VAR_BOUNDARY_aiStartMoveGen SET	TEMPORARY_OFFSET
      7  1c00				   FUNCTION_NAME SET	aiStartMoveGen
     19  1c00					      SUBROUTINE
     20  1c00
      0  1c00					      REFER	AiStateMachine
      1  1c00				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c00				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c00					      ENDIF
      0  1c00					      VEND	aiStartMoveGen
      1  1c00				  -	      IFNCONST	aiStartMoveGen
      2  1c00				  -	      ECHO	"Incorrect VEND label", aiStartMoveGen
      3  1c00				  -	      ERR
      4  1c00					      ENDIF
      5  1c00		       00 a1	   VAREND_aiStartMoveGen =	TEMPORARY_VAR
     23  1c00
     24  1c00							; To assist with castling, generate the moves for the opponent, giving us effectively
     25  1c00							; a list of squares that are being attacked. The castling can't happen if the king is
     26  1c00							; in check or if the squares it would have to move over are in check
     27  1c00
     28  1c00							; we don't need to worry about this if K has moved, or relevant R has moved or if
     29  1c00							; the squares between are occupied. We can tell THAT by examining the movelist to see
     30  1c00							; if there are K-moves marked "FLAG_CASTLE" - and the relevant squares
     31  1c00
     32  1c00							;inc currentPly
     33  1c00							;jsr InitialiseMoveGeneration
     34  1c00
      0  1c00					      PHASE	AI_StepMoveGen
      1  1c00		       a9 0c		      lda	#AI_StepMoveGen
      2  1c02		       85 8b		      sta	aiState
     36  1c04		       60		      rts
     37  1c05
     38  1c05
     39  1c05							;---------------------------------------------------------------------------------------------------
     40  1c05
      0  1c05					      DEF	aiInCheckBackup
      1  1c05				   SLOT_aiInCheckBackup SET	_BANK_SLOT
      2  1c05				   BANK_aiInCheckBackup SET	SLOT_aiInCheckBackup + _CURRENT_BANK
      3  1c05				   aiInCheckBackup
      4  1c05				   TEMPORARY_VAR SET	Overlay
      5  1c05				   TEMPORARY_OFFSET SET	0
      6  1c05				   VAR_BOUNDARY_aiInCheckBackup SET	TEMPORARY_OFFSET
      7  1c05				   FUNCTION_NAME SET	aiInCheckBackup
     42  1c05					      SUBROUTINE
     43  1c05
      0  1c05					      REFER	AiStateMachine
      1  1c05				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c05				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c05					      ENDIF
      0  1c05					      VEND	aiInCheckBackup
      1  1c05				  -	      IFNCONST	aiInCheckBackup
      2  1c05				  -	      ECHO	"Incorrect VEND label", aiInCheckBackup
      3  1c05				  -	      ERR
      4  1c05					      ENDIF
      5  1c05		       00 a1	   VAREND_aiInCheckBackup =	TEMPORARY_VAR
     46  1c05
     47  1c05							; We're about to draw some large text on the screen
     48  1c05							; Make a backup copy of all of the row bitmaps, so that we can restore once text is done
     49  1c05
     50  1c05		       c6 84		      dec	drawCount
     51  1c07		       30 02		      bmi	.exit	; done all rows
     52  1c09		       a4 84		      ldy	drawCount
     53  1c0b				  -	      IF	0
     54  1c0b				  -	      jmp	SAFE_BackupBitmaps
     55  1c0b					      ENDIF
     56  1c0b
      0  1c0b				   .exit      PHASE	AI_InCheckDelay
      1  1c0b		       a9 1e		      lda	#AI_InCheckDelay
      2  1c0d		       85 8b		      sta	aiState
     58  1c0f		       60		      rts
     59  1c10
     60  1c10
     61  1c10							;---------------------------------------------------------------------------------------------------
     62  1c10
      0  1c10					      DEF	aiInCheckDelay
      1  1c10				   SLOT_aiInCheckDelay SET	_BANK_SLOT
      2  1c10				   BANK_aiInCheckDelay SET	SLOT_aiInCheckDelay + _CURRENT_BANK
      3  1c10				   aiInCheckDelay
      4  1c10				   TEMPORARY_VAR SET	Overlay
      5  1c10				   TEMPORARY_OFFSET SET	0
      6  1c10				   VAR_BOUNDARY_aiInCheckDelay SET	TEMPORARY_OFFSET
      7  1c10				   FUNCTION_NAME SET	aiInCheckDelay
     64  1c10					      SUBROUTINE
     65  1c10
      0  1c10					      REFER	AiStateMachine
      1  1c10				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c10				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c10					      ENDIF
      0  1c10					      VEND	aiInCheckDelay
      1  1c10				  -	      IFNCONST	aiInCheckDelay
      2  1c10				  -	      ECHO	"Incorrect VEND label", aiInCheckDelay
      3  1c10				  -	      ERR
      4  1c10					      ENDIF
      5  1c10		       00 a1	   VAREND_aiInCheckDelay =	TEMPORARY_VAR
     68  1c10
     69  1c10		       c6 89		      dec	mdelay
     70  1c12		       d0 08		      bne	.exit
     71  1c14
     72  1c14		       a9 00		      lda	#0
     73  1c16		       85 49		      sta	COLUBK
     74  1c18
      0  1c18					      PHASE	AI_BeginSelectMovePhase
      1  1c18		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  1c1a		       85 8b		      sta	aiState
     76  1c1c		       60	   .exit      rts
     77  1c1d
     78  1c1d
     79  1c1d							;---------------------------------------------------------------------------------------------------
     80  1c1d
      0  1c1d					      DEF	aiBeginSelectMovePhase
      1  1c1d				   SLOT_aiBeginSelectMovePhase SET	_BANK_SLOT
      2  1c1d				   BANK_aiBeginSelectMovePhase SET	SLOT_aiBeginSelectMovePhase + _CURRENT_BANK
      3  1c1d				   aiBeginSelectMovePhase
      4  1c1d				   TEMPORARY_VAR SET	Overlay
      5  1c1d				   TEMPORARY_OFFSET SET	0
      6  1c1d				   VAR_BOUNDARY_aiBeginSelectMovePhase SET	TEMPORARY_OFFSET
      7  1c1d				   FUNCTION_NAME SET	aiBeginSelectMovePhase
     82  1c1d					      SUBROUTINE
     83  1c1d
      0  1c1d					      REFER	AiStateMachine
      1  1c1d				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c1d				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c1d					      ENDIF
      0  1c1d					      VEND	aiBeginSelectMovePhase
      1  1c1d				  -	      IFNCONST	aiBeginSelectMovePhase
      2  1c1d				  -	      ECHO	"Incorrect VEND label", aiBeginSelectMovePhase
      3  1c1d				  -	      ERR
      4  1c1d					      ENDIF
      5  1c1d		       00 a1	   VAREND_aiBeginSelectMovePhase =	TEMPORARY_VAR
     86  1c1d
     87  1c1d		       a9 02		      lda	#$2
     88  1c1f		       85 46		      sta	COLUP0
     89  1c21		       a2 04		      ldx	#%100
     90  1c23		       86 4a		      stx	CTRLPF	; under
     91  1c25
     92  1c25		       a9 00		      lda	#0
     93  1c27		       85 89		      sta	mdelay	;?
     94  1c29		       85 8e		      sta	aiFlashPhase	; odd/even for flashing pieces
     95  1c2b
     96  1c2b		       a9 28		      lda	#CAP_SPEED*2
     97  1c2d		       85 8c		      sta	aiFlashDelay
     98  1c2f
     99  1c2f		       a9 ff		      lda	#-1
    100  1c31		       85 85		      sta	fromX12
    101  1c33		       85 86		      sta	toX12
    102  1c35
    103  1c35							;lsr randomness
    104  1c35
      0  1c35					      PHASE	AI_FlashComputerMove
      1  1c35		       a9 00		      lda	#AI_FlashComputerMove
      2  1c37		       85 8b		      sta	aiState
    106  1c39		       60		      rts
    107  1c3a
    108  1c3a
    109  1c3a							;---------------------------------------------------------------------------------------------------
    110  1c3a
      0  1c3a					      DEF	aiFlashComputerMove
      1  1c3a				   SLOT_aiFlashComputerMove SET	_BANK_SLOT
      2  1c3a				   BANK_aiFlashComputerMove SET	SLOT_aiFlashComputerMove + _CURRENT_BANK
      3  1c3a				   aiFlashComputerMove
      4  1c3a				   TEMPORARY_VAR SET	Overlay
      5  1c3a				   TEMPORARY_OFFSET SET	0
      6  1c3a				   VAR_BOUNDARY_aiFlashComputerMove SET	TEMPORARY_OFFSET
      7  1c3a				   FUNCTION_NAME SET	aiFlashComputerMove
    112  1c3a					      SUBROUTINE
    113  1c3a
    114  1c3a		       a5 80		      lda	squareToDraw
    115  1c3c		       30 1f		      bmi	.initial	; startup - no computer move to show
    116  1c3e
    117  1c3e							; "squareToDraw" is the piece that should flash while human waits
    118  1c3e
    119  1c3e		       ad 80 02 	      lda	SWCHA
    120  1c41		       29 f0		      and	#$F0
    121  1c43		       c9 f0		      cmp	#$F0
    122  1c45		       f0 08		      beq	.nodir
    123  1c47
    124  1c47		       a9 01		      lda	#1
    125  1c49		       85 8c		      sta	aiFlashDelay
    126  1c4b		       25 8e		      and	aiFlashPhase
    127  1c4d		       f0 0e		      beq	.initial
    128  1c4f
    129  1c4f		       c6 8c	   .nodir     dec	aiFlashDelay
    130  1c51		       d0 0e		      bne	.exit	; don't flash
    131  1c53		       a9 28		      lda	#CAP_SPEED*2
    132  1c55		       85 8c		      sta	aiFlashDelay
    133  1c57
    134  1c57		       e6 8e		      inc	aiFlashPhase
    135  1c59
    136  1c59		       20 a3 f0 	      jsr	CopySinglePiece	;@0
    137  1c5c		       60		      rts
    138  1c5d
      0  1c5d				   .initial   PHASE	AI_SelectStartSquare
      1  1c5d		       a9 02		      lda	#AI_SelectStartSquare
      2  1c5f		       85 8b		      sta	aiState
    140  1c61
    141  1c61		       60	   .exit      rts
    142  1c62
    143  1c62
    144  1c62							;---------------------------------------------------------------------------------------------------
    145  1c62
      0  1c62					      DEF	aiSelectStartSquare
      1  1c62				   SLOT_aiSelectStartSquare SET	_BANK_SLOT
      2  1c62				   BANK_aiSelectStartSquare SET	SLOT_aiSelectStartSquare + _CURRENT_BANK
      3  1c62				   aiSelectStartSquare
      4  1c62				   TEMPORARY_VAR SET	Overlay
      5  1c62				   TEMPORARY_OFFSET SET	0
      6  1c62				   VAR_BOUNDARY_aiSelectStartSquare SET	TEMPORARY_OFFSET
      7  1c62				   FUNCTION_NAME SET	aiSelectStartSquare
    147  1c62					      SUBROUTINE
    148  1c62
      0  1c62					      REFER	AiStateMachine
      1  1c62				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c62				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c62					      ENDIF
      0  1c62					      VEND	aiSelectStartSquare
      1  1c62				  -	      IFNCONST	aiSelectStartSquare
      2  1c62				  -	      ECHO	"Incorrect VEND label", aiSelectStartSquare
      3  1c62				  -	      ERR
      4  1c62					      ENDIF
      5  1c62		       00 a1	   VAREND_aiSelectStartSquare =	TEMPORARY_VAR
    151  1c62
      0  1c62					      NEXT_RANDOM
      1  1c62		       a5 81		      lda	rnd
      2  1c64		       4a		      lsr
      3  1c65		       90 02		      bcc	.skipEOR
      4  1c67		       49 fe		      eor	#RND_EOR_VAL
      5  1c69		       85 81	   .skipEOR   sta	rnd
    153  1c6b
    154  1c6b		       20 2b f6 	      jsr	moveCursor
    155  1c6e
    156  1c6e							; Search the player's movelist for the square, so we can set cursor colour
    157  1c6e
    158  1c6e		       a5 94		      lda	currentPly
    159  1c70		       85 3e		      sta	SET_BANK_RAM	;@2
    160  1c72
    161  1c72		       a5 88		      lda	cursorX12
    162  1c74		       85 85		      sta	fromX12
    163  1c76
      0  1c76					      ldy@PLY	moveIndex
      1  1c76		       ac d0 f9 	      ldy	moveIndex
    165  1c79		       30 0d		      bmi	.done
    166  1c7b
    167  1c7b		       d9 00 f8    .scan      cmp	MoveFrom,y
    168  1c7e		       f0 03		      beq	.scanned
    169  1c80		       88		      dey
    170  1c81		       10 f8		      bpl	.scan
    171  1c83
      0  1c83				   .scanned   lda@PLY	MovePiece,y
      1  1c83		       b9 00 f9 	      lda	MovePiece,y
    173  1c86		       85 96		      sta	fromPiece
    174  1c88
    175  1c88		       c6 8a	   .done      dec	ccur	; pulse colour for valid squares
    176  1c8a		       20 af f4 	      jsr	setCursorColours
    177  1c8d
    178  1c8d		       98		      tya
    179  1c8e		       05 4c		      ora	INPT4
    180  1c90		       30 04		      bmi	.exit	; illegal square or no button press
    181  1c92
      0  1c92					      PHASE	AI_StartSquareSelected
      1  1c92		       a9 03		      lda	#AI_StartSquareSelected
      2  1c94		       85 8b		      sta	aiState
    183  1c96
    184  1c96		       60	   .exit      rts
    185  1c97
    186  1c97							;---------------------------------------------------------------------------------------------------
    187  1c97
      0  1c97					      DEF	setCursorPriority
      1  1c97				   SLOT_setCursorPriority SET	_BANK_SLOT
      2  1c97				   BANK_setCursorPriority SET	SLOT_setCursorPriority + _CURRENT_BANK
      3  1c97				   setCursorPriority
      4  1c97				   TEMPORARY_VAR SET	Overlay
      5  1c97				   TEMPORARY_OFFSET SET	0
      6  1c97				   VAR_BOUNDARY_setCursorPriority SET	TEMPORARY_OFFSET
      7  1c97				   FUNCTION_NAME SET	setCursorPriority
    189  1c97					      SUBROUTINE
    190  1c97
      0  1c97					      REFER	moveCursor
      1  1c97					      IF	VAREND_moveCursor > TEMPORARY_VAR
      2  1c97				   TEMPORARY_VAR SET	VAREND_moveCursor
      3  1c97					      ENDIF
      0  1c97					      VEND	setCursorPriority
      1  1c97				  -	      IFNCONST	setCursorPriority
      2  1c97				  -	      ECHO	"Incorrect VEND label", setCursorPriority
      3  1c97				  -	      ERR
      4  1c97					      ENDIF
      5  1c97		       00 a2	   VAREND_setCursorPriority =	TEMPORARY_VAR
    193  1c97
    194  1c97		       98		      tya
    195  1c98		       48		      pha
    196  1c99
    197  1c99		       a2 04		      ldx	#%100
    198  1c9b
    199  1c9b		       a4 88		      ldy	cursorX12
    200  1c9d		       30 0b		      bmi	.under
    201  1c9f
    202  1c9f		       a9 cf		      lda	#RAMBANK_BOARD
    203  1ca1		       85 3e		      sta	SET_BANK_RAM	;@3
    204  1ca3		       b9 79 fc 	      lda	Board,y
    205  1ca6		       d0 02		      bne	.under
    206  1ca8		       a2 00		      ldx	#0
    207  1caa		       86 4a	   .under     stx	CTRLPF	; UNDER
    208  1cac
    209  1cac		       68		      pla
    210  1cad		       a8		      tay
    211  1cae		       60		      rts
    212  1caf
    213  1caf							;---------------------------------------------------------------------------------------------------
    214  1caf
      0  1caf					      DEF	setCursorColours
      1  1caf				   SLOT_setCursorColours SET	_BANK_SLOT
      2  1caf				   BANK_setCursorColours SET	SLOT_setCursorColours + _CURRENT_BANK
      3  1caf				   setCursorColours
      4  1caf				   TEMPORARY_VAR SET	Overlay
      5  1caf				   TEMPORARY_OFFSET SET	0
      6  1caf				   VAR_BOUNDARY_setCursorColours SET	TEMPORARY_OFFSET
      7  1caf				   FUNCTION_NAME SET	setCursorColours
    216  1caf					      SUBROUTINE
    217  1caf
      0  1caf					      REFER	aiSelectStartSquare
      1  1caf				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  1caf				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  1caf					      ENDIF
      0  1caf					      REFER	aiDrawMoves
      1  1caf				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  1caf				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  1caf					      ENDIF
      0  1caf					      REFER	aiUnDrawTargetSquares
      1  1caf				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  1caf				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  1caf					      ENDIF
      0  1caf					      REFER	aiShowMoveCaptures
      1  1caf				  -	      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  1caf				  -TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  1caf					      ENDIF
      0  1caf					      REFER	aiSlowFlash
      1  1caf				  -	      IF	VAREND_aiSlowFlash > TEMPORARY_VAR
      2  1caf				  -TEMPORARY_VAR SET	VAREND_aiSlowFlash
      3  1caf					      ENDIF
      0  1caf					      REFER	aiSelectDestinationSquare
      1  1caf				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  1caf				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  1caf					      ENDIF
      0  1caf					      VEND	setCursorColours
      1  1caf				  -	      IFNCONST	setCursorColours
      2  1caf				  -	      ECHO	"Incorrect VEND label", setCursorColours
      3  1caf				  -	      ERR
      4  1caf					      ENDIF
      5  1caf		       00 a1	   VAREND_setCursorColours =	TEMPORARY_VAR
    225  1caf
    226  1caf							; pass y=-1 if move is NOT in the movelist
    227  1caf							; preserve y
    228  1caf
    229  1caf		       a9 40		      lda	#$40
    230  1cb1
    231  1cb1		       c0 ff		      cpy	#-1
    232  1cb3		       f0 0a		      beq	.writeCursorCol	; NOT in the movelist
    233  1cb5
    234  1cb5		       a5 8a		      lda	ccur
    235  1cb7		       4a		      lsr
    236  1cb8		       4a		      lsr
    237  1cb9		       4a		      lsr
    238  1cba		       29 03		      and	#3
    239  1cbc		       18		      clc
    240  1cbd		       69 d0		      adc	#$D0	;COLOUR_LINE_1
    241  1cbf
    242  1cbf		       85 46	   .writeCursorCol sta	COLUP0
    243  1cc1		       60		      rts
    244  1cc2
    245  1cc2
    246  1cc2							;---------------------------------------------------------------------------------------------------
    247  1cc2
    248  1cc2							;	    RLDU RLD  RL U RL	R DU R D  R  U R     LDU  LD   L U  L	  DU   D     U
    249  1cc2							;	    0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    250  1cc2
      0  1cc2					      ALLOCATE	JoyCombined, 16
      0  1cc2					      OPTIONAL_PAGEBREAK	"Table", 16
     12  1cc2					      LIST	ON
      0  1cc2					      DEF	JoyCombined
      1  1cc2				   SLOT_JoyCombined SET	_BANK_SLOT
      2  1cc2				   BANK_JoyCombined SET	SLOT_JoyCombined + _CURRENT_BANK
      3  1cc2				   JoyCombined
      4  1cc2				   TEMPORARY_VAR SET	Overlay
      5  1cc2				   TEMPORARY_OFFSET SET	0
      6  1cc2				   VAR_BOUNDARY_JoyCombined SET	TEMPORARY_OFFSET
      7  1cc2				   FUNCTION_NAME SET	JoyCombined
    252  1cc2		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, -1, 0
    253  1cd2
      0  1cd2					      ALLOCATE	JoyMoveCursor, 16
      0  1cd2					      OPTIONAL_PAGEBREAK	"Table", 16
     12  1cd2					      LIST	ON
      0  1cd2					      DEF	JoyMoveCursor
      1  1cd2				   SLOT_JoyMoveCursor SET	_BANK_SLOT
      2  1cd2				   BANK_JoyMoveCursor SET	SLOT_JoyMoveCursor + _CURRENT_BANK
      3  1cd2				   JoyMoveCursor
      4  1cd2				   TEMPORARY_VAR SET	Overlay
      5  1cd2				   TEMPORARY_OFFSET SET	0
      6  1cd2				   VAR_BOUNDARY_JoyMoveCursor SET	TEMPORARY_OFFSET
      7  1cd2				   FUNCTION_NAME SET	JoyMoveCursor
    255  1cd2		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, -9, 11, 1, 0, -11, 9, -1, 0, -10, 10, 0
    256  1ce2
    257  1ce2
    258  1ce2							;---------------------------------------------------------------------------------------------------
    259  1ce2
      0  1ce2					      DEF	aiStartSquareSelected
      1  1ce2				   SLOT_aiStartSquareSelected SET	_BANK_SLOT
      2  1ce2				   BANK_aiStartSquareSelected SET	SLOT_aiStartSquareSelected + _CURRENT_BANK
      3  1ce2				   aiStartSquareSelected
      4  1ce2				   TEMPORARY_VAR SET	Overlay
      5  1ce2				   TEMPORARY_OFFSET SET	0
      6  1ce2				   VAR_BOUNDARY_aiStartSquareSelected SET	TEMPORARY_OFFSET
      7  1ce2				   FUNCTION_NAME SET	aiStartSquareSelected
    261  1ce2					      SUBROUTINE
    262  1ce2
      0  1ce2					      REFER	AiStateMachine
      1  1ce2				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1ce2				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1ce2					      ENDIF
      0  1ce2					      VEND	aiStartSquareSelected
      1  1ce2				  -	      IFNCONST	aiStartSquareSelected
      2  1ce2				  -	      ECHO	"Incorrect VEND label", aiStartSquareSelected
      3  1ce2				  -	      ERR
      4  1ce2					      ENDIF
      5  1ce2		       00 a1	   VAREND_aiStartSquareSelected =	TEMPORARY_VAR
    265  1ce2
    266  1ce2
    267  1ce2							; Mark all the valid moves for the selected piece on the board
    268  1ce2							; and then start pulsing the piece
    269  1ce2							; AND start choosing for selection of TO square
    270  1ce2
    271  1ce2							; Iterate the movelist and for all from squares which = drawPieceNumber
    272  1ce2							; then draw a BLANK at that square
    273  1ce2							; do 1 by one, when none found then increment state
    274  1ce2
    275  1ce2		       a5 88		      lda	cursorX12
    276  1ce4		       85 80		      sta	squareToDraw
    277  1ce6
    278  1ce6		       a9 0a		      lda	#10
    279  1ce8		       85 8c		      sta	aiFlashDelay
    280  1cea
    281  1cea		       a9 00		      lda	#0
    282  1cec		       85 86		      sta	toX12	;aiToSquareX12
    283  1cee		       85 8e		      sta	aiFlashPhase	; for debounce exit timing
    284  1cf0
    285  1cf0		       a9 ff		      lda	#-1
    286  1cf2		       85 8d		      sta	aiMoveIndex
    287  1cf4
    288  1cf4		       a9 28		      lda	#HOLD_DELAY
    289  1cf6		       85 89		      sta	mdelay	; hold-down delay before moves are shown
    290  1cf8
      0  1cf8					      PHASE	AI_DrawMoves
      1  1cf8		       a9 04		      lda	#AI_DrawMoves
      2  1cfa		       85 8b		      sta	aiState
    292  1cfc		       60		      rts
    293  1cfd
    294  1cfd
    295  1cfd							;---------------------------------------------------------------------------------------------------
    296  1cfd
      0  1cfd					      DEF	aiDrawMoves
      1  1cfd				   SLOT_aiDrawMoves SET	_BANK_SLOT
      2  1cfd				   BANK_aiDrawMoves SET	SLOT_aiDrawMoves + _CURRENT_BANK
      3  1cfd				   aiDrawMoves
      4  1cfd				   TEMPORARY_VAR SET	Overlay
      5  1cfd				   TEMPORARY_OFFSET SET	0
      6  1cfd				   VAR_BOUNDARY_aiDrawMoves SET	TEMPORARY_OFFSET
      7  1cfd				   FUNCTION_NAME SET	aiDrawMoves
    298  1cfd					      SUBROUTINE
    299  1cfd
      0  1cfd					      REFER	AiStateMachine
      1  1cfd				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1cfd				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1cfd					      ENDIF
      0  1cfd					      VEND	aiDrawMoves
      1  1cfd				  -	      IFNCONST	aiDrawMoves
      2  1cfd				  -	      ECHO	"Incorrect VEND label", aiDrawMoves
      3  1cfd				  -	      ERR
      4  1cfd					      ENDIF
      5  1cfd		       00 a1	   VAREND_aiDrawMoves =	TEMPORARY_VAR
    302  1cfd
    303  1cfd		       c6 8a		      dec	ccur
    304  1cff		       20 af f4 	      jsr	setCursorColours
    305  1d02
    306  1d02		       c6 89		      dec	mdelay
    307  1d04		       d0 25		      bne	.exit
    308  1d06		       a9 01		      lda	#1	; larger number will slow the draw of available moves
    309  1d08		       85 89		      sta	mdelay	; once triggered, runs always
    310  1d0a
    311  1d0a		       a5 8d		      lda	aiMoveIndex
    312  1d0c		       10 09		      bpl	.valid
    313  1d0e
    314  1d0e		       a9 89		      lda	#RAMBANK_PLY+1
    315  1d10		       85 3e		      sta	SET_BANK_RAM	;@2
      0  1d12					      lda@PLY	moveIndex
      1  1d12		       ad d0 f9 	      lda	moveIndex
    317  1d15		       85 8d		      sta	aiMoveIndex
    318  1d17				   .valid
    319  1d17
    320  1d17		       20 38 f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    321  1d1a		       a5 8d		      lda	aiMoveIndex
    322  1d1c		       10 19		      bpl	.unsure	; still drawing in this phase
    323  1d1e
    324  1d1e		       a9 14		      lda	#CAP_SPEED
    325  1d20		       85 89		      sta	mdelay
    326  1d22
    327  1d22		       a9 00		      lda	#0
    328  1d24		       85 8e		      sta	aiFlashPhase	; controls odd/even exit of flashing
    329  1d26
      0  1d26					      PHASE	AI_ShowMoveCaptures
      1  1d26		       a9 05		      lda	#AI_ShowMoveCaptures
      2  1d28		       85 8b		      sta	aiState
    331  1d2a		       60		      rts
    332  1d2b
    333  1d2b				   .exit
    334  1d2b
    335  1d2b							; Initial piece selection has happened, but the button hasn't been released yet
    336  1d2b							; AND we're still in the waiting phase to see if the button was held long enough for move show
    337  1d2b
    338  1d2b		       a5 4c		      lda	INPT4
    339  1d2d		       10 08		      bpl	.unsure	; button still pressed, so still unsure what to do
    340  1d2f
    341  1d2f							; Aha! Button released, so we know the selected piece and can start flashing it
    342  1d2f							; and allowing movement of the selector to a destination square...
    343  1d2f
    344  1d2f		       a9 18		      lda	#6*4
    345  1d31		       85 8a		      sta	ccur	; bright green square for selection
    346  1d33
      0  1d33					      PHASE	AI_SelectDestinationSquare
      1  1d33		       a9 08		      lda	#AI_SelectDestinationSquare
      2  1d35		       85 8b		      sta	aiState
    348  1d37
    349  1d37		       60	   .unsure    rts
    350  1d38
    351  1d38
    352  1d38							;---------------------------------------------------------------------------------------------------
    353  1d38
      0  1d38					      DEF	showMoveOptions
      1  1d38				   SLOT_showMoveOptions SET	_BANK_SLOT
      2  1d38				   BANK_showMoveOptions SET	SLOT_showMoveOptions + _CURRENT_BANK
      3  1d38				   showMoveOptions
      4  1d38				   TEMPORARY_VAR SET	Overlay
      5  1d38				   TEMPORARY_OFFSET SET	0
      6  1d38				   VAR_BOUNDARY_showMoveOptions SET	TEMPORARY_OFFSET
      7  1d38				   FUNCTION_NAME SET	showMoveOptions
    355  1d38					      SUBROUTINE
    356  1d38
      0  1d38					      REFER	aiDrawMoves
      1  1d38				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  1d38				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  1d38					      ENDIF
      0  1d38					      REFER	aiUnDrawTargetSquares
      1  1d38				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  1d38				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  1d38					      ENDIF
      0  1d38					      VAR	__saveIdx, 1
      1  1d38		       00 a1	   __saveIdx  =	TEMPORARY_VAR
      2  1d38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1d38
      4  1d38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1d38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1d38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1d38					      ENDIF
      8  1d38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1d38				  -	      ECHO	"Temporary Variable", __saveIdx, "overflow!"
     10  1d38				  -	      ERR
     11  1d38					      ENDIF
     12  1d38					      LIST	ON
      0  1d38					      VAR	__piece, 1
      1  1d38		       00 a2	   __piece    =	TEMPORARY_VAR
      2  1d38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1d38
      4  1d38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1d38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1d38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1d38					      ENDIF
      8  1d38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1d38				  -	      ECHO	"Temporary Variable", __piece, "overflow!"
     10  1d38				  -	      ERR
     11  1d38					      ENDIF
     12  1d38					      LIST	ON
      0  1d38					      VEND	showMoveOptions
      1  1d38				  -	      IFNCONST	showMoveOptions
      2  1d38				  -	      ECHO	"Incorrect VEND label", showMoveOptions
      3  1d38				  -	      ERR
      4  1d38					      ENDIF
      5  1d38		       00 a3	   VAREND_showMoveOptions =	TEMPORARY_VAR
    362  1d38
    363  1d38							; place a marker on the board for any square matching the piece
    364  1d38							; EXCEPT for squares which are occupied (we'll flash those later)
    365  1d38
    366  1d38		       a6 8d	   .next      ldx	aiMoveIndex
    367  1d3a		       86 a1		      stx	__saveIdx
    368  1d3c		       30 48		      bmi	.skip
    369  1d3e
    370  1d3e		       ad 84 02 	      lda	INTIM
    371  1d41		       c9 2b		      cmp	#2+SPEEDOF_COPYSINGLEPIECE
    372  1d43		       90 41		      bcc	.skip
    373  1d45
    374  1d45		       c6 8d		      dec	aiMoveIndex
    375  1d47
    376  1d47		       a9 89		      lda	#RAMBANK_PLY+1
    377  1d49		       85 3e		      sta	SET_BANK_RAM	;@2
    378  1d4b
      0  1d4b					      lda@PLY	MoveFrom,x
      1  1d4b		       bd 00 f8 	      lda	MoveFrom,x
    380  1d4e		       c5 85		      cmp	fromX12
    381  1d50		       d0 e6		      bne	.next
    382  1d52
      0  1d52					      lda@PLY	MoveTo,x
      1  1d52		       bd 64 f8 	      lda	MoveTo,x
    384  1d55		       85 80		      sta	squareToDraw
    385  1d57
      0  1d57					      lda@PLY	MovePiece,x
      1  1d57		       bd 00 f9 	      lda	MovePiece,x
    387  1d5a		       85 a2		      sta	__piece
    388  1d5c
    389  1d5c							; If it's a pawn promote (duplicate "to" AND piece different (TODO) then skip others)
    390  1d5c							; TODO this could/will fail on sorted lists. MMh.
    391  1d5c
    392  1d5c		       ca		      dex
    393  1d5d		       30 16		      bmi	.prom
    394  1d5f
      0  1d5f					      lda@PLY	MoveTo,x
      1  1d5f		       bd 64 f8 	      lda	MoveTo,x
    396  1d62		       c5 80		      cmp	squareToDraw
    397  1d64		       d0 0f		      bne	.prom
    398  1d66
      0  1d66					      lda@PLY	MovePiece,x
      1  1d66		       bd 00 f9 	      lda	MovePiece,x
    400  1d69		       45 a2		      eor	__piece
    401  1d6b		       29 0f		      and	#PIECE_MASK
    402  1d6d		       f0 06		      beq	.prom	; same piece type so not a promote
    403  1d6f
    404  1d6f		       c6 8d		      dec	aiMoveIndex
    405  1d71		       c6 8d		      dec	aiMoveIndex
    406  1d73		       c6 8d		      dec	aiMoveIndex
    407  1d75				   .prom
    408  1d75
    409  1d75		       a4 80		      ldy	squareToDraw
    410  1d77
    411  1d77		       a9 cf		      lda	#RAMBANK_BOARD
    412  1d79		       85 3e		      sta	SET_BANK_RAM	;@3
    413  1d7b		       b9 79 fc 	      lda	Board,y
    414  1d7e		       29 0f		      and	#PIECE_MASK
    415  1d80		       d0 b6		      bne	.next	; don't draw dots on captures - they are flashed later
    416  1d82
    417  1d82
    418  1d82							;lda INTIM
    419  1d82							;cmp #SPEEDOF_COPYSINGLEPIECE
    420  1d82							;bcc .skip
    421  1d82
    422  1d82							;lda aiMoveIndex
    423  1d82							;sta __saveIdx
    424  1d82
    425  1d82		       20 8b f5 	      jsr	markerDraw	;@1
    426  1d85		       60		      rts
    427  1d86
    428  1d86		       a5 a1	   .skip      lda	__saveIdx
    429  1d88		       85 8d		      sta	aiMoveIndex
    430  1d8a		       60		      rts
    431  1d8b
    432  1d8b
    433  1d8b							;---------------------------------------------------------------------------------------------------
    434  1d8b
      0  1d8b					      DEF	markerDraw
      1  1d8b				   SLOT_markerDraw SET	_BANK_SLOT
      2  1d8b				   BANK_markerDraw SET	SLOT_markerDraw + _CURRENT_BANK
      3  1d8b				   markerDraw
      4  1d8b				   TEMPORARY_VAR SET	Overlay
      5  1d8b				   TEMPORARY_OFFSET SET	0
      6  1d8b				   VAR_BOUNDARY_markerDraw SET	TEMPORARY_OFFSET
      7  1d8b				   FUNCTION_NAME SET	markerDraw
    436  1d8b					      SUBROUTINE
    437  1d8b
      0  1d8b					      REFER	showMoveOptions
      1  1d8b					      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  1d8b				   TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  1d8b					      ENDIF
      0  1d8b					      VEND	markerDraw
      1  1d8b				  -	      IFNCONST	markerDraw
      2  1d8b				  -	      ECHO	"Incorrect VEND label", markerDraw
      3  1d8b				  -	      ERR
      4  1d8b					      ENDIF
      5  1d8b		       00 a3	   VAREND_markerDraw =	TEMPORARY_VAR
    440  1d8b
    441  1d8b		       a2 1c		      ldx	#INDEX_WHITE_MARKER_on_WHITE_SQUARE_0
    442  1d8d		       20 93 f5 	      jsr	CopySetupForMarker	;@1
    443  1d90		       4c aa f0 	      jmp	InterceptMarkerCopy	;@0
    444  1d93
    445  1d93
    446  1d93							;---------------------------------------------------------------------------------------------------
    447  1d93
      0  1d93					      DEF	CopySetupForMarker
      1  1d93				   SLOT_CopySetupForMarker SET	_BANK_SLOT
      2  1d93				   BANK_CopySetupForMarker SET	SLOT_CopySetupForMarker + _CURRENT_BANK
      3  1d93				   CopySetupForMarker
      4  1d93				   TEMPORARY_VAR SET	Overlay
      5  1d93				   TEMPORARY_OFFSET SET	0
      6  1d93				   VAR_BOUNDARY_CopySetupForMarker SET	TEMPORARY_OFFSET
      7  1d93				   FUNCTION_NAME SET	CopySetupForMarker
    449  1d93					      SUBROUTINE
    450  1d93
      0  1d93					      REFER	markerDraw
      1  1d93					      IF	VAREND_markerDraw > TEMPORARY_VAR
      2  1d93				   TEMPORARY_VAR SET	VAREND_markerDraw
      3  1d93					      ENDIF
      0  1d93					      REFER	showPromoteOptions
      1  1d93				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  1d93				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  1d93					      ENDIF
      0  1d93					      VAR	__pieceColour, 1
      1  1d93		       00 a3	   __pieceColour =	TEMPORARY_VAR
      2  1d93				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1d93
      4  1d93				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1d93				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1d93				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1d93					      ENDIF
      8  1d93				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1d93				  -	      ECHO	"Temporary Variable", __pieceColour, "overflow!"
     10  1d93				  -	      ERR
     11  1d93					      ENDIF
     12  1d93					      LIST	ON
      0  1d93					      VAR	__oddeven, 1
      1  1d93		       00 a4	   __oddeven  =	TEMPORARY_VAR
      2  1d93				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1d93
      4  1d93				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1d93				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1d93				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1d93					      ENDIF
      8  1d93				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1d93				  -	      ECHO	"Temporary Variable", __oddeven, "overflow!"
     10  1d93				  -	      ERR
     11  1d93					      ENDIF
     12  1d93					      LIST	ON
      0  1d93					      VAR	__pmcol, 1
      1  1d93		       00 a5	   __pmcol    =	TEMPORARY_VAR
      2  1d93				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1d93
      4  1d93				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1d93				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1d93				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1d93					      ENDIF
      8  1d93				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1d93				  -	      ECHO	"Temporary Variable", __pmcol, "overflow!"
     10  1d93				  -	      ERR
     11  1d93					      ENDIF
     12  1d93					      LIST	ON
      0  1d93					      VEND	CopySetupForMarker
      1  1d93				  -	      IFNCONST	CopySetupForMarker
      2  1d93				  -	      ECHO	"Incorrect VEND label", CopySetupForMarker
      3  1d93				  -	      ERR
      4  1d93					      ENDIF
      5  1d93		       00 a6	   VAREND_CopySetupForMarker =	TEMPORARY_VAR
    457  1d93
    458  1d93		       a5 80		      lda	squareToDraw
    459  1d95		       38		      sec
    460  1d96		       a0 0a		      ldy	#10
    461  1d98		       e9 0a	   .sub10     sbc	#10
    462  1d9a		       88		      dey
    463  1d9b		       b0 fb		      bcs	.sub10
    464  1d9d		       84 a4		      sty	__oddeven
    465  1d9f		       69 08		      adc	#8
    466  1da1		       85 a5		      sta	__pmcol
    467  1da3		       65 a4		      adc	__oddeven
    468  1da5
    469  1da5		       29 01		      and	#1
    470  1da7		       49 01		      eor	#1
    471  1da9		       f0 02		      beq	.white
    472  1dab		       a9 24		      lda	#36
    473  1dad				   .white
    474  1dad		       85 a3		      sta	__pieceColour	; actually SQUARE black/white
    475  1daf
    476  1daf		       8a		      txa
    477  1db0		       18		      clc
    478  1db1		       65 a3		      adc	__pieceColour
    479  1db3		       85 a3		      sta	__pieceColour
    480  1db5
    481  1db5		       a5 a5		      lda	__pmcol
    482  1db7		       29 03		      and	#3
    483  1db9
    484  1db9		       18		      clc
    485  1dba		       65 a3		      adc	__pieceColour
    486  1dbc		       a8		      tay
    487  1dbd		       60		      rts
    488  1dbe
    489  1dbe
    490  1dbe							;---------------------------------------------------------------------------------------------------
    491  1dbe
      0  1dbe					      DEF	aiUnDrawTargetSquares
      1  1dbe				   SLOT_aiUnDrawTargetSquares SET	_BANK_SLOT
      2  1dbe				   BANK_aiUnDrawTargetSquares SET	SLOT_aiUnDrawTargetSquares + _CURRENT_BANK
      3  1dbe				   aiUnDrawTargetSquares
      4  1dbe				   TEMPORARY_VAR SET	Overlay
      5  1dbe				   TEMPORARY_OFFSET SET	0
      6  1dbe				   VAR_BOUNDARY_aiUnDrawTargetSquares SET	TEMPORARY_OFFSET
      7  1dbe				   FUNCTION_NAME SET	aiUnDrawTargetSquares
    493  1dbe					      SUBROUTINE
    494  1dbe
      0  1dbe					      REFER	AiStateMachine
      1  1dbe				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1dbe				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1dbe					      ENDIF
      0  1dbe					      VEND	aiUnDrawTargetSquares
      1  1dbe				  -	      IFNCONST	aiUnDrawTargetSquares
      2  1dbe				  -	      ECHO	"Incorrect VEND label", aiUnDrawTargetSquares
      3  1dbe				  -	      ERR
      4  1dbe					      ENDIF
      5  1dbe		       00 a1	   VAREND_aiUnDrawTargetSquares =	TEMPORARY_VAR
    497  1dbe
    498  1dbe
    499  1dbe		       c6 8a		      dec	ccur
    500  1dc0		       20 af f4 	      jsr	setCursorColours
    501  1dc3
    502  1dc3		       c6 89		      dec	mdelay
    503  1dc5		       d0 1c		      bne	.exit
    504  1dc7		       a9 01		      lda	#1
    505  1dc9		       85 89		      sta	mdelay	; once triggered, runs always
    506  1dcb
    507  1dcb		       a5 8d		      lda	aiMoveIndex
    508  1dcd		       10 09		      bpl	.valid
    509  1dcf
    510  1dcf		       a9 89		      lda	#RAMBANK_PLY+1
    511  1dd1		       85 3e		      sta	SET_BANK_RAM	;@2
      0  1dd3					      lda@PLY	moveIndex
      1  1dd3		       ad d0 f9 	      lda	moveIndex
    513  1dd6		       85 8d		      sta	aiMoveIndex
    514  1dd8				   .valid
    515  1dd8
    516  1dd8		       20 38 f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    517  1ddb		       a5 8d		      lda	aiMoveIndex
    518  1ddd		       10 04		      bpl	.exit	; still drawing in this phase
    519  1ddf
      0  1ddf					      PHASE	AI_SelectStartSquare
      1  1ddf		       a9 02		      lda	#AI_SelectStartSquare
      2  1de1		       85 8b		      sta	aiState
    521  1de3
    522  1de3		       60	   .exit      rts
    523  1de4
    524  1de4
    525  1de4							;---------------------------------------------------------------------------------------------------
    526  1de4
    527  1de4
      0  1de4					      DEF	aiShowMoveCaptures
      1  1de4				   SLOT_aiShowMoveCaptures SET	_BANK_SLOT
      2  1de4				   BANK_aiShowMoveCaptures SET	SLOT_aiShowMoveCaptures + _CURRENT_BANK
      3  1de4				   aiShowMoveCaptures
      4  1de4				   TEMPORARY_VAR SET	Overlay
      5  1de4				   TEMPORARY_OFFSET SET	0
      6  1de4				   VAR_BOUNDARY_aiShowMoveCaptures SET	TEMPORARY_OFFSET
      7  1de4				   FUNCTION_NAME SET	aiShowMoveCaptures
    529  1de4					      SUBROUTINE
    530  1de4
      0  1de4					      REFER	AiStateMachine
      1  1de4				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1de4				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1de4					      ENDIF
      0  1de4					      VEND	aiShowMoveCaptures
      1  1de4				  -	      IFNCONST	aiShowMoveCaptures
      2  1de4				  -	      ECHO	"Incorrect VEND label", aiShowMoveCaptures
      3  1de4				  -	      ERR
      4  1de4					      ENDIF
      5  1de4		       00 a1	   VAREND_aiShowMoveCaptures =	TEMPORARY_VAR
    533  1de4
    534  1de4							; draw/undraw ALL captured pieces
    535  1de4							; we should do this an even number of times so that pieces don't disappEOR
    536  1de4
    537  1de4		       c6 8a		      dec	ccur
    538  1de6		       20 af f4 	      jsr	setCursorColours
    539  1de9
    540  1de9		       c6 89		      dec	mdelay	; flash speed UNVARYING despite draw happening
    541  1deb
    542  1deb		       a5 8d		      lda	aiMoveIndex
    543  1ded		       10 09		      bpl	.valid	; guaranteed -1 on 1st call
    544  1def		       a9 89		      lda	#RAMBANK_PLY+1
    545  1df1		       85 3e		      sta	SET_BANK_RAM	;@2
      0  1df3					      lda@PLY	moveIndex
      1  1df3		       ad d0 f9 	      lda	moveIndex
    547  1df6		       85 8d		      sta	aiMoveIndex
    548  1df8				   .valid
    549  1df8
    550  1df8							;lda #BANK_showMoveCaptures
    551  1df8							;sta SET_BANK;@0
    552  1df8
    553  1df8		       20 7d f2 	      jsr	showMoveCaptures	;@0
    554  1dfb		       a5 8d		      lda	aiMoveIndex
    555  1dfd		       10 06		      bpl	.exit
    556  1dff
    557  1dff		       e6 8e		      inc	aiFlashPhase
    558  1e01
      0  1e01					      PHASE	AI_SlowFlash
      1  1e01		       a9 06		      lda	#AI_SlowFlash
      2  1e03		       85 8b		      sta	aiState
    560  1e05
    561  1e05		       60	   .exit      rts
    562  1e06
    563  1e06
    564  1e06							;---------------------------------------------------------------------------------------------------
    565  1e06
      0  1e06					      DEF	aiSlowFlash
      1  1e06				   SLOT_aiSlowFlash SET	_BANK_SLOT
      2  1e06				   BANK_aiSlowFlash SET	SLOT_aiSlowFlash + _CURRENT_BANK
      3  1e06				   aiSlowFlash
      4  1e06				   TEMPORARY_VAR SET	Overlay
      5  1e06				   TEMPORARY_OFFSET SET	0
      6  1e06				   VAR_BOUNDARY_aiSlowFlash SET	TEMPORARY_OFFSET
      7  1e06				   FUNCTION_NAME SET	aiSlowFlash
    567  1e06					      SUBROUTINE
    568  1e06
      0  1e06					      REFER	AiStateMachine
      1  1e06				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1e06				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1e06					      ENDIF
      0  1e06					      VEND	aiSlowFlash
      1  1e06				  -	      IFNCONST	aiSlowFlash
      2  1e06				  -	      ECHO	"Incorrect VEND label", aiSlowFlash
      3  1e06				  -	      ERR
      4  1e06					      ENDIF
      5  1e06		       00 a1	   VAREND_aiSlowFlash =	TEMPORARY_VAR
    571  1e06
    572  1e06							; Joystick button is held down, so we're displaying the available moves
    573  1e06							; They have all been drawn, so now we "slow" flash any pieces that can be captures
    574  1e06
    575  1e06		       c6 8a		      dec	ccur
    576  1e08		       20 af f4 	      jsr	setCursorColours
    577  1e0b
    578  1e0b		       a5 8e		      lda	aiFlashPhase
    579  1e0d		       29 01		      and	#1
    580  1e0f		       d0 04		      bne	.notEven	; only exit after even # EOR-draws
    581  1e11
    582  1e11		       a5 4c		      lda	INPT4
    583  1e13		       30 0d		      bmi	.butpress	; exit on button release
    584  1e15
    585  1e15				   .notEven
    586  1e15
    587  1e15							; Wait for delay to expire then back and flash 'em again
    588  1e15
    589  1e15		       c6 89		      dec	mdelay
    590  1e17		       10 08		      bpl	.slowWait
    591  1e19
    592  1e19		       a9 14		      lda	#CAP_SPEED
    593  1e1b		       85 89		      sta	mdelay
    594  1e1d
      0  1e1d					      PHASE	AI_ShowMoveCaptures	; go back and rEORdraw all captures again
      1  1e1d		       a9 05		      lda	#AI_ShowMoveCaptures
      2  1e1f		       85 8b		      sta	aiState
    596  1e21
    597  1e21		       60	   .slowWait  rts
    598  1e22
    599  1e22
    600  1e22		       a9 01	   .butpress  lda	#1
    601  1e24		       85 89		      sta	mdelay
    602  1e26
      0  1e26					      PHASE	AI_UnDrawTargetSquares
      1  1e26		       a9 07		      lda	#AI_UnDrawTargetSquares
      2  1e28		       85 8b		      sta	aiState
    604  1e2a		       60		      rts
    605  1e2b
    606  1e2b
    607  1e2b							;---------------------------------------------------------------------------------------------------
    608  1e2b
      0  1e2b					      DEF	moveCursor
      1  1e2b				   SLOT_moveCursor SET	_BANK_SLOT
      2  1e2b				   BANK_moveCursor SET	SLOT_moveCursor + _CURRENT_BANK
      3  1e2b				   moveCursor
      4  1e2b				   TEMPORARY_VAR SET	Overlay
      5  1e2b				   TEMPORARY_OFFSET SET	0
      6  1e2b				   VAR_BOUNDARY_moveCursor SET	TEMPORARY_OFFSET
      7  1e2b				   FUNCTION_NAME SET	moveCursor
    610  1e2b					      SUBROUTINE
    611  1e2b
      0  1e2b					      REFER	aiSelectStartSquare
      1  1e2b				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  1e2b				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  1e2b					      ENDIF
      0  1e2b					      REFER	aiSelectDestinationSquare
      1  1e2b				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  1e2b				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  1e2b					      ENDIF
      0  1e2b					      VAR	__newCursor, 1
      1  1e2b		       00 a1	   __newCursor =	TEMPORARY_VAR
      2  1e2b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1e2b
      4  1e2b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1e2b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1e2b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1e2b					      ENDIF
      8  1e2b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1e2b				  -	      ECHO	"Temporary Variable", __newCursor, "overflow!"
     10  1e2b				  -	      ERR
     11  1e2b					      ENDIF
     12  1e2b					      LIST	ON
      0  1e2b					      VEND	moveCursor
      1  1e2b				  -	      IFNCONST	moveCursor
      2  1e2b				  -	      ECHO	"Incorrect VEND label", moveCursor
      3  1e2b				  -	      ERR
      4  1e2b					      ENDIF
      5  1e2b		       00 a2	   VAREND_moveCursor =	TEMPORARY_VAR
    616  1e2b
    617  1e2b							; Part (a) move cursor around the board waiting for joystick press
    618  1e2b
    619  1e2b		       a2 00		      ldx	#0	; delay
    620  1e2d
    621  1e2d		       ad 80 02 	      lda	SWCHA
    622  1e30		       4a		      lsr
    623  1e31		       4a		      lsr
    624  1e32		       4a		      lsr
    625  1e33		       4a		      lsr
    626  1e34		       a8		      tay
    627  1e35
    628  1e35		       c9 0f		      cmp	#15
    629  1e37		       f0 1e		      beq	.cursor	; nothing pressed - skip delays
    630  1e39
    631  1e39		       c6 89		      dec	mdelay
    632  1e3b		       10 1f		      bpl	.delaym
    633  1e3d
    634  1e3d		       18		      clc
    635  1e3e		       a5 88		      lda	cursorX12
    636  1e40		       79 d2 f4 	      adc	JoyMoveCursor,y
    637  1e43		       85 a1		      sta	__newCursor
    638  1e45		       a8		      tay
    639  1e46
    640  1e46		       a9 cf		      lda	#RAMBANK_BOARD
    641  1e48		       85 3e		      sta	SET_BANK_RAM	;@3
    642  1e4a		       b9 15 fc 	      lda	ValidSquare,y
    643  1e4d		       c9 ff		      cmp	#-1
    644  1e4f		       f0 04		      beq	.invalid
    645  1e51		       a5 a1		      lda	__newCursor
    646  1e53		       85 88		      sta	cursorX12
    647  1e55				   .invalid
    648  1e55
    649  1e55		       a2 10		      ldx	#CURSOR_MOVE_SPEED
    650  1e57		       86 89	   .cursor    stx	mdelay
    651  1e59		       20 97 f4 	      jsr	setCursorPriority
    652  1e5c		       60	   .delaym    rts
    653  1e5d
    654  1e5d
    655  1e5d							;---------------------------------------------------------------------------------------------------
    656  1e5d
      0  1e5d					      DEF	aiSelectDestinationSquare
      1  1e5d				   SLOT_aiSelectDestinationSquare SET	_BANK_SLOT
      2  1e5d				   BANK_aiSelectDestinationSquare SET	SLOT_aiSelectDestinationSquare + _CURRENT_BANK
      3  1e5d				   aiSelectDestinationSquare
      4  1e5d				   TEMPORARY_VAR SET	Overlay
      5  1e5d				   TEMPORARY_OFFSET SET	0
      6  1e5d				   VAR_BOUNDARY_aiSelectDestinationSquare SET	TEMPORARY_OFFSET
      7  1e5d				   FUNCTION_NAME SET	aiSelectDestinationSquare
    658  1e5d					      SUBROUTINE
    659  1e5d
      0  1e5d					      REFER	AiStateMachine
      1  1e5d				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1e5d				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1e5d					      ENDIF
      0  1e5d					      VEND	aiSelectDestinationSquare
      1  1e5d				  -	      IFNCONST	aiSelectDestinationSquare
      2  1e5d				  -	      ECHO	"Incorrect VEND label", aiSelectDestinationSquare
      3  1e5d				  -	      ERR
      4  1e5d					      ENDIF
      5  1e5d		       00 a1	   VAREND_aiSelectDestinationSquare =	TEMPORARY_VAR
    662  1e5d
    663  1e5d							; Piece is selected and now we're looking for a button press on a destination square
    664  1e5d							; we flash the piece on-and-off while we're doing that
    665  1e5d							; Flash the selected piece
    666  1e5d
    667  1e5d		       ad 84 02 	      lda	INTIM
    668  1e60		       c9 28		      cmp	#ONCEPERFRAME
    669  1e62		       90 0e		      bcc	.exit
    670  1e64
    671  1e64
    672  1e64		       c6 8c		      dec	aiFlashDelay
    673  1e66		       d0 0a		      bne	.exit	; don't flash
    674  1e68		       a9 14		      lda	#CAP_SPEED
    675  1e6a		       85 8c		      sta	aiFlashDelay
    676  1e6c
    677  1e6c		       e6 8e		      inc	aiFlashPhase
    678  1e6e
    679  1e6e		       20 a3 f0 	      jsr	CopySinglePiece	;@0
    680  1e71		       60		      rts
    681  1e72
    682  1e72				   .exit
    683  1e72		       20 2b f6 	      jsr	moveCursor
    684  1e75
    685  1e75		       ad 84 02 	      lda	INTIM
    686  1e78		       c9 14		      cmp	#20
    687  1e7a		       90 39		      bcc	.noButton
    688  1e7c
    689  1e7c
    690  1e7c		       a4 88		      ldy	cursorX12
    691  1e7e		       84 86		      sty	toX12
    692  1e80
      0  1e80					      CALL	GetPiece	;@3
      1  1e80				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  1e80				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1e80				  -	      ECHO	"Cannot switch bank in use for", GetPiece
      4  1e80				  -	      ERR
      5  1e80					      ENDIF
      6  1e80		       a9 df		      lda	#BANK_GetPiece
      7  1e82		       85 3f		      sta	SET_BANK
      8  1e84		       20 00 fc 	      jsr	GetPiece
    694  1e87		       20 af f4 	      jsr	setCursorColours
    695  1e8a
    696  1e8a
    697  1e8a							; y = valid square
    698  1e8a
    699  1e8a		       a5 4c		      lda	INPT4
    700  1e8c		       30 27		      bmi	.noButton
    701  1e8e
    702  1e8e		       a5 86		      lda	toX12
    703  1e90		       c5 85		      cmp	fromX12
    704  1e92		       f0 0d		      beq	.cancel
    705  1e94
    706  1e94		       c0 ff		      cpy	#-1
    707  1e96		       f0 1d		      beq	.noButton	; not a valid square
    708  1e98
    709  1e98		       a5 8e		      lda	aiFlashPhase
    710  1e9a		       29 01		      and	#1
    711  1e9c		       f0 13		      beq	.done
    712  1e9e		       85 8c		      sta	aiFlashDelay	; EOR-phase incorrect - force quick fix to allow next-frame button detect
    713  1ea0		       60		      rts
    714  1ea1
    715  1ea1				   .cancel
    716  1ea1
    717  1ea1		       a5 8e		      lda	aiFlashPhase
    718  1ea3		       29 01		      and	#1
    719  1ea5		       f0 05		      beq	.doCancel
    720  1ea7
    721  1ea7							; EOR-phase incorrect - force quick fix to allow next-frame button detect
    722  1ea7
    723  1ea7		       a9 01		      lda	#1
    724  1ea9		       85 8c		      sta	aiFlashDelay
    725  1eab		       60		      rts
    726  1eac
    727  1eac
      0  1eac				   .doCancel  PHASE	AI_ReselectDebounce
      1  1eac		       a9 0a		      lda	#AI_ReselectDebounce
      2  1eae		       85 8b		      sta	aiState
    729  1eb0		       60		      rts
    730  1eb1
      0  1eb1				   .done      PHASE	AI_Quiescent	; destination selected!
      1  1eb1		       a9 09		      lda	#AI_Quiescent
      2  1eb3		       85 8b		      sta	aiState
    732  1eb5		       60	   .noButton  rts
    733  1eb6
    734  1eb6
    735  1eb6
    736  1eb6
    737  1eb6							;---------------------------------------------------------------------------------------------------
    738  1eb6
      0  1eb6					      DEF	aiReselectDebounce
      1  1eb6				   SLOT_aiReselectDebounce SET	_BANK_SLOT
      2  1eb6				   BANK_aiReselectDebounce SET	SLOT_aiReselectDebounce + _CURRENT_BANK
      3  1eb6				   aiReselectDebounce
      4  1eb6				   TEMPORARY_VAR SET	Overlay
      5  1eb6				   TEMPORARY_OFFSET SET	0
      6  1eb6				   VAR_BOUNDARY_aiReselectDebounce SET	TEMPORARY_OFFSET
      7  1eb6				   FUNCTION_NAME SET	aiReselectDebounce
    740  1eb6					      SUBROUTINE
    741  1eb6
      0  1eb6					      REFER	AiStateMachine
      1  1eb6				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1eb6				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1eb6					      ENDIF
      0  1eb6					      VEND	aiReselectDebounce
      1  1eb6				  -	      IFNCONST	aiReselectDebounce
      2  1eb6				  -	      ECHO	"Incorrect VEND label", aiReselectDebounce
      3  1eb6				  -	      ERR
      4  1eb6					      ENDIF
      5  1eb6		       00 a1	   VAREND_aiReselectDebounce =	TEMPORARY_VAR
    744  1eb6
    745  1eb6							; We've just cancelled the move. Wait for the button to be released
    746  1eb6							; and then go back to selecting a piece to move
    747  1eb6
    748  1eb6		       a5 4c		      lda	INPT4
    749  1eb8		       10 04		      bpl	.exit	; button still pressed, so wait
    750  1eba
      0  1eba					      PHASE	AI_SelectStartSquare
      1  1eba		       a9 02		      lda	#AI_SelectStartSquare
      2  1ebc		       85 8b		      sta	aiState
    752  1ebe		       60	   .exit      rts
    753  1ebf
    754  1ebf
    755  1ebf							;---------------------------------------------------------------------------------------------------
    756  1ebf
      0  1ebf					      DEF	aiQuiescent
      1  1ebf				   SLOT_aiQuiescent SET	_BANK_SLOT
      2  1ebf				   BANK_aiQuiescent SET	SLOT_aiQuiescent + _CURRENT_BANK
      3  1ebf				   aiQuiescent
      4  1ebf				   TEMPORARY_VAR SET	Overlay
      5  1ebf				   TEMPORARY_OFFSET SET	0
      6  1ebf				   VAR_BOUNDARY_aiQuiescent SET	TEMPORARY_OFFSET
      7  1ebf				   FUNCTION_NAME SET	aiQuiescent
    758  1ebf					      SUBROUTINE
    759  1ebf
      0  1ebf					      REFER	AiStateMachine
      1  1ebf				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1ebf				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1ebf					      ENDIF
      0  1ebf					      VEND	aiQuiescent
      1  1ebf				  -	      IFNCONST	aiQuiescent
      2  1ebf				  -	      ECHO	"Incorrect VEND label", aiQuiescent
      3  1ebf				  -	      ERR
      4  1ebf					      ENDIF
      5  1ebf		       00 a1	   VAREND_aiQuiescent =	TEMPORARY_VAR
    762  1ebf
    763  1ebf							; Move has been selected
    764  1ebf
    765  1ebf		       a9 ff		      lda	#-1
    766  1ec1		       85 88		      sta	cursorX12
    767  1ec3
    768  1ec3		       a5 85		      lda	fromX12
    769  1ec5		       85 87		      sta	originX12
      0  1ec7					      CALL	GetPiece	;@3		    ; from the movelist
      1  1ec7				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  1ec7				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1ec7				  -	      ECHO	"Cannot switch bank in use for", GetPiece
      4  1ec7				  -	      ERR
      5  1ec7					      ENDIF
      6  1ec7		       a9 df		      lda	#BANK_GetPiece
      7  1ec9		       85 3f		      sta	SET_BANK
      8  1ecb		       20 00 fc 	      jsr	GetPiece
    771  1ece
    772  1ece		       a4 85		      ldy	fromX12
    773  1ed0		       a9 cf		      lda	#RAMBANK_BOARD
    774  1ed2		       85 3e		      sta	SET_BANK_RAM	;@3
    775  1ed4		       b9 79 fc 	      lda	Board,y
    776  1ed7		       45 96		      eor	fromPiece
    777  1ed9		       29 0f		      and	#PIECE_MASK	; if not the same piece board/movelist...
    778  1edb		       d0 05		      bne	.promote	; promote a pawn
    779  1edd
      0  1edd					      PHASE	AI_MoveIsSelected
      1  1edd		       a9 14		      lda	#AI_MoveIsSelected
      2  1edf		       85 8b		      sta	aiState
    781  1ee1		       60		      rts
    782  1ee2
      0  1ee2				   .promote   PHASE	AI_PromotePawnStart
      1  1ee2		       a9 1f		      lda	#AI_PromotePawnStart
      2  1ee4		       85 8b		      sta	aiState
    784  1ee6		       60		      rts
    785  1ee7
    786  1ee7
    787  1ee7							;---------------------------------------------------------------------------------------------------
    788  1ee7
      0  1ee7					      DEF	aiRollPromotionPiece
      1  1ee7				   SLOT_aiRollPromotionPiece SET	_BANK_SLOT
      2  1ee7				   BANK_aiRollPromotionPiece SET	SLOT_aiRollPromotionPiece + _CURRENT_BANK
      3  1ee7				   aiRollPromotionPiece
      4  1ee7				   TEMPORARY_VAR SET	Overlay
      5  1ee7				   TEMPORARY_OFFSET SET	0
      6  1ee7				   VAR_BOUNDARY_aiRollPromotionPiece SET	TEMPORARY_OFFSET
      7  1ee7				   FUNCTION_NAME SET	aiRollPromotionPiece
    790  1ee7					      SUBROUTINE
    791  1ee7
      0  1ee7					      REFER	AiStateMachine
      1  1ee7				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1ee7				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1ee7					      ENDIF
      0  1ee7					      VEND	aiRollPromotionPiece
      1  1ee7				  -	      IFNCONST	aiRollPromotionPiece
      2  1ee7				  -	      ECHO	"Incorrect VEND label", aiRollPromotionPiece
      3  1ee7				  -	      ERR
      4  1ee7					      ENDIF
      5  1ee7		       00 a1	   VAREND_aiRollPromotionPiece =	TEMPORARY_VAR
    794  1ee7
    795  1ee7							; Flash the '?' and wait for an UDLR move
    796  1ee7
    797  1ee7		       ad 84 02 	      lda	INTIM
    798  1eea		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    799  1eec		       90 28		      bcc	.exit
    800  1eee
    801  1eee		       ad 80 02 	      lda	SWCHA
    802  1ef1		       29 f0		      and	#$F0
    803  1ef3		       c9 f0		      cmp	#$F0
    804  1ef5		       f0 0a		      beq	.nojoy
    805  1ef7
    806  1ef7		       a9 00		      lda	#0
    807  1ef9		       85 8c		      sta	aiFlashDelay
    808  1efb
    809  1efb		       a5 8e		      lda	aiFlashPhase
    810  1efd		       29 01		      and	#1
    811  1eff		       f0 16		      beq	.even
    812  1f01
    813  1f01		       c6 8c	   .nojoy     dec	aiFlashDelay
    814  1f03		       10 11		      bpl	.exit
    815  1f05
    816  1f05		       a9 0a		      lda	#10
    817  1f07		       85 8c		      sta	aiFlashDelay
    818  1f09
    819  1f09		       a2 20		      ldx	#INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0
    820  1f0b		       a5 95		      lda	sideToMove
    821  1f0d		       10 02		      bpl	.wtm
    822  1f0f		       a2 68		      ldx	#INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0
    823  1f11				   .wtm
    824  1f11		       20 00 f4 	      jsr	showPromoteOptions
    825  1f14
    826  1f14		       e6 8e		      inc	aiFlashPhase
    827  1f16
    828  1f16		       60	   .exit      rts
    829  1f17
    830  1f17
    831  1f17		       a9 03	   .even      lda	#3	; QUEEN
    832  1f19		       85 96		      sta	fromPiece	; cycles as index to NBRQ
    833  1f1b
    834  1f1b		       e6 8e		      inc	aiFlashPhase
    835  1f1d
    836  1f1d
    837  1f1d		       a2 14		      ldx	#INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0	;TODO: fix for colour
    838  1f1f		       a5 95		      lda	sideToMove
    839  1f21		       10 02		      bpl	.whiteToMove
    840  1f23		       a2 5c		      ldx	#INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    841  1f25				   .whiteToMove
    842  1f25
    843  1f25		       20 00 f4 	      jsr	showPromoteOptions
    844  1f28
      0  1f28					      PHASE	AI_ChooseDebounce
      1  1f28		       a9 22		      lda	#AI_ChooseDebounce
      2  1f2a		       85 8b		      sta	aiState
    846  1f2c		       60		      rts
    847  1f2d
    848  1f2d
    849  1f2d
    850  1f2d							;---------------------------------------------------------------------------------------------------
    851  1f2d
      0  1f2d					      DEF	aiMarchA2
      1  1f2d				   SLOT_aiMarchA2 SET	_BANK_SLOT
      2  1f2d				   BANK_aiMarchA2 SET	SLOT_aiMarchA2 + _CURRENT_BANK
      3  1f2d				   aiMarchA2
      4  1f2d				   TEMPORARY_VAR SET	Overlay
      5  1f2d				   TEMPORARY_OFFSET SET	0
      6  1f2d				   VAR_BOUNDARY_aiMarchA2 SET	TEMPORARY_OFFSET
      7  1f2d				   FUNCTION_NAME SET	aiMarchA2
    853  1f2d					      SUBROUTINE
    854  1f2d
    855  1f2d
    856  1f2d							; erase object in new sqare --> blank
    857  1f2d
    858  1f2d		       a4 85		      ldy	fromX12
    859  1f2f		       84 80		      sty	squareToDraw
    860  1f31
    861  1f31		       a9 cf		      lda	#RAMBANK_BOARD
    862  1f33		       85 3e		      sta	SET_BANK_RAM	;@3
    863  1f35		       b9 79 fc 	      lda	Board,y
    864  1f38		       f0 03		      beq	.skipbl
    865  1f3a		       20 a3 f0 	      jsr	CopySinglePiece	;@0	      ; erase next square along --> blank
    866  1f3d
    867  1f3d				   .skipbl
    868  1f3d		       a4 85		      ldy	fromX12
    869  1f3f		       84 a2		      sty	__boardIndex
    870  1f41
    871  1f41		       a9 cf		      lda	#RAMBANK_BOARD
    872  1f43		       85 3e		      sta	SET_BANK_RAM	;@3
    873  1f45		       b9 79 fc 	      lda	Board,y
    874  1f48		       85 97		      sta	lastPiece	; what we are overwriting
    875  1f4a		       a5 96		      lda	fromPiece
    876  1f4c		       09 40		      ora	#FLAG_MOVED	; prevents usage in castling for K/R
    877  1f4e		       29 df		      and	#~FLAG_ENPASSANT
    878  1f50		       a4 a2		      ldy	__boardIndex
      0  1f52					      sta@RAM	Board,y	; and what's actually moving there
      1  1f52		       99 79 fe 	      sta	[RAM]+Board,y
    880  1f55
    881  1f55
      0  1f55					      PHASE	AI_MarchB
      1  1f55		       a9 18		      lda	#AI_MarchB
      2  1f57		       85 8b		      sta	aiState
    883  1f59		       60		      rts
    884  1f5a
    885  1f5a
    886  1f5a							;---------------------------------------------------------------------------------------------------
    887  1f5a
      0  1f5a					      DEF	aiMarchB2
      1  1f5a				   SLOT_aiMarchB2 SET	_BANK_SLOT
      2  1f5a				   BANK_aiMarchB2 SET	SLOT_aiMarchB2 + _CURRENT_BANK
      3  1f5a				   aiMarchB2
      4  1f5a				   TEMPORARY_VAR SET	Overlay
      5  1f5a				   TEMPORARY_OFFSET SET	0
      6  1f5a				   VAR_BOUNDARY_aiMarchB2 SET	TEMPORARY_OFFSET
      7  1f5a				   FUNCTION_NAME SET	aiMarchB2
    889  1f5a					      SUBROUTINE
    890  1f5a
      0  1f5a					      REFER	AiStateMachine
      1  1f5a				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1f5a				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1f5a					      ENDIF
      0  1f5a					      VEND	aiMarchB2
      1  1f5a				  -	      IFNCONST	aiMarchB2
      2  1f5a				  -	      ECHO	"Incorrect VEND label", aiMarchB2
      3  1f5a				  -	      ERR
      4  1f5a					      ENDIF
      5  1f5a		       00 a1	   VAREND_aiMarchB2 =	TEMPORARY_VAR
    893  1f5a
    894  1f5a		       a4 83		      ldy	lastSquareX12
    895  1f5c		       84 80		      sty	squareToDraw
    896  1f5e
    897  1f5e		       a9 cf		      lda	#RAMBANK_BOARD
    898  1f60		       85 3e		      sta	SET_BANK_RAM	;@3
    899  1f62		       b9 79 fc 	      lda	Board,y
    900  1f65		       f0 03		      beq	.skipbl2
    901  1f67
    902  1f67		       20 a3 f0 	      jsr	CopySinglePiece	;@0	      ; draw previous piece back in old position
    903  1f6a				   .skipbl2
    904  1f6a
    905  1f6a		       a5 85		      lda	fromX12
    906  1f6c		       c5 86		      cmp	toX12
    907  1f6e		       f0 09		      beq	xhalt
    908  1f70
    909  1f70		       a9 64		      lda	#100	;??? inter-move segment speed (can be 0)
    910  1f72		       85 82		      sta	drawDelay
      0  1f74					      PHASE	AI_MarchToTargetA
      1  1f74		       a9 16		      lda	#AI_MarchToTargetA
      2  1f76		       85 8b		      sta	aiState
    912  1f78
    913  1f78		       60		      rts
    914  1f79
    915  1f79				   xhalt
    916  1f79
    917  1f79							;??? jsr FinaliseMove
    918  1f79
    919  1f79		       a9 04		      lda	#4	; on/off count
    920  1f7b		       85 84		      sta	drawCount	; flashing for piece about to move
    921  1f7d		       a9 00		      lda	#0
    922  1f7f		       85 82		      sta	drawDelay
    923  1f81
      0  1f81					      PHASE	AI_FinalFlash
      1  1f81		       a9 1b		      lda	#AI_FinalFlash
      2  1f83		       85 8b		      sta	aiState
    925  1f85		       60		      rts
    926  1f86
    927  1f86
    928  1f86							;---------------------------------------------------------------------------------------------------
    929  1f86
    930  1f86
      0  1f86					      DEF	aiWriteStartPieceBlank
      1  1f86				   SLOT_aiWriteStartPieceBlank SET	_BANK_SLOT
      2  1f86				   BANK_aiWriteStartPieceBlank SET	SLOT_aiWriteStartPieceBlank + _CURRENT_BANK
      3  1f86				   aiWriteStartPieceBlank
      4  1f86				   TEMPORARY_VAR SET	Overlay
      5  1f86				   TEMPORARY_OFFSET SET	0
      6  1f86				   VAR_BOUNDARY_aiWriteStartPieceBlank SET	TEMPORARY_OFFSET
      7  1f86				   FUNCTION_NAME SET	aiWriteStartPieceBlank
    932  1f86					      SUBROUTINE
    933  1f86
      0  1f86					      REFER	AiStateMachine
      1  1f86				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1f86				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1f86					      ENDIF
      0  1f86					      VEND	aiWriteStartPieceBlank
      1  1f86				  -	      IFNCONST	aiWriteStartPieceBlank
      2  1f86				  -	      ECHO	"Incorrect VEND label", aiWriteStartPieceBlank
      3  1f86				  -	      ERR
      4  1f86					      ENDIF
      5  1f86		       00 a1	   VAREND_aiWriteStartPieceBlank =	TEMPORARY_VAR
    936  1f86
    937  1f86							; Flash the piece in-place preparatory to moving it.
    938  1f86							; drawDelay = flash speed
    939  1f86							; drawCount = # of flashes
    940  1f86
    941  1f86		       a5 87		      lda	originX12
    942  1f88		       85 88		      sta	cursorX12
    943  1f8a
    944  1f8a		       a9 04		      lda	#%100
    945  1f8c		       85 4a		      sta	CTRLPF
    946  1f8e		       a9 02		      lda	#2
    947  1f90		       85 46		      sta	COLUP0
    948  1f92
    949  1f92
    950  1f92		       a5 82		      lda	drawDelay
    951  1f94		       f0 03		      beq	deCount
    952  1f96		       c6 82		      dec	drawDelay
    953  1f98		       60		      rts
    954  1f99				   deCount
    955  1f99
    956  1f99		       a5 84		      lda	drawCount
    957  1f9b		       f0 0d		      beq	flashDone
    958  1f9d		       c6 84		      dec	drawCount
    959  1f9f
    960  1f9f		       a9 0a		      lda	#READY_TO_MOVE_FLASH
    961  1fa1		       85 82		      sta	drawDelay	; "getting ready to move" flash
    962  1fa3
    963  1fa3		       a5 85		      lda	fromX12
    964  1fa5		       85 80		      sta	squareToDraw
    965  1fa7
    966  1fa7		       4c a3 f0 	      jmp	CopySinglePiece	;@0	      ; EOR-draw = flash
    967  1faa
    968  1faa				   flashDone
    969  1faa
      0  1faa					      PHASE	AI_MarchToTargetA
      1  1faa		       a9 16		      lda	#AI_MarchToTargetA
      2  1fac		       85 8b		      sta	aiState
    971  1fae		       60		      rts
    972  1faf
    973  1faf
    974  1faf							;---------------------------------------------------------------------------------------------------
    975  1faf
      0  1faf					      CHECK_BANK_SIZE	"BANK_StateMachine"
      1  1faf		       03 af	   .TEMP      =	* - _BANK_START
 BANK_StateMachine (1K) SIZE =  $3af , FREE= $51
      2  1faf					      ECHO	"BANK_StateMachine", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1faf				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1faf				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_StateMachine", " size=", * - ORIGIN
      5  1faf				  -	      ERR
      6  1faf					      ENDIF
    977  1faf
    978  1faf
    979  1faf							;---------------------------------------------------------------------------------------------------
    980  1faf
    981  1faf							; EOF
------- FILE ./chess.asm
------- FILE BANK_StateMachine@1#2.asm LEVEL 2 PASS 4
      0  1faf					      include	"BANK_StateMachine@1#2.asm"
      0  1faf					      SLOT	1
      1  1faf				  -	      IF	(1 < 0) || (1 > 3)
      2  1faf				  -	      ECHO	"Illegal bank address/segment location", 1
      3  1faf				  -	      ERR
      4  1faf					      ENDIF
      5  1faf				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  1faf				   _BANK_SLOT SET	1 * 64
      0  1faf					      NEWBANK	STATEMACHINE2
      1  22a9 ????				      SEG	STATEMACHINE2
      2  2000					      ORG	_ORIGIN
      3  2000					      RORG	_BANK_ADDRESS_ORIGIN
      4  2000				   _BANK_START SET	*
      5  2000				   STATEMACHINE2_START SET	*
      6  2000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2000				   STATEMACHINE2 SET	_BANK_SLOT + _CURRENT_BANK
      8  2000				   _ORIGIN    SET	_ORIGIN + 1024
      3  2000
      4  2000							;---------------------------------------------------------------------------------------------------
      5  2000
      0  2000					      DEF	aiChoosePromotePiece
      1  2000				   SLOT_aiChoosePromotePiece SET	_BANK_SLOT
      2  2000				   BANK_aiChoosePromotePiece SET	SLOT_aiChoosePromotePiece + _CURRENT_BANK
      3  2000				   aiChoosePromotePiece
      4  2000				   TEMPORARY_VAR SET	Overlay
      5  2000				   TEMPORARY_OFFSET SET	0
      6  2000				   VAR_BOUNDARY_aiChoosePromotePiece SET	TEMPORARY_OFFSET
      7  2000				   FUNCTION_NAME SET	aiChoosePromotePiece
      7  2000					      SUBROUTINE
      8  2000
      0  2000					      REFER	AiStateMachine
      1  2000				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2000				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2000					      ENDIF
      0  2000					      VEND	aiChoosePromotePiece
      1  2000				  -	      IFNCONST	aiChoosePromotePiece
      2  2000				  -	      ECHO	"Incorrect VEND label", aiChoosePromotePiece
      3  2000				  -	      ERR
      4  2000					      ENDIF
      5  2000		       00 a1	   VAREND_aiChoosePromotePiece =	TEMPORARY_VAR
     11  2000
     12  2000							; Question-mark phase has exited via joystick direction
     13  2000							; Now we cycle through the selectable pieces
     14  2000
     15  2000		       ad 84 02 	      lda	INTIM
     16  2003		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
     17  2005		       90 40		      bcc	.exit
     18  2007
     19  2007		       a5 4c		      lda	INPT4
     20  2009		       30 0a		      bmi	.nobut	; no press
     21  200b
     22  200b							; button pressed but make sure phase is correct for exit
     23  200b
     24  200b		       a9 00		      lda	#0
     25  200d		       85 8c		      sta	aiFlashDelay
     26  200f
     27  200f		       a5 8e		      lda	aiFlashPhase
     28  2011		       29 01		      and	#1
     29  2013		       f0 33		      beq	.chosen	; button pressed --> selection made
     30  2015
     31  2015				   .nobut
     32  2015		       ad 80 02 	      lda	SWCHA
     33  2018		       29 f0		      and	#$F0
     34  201a		       c9 f0		      cmp	#$F0
     35  201c		       f0 17		      beq	.odd	; no direction pressed
     36  201e
     37  201e		       4a		      lsr
     38  201f		       4a		      lsr
     39  2020		       4a		      lsr
     40  2021		       4a		      lsr
     41  2022		       a8		      tay
     42  2023
     43  2023							; joystick but make sure phase is correct
     44  2023
     45  2023		       a5 8e		      lda	aiFlashPhase
     46  2025		       4a		      lsr
     47  2026		       b0 0d		      bcs	.odd	; must wait until piece undrawn
     48  2028
     49  2028							; cycle to the next promotable piece (N/B/R/Q)
     50  2028							; TODO; use joy table for mod instead of just incrementing all the time
     51  2028
     52  2028							;clc
     53  2028		       a5 96		      lda	fromPiece
     54  202a		       79 c2 f4 	      adc	JoyCombined,y
     55  202d		       29 03		      and	#3
     56  202f		       85 96		      sta	fromPiece
     57  2031
      0  2031					      PHASE	AI_ChooseDebounce	; wait for release
      1  2031		       a9 22		      lda	#AI_ChooseDebounce
      2  2033		       85 8b		      sta	aiState
     59  2035
     60  2035		       c6 8c	   .odd       dec	aiFlashDelay
     61  2037		       10 0e		      bpl	.exit
     62  2039
     63  2039		       a9 0a	   .force     lda	#10
     64  203b		       85 8c		      sta	aiFlashDelay
     65  203d
     66  203d		       e6 8e		      inc	aiFlashPhase
     67  203f
     68  203f		       a4 96		      ldy	fromPiece
     69  2041		       be 67 f4 	      ldx	promotePiece,y
     70  2044		       20 00 f4 	      jsr	showPromoteOptions
     71  2047
     72  2047		       60	   .exit      rts
     73  2048
     74  2048
     75  2048				   .chosen
     76  2048		       a5 96		      lda	fromPiece
     77  204a		       29 0f		      and	#PIECE_MASK
     78  204c		       aa		      tax
     79  204d
     80  204d		       bd 6b f4 	      lda	promoteType,x
     81  2050		       85 96		      sta	fromPiece
     82  2052
     83  2052		       a4 86		      ldy	toX12
     84  2054		       a9 cf		      lda	#RAMBANK_BOARD
     85  2056		       85 3e		      sta	SET_BANK_RAM	;@3
     86  2058		       b9 79 fc 	      lda	Board,y
     87  205b		       29 0f		      and	#PIECE_MASK
     88  205d		       f0 03		      beq	.nothing
     89  205f
     90  205f		       20 a3 f0 	      jsr	CopySinglePiece	;@0	      ; put back whatever was there to start
     91  2062
      0  2062				   .nothing   PHASE	AI_MoveIsSelected
      1  2062		       a9 14		      lda	#AI_MoveIsSelected
      2  2064		       85 8b		      sta	aiState
     93  2066		       60		      rts
     94  2067
      0  2067					      ALLOCATE	promotePiece, 4
      0  2067					      OPTIONAL_PAGEBREAK	"Table", 4
     12  2067					      LIST	ON
      0  2067					      DEF	promotePiece
      1  2067				   SLOT_promotePiece SET	_BANK_SLOT
      2  2067				   BANK_promotePiece SET	SLOT_promotePiece + _CURRENT_BANK
      3  2067				   promotePiece
      4  2067				   TEMPORARY_VAR SET	Overlay
      5  2067				   TEMPORARY_OFFSET SET	0
      6  2067				   VAR_BOUNDARY_promotePiece SET	TEMPORARY_OFFSET
      7  2067				   FUNCTION_NAME SET	promotePiece
     96  2067		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
     97  2068		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
     98  2069		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
     99  206a		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    100  206b
      0  206b					      ALLOCATE	promoteType,4
      0  206b					      OPTIONAL_PAGEBREAK	"Table", 4
     12  206b					      LIST	ON
      0  206b					      DEF	promoteType
      1  206b				   SLOT_promoteType SET	_BANK_SLOT
      2  206b				   BANK_promoteType SET	SLOT_promoteType + _CURRENT_BANK
      3  206b				   promoteType
      4  206b				   TEMPORARY_VAR SET	Overlay
      5  206b				   TEMPORARY_OFFSET SET	0
      6  206b				   VAR_BOUNDARY_promoteType SET	TEMPORARY_OFFSET
      7  206b				   FUNCTION_NAME SET	promoteType
    102  206b		       03 04 05 06	      .byte.b	KNIGHT, BISHOP, ROOK, QUEEN
    103  206f
    104  206f
    105  206f							;---------------------------------------------------------------------------------------------------
    106  206f
      0  206f					      DEF	aiChooseDebounce
      1  206f				   SLOT_aiChooseDebounce SET	_BANK_SLOT
      2  206f				   BANK_aiChooseDebounce SET	SLOT_aiChooseDebounce + _CURRENT_BANK
      3  206f				   aiChooseDebounce
      4  206f				   TEMPORARY_VAR SET	Overlay
      5  206f				   TEMPORARY_OFFSET SET	0
      6  206f				   VAR_BOUNDARY_aiChooseDebounce SET	TEMPORARY_OFFSET
      7  206f				   FUNCTION_NAME SET	aiChooseDebounce
    108  206f					      SUBROUTINE
    109  206f
      0  206f					      REFER	AiStateMachine
      1  206f				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  206f				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  206f					      ENDIF
      0  206f					      VEND	aiChooseDebounce
      1  206f				  -	      IFNCONST	aiChooseDebounce
      2  206f				  -	      ECHO	"Incorrect VEND label", aiChooseDebounce
      3  206f				  -	      ERR
      4  206f					      ENDIF
      5  206f		       00 a1	   VAREND_aiChooseDebounce =	TEMPORARY_VAR
    112  206f
    113  206f							; We've changed promotion piece, but wait for joystick to be released
    114  206f
    115  206f		       ad 80 02 	      lda	SWCHA
    116  2072		       29 f0		      and	#$F0
    117  2074		       c9 f0		      cmp	#$F0
    118  2076		       d0 08		      bne	.exit	; wait while joystick still pressed
    119  2078
    120  2078		       a9 01		      lda	#1
    121  207a		       85 8c		      sta	aiFlashDelay
    122  207c
      0  207c					      PHASE	AI_ChoosePromotePiece
      1  207c		       a9 21		      lda	#AI_ChoosePromotePiece
      2  207e		       85 8b		      sta	aiState
    124  2080		       60	   .exit      rts
    125  2081
    126  2081
    127  2081							;---------------------------------------------------------------------------------------------------
    128  2081
      0  2081					      DEF	aiDelayAfterMove
      1  2081				   SLOT_aiDelayAfterMove SET	_BANK_SLOT
      2  2081				   BANK_aiDelayAfterMove SET	SLOT_aiDelayAfterMove + _CURRENT_BANK
      3  2081				   aiDelayAfterMove
      4  2081				   TEMPORARY_VAR SET	Overlay
      5  2081				   TEMPORARY_OFFSET SET	0
      6  2081				   VAR_BOUNDARY_aiDelayAfterMove SET	TEMPORARY_OFFSET
      7  2081				   FUNCTION_NAME SET	aiDelayAfterMove
    130  2081					      SUBROUTINE
    131  2081
      0  2081					      VEND	aiDelayAfterMove
      1  2081				  -	      IFNCONST	aiDelayAfterMove
      2  2081				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  2081				  -	      ERR
      4  2081					      ENDIF
      5  2081		       00 a1	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
    133  2081
    134  2081		       a9 32		      lda	#50
    135  2083		       85 8c		      sta	aiFlashDelay
      0  2085					      PHASE	AI_DelayAfterMove2
      1  2085		       a9 26		      lda	#AI_DelayAfterMove2
      2  2087		       85 8b		      sta	aiState
    137  2089		       60	   .exit      rts
    138  208a
    139  208a
    140  208a							;---------------------------------------------------------------------------------------------------
    141  208a
      0  208a					      DEF	aiDelayAfterMove2
      1  208a				   SLOT_aiDelayAfterMove2 SET	_BANK_SLOT
      2  208a				   BANK_aiDelayAfterMove2 SET	SLOT_aiDelayAfterMove2 + _CURRENT_BANK
      3  208a				   aiDelayAfterMove2
      4  208a				   TEMPORARY_VAR SET	Overlay
      5  208a				   TEMPORARY_OFFSET SET	0
      6  208a				   VAR_BOUNDARY_aiDelayAfterMove2 SET	TEMPORARY_OFFSET
      7  208a				   FUNCTION_NAME SET	aiDelayAfterMove2
    143  208a					      SUBROUTINE
    144  208a
      0  208a					      VEND	aiDelayAfterMove
      1  208a				  -	      IFNCONST	aiDelayAfterMove
      2  208a				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  208a				  -	      ERR
      4  208a					      ENDIF
      5  208a		       00 a1	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
    146  208a
    147  208a		       c6 8c		      dec	aiFlashDelay
    148  208c		       d0 04		      bne	.exit
      0  208e					      PHASE	AI_MoveIsSelected
      1  208e		       a9 14		      lda	#AI_MoveIsSelected
      2  2090		       85 8b		      sta	aiState
    150  2092		       60	   .exit      rts
    151  2093
    152  2093
    153  2093							;---------------------------------------------------------------------------------------------------
    154  2093
      0  2093					      DEF	aiDelayAfterPlaced
      1  2093				   SLOT_aiDelayAfterPlaced SET	_BANK_SLOT
      2  2093				   BANK_aiDelayAfterPlaced SET	SLOT_aiDelayAfterPlaced + _CURRENT_BANK
      3  2093				   aiDelayAfterPlaced
      4  2093				   TEMPORARY_VAR SET	Overlay
      5  2093				   TEMPORARY_OFFSET SET	0
      6  2093				   VAR_BOUNDARY_aiDelayAfterPlaced SET	TEMPORARY_OFFSET
      7  2093				   FUNCTION_NAME SET	aiDelayAfterPlaced
    156  2093					      SUBROUTINE
    157  2093
      0  2093					      VEND	aiDelayAfterPlaced
      1  2093				  -	      IFNCONST	aiDelayAfterPlaced
      2  2093				  -	      ECHO	"Incorrect VEND label", aiDelayAfterPlaced
      3  2093				  -	      ERR
      4  2093					      ENDIF
      5  2093		       00 a1	   VAREND_aiDelayAfterPlaced =	TEMPORARY_VAR
    159  2093
    160  2093		       a2 4b		      ldx	#75	; delay after human move
    161  2095		       a5 95		      lda	sideToMove
    162  2097		       30 02		      bmi	.computer
    163  2099		       a2 01		      ldx	#1	; delay after computer move
    164  209b		       86 8c	   .computer  stx	aiFlashDelay
    165  209d
      0  209d					      PHASE	AI_DelayAfterPlaced2
      1  209d		       a9 28		      lda	#AI_DelayAfterPlaced2
      2  209f		       85 8b		      sta	aiState
    167  20a1		       60		      rts
    168  20a2
    169  20a2
    170  20a2							;---------------------------------------------------------------------------------------------------
    171  20a2
      0  20a2					      DEF	aiDelayAfterPlaced2
      1  20a2				   SLOT_aiDelayAfterPlaced2 SET	_BANK_SLOT
      2  20a2				   BANK_aiDelayAfterPlaced2 SET	SLOT_aiDelayAfterPlaced2 + _CURRENT_BANK
      3  20a2				   aiDelayAfterPlaced2
      4  20a2				   TEMPORARY_VAR SET	Overlay
      5  20a2				   TEMPORARY_OFFSET SET	0
      6  20a2				   VAR_BOUNDARY_aiDelayAfterPlaced2 SET	TEMPORARY_OFFSET
      7  20a2				   FUNCTION_NAME SET	aiDelayAfterPlaced2
    173  20a2					      SUBROUTINE
    174  20a2
    175  20a2							;jsr debug
    176  20a2
    177  20a2		       c6 8c		      dec	aiFlashDelay
    178  20a4		       d0 04		      bne	.exit
      0  20a6					      PHASE	AI_GenerateMoves
      1  20a6		       a9 12		      lda	#AI_GenerateMoves
      2  20a8		       85 8b		      sta	aiState
    180  20aa		       60	   .exit      rts
    181  20ab
    182  20ab
    183  20ab							;---------------------------------------------------------------------------------------------------
    184  20ab
      0  20ab					      DEF	aiMarchToTargetB
      1  20ab				   SLOT_aiMarchToTargetB SET	_BANK_SLOT
      2  20ab				   BANK_aiMarchToTargetB SET	SLOT_aiMarchToTargetB + _CURRENT_BANK
      3  20ab				   aiMarchToTargetB
      4  20ab				   TEMPORARY_VAR SET	Overlay
      5  20ab				   TEMPORARY_OFFSET SET	0
      6  20ab				   VAR_BOUNDARY_aiMarchToTargetB SET	TEMPORARY_OFFSET
      7  20ab				   FUNCTION_NAME SET	aiMarchToTargetB
    186  20ab					      SUBROUTINE
    187  20ab
      0  20ab					      REFER	AiStateMachine
      1  20ab				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  20ab				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  20ab					      ENDIF
      0  20ab					      VEND	aiMarchToTargetB
      1  20ab				  -	      IFNCONST	aiMarchToTargetB
      2  20ab				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetB
      3  20ab				  -	      ERR
      4  20ab					      ENDIF
      5  20ab		       00 a1	   VAREND_aiMarchToTargetB =	TEMPORARY_VAR
    190  20ab
    191  20ab							; now we want to undraw the piece in the old square
    192  20ab
    193  20ab		       a5 83		      lda	lastSquareX12
    194  20ad		       85 80		      sta	squareToDraw
    195  20af
    196  20af		       20 a3 f0 	      jsr	CopySinglePiece	;@0	      ; erase whatever was on the previous square (completely blank)
    197  20b2
    198  20b2		       a4 83		      ldy	lastSquareX12
    199  20b4		       a5 98		      lda	previousPiece
    200  20b6
    201  20b6		       a2 cf		      ldx	#RAMBANK_BOARD
    202  20b8		       86 3e		      stx	SET_BANK_RAM	;@3
      0  20ba					      sta@RAM	Board,y	; and what's actually moving there
      1  20ba		       99 79 fe 	      sta	[RAM]+Board,y
    204  20bd
    205  20bd		       a5 97		      lda	lastPiece
    206  20bf		       85 98		      sta	previousPiece
    207  20c1
      0  20c1					      PHASE	AI_MarchB2
      1  20c1		       a9 1a		      lda	#AI_MarchB2
      2  20c3		       85 8b		      sta	aiState
    209  20c5		       60		      rts
    210  20c6
    211  20c6
    212  20c6							;---------------------------------------------------------------------------------------------------
    213  20c6
      0  20c6					      DEF	aiPromotePawnStart
      1  20c6				   SLOT_aiPromotePawnStart SET	_BANK_SLOT
      2  20c6				   BANK_aiPromotePawnStart SET	SLOT_aiPromotePawnStart + _CURRENT_BANK
      3  20c6				   aiPromotePawnStart
      4  20c6				   TEMPORARY_VAR SET	Overlay
      5  20c6				   TEMPORARY_OFFSET SET	0
      6  20c6				   VAR_BOUNDARY_aiPromotePawnStart SET	TEMPORARY_OFFSET
      7  20c6				   FUNCTION_NAME SET	aiPromotePawnStart
    215  20c6					      SUBROUTINE
    216  20c6
      0  20c6					      REFER	AiStateMachine
      1  20c6				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  20c6				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  20c6					      ENDIF
      0  20c6					      VEND	aiPromotePawnStart
      1  20c6				  -	      IFNCONST	aiPromotePawnStart
      2  20c6				  -	      ECHO	"Incorrect VEND label", aiPromotePawnStart
      3  20c6				  -	      ERR
      4  20c6					      ENDIF
      5  20c6		       00 a1	   VAREND_aiPromotePawnStart =	TEMPORARY_VAR
    219  20c6
    220  20c6
    221  20c6		       ad 84 02 	      lda	INTIM
    222  20c9		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    223  20cb		       90 1c		      bcc	.exit
    224  20cd
    225  20cd		       a9 00		      lda	#0
    226  20cf		       85 8e		      sta	aiFlashPhase
    227  20d1		       85 8c		      sta	aiFlashDelay
    228  20d3
    229  20d3		       a4 86		      ldy	toX12
    230  20d5		       84 80		      sty	squareToDraw
    231  20d7
    232  20d7		       a9 cf		      lda	#RAMBANK_BOARD
    233  20d9		       85 3e		      sta	SET_BANK_RAM	;@3
    234  20db		       b9 79 fc 	      lda	Board,y
    235  20de		       29 0f		      and	#PIECE_MASK
    236  20e0		       f0 03		      beq	.empty
    237  20e2
    238  20e2		       20 a3 f0 	      jsr	CopySinglePiece	;@0	      ; remove any capturable piece for display purposes
    239  20e5
      0  20e5				   .empty     PHASE	AI_RollPromotionPiece
      1  20e5		       a9 20		      lda	#AI_RollPromotionPiece
      2  20e7		       85 8b		      sta	aiState
    241  20e9		       60	   .exit      rts
    242  20ea
    243  20ea
    244  20ea							;---------------------------------------------------------------------------------------------------
    245  20ea
      0  20ea					      DEF	aiGenerateMoves
      1  20ea				   SLOT_aiGenerateMoves SET	_BANK_SLOT
      2  20ea				   BANK_aiGenerateMoves SET	SLOT_aiGenerateMoves + _CURRENT_BANK
      3  20ea				   aiGenerateMoves
      4  20ea				   TEMPORARY_VAR SET	Overlay
      5  20ea				   TEMPORARY_OFFSET SET	0
      6  20ea				   VAR_BOUNDARY_aiGenerateMoves SET	TEMPORARY_OFFSET
      7  20ea				   FUNCTION_NAME SET	aiGenerateMoves
    247  20ea					      SUBROUTINE
    248  20ea
      0  20ea					      REFER	AiStateMachine
      1  20ea				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  20ea				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  20ea					      ENDIF
      0  20ea					      VEND	aiGenerateMoves
      1  20ea				  -	      IFNCONST	aiGenerateMoves
      2  20ea				  -	      ECHO	"Incorrect VEND label", aiGenerateMoves
      3  20ea				  -	      ERR
      4  20ea					      ENDIF
      5  20ea		       00 a1	   VAREND_aiGenerateMoves =	TEMPORARY_VAR
    251  20ea
    252  20ea							; Player comes here at the start of making a move
    253  20ea							; This generates a valid movelist by calling 'negaMax' (removing illegal moves)
    254  20ea
    255  20ea		       a5 86		      lda	toX12
    256  20ec		       85 80		      sta	squareToDraw	; for showing move (display square)
    257  20ee
    258  20ee		       a6 95		      ldx	sideToMove
    259  20f0		       10 05		      bpl	.player
    260  20f2
    261  20f2
      0  20f2				   .computer  PHASE	AI_ComputerMove	; computer select move
      1  20f2		       a9 13		      lda	#AI_ComputerMove
      2  20f4		       85 8b		      sta	aiState
    263  20f6		       60		      rts
    264  20f7
    265  20f7
      0  20f7				   .player    PHASE	AI_StartMoveGen
      1  20f7		       a9 0b		      lda	#AI_StartMoveGen
      2  20f9		       85 8b		      sta	aiState
    267  20fb		       60		      rts
    268  20fc
    269  20fc
    270  20fc							;---------------------------------------------------------------------------------------------------
    271  20fc
      0  20fc					      DEF	aiStepMoveGen
      1  20fc				   SLOT_aiStepMoveGen SET	_BANK_SLOT
      2  20fc				   BANK_aiStepMoveGen SET	SLOT_aiStepMoveGen + _CURRENT_BANK
      3  20fc				   aiStepMoveGen
      4  20fc				   TEMPORARY_VAR SET	Overlay
      5  20fc				   TEMPORARY_OFFSET SET	0
      6  20fc				   VAR_BOUNDARY_aiStepMoveGen SET	TEMPORARY_OFFSET
      7  20fc				   FUNCTION_NAME SET	aiStepMoveGen
    273  20fc					      SUBROUTINE
    274  20fc
      0  20fc					      REFER	AiStateMachine
      1  20fc				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  20fc				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  20fc					      ENDIF
      0  20fc					      VEND	aiStepMoveGen
      1  20fc				  -	      IFNCONST	aiStepMoveGen
      2  20fc				  -	      ECHO	"Incorrect VEND label", aiStepMoveGen
      3  20fc				  -	      ERR
      4  20fc					      ENDIF
      5  20fc		       00 a1	   VAREND_aiStepMoveGen =	TEMPORARY_VAR
    277  20fc
    278  20fc		       a5 87		      lda	originX12	; location of cursor (show move)
    279  20fe		       85 88		      sta	cursorX12
      0  2100					      PHASE	AI_BeginSelectMovePhase
      1  2100		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  2102		       85 8b		      sta	aiState
    281  2104		       60		      rts
    282  2105
    283  2105
    284  2105							;---------------------------------------------------------------------------------------------------
    285  2105
    286  2200		       00 00 00 00*	      align	256
      0  2200					      DEF	PositionSprites
      1  2200				   SLOT_PositionSprites SET	_BANK_SLOT
      2  2200				   BANK_PositionSprites SET	SLOT_PositionSprites + _CURRENT_BANK
      3  2200				   PositionSprites
      4  2200				   TEMPORARY_VAR SET	Overlay
      5  2200				   TEMPORARY_OFFSET SET	0
      6  2200				   VAR_BOUNDARY_PositionSprites SET	TEMPORARY_OFFSET
      7  2200				   FUNCTION_NAME SET	PositionSprites
    288  2200					      SUBROUTINE
    289  2200
      0  2200					      REFER	StartupBankReset
      1  2200				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  2200				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  2200					      ENDIF
      0  2200					      VEND	PositionSprites
      1  2200				  -	      IFNCONST	PositionSprites
      2  2200				  -	      ECHO	"Incorrect VEND label", PositionSprites
      3  2200				  -	      ERR
      4  2200					      ENDIF
      5  2200		       00 a1	   VAREND_PositionSprites =	TEMPORARY_VAR
    292  2200
    293  2200
    294  2200		       a5 88		      lda	cursorX12
    295  2202		       38		      sec
    296  2203		       e9 0a	   .sub10     sbc	#10
    297  2205		       b0 fc		      bcs	.sub10
    298  2207		       69 08		      adc	#8
    299  2209		       a8		      tay
    300  220a
    301  220a		       85 42		      sta	WSYNC	; 00	  Sync to start of scanline.
    302  220c
    303  220c		       b9 30 f6 	      lda	colToPixel,y
    304  220f
    305  220f		       38		      sec		; 02	  Set the carry flag so no borrow will be applied during the division.
    306  2210		       e9 0f	   .divideby15 sbc	#15	; 04	  Waste the necessary amount of time dividing X-pos by 15!
    307  2212		       b0 fc		      bcs	.divideby15	; 06/07  11/16/21/26/31/36/41/46/51/56/61/66
    308  2214
    309  2214		       a8		      tay
    310  2215		       b9 30 f5 	      lda	fineAdjustTable,y	; 13 -> Consume 5 cycles by guaranteeing we cross a page boundary
    311  2218		       85 60		      sta	HMP0
    312  221a		       85 50		      sta	RESP0	; 21/ 26/31/36/41/46/51/56/61/66/71 - Set the rough position.
    313  221c
    314  221c		       85 42		      sta	WSYNC
    315  221e		       85 6a		      sta	HMOVE
    316  2220
    317  2220		       60		      rts
    318  2221
    319  2221							; This table converts the "remainder" of the division by 15 (-1 to -15) to the correct
    320  2221							; fine adjustment value. This table is on a page boundary to guarantee the processor
    321  2221							; will cross a page boundary and waste a cycle in order to be at the precise position
    322  2221							; for a RESP0,x write
    323  2221
    324  2221				   fineAdjustBegin
    325  2221
    326  2221		       70		      DC.B	%01110000	; Left 7
    327  2222		       60		      DC.B	%01100000	; Left 6
    328  2223		       50		      DC.B	%01010000	; Left 5
    329  2224		       40		      DC.B	%01000000	; Left 4
    330  2225		       30		      DC.B	%00110000	; Left 3
    331  2226		       20		      DC.B	%00100000	; Left 2
    332  2227		       10		      DC.B	%00010000	; Left 1
    333  2228		       00		      DC.B	%00000000	; No movement.
    334  2229		       f0		      DC.B	%11110000	; Right 1
    335  222a		       e0		      DC.B	%11100000	; Right 2
    336  222b		       d0		      DC.B	%11010000	; Right 3
    337  222c		       c0		      DC.B	%11000000	; Right 4
    338  222d		       b0		      DC.B	%10110000	; Right 5
    339  222e		       a0		      DC.B	%10100000	; Right 6
    340  222f		       90		      DC.B	%10010000	; Right 7
    341  2230
    342  2230		       f5 30	   fineAdjustTable EQU	fineAdjustBegin - %11110001	; NOTE: %11110001 = -15
    343  2230
    344  2230
      0  2230					      ALLOCATE	colToPixel, 8
      0  2230					      OPTIONAL_PAGEBREAK	"Table", 8
     12  2230					      LIST	ON
      0  2230					      DEF	colToPixel
      1  2230				   SLOT_colToPixel SET	_BANK_SLOT
      2  2230				   BANK_colToPixel SET	SLOT_colToPixel + _CURRENT_BANK
      3  2230				   colToPixel
      4  2230				   TEMPORARY_VAR SET	Overlay
      5  2230				   TEMPORARY_OFFSET SET	0
      6  2230				   VAR_BOUNDARY_colToPixel SET	TEMPORARY_OFFSET
      7  2230				   FUNCTION_NAME SET	colToPixel
    346  2230		       00 14 28 3c*	      .byte.b	0,20,40,60,80,100,120,140
    347  2238
    348  2238
    349  2238							;---------------------------------------------------------------------------------------------------
    350  2238
      0  2238					      DEF	aiMarchToTargetA
      1  2238				   SLOT_aiMarchToTargetA SET	_BANK_SLOT
      2  2238				   BANK_aiMarchToTargetA SET	SLOT_aiMarchToTargetA + _CURRENT_BANK
      3  2238				   aiMarchToTargetA
      4  2238				   TEMPORARY_VAR SET	Overlay
      5  2238				   TEMPORARY_OFFSET SET	0
      6  2238				   VAR_BOUNDARY_aiMarchToTargetA SET	TEMPORARY_OFFSET
      7  2238				   FUNCTION_NAME SET	aiMarchToTargetA
    352  2238					      SUBROUTINE
    353  2238
      0  2238					      REFER	AiStateMachine
      1  2238				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2238				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2238					      ENDIF
      0  2238					      VAR	__fromRow, 1
      1  2238		       00 a1	   __fromRow  =	TEMPORARY_VAR
      2  2238				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  2238
      4  2238				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  2238				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  2238				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  2238					      ENDIF
      8  2238				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  2238				  -	      ECHO	"Temporary Variable", __fromRow, "overflow!"
     10  2238				  -	      ERR
     11  2238					      ENDIF
     12  2238					      LIST	ON
      0  2238					      VAR	__boardIndex, 1
      1  2238		       00 a2	   __boardIndex =	TEMPORARY_VAR
      2  2238				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  2238
      4  2238				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  2238				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  2238				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  2238					      ENDIF
      8  2238				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  2238				  -	      ECHO	"Temporary Variable", __boardIndex, "overflow!"
     10  2238				  -	      ERR
     11  2238					      ENDIF
     12  2238					      LIST	ON
      0  2238					      VAR	__fromCol, 1
      1  2238		       00 a3	   __fromCol  =	TEMPORARY_VAR
      2  2238				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  2238
      4  2238				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  2238				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  2238				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  2238					      ENDIF
      8  2238				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  2238				  -	      ECHO	"Temporary Variable", __fromCol, "overflow!"
     10  2238				  -	      ERR
     11  2238					      ENDIF
     12  2238					      LIST	ON
      0  2238					      VAR	__toCol, 1
      1  2238		       00 a4	   __toCol    =	TEMPORARY_VAR
      2  2238				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  2238
      4  2238				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  2238				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  2238				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  2238					      ENDIF
      8  2238				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  2238				  -	      ECHO	"Temporary Variable", __toCol, "overflow!"
     10  2238				  -	      ERR
     11  2238					      ENDIF
     12  2238					      LIST	ON
      0  2238					      VEND	aiMarchToTargetA
      1  2238				  -	      IFNCONST	aiMarchToTargetA
      2  2238				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetA
      3  2238				  -	      ERR
      4  2238					      ENDIF
      5  2238		       00 a5	   VAREND_aiMarchToTargetA =	TEMPORARY_VAR
    360  2238
    361  2238
    362  2238							; Now we calculate move to new square
    363  2238
    364  2238		       a5 85		      lda	fromX12
    365  223a		       c5 86		      cmp	toX12
    366  223c		       f0 44		      beq	.unmovedx
    367  223e		       85 83		      sta	lastSquareX12
    368  2240
    369  2240		       38		      sec
    370  2241		       a2 fd		      ldx	#-3
    371  2243		       e9 0a	   .sub10     sbc	#10
    372  2245		       e8		      inx
    373  2246		       b0 fb		      bcs	.sub10
    374  2248		       69 08		      adc	#8
    375  224a		       85 a3		      sta	__fromCol
    376  224c		       86 a1		      stx	__fromRow
    377  224e
    378  224e		       a5 86		      lda	toX12
    379  2250		       38		      sec
    380  2251		       a2 fd		      ldx	#-3
    381  2253		       e9 0a	   .sub10b    sbc	#10
    382  2255		       e8		      inx
    383  2256		       b0 fb		      bcs	.sub10b
    384  2258		       69 08		      adc	#8
    385  225a		       85 a4		      sta	__toCol
    386  225c
    387  225c
    388  225c		       e4 a1		      cpx	__fromRow
    389  225e		       f0 13		      beq	.rowDone
    390  2260
    391  2260		       b0 0a		      bcs	.incRow
    392  2262
    393  2262		       38		      sec
    394  2263		       a5 85		      lda	fromX12
    395  2265		       e9 0a		      sbc	#10
    396  2267		       85 85		      sta	fromX12
    397  2269		       4c 73 f6 	      jmp	.rowDone
    398  226c
    399  226c		       18	   .incRow    clc
    400  226d		       a5 85		      lda	fromX12
    401  226f		       69 0a		      adc	#10
    402  2271		       85 85		      sta	fromX12
    403  2273
    404  2273				   .rowDone
    405  2273
    406  2273		       a5 a4		      lda	__toCol
    407  2275		       c5 a3		      cmp	__fromCol
    408  2277		       f0 09		      beq	.colDone
    409  2279
    410  2279		       b0 05		      bcs	.incCol
    411  227b
    412  227b		       c6 85		      dec	fromX12
    413  227d		       4c 82 f6 	      jmp	.colDone
    414  2280
    415  2280		       e6 85	   .incCol    inc	fromX12
    416  2282				   .colDone
    417  2282				   .unmovedx
    418  2282
      0  2282					      PHASE	AI_MarchA2
      1  2282		       a9 17		      lda	#AI_MarchA2
      2  2284		       85 8b		      sta	aiState
    420  2286		       60		      rts
    421  2287
    422  2287
    423  2287							;---------------------------------------------------------------------------------------------------
    424  2287
      0  2287					      DEF	aiFinalFlash
      1  2287				   SLOT_aiFinalFlash SET	_BANK_SLOT
      2  2287				   BANK_aiFinalFlash SET	SLOT_aiFinalFlash + _CURRENT_BANK
      3  2287				   aiFinalFlash
      4  2287				   TEMPORARY_VAR SET	Overlay
      5  2287				   TEMPORARY_OFFSET SET	0
      6  2287				   VAR_BOUNDARY_aiFinalFlash SET	TEMPORARY_OFFSET
      7  2287				   FUNCTION_NAME SET	aiFinalFlash
    426  2287					      SUBROUTINE
    427  2287
      0  2287					      REFER	AiStateMachine
      1  2287				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2287				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2287					      ENDIF
      0  2287					      VEND	aiFinalFlash
      1  2287				  -	      IFNCONST	aiFinalFlash
      2  2287				  -	      ECHO	"Incorrect VEND label", aiFinalFlash
      3  2287				  -	      ERR
      4  2287					      ENDIF
      5  2287		       00 a1	   VAREND_aiFinalFlash =	TEMPORARY_VAR
    430  2287
    431  2287
    432  2287		       a5 82		      lda	drawDelay
    433  2289		       f0 03		      beq	.deCount
    434  228b		       c6 82		      dec	drawDelay
    435  228d		       60		      rts
    436  228e
    437  228e		       a5 84	   .deCount   lda	drawCount
    438  2290		       f0 0e		      beq	.flashDone2
    439  2292		       c6 84		      dec	drawCount
    440  2294
    441  2294		       a9 0a		      lda	#10
    442  2296		       85 82		      sta	drawDelay	; "getting ready to move" flash
    443  2298
    444  2298		       a5 85		      lda	fromX12
    445  229a		       85 80		      sta	squareToDraw
    446  229c
    447  229c		       20 a3 f0 	      jsr	CopySinglePiece	;@0
    448  229f		       60		      rts
    449  22a0
    450  22a0				   .flashDone2
    451  22a0
    452  22a0		       a9 64		      lda	#100
    453  22a2		       85 8c		      sta	aiFlashDelay
    454  22a4
      0  22a4					      PHASE	AI_SpecialMoveFixup
      1  22a4		       a9 1c		      lda	#AI_SpecialMoveFixup
      2  22a6		       85 8b		      sta	aiState
    456  22a8		       60		      rts
    457  22a9
    458  22a9
    459  22a9							;---------------------------------------------------------------------------------------------------
    460  22a9
    461  22a9
      0  22a9					      CHECK_BANK_SIZE	"BANK_StateMachine2"
      1  22a9		       02 a9	   .TEMP      =	* - _BANK_START
 BANK_StateMachine2 (1K) SIZE =  $2a9 , FREE= $157
      2  22a9					      ECHO	"BANK_StateMachine2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  22a9				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  22a9				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_StateMachine2", " size=", * - ORIGIN
      5  22a9				  -	      ERR
      6  22a9					      ENDIF
    463  22a9
    464  22a9
    465  22a9							;---------------------------------------------------------------------------------------------------
    466  22a9
    467  22a9							; EOF
------- FILE ./chess.asm
------- FILE BANK_RECON.asm LEVEL 2 PASS 4
      0  22a9					      include	"BANK_RECON.asm"
      0  22a9					      SLOT	1
      1  22a9				  -	      IF	(1 < 0) || (1 > 3)
      2  22a9				  -	      ECHO	"Illegal bank address/segment location", 1
      3  22a9				  -	      ERR
      4  22a9					      ENDIF
      5  22a9				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  22a9				   _BANK_SLOT SET	1 * 64
      0  22a9					      NEWBANK	RECON
      1  240a ????				      SEG	RECON
      2  2400					      ORG	_ORIGIN
      3  2400					      RORG	_BANK_ADDRESS_ORIGIN
      4  2400				   _BANK_START SET	*
      5  2400				   RECON_START SET	*
      6  2400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2400				   RECON      SET	_BANK_SLOT + _CURRENT_BANK
      8  2400				   _ORIGIN    SET	_ORIGIN + 1024
      3  2400
      4  2400
      5  2400							;---------------------------------------------------------------------------------------------------
      6  2400
      0  2400					      DEF	showPromoteOptions
      1  2400				   SLOT_showPromoteOptions SET	_BANK_SLOT
      2  2400				   BANK_showPromoteOptions SET	SLOT_showPromoteOptions + _CURRENT_BANK
      3  2400				   showPromoteOptions
      4  2400				   TEMPORARY_VAR SET	Overlay
      5  2400				   TEMPORARY_OFFSET SET	0
      6  2400				   VAR_BOUNDARY_showPromoteOptions SET	TEMPORARY_OFFSET
      7  2400				   FUNCTION_NAME SET	showPromoteOptions
      8  2400					      SUBROUTINE
      9  2400
      0  2400					      REFER	aiRollPromotionPiece
      1  2400				  -	      IF	VAREND_aiRollPromotionPiece > TEMPORARY_VAR
      2  2400				  -TEMPORARY_VAR SET	VAREND_aiRollPromotionPiece
      3  2400					      ENDIF
      0  2400					      REFER	aiChoosePromotePiece
      1  2400				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  2400				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  2400					      ENDIF
      0  2400					      VEND	showPromoteOptions
      1  2400				  -	      IFNCONST	showPromoteOptions
      2  2400				  -	      ECHO	"Incorrect VEND label", showPromoteOptions
      3  2400				  -	      ERR
      4  2400					      ENDIF
      5  2400		       00 a1	   VAREND_showPromoteOptions =	TEMPORARY_VAR
     13  2400
     14  2400							; X = character shape # (?/N/B/R/Q)
     15  2400
     16  2400		       a4 86		      ldy	toX12
     17  2402		       84 80		      sty	squareToDraw
     18  2404
     19  2404		       20 93 f5 	      jsr	CopySetupForMarker
     20  2407		       4c aa f0 	      jmp	InterceptMarkerCopy
     21  240a
     22  240a
     23  240a
     24  240a							;---------------------------------------------------------------------------------------------------
     25  240a
     26  240a
      0  240a					      CHECK_BANK_SIZE	"BANK_RECON"
      1  240a		       00 0a	   .TEMP      =	* - _BANK_START
 BANK_RECON (1K) SIZE =  $a , FREE= $3f6
      2  240a					      ECHO	"BANK_RECON", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  240a				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  240a				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_RECON", " size=", * - ORIGIN
      5  240a				  -	      ERR
      6  240a					      ENDIF
     28  240a
     29  240a							; EOF
------- FILE ./chess.asm
------- FILE piece_graphics.asm LEVEL 2 PASS 4
      0  240a					      include	"piece_graphics.asm"
      1  240a							; Import the graphics definitions generated by ConvertChessPieces.py
      2  240a
      0  240a					      SLOT	2
      1  240a				  -	      IF	(2 < 0) || (2 > 3)
      2  240a				  -	      ECHO	"Illegal bank address/segment location", 2
      3  240a				  -	      ERR
      4  240a					      ENDIF
      5  240a				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  240a				   _BANK_SLOT SET	2 * 64
      0  240a					      NEWBANK	PIECES_0
      1  2bd8 ????				      SEG	PIECES_0
      2  2800					      ORG	_ORIGIN
      3  2800					      RORG	_BANK_ADDRESS_ORIGIN
      4  2800				   _BANK_START SET	*
      5  2800				   PIECES_0_START SET	*
      6  2800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2800				   PIECES_0   SET	_BANK_SLOT + _CURRENT_BANK
      8  2800				   _ORIGIN    SET	_ORIGIN + 1024
      5  2800
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2800					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm"
      0  2800					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_0", 72
     12  2800					      LIST	ON
      0  2800					      DEF	WHITE_BLANK_on_WHITE_SQUARE_0
      1  2800				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2800				   BANK_WHITE_BLANK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2800				   WHITE_BLANK_on_WHITE_SQUARE_0
      4  2800				   TEMPORARY_VAR SET	Overlay
      5  2800				   TEMPORARY_OFFSET SET	0
      6  2800				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2800				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_0
      3  2800		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$e0,$f0,$f0,$f0,$f0,$f0,$f0,$e0	;PF0
      4  2818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$00	;PF1
      5  2830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2848					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm"
      0  2848					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_1", 72
     12  2848					      LIST	ON
      0  2848					      DEF	WHITE_BLANK_on_WHITE_SQUARE_1
      1  2848				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2848				   BANK_WHITE_BLANK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2848				   WHITE_BLANK_on_WHITE_SQUARE_1
      4  2848				   TEMPORARY_VAR SET	Overlay
      5  2848				   TEMPORARY_OFFSET SET	0
      6  2848				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2848				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_1
      3  2848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2860		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$38,$7c,$7c,$7c,$7c,$7c,$7c,$38	;PF1
      5  2878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2890					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm"
      0  2890					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_2", 72
     12  2890					      LIST	ON
      0  2890					      DEF	WHITE_BLANK_on_WHITE_SQUARE_2
      1  2890				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2890				   BANK_WHITE_BLANK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2890				   WHITE_BLANK_on_WHITE_SQUARE_2
      4  2890				   TEMPORARY_VAR SET	Overlay
      5  2890				   TEMPORARY_OFFSET SET	0
      6  2890				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2890				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_2
      3  2890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  28a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$03,$03,$03,$01	;PF1
      5  28c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$07,$07,$07,$07,$07,$07,$03	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  28d8					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm"
      0  28d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_3", 72
     12  2900					      LIST	ON
      0  2900					      DEF	WHITE_BLANK_on_WHITE_SQUARE_3
      1  2900				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2900				   BANK_WHITE_BLANK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2900				   WHITE_BLANK_on_WHITE_SQUARE_3
      4  2900				   TEMPORARY_VAR SET	Overlay
      5  2900				   TEMPORARY_OFFSET SET	0
      6  2900				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2900				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_3
      3  2900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2930		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$70,$f8,$f8,$f8,$f8,$f8,$f8,$70	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2948					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm"
      0  2948					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_0", 72
     12  2948					      LIST	ON
      0  2948					      DEF	WHITE_PAWN_on_WHITE_SQUARE_0
      1  2948				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2948				   BANK_WHITE_PAWN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2948				   WHITE_PAWN_on_WHITE_SQUARE_0
      4  2948				   TEMPORARY_VAR SET	Overlay
      5  2948				   TEMPORARY_OFFSET SET	0
      6  2948				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2948				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_0
      3  2948		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$00,$00,$40,$00,$00,$00,$00	;PF0
      4  2960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2990					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm"
      0  2990					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_1", 72
     12  2990					      LIST	ON
      0  2990					      DEF	WHITE_PAWN_on_WHITE_SQUARE_1
      1  2990				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2990				   BANK_WHITE_PAWN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2990				   WHITE_PAWN_on_WHITE_SQUARE_1
      4  2990				   TEMPORARY_VAR SET	Overlay
      5  2990				   TEMPORARY_OFFSET SET	0
      6  2990				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2990				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_1
      3  2990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  29a8		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$00,$00,$10,$00,$00,$00,$00	;PF1
      5  29c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  29d8					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm"
      0  29d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_2", 72
     12  2a00					      LIST	ON
      0  2a00					      DEF	WHITE_PAWN_on_WHITE_SQUARE_2
      1  2a00				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2a00				   BANK_WHITE_PAWN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2a00				   WHITE_PAWN_on_WHITE_SQUARE_2
      4  2a00				   TEMPORARY_VAR SET	Overlay
      5  2a00				   TEMPORARY_OFFSET SET	0
      6  2a00				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2a00				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_2
      3  2a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a18		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2a30		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$00,$00,$01,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2a48					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm"
      0  2a48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_3", 72
     12  2a48					      LIST	ON
      0  2a48					      DEF	WHITE_PAWN_on_WHITE_SQUARE_3
      1  2a48				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2a48				   BANK_WHITE_PAWN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2a48				   WHITE_PAWN_on_WHITE_SQUARE_3
      4  2a48				   TEMPORARY_VAR SET	Overlay
      5  2a48				   TEMPORARY_OFFSET SET	0
      6  2a48				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2a48				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_3
      3  2a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2a78		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$00,$00,$20,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2a90					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  2a90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_0", 72
     12  2a90					      LIST	ON
      0  2a90					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_0
      1  2a90				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2a90				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2a90				   WHITE_KNIGHT_on_WHITE_SQUARE_0
      4  2a90				   TEMPORARY_VAR SET	Overlay
      5  2a90				   TEMPORARY_OFFSET SET	0
      6  2a90				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2a90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_0
      3  2a90		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$10,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2aa8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2ad8					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  2ad8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_1", 72
     12  2b00					      LIST	ON
      0  2b00					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_1
      1  2b00				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2b00				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2b00				   WHITE_KNIGHT_on_WHITE_SQUARE_1
      4  2b00				   TEMPORARY_VAR SET	Overlay
      5  2b00				   TEMPORARY_OFFSET SET	0
      6  2b00				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2b00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_1
      3  2b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b18		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$44,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2b48					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  2b48					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_2", 72
     12  2b48					      LIST	ON
      0  2b48					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_2
      1  2b48				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2b48				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2b48				   WHITE_KNIGHT_on_WHITE_SQUARE_2
      4  2b48				   TEMPORARY_VAR SET	Overlay
      5  2b48				   TEMPORARY_OFFSET SET	0
      6  2b48				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2b48				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_2
      3  2b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b60		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$02,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2b78		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$04,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2b90					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  2b90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_3", 72
     12  2b90					      LIST	ON
      0  2b90					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_3
      1  2b90				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2b90				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2b90				   WHITE_KNIGHT_on_WHITE_SQUARE_3
      4  2b90				   TEMPORARY_VAR SET	Overlay
      5  2b90				   TEMPORARY_OFFSET SET	0
      6  2b90				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2b90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_3
      3  2b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2bc0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$88,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  2bd8					      CHECK_BANK_SIZE	"PIECE_0 (1K)"
      1  2bd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_0 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  2bd8					      ECHO	"PIECE_0 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2bd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_0 (1K)", " size=", * - ORIGIN
      5  2bd8				  -	      ERR
      6  2bd8					      ENDIF
     19  2bd8
      0  2bd8					      SLOT	2
      1  2bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  2bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  2bd8				  -	      ERR
      4  2bd8					      ENDIF
      5  2bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  2bd8				   _BANK_SLOT SET	2 * 64
      0  2bd8					      NEWBANK	PIECES_1
      1  2fd8 ????				      SEG	PIECES_1
      2  2c00					      ORG	_ORIGIN
      3  2c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  2c00				   _BANK_START SET	*
      5  2c00				   PIECES_1_START SET	*
      6  2c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2c00				   PIECES_1   SET	_BANK_SLOT + _CURRENT_BANK
      8  2c00				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2c00					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm"
      0  2c00					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_0", 72
     12  2c00					      LIST	ON
      0  2c00					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_0
      1  2c00				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2c00				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2c00				   WHITE_BISHOP_on_WHITE_SQUARE_0
      4  2c00				   TEMPORARY_VAR SET	Overlay
      5  2c00				   TEMPORARY_OFFSET SET	0
      6  2c00				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2c00				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_0
      3  2c00		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$10,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c18		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2c48					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm"
      0  2c48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_1", 72
     12  2c48					      LIST	ON
      0  2c48					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_1
      1  2c48				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2c48				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2c48				   WHITE_BISHOP_on_WHITE_SQUARE_1
      4  2c48				   TEMPORARY_VAR SET	Overlay
      5  2c48				   TEMPORARY_OFFSET SET	0
      6  2c48				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2c48				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_1
      3  2c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c60		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$44,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2c90					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm"
      0  2c90					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_2", 72
     12  2c90					      LIST	ON
      0  2c90					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_2
      1  2c90				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2c90				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2c90				   WHITE_BISHOP_on_WHITE_SQUARE_2
      4  2c90				   TEMPORARY_VAR SET	Overlay
      5  2c90				   TEMPORARY_OFFSET SET	0
      6  2c90				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2c90				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_2
      3  2c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ca8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$02,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2cc0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$04,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2cd8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm"
      0  2cd8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_3", 72
     12  2d00					      LIST	ON
      0  2d00					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_3
      1  2d00				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2d00				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2d00				   WHITE_BISHOP_on_WHITE_SQUARE_3
      4  2d00				   TEMPORARY_VAR SET	Overlay
      5  2d00				   TEMPORARY_OFFSET SET	0
      6  2d00				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2d00				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_3
      3  2d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d30		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$88,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2d48					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm"
      0  2d48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_0", 72
     12  2d48					      LIST	ON
      0  2d48					      DEF	WHITE_ROOK_on_WHITE_SQUARE_0
      1  2d48				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2d48				   BANK_WHITE_ROOK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2d48				   WHITE_ROOK_on_WHITE_SQUARE_0
      4  2d48				   TEMPORARY_VAR SET	Overlay
      5  2d48				   TEMPORARY_OFFSET SET	0
      6  2d48				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2d48				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_0
      3  2d48		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$10,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d60		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2d90					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm"
      0  2d90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_1", 72
     12  2d90					      LIST	ON
      0  2d90					      DEF	WHITE_ROOK_on_WHITE_SQUARE_1
      1  2d90				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2d90				   BANK_WHITE_ROOK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2d90				   WHITE_ROOK_on_WHITE_SQUARE_1
      4  2d90				   TEMPORARY_VAR SET	Overlay
      5  2d90				   TEMPORARY_OFFSET SET	0
      6  2d90				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2d90				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_1
      3  2d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2da8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$44,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2dd8					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm"
      0  2dd8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_2", 72
     12  2e00					      LIST	ON
      0  2e00					      DEF	WHITE_ROOK_on_WHITE_SQUARE_2
      1  2e00				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2e00				   BANK_WHITE_ROOK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2e00				   WHITE_ROOK_on_WHITE_SQUARE_2
      4  2e00				   TEMPORARY_VAR SET	Overlay
      5  2e00				   TEMPORARY_OFFSET SET	0
      6  2e00				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2e00				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_2
      3  2e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e18		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$02,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e30		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$04,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2e48					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm"
      0  2e48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_3", 72
     12  2e48					      LIST	ON
      0  2e48					      DEF	WHITE_ROOK_on_WHITE_SQUARE_3
      1  2e48				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2e48				   BANK_WHITE_ROOK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2e48				   WHITE_ROOK_on_WHITE_SQUARE_3
      4  2e48				   TEMPORARY_VAR SET	Overlay
      5  2e48				   TEMPORARY_OFFSET SET	0
      6  2e48				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2e48				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_3
      3  2e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e78		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$88,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2e90					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm"
      0  2e90					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_0", 72
     12  2e90					      LIST	ON
      0  2e90					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_0
      1  2e90				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2e90				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2e90				   WHITE_QUEEN_on_WHITE_SQUARE_0
      4  2e90				   TEMPORARY_VAR SET	Overlay
      5  2e90				   TEMPORARY_OFFSET SET	0
      6  2e90				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2e90				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_0
      3  2e90		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ea8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2ed8					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm"
      0  2ed8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_1", 72
     12  2f00					      LIST	ON
      0  2f00					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_1
      1  2f00				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2f00				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2f00				   WHITE_QUEEN_on_WHITE_SQUARE_1
      4  2f00				   TEMPORARY_VAR SET	Overlay
      5  2f00				   TEMPORARY_OFFSET SET	0
      6  2f00				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2f00				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_1
      3  2f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f18		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2f48					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm"
      0  2f48					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_2", 72
     12  2f48					      LIST	ON
      0  2f48					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_2
      1  2f48				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2f48				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2f48				   WHITE_QUEEN_on_WHITE_SQUARE_2
      4  2f48				   TEMPORARY_VAR SET	Overlay
      5  2f48				   TEMPORARY_OFFSET SET	0
      6  2f48				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2f48				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_2
      3  2f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f60		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2f78		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2f90					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm"
      0  2f90					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_3", 72
     12  2f90					      LIST	ON
      0  2f90					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_3
      1  2f90				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2f90				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2f90				   WHITE_QUEEN_on_WHITE_SQUARE_3
      4  2f90				   TEMPORARY_VAR SET	Overlay
      5  2f90				   TEMPORARY_OFFSET SET	0
      6  2f90				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2f90				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_3
      3  2f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2fc0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  2fd8					      CHECK_BANK_SIZE	"PIECE_1 (1K)"
      1  2fd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_1 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  2fd8					      ECHO	"PIECE_1 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2fd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_1 (1K)", " size=", * - ORIGIN
      5  2fd8				  -	      ERR
      6  2fd8					      ENDIF
      0  2fd8					      SLOT	2
      1  2fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  2fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  2fd8				  -	      ERR
      4  2fd8					      ENDIF
      5  2fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  2fd8				   _BANK_SLOT SET	2 * 64
      0  2fd8					      NEWBANK	PIECES_2
      1  33d8 ????				      SEG	PIECES_2
      2  3000					      ORG	_ORIGIN
      3  3000					      RORG	_BANK_ADDRESS_ORIGIN
      4  3000				   _BANK_START SET	*
      5  3000				   PIECES_2_START SET	*
      6  3000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3000				   PIECES_2   SET	_BANK_SLOT + _CURRENT_BANK
      8  3000				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3000					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_0.asm"
      0  3000					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_0", 72
     12  3000					      LIST	ON
      0  3000					      DEF	WHITE_KING_on_WHITE_SQUARE_0
      1  3000				   SLOT_WHITE_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3000				   BANK_WHITE_KING_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3000				   WHITE_KING_on_WHITE_SQUARE_0
      4  3000				   TEMPORARY_VAR SET	Overlay
      5  3000				   TEMPORARY_OFFSET SET	0
      6  3000				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3000				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_0
      3  3000		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$80,$40,$00,$00	;PF0
      4  3018		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3048					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_1.asm"
      0  3048					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_1", 72
     12  3048					      LIST	ON
      0  3048					      DEF	WHITE_KING_on_WHITE_SQUARE_1
      1  3048				   SLOT_WHITE_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3048				   BANK_WHITE_KING_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3048				   WHITE_KING_on_WHITE_SQUARE_1
      4  3048				   TEMPORARY_VAR SET	Overlay
      5  3048				   TEMPORARY_OFFSET SET	0
      6  3048				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3048				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_1
      3  3048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3060		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$08,$10,$00,$00	;PF1
      5  3078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3090					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_2.asm"
      0  3090					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_2", 72
     12  3090					      LIST	ON
      0  3090					      DEF	WHITE_KING_on_WHITE_SQUARE_2
      1  3090				   SLOT_WHITE_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3090				   BANK_WHITE_KING_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3090				   WHITE_KING_on_WHITE_SQUARE_2
      4  3090				   TEMPORARY_VAR SET	Overlay
      5  3090				   TEMPORARY_OFFSET SET	0
      6  3090				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3090				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_2
      3  3090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  30a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  30c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$02,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  30d8					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_3.asm"
      0  30d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_3", 72
     12  3100					      LIST	ON
      0  3100					      DEF	WHITE_KING_on_WHITE_SQUARE_3
      1  3100				   SLOT_WHITE_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3100				   BANK_WHITE_KING_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3100				   WHITE_KING_on_WHITE_SQUARE_3
      4  3100				   TEMPORARY_VAR SET	Overlay
      5  3100				   TEMPORARY_OFFSET SET	0
      6  3100				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3100				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_3
      3  3100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3130		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$40,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3148					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm"
      0  3148					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_0", 72
     12  3148					      LIST	ON
      0  3148					      DEF	WHITE_BLANK_on_BLACK_SQUARE_0
      1  3148				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3148				   BANK_WHITE_BLANK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3148				   WHITE_BLANK_on_BLACK_SQUARE_0
      4  3148				   TEMPORARY_VAR SET	Overlay
      5  3148				   TEMPORARY_OFFSET SET	0
      6  3148				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3148				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_0
      3  3148		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3160		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3190					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm"
      0  3190					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_1", 72
     12  3190					      LIST	ON
      0  3190					      DEF	WHITE_BLANK_on_BLACK_SQUARE_1
      1  3190				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3190				   BANK_WHITE_BLANK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3190				   WHITE_BLANK_on_BLACK_SQUARE_1
      4  3190				   TEMPORARY_VAR SET	Overlay
      5  3190				   TEMPORARY_OFFSET SET	0
      6  3190				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3190				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_1
      3  3190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  31a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  31c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  31d8					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm"
      0  31d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_2", 72
     12  3200					      LIST	ON
      0  3200					      DEF	WHITE_BLANK_on_BLACK_SQUARE_2
      1  3200				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3200				   BANK_WHITE_BLANK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3200				   WHITE_BLANK_on_BLACK_SQUARE_2
      4  3200				   TEMPORARY_VAR SET	Overlay
      5  3200				   TEMPORARY_OFFSET SET	0
      6  3200				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3200				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_2
      3  3200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3218		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3230		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3248					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm"
      0  3248					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_3", 72
     12  3248					      LIST	ON
      0  3248					      DEF	WHITE_BLANK_on_BLACK_SQUARE_3
      1  3248				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3248				   BANK_WHITE_BLANK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3248				   WHITE_BLANK_on_BLACK_SQUARE_3
      4  3248				   TEMPORARY_VAR SET	Overlay
      5  3248				   TEMPORARY_OFFSET SET	0
      6  3248				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3248				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_3
      3  3248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3278		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3290					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm"
      0  3290					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_0", 72
     12  3290					      LIST	ON
      0  3290					      DEF	WHITE_PAWN_on_BLACK_SQUARE_0
      1  3290				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3290				   BANK_WHITE_PAWN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3290				   WHITE_PAWN_on_BLACK_SQUARE_0
      4  3290				   TEMPORARY_VAR SET	Overlay
      5  3290				   TEMPORARY_OFFSET SET	0
      6  3290				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3290				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_0
      3  3290		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$e0,$40,$00,$e0,$40,$40,$00	;PF0
      4  32a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  32c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  32d8					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm"
      0  32d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_1", 72
     12  3300					      LIST	ON
      0  3300					      DEF	WHITE_PAWN_on_BLACK_SQUARE_1
      1  3300				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3300				   BANK_WHITE_PAWN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3300				   WHITE_PAWN_on_BLACK_SQUARE_1
      4  3300				   TEMPORARY_VAR SET	Overlay
      5  3300				   TEMPORARY_OFFSET SET	0
      6  3300				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3300				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_1
      3  3300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3318		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$38,$10,$00,$38,$10,$10,$00	;PF1
      5  3330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3348					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm"
      0  3348					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_2", 72
     12  3348					      LIST	ON
      0  3348					      DEF	WHITE_PAWN_on_BLACK_SQUARE_2
      1  3348				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3348				   BANK_WHITE_PAWN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3348				   WHITE_PAWN_on_BLACK_SQUARE_2
      4  3348				   TEMPORARY_VAR SET	Overlay
      5  3348				   TEMPORARY_OFFSET SET	0
      6  3348				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3348				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_2
      3  3348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3360		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  3378		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$03,$01,$00,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3390					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm"
      0  3390					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_3", 72
     12  3390					      LIST	ON
      0  3390					      DEF	WHITE_PAWN_on_BLACK_SQUARE_3
      1  3390				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3390				   BANK_WHITE_PAWN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3390				   WHITE_PAWN_on_BLACK_SQUARE_3
      4  3390				   TEMPORARY_VAR SET	Overlay
      5  3390				   TEMPORARY_OFFSET SET	0
      6  3390				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3390				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_3
      3  3390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  33a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  33c0		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$70,$20,$00,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
      0  33d8					      CHECK_BANK_SIZE	"PIECE_2 (1K)"
      1  33d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_2 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  33d8					      ECHO	"PIECE_2 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  33d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  33d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_2 (1K)", " size=", * - ORIGIN
      5  33d8				  -	      ERR
      6  33d8					      ENDIF
      0  33d8					      SLOT	2
      1  33d8				  -	      IF	(2 < 0) || (2 > 3)
      2  33d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  33d8				  -	      ERR
      4  33d8					      ENDIF
      5  33d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  33d8				   _BANK_SLOT SET	2 * 64
      0  33d8					      NEWBANK	PIECES_3
      1  37d8 ????				      SEG	PIECES_3
      2  3400					      ORG	_ORIGIN
      3  3400					      RORG	_BANK_ADDRESS_ORIGIN
      4  3400				   _BANK_START SET	*
      5  3400				   PIECES_3_START SET	*
      6  3400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3400				   PIECES_3   SET	_BANK_SLOT + _CURRENT_BANK
      8  3400				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3400					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  3400					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_0", 72
     12  3400					      LIST	ON
      0  3400					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_0
      1  3400				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3400				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3400				   WHITE_KNIGHT_on_BLACK_SQUARE_0
      4  3400				   TEMPORARY_VAR SET	Overlay
      5  3400				   TEMPORARY_OFFSET SET	0
      6  3400				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3400				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_0
      3  3400		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$f0,$e0,$e0,$f0,$f0,$40,$00	;PF0
      4  3418		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  3430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3448					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  3448					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_1", 72
     12  3448					      LIST	ON
      0  3448					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_1
      1  3448				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3448				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3448				   WHITE_KNIGHT_on_BLACK_SQUARE_1
      4  3448				   TEMPORARY_VAR SET	Overlay
      5  3448				   TEMPORARY_OFFSET SET	0
      6  3448				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3448				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_1
      3  3448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3460		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$78,$38,$3c,$7c,$7c,$14,$00	;PF1
      5  3478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3490					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  3490					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_2", 72
     12  3490					      LIST	ON
      0  3490					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_2
      1  3490				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3490				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3490				   WHITE_KNIGHT_on_BLACK_SQUARE_2
      4  3490				   TEMPORARY_VAR SET	Overlay
      5  3490				   TEMPORARY_OFFSET SET	0
      6  3490				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3490				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_2
      3  3490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  34a8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$01,$03,$03,$00,$00	;PF1
      5  34c0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$03,$03,$07,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  34d8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  34d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_3", 72
     12  3500					      LIST	ON
      0  3500					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_3
      1  3500				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3500				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3500				   WHITE_KNIGHT_on_BLACK_SQUARE_3
      4  3500				   TEMPORARY_VAR SET	Overlay
      5  3500				   TEMPORARY_OFFSET SET	0
      6  3500				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3500				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_3
      3  3500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3530		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$78,$70,$f0,$f8,$f8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3548					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm"
      0  3548					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_0", 72
     12  3548					      LIST	ON
      0  3548					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_0
      1  3548				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3548				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3548				   WHITE_BISHOP_on_BLACK_SQUARE_0
      4  3548				   TEMPORARY_VAR SET	Overlay
      5  3548				   TEMPORARY_OFFSET SET	0
      6  3548				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3548				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_0
      3  3548		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$b0,$d0,$e0,$40,$40	;PF0
      4  3560		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  3578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3590					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm"
      0  3590					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_1", 72
     12  3590					      LIST	ON
      0  3590					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_1
      1  3590				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3590				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3590				   WHITE_BISHOP_on_BLACK_SQUARE_1
      4  3590				   TEMPORARY_VAR SET	Overlay
      5  3590				   TEMPORARY_OFFSET SET	0
      6  3590				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3590				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_1
      3  3590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  35a8		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$6c,$5c,$38,$10,$10	;PF1
      5  35c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  35d8					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm"
      0  35d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_2", 72
     12  3600					      LIST	ON
      0  3600					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_2
      1  3600				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3600				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3600				   WHITE_BISHOP_on_BLACK_SQUARE_2
      4  3600				   TEMPORARY_VAR SET	Overlay
      5  3600				   TEMPORARY_OFFSET SET	0
      6  3600				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3600				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_2
      3  3600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3618		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  3630		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$06,$07,$03,$01,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3648					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm"
      0  3648					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_3", 72
     12  3648					      LIST	ON
      0  3648					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_3
      1  3648				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3648				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3648				   WHITE_BISHOP_on_BLACK_SQUARE_3
      4  3648				   TEMPORARY_VAR SET	Overlay
      5  3648				   TEMPORARY_OFFSET SET	0
      6  3648				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3648				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_3
      3  3648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3678		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$d8,$e8,$70,$20,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3690					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm"
      0  3690					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_0", 72
     12  3690					      LIST	ON
      0  3690					      DEF	WHITE_ROOK_on_BLACK_SQUARE_0
      1  3690				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3690				   BANK_WHITE_ROOK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3690				   WHITE_ROOK_on_BLACK_SQUARE_0
      4  3690				   TEMPORARY_VAR SET	Overlay
      5  3690				   TEMPORARY_OFFSET SET	0
      6  3690				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3690				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_0
      3  3690		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$f0,$50,$00	;PF0
      4  36a8		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  36c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  36d8					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm"
      0  36d8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_1", 72
     12  3700					      LIST	ON
      0  3700					      DEF	WHITE_ROOK_on_BLACK_SQUARE_1
      1  3700				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3700				   BANK_WHITE_ROOK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3700				   WHITE_ROOK_on_BLACK_SQUARE_1
      4  3700				   TEMPORARY_VAR SET	Overlay
      5  3700				   TEMPORARY_OFFSET SET	0
      6  3700				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3700				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_1
      3  3700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3718		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$7c,$54,$00	;PF1
      5  3730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3748					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm"
      0  3748					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_2", 72
     12  3748					      LIST	ON
      0  3748					      DEF	WHITE_ROOK_on_BLACK_SQUARE_2
      1  3748				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3748				   BANK_WHITE_ROOK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3748				   WHITE_ROOK_on_BLACK_SQUARE_2
      4  3748				   TEMPORARY_VAR SET	Overlay
      5  3748				   TEMPORARY_OFFSET SET	0
      6  3748				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3748				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_2
      3  3748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3760		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$03,$02,$00	;PF1
      5  3778		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3790					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm"
      0  3790					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_3", 72
     12  3790					      LIST	ON
      0  3790					      DEF	WHITE_ROOK_on_BLACK_SQUARE_3
      1  3790				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3790				   BANK_WHITE_ROOK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3790				   WHITE_ROOK_on_BLACK_SQUARE_3
      4  3790				   TEMPORARY_VAR SET	Overlay
      5  3790				   TEMPORARY_OFFSET SET	0
      6  3790				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3790				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_3
      3  3790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  37a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  37c0		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$f8,$a8,$00	;PF2
------- FILE piece_graphics.asm
      0  37d8					      CHECK_BANK_SIZE	"PIECE_3 (1K)"
      1  37d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_3 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  37d8					      ECHO	"PIECE_3 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  37d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  37d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_3 (1K)", " size=", * - ORIGIN
      5  37d8				  -	      ERR
      6  37d8					      ENDIF
      0  37d8					      SLOT	2
      1  37d8				  -	      IF	(2 < 0) || (2 > 3)
      2  37d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  37d8				  -	      ERR
      4  37d8					      ENDIF
      5  37d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  37d8				   _BANK_SLOT SET	2 * 64
      0  37d8					      NEWBANK	PIECE_4
      1  3bd8 ????				      SEG	PIECE_4
      2  3800					      ORG	_ORIGIN
      3  3800					      RORG	_BANK_ADDRESS_ORIGIN
      4  3800				   _BANK_START SET	*
      5  3800				   PIECE_4_START SET	*
      6  3800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3800				   PIECE_4    SET	_BANK_SLOT + _CURRENT_BANK
      8  3800				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3800					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm"
      0  3800					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_0", 72
     12  3800					      LIST	ON
      0  3800					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_0
      1  3800				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3800				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3800				   WHITE_QUEEN_on_BLACK_SQUARE_0
      4  3800				   TEMPORARY_VAR SET	Overlay
      5  3800				   TEMPORARY_OFFSET SET	0
      6  3800				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3800				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_0
      3  3800		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  3818		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00,$80,$00	;PF1
      5  3830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3848					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm"
      0  3848					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_1", 72
     12  3848					      LIST	ON
      0  3848					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_1
      1  3848				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3848				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3848				   WHITE_QUEEN_on_BLACK_SQUARE_1
      4  3848				   TEMPORARY_VAR SET	Overlay
      5  3848				   TEMPORARY_OFFSET SET	0
      6  3848				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3848				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_1
      3  3848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3860		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$7c,$7c,$54,$00,$54,$00	;PF1
      5  3878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3890					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm"
      0  3890					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_2", 72
     12  3890					      LIST	ON
      0  3890					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_2
      1  3890				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3890				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3890				   WHITE_QUEEN_on_BLACK_SQUARE_2
      4  3890				   TEMPORARY_VAR SET	Overlay
      5  3890				   TEMPORARY_OFFSET SET	0
      6  3890				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3890				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_2
      3  3890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  38a8		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  38c0		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$07,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  38d8					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm"
      0  38d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_3", 72
     12  3900					      LIST	ON
      0  3900					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_3
      1  3900				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3900				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3900				   WHITE_QUEEN_on_BLACK_SQUARE_3
      4  3900				   TEMPORARY_VAR SET	Overlay
      5  3900				   TEMPORARY_OFFSET SET	0
      6  3900				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3900				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_3
      3  3900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3930		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$f8,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3948					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_0.asm"
      0  3948					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_0", 72
     12  3948					      LIST	ON
      0  3948					      DEF	WHITE_KING_on_BLACK_SQUARE_0
      1  3948				   SLOT_WHITE_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3948				   BANK_WHITE_KING_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3948				   WHITE_KING_on_BLACK_SQUARE_0
      4  3948				   TEMPORARY_VAR SET	Overlay
      5  3948				   TEMPORARY_OFFSET SET	0
      6  3948				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3948				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_0
      3  3948		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$70,$00,$e0,$40	;PF0
      4  3960		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  3978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3990					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_1.asm"
      0  3990					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_1", 72
     12  3990					      LIST	ON
      0  3990					      DEF	WHITE_KING_on_BLACK_SQUARE_1
      1  3990				   SLOT_WHITE_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3990				   BANK_WHITE_KING_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3990				   WHITE_KING_on_BLACK_SQUARE_1
      4  3990				   TEMPORARY_VAR SET	Overlay
      5  3990				   TEMPORARY_OFFSET SET	0
      6  3990				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3990				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_1
      3  3990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  39a8		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$74,$00,$38,$10	;PF1
      5  39c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  39d8					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_2.asm"
      0  39d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_2", 72
     12  3a00					      LIST	ON
      0  3a00					      DEF	WHITE_KING_on_BLACK_SQUARE_2
      1  3a00				   SLOT_WHITE_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3a00				   BANK_WHITE_KING_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3a00				   WHITE_KING_on_BLACK_SQUARE_2
      4  3a00				   TEMPORARY_VAR SET	Overlay
      5  3a00				   TEMPORARY_OFFSET SET	0
      6  3a00				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3a00				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_2
      3  3a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a18		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  3a30		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$05,$00,$03,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3a48					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_3.asm"
      0  3a48					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_3", 72
     12  3a48					      LIST	ON
      0  3a48					      DEF	WHITE_KING_on_BLACK_SQUARE_3
      1  3a48				   SLOT_WHITE_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3a48				   BANK_WHITE_KING_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3a48				   WHITE_KING_on_BLACK_SQUARE_3
      4  3a48				   TEMPORARY_VAR SET	Overlay
      5  3a48				   TEMPORARY_OFFSET SET	0
      6  3a48				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3a48				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_3
      3  3a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3a78		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$b8,$00,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3a90					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm"
      0  3a90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_0", 72
     12  3a90					      LIST	ON
      0  3a90					      DEF	BLACK_BLANK_on_WHITE_SQUARE_0
      1  3a90				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3a90				   BANK_BLACK_BLANK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3a90				   BLACK_BLANK_on_WHITE_SQUARE_0
      4  3a90				   TEMPORARY_VAR SET	Overlay
      5  3a90				   TEMPORARY_OFFSET SET	0
      6  3a90				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3a90				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_0
      3  3a90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$e0,$f0,$f0,$f0,$f0,$f0,$f0,$e0	;PF0
      4  3aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$00	;PF1
      5  3ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ad8					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm"
      0  3ad8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_1", 72
     12  3b00					      LIST	ON
      0  3b00					      DEF	BLACK_BLANK_on_WHITE_SQUARE_1
      1  3b00				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3b00				   BANK_BLACK_BLANK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3b00				   BLACK_BLANK_on_WHITE_SQUARE_1
      4  3b00				   TEMPORARY_VAR SET	Overlay
      5  3b00				   TEMPORARY_OFFSET SET	0
      6  3b00				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3b00				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_1
      3  3b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$38,$7c,$7c,$7c,$7c,$7c,$7c,$38	;PF1
      5  3b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3b48					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm"
      0  3b48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_2", 72
     12  3b48					      LIST	ON
      0  3b48					      DEF	BLACK_BLANK_on_WHITE_SQUARE_2
      1  3b48				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3b48				   BANK_BLACK_BLANK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3b48				   BLACK_BLANK_on_WHITE_SQUARE_2
      4  3b48				   TEMPORARY_VAR SET	Overlay
      5  3b48				   TEMPORARY_OFFSET SET	0
      6  3b48				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3b48				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_2
      3  3b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$03,$03,$03,$01	;PF1
      5  3b78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$07,$07,$07,$07,$07,$07,$03	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3b90					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm"
      0  3b90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_3", 72
     12  3b90					      LIST	ON
      0  3b90					      DEF	BLACK_BLANK_on_WHITE_SQUARE_3
      1  3b90				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3b90				   BANK_BLACK_BLANK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3b90				   BLACK_BLANK_on_WHITE_SQUARE_3
      4  3b90				   TEMPORARY_VAR SET	Overlay
      5  3b90				   TEMPORARY_OFFSET SET	0
      6  3b90				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3b90				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_3
      3  3b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3bc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$70,$f8,$f8,$f8,$f8,$f8,$f8,$70	;PF2
------- FILE piece_graphics.asm
      0  3bd8					      CHECK_BANK_SIZE	"PIECE_4 (1K)"
      1  3bd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_4 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  3bd8					      ECHO	"PIECE_4 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  3bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3bd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_4 (1K)", " size=", * - ORIGIN
      5  3bd8				  -	      ERR
      6  3bd8					      ENDIF
      0  3bd8					      SLOT	2
      1  3bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  3bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  3bd8				  -	      ERR
      4  3bd8					      ENDIF
      5  3bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  3bd8				   _BANK_SLOT SET	2 * 64
      0  3bd8					      NEWBANK	PIECE_5
      1  3fd8 ????				      SEG	PIECE_5
      2  3c00					      ORG	_ORIGIN
      3  3c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  3c00				   _BANK_START SET	*
      5  3c00				   PIECE_5_START SET	*
      6  3c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3c00				   PIECE_5    SET	_BANK_SLOT + _CURRENT_BANK
      8  3c00				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3c00					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm"
      0  3c00					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_0", 72
     12  3c00					      LIST	ON
      0  3c00					      DEF	BLACK_PAWN_on_WHITE_SQUARE_0
      1  3c00				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3c00				   BANK_BLACK_PAWN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3c00				   BLACK_PAWN_on_WHITE_SQUARE_0
      4  3c00				   TEMPORARY_VAR SET	Overlay
      5  3c00				   TEMPORARY_OFFSET SET	0
      6  3c00				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3c00				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_0
      3  3c00		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00	;PF0
      4  3c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3c48					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm"
      0  3c48					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_1", 72
     12  3c48					      LIST	ON
      0  3c48					      DEF	BLACK_PAWN_on_WHITE_SQUARE_1
      1  3c48				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3c48				   BANK_BLACK_PAWN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3c48				   BLACK_PAWN_on_WHITE_SQUARE_1
      4  3c48				   TEMPORARY_VAR SET	Overlay
      5  3c48				   TEMPORARY_OFFSET SET	0
      6  3c48				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3c48				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_1
      3  3c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3c60		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00	;PF1
      5  3c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3c90					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm"
      0  3c90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_2", 72
     12  3c90					      LIST	ON
      0  3c90					      DEF	BLACK_PAWN_on_WHITE_SQUARE_2
      1  3c90				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3c90				   BANK_BLACK_PAWN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3c90				   BLACK_PAWN_on_WHITE_SQUARE_2
      4  3c90				   TEMPORARY_VAR SET	Overlay
      5  3c90				   TEMPORARY_OFFSET SET	0
      6  3c90				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3c90				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_2
      3  3c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ca8		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  3cc0		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3cd8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm"
      0  3cd8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_3", 72
     12  3d00					      LIST	ON
      0  3d00					      DEF	BLACK_PAWN_on_WHITE_SQUARE_3
      1  3d00				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3d00				   BANK_BLACK_PAWN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3d00				   BLACK_PAWN_on_WHITE_SQUARE_3
      4  3d00				   TEMPORARY_VAR SET	Overlay
      5  3d00				   TEMPORARY_OFFSET SET	0
      6  3d00				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3d00				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_3
      3  3d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d30		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3d48					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  3d48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_0", 72
     12  3d48					      LIST	ON
      0  3d48					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_0
      1  3d48				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3d48				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3d48				   BLACK_KNIGHT_on_WHITE_SQUARE_0
      4  3d48				   TEMPORARY_VAR SET	Overlay
      5  3d48				   TEMPORARY_OFFSET SET	0
      6  3d48				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3d48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_0
      3  3d48		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$e0,$70,$e0,$c0,$f0,$b0,$40,$00	;PF0
      4  3d60		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  3d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3d90					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  3d90					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_1", 72
     12  3d90					      LIST	ON
      0  3d90					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_1
      1  3d90				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3d90				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3d90				   BLACK_KNIGHT_on_WHITE_SQUARE_1
      4  3d90				   TEMPORARY_VAR SET	Overlay
      5  3d90				   TEMPORARY_OFFSET SET	0
      6  3d90				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3d90				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_1
      3  3d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3da8		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$38,$70,$38,$1c,$7c,$6c,$14,$00	;PF1
      5  3dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3dd8					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  3dd8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_2", 72
     12  3e00					      LIST	ON
      0  3e00					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_2
      1  3e00				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3e00				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3e00				   BLACK_KNIGHT_on_WHITE_SQUARE_2
      4  3e00				   TEMPORARY_VAR SET	Overlay
      5  3e00				   TEMPORARY_OFFSET SET	0
      6  3e00				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3e00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_2
      3  3e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e18		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$01,$03,$01,$00,$03,$03,$00,$00	;PF1
      5  3e30		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$03,$01,$03,$07,$07,$06,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3e48					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  3e48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_3", 72
     12  3e48					      LIST	ON
      0  3e48					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_3
      1  3e48				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3e48				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3e48				   BLACK_KNIGHT_on_WHITE_SQUARE_3
      4  3e48				   TEMPORARY_VAR SET	Overlay
      5  3e48				   TEMPORARY_OFFSET SET	0
      6  3e48				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3e48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_3
      3  3e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e78		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$70,$38,$70,$e0,$f8,$d8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3e90					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm"
      0  3e90					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_0", 72
     12  3e90					      LIST	ON
      0  3e90					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_0
      1  3e90				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3e90				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3e90				   BLACK_BISHOP_on_WHITE_SQUARE_0
      4  3e90				   TEMPORARY_VAR SET	Overlay
      5  3e90				   TEMPORARY_OFFSET SET	0
      6  3e90				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3e90				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_0
      3  3e90		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$e0,$e0,$f0,$b0,$d0,$e0,$00,$40	;PF0
      4  3ea8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  3ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ed8					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm"
      0  3ed8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_1", 72
     12  3f00					      LIST	ON
      0  3f00					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_1
      1  3f00				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3f00				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3f00				   BLACK_BISHOP_on_WHITE_SQUARE_1
      4  3f00				   TEMPORARY_VAR SET	Overlay
      5  3f00				   TEMPORARY_OFFSET SET	0
      6  3f00				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3f00				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_1
      3  3f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f18		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$38,$38,$78,$6c,$5c,$38,$00,$10	;PF1
      5  3f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3f48					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm"
      0  3f48					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_2", 72
     12  3f48					      LIST	ON
      0  3f48					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_2
      1  3f48				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3f48				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3f48				   BLACK_BISHOP_on_WHITE_SQUARE_2
      4  3f48				   TEMPORARY_VAR SET	Overlay
      5  3f48				   TEMPORARY_OFFSET SET	0
      6  3f48				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3f48				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_2
      3  3f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f60		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$01,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  3f78		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$03,$03,$03,$06,$07,$03,$00,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3f90					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm"
      0  3f90					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_3", 72
     12  3f90					      LIST	ON
      0  3f90					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_3
      1  3f90				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3f90				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3f90				   BLACK_BISHOP_on_WHITE_SQUARE_3
      4  3f90				   TEMPORARY_VAR SET	Overlay
      5  3f90				   TEMPORARY_OFFSET SET	0
      6  3f90				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3f90				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_3
      3  3f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3fc0		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$70,$70,$78,$d8,$e8,$70,$00,$20	;PF2
------- FILE piece_graphics.asm
      0  3fd8					      CHECK_BANK_SIZE	"PIECE_5 (1K)"
      1  3fd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_5 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  3fd8					      ECHO	"PIECE_5 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  3fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3fd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_5 (1K)", " size=", * - ORIGIN
      5  3fd8				  -	      ERR
      6  3fd8					      ENDIF
      0  3fd8					      SLOT	2
      1  3fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  3fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  3fd8				  -	      ERR
      4  3fd8					      ENDIF
      5  3fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  3fd8				   _BANK_SLOT SET	2 * 64
      0  3fd8					      NEWBANK	PIECE_6
      1  4390 ????				      SEG	PIECE_6
      2  4000					      ORG	_ORIGIN
      3  4000					      RORG	_BANK_ADDRESS_ORIGIN
      4  4000				   _BANK_START SET	*
      5  4000				   PIECE_6_START SET	*
      6  4000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4000				   PIECE_6    SET	_BANK_SLOT + _CURRENT_BANK
      8  4000				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4000					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm"
      0  4000					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_0", 72
     12  4000					      LIST	ON
      0  4000					      DEF	BLACK_ROOK_on_WHITE_SQUARE_0
      1  4000				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4000				   BANK_BLACK_ROOK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4000				   BLACK_ROOK_on_WHITE_SQUARE_0
      4  4000				   TEMPORARY_VAR SET	Overlay
      5  4000				   TEMPORARY_OFFSET SET	0
      6  4000				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4000				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_0
      3  4000		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$e0,$e0,$e0,$e0,$f0,$50,$50,$00	;PF0
      4  4018		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  4030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4048					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm"
      0  4048					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_1", 72
     12  4048					      LIST	ON
      0  4048					      DEF	BLACK_ROOK_on_WHITE_SQUARE_1
      1  4048				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4048				   BANK_BLACK_ROOK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4048				   BLACK_ROOK_on_WHITE_SQUARE_1
      4  4048				   TEMPORARY_VAR SET	Overlay
      5  4048				   TEMPORARY_OFFSET SET	0
      6  4048				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4048				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_1
      3  4048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4060		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$38,$38,$38,$38,$7c,$54,$54,$00	;PF1
      5  4078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4090					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm"
      0  4090					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_2", 72
     12  4090					      LIST	ON
      0  4090					      DEF	BLACK_ROOK_on_WHITE_SQUARE_2
      1  4090				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4090				   BANK_BLACK_ROOK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4090				   BLACK_ROOK_on_WHITE_SQUARE_2
      4  4090				   TEMPORARY_VAR SET	Overlay
      5  4090				   TEMPORARY_OFFSET SET	0
      6  4090				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4090				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_2
      3  4090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  40a8		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$01,$01,$01,$01,$03,$02,$02,$00	;PF1
      5  40c0		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$03,$03,$03,$03,$07,$05,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  40d8					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm"
      0  40d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_3", 72
     12  4100					      LIST	ON
      0  4100					      DEF	BLACK_ROOK_on_WHITE_SQUARE_3
      1  4100				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4100				   BANK_BLACK_ROOK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4100				   BLACK_ROOK_on_WHITE_SQUARE_3
      4  4100				   TEMPORARY_VAR SET	Overlay
      5  4100				   TEMPORARY_OFFSET SET	0
      6  4100				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4100				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_3
      3  4100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4130		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$70,$70,$70,$70,$f8,$a8,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4148					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm"
      0  4148					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_0", 72
     12  4148					      LIST	ON
      0  4148					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_0
      1  4148				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4148				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4148				   BLACK_QUEEN_on_WHITE_SQUARE_0
      4  4148				   TEMPORARY_VAR SET	Overlay
      5  4148				   TEMPORARY_OFFSET SET	0
      6  4148				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4148				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_0
      3  4148		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  4160		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$80,$80,$00,$80,$00	;PF1
      5  4178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4190					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm"
      0  4190					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_1", 72
     12  4190					      LIST	ON
      0  4190					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_1
      1  4190				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4190				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4190				   BLACK_QUEEN_on_WHITE_SQUARE_1
      4  4190				   TEMPORARY_VAR SET	Overlay
      5  4190				   TEMPORARY_OFFSET SET	0
      6  4190				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4190				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_1
      3  4190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  41a8		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$78,$7c,$54,$00,$54,$00	;PF1
      5  41c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  41d8					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm"
      0  41d8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_2", 72
     12  4200					      LIST	ON
      0  4200					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_2
      1  4200				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4200				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4200				   BLACK_QUEEN_on_WHITE_SQUARE_2
      4  4200				   TEMPORARY_VAR SET	Overlay
      5  4200				   TEMPORARY_OFFSET SET	0
      6  4200				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4200				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_2
      3  4200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4218		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  4230		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$03,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4248					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm"
      0  4248					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_3", 72
     12  4248					      LIST	ON
      0  4248					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_3
      1  4248				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4248				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4248				   BLACK_QUEEN_on_WHITE_SQUARE_3
      4  4248				   TEMPORARY_VAR SET	Overlay
      5  4248				   TEMPORARY_OFFSET SET	0
      6  4248				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4248				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_3
      3  4248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4278		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$78,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4290					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_0.asm"
      0  4290					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_0", 72
     12  4290					      LIST	ON
      0  4290					      DEF	BLACK_KING_on_WHITE_SQUARE_0
      1  4290				   SLOT_BLACK_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4290				   BANK_BLACK_KING_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4290				   BLACK_KING_on_WHITE_SQUARE_0
      4  4290				   TEMPORARY_VAR SET	Overlay
      5  4290				   TEMPORARY_OFFSET SET	0
      6  4290				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4290				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_0
      3  4290		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$f0,$40,$e0,$40	;PF0
      4  42a8		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  42c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  42d8					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_1.asm"
      0  42d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_1", 72
     12  4300					      LIST	ON
      0  4300					      DEF	BLACK_KING_on_WHITE_SQUARE_1
      1  4300				   SLOT_BLACK_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4300				   BANK_BLACK_KING_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4300				   BLACK_KING_on_WHITE_SQUARE_1
      4  4300				   TEMPORARY_VAR SET	Overlay
      5  4300				   TEMPORARY_OFFSET SET	0
      6  4300				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4300				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_1
      3  4300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4318		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$7c,$10,$38,$10	;PF1
      5  4330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4348					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_2.asm"
      0  4348					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_2", 72
     12  4348					      LIST	ON
      0  4348					      DEF	BLACK_KING_on_WHITE_SQUARE_2
      1  4348				   SLOT_BLACK_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4348				   BANK_BLACK_KING_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4348				   BLACK_KING_on_WHITE_SQUARE_2
      4  4348				   TEMPORARY_VAR SET	Overlay
      5  4348				   TEMPORARY_OFFSET SET	0
      6  4348				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4348				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_2
      3  4348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4360		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  4378		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$07,$01,$03,$01	;PF2
------- FILE piece_graphics.asm
      0  4390					      CHECK_BANK_SIZE	"PIECE_6 (1K)"
      1  4390		       03 90	   .TEMP      =	* - _BANK_START
 PIECE_6 (1K) (1K) SIZE =  $390 , FREE= $70
      2  4390					      ECHO	"PIECE_6 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4390				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4390				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_6 (1K)", " size=", * - ORIGIN
      5  4390				  -	      ERR
      6  4390					      ENDIF
      0  4390					      SLOT	2
      1  4390				  -	      IF	(2 < 0) || (2 > 3)
      2  4390				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4390				  -	      ERR
      4  4390					      ENDIF
      5  4390				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4390				   _BANK_SLOT SET	2 * 64
      0  4390					      NEWBANK	PIECE_7
      1  4848 ????				      SEG	PIECE_7
      2  4400					      ORG	_ORIGIN
      3  4400					      RORG	_BANK_ADDRESS_ORIGIN
      4  4400				   _BANK_START SET	*
      5  4400				   PIECE_7_START SET	*
      6  4400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4400				   PIECE_7    SET	_BANK_SLOT + _CURRENT_BANK
      8  4400				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4400					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_3.asm"
      0  4400					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_3", 72
     12  4400					      LIST	ON
      0  4400					      DEF	BLACK_KING_on_WHITE_SQUARE_3
      1  4400				   SLOT_BLACK_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4400				   BANK_BLACK_KING_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4400				   BLACK_KING_on_WHITE_SQUARE_3
      4  4400				   TEMPORARY_VAR SET	Overlay
      5  4400				   TEMPORARY_OFFSET SET	0
      6  4400				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4400				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_3
      3  4400		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4430		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$f8,$20,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4448					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm"
      0  4448					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_0", 72
     12  4448					      LIST	ON
      0  4448					      DEF	BLACK_BLANK_on_BLACK_SQUARE_0
      1  4448				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4448				   BANK_BLACK_BLANK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4448				   BLACK_BLANK_on_BLACK_SQUARE_0
      4  4448				   TEMPORARY_VAR SET	Overlay
      5  4448				   TEMPORARY_OFFSET SET	0
      6  4448				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4448				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_0
      3  4448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4460		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4490					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm"
      0  4490					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_1", 72
     12  4490					      LIST	ON
      0  4490					      DEF	BLACK_BLANK_on_BLACK_SQUARE_1
      1  4490				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4490				   BANK_BLACK_BLANK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4490				   BLACK_BLANK_on_BLACK_SQUARE_1
      4  4490				   TEMPORARY_VAR SET	Overlay
      5  4490				   TEMPORARY_OFFSET SET	0
      6  4490				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4490				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_1
      3  4490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  44a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  44c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  44d8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm"
      0  44d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_2", 72
     12  4500					      LIST	ON
      0  4500					      DEF	BLACK_BLANK_on_BLACK_SQUARE_2
      1  4500				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4500				   BANK_BLACK_BLANK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4500				   BLACK_BLANK_on_BLACK_SQUARE_2
      4  4500				   TEMPORARY_VAR SET	Overlay
      5  4500				   TEMPORARY_OFFSET SET	0
      6  4500				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4500				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_2
      3  4500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4530		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4548					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm"
      0  4548					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_3", 72
     12  4548					      LIST	ON
      0  4548					      DEF	BLACK_BLANK_on_BLACK_SQUARE_3
      1  4548				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4548				   BANK_BLACK_BLANK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4548				   BLACK_BLANK_on_BLACK_SQUARE_3
      4  4548				   TEMPORARY_VAR SET	Overlay
      5  4548				   TEMPORARY_OFFSET SET	0
      6  4548				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4548				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_3
      3  4548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4590					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm"
      0  4590					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_0", 72
     12  4590					      LIST	ON
      0  4590					      DEF	BLACK_PAWN_on_BLACK_SQUARE_0
      1  4590				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4590				   BANK_BLACK_PAWN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4590				   BLACK_PAWN_on_BLACK_SQUARE_0
      4  4590				   TEMPORARY_VAR SET	Overlay
      5  4590				   TEMPORARY_OFFSET SET	0
      6  4590				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4590				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_0
      3  4590		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$40,$00,$00	;PF0
      4  45a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  45c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  45d8					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm"
      0  45d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_1", 72
     12  4600					      LIST	ON
      0  4600					      DEF	BLACK_PAWN_on_BLACK_SQUARE_1
      1  4600				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4600				   BANK_BLACK_PAWN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4600				   BLACK_PAWN_on_BLACK_SQUARE_1
      4  4600				   TEMPORARY_VAR SET	Overlay
      5  4600				   TEMPORARY_OFFSET SET	0
      6  4600				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4600				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_1
      3  4600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4618		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$00,$00,$00,$00,$10,$00,$00	;PF1
      5  4630		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4648					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm"
      0  4648					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_2", 72
     12  4648					      LIST	ON
      0  4648					      DEF	BLACK_PAWN_on_BLACK_SQUARE_2
      1  4648				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4648				   BANK_BLACK_PAWN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4648				   BLACK_PAWN_on_BLACK_SQUARE_2
      4  4648				   TEMPORARY_VAR SET	Overlay
      5  4648				   TEMPORARY_OFFSET SET	0
      6  4648				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4648				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_2
      3  4648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4660		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4678		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4690					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm"
      0  4690					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_3", 72
     12  4690					      LIST	ON
      0  4690					      DEF	BLACK_PAWN_on_BLACK_SQUARE_3
      1  4690				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4690				   BANK_BLACK_PAWN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4690				   BLACK_PAWN_on_BLACK_SQUARE_3
      4  4690				   TEMPORARY_VAR SET	Overlay
      5  4690				   TEMPORARY_OFFSET SET	0
      6  4690				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4690				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_3
      3  4690		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  46a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  46c0		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$00,$00,$00,$00,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  46d8					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  46d8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_0", 72
     12  4700					      LIST	ON
      0  4700					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_0
      1  4700				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4700				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4700				   BLACK_KNIGHT_on_BLACK_SQUARE_0
      4  4700				   TEMPORARY_VAR SET	Overlay
      5  4700				   TEMPORARY_OFFSET SET	0
      6  4700				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4700				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_0
      3  4700		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$40,$00,$00	;PF0
      4  4718		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4748					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  4748					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_1", 72
     12  4748					      LIST	ON
      0  4748					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_1
      1  4748				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4748				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4748				   BLACK_KNIGHT_on_BLACK_SQUARE_1
      4  4748				   TEMPORARY_VAR SET	Overlay
      5  4748				   TEMPORARY_OFFSET SET	0
      6  4748				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4748				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_1
      3  4748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4760		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$10,$00,$00	;PF1
      5  4778		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4790					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  4790					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_2", 72
     12  4790					      LIST	ON
      0  4790					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_2
      1  4790				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4790				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4790				   BLACK_KNIGHT_on_BLACK_SQUARE_2
      4  4790				   TEMPORARY_VAR SET	Overlay
      5  4790				   TEMPORARY_OFFSET SET	0
      6  4790				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4790				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_2
      3  4790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  47a8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  47c0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  47d8					      CHECK_BANK_SIZE	"PIECE_7 (1K)"
      1  47d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_7 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  47d8					      ECHO	"PIECE_7 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  47d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  47d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_7 (1K)", " size=", * - ORIGIN
      5  47d8				  -	      ERR
      6  47d8					      ENDIF
      0  47d8					      SLOT	2
      1  47d8				  -	      IF	(2 < 0) || (2 > 3)
      2  47d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  47d8				  -	      ERR
      4  47d8					      ENDIF
      5  47d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  47d8				   _BANK_SLOT SET	2 * 64
      0  47d8					      NEWBANK	PIECE_7
      1  47d8					      SEG	PIECE_7
      2  4800					      ORG	_ORIGIN
      3  4800					      RORG	_BANK_ADDRESS_ORIGIN
      4  4800				   _BANK_START SET	*
      5  4800				   PIECE_7_START SET	*
      6  4800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4800				   PIECE_7    SET	_BANK_SLOT + _CURRENT_BANK
      8  4800				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4800					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  4800					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_3", 72
     12  4800					      LIST	ON
      0  4800					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_3
      1  4800				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4800				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4800				   BLACK_KNIGHT_on_BLACK_SQUARE_3
      4  4800				   TEMPORARY_VAR SET	Overlay
      5  4800				   TEMPORARY_OFFSET SET	0
      6  4800				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4800				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_3
      3  4800		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4830		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
    127  4848
    128  4848							;    CHECK_BANK_SIZE "PIECES_4 (2K)"
    129  4848
    130  4848							;    NEWBANK PIECES_5
    131  4848
    132  4848							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
    133  4848							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
    134  4848							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
    135  4848							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
    136  4848							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
    137  4848							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
    138  4848							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
    139  4848							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
    140  4848
    141  4848
    142  4848				  -	      IF	0
    143  4848				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    144  4848				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    145  4848				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    146  4848				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    147  4848				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    148  4848				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    149  4848				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    150  4848				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    151  4848				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    152  4848				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    153  4848				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    154  4848				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    155  4848				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    156  4848				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    157  4848				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    158  4848				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    159  4848					      ENDIF
    160  4848
    161  4848							;    CHECK_BANK_SIZE "PIECES_5 (2K)"
    162  4848
    163  4848				  -	      IF	0
    164  4848				  -	      NEWBANK	PIECES_6
    165  4848				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    166  4848				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    167  4848				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    168  4848				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    169  4848				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    170  4848				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    171  4848				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    172  4848				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    173  4848				  -
    174  4848				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_0.asm"
    175  4848				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_1.asm"
    176  4848				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_2.asm"
    177  4848				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_3.asm"
    178  4848				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    179  4848				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    180  4848				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    181  4848				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    182  4848				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    183  4848				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    184  4848				  -
    185  4848				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    186  4848				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    187  4848				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    188  4848				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    189  4848				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    190  4848				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    191  4848				  -	      CHECK_BANK_SIZE	"PIECES_6 (2K)"
    192  4848				  -
    193  4848				  -
    194  4848				  -	      NEWBANK	PIECES_7
    195  4848				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    196  4848				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    197  4848				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    198  4848				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    199  4848				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    200  4848				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    201  4848				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    202  4848				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    203  4848				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    204  4848				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    205  4848				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    206  4848				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    207  4848				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_0.asm"
    208  4848				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_1.asm"
    209  4848				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_2.asm"
    210  4848				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_3.asm"
    211  4848				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    212  4848				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    213  4848				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    214  4848				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    215  4848				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    216  4848				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    217  4848				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    218  4848				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    219  4848				  -	      CHECK_BANK_SIZE	"PIECES_7 (2K)"
    220  4848				  -
    221  4848				  -
    222  4848				  -	      NEWBANK	PIECES_8
    223  4848				  -
    224  4848				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    225  4848				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    226  4848				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    227  4848				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    228  4848				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    229  4848				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    230  4848				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    231  4848				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    232  4848				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    233  4848				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    234  4848				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    235  4848				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    236  4848				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    237  4848				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    238  4848				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    239  4848				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    240  4848				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_0.asm"
    241  4848				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_1.asm"
    242  4848				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_2.asm"
    243  4848				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_3.asm"
    244  4848				  -
    245  4848				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    246  4848				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    247  4848				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    248  4848				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    249  4848				  -	      CHECK_BANK_SIZE	"PIECES_8 (2K)"
    250  4848				  -
    251  4848					      ENDIF
    252  4848
    253  4848							;    NEWBANK PIECES_9
    254  4848
    255  4848							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    256  4848							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    257  4848							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    258  4848							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    259  4848							; include "gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    260  4848
    261  4848				  -	      IF	0
    262  4848				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    263  4848				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    264  4848				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    265  4848					      ENDIF
    266  4848
    267  4848							;    CHECK_BANK_SIZE "PIECES_9 (2K)"
    268  4848
    269  4848				  -	      IF	0
    270  4848				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    271  4848				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    272  4848				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    273  4848				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    274  4848				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    275  4848				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    276  4848				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    277  4848				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    278  4848				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    279  4848				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    280  4848				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    281  4848				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    282  4848				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_0.asm"
    283  4848				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_1.asm"
    284  4848				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_2.asm"
    285  4848				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_3.asm"
    286  4848					      ENDIF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@2.asm LEVEL 2 PASS 4
      0  4848					      include	"BANK_GENERIC@2.asm"
      1  4848
      0  4848					      SLOT	2
      1  4848				  -	      IF	(2 < 0) || (2 > 3)
      2  4848				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4848				  -	      ERR
      4  4848					      ENDIF
      5  4848				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4848				   _BANK_SLOT SET	2 * 64
      0  4848					      NEWBANK	GENERIC_BANK@2
      1  4e53 ????				      SEG	GENERIC_BANK@2
      2  4c00					      ORG	_ORIGIN
      3  4c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  4c00				   _BANK_START SET	*
      5  4c00				   GENERIC_BANK@2_START SET	*
      6  4c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4c00				   GENERIC_BANK@2 SET	_BANK_SLOT + _CURRENT_BANK
      8  4c00				   _ORIGIN    SET	_ORIGIN + 1024
      4  4c00
      5  4c00							;    DEFINE_1K_SEGMENT DECODE_LEVEL_SHADOW
      6  4c00
      7  4c00				  -	      IF	0
      8  4c00				  -	      IF	PLUSCART = YES
      9  4c00				  -	      .byte	"ChessAPI.php", #0 //TODO: change!
     10  4c00				  -	      .byte	"pluscart.firmaplus.de", #0
     11  4c00				  -	      ENDIF
     12  4c00					      ENDIF
     13  4c00
     14  4c00							;STELLA_AUTODETECT .byte $85,$3e,$a9,$00 ; 3E
     15  4c00
     16  4c00
     17  4c00
     18  4c00
     19  4c00							;---------------------------------------------------------------------------------------------------
     20  4c00
      0  4c00					      DEF	tidySc
      1  4c00				   SLOT_tidySc SET	_BANK_SLOT
      2  4c00				   BANK_tidySc SET	SLOT_tidySc + _CURRENT_BANK
      3  4c00				   tidySc
      4  4c00				   TEMPORARY_VAR SET	Overlay
      5  4c00				   TEMPORARY_OFFSET SET	0
      6  4c00				   VAR_BOUNDARY_tidySc SET	TEMPORARY_OFFSET
      7  4c00				   FUNCTION_NAME SET	tidySc
     22  4c00					      SUBROUTINE
     23  4c00
     24  4c00		       a9 00		      lda	#0
     25  4c02		       85 4d		      sta	PF0
     26  4c04		       85 4e		      sta	PF1
     27  4c06		       85 4f		      sta	PF2
     28  4c08		       85 5b		      sta	GRP0
     29  4c0a		       85 5c		      sta	GRP1
     30  4c0c
     31  4c0c		       a9 42		      lda	#%01000010	; bit6 is not required
     32  4c0e							;sta VBLANK			  ; end of screen - enter blanking
     33  4c0e
     34  4c0e
     35  4c0e							; END OF VISIBLE SCREEN
     36  4c0e							; HERE'S SOME TIME TO DO STUFF
     37  4c0e
     38  4c0e		       a9 2e		      lda	#TIME_PART_2
     39  4c10		       8d 96 02 	      sta	TIM64T
     40  4c13		       60		      rts
     41  4c14
     42  4c14
     43  4c14							;---------------------------------------------------------------------------------------------------
     44  4c14
      0  4c14					      DEF	longD
      1  4c14				   SLOT_longD SET	_BANK_SLOT
      2  4c14				   BANK_longD SET	SLOT_longD + _CURRENT_BANK
      3  4c14				   longD
      4  4c14				   TEMPORARY_VAR SET	Overlay
      5  4c14				   TEMPORARY_OFFSET SET	0
      6  4c14				   VAR_BOUNDARY_longD SET	TEMPORARY_OFFSET
      7  4c14				   FUNCTION_NAME SET	longD
     46  4c14					      SUBROUTINE
     47  4c14
     48  4c14		       85 42		      sta	WSYNC
     49  4c16
     50  4c16		       20 27 f8 	      jsr	_rts
     51  4c19		       20 27 f8 	      jsr	_rts
     52  4c1c		       20 27 f8 	      jsr	_rts
      0  4c1f					      SLEEP	7
      1  4c1f				   .CYCLES    SET	7
      2  4c1f
      3  4c1f				  -	      IF	.CYCLES < 2
      4  4c1f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4c1f				  -	      ERR
      6  4c1f					      ENDIF
      7  4c1f
      8  4c1f					      IF	.CYCLES & 1
      9  4c1f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4c1f		       04 00		      nop	0
     11  4c21				  -	      ELSE
     12  4c21				  -	      bit	VSYNC
     13  4c21					      ENDIF
     14  4c21				   .CYCLES    SET	.CYCLES - 3
     15  4c21					      ENDIF
     16  4c21
     17  4c21					      REPEAT	.CYCLES / 2
     18  4c21		       ea		      nop
     17  4c21					      REPEND
     18  4c22		       ea		      nop
     19  4c23					      REPEND
     54  4c23
     55  4c23		       a2 00		      ldx	#0
     56  4c25		       86 41		      stx	VBLANK
     57  4c27		       60	   _rts       rts
     58  4c28
     59  4c28				  -	      IF	0
     60  4c28				  -	      DEF	Resync
     61  4c28				  -	      SUBROUTINE
     62  4c28				  -
     63  4c28				  -	      RESYNC
     64  4c28				  -	      rts
     65  4c28					      ENDIF
     66  4c28
     67  4c28
     68  4c28							;---------------------------------------------------------------------------------------------------
     69  4c28
      0  4c28					      DEF	aiStartClearBoard
      1  4c28				   SLOT_aiStartClearBoard SET	_BANK_SLOT
      2  4c28				   BANK_aiStartClearBoard SET	SLOT_aiStartClearBoard + _CURRENT_BANK
      3  4c28				   aiStartClearBoard
      4  4c28				   TEMPORARY_VAR SET	Overlay
      5  4c28				   TEMPORARY_OFFSET SET	0
      6  4c28				   VAR_BOUNDARY_aiStartClearBoard SET	TEMPORARY_OFFSET
      7  4c28				   FUNCTION_NAME SET	aiStartClearBoard
     71  4c28					      SUBROUTINE
     72  4c28
      0  4c28					      REFER	AiStateMachine
      1  4c28				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  4c28				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  4c28					      ENDIF
      0  4c28					      VEND	aiStartClearBoard
      1  4c28				  -	      IFNCONST	aiStartClearBoard
      2  4c28				  -	      ECHO	"Incorrect VEND label", aiStartClearBoard
      3  4c28				  -	      ERR
      4  4c28					      ENDIF
      5  4c28		       00 a1	   VAREND_aiStartClearBoard =	TEMPORARY_VAR
     75  4c28
     76  4c28		       a2 08		      ldx	#8
     77  4c2a		       86 84		      stx	drawCount	; = bank
     78  4c2c
     79  4c2c		       a9 ff		      lda	#-1
     80  4c2e		       85 88		      sta	cursorX12
     81  4c30
      0  4c30					      PHASE	AI_ClearEachRow
      1  4c30		       a9 0e		      lda	#AI_ClearEachRow
      2  4c32		       85 8b		      sta	aiState
     83  4c34		       60		      rts
     84  4c35
     85  4c35							;---------------------------------------------------------------------------------------------------
     86  4c35
      0  4c35					      DEF	aiClearEachRow
      1  4c35				   SLOT_aiClearEachRow SET	_BANK_SLOT
      2  4c35				   BANK_aiClearEachRow SET	SLOT_aiClearEachRow + _CURRENT_BANK
      3  4c35				   aiClearEachRow
      4  4c35				   TEMPORARY_VAR SET	Overlay
      5  4c35				   TEMPORARY_OFFSET SET	0
      6  4c35				   VAR_BOUNDARY_aiClearEachRow SET	TEMPORARY_OFFSET
      7  4c35				   FUNCTION_NAME SET	aiClearEachRow
     88  4c35					      SUBROUTINE
     89  4c35
      0  4c35					      REFER	AiStateMachine
      1  4c35				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  4c35				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  4c35					      ENDIF
      0  4c35					      VEND	aiClearEachRow
      1  4c35				  -	      IFNCONST	aiClearEachRow
      2  4c35				  -	      ECHO	"Incorrect VEND label", aiClearEachRow
      3  4c35				  -	      ERR
      4  4c35					      ENDIF
      5  4c35		       00 a1	   VAREND_aiClearEachRow =	TEMPORARY_VAR
     92  4c35
     93  4c35		       c6 84		      dec	drawCount
     94  4c37		       30 00		      bmi	.bitmapCleared
     95  4c39							;TODOldy drawCount
     96  4c39							;TODO jmp CallClear
     97  4c39
     98  4c39				   .bitmapCleared
     99  4c39
    100  4c39		       a9 63		      lda	#99
    101  4c3b		       85 80		      sta	squareToDraw
    102  4c3d
      0  4c3d					      PHASE	AI_DrawEntireBoard
      1  4c3d		       a9 0f		      lda	#AI_DrawEntireBoard
      2  4c3f		       85 8b		      sta	aiState
    104  4c41		       60		      rts
    105  4c42
    106  4c42
    107  4c42
    108  4c42							;---------------------------------------------------------------------------------------------------
    109  4c42
      0  4c42					      DEF	aiMoveIsSelected
      1  4c42				   SLOT_aiMoveIsSelected SET	_BANK_SLOT
      2  4c42				   BANK_aiMoveIsSelected SET	SLOT_aiMoveIsSelected + _CURRENT_BANK
      3  4c42				   aiMoveIsSelected
      4  4c42				   TEMPORARY_VAR SET	Overlay
      5  4c42				   TEMPORARY_OFFSET SET	0
      6  4c42				   VAR_BOUNDARY_aiMoveIsSelected SET	TEMPORARY_OFFSET
      7  4c42				   FUNCTION_NAME SET	aiMoveIsSelected
    111  4c42					      SUBROUTINE
    112  4c42
      0  4c42					      REFER	AiStateMachine
      1  4c42				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  4c42				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  4c42					      ENDIF
      0  4c42					      VEND	aiMoveIsSelected
      1  4c42				  -	      IFNCONST	aiMoveIsSelected
      2  4c42				  -	      ECHO	"Incorrect VEND label", aiMoveIsSelected
      3  4c42				  -	      ERR
      4  4c42					      ENDIF
      5  4c42		       00 a1	   VAREND_aiMoveIsSelected =	TEMPORARY_VAR
    115  4c42
    116  4c42
    117  4c42							; Both computer and human have now seleted a move, and converge here
    118  4c42
    119  4c42
    120  4c42							; fromPiece	 piece doing the move
    121  4c42							; fromX12	 current square X12
    122  4c42							; originX12	 starting square X12
    123  4c42							; toX12	 ending square X12
    124  4c42
      0  4c42					      CALL	AdjustMaterialPositionalValue	;@1
      1  4c42				  -	      IF	SLOT_AdjustMaterialPositionalValue == _BANK_SLOT
      2  4c42				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  4c42				  -	      ECHO	"Cannot switch bank in use for", AdjustMaterialPositionalValue
      4  4c42				  -	      ERR
      5  4c42					      ENDIF
      6  4c42		       a9 41		      lda	#BANK_AdjustMaterialPositionalValue
      7  4c44		       85 3f		      sta	SET_BANK
      8  4c46		       20 33 f5 	      jsr	AdjustMaterialPositionalValue
    126  4c49
    127  4c49		       a9 00		      lda	#0
    128  4c4b		       85 98		      sta	previousPiece
    129  4c4d		       85 82		      sta	drawDelay
    130  4c4f
    131  4c4f		       a9 0a		      lda	#10	; on/off count
    132  4c51		       85 84		      sta	drawCount	; flashing for piece about to move
    133  4c53
      0  4c53					      PHASE	AI_WriteStartPieceBlank
      1  4c53		       a9 15		      lda	#AI_WriteStartPieceBlank
      2  4c55		       85 8b		      sta	aiState
    135  4c57		       60	   .idleErase rts
    136  4c58
    137  4c58
    138  4c58							;---------------------------------------------------------------------------------------------------
    139  4c58
      0  4c58					      DEF	CopySetup	;@2 - uses @3
      1  4c58				   SLOT_CopySetup SET	_BANK_SLOT
      2  4c58				   BANK_CopySetup SET	SLOT_CopySetup + _CURRENT_BANK
      3  4c58				   CopySetup
      4  4c58				   TEMPORARY_VAR SET	Overlay
      5  4c58				   TEMPORARY_OFFSET SET	0
      6  4c58				   VAR_BOUNDARY_CopySetup SET	TEMPORARY_OFFSET
      7  4c58				   FUNCTION_NAME SET	CopySetup
    141  4c58					      SUBROUTINE
    142  4c58
      0  4c58					      REFER	CopySinglePiece
      1  4c58					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  4c58				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  4c58					      ENDIF
      0  4c58					      VAR	__tmp, 1
      1  4c58		       00 ad	   __tmp      =	TEMPORARY_VAR
      2  4c58				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4c58
      4  4c58				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4c58				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4c58				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4c58					      ENDIF
      8  4c58				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4c58				  -	      ECHO	"Temporary Variable", __tmp, "overflow!"
     10  4c58				  -	      ERR
     11  4c58					      ENDIF
     12  4c58					      LIST	ON
      0  4c58					      VAR	__shiftx, 1
      1  4c58		       00 ae	   __shiftx   =	TEMPORARY_VAR
      2  4c58				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4c58
      4  4c58				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4c58				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4c58				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4c58					      ENDIF
      8  4c58				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4c58				  -	      ECHO	"Temporary Variable", __shiftx, "overflow!"
     10  4c58				  -	      ERR
     11  4c58					      ENDIF
     12  4c58					      LIST	ON
      0  4c58					      VAR	__pieceColour2, 1
      1  4c58		       00 af	   __pieceColour2 =	TEMPORARY_VAR
      2  4c58				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4c58
      4  4c58				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4c58				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4c58				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4c58					      ENDIF
      8  4c58				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4c58				  -	      ECHO	"Temporary Variable", __pieceColour2, "overflow!"
     10  4c58				  -	      ERR
     11  4c58					      ENDIF
     12  4c58					      LIST	ON
      0  4c58					      VEND	CopySetup
      1  4c58				  -	      IFNCONST	CopySetup
      2  4c58				  -	      ECHO	"Incorrect VEND label", CopySetup
      3  4c58				  -	      ERR
      4  4c58					      ENDIF
      5  4c58		       00 b0	   VAREND_CopySetup =	TEMPORARY_VAR
    148  4c58
    149  4c58							; figure colouration of square
    150  4c58
    151  4c58		       a5 80		      lda	squareToDraw
    152  4c5a
    153  4c5a				  -	      IF	DIAGNOSTICS
    154  4c5a				  -			; Catch out-of-range piece square
    155  4c5a				  -			; will not catch off left/right edge
    156  4c5a				  -
    157  4c5a				  -.fail      cmp	#100
    158  4c5a				  -	      bcs	.fail
    159  4c5a				  -	      cmp	#22
    160  4c5a				  -	      bcc	.fail
    161  4c5a					      ENDIF
    162  4c5a
    163  4c5a
    164  4c5a		       a2 0a		      ldx	#10
    165  4c5c		       38		      sec
    166  4c5d		       e9 0a	   .sub10     sbc	#10
    167  4c5f		       ca		      dex
    168  4c60		       b0 fb		      bcs	.sub10
    169  4c62		       69 08		      adc	#8
    170  4c64		       85 ae		      sta	__shiftx
    171  4c66				  -	      IF	DIAGNOSTICS
    172  4c66				  -.fail2     cmp	#8
    173  4c66				  -	      bcs	.fail2
    174  4c66				  -	      cpx	#8
    175  4c66				  -	      bcs	.fail2
    176  4c66					      ENDIF
    177  4c66		       86 ad		      stx	__tmp
    178  4c68		       65 ad		      adc	__tmp
    179  4c6a
    180  4c6a
    181  4c6a		       29 01		      and	#1
    182  4c6c		       49 01		      eor	#1
    183  4c6e		       f0 02		      beq	.white
    184  4c70		       a9 24		      lda	#36
    185  4c72				   .white
    186  4c72		       85 af		      sta	__pieceColour2	; actually SQUARE black/white
    187  4c74
    188  4c74							; PieceColour = 0 for white square, 36 for black square
    189  4c74
    190  4c74		       a9 cf		      lda	#RAMBANK_BOARD
    191  4c76		       85 3e		      sta	SET_BANK_RAM	;@3
    192  4c78
    193  4c78		       a4 80		      ldy	squareToDraw
    194  4c7a		       b9 79 fc 	      lda	Board,y
    195  4c7d							;and #$87
    196  4c7d		       0a		      asl
    197  4c7e		       90 02		      bcc	.blackAdjust
    198  4c80		       09 10		      ora	#16	; switch white pieces
    199  4c82		       4a	   .blackAdjust lsr
    200  4c83		       29 0f		      and	#%1111
    201  4c85		       aa		      tax
    202  4c86
    203  4c86		       a5 ae		      lda	__shiftx
    204  4c88		       29 03		      and	#3	; shift position in P
    205  4c8a
    206  4c8a		       18		      clc
    207  4c8b		       7d 93 f8 	      adc	PieceToShape,x
    208  4c8e		       18		      clc
    209  4c8f		       65 af		      adc	__pieceColour2
    210  4c91		       a8		      tay
    211  4c92		       60		      rts
    212  4c93
    213  4c93				   PieceToShape
    214  4c93
    215  4c93		       00		      .byte.b	INDEX_WHITE_BLANK_on_WHITE_SQUARE_0
    216  4c94		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    217  4c95		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (black P)
    218  4c96		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    219  4c97		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    220  4c98		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    221  4c99		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    222  4c9a		       18		      .byte.b	INDEX_WHITE_KING_on_WHITE_SQUARE_0
    223  4c9b
    224  4c9b		       48		      .byte.b	INDEX_BLACK_BLANK_on_WHITE_SQUARE_0
    225  4c9c		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (white P)
    226  4c9d		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    227  4c9e		       50		      .byte.b	INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0
    228  4c9f		       54		      .byte.b	INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0
    229  4ca0		       58		      .byte.b	INDEX_BLACK_ROOK_on_WHITE_SQUARE_0
    230  4ca1		       5c		      .byte.b	INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    231  4ca2		       60		      .byte.b	INDEX_BLACK_KING_on_WHITE_SQUARE_0
    232  4ca3
    233  4ca3
    234  4ca3							;---------------------------------------------------------------------------------------------------
    235  4ca3
------- FILE piece_vectors.asm LEVEL 3 PASS 4
      0  4ca3					      include	"piece_vectors.asm"
      1  4ca3							; Created by ConvertChessPieces.py
      0  4ca3					      DEF	PIECE_VECTOR_LO
      1  4ca3				   SLOT_PIECE_VECTOR_LO SET	_BANK_SLOT
      2  4ca3				   BANK_PIECE_VECTOR_LO SET	SLOT_PIECE_VECTOR_LO + _CURRENT_BANK
      3  4ca3				   PIECE_VECTOR_LO
      4  4ca3				   TEMPORARY_VAR SET	Overlay
      5  4ca3				   TEMPORARY_OFFSET SET	0
      6  4ca3				   VAR_BOUNDARY_PIECE_VECTOR_LO SET	TEMPORARY_OFFSET
      7  4ca3				   FUNCTION_NAME SET	PIECE_VECTOR_LO
      3  4ca3		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_0
      4  4ca4		       48		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_1
      5  4ca5		       90		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_2
      6  4ca6		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_3
      7  4ca7		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_0
      8  4ca8		       90		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_1
      9  4ca9		       00		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_2
     10  4caa		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_3
     11  4cab		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_0
     12  4cac		       00		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_1
     13  4cad		       48		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_2
     14  4cae		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_3
     15  4caf		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_0
     16  4cb0		       48		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_1
     17  4cb1		       90		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_2
     18  4cb2		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_3
     19  4cb3		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_0
     20  4cb4		       90		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_1
     21  4cb5		       00		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_2
     22  4cb6		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_3
     23  4cb7		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_0
     24  4cb8		       00		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_1
     25  4cb9		       48		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_2
     26  4cba		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_3
     27  4cbb		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_0
     28  4cbc		       48		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_1
     29  4cbd		       90		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_2
     30  4cbe		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_3
     31  4cbf		       00		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_0
     32  4cc0		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_1
     33  4cc1		       90		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_2
     34  4cc2		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_3
     35  4cc3		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_0
     36  4cc4		       00		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_1
     37  4cc5		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_2
     38  4cc6		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_3
     39  4cc7		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_0
     40  4cc8		       90		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_1
     41  4cc9		       00		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_2
     42  4cca		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_3
     43  4ccb		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_0
     44  4ccc		       00		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_1
     45  4ccd		       48		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_2
     46  4cce		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_3
     47  4ccf		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_0
     48  4cd0		       48		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_1
     49  4cd1		       90		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_2
     50  4cd2		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_3
     51  4cd3		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_0
     52  4cd4		       90		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_1
     53  4cd5		       00		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_2
     54  4cd6		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_3
     55  4cd7		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_0
     56  4cd8		       00		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_1
     57  4cd9		       48		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_2
     58  4cda		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_3
     59  4cdb		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_0
     60  4cdc		       48		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_1
     61  4cdd		       90		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_2
     62  4cde		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_3
     63  4cdf		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_0
     64  4ce0		       90		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_1
     65  4ce1		       00		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_2
     66  4ce2		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_3
     67  4ce3		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_0
     68  4ce4		       00		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_1
     69  4ce5		       48		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_2
     70  4ce6		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_3
     71  4ce7		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_0
     72  4ce8		       90		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_1
     73  4ce9		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_2
     74  4cea		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_3
     75  4ceb		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_0
     76  4cec		       00		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_1
     77  4ced		       48		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_2
     78  4cee		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_3
     79  4cef		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_0
     80  4cf0		       48		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_1
     81  4cf1		       90		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_2
     82  4cf2		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_3
     83  4cf3		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_0
     84  4cf4		       90		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_1
     85  4cf5		       00		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_2
     86  4cf6		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_3
     87  4cf7		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_0
     88  4cf8		       00		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_1
     89  4cf9		       48		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_2
     90  4cfa		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_3
     91  4cfb		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_0
     92  4cfc		       48		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_1
     93  4cfd		       90		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_2
     94  4cfe		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_3
     95  4cff		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_0
     96  4d00		       90		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_1
     97  4d01		       00		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_2
     98  4d02		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_3
     99  4d03		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_0
    100  4d04		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_1
    101  4d05		       48		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_2
    102  4d06		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_3
    103  4d07		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_0
    104  4d08		       48		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_1
    105  4d09		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_2
    106  4d0a		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_3
    107  4d0b		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_0
    108  4d0c		       90		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_1
    109  4d0d		       00		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_2
    110  4d0e		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_3
    111  4d0f		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_0
    112  4d10		       90		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_1
    113  4d11		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_2
    114  4d12		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_3
    115  4d13		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_0
    116  4d14		       00		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_1
    117  4d15		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_2
    118  4d16		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_3
    119  4d17		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_0
    120  4d18		       48		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_1
    121  4d19		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_2
    122  4d1a		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_3
    123  4d1b		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_0
    124  4d1c		       48		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_1
    125  4d1d		       90		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_2
    126  4d1e		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_3
    127  4d1f		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_0
    128  4d20		       90		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_1
    129  4d21		       00		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_2
    130  4d22		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_3
    131  4d23		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_0
    132  4d24		       00		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_1
    133  4d25		       48		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_2
    134  4d26		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_3
    135  4d27		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_0
    136  4d28		       48		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_1
    137  4d29		       90		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_2
    138  4d2a		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_3
    139  4d2b		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_0
    140  4d2c		       00		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_1
    141  4d2d		       48		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_2
    142  4d2e		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_3
    143  4d2f		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_0
    144  4d30		       48		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_1
    145  4d31		       90		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_2
    146  4d32		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  4d33					      DEF	PIECE_VECTOR_HI
      1  4d33				   SLOT_PIECE_VECTOR_HI SET	_BANK_SLOT
      2  4d33				   BANK_PIECE_VECTOR_HI SET	SLOT_PIECE_VECTOR_HI + _CURRENT_BANK
      3  4d33				   PIECE_VECTOR_HI
      4  4d33				   TEMPORARY_VAR SET	Overlay
      5  4d33				   TEMPORARY_OFFSET SET	0
      6  4d33				   VAR_BOUNDARY_PIECE_VECTOR_HI SET	TEMPORARY_OFFSET
      7  4d33				   FUNCTION_NAME SET	PIECE_VECTOR_HI
    148  4d33		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_0
    149  4d34		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_1
    150  4d35		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_2
    151  4d36		       f9		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_3
    152  4d37		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_0
    153  4d38		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_1
    154  4d39		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_2
    155  4d3a		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_3
    156  4d3b		       fa		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_0
    157  4d3c		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_1
    158  4d3d		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_2
    159  4d3e		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_3
    160  4d3f		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_0
    161  4d40		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_1
    162  4d41		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_2
    163  4d42		       f9		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_3
    164  4d43		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_0
    165  4d44		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_1
    166  4d45		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_2
    167  4d46		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_3
    168  4d47		       fa		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_0
    169  4d48		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_1
    170  4d49		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_2
    171  4d4a		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_3
    172  4d4b		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_0
    173  4d4c		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_1
    174  4d4d		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_2
    175  4d4e		       f9		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_3
    176  4d4f		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_0
    177  4d50		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_1
    178  4d51		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_2
    179  4d52		       fa		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_3
    180  4d53		       fa		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_0
    181  4d54		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_1
    182  4d55		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_2
    183  4d56		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_3
    184  4d57		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_0
    185  4d58		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_1
    186  4d59		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_2
    187  4d5a		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_3
    188  4d5b		       fa		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_0
    189  4d5c		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_1
    190  4d5d		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_2
    191  4d5e		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_3
    192  4d5f		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_0
    193  4d60		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_1
    194  4d61		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_2
    195  4d62		       f9		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_3
    196  4d63		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_0
    197  4d64		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_1
    198  4d65		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_2
    199  4d66		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_3
    200  4d67		       fa		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_0
    201  4d68		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_1
    202  4d69		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_2
    203  4d6a		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_3
    204  4d6b		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_0
    205  4d6c		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_1
    206  4d6d		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_2
    207  4d6e		       f9		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_3
    208  4d6f		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_0
    209  4d70		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_1
    210  4d71		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_2
    211  4d72		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_3
    212  4d73		       fa		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_0
    213  4d74		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_1
    214  4d75		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_2
    215  4d76		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_3
    216  4d77		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_0
    217  4d78		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_1
    218  4d79		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_2
    219  4d7a		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_3
    220  4d7b		       fa		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_0
    221  4d7c		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_1
    222  4d7d		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_2
    223  4d7e		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_3
    224  4d7f		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_0
    225  4d80		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_1
    226  4d81		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_2
    227  4d82		       f9		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_3
    228  4d83		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_0
    229  4d84		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_1
    230  4d85		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_2
    231  4d86		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_3
    232  4d87		       fa		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_0
    233  4d88		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_1
    234  4d89		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_2
    235  4d8a		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_3
    236  4d8b		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_0
    237  4d8c		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_1
    238  4d8d		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_2
    239  4d8e		       f9		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_3
    240  4d8f		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_0
    241  4d90		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_1
    242  4d91		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_2
    243  4d92		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_3
    244  4d93		       fa		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_0
    245  4d94		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_1
    246  4d95		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_2
    247  4d96		       f8		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_3
    248  4d97		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_0
    249  4d98		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_1
    250  4d99		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_2
    251  4d9a		       f9		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_3
    252  4d9b		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_0
    253  4d9c		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_1
    254  4d9d		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_2
    255  4d9e		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_3
    256  4d9f		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_0
    257  4da0		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_1
    258  4da1		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_2
    259  4da2		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_3
    260  4da3		       f9		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_0
    261  4da4		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_1
    262  4da5		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_2
    263  4da6		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_3
    264  4da7		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_0
    265  4da8		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_1
    266  4da9		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_2
    267  4daa		       f8		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_3
    268  4dab		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_0
    269  4dac		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_1
    270  4dad		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_2
    271  4dae		       fa		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_3
    272  4daf		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_0
    273  4db0		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_1
    274  4db1		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_2
    275  4db2		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_3
    276  4db3		       fb		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_0
    277  4db4		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_1
    278  4db5		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_2
    279  4db6		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_3
    280  4db7		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_0
    281  4db8		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_1
    282  4db9		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_2
    283  4dba		       fa		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_3
    284  4dbb		       fa		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_0
    285  4dbc		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_1
    286  4dbd		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_2
    287  4dbe		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_3
    288  4dbf		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_0
    289  4dc0		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_1
    290  4dc1		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_2
    291  4dc2		       f9		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  4dc3					      DEF	PIECE_VECTOR_BANK
      1  4dc3				   SLOT_PIECE_VECTOR_BANK SET	_BANK_SLOT
      2  4dc3				   BANK_PIECE_VECTOR_BANK SET	SLOT_PIECE_VECTOR_BANK + _CURRENT_BANK
      3  4dc3				   PIECE_VECTOR_BANK
      4  4dc3				   TEMPORARY_VAR SET	Overlay
      5  4dc3				   TEMPORARY_OFFSET SET	0
      6  4dc3				   VAR_BOUNDARY_PIECE_VECTOR_BANK SET	TEMPORARY_OFFSET
      7  4dc3				   FUNCTION_NAME SET	PIECE_VECTOR_BANK
    293  4dc3		       8a		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_0
    294  4dc4		       8a		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_1
    295  4dc5		       8a		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_2
    296  4dc6		       8a		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_3
    297  4dc7		       8a		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_0
    298  4dc8		       8a		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_1
    299  4dc9		       8a		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_2
    300  4dca		       8a		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_3
    301  4dcb		       8a		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0
    302  4dcc		       8a		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1
    303  4dcd		       8a		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2
    304  4dce		       8a		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3
    305  4dcf		       8b		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_0
    306  4dd0		       8b		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_1
    307  4dd1		       8b		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_2
    308  4dd2		       8b		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_3
    309  4dd3		       8b		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_0
    310  4dd4		       8b		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_1
    311  4dd5		       8b		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_2
    312  4dd6		       8b		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_3
    313  4dd7		       8b		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_0
    314  4dd8		       8b		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_1
    315  4dd9		       8b		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_2
    316  4dda		       8b		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_3
    317  4ddb		       8c		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_0
    318  4ddc		       8c		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_1
    319  4ddd		       8c		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_2
    320  4dde		       8c		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_3
    321  4ddf		       96		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_0
    322  4de0		       96		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_1
    323  4de1		       96		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_2
    324  4de2		       97		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_3
    325  4de3		       98		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0
    326  4de4		       98		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1
    327  4de5		       98		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2
    328  4de6		       98		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3
    329  4de7		       8c		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_0
    330  4de8		       8c		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_1
    331  4de9		       8c		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_2
    332  4dea		       8c		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_3
    333  4deb		       8c		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_0
    334  4dec		       8c		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_1
    335  4ded		       8c		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_2
    336  4dee		       8c		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_3
    337  4def		       8d		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0
    338  4df0		       8d		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1
    339  4df1		       8d		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2
    340  4df2		       8d		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3
    341  4df3		       8d		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_0
    342  4df4		       8d		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_1
    343  4df5		       8d		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_2
    344  4df6		       8d		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_3
    345  4df7		       8d		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_0
    346  4df8		       8d		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_1
    347  4df9		       8d		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_2
    348  4dfa		       8d		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_3
    349  4dfb		       8e		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_0
    350  4dfc		       8e		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_1
    351  4dfd		       8e		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_2
    352  4dfe		       8e		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_3
    353  4dff		       8e		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_0
    354  4e00		       8e		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_1
    355  4e01		       8e		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_2
    356  4e02		       8e		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_3
    357  4e03		       95		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_0
    358  4e04		       95		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_1
    359  4e05		       95		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_2
    360  4e06		       95		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_3
    361  4e07		       98		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0
    362  4e08		       98		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1
    363  4e09		       98		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2
    364  4e0a		       98		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3
    365  4e0b		       8e		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_0
    366  4e0c		       8e		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_1
    367  4e0d		       8e		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_2
    368  4e0e		       8e		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_3
    369  4e0f		       8f		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_0
    370  4e10		       8f		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_1
    371  4e11		       8f		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_2
    372  4e12		       8f		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_3
    373  4e13		       8f		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0
    374  4e14		       8f		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1
    375  4e15		       8f		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2
    376  4e16		       8f		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3
    377  4e17		       8f		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_0
    378  4e18		       8f		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_1
    379  4e19		       8f		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_2
    380  4e1a		       8f		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_3
    381  4e1b		       90		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_0
    382  4e1c		       90		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_1
    383  4e1d		       90		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_2
    384  4e1e		       90		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_3
    385  4e1f		       90		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_0
    386  4e20		       90		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_1
    387  4e21		       90		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_2
    388  4e22		       90		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_3
    389  4e23		       90		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_0
    390  4e24		       90		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_1
    391  4e25		       90		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_2
    392  4e26		       91		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_3
    393  4e27		       98		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_0
    394  4e28		       98		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_1
    395  4e29		       98		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_2
    396  4e2a		       98		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_3
    397  4e2b		       95		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0
    398  4e2c		       95		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1
    399  4e2d		       95		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2
    400  4e2e		       95		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3
    401  4e2f		       91		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_0
    402  4e30		       91		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_1
    403  4e31		       91		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_2
    404  4e32		       91		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_3
    405  4e33		       91		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_0
    406  4e34		       91		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_1
    407  4e35		       91		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_2
    408  4e36		       91		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_3
    409  4e37		       91		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0
    410  4e38		       91		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1
    411  4e39		       91		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2
    412  4e3a		       92		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3
    413  4e3b		       96		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_0
    414  4e3c		       96		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_1
    415  4e3d		       96		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_2
    416  4e3e		       96		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_3
    417  4e3f		       96		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_0
    418  4e40		       96		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_1
    419  4e41		       96		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_2
    420  4e42		       96		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_3
    421  4e43		       96		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_0
    422  4e44		       97		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_1
    423  4e45		       97		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_2
    424  4e46		       97		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_3
    425  4e47		       97		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_0
    426  4e48		       97		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_1
    427  4e49		       97		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_2
    428  4e4a		       97		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_3
    429  4e4b		       97		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_0
    430  4e4c		       97		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_1
    431  4e4d		       97		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_2
    432  4e4e		       97		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_3
    433  4e4f		       95		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0
    434  4e50		       95		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1
    435  4e51		       95		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2
    436  4e52		       95		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3
    437  4e53
    438  4e53							; piece index equates...
    439  4e53		       00 00	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_0 =	0
    440  4e53		       00 01	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_1 =	1
    441  4e53		       00 02	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_2 =	2
    442  4e53		       00 03	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_3 =	3
    443  4e53		       00 04	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_0 =	4
    444  4e53		       00 05	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_1 =	5
    445  4e53		       00 06	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_2 =	6
    446  4e53		       00 07	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_3 =	7
    447  4e53		       00 08	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0 =	8
    448  4e53		       00 09	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_1 =	9
    449  4e53		       00 0a	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_2 =	10
    450  4e53		       00 0b	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_3 =	11
    451  4e53		       00 0c	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0 =	12
    452  4e53		       00 0d	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_1 =	13
    453  4e53		       00 0e	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_2 =	14
    454  4e53		       00 0f	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_3 =	15
    455  4e53		       00 10	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_0 =	16
    456  4e53		       00 11	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_1 =	17
    457  4e53		       00 12	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_2 =	18
    458  4e53		       00 13	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_3 =	19
    459  4e53		       00 14	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0 =	20
    460  4e53		       00 15	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_1 =	21
    461  4e53		       00 16	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_2 =	22
    462  4e53		       00 17	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_3 =	23
    463  4e53		       00 18	   INDEX_WHITE_KING_on_WHITE_SQUARE_0 =	24
    464  4e53		       00 19	   INDEX_WHITE_KING_on_WHITE_SQUARE_1 =	25
    465  4e53		       00 1a	   INDEX_WHITE_KING_on_WHITE_SQUARE_2 =	26
    466  4e53		       00 1b	   INDEX_WHITE_KING_on_WHITE_SQUARE_3 =	27
    467  4e53		       00 1c	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_0 =	28
    468  4e53		       00 1d	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_1 =	29
    469  4e53		       00 1e	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_2 =	30
    470  4e53		       00 1f	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_3 =	31
    471  4e53		       00 20	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0 =	32
    472  4e53		       00 21	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_1 =	33
    473  4e53		       00 22	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_2 =	34
    474  4e53		       00 23	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_3 =	35
    475  4e53		       00 24	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_0 =	36
    476  4e53		       00 25	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_1 =	37
    477  4e53		       00 26	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_2 =	38
    478  4e53		       00 27	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_3 =	39
    479  4e53		       00 28	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_0 =	40
    480  4e53		       00 29	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_1 =	41
    481  4e53		       00 2a	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_2 =	42
    482  4e53		       00 2b	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_3 =	43
    483  4e53		       00 2c	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_0 =	44
    484  4e53		       00 2d	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_1 =	45
    485  4e53		       00 2e	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_2 =	46
    486  4e53		       00 2f	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_3 =	47
    487  4e53		       00 30	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_0 =	48
    488  4e53		       00 31	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_1 =	49
    489  4e53		       00 32	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_2 =	50
    490  4e53		       00 33	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_3 =	51
    491  4e53		       00 34	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_0 =	52
    492  4e53		       00 35	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_1 =	53
    493  4e53		       00 36	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_2 =	54
    494  4e53		       00 37	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_3 =	55
    495  4e53		       00 38	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_0 =	56
    496  4e53		       00 39	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_1 =	57
    497  4e53		       00 3a	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_2 =	58
    498  4e53		       00 3b	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_3 =	59
    499  4e53		       00 3c	   INDEX_WHITE_KING_on_BLACK_SQUARE_0 =	60
    500  4e53		       00 3d	   INDEX_WHITE_KING_on_BLACK_SQUARE_1 =	61
    501  4e53		       00 3e	   INDEX_WHITE_KING_on_BLACK_SQUARE_2 =	62
    502  4e53		       00 3f	   INDEX_WHITE_KING_on_BLACK_SQUARE_3 =	63
    503  4e53		       00 40	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_0 =	64
    504  4e53		       00 41	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_1 =	65
    505  4e53		       00 42	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_2 =	66
    506  4e53		       00 43	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_3 =	67
    507  4e53		       00 44	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_0 =	68
    508  4e53		       00 45	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_1 =	69
    509  4e53		       00 46	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_2 =	70
    510  4e53		       00 47	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_3 =	71
    511  4e53		       00 48	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_0 =	72
    512  4e53		       00 49	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_1 =	73
    513  4e53		       00 4a	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_2 =	74
    514  4e53		       00 4b	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_3 =	75
    515  4e53		       00 4c	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_0 =	76
    516  4e53		       00 4d	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_1 =	77
    517  4e53		       00 4e	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_2 =	78
    518  4e53		       00 4f	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_3 =	79
    519  4e53		       00 50	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0 =	80
    520  4e53		       00 51	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_1 =	81
    521  4e53		       00 52	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_2 =	82
    522  4e53		       00 53	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_3 =	83
    523  4e53		       00 54	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0 =	84
    524  4e53		       00 55	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_1 =	85
    525  4e53		       00 56	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_2 =	86
    526  4e53		       00 57	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_3 =	87
    527  4e53		       00 58	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_0 =	88
    528  4e53		       00 59	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_1 =	89
    529  4e53		       00 5a	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_2 =	90
    530  4e53		       00 5b	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_3 =	91
    531  4e53		       00 5c	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0 =	92
    532  4e53		       00 5d	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_1 =	93
    533  4e53		       00 5e	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_2 =	94
    534  4e53		       00 5f	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_3 =	95
    535  4e53		       00 60	   INDEX_BLACK_KING_on_WHITE_SQUARE_0 =	96
    536  4e53		       00 61	   INDEX_BLACK_KING_on_WHITE_SQUARE_1 =	97
    537  4e53		       00 62	   INDEX_BLACK_KING_on_WHITE_SQUARE_2 =	98
    538  4e53		       00 63	   INDEX_BLACK_KING_on_WHITE_SQUARE_3 =	99
    539  4e53		       00 64	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_0 =	100
    540  4e53		       00 65	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_1 =	101
    541  4e53		       00 66	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_2 =	102
    542  4e53		       00 67	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_3 =	103
    543  4e53		       00 68	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0 =	104
    544  4e53		       00 69	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_1 =	105
    545  4e53		       00 6a	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_2 =	106
    546  4e53		       00 6b	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_3 =	107
    547  4e53		       00 6c	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_0 =	108
    548  4e53		       00 6d	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_1 =	109
    549  4e53		       00 6e	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_2 =	110
    550  4e53		       00 6f	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_3 =	111
    551  4e53		       00 70	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_0 =	112
    552  4e53		       00 71	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_1 =	113
    553  4e53		       00 72	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_2 =	114
    554  4e53		       00 73	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_3 =	115
    555  4e53		       00 74	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_0 =	116
    556  4e53		       00 75	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_1 =	117
    557  4e53		       00 76	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_2 =	118
    558  4e53		       00 77	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_3 =	119
    559  4e53		       00 78	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_0 =	120
    560  4e53		       00 79	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_1 =	121
    561  4e53		       00 7a	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_2 =	122
    562  4e53		       00 7b	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_3 =	123
    563  4e53		       00 7c	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_0 =	124
    564  4e53		       00 7d	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_1 =	125
    565  4e53		       00 7e	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_2 =	126
    566  4e53		       00 7f	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_3 =	127
    567  4e53		       00 80	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_0 =	128
    568  4e53		       00 81	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_1 =	129
    569  4e53		       00 82	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_2 =	130
    570  4e53		       00 83	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_3 =	131
    571  4e53		       00 84	   INDEX_BLACK_KING_on_BLACK_SQUARE_0 =	132
    572  4e53		       00 85	   INDEX_BLACK_KING_on_BLACK_SQUARE_1 =	133
    573  4e53		       00 86	   INDEX_BLACK_KING_on_BLACK_SQUARE_2 =	134
    574  4e53		       00 87	   INDEX_BLACK_KING_on_BLACK_SQUARE_3 =	135
    575  4e53		       00 88	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_0 =	136
    576  4e53		       00 89	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_1 =	137
    577  4e53		       00 8a	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_2 =	138
    578  4e53		       00 8b	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_3 =	139
    579  4e53		       00 8c	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_0 =	140
    580  4e53		       00 8d	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_1 =	141
    581  4e53		       00 8e	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_2 =	142
    582  4e53		       00 8f	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_3 =	143
------- FILE BANK_GENERIC@2.asm
    237  4e53
    238  4e53							;---------------------------------------------------------------------------------------------------
    239  4e53
      0  4e53					      CHECK_BANK_SIZE	"BANK_GENERIC@2"
      1  4e53		       02 53	   .TEMP      =	* - _BANK_START
 BANK_GENERIC@2 (1K) SIZE =  $253 , FREE= $1ad
      2  4e53					      ECHO	"BANK_GENERIC@2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4e53				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4e53				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC@2", " size=", * - ORIGIN
      5  4e53				  -	      ERR
      6  4e53					      ENDIF
    241  4e53
    242  4e53							;---------------------------------------------------------------------------------------------------
    243  4e53							;EOF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@1#3.asm LEVEL 2 PASS 4
      0  4e53					      include	"BANK_GENERIC@1#3.asm"
      0  4e53					      SLOT	1
      1  4e53				  -	      IF	(1 < 0) || (1 > 3)
      2  4e53				  -	      ECHO	"Illegal bank address/segment location", 1
      3  4e53				  -	      ERR
      4  4e53					      ENDIF
      5  4e53				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  4e53				   _BANK_SLOT SET	1 * 64
      0  4e53					      NEWBANK	GENERIC_BANK_2
      1  5037 ????				      SEG	GENERIC_BANK_2
      2  5000					      ORG	_ORIGIN
      3  5000					      RORG	_BANK_ADDRESS_ORIGIN
      4  5000				   _BANK_START SET	*
      5  5000				   GENERIC_BANK_2_START SET	*
      6  5000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5000				   GENERIC_BANK_2 SET	_BANK_SLOT + _CURRENT_BANK
      8  5000				   _ORIGIN    SET	_ORIGIN + 1024
      3  5000
      4  5000
      5  5000							;---------------------------------------------------------------------------------------------------
      6  5000
      0  5000					      DEF	aiDrawPart2
      1  5000				   SLOT_aiDrawPart2 SET	_BANK_SLOT
      2  5000				   BANK_aiDrawPart2 SET	SLOT_aiDrawPart2 + _CURRENT_BANK
      3  5000				   aiDrawPart2
      4  5000				   TEMPORARY_VAR SET	Overlay
      5  5000				   TEMPORARY_OFFSET SET	0
      6  5000				   VAR_BOUNDARY_aiDrawPart2 SET	TEMPORARY_OFFSET
      7  5000				   FUNCTION_NAME SET	aiDrawPart2
      8  5000					      SUBROUTINE
      9  5000
      0  5000					      REFER	AiStateMachine
      1  5000				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5000				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5000					      ENDIF
      0  5000					      VEND	aiDrawPart2
      1  5000				  -	      IFNCONST	aiDrawPart2
      2  5000				  -	      ECHO	"Incorrect VEND label", aiDrawPart2
      3  5000				  -	      ERR
      4  5000					      ENDIF
      5  5000		       00 a1	   VAREND_aiDrawPart2 =	TEMPORARY_VAR
     12  5000
     13  5000		       20 a3 f0 	      jsr	CopySinglePiece	;@0
     14  5003
      0  5003					      DEF	aiDrawPart3
      1  5003				   SLOT_aiDrawPart3 SET	_BANK_SLOT
      2  5003				   BANK_aiDrawPart3 SET	SLOT_aiDrawPart3 + _CURRENT_BANK
      3  5003				   aiDrawPart3
      4  5003				   TEMPORARY_VAR SET	Overlay
      5  5003				   TEMPORARY_OFFSET SET	0
      6  5003				   VAR_BOUNDARY_aiDrawPart3 SET	TEMPORARY_OFFSET
      7  5003				   FUNCTION_NAME SET	aiDrawPart3
     16  5003					      SUBROUTINE
     17  5003
     18  5003		       c6 80		      dec	squareToDraw
     19  5005		       a5 80		      lda	squareToDraw
     20  5007		       c9 16		      cmp	#22
     21  5009		       90 05		      bcc	.comp
     22  500b
      0  500b					      PHASE	AI_DrawEntireBoard
      1  500b		       a9 0f		      lda	#AI_DrawEntireBoard
      2  500d		       85 8b		      sta	aiState
     24  500f		       60		      rts
     25  5010
     26  5010				   .comp
     27  5010
     28  5010		       a9 ff		      lda	#-1
     29  5012		       85 86		      sta	toX12	; becomes startup flash square
     30  5014		       a9 24		      lda	#36	; becomes cursor position
     31  5016		       85 87		      sta	originX12
     32  5018
     33  5018
      0  5018					      PHASE	AI_GenerateMoves
      1  5018		       a9 12		      lda	#AI_GenerateMoves
      2  501a		       85 8b		      sta	aiState
     35  501c		       60		      rts
     36  501d
     37  501d
     38  501d
     39  501d
     40  501d							;---------------------------------------------------------------------------------------------------
     41  501d
      0  501d					      DEF	aiMarchB
      1  501d				   SLOT_aiMarchB SET	_BANK_SLOT
      2  501d				   BANK_aiMarchB SET	SLOT_aiMarchB + _CURRENT_BANK
      3  501d				   aiMarchB
      4  501d				   TEMPORARY_VAR SET	Overlay
      5  501d				   TEMPORARY_OFFSET SET	0
      6  501d				   VAR_BOUNDARY_aiMarchB SET	TEMPORARY_OFFSET
      7  501d				   FUNCTION_NAME SET	aiMarchB
     43  501d					      SUBROUTINE
     44  501d
      0  501d					      REFER	AiStateMachine
      1  501d				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  501d				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  501d					      ENDIF
      0  501d					      VEND	aiMarchB
      1  501d				  -	      IFNCONST	aiMarchB
      2  501d				  -	      ECHO	"Incorrect VEND label", aiMarchB
      3  501d				  -	      ERR
      4  501d					      ENDIF
      5  501d		       00 a1	   VAREND_aiMarchB =	TEMPORARY_VAR
     47  501d
     48  501d							; Draw the piece in the new square
     49  501d
     50  501d		       a5 85		      lda	fromX12
     51  501f		       85 80		      sta	squareToDraw
     52  5021
     53  5021		       20 a3 f0 	      jsr	CopySinglePiece	;@0	      ; draw the moving piece into the new square
     54  5024
     55  5024		       a9 0a		      lda	#10	; snail trail delay ??
     56  5026		       85 82		      sta	drawDelay
     57  5028
      0  5028					      PHASE	AI_MarchToTargetB
      1  5028		       a9 19		      lda	#AI_MarchToTargetB
      2  502a		       85 8b		      sta	aiState
     59  502c		       60		      rts
     60  502d
     61  502d
     62  502d
     63  502d							;---------------------------------------------------------------------------------------------------
     64  502d
      0  502d					      DEF	aiDraw
      1  502d				   SLOT_aiDraw SET	_BANK_SLOT
      2  502d				   BANK_aiDraw SET	SLOT_aiDraw + _CURRENT_BANK
      3  502d				   aiDraw
      4  502d				   TEMPORARY_VAR SET	Overlay
      5  502d				   TEMPORARY_OFFSET SET	0
      6  502d				   VAR_BOUNDARY_aiDraw SET	TEMPORARY_OFFSET
      7  502d				   FUNCTION_NAME SET	aiDraw
     66  502d					      SUBROUTINE
     67  502d		       a9 c0		      lda	#$C0
     68  502f		       85 49		      sta	COLUBK
     69  5031		       60		      rts
     70  5032
     71  5032
     72  5032							;---------------------------------------------------------------------------------------------------
     73  5032
      0  5032					      DEF	aiCheckMate
      1  5032				   SLOT_aiCheckMate SET	_BANK_SLOT
      2  5032				   BANK_aiCheckMate SET	SLOT_aiCheckMate + _CURRENT_BANK
      3  5032				   aiCheckMate
      4  5032				   TEMPORARY_VAR SET	Overlay
      5  5032				   TEMPORARY_OFFSET SET	0
      6  5032				   VAR_BOUNDARY_aiCheckMate SET	TEMPORARY_OFFSET
      7  5032				   FUNCTION_NAME SET	aiCheckMate
     75  5032					      SUBROUTINE
     76  5032		       a9 44		      lda	#$44
     77  5034		       85 49		      sta	COLUBK
     78  5036		       60		      rts
     79  5037
     80  5037							;---------------------------------------------------------------------------------------------------
     81  5037
      0  5037					      CHECK_BANK_SIZE	"BANK_GENERIC2"
      1  5037		       00 37	   .TEMP      =	* - _BANK_START
 BANK_GENERIC2 (1K) SIZE =  $37 , FREE= $3c9
      2  5037					      ECHO	"BANK_GENERIC2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5037				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5037				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC2", " size=", * - ORIGIN
      5  5037				  -	      ERR
      6  5037					      ENDIF
     83  5037
     84  5037							;---------------------------------------------------------------------------------------------------
     85  5037							;EOF
------- FILE ./chess.asm
------- FILE GFX1.asm LEVEL 2 PASS 4
      0  5037					      include	"GFX1.asm"
      0  5037					      SLOT	2
      1  5037				  -	      IF	(2 < 0) || (2 > 3)
      2  5037				  -	      ECHO	"Illegal bank address/segment location", 2
      3  5037				  -	      ERR
      4  5037					      ENDIF
      5  5037				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  5037				   _BANK_SLOT SET	2 * 64
      0  5037					      NEWBANK	GFX1
      1  57d8 ????				      SEG	GFX1
      2  5400					      ORG	_ORIGIN
      3  5400					      RORG	_BANK_ADDRESS_ORIGIN
      4  5400				   _BANK_START SET	*
      5  5400				   GFX1_START SET	*
      6  5400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5400				   GFX1       SET	_BANK_SLOT + _CURRENT_BANK
      8  5400				   _ORIGIN    SET	_ORIGIN + 1024
      3  5400
      4  5400
      5  5400							;---------------------------------------------------------------------------------------------------
      6  5400
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5400					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  5400					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_0", 72
     12  5400					      LIST	ON
      0  5400					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_0
      1  5400				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5400				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5400				   BLACK_PROMOTE_on_BLACK_SQUARE_0
      4  5400				   TEMPORARY_VAR SET	Overlay
      5  5400				   TEMPORARY_OFFSET SET	0
      6  5400				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5400				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_0
      3  5400		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5448					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  5448					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_1", 72
     12  5448					      LIST	ON
      0  5448					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_1
      1  5448				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5448				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5448				   BLACK_PROMOTE_on_BLACK_SQUARE_1
      4  5448				   TEMPORARY_VAR SET	Overlay
      5  5448				   TEMPORARY_OFFSET SET	0
      6  5448				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5448				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_1
      3  5448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5460		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5490					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  5490					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_2", 72
     12  5490					      LIST	ON
      0  5490					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_2
      1  5490				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5490				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5490				   BLACK_PROMOTE_on_BLACK_SQUARE_2
      4  5490				   TEMPORARY_VAR SET	Overlay
      5  5490				   TEMPORARY_OFFSET SET	0
      6  5490				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5490				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_2
      3  5490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  54a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  54c0		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  54d8					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  54d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_3", 72
     12  5500					      LIST	ON
      0  5500					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_3
      1  5500				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5500				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5500				   BLACK_PROMOTE_on_BLACK_SQUARE_3
      4  5500				   TEMPORARY_VAR SET	Overlay
      5  5500				   TEMPORARY_OFFSET SET	0
      6  5500				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5500				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_3
      3  5500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5530		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5548					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  5548					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_0", 72
     12  5548					      LIST	ON
      0  5548					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_0
      1  5548				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5548				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5548				   BLACK_PROMOTE_on_WHITE_SQUARE_0
      4  5548				   TEMPORARY_VAR SET	Overlay
      5  5548				   TEMPORARY_OFFSET SET	0
      6  5548				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5548				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_0
      3  5548		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  5560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5590					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  5590					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_1", 72
     12  5590					      LIST	ON
      0  5590					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_1
      1  5590				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5590				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5590				   BLACK_PROMOTE_on_WHITE_SQUARE_1
      4  5590				   TEMPORARY_VAR SET	Overlay
      5  5590				   TEMPORARY_OFFSET SET	0
      6  5590				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5590				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_1
      3  5590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  55a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  55c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  55d8					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  55d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_2", 72
     12  5600					      LIST	ON
      0  5600					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_2
      1  5600				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5600				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5600				   BLACK_PROMOTE_on_WHITE_SQUARE_2
      4  5600				   TEMPORARY_VAR SET	Overlay
      5  5600				   TEMPORARY_OFFSET SET	0
      6  5600				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5600				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_2
      3  5600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  5630		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5648					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  5648					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_3", 72
     12  5648					      LIST	ON
      0  5648					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_3
      1  5648				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5648				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5648				   BLACK_PROMOTE_on_WHITE_SQUARE_3
      4  5648				   TEMPORARY_VAR SET	Overlay
      5  5648				   TEMPORARY_OFFSET SET	0
      6  5648				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5648				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_3
      3  5648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5678		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE GFX1.asm
     15  5690
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5690					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm"
      0  5690					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_0", 72
     12  5690					      LIST	ON
      0  5690					      DEF	WHITE_MARKER_on_BLACK_SQUARE_0
      1  5690				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5690				   BANK_WHITE_MARKER_on_BLACK_SQUARE_0 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5690				   WHITE_MARKER_on_BLACK_SQUARE_0
      4  5690				   TEMPORARY_VAR SET	Overlay
      5  5690				   TEMPORARY_OFFSET SET	0
      6  5690				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5690				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_0
      3  5690		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  56a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  56c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  56d8					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm"
      0  56d8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_1", 72
     12  5700					      LIST	ON
      0  5700					      DEF	WHITE_MARKER_on_BLACK_SQUARE_1
      1  5700				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5700				   BANK_WHITE_MARKER_on_BLACK_SQUARE_1 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5700				   WHITE_MARKER_on_BLACK_SQUARE_1
      4  5700				   TEMPORARY_VAR SET	Overlay
      5  5700				   TEMPORARY_OFFSET SET	0
      6  5700				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5700				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_1
      3  5700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5718		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5748					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm"
      0  5748					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_2", 72
     12  5748					      LIST	ON
      0  5748					      DEF	WHITE_MARKER_on_BLACK_SQUARE_2
      1  5748				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5748				   BANK_WHITE_MARKER_on_BLACK_SQUARE_2 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5748				   WHITE_MARKER_on_BLACK_SQUARE_2
      4  5748				   TEMPORARY_VAR SET	Overlay
      5  5748				   TEMPORARY_OFFSET SET	0
      6  5748				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5748				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_2
      3  5748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5760		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5778		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5790					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm"
      0  5790					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_3", 72
     12  5790					      LIST	ON
      0  5790					      DEF	WHITE_MARKER_on_BLACK_SQUARE_3
      1  5790				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5790				   BANK_WHITE_MARKER_on_BLACK_SQUARE_3 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5790				   WHITE_MARKER_on_BLACK_SQUARE_3
      4  5790				   TEMPORARY_VAR SET	Overlay
      5  5790				   TEMPORARY_OFFSET SET	0
      6  5790				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5790				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_3
      3  5790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  57a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  57c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
     20  57d8
     21  57d8
     22  57d8							;---------------------------------------------------------------------------------------------------
     23  57d8
      0  57d8					      CHECK_BANK_SIZE	"BANK_GFX1"
      1  57d8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX1 (1K) SIZE =  $3d8 , FREE= $28
      2  57d8					      ECHO	"BANK_GFX1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  57d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  57d8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX1", " size=", * - ORIGIN
      5  57d8				  -	      ERR
      6  57d8					      ENDIF
     25  57d8
     26  57d8							;---------------------------------------------------------------------------------------------------
     27  57d8							;EOF
------- FILE ./chess.asm
------- FILE GFX2.asm LEVEL 2 PASS 4
      0  57d8					      include	"GFX2.asm"
      0  57d8					      SLOT	2
      1  57d8				  -	      IF	(2 < 0) || (2 > 3)
      2  57d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  57d8				  -	      ERR
      4  57d8					      ENDIF
      5  57d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  57d8				   _BANK_SLOT SET	2 * 64
      0  57d8					      NEWBANK	GFX2
      1  5bd8 ????				      SEG	GFX2
      2  5800					      ORG	_ORIGIN
      3  5800					      RORG	_BANK_ADDRESS_ORIGIN
      4  5800				   _BANK_START SET	*
      5  5800				   GFX2_START SET	*
      6  5800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5800				   GFX2       SET	_BANK_SLOT + _CURRENT_BANK
      8  5800				   _ORIGIN    SET	_ORIGIN + 1024
      3  5800
      4  5800							;---------------------------------------------------------------------------------------------------
      5  5800
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5800					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm"
      0  5800					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_0", 72
     12  5800					      LIST	ON
      0  5800					      DEF	WHITE_MARKER_on_WHITE_SQUARE_0
      1  5800				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5800				   BANK_WHITE_MARKER_on_WHITE_SQUARE_0 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5800				   WHITE_MARKER_on_WHITE_SQUARE_0
      4  5800				   TEMPORARY_VAR SET	Overlay
      5  5800				   TEMPORARY_OFFSET SET	0
      6  5800				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5800				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_0
      3  5800		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00	;PF0
      4  5818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5848					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm"
      0  5848					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_1", 72
     12  5848					      LIST	ON
      0  5848					      DEF	WHITE_MARKER_on_WHITE_SQUARE_1
      1  5848				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5848				   BANK_WHITE_MARKER_on_WHITE_SQUARE_1 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5848				   WHITE_MARKER_on_WHITE_SQUARE_1
      4  5848				   TEMPORARY_VAR SET	Overlay
      5  5848				   TEMPORARY_OFFSET SET	0
      6  5848				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5848				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_1
      3  5848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5860		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00	;PF1
      5  5878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5890					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm"
      0  5890					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_2", 72
     12  5890					      LIST	ON
      0  5890					      DEF	WHITE_MARKER_on_WHITE_SQUARE_2
      1  5890				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5890				   BANK_WHITE_MARKER_on_WHITE_SQUARE_2 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5890				   WHITE_MARKER_on_WHITE_SQUARE_2
      4  5890				   TEMPORARY_VAR SET	Overlay
      5  5890				   TEMPORARY_OFFSET SET	0
      6  5890				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5890				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_2
      3  5890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  58a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00	;PF1
      5  58c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00	;PF2
------- FILE GFX2.asm
      9  58d8
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  58d8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm"
      0  58d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_0", 72
     12  5900					      LIST	ON
      0  5900					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_0
      1  5900				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5900				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5900				   BLACK_BISHOP_on_BLACK_SQUARE_0
      4  5900				   TEMPORARY_VAR SET	Overlay
      5  5900				   TEMPORARY_OFFSET SET	0
      6  5900				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5900				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_0
      3  5900		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$40,$00	;PF0
      4  5918		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5930		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5948					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm"
      0  5948					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_1", 72
     12  5948					      LIST	ON
      0  5948					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_1
      1  5948				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5948				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5948				   BLACK_BISHOP_on_BLACK_SQUARE_1
      4  5948				   TEMPORARY_VAR SET	Overlay
      5  5948				   TEMPORARY_OFFSET SET	0
      6  5948				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5948				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_1
      3  5948		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5960		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$00,$00,$00,$10,$00	;PF1
      5  5978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5990					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm"
      0  5990					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_2", 72
     12  5990					      LIST	ON
      0  5990					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_2
      1  5990				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5990				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5990				   BLACK_BISHOP_on_BLACK_SQUARE_2
      4  5990				   TEMPORARY_VAR SET	Overlay
      5  5990				   TEMPORARY_OFFSET SET	0
      6  5990				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5990				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_2
      3  5990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  59a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  59c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$00,$00,$00,$01,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  59d8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm"
      0  59d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_3", 72
     12  5a00					      LIST	ON
      0  5a00					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_3
      1  5a00				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5a00				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5a00				   BLACK_BISHOP_on_BLACK_SQUARE_3
      4  5a00				   TEMPORARY_VAR SET	Overlay
      5  5a00				   TEMPORARY_OFFSET SET	0
      6  5a00				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5a00				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_3
      3  5a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5a30		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$00,$00,$00,$20,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5a48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm"
      0  5a48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_0", 72
     12  5a48					      LIST	ON
      0  5a48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_0
      1  5a48				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5a48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5a48				   BLACK_ROOK_on_BLACK_SQUARE_0
      4  5a48				   TEMPORARY_VAR SET	Overlay
      5  5a48				   TEMPORARY_OFFSET SET	0
      6  5a48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5a48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_0
      3  5a48		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$a0,$00,$00	;PF0
      4  5a60		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5a78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5a90					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm"
      0  5a90					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_1", 72
     12  5a90					      LIST	ON
      0  5a90					      DEF	BLACK_ROOK_on_BLACK_SQUARE_1
      1  5a90				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5a90				   BANK_BLACK_ROOK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5a90				   BLACK_ROOK_on_BLACK_SQUARE_1
      4  5a90				   TEMPORARY_VAR SET	Overlay
      5  5a90				   TEMPORARY_OFFSET SET	0
      6  5a90				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5a90				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_1
      3  5a90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5aa8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$28,$00,$00	;PF1
      5  5ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5ad8					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm"
      0  5ad8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_2", 72
     12  5b00					      LIST	ON
      0  5b00					      DEF	BLACK_ROOK_on_BLACK_SQUARE_2
      1  5b00				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5b00				   BANK_BLACK_ROOK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5b00				   BLACK_ROOK_on_BLACK_SQUARE_2
      4  5b00				   TEMPORARY_VAR SET	Overlay
      5  5b00				   TEMPORARY_OFFSET SET	0
      6  5b00				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5b00				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_2
      3  5b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5b18		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF1
      5  5b30		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$02,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5b48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm"
      0  5b48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_3", 72
     12  5b48					      LIST	ON
      0  5b48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_3
      1  5b48				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5b48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5b48				   BLACK_ROOK_on_BLACK_SQUARE_3
      4  5b48				   TEMPORARY_VAR SET	Overlay
      5  5b48				   TEMPORARY_OFFSET SET	0
      6  5b48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5b48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_3
      3  5b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5b60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5b78		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00	;PF2
------- FILE GFX2.asm
     18  5b90
     19  5b90
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5b90					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm"
      0  5b90					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_0", 72
     12  5b90					      LIST	ON
      0  5b90					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_0
      1  5b90				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5b90				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5b90				   BLACK_QUEEN_on_BLACK_SQUARE_0
      4  5b90				   TEMPORARY_VAR SET	Overlay
      5  5b90				   TEMPORARY_OFFSET SET	0
      6  5b90				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5b90				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_0
      3  5b90		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ba8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5bc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
     21  5bd8
     22  5bd8
     23  5bd8							;---------------------------------------------------------------------------------------------------
     24  5bd8
      0  5bd8					      CHECK_BANK_SIZE	"BANK_GFX2"
      1  5bd8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX2 (1K) SIZE =  $3d8 , FREE= $28
      2  5bd8					      ECHO	"BANK_GFX2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5bd8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX2", " size=", * - ORIGIN
      5  5bd8				  -	      ERR
      6  5bd8					      ENDIF
     26  5bd8
     27  5bd8							;---------------------------------------------------------------------------------------------------
     28  5bd8							;EOF
------- FILE ./chess.asm
------- FILE GFX3.asm LEVEL 2 PASS 4
      0  5bd8					      include	"GFX3.asm"
      0  5bd8					      SLOT	2
      1  5bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  5bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  5bd8				  -	      ERR
      4  5bd8					      ENDIF
      5  5bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  5bd8				   _BANK_SLOT SET	2 * 64
      0  5bd8					      NEWBANK	GFX3
      1  5fd8 ????				      SEG	GFX3
      2  5c00					      ORG	_ORIGIN
      3  5c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  5c00				   _BANK_START SET	*
      5  5c00				   GFX3_START SET	*
      6  5c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5c00				   GFX3       SET	_BANK_SLOT + _CURRENT_BANK
      8  5c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  5c00
      4  5c00							;---------------------------------------------------------------------------------------------------
      5  5c00
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5c00					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm"
      0  5c00					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_1", 72
     12  5c00					      LIST	ON
      0  5c00					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_1
      1  5c00				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5c00				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5c00				   BLACK_QUEEN_on_BLACK_SQUARE_1
      4  5c00				   TEMPORARY_VAR SET	Overlay
      5  5c00				   TEMPORARY_OFFSET SET	0
      6  5c00				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5c00				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_1
      3  5c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5c18		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
      7  5c48
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5c48					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm"
      0  5c48					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_2", 72
     12  5c48					      LIST	ON
      0  5c48					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_2
      1  5c48				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5c48				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5c48				   BLACK_QUEEN_on_BLACK_SQUARE_2
      4  5c48				   TEMPORARY_VAR SET	Overlay
      5  5c48				   TEMPORARY_OFFSET SET	0
      6  5c48				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5c48				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_2
      3  5c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5c60		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5c78		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5c90					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm"
      0  5c90					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_3", 72
     12  5c90					      LIST	ON
      0  5c90					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_3
      1  5c90				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5c90				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5c90				   BLACK_QUEEN_on_BLACK_SQUARE_3
      4  5c90				   TEMPORARY_VAR SET	Overlay
      5  5c90				   TEMPORARY_OFFSET SET	0
      6  5c90				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5c90				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_3
      3  5c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5cc0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     10  5cd8
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5cd8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_0.asm"
      0  5cd8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_0", 72
     12  5d00					      LIST	ON
      0  5d00					      DEF	BLACK_KING_on_BLACK_SQUARE_0
      1  5d00				   SLOT_BLACK_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5d00				   BANK_BLACK_KING_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5d00				   BLACK_KING_on_BLACK_SQUARE_0
      4  5d00				   TEMPORARY_VAR SET	Overlay
      5  5d00				   TEMPORARY_OFFSET SET	0
      6  5d00				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5d00				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_0
      3  5d00		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5d18		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5d48					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_1.asm"
      0  5d48					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_1", 72
     12  5d48					      LIST	ON
      0  5d48					      DEF	BLACK_KING_on_BLACK_SQUARE_1
      1  5d48				   SLOT_BLACK_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5d48				   BANK_BLACK_KING_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5d48				   BLACK_KING_on_BLACK_SQUARE_1
      4  5d48				   TEMPORARY_VAR SET	Overlay
      5  5d48				   TEMPORARY_OFFSET SET	0
      6  5d48				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5d48				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_1
      3  5d48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5d60		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5d90					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_2.asm"
      0  5d90					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_2", 72
     12  5d90					      LIST	ON
      0  5d90					      DEF	BLACK_KING_on_BLACK_SQUARE_2
      1  5d90				   SLOT_BLACK_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5d90				   BANK_BLACK_KING_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5d90				   BLACK_KING_on_BLACK_SQUARE_2
      4  5d90				   TEMPORARY_VAR SET	Overlay
      5  5d90				   TEMPORARY_OFFSET SET	0
      6  5d90				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5d90				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_2
      3  5d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5da8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5dc0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5dd8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_3.asm"
      0  5dd8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_3", 72
     12  5e00					      LIST	ON
      0  5e00					      DEF	BLACK_KING_on_BLACK_SQUARE_3
      1  5e00				   SLOT_BLACK_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5e00				   BANK_BLACK_KING_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5e00				   BLACK_KING_on_BLACK_SQUARE_3
      4  5e00				   TEMPORARY_VAR SET	Overlay
      5  5e00				   TEMPORARY_OFFSET SET	0
      6  5e00				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5e00				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_3
      3  5e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5e18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5e30		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     15  5e48
     16  5e48
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5e48					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm"
      0  5e48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_3", 72
     12  5e48					      LIST	ON
      0  5e48					      DEF	WHITE_MARKER_on_WHITE_SQUARE_3
      1  5e48				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5e48				   BANK_WHITE_MARKER_on_WHITE_SQUARE_3 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5e48				   WHITE_MARKER_on_WHITE_SQUARE_3
      4  5e48				   TEMPORARY_VAR SET	Overlay
      5  5e48				   TEMPORARY_OFFSET SET	0
      6  5e48				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5e48				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_3
      3  5e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5e78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00	;PF2
------- FILE GFX3.asm
     18  5e90
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5e90					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
      0  5e90					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_0", 72
     12  5e90					      LIST	ON
      0  5e90					      DEF	BLACK_MARKER_on_BLACK_SQUARE_0
      1  5e90				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5e90				   BANK_BLACK_MARKER_on_BLACK_SQUARE_0 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5e90				   BLACK_MARKER_on_BLACK_SQUARE_0
      4  5e90				   TEMPORARY_VAR SET	Overlay
      5  5e90				   TEMPORARY_OFFSET SET	0
      6  5e90				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5e90				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_0
      3  5e90		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5ed8					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
      0  5ed8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_1", 72
     12  5f00					      LIST	ON
      0  5f00					      DEF	BLACK_MARKER_on_BLACK_SQUARE_1
      1  5f00				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5f00				   BANK_BLACK_MARKER_on_BLACK_SQUARE_1 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5f00				   BLACK_MARKER_on_BLACK_SQUARE_1
      4  5f00				   TEMPORARY_VAR SET	Overlay
      5  5f00				   TEMPORARY_OFFSET SET	0
      6  5f00				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5f00				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_1
      3  5f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5f18		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5f48					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
      0  5f48					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_2", 72
     12  5f48					      LIST	ON
      0  5f48					      DEF	BLACK_MARKER_on_BLACK_SQUARE_2
      1  5f48				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5f48				   BANK_BLACK_MARKER_on_BLACK_SQUARE_2 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5f48				   BLACK_MARKER_on_BLACK_SQUARE_2
      4  5f48				   TEMPORARY_VAR SET	Overlay
      5  5f48				   TEMPORARY_OFFSET SET	0
      6  5f48				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5f48				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_2
      3  5f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5f78		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5f90					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
      0  5f90					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_3", 72
     12  5f90					      LIST	ON
      0  5f90					      DEF	BLACK_MARKER_on_BLACK_SQUARE_3
      1  5f90				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5f90				   BANK_BLACK_MARKER_on_BLACK_SQUARE_3 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5f90				   BLACK_MARKER_on_BLACK_SQUARE_3
      4  5f90				   TEMPORARY_VAR SET	Overlay
      5  5f90				   TEMPORARY_OFFSET SET	0
      6  5f90				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5f90				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_3
      3  5f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5fc0		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     23  5fd8
     24  5fd8							;---------------------------------------------------------------------------------------------------
     25  5fd8
      0  5fd8					      CHECK_BANK_SIZE	"BANK_GFX3"
      1  5fd8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX3 (1K) SIZE =  $3d8 , FREE= $28
      2  5fd8					      ECHO	"BANK_GFX3", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5fd8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX3", " size=", * - ORIGIN
      5  5fd8				  -	      ERR
      6  5fd8					      ENDIF
     27  5fd8
     28  5fd8							;---------------------------------------------------------------------------------------------------
     29  5fd8							;EOF
------- FILE ./chess.asm
------- FILE GFX4.asm LEVEL 2 PASS 4
      0  5fd8					      include	"GFX4.asm"
      0  5fd8					      SLOT	2
      1  5fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  5fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  5fd8				  -	      ERR
      4  5fd8					      ENDIF
      5  5fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  5fd8				   _BANK_SLOT SET	2 * 64
      0  5fd8					      NEWBANK	GFX4
      1  63d8 ????				      SEG	GFX4
      2  6000					      ORG	_ORIGIN
      3  6000					      RORG	_BANK_ADDRESS_ORIGIN
      4  6000				   _BANK_START SET	*
      5  6000				   GFX4_START SET	*
      6  6000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6000				   GFX4       SET	_BANK_SLOT + _CURRENT_BANK
      8  6000				   _ORIGIN    SET	_ORIGIN + 1024
      3  6000
      4  6000							;---------------------------------------------------------------------------------------------------
      5  6000
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  6000					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
      0  6000					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_0", 72
     12  6000					      LIST	ON
      0  6000					      DEF	BLACK_MARKER_on_WHITE_SQUARE_0
      1  6000				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  6000				   BANK_BLACK_MARKER_on_WHITE_SQUARE_0 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  6000				   BLACK_MARKER_on_WHITE_SQUARE_0
      4  6000				   TEMPORARY_VAR SET	Overlay
      5  6000				   TEMPORARY_OFFSET SET	0
      6  6000				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  6000				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_0
      3  6000		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00	;PF0
      4  6018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  6048					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
      0  6048					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_1", 72
     12  6048					      LIST	ON
      0  6048					      DEF	BLACK_MARKER_on_WHITE_SQUARE_1
      1  6048				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  6048				   BANK_BLACK_MARKER_on_WHITE_SQUARE_1 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  6048				   BLACK_MARKER_on_WHITE_SQUARE_1
      4  6048				   TEMPORARY_VAR SET	Overlay
      5  6048				   TEMPORARY_OFFSET SET	0
      6  6048				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  6048				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_1
      3  6048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6060		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00	;PF1
      5  6078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  6090					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
      0  6090					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_2", 72
     12  6090					      LIST	ON
      0  6090					      DEF	BLACK_MARKER_on_WHITE_SQUARE_2
      1  6090				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  6090				   BANK_BLACK_MARKER_on_WHITE_SQUARE_2 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  6090				   BLACK_MARKER_on_WHITE_SQUARE_2
      4  6090				   TEMPORARY_VAR SET	Overlay
      5  6090				   TEMPORARY_OFFSET SET	0
      6  6090				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  6090				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_2
      3  6090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  60a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  60c0		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  60d8					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
      0  60d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_3", 72
     12  6100					      LIST	ON
      0  6100					      DEF	BLACK_MARKER_on_WHITE_SQUARE_3
      1  6100				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  6100				   BANK_BLACK_MARKER_on_WHITE_SQUARE_3 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  6100				   BLACK_MARKER_on_WHITE_SQUARE_3
      4  6100				   TEMPORARY_VAR SET	Overlay
      5  6100				   TEMPORARY_OFFSET SET	0
      6  6100				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  6100				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_3
      3  6100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6130		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00	;PF2
------- FILE GFX4.asm
     10  6148
     11  6148
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  6148					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  6148					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_0", 72
     12  6148					      LIST	ON
      0  6148					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_0
      1  6148				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  6148				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  6148				   WHITE_PROMOTE_on_BLACK_SQUARE_0
      4  6148				   TEMPORARY_VAR SET	Overlay
      5  6148				   TEMPORARY_OFFSET SET	0
      6  6148				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  6148				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_0
      3  6148		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  6160		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  6190					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  6190					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_1", 72
     12  6190					      LIST	ON
      0  6190					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_1
      1  6190				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  6190				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  6190				   WHITE_PROMOTE_on_BLACK_SQUARE_1
      4  6190				   TEMPORARY_VAR SET	Overlay
      5  6190				   TEMPORARY_OFFSET SET	0
      6  6190				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  6190				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_1
      3  6190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  61a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  61c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  61d8					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  61d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_2", 72
     12  6200					      LIST	ON
      0  6200					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_2
      1  6200				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  6200				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  6200				   WHITE_PROMOTE_on_BLACK_SQUARE_2
      4  6200				   TEMPORARY_VAR SET	Overlay
      5  6200				   TEMPORARY_OFFSET SET	0
      6  6200				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  6200				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_2
      3  6200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6218		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  6230		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  6248					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  6248					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_3", 72
     12  6248					      LIST	ON
      0  6248					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_3
      1  6248				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  6248				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  6248				   WHITE_PROMOTE_on_BLACK_SQUARE_3
      4  6248				   TEMPORARY_VAR SET	Overlay
      5  6248				   TEMPORARY_OFFSET SET	0
      6  6248				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  6248				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_3
      3  6248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6278		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  6290					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  6290					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_0", 72
     12  6290					      LIST	ON
      0  6290					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_0
      1  6290				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  6290				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  6290				   WHITE_PROMOTE_on_WHITE_SQUARE_0
      4  6290				   TEMPORARY_VAR SET	Overlay
      5  6290				   TEMPORARY_OFFSET SET	0
      6  6290				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  6290				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_0
      3  6290		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  62a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  62c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  62d8					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  62d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_1", 72
     12  6300					      LIST	ON
      0  6300					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_1
      1  6300				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  6300				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  6300				   WHITE_PROMOTE_on_WHITE_SQUARE_1
      4  6300				   TEMPORARY_VAR SET	Overlay
      5  6300				   TEMPORARY_OFFSET SET	0
      6  6300				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  6300				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_1
      3  6300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6318		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  6348					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  6348					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_2", 72
     12  6348					      LIST	ON
      0  6348					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_2
      1  6348				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  6348				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  6348				   WHITE_PROMOTE_on_WHITE_SQUARE_2
      4  6348				   TEMPORARY_VAR SET	Overlay
      5  6348				   TEMPORARY_OFFSET SET	0
      6  6348				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  6348				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_2
      3  6348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6378		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  6390					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  6390					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_3", 72
     12  6390					      LIST	ON
      0  6390					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_3
      1  6390				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  6390				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  6390				   WHITE_PROMOTE_on_WHITE_SQUARE_3
      4  6390				   TEMPORARY_VAR SET	Overlay
      5  6390				   TEMPORARY_OFFSET SET	0
      6  6390				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  6390				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_3
      3  6390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  63a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  63c0		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
     20  63d8
     21  63d8
     22  63d8							;---------------------------------------------------------------------------------------------------
     23  63d8
      0  63d8					      CHECK_BANK_SIZE	"BANK_GFX4"
      1  63d8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX4 (1K) SIZE =  $3d8 , FREE= $28
      2  63d8					      ECHO	"BANK_GFX4", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  63d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  63d8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX4", " size=", * - ORIGIN
      5  63d8				  -	      ERR
      6  63d8					      ENDIF
     25  63d8
     26  63d8							;---------------------------------------------------------------------------------------------------
     27  63d8							;EOF
------- FILE ./chess.asm
------- FILE NEGAMAX.asm LEVEL 2 PASS 4
      0  63d8					      include	"NEGAMAX.asm"
      1  63d8							; Chess
      2  63d8							; Copyright (c) 2019-2020 Andrew Davie
      3  63d8							; andrew@taswegian.com
      4  63d8
      0  63d8					      SLOT	1	; this code assembles for bank #1
      1  63d8				  -	      IF	(1 < 0) || (1 > 3)
      2  63d8				  -	      ECHO	"Illegal bank address/segment location", 1
      3  63d8				  -	      ERR
      4  63d8					      ENDIF
      5  63d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  63d8				   _BANK_SLOT SET	1 * 64
      0  63d8					      NEWBANK	NEGAMAX
      1  653b ????				      SEG	NEGAMAX
      2  6400					      ORG	_ORIGIN
      3  6400					      RORG	_BANK_ADDRESS_ORIGIN
      4  6400				   _BANK_START SET	*
      5  6400				   NEGAMAX_START SET	*
      6  6400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6400				   NEGAMAX    SET	_BANK_SLOT + _CURRENT_BANK
      8  6400				   _ORIGIN    SET	_ORIGIN + 1024
      7  6400
      8  6400							;---------------------------------------------------------------------------------------------------
      9  6400
     10  6400							;function negaMax(node, depth, α, β, color) is
     11  6400							;    if depth = 0 or node is a terminal node then
     12  6400							;	  return color × the heuristic value of node
     13  6400
     14  6400							;    childNodes := generateMoves(node)
     15  6400							;    childNodes := orderMoves(childNodes)
     16  6400							;    value := −∞
     17  6400							;    foreach child in childNodes do
     18  6400							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
     19  6400							;	  α := max(α, value)
     20  6400							;	  if α ≥ β then
     21  6400							;	      break (* cut-off *)
     22  6400							;    return value
     23  6400							;(* Initial call for Player A's root node *)
     24  6400							;negaMax(rootNode, depth, −∞, +∞, 1)
     25  6400
     26  6400
     27  6400					      SUBROUTINE
     28  6400
     29  6400		       a9 ff	   .doQ       lda	#-1
     30  6402		       85 ac		      sta	__quiesceCapOnly
     31  6404		       20 83 f4 	      jsr	quiesce
     32  6407		       e6 ac		      inc	__quiesceCapOnly
     33  6409		       60		      rts
     34  640a
     35  640a
      0  640a				   .exit      lda@PLY	value
      1  640a		       ad d7 f9 	      lda	value
     37  640d		       85 a8		      sta	__negaMax
      0  640f					      lda@PLY	value+1
      1  640f		       ad d8 f9 	      lda	value+1
     39  6412		       85 a9		      sta	__negaMax+1
     40  6414		       60		      rts
     41  6415
     42  6415
     43  6415		       c9 00	   .terminal  cmp	#0	; captured piece
     44  6417		       d0 e7		      bne	.doQ	; last move was capture, so quiesce
     45  6419
     46  6419
     47  6419				  -	      IF	0
     48  6419				  -			; king moves will also quiesce
     49  6419				  -			; theory is - we need to see if it was an illegal move
     50  6419				  -
     51  6419				  -	      lda	fromPiece
     52  6419				  -	      and	#PIECE_MASK
     53  6419				  -	      cmp	#KING
     54  6419				  -	      beq	.doQ
     55  6419					      ENDIF
     56  6419
     57  6419		       a5 8f		      lda	Evaluation
     58  641b		       85 a8		      sta	__negaMax
     59  641d		       a5 90		      lda	Evaluation+1
     60  641f		       85 a9		      sta	__negaMax+1
     61  6421
     62  6421		       60	   .inCheck2  rts
     63  6422
     64  6422
     65  6422
      0  6422					      DEF	negaMax
      1  6422				   SLOT_negaMax SET	_BANK_SLOT
      2  6422				   BANK_negaMax SET	SLOT_negaMax + _CURRENT_BANK
      3  6422				   negaMax
      4  6422				   TEMPORARY_VAR SET	Overlay
      5  6422				   TEMPORARY_OFFSET SET	0
      6  6422				   VAR_BOUNDARY_negaMax SET	TEMPORARY_OFFSET
      7  6422				   FUNCTION_NAME SET	negaMax
     67  6422
     68  6422							; PARAMS depth-1, -beta, -alpha
     69  6422							; pased through temporary variables (__alpha, __beta) and X reg
     70  6422
     71  6422							; pass...
     72  6422							; x = depthleft
     73  6422							; a = captured piece
     74  6422							; SET_BANK_RAM      --> current ply
     75  6422							; __alpha[2] = param alpha
     76  6422							; __beta[2] = param beta
     77  6422
     78  6422
      0  6422					      COMMON_VARS_ALPHABETA
      1  6422
      0  6422					      VAR	__thinkbar, 1
      1  6422		       00 a1	   __thinkbar =	TEMPORARY_VAR
      2  6422				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6422
      4  6422				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6422				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6422				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6422					      ENDIF
      8  6422				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6422				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  6422				  -	      ERR
     11  6422					      ENDIF
     12  6422					      LIST	ON
      0  6422					      VAR	__toggle, 1
      1  6422		       00 a2	   __toggle   =	TEMPORARY_VAR
      2  6422				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6422
      4  6422				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6422				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6422				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6422					      ENDIF
      8  6422				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6422				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  6422				  -	      ERR
     11  6422					      ENDIF
     12  6422					      LIST	ON
      4  6422
      0  6422					      VAR	__bestMove, 1
      1  6422		       00 a3	   __bestMove =	TEMPORARY_VAR
      2  6422				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6422
      4  6422				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6422				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6422				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6422					      ENDIF
      8  6422				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6422				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  6422				  -	      ERR
     11  6422					      ENDIF
     12  6422					      LIST	ON
      0  6422					      VAR	__alpha, 2
      1  6422		       00 a4	   __alpha    =	TEMPORARY_VAR
      2  6422				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6422
      4  6422				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6422				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6422				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6422					      ENDIF
      8  6422				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6422				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  6422				  -	      ERR
     11  6422					      ENDIF
     12  6422					      LIST	ON
      0  6422					      VAR	__beta, 2
      1  6422		       00 a6	   __beta     =	TEMPORARY_VAR
      2  6422				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6422
      4  6422				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6422				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6422				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6422					      ENDIF
      8  6422				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6422				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  6422				  -	      ERR
     11  6422					      ENDIF
     12  6422					      LIST	ON
      0  6422					      VAR	__negaMax, 2
      1  6422		       00 a8	   __negaMax  =	TEMPORARY_VAR
      2  6422				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6422
      4  6422				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6422				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6422				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6422					      ENDIF
      8  6422				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6422				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  6422				  -	      ERR
     11  6422					      ENDIF
     12  6422					      LIST	ON
      0  6422					      VAR	__value, 2
      1  6422		       00 aa	   __value    =	TEMPORARY_VAR
      2  6422				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6422
      4  6422				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6422				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6422				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6422					      ENDIF
      8  6422				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6422				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  6422				  -	      ERR
     11  6422					      ENDIF
     12  6422					      LIST	ON
     10  6422
      0  6422					      VAR	__quiesceCapOnly, 1
      1  6422		       00 ac	   __quiesceCapOnly =	TEMPORARY_VAR
      2  6422				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6422
      4  6422				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6422				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6422				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6422					      ENDIF
      8  6422				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6422				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  6422				  -	      ERR
     11  6422					      ENDIF
     12  6422					      LIST	ON
     12  6422
      0  6422					      REFER	selectmove
      1  6422				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  6422				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  6422					      ENDIF
      0  6422					      VEND	negaMax
      1  6422				  -	      IFNCONST	negaMax
      2  6422				  -	      ECHO	"Incorrect VEND label", negaMax
      3  6422				  -	      ERR
      4  6422					      ENDIF
      5  6422		       00 ad	   VAREND_negaMax =	TEMPORARY_VAR
     82  6422
     83  6422		       48		      pha
     84  6423
      0  6423					      CALL	ThinkBar
      1  6423				  -	      IF	SLOT_ThinkBar == _BANK_SLOT
      2  6423				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  6423				  -	      ECHO	"Cannot switch bank in use for", ThinkBar
      4  6423				  -	      ERR
      5  6423					      ENDIF
      6  6423		       a9 00		      lda	#BANK_ThinkBar
      7  6425		       85 3f		      sta	SET_BANK
      8  6427		       20 7e f0 	      jsr	ThinkBar
     86  642a		       a5 94		      lda	currentPly
     87  642c		       85 3e		      sta	SET_BANK_RAM
     88  642e
     89  642e		       68		      pla
     90  642f		       ca		      dex
     91  6430		       30 e3		      bmi	.terminal
      0  6432					      stx@PLY	depthLeft
      1  6432		       8e d9 fb 	      stx	[RAM]+depthLeft
     93  6435
     94  6435
     95  6435							; Allow the player to force computer to select a move. Press the SELECT switch
     96  6435							; This may have issues if no move has been selected yet. Still... if you wanna cheat....
     97  6435
     98  6435		       ad 82 02 	      lda	SWCHB
     99  6438		       29 02		      and	#2
    100  643a		       f0 ce		      beq	.exit	; SELECT abort
    101  643c		       85 48		      sta	COLUPF	; grey thinkbars
    102  643e
    103  643e		       a5 a4		      lda	__alpha
      0  6440					      sta@PLY	alpha
      1  6440		       8d d3 fb 	      sta	[RAM]+alpha
    105  6443		       a5 a5		      lda	__alpha+1
      0  6445					      sta@PLY	alpha+1
      1  6445		       8d d4 fb 	      sta	[RAM]+alpha+1
    107  6448
    108  6448		       a5 a6		      lda	__beta
      0  644a					      sta@PLY	beta
      1  644a		       8d d5 fb 	      sta	[RAM]+beta
    110  644d		       a5 a7		      lda	__beta+1
      0  644f					      sta@PLY	beta+1
      1  644f		       8d d6 fb 	      sta	[RAM]+beta+1
    112  6452
    113  6452
    114  6452					      IF	1
    115  6452		       a5 8f		      lda	Evaluation
    116  6454		       65 a0		      adc	randomness
    117  6456		       85 8f		      sta	Evaluation
    118  6458		       90 02		      bcc	.evh
    119  645a		       e6 90		      inc	Evaluation+1
    120  645c				   .evh
    121  645c					      ENDIF
    122  645c
    123  645c		       20 6d f1 	      jsr	GenerateAllMoves
    124  645f		       a5 9e		      lda	flagCheck
    125  6461		       d0 be		      bne	.inCheck2	; OTHER guy in check
    126  6463
    127  6463					      IF	1
      0  6463					      lda@PLY	moveIndex
      1  6463		       ad d0 f9 	      lda	moveIndex
    129  6466		       30 0f		      bmi	.none
    130  6468		       4a		      lsr
    131  6469		       4a		      lsr
    132  646a		       4a		      lsr
    133  646b		       4a		      lsr
    134  646c		       4a		      lsr
    135  646d		       65 8f		      adc	Evaluation
    136  646f		       85 8f		      sta	Evaluation
    137  6471		       a5 90		      lda	Evaluation+1
    138  6473		       69 00		      adc	#0
    139  6475		       85 90		      sta	Evaluation+1
    140  6477				   .none
    141  6477					      ENDIF
    142  6477
    143  6477
    144  6477		       a9 00		      lda	#<-INFINITY
      0  6479					      sta@PLY	value
      1  6479		       8d d7 fb 	      sta	[RAM]+value
    146  647c		       a9 90		      lda	#>-INFINITY
      0  647e					      sta@PLY	value+1
      1  647e		       8d d8 fb 	      sta	[RAM]+value+1
    148  6481
      0  6481					      ldx@PLY	moveIndex
      1  6481		       ae d0 f9 	      ldx	moveIndex
    150  6484		       10 03		      bpl	.forChild
    151  6486		       4c 0a f4 	      jmp	.exit
    152  6489
      0  6489				   .forChild  stx@PLY	movePtr
      1  6489		       8e d1 fb 	      stx	[RAM]+movePtr
    154  648c
    155  648c		       20 64 f6 	      jsr	MakeMove
    156  648f
    157  648f
    158  648f
    159  648f							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    160  648f
    161  648f							; PARAMS depth-1, -beta, -alpha
    162  648f							; pased through temporary variables (__alpha, __beta) and X reg
    163  648f
    164  648f		       38		      sec
    165  6490		       a9 00		      lda	#0
      0  6492					      sbc@PLY	beta
      1  6492		       ed d5 f9 	      sbc	beta
    167  6495		       85 a4		      sta	__alpha
    168  6497		       a9 00		      lda	#0
      0  6499					      sbc@PLY	beta+1
      1  6499		       ed d6 f9 	      sbc	beta+1
    170  649c		       85 a5		      sta	__alpha+1
    171  649e
    172  649e		       38		      sec
    173  649f		       a9 00		      lda	#0
      0  64a1					      sbc@PLY	alpha
      1  64a1		       ed d3 f9 	      sbc	alpha
    175  64a4		       85 a6		      sta	__beta
    176  64a6		       a9 00		      lda	#0
      0  64a8					      sbc@PLY	alpha+1
      1  64a8		       ed d4 f9 	      sbc	alpha+1
    178  64ab		       85 a7		      sta	__beta+1
    179  64ad
    180  64ad
      0  64ad					      ldx@PLY	depthLeft
      1  64ad		       ae d9 f9 	      ldx	depthLeft
      0  64b0					      lda@PLY	capturedPiece
      1  64b0		       ad cb f9 	      lda	capturedPiece
    183  64b3
    184  64b3		       e6 94		      inc	currentPly
    185  64b5		       a4 94		      ldy	currentPly
    186  64b7		       84 3e		      sty	SET_BANK_RAM	; self-switch
    187  64b9
    188  64b9		       20 22 f4 	      jsr	negaMax
    189  64bc
    190  64bc		       c6 94		      dec	currentPly
    191  64be		       a5 94		      lda	currentPly
    192  64c0		       85 3e		      sta	SET_BANK_RAM
    193  64c2
    194  64c2		       20 32 f2 	      jsr	unmakeMove	;@0
    195  64c5
    196  64c5		       38		      sec
    197  64c6		       a9 00		      lda	#0
    198  64c8		       e5 a8		      sbc	__negaMax
    199  64ca		       85 a8		      sta	__negaMax
    200  64cc		       a9 00		      lda	#0
    201  64ce		       e5 a9		      sbc	__negaMax+1
    202  64d0		       85 a9		      sta	__negaMax+1	; -negaMax(...)
    203  64d2
    204  64d2		       a5 9e		      lda	flagCheck
    205  64d4		       f0 06		      beq	.notCheck
    206  64d6
    207  64d6							; at this point we've determined that the move was illegal, because the next ply detected
    208  64d6							; a king capture. So, the move should be totally discounted
    209  64d6
    210  64d6		       a9 00		      lda	#0
    211  64d8		       85 9e		      sta	flagCheck	; so we don't retrigger in future - it's been handled!
    212  64da		       f0 53		      beq	.nextMove	; unconditional - move is not considered!
    213  64dc
    214  64dc		       38	   .notCheck  sec
      0  64dd					      lda@PLY	value
      1  64dd		       ad d7 f9 	      lda	value
    216  64e0		       e5 a8		      sbc	__negaMax
      0  64e2					      lda@PLY	value+1
      1  64e2		       ad d8 f9 	      lda	value+1
    218  64e5		       e5 a9		      sbc	__negaMax+1
    219  64e7		       50 02		      bvc	.lab0
    220  64e9		       49 80		      eor	#$80
    221  64eb		       10 10	   .lab0      bpl	.lt0	; branch if value >= negaMax
    222  64ed
    223  64ed							; so, negaMax > value!
    224  64ed
    225  64ed		       a5 a8		      lda	__negaMax
      0  64ef					      sta@PLY	value
      1  64ef		       8d d7 fb 	      sta	[RAM]+value
    227  64f2		       a5 a9		      lda	__negaMax+1
      0  64f4					      sta@PLY	value+1	; max(value, -negaMax)
      1  64f4		       8d d8 fb 	      sta	[RAM]+value+1
    229  64f7
      0  64f7					      lda@PLY	movePtr
      1  64f7		       ad d1 f9 	      lda	movePtr
      0  64fa					      sta@PLY	bestMove
      1  64fa		       8d d2 fb 	      sta	[RAM]+bestMove
    232  64fd				   .lt0
    233  64fd
    234  64fd							;	  α := max(α, value)
    235  64fd
    236  64fd		       38		      sec
      0  64fe					      lda@PLY	value
      1  64fe		       ad d7 f9 	      lda	value
      0  6501					      sbc@PLY	alpha
      1  6501		       ed d3 f9 	      sbc	alpha
      0  6504					      lda@PLY	value+1
      1  6504		       ad d8 f9 	      lda	value+1
      0  6507					      sbc@PLY	alpha+1
      1  6507		       ed d4 f9 	      sbc	alpha+1
    241  650a		       50 02		      bvc	.lab1
    242  650c		       49 80		      eor	#$80
    243  650e		       30 0c	   .lab1      bmi	.lt1	; value < alpha
    244  6510
      0  6510					      lda@PLY	value
      1  6510		       ad d7 f9 	      lda	value
      0  6513					      sta@PLY	alpha
      1  6513		       8d d3 fb 	      sta	[RAM]+alpha
      0  6516					      lda@PLY	value+1
      1  6516		       ad d8 f9 	      lda	value+1
      0  6519					      sta@PLY	alpha+1	; alpha = max(alpha, value)
      1  6519		       8d d4 fb 	      sta	[RAM]+alpha+1
    249  651c
    250  651c				   .lt1
    251  651c
    252  651c							;	  if α ≥ β then
    253  651c							;	      break (* cut-off *)
    254  651c
    255  651c		       38		      sec
      0  651d					      lda@PLY	alpha
      1  651d		       ad d3 f9 	      lda	alpha
      0  6520					      sbc@PLY	beta
      1  6520		       ed d5 f9 	      sbc	beta
      0  6523					      lda@PLY	alpha+1
      1  6523		       ad d4 f9 	      lda	alpha+1
      0  6526					      sbc@PLY	beta+1
      1  6526		       ed d6 f9 	      sbc	beta+1
    260  6529		       50 02		      bvc	.lab2
    261  652b		       49 80		      eor	#$80
    262  652d		       10 09	   .lab2      bpl	.retrn	; alpha >= beta
    263  652f
    264  652f
      0  652f				   .nextMove  ldx@PLY	movePtr
      1  652f		       ae d1 f9 	      ldx	movePtr
    266  6532		       ca	   .nextX     dex
    267  6533		       30 03		      bmi	.retrn
    268  6535		       4c 89 f4 	      jmp	.forChild
    269  6538
    270  6538		       4c 0a f4    .retrn     jmp	.exit
    271  653b
    272  653b
    273  653b							;---------------------------------------------------------------------------------------------------
    274  653b
      0  653b					      CHECK_BANK_SIZE	"NEGAMAX"
      1  653b		       01 3b	   .TEMP      =	* - _BANK_START
 NEGAMAX (1K) SIZE =  $13b , FREE= $2c5
      2  653b					      ECHO	"NEGAMAX", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  653b				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  653b				  -	      ECHO	"BANK OVERFLOW @ ", "NEGAMAX", " size=", * - ORIGIN
      5  653b				  -	      ERR
      6  653b					      ENDIF
    276  653b
    277  653b							;---------------------------------------------------------------------------------------------------
    278  653b							; EOF
------- FILE ./chess.asm
    628  653b
------- FILE PIECE_MACROS.asm LEVEL 2 PASS 4
      0  653b					      include	"PIECE_MACROS.asm"
      1  653b							; Copyright (C)2020 Andrew Davie
      2  653b							; Common macros for piece move handlers
      3  653b
      4  653b							;---------------------------------------------------------------------------------------------------
      5  653b							; Looks at a square offset {1} to see if piece can move to it
      6  653b							; Adds the square to the movelist if it can
      7  653b							; Keeps moving in the same direction until it's blocked/off=board
      8  653b
      9  653b					      MAC	move_towards
     10  653b					      SUBROUTINE
     11  653b
     12  653b							; = 76 for single square (empty/take)
     13  653b
     14  653b					      lda	#0
     15  653b					      sta	capture
     16  653b
     17  653b					      ldx	currentSquare	; 3
     18  653b					      bne	.project	; 3   unconditional
     19  653b
     20  653b				   .empty     jsr	AddMoveSlider	; 57
     21  653b				   .project   ldy	ValidSquare+{1},x	; 4
     22  653b					      bmi	.invalid	; 2/3 off board!
     23  653b					      lda	Board,y	; 4   piece @ destination
     24  653b					      beq	.empty	; 2/3
     25  653b					      sta	capture
     26  653b					      eor	currentPiece	; 3
     27  653b					      bpl	.invalid	; 2/3 same colour
     28  653b					      jsr	AddMove	; 57  and exit
     29  653b
     30  653b				   .invalid
     31  653b					      ENDM
     32  653b
     33  653b
     34  653b							;---------------------------------------------------------------------------------------------------
     35  653b
     36  653b					      MAC	move_to
     37  653b					      SUBROUTINE
     38  653b					      ldy	ValidSquare+{1},x
     39  653b					      bmi	.invalid	; off board!
     40  653b					      lda	Board,y	; piece @ destination
     41  653b					      sta	capture
     42  653b					      beq	.squareEmpty
     43  653b					      eor	currentPiece
     44  653b					      bpl	.invalid	; same colour
     45  653b				   .squareEmpty jsr	AddMove
     46  653b				   .invalid
     47  653b					      ENDM
     48  653b
     49  653b
     50  653b							;---------------------------------------------------------------------------------------------------
     51  653b
     52  653b					      MAC	move_to_x
     53  653b					      ldx	currentSquare
     54  653b					      MOVE_TO	{1}
     55  653b					      ENDM
     56  653b
     57  653b
     58  653b							;---------------------------------------------------------------------------------------------------
     59  653b							; EOF
------- FILE ./chess.asm
------- FILE GENMOVE.asm LEVEL 2 PASS 4
      0  653b					      include	"GENMOVE.asm"
      1  653b							; Chess
      2  653b							; Copyright (c) 2019-2020 Andrew Davie
      3  653b							; andrew@taswegian.com
      4  653b
      0  653b					      SLOT	1	; this code assembles for bank #1
      1  653b				  -	      IF	(1 < 0) || (1 > 3)
      2  653b				  -	      ECHO	"Illegal bank address/segment location", 1
      3  653b				  -	      ERR
      4  653b					      ENDIF
      5  653b				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  653b				   _BANK_SLOT SET	1 * 64
      0  653b					      NEWBANK	GENMOVE
      1  6830 ????				      SEG	GENMOVE
      2  6800					      ORG	_ORIGIN
      3  6800					      RORG	_BANK_ADDRESS_ORIGIN
      4  6800				   _BANK_START SET	*
      5  6800				   GENMOVE_START SET	*
      6  6800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6800				   GENMOVE    SET	_BANK_SLOT + _CURRENT_BANK
      8  6800				   _ORIGIN    SET	_ORIGIN + 1024
      7  6800
      8  6800					      MAC	handlevec
      9  6800					      .byte	{1}MoveReturn
     10  6800					      .byte	{1}MoveReturn	;byte {1}Handle_WHITE_PAWN	   ; 1
     11  6800					      .byte	{1}MoveReturn	;.byte {1}Handle_BLACK_PAWN	    ; 2
     12  6800					      .byte	{1}Handle_KNIGHT	; 3
     13  6800					      .byte	{1}Handle_BISHOP	; 4
     14  6800					      .byte	{1}Handle_ROOK	; 5
     15  6800					      .byte	{1}Handle_QUEEN	; 6
     16  6800					      .byte	{1}Handle_KING	; 7
     17  6800
     18  6800					      .byte	{1}MoveReturn
     19  6800					      .byte	{1}Handle_WHITE_PAWN	; 1
     20  6800					      .byte	{1}Handle_BLACK_PAWN	; 2
     21  6800					      .byte	{1}MoveReturn	;.byte {1}Handle_KNIGHT	    ; 3
     22  6800					      .byte	{1}MoveReturn	;.byte {1}Handle_BISHOP	    ; 4
     23  6800					      .byte	{1}MoveReturn	;.byte {1}Handle_ROOK		    ; 5
     24  6800					      .byte	{1}MoveReturn	;.byte {1}Handle_QUEEN 	    ; 6
     25  6800					      .byte	{1}MoveReturn	;.byte {1}Handle_KING		    ; 7
     26  6800					      ENDM
     27  6800
     28  6800
     29  6800							;    .byte 0	  ; dummy to prevent page cross access on index 0
     30  6800
      0  6800					      DEF	HandlerVectorLO
      1  6800				   SLOT_HandlerVectorLO SET	_BANK_SLOT
      2  6800				   BANK_HandlerVectorLO SET	SLOT_HandlerVectorLO + _CURRENT_BANK
      3  6800				   HandlerVectorLO
      4  6800				   TEMPORARY_VAR SET	Overlay
      5  6800				   TEMPORARY_OFFSET SET	0
      6  6800				   VAR_BOUNDARY_HandlerVectorLO SET	TEMPORARY_OFFSET
      7  6800				   FUNCTION_NAME SET	HandlerVectorLO
      0  6800					      HANDLEVEC	<
      1  6800		       99		      .byte.b	<MoveReturn
      2  6801		       99		      .byte.b	<MoveReturn
      3  6802		       99		      .byte.b	<MoveReturn
      4  6803		       44		      .byte.b	<Handle_KNIGHT
      5  6804		       ed		      .byte.b	<Handle_BISHOP
      6  6805		       00		      .byte.b	<Handle_ROOK
      7  6806		       7b		      .byte.b	<Handle_QUEEN
      8  6807		       6e		      .byte.b	<Handle_KING
      9  6808
     10  6808		       99		      .byte.b	<MoveReturn
     11  6809		       29		      .byte.b	<Handle_WHITE_PAWN
     12  680a		       cb		      .byte.b	<Handle_BLACK_PAWN
     13  680b		       99		      .byte.b	<MoveReturn
     14  680c		       99		      .byte.b	<MoveReturn
     15  680d		       99		      .byte.b	<MoveReturn
     16  680e		       99		      .byte.b	<MoveReturn
     17  680f		       99		      .byte.b	<MoveReturn
      0  6810					      DEF	HandlerVectorHI
      1  6810				   SLOT_HandlerVectorHI SET	_BANK_SLOT
      2  6810				   BANK_HandlerVectorHI SET	SLOT_HandlerVectorHI + _CURRENT_BANK
      3  6810				   HandlerVectorHI
      4  6810				   TEMPORARY_VAR SET	Overlay
      5  6810				   TEMPORARY_OFFSET SET	0
      6  6810				   VAR_BOUNDARY_HandlerVectorHI SET	TEMPORARY_OFFSET
      7  6810				   FUNCTION_NAME SET	HandlerVectorHI
      0  6810					      HANDLEVEC	>
      1  6810		       f1		      .byte.b	>MoveReturn
      2  6811		       f1		      .byte.b	>MoveReturn
      3  6812		       f1		      .byte.b	>MoveReturn
      4  6813		       f5		      .byte.b	>Handle_KNIGHT
      5  6814		       f5		      .byte.b	>Handle_BISHOP
      6  6815		       f4		      .byte.b	>Handle_ROOK
      7  6816		       f4		      .byte.b	>Handle_QUEEN
      8  6817		       f5		      .byte.b	>Handle_KING
      9  6818
     10  6818		       f1		      .byte.b	>MoveReturn
     11  6819		       f4		      .byte.b	>Handle_WHITE_PAWN
     12  681a		       f4		      .byte.b	>Handle_BLACK_PAWN
     13  681b		       f1		      .byte.b	>MoveReturn
     14  681c		       f1		      .byte.b	>MoveReturn
     15  681d		       f1		      .byte.b	>MoveReturn
     16  681e		       f1		      .byte.b	>MoveReturn
     17  681f		       f1		      .byte.b	>MoveReturn
      0  6820					      DEF	HandlerVectorBANK
      1  6820				   SLOT_HandlerVectorBANK SET	_BANK_SLOT
      2  6820				   BANK_HandlerVectorBANK SET	SLOT_HandlerVectorBANK + _CURRENT_BANK
      3  6820				   HandlerVectorBANK
      4  6820				   TEMPORARY_VAR SET	Overlay
      5  6820				   TEMPORARY_OFFSET SET	0
      6  6820				   VAR_BOUNDARY_HandlerVectorBANK SET	TEMPORARY_OFFSET
      7  6820				   FUNCTION_NAME SET	HandlerVectorBANK
      0  6820					      HANDLEVEC	BANK_
      1  6820		       00		      .byte.b	BANK_MoveReturn
      2  6821		       00		      .byte.b	BANK_MoveReturn
      3  6822		       00		      .byte.b	BANK_MoveReturn
      4  6823		       5d		      .byte.b	BANK_Handle_KNIGHT
      5  6824		       5d		      .byte.b	BANK_Handle_BISHOP
      6  6825		       5e		      .byte.b	BANK_Handle_ROOK
      7  6826		       5e		      .byte.b	BANK_Handle_QUEEN
      8  6827		       5e		      .byte.b	BANK_Handle_KING
      9  6828
     10  6828		       00		      .byte.b	BANK_MoveReturn
     11  6829		       5d		      .byte.b	BANK_Handle_WHITE_PAWN
     12  682a		       5d		      .byte.b	BANK_Handle_BLACK_PAWN
     13  682b		       00		      .byte.b	BANK_MoveReturn
     14  682c		       00		      .byte.b	BANK_MoveReturn
     15  682d		       00		      .byte.b	BANK_MoveReturn
     16  682e		       00		      .byte.b	BANK_MoveReturn
     17  682f		       00		      .byte.b	BANK_MoveReturn
     37  6830
     38  6830
     39  6830							;---------------------------------------------------------------------------------------------------
     40  6830
      0  6830					      CHECK_BANK_SIZE	"GENMOVE"
      1  6830		       00 30	   .TEMP      =	* - _BANK_START
 GENMOVE (1K) SIZE =  $30 , FREE= $3d0
      2  6830					      ECHO	"GENMOVE", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  6830				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6830				  -	      ECHO	"BANK OVERFLOW @ ", "GENMOVE", " size=", * - ORIGIN
      5  6830				  -	      ERR
      6  6830					      ENDIF
     42  6830
     43  6830							;---------------------------------------------------------------------------------------------------
     44  6830							; EOF
------- FILE ./chess.asm
------- FILE GENMOVE2.asm LEVEL 2 PASS 4
      0  6830					      include	"GENMOVE2.asm"
      1  6830							; Chess
      2  6830							; Copyright (c) 2019-2020 Andrew Davie
      3  6830							; andrew@taswegian.com
      4  6830
      0  6830					      SLOT	1	; this code assembles for bank #1
      1  6830				  -	      IF	(1 < 0) || (1 > 3)
      2  6830				  -	      ECHO	"Illegal bank address/segment location", 1
      3  6830				  -	      ERR
      4  6830					      ENDIF
      5  6830				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  6830				   _BANK_SLOT SET	1 * 64
      0  6830					      NEWBANK	GENMOVE2
      1  6c00 ????				      SEG	GENMOVE2
      2  6c00					      ORG	_ORIGIN
      3  6c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  6c00				   _BANK_START SET	*
      5  6c00				   GENMOVE2_START SET	*
      6  6c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6c00				   GENMOVE2   SET	_BANK_SLOT + _CURRENT_BANK
      8  6c00				   _ORIGIN    SET	_ORIGIN + 1024
      7  6c00
      8  6c00							;---------------------------------------------------------------------------------------------------
      9  6c00
      0  6c00					      CHECK_BANK_SIZE	"GENMOVE2"
      1  6c00		       00 00	   .TEMP      =	* - _BANK_START
 GENMOVE2 (1K) SIZE =  $0 , FREE= $400
      2  6c00					      ECHO	"GENMOVE2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  6c00				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6c00				  -	      ECHO	"BANK OVERFLOW @ ", "GENMOVE2", " size=", * - ORIGIN
      5  6c00				  -	      ERR
      6  6c00					      ENDIF
     11  6c00
     12  6c00							;---------------------------------------------------------------------------------------------------
     13  6c00							; EOF
------- FILE ./chess.asm
    632  6c00
------- FILE BANK_GENERIC@1#2.asm LEVEL 2 PASS 4
      0  6c00					      include	"BANK_GENERIC@1#2.asm"
      1  6c00							; Chess
      2  6c00							; Copyright (c) 2019-2020 Andrew Davie
      3  6c00							; andrew@taswegian.com
      4  6c00
      0  6c00					      SLOT	1
      1  6c00				  -	      IF	(1 < 0) || (1 > 3)
      2  6c00				  -	      ECHO	"Illegal bank address/segment location", 1
      3  6c00				  -	      ERR
      4  6c00					      ENDIF
      5  6c00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  6c00				   _BANK_SLOT SET	1 * 64
      0  6c00					      NEWBANK	TWO
      1  70b0 ????				      SEG	TWO
      2  7000					      ORG	_ORIGIN
      3  7000					      RORG	_BANK_ADDRESS_ORIGIN
      4  7000				   _BANK_START SET	*
      5  7000				   TWO_START  SET	*
      6  7000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7000				   TWO	      SET	_BANK_SLOT + _CURRENT_BANK
      8  7000				   _ORIGIN    SET	_ORIGIN + 1024
      7  7000
      8  7000
      9  7000							;---------------------------------------------------------------------------------------------------
     10  7000
     11  7000				  -	      IF	0
     12  7000				  -	      DEF	SAFE_BackupBitmaps
     13  7000				  -	      SUBROUTINE
     14  7000				  -
     15  7000				  -	      VEND	SAFE_BackupBitmaps
     16  7000				  -
     17  7000				  -	      sty	SET_BANK_RAM
     18  7000				  -	      jsr	SaveBitmap
     19  7000				  -	      rts
     20  7000					      ENDIF
     21  7000
     22  7000
     23  7000							;---------------------------------------------------------------------------------------------------
     24  7000
      0  7000					      DEF	AddMoveSlider
      1  7000				   SLOT_AddMoveSlider SET	_BANK_SLOT
      2  7000				   BANK_AddMoveSlider SET	SLOT_AddMoveSlider + _CURRENT_BANK
      3  7000				   AddMoveSlider
      4  7000				   TEMPORARY_VAR SET	Overlay
      5  7000				   TEMPORARY_OFFSET SET	0
      6  7000				   VAR_BOUNDARY_AddMoveSlider SET	TEMPORARY_OFFSET
      7  7000				   FUNCTION_NAME SET	AddMoveSlider
     26  7000					      SUBROUTINE
     27  7000
      0  7000					      VEND	AddMoveSlider
      1  7000				  -	      IFNCONST	AddMoveSlider
      2  7000				  -	      ECHO	"Incorrect VEND label", AddMoveSlider
      3  7000				  -	      ERR
      4  7000					      ENDIF
      5  7000		       00 a1	   VAREND_AddMoveSlider =	TEMPORARY_VAR
     29  7000
     30  7000							; add square in y register to movelist as destination (X12 format)
     31  7000							; [y]		     to square (X12)
     32  7000							; currentSquare     from square (X12)
     33  7000							; currentPiece      piece.
     34  7000							;   ENPASSANT flag set if pawn double-moving off opening rank
     35  7000							; capture	     captured piece
     36  7000
     37  7000		       a5 9d		      lda	capture
     38  7002		       d0 04		      bne	.always
     39  7004		       a5 ac		      lda	__quiesceCapOnly
     40  7006		       d0 1c		      bne	.abort
     41  7008
     42  7008				   .always
     43  7008		       98		      tya
     44  7009
      0  7009					      ldy@PLY	moveIndex
      1  7009		       ac d0 f9 	      ldy	moveIndex
     46  700c		       c8		      iny
      0  700d					      sty@PLY	moveIndex
      1  700d		       8c d0 fb 	      sty	[RAM]+moveIndex
     48  7010
      0  7010					      sta@PLY	MoveTo,y
      1  7010		       99 64 fa 	      sta	[RAM]+MoveTo,y
     50  7013		       aa		      tax		; used for continuation of sliding moves
     51  7014		       a5 92		      lda	currentSquare
      0  7016					      sta@PLY	MoveFrom,y
      1  7016		       99 00 fa 	      sta	[RAM]+MoveFrom,y
     53  7019		       a5 91		      lda	currentPiece
      0  701b					      sta@PLY	MovePiece,y
      1  701b		       99 00 fb 	      sta	[RAM]+MovePiece,y
     55  701e		       a5 9d		      lda	capture
      0  7020					      sta@PLY	MoveCapture,y
      1  7020		       99 64 fb 	      sta	[RAM]+MoveCapture,y
     57  7023
     58  7023		       60		      rts
     59  7024
     60  7024		       98	   .abort     tya
     61  7025		       aa		      tax
     62  7026		       60		      rts
     63  7027
     64  7027
     65  7027
     66  7027
     67  7027							;---------------------------------------------------------------------------------------------------
     68  7027
      0  7027					      DEF	aiComputerMove
      1  7027				   SLOT_aiComputerMove SET	_BANK_SLOT
      2  7027				   BANK_aiComputerMove SET	SLOT_aiComputerMove + _CURRENT_BANK
      3  7027				   aiComputerMove
      4  7027				   TEMPORARY_VAR SET	Overlay
      5  7027				   TEMPORARY_OFFSET SET	0
      6  7027				   VAR_BOUNDARY_aiComputerMove SET	TEMPORARY_OFFSET
      7  7027				   FUNCTION_NAME SET	aiComputerMove
     70  7027					      SUBROUTINE
     71  7027
      0  7027					      REFER	AiStateMachine
      1  7027				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  7027				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  7027					      ENDIF
      0  7027					      VEND	aiComputerMove
      1  7027				  -	      IFNCONST	aiComputerMove
      2  7027				  -	      ECHO	"Incorrect VEND label", aiComputerMove
      3  7027				  -	      ERR
      4  7027					      ENDIF
      5  7027		       00 a1	   VAREND_aiComputerMove =	TEMPORARY_VAR
     74  7027
     75  7027		       a9 88		      lda	#RAMBANK_PLY
     76  7029		       85 94		      sta	currentPly
     77  702b		       85 3e		      sta	SET_BANK_RAM	;@2		 ; switch in movelist
     78  702d
     79  702d		       a9 01		      lda	#1
     80  702f		       85 4a		      sta	CTRLPF	; mirroring for thinkbars
     81  7031
      0  7031					      CALL	selectmove	;@3
      1  7031				  -	      IF	SLOT_selectmove == _BANK_SLOT
      2  7031				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  7031				  -	      ECHO	"Cannot switch bank in use for", selectmove
      4  7031				  -	      ERR
      5  7031					      ENDIF
      6  7031		       a9 df		      lda	#BANK_selectmove
      7  7033		       85 3f		      sta	SET_BANK
      8  7035		       20 21 fc 	      jsr	selectmove
     83  7038
     84  7038		       a9 00		      lda	#0
     85  703a		       85 4a		      sta	CTRLPF	; clear mirroring
     86  703c		       85 4e		      sta	PF1
     87  703e		       85 4f		      sta	PF2
     88  7040		       4c 5f f4 	      jmp	.notComputer	;tmp
      0  7043					      lda@PLY	bestMove
      1  7043		       ad d2 f9 	      lda	bestMove
     90  7046		       10 17		      bpl	.notComputer
     91  7048
     92  7048							; Computer could not find a valid move. It's checkmate or stalemate. Find which...
     93  7048
      0  7048					      SWAP
      1  7048		       a5 95		      lda	sideToMove
      2  704a		       49 80		      eor	#SWAP_SIDE
      3  704c		       85 95		      sta	sideToMove
     95  704e		       20 6d f1 	      jsr	GenerateAllMoves
     96  7051		       a5 9e		      lda	flagCheck
     97  7053		       f0 05		      beq	.gameDrawn
     98  7055
      0  7055					      PHASE	AI_CheckMate
      1  7055		       a9 23		      lda	#AI_CheckMate
      2  7057		       85 8b		      sta	aiState
    100  7059		       60		      rts
    101  705a
    102  705a
      0  705a				   .gameDrawn PHASE	AI_Draw
      1  705a		       a9 24		      lda	#AI_Draw
      2  705c		       85 8b		      sta	aiState
    104  705e		       60		      rts
    105  705f
    106  705f				   .notComputer
    107  705f
    108  705f
    109  705f		       a9 ff		      lda	#-1
    110  7061		       85 88		      sta	cursorX12
    111  7063
    112  7063							;tmpPHASE AI_DelayAfterMove
    113  7063		       60	   .halted    rts
    114  7064
    115  7064
    116  7064
    117  7064							;---------------------------------------------------------------------------------------------------
    118  7064
      0  7064					      DEF	aiSpecialMoveFixup
      1  7064				   SLOT_aiSpecialMoveFixup SET	_BANK_SLOT
      2  7064				   BANK_aiSpecialMoveFixup SET	SLOT_aiSpecialMoveFixup + _CURRENT_BANK
      3  7064				   aiSpecialMoveFixup
      4  7064				   TEMPORARY_VAR SET	Overlay
      5  7064				   TEMPORARY_OFFSET SET	0
      6  7064				   VAR_BOUNDARY_aiSpecialMoveFixup SET	TEMPORARY_OFFSET
      7  7064				   FUNCTION_NAME SET	aiSpecialMoveFixup
    120  7064					      SUBROUTINE
    121  7064
      0  7064					      COMMON_VARS_ALPHABETA
      1  7064
      0  7064					      VAR	__thinkbar, 1
      1  7064		       00 a1	   __thinkbar =	TEMPORARY_VAR
      2  7064				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7064
      4  7064				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7064				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7064				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7064					      ENDIF
      8  7064				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7064				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  7064				  -	      ERR
     11  7064					      ENDIF
     12  7064					      LIST	ON
      0  7064					      VAR	__toggle, 1
      1  7064		       00 a2	   __toggle   =	TEMPORARY_VAR
      2  7064				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7064
      4  7064				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7064				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7064				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7064					      ENDIF
      8  7064				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7064				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  7064				  -	      ERR
     11  7064					      ENDIF
     12  7064					      LIST	ON
      4  7064
      0  7064					      VAR	__bestMove, 1
      1  7064		       00 a3	   __bestMove =	TEMPORARY_VAR
      2  7064				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7064
      4  7064				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7064				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7064				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7064					      ENDIF
      8  7064				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7064				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  7064				  -	      ERR
     11  7064					      ENDIF
     12  7064					      LIST	ON
      0  7064					      VAR	__alpha, 2
      1  7064		       00 a4	   __alpha    =	TEMPORARY_VAR
      2  7064				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7064
      4  7064				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7064				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7064				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7064					      ENDIF
      8  7064				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7064				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  7064				  -	      ERR
     11  7064					      ENDIF
     12  7064					      LIST	ON
      0  7064					      VAR	__beta, 2
      1  7064		       00 a6	   __beta     =	TEMPORARY_VAR
      2  7064				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7064
      4  7064				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7064				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7064				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7064					      ENDIF
      8  7064				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7064				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  7064				  -	      ERR
     11  7064					      ENDIF
     12  7064					      LIST	ON
      0  7064					      VAR	__negaMax, 2
      1  7064		       00 a8	   __negaMax  =	TEMPORARY_VAR
      2  7064				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7064
      4  7064				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7064				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7064				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7064					      ENDIF
      8  7064				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7064				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  7064				  -	      ERR
     11  7064					      ENDIF
     12  7064					      LIST	ON
      0  7064					      VAR	__value, 2
      1  7064		       00 aa	   __value    =	TEMPORARY_VAR
      2  7064				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7064
      4  7064				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7064				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7064				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7064					      ENDIF
      8  7064				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7064				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  7064				  -	      ERR
     11  7064					      ENDIF
     12  7064					      LIST	ON
     10  7064
      0  7064					      VAR	__quiesceCapOnly, 1
      1  7064		       00 ac	   __quiesceCapOnly =	TEMPORARY_VAR
      2  7064				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7064
      4  7064				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7064				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7064				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7064					      ENDIF
      8  7064				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7064				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  7064				  -	      ERR
     11  7064					      ENDIF
     12  7064					      LIST	ON
     12  7064
      0  7064					      REFER	AiStateMachine
      1  7064				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  7064				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  7064					      ENDIF
      0  7064					      VEND	aiSpecialMoveFixup
      1  7064				  -	      IFNCONST	aiSpecialMoveFixup
      2  7064				  -	      ECHO	"Incorrect VEND label", aiSpecialMoveFixup
      3  7064				  -	      ERR
      4  7064					      ENDIF
      5  7064		       00 ad	   VAREND_aiSpecialMoveFixup =	TEMPORARY_VAR
    125  7064
    126  7064		       ad 84 02 	      lda	INTIM
    127  7067		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    128  7069		       b0 01		      bcs	.cont
    129  706b		       60		      rts
    130  706c
    131  706c
    132  706c				   .cont
    133  706c
    134  706c
      0  706c					      PHASE	AI_DelayAfterPlaced
      1  706c		       a9 27		      lda	#AI_DelayAfterPlaced
      2  706e		       85 8b		      sta	aiState
    136  7070
    137  7070
    138  7070							; Special move fixup
    139  7070
    140  7070				  -	      IF	ENPASSANT_ENABLED
    141  7070				  -
    142  7070				  -			; Handle en-passant captures
    143  7070				  -			; The (dual-use) FLAG_ENPASSANT will have been cleared if it was set for a home-rank move
    144  7070				  -			; but if we're here and the flag is still set, then it's an actual en-passant CAPTURE and we
    145  7070				  -			; need to do the appropriate things...
    146  7070				  -
    147  7070				  -	      jsr	EnPassantCheck
    148  7070				  -
    149  7070					      ENDIF
    150  7070
    151  7070
    152  7070		       a5 94		      lda	currentPly
    153  7072		       85 3e		      sta	SET_BANK_RAM
    154  7074		       20 c7 f6 	      jsr	CastleFixupDraw
    155  7077
    156  7077		       a5 85		      lda	fromX12
    157  7079		       85 80		      sta	squareToDraw
    158  707b
    159  707b		       60		      rts
    160  707c
    161  707c
    162  707c							;---------------------------------------------------------------------------------------------------
    163  707c
      0  707c					      DEF	aiDrawEntireBoard
      1  707c				   SLOT_aiDrawEntireBoard SET	_BANK_SLOT
      2  707c				   BANK_aiDrawEntireBoard SET	SLOT_aiDrawEntireBoard + _CURRENT_BANK
      3  707c				   aiDrawEntireBoard
      4  707c				   TEMPORARY_VAR SET	Overlay
      5  707c				   TEMPORARY_OFFSET SET	0
      6  707c				   VAR_BOUNDARY_aiDrawEntireBoard SET	TEMPORARY_OFFSET
      7  707c				   FUNCTION_NAME SET	aiDrawEntireBoard
    165  707c					      SUBROUTINE
    166  707c
      0  707c					      REFER	AiStateMachine
      1  707c				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  707c				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  707c					      ENDIF
      0  707c					      VEND	aiDrawEntireBoard
      1  707c				  -	      IFNCONST	aiDrawEntireBoard
      2  707c				  -	      ECHO	"Incorrect VEND label", aiDrawEntireBoard
      3  707c				  -	      ERR
      4  707c					      ENDIF
      5  707c		       00 a1	   VAREND_aiDrawEntireBoard =	TEMPORARY_VAR
    169  707c
    170  707c
    171  707c		       ad 84 02 	      lda	INTIM
    172  707f		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    173  7081		       90 2c		      bcc	.exit
    174  7083
    175  7083							; We use [SLOT3] for accessing board
    176  7083
    177  7083		       a9 cf		      lda	#RAMBANK_BOARD
    178  7085		       85 3e		      sta	SET_BANK_RAM
    179  7087		       a4 80		      ldy	squareToDraw
    180  7089		       b9 15 fc 	      lda	ValidSquare,y
    181  708c		       30 1d		      bmi	.isablank2
    182  708e
    183  708e		       b9 79 fc 	      lda	Board,y
    184  7091		       f0 13		      beq	.isablank
    185  7093		       48		      pha
    186  7094		       a9 00		      lda	#BLANK
      0  7096					      sta@RAM	Board,y
      1  7096		       99 79 fe 	      sta	[RAM]+Board,y
    188  7099
    189  7099		       20 a3 f0 	      jsr	CopySinglePiece
    190  709c
    191  709c		       a9 cf		      lda	#RAMBANK_BOARD
    192  709e		       85 3e		      sta	SET_BANK_RAM
    193  70a0
    194  70a0		       a4 80		      ldy	squareToDraw
    195  70a2		       68		      pla
      0  70a3					      sta@RAM	Board,y
      1  70a3		       99 79 fe 	      sta	[RAM]+Board,y
    197  70a6
      0  70a6				   .isablank  PHASE	AI_DrawPart2
      1  70a6		       a9 10		      lda	#AI_DrawPart2
      2  70a8		       85 8b		      sta	aiState
    199  70aa		       60		      rts
    200  70ab
      0  70ab				   .isablank2 PHASE	AI_DrawPart3
      1  70ab		       a9 11		      lda	#AI_DrawPart3
      2  70ad		       85 8b		      sta	aiState
    202  70af		       60	   .exit      rts
    203  70b0
    204  70b0
    205  70b0							;---------------------------------------------------------------------------------------------------
    206  70b0
    207  70b0				  -	      IF	ENPASSANT_ENABLED
    208  70b0				  -
    209  70b0				  -	      DEF	EnPassantCheck
    210  70b0				  -	      SUBROUTINE
    211  70b0				  -
    212  70b0				  -	      REFER	MakeMove
    213  70b0				  -	      REFER	aiSpecialMoveFixup
    214  70b0				  -	      VEND	EnPassantCheck
    215  70b0				  -
    216  70b0				  -			; {
    217  70b0				  -			; With en-passant flag, it is essentially dual-use.
    218  70b0				  -			; First, it marks if the move is *involved* somehow in an en-passant
    219  70b0				  -			; if the piece has MOVED already, then it's an en-passant capture
    220  70b0				  -			; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
    221  70b0				  -
    222  70b0				  -	      ldy	enPassantPawn	; save from previous side move
    223  70b0				  -
    224  70b0				  -	      ldx	#0	; (probably) NO en-passant this time
    225  70b0				  -	      lda	fromPiece
    226  70b0				  -	      and	#FLAG_ENPASSANT|FLAG_MOVED
    227  70b0				  -	      cmp	#FLAG_ENPASSANT
    228  70b0				  -	      bne	.noep	; HAS moved, or not en-passant
    229  70b0				  -
    230  70b0				  -	      eor	fromPiece	; clear FLAG_ENPASSANT
    231  70b0				  -	      sta	fromPiece
    232  70b0				  -
    233  70b0				  -	      ldx	fromX12	; this IS an en-passantable opening, so record the square
    234  70b0				  -.noep      stx	enPassantPawn	; capturable square for en-passant move (or none)
    235  70b0				  -
    236  70b0				  -			; }
    237  70b0				  -
    238  70b0				  -
    239  70b0				  -			; Check to see if we are doing an actual en-passant capture...
    240  70b0				  -
    241  70b0				  -			; NOTE: If using test boards for debugging, the FLAG_MOVED flag is IMPORTANT
    242  70b0				  -			;  as the en-passant will fail if the taking piece does not have this flag set correctly
    243  70b0				  -
    244  70b0				  -	      lda	fromPiece
    245  70b0				  -	      and	#FLAG_ENPASSANT
    246  70b0				  -	      beq	.notEnPassant	; not an en-passant, or it's enpassant by a MOVED piece
    247  70b0				  -
    248  70b0				  -
    249  70b0				  -			; {
    250  70b0				  -
    251  70b0				  -			; Here we are the aggressor and we need to take the pawn 'en passant' fashion
    252  70b0				  -			; y = the square containing the pawn to capture (i.e., previous value of 'enPassantPawn')
    253  70b0				  -
    254  70b0				  -			; Remove the pawn from the board and piecelist, and undraw
    255  70b0				  -
    256  70b0				  -	      sty	squareToDraw
    257  70b0				  -	      jsr	CopySinglePiece	;@0	      ; undraw captured pawn
    258  70b0				  -
    259  70b0				  -	      lda	#EVAL
    260  70b0				  -	      sta	SET_BANK	;@3
    261  70b0				  -
    262  70b0				  -	      ldy	originX12	; taken pawn's square
    263  70b0				  -	      jsr	EnPassantRemovePiece
    264  70b0				  -
    265  70b0				  -.notEnPassant
    266  70b0				  -			; }
    267  70b0				  -
    268  70b0				  -	      rts
    269  70b0				  -
    270  70b0					      ENDIF
    271  70b0
    272  70b0
    273  70b0							;---------------------------------------------------------------------------------------------------
    274  70b0
      0  70b0					      CHECK_BANK_SIZE	"TWO"
      1  70b0		       00 b0	   .TEMP      =	* - _BANK_START
 TWO (1K) SIZE =  $b0 , FREE= $350
      2  70b0					      ECHO	"TWO", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  70b0				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  70b0				  -	      ECHO	"BANK OVERFLOW @ ", "TWO", " size=", * - ORIGIN
      5  70b0				  -	      ERR
      6  70b0					      ENDIF
    276  70b0
    277  70b0							;---------------------------------------------------------------------------------------------------
    278  70b0							;EOF
------- FILE ./chess.asm
------- FILE PIECE_HANDLER@1#1.asm LEVEL 2 PASS 4
      0  70b0					      include	"PIECE_HANDLER@1#1.asm"
      0  70b0					      SLOT	1
      1  70b0				  -	      IF	(1 < 0) || (1 > 3)
      2  70b0				  -	      ECHO	"Illegal bank address/segment location", 1
      3  70b0				  -	      ERR
      4  70b0					      ENDIF
      5  70b0				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  70b0				   _BANK_SLOT SET	1 * 64
      0  70b0					      NEWBANK	PIECE_HANDLER_1
      1  7668 ????				      SEG	PIECE_HANDLER_1
      2  7400					      ORG	_ORIGIN
      3  7400					      RORG	_BANK_ADDRESS_ORIGIN
      4  7400				   _BANK_START SET	*
      5  7400				   PIECE_HANDLER_1_START SET	*
      6  7400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7400				   PIECE_HANDLER_1 SET	_BANK_SLOT + _CURRENT_BANK
      8  7400				   _ORIGIN    SET	_ORIGIN + 1024
      3  7400
------- FILE PIECE_PAWN.asm LEVEL 3 PASS 4
      0  7400					      include	"PIECE_PAWN.asm"
      1  7400							; Copyright (C)2020 Andrew Davie
      2  7400							; Pawn move handlers
      3  7400
      4  7400							;---------------------------------------------------------------------------------------------------
      5  7400							; WHITE PAWN
      6  7400							;---------------------------------------------------------------------------------------------------
      7  7400
      8  7400		       00 28	   WHITE_HOME_ROW =	40	; < this, on home row
      9  7400		       00 52	   BLACK_HOME_ROW =	82	; >= this, on home row
     10  7400
     11  7400							;---------------------------------------------------------------------------------------------------
     12  7400
     13  7400					      MAC	en_passant
     14  7400					      SUBROUTINE
     15  7400							; {1} = _LEFT or _RIGHT
     16  7400
     17  7400					      ldx	currentSquare
     18  7400					      ldy	ValidSquare+{1},x
     19  7400					      cpy	enPassantPawn
     20  7400					      bne	.invalid
     21  7400					      ldy	ValidSquare+{1}+{2},x	; en-passant endpoint must be blank
     22  7400					      lda	Board,y
     23  7400					      bne	.invalid
     24  7400					      jsr	AddMove	; the MOVE will need to deal with the details of en-passant??
     25  7400				   .invalid
     26  7400					      ENDM
     27  7400
     28  7400							;---------------------------------------------------------------------------------------------------
     29  7400
     30  7400					      MAC	promote_pawn
     31  7400							;SUBROUTINE
     32  7400
     33  7400							;{1} = BLACK or WHITE
     34  7400
     35  7400
     36  7400					      sty	__temp
     37  7400					      lda	#{1}|QUEEN
     38  7400					      sta	currentPiece
     39  7400					      jsr	AddMove
     40  7400
     41  7400					      lda	#{1}|ROOK
     42  7400					      sta	currentPiece
     43  7400					      ldy	__temp
     44  7400					      jsr	AddMove
     45  7400
     46  7400					      lda	#{1}|BISHOP
     47  7400					      sta	currentPiece
     48  7400					      ldy	__temp
     49  7400					      jsr	AddMove
     50  7400
     51  7400					      lda	#{1}|KNIGHT
     52  7400					      sta	currentPiece
     53  7400					      ldy	__temp
     54  7400					      jsr	AddMove
     55  7400
     56  7400					      IF	{1} = WHITE
     57  7400					      lda	#WHITE|WP
     58  7400					      ENDIF
     59  7400					      IF	{1} = BLACK
     60  7400					      lda	#BLACK|BP
     61  7400					      ENDIF
     62  7400					      sta	currentPiece
     63  7400					      ENDM
     64  7400
     65  7400							;---------------------------------------------------------------------------------------------------
     66  7400
     67  7400					      MAC	move_or_promote_pawn
     68  7400							;SUBROUTINE
     69  7400							; {1} = BLACK or WHITE
     70  7400
     71  7400					      IF	{1} = WHITE
     72  7400					      cpy	#90	; last rank?
     73  7400					      bcc	.standard
     74  7400					      jsr	PromoteWhitePawn
     75  7400					      jmp	.pMoved
     76  7400					      ENDIF
     77  7400
     78  7400					      IF	{1} = BLACK
     79  7400					      cpy	#30	; last rank?
     80  7400					      bcs	.standard
     81  7400					      jsr	PromoteBlackPawn
     82  7400					      jmp	.pMoved
     83  7400					      ENDIF
     84  7400
     85  7400				   .standard  jsr	AddMove	; add +1UP move
     86  7400				   .pMoved
     87  7400
     88  7400					      ENDM
     89  7400
     90  7400							;---------------------------------------------------------------------------------------------------
     91  7400
     92  7400					      MAC	take
     93  7400							;SUBROUTINE
     94  7400							; {1} = capture square offset
     95  7400
     96  7400					      ldx	currentSquare
     97  7400					      ldy	ValidSquare+{1},x
     98  7400					      bmi	.invalid2
     99  7400					      lda	Board,y
    100  7400					      beq	.invalid2	; square empty
    101  7400					      sta	capture
    102  7400					      eor	currentPiece
    103  7400					      bpl	.invalid	; same colour
    104  7400
    105  7400					      MOVE_OR_PROMOTE_PAWN	{2}
    106  7400
    107  7400					      jmp	.invalid2
    108  7400				   .invalid   inc	protecting
    109  7400				   .invalid2
    110  7400					      ENDM
    111  7400
    112  7400							;---------------------------------------------------------------------------------------------------
    113  7400
      0  7400					      DEF	PromoteWhitePawn
      1  7400				   SLOT_PromoteWhitePawn SET	_BANK_SLOT
      2  7400				   BANK_PromoteWhitePawn SET	SLOT_PromoteWhitePawn + _CURRENT_BANK
      3  7400				   PromoteWhitePawn
      4  7400				   TEMPORARY_VAR SET	Overlay
      5  7400				   TEMPORARY_OFFSET SET	0
      6  7400				   VAR_BOUNDARY_PromoteWhitePawn SET	TEMPORARY_OFFSET
      7  7400				   FUNCTION_NAME SET	PromoteWhitePawn
    115  7400					      SUBROUTINE
    116  7400
      0  7400					      REFER	Handle_WHITE_PAWN
      1  7400					      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  7400				   TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  7400					      ENDIF
      0  7400					      VAR	__temp, 1
      1  7400		       00 b2	   __temp     =	TEMPORARY_VAR
      2  7400				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7400
      4  7400				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7400				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7400				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7400					      ENDIF
      8  7400				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7400				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  7400				  -	      ERR
     11  7400					      ENDIF
     12  7400					      LIST	ON
      0  7400					      VEND	PromoteWhitePawn
      1  7400				  -	      IFNCONST	PromoteWhitePawn
      2  7400				  -	      ECHO	"Incorrect VEND label", PromoteWhitePawn
      3  7400				  -	      ERR
      4  7400					      ENDIF
      5  7400		       00 b3	   VAREND_PromoteWhitePawn =	TEMPORARY_VAR
    120  7400
      0  7400					      PROMOTE_PAWN	WHITE
      1  7400
      2  7400
      3  7400
      4  7400
      5  7400
      6  7400		       84 b2		      sty	__temp
      7  7402		       a9 06		      lda	#WHITE|QUEEN
      8  7404		       85 91		      sta	currentPiece
      9  7406		       20 0e f2 	      jsr	AddMove
     10  7409
     11  7409		       a9 05		      lda	#WHITE|ROOK
     12  740b		       85 91		      sta	currentPiece
     13  740d		       a4 b2		      ldy	__temp
     14  740f		       20 0e f2 	      jsr	AddMove
     15  7412
     16  7412		       a9 04		      lda	#WHITE|BISHOP
     17  7414		       85 91		      sta	currentPiece
     18  7416		       a4 b2		      ldy	__temp
     19  7418		       20 0e f2 	      jsr	AddMove
     20  741b
     21  741b		       a9 03		      lda	#WHITE|KNIGHT
     22  741d		       85 91		      sta	currentPiece
     23  741f		       a4 b2		      ldy	__temp
     24  7421		       20 0e f2 	      jsr	AddMove
     25  7424
     26  7424					      IF	WHITE = WHITE
     27  7424		       a9 01		      lda	#WHITE|WP
     28  7426					      ENDIF
     29  7426				  -	      IF	WHITE = BLACK
     30  7426				  -	      lda	#BLACK|BP
     31  7426					      ENDIF
     32  7426		       85 91		      sta	currentPiece
    122  7428		       60		      rts
    123  7429
    124  7429							;---------------------------------------------------------------------------------------------------
    125  7429
      0  7429					      DEF	Handle_WHITE_PAWN
      1  7429				   SLOT_Handle_WHITE_PAWN SET	_BANK_SLOT
      2  7429				   BANK_Handle_WHITE_PAWN SET	SLOT_Handle_WHITE_PAWN + _CURRENT_BANK
      3  7429				   Handle_WHITE_PAWN
      4  7429				   TEMPORARY_VAR SET	Overlay
      5  7429				   TEMPORARY_OFFSET SET	0
      6  7429				   VAR_BOUNDARY_Handle_WHITE_PAWN SET	TEMPORARY_OFFSET
      7  7429				   FUNCTION_NAME SET	Handle_WHITE_PAWN
    127  7429					      SUBROUTINE
    128  7429
      0  7429					      REFER	GenerateAllMoves
      1  7429					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  7429				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  7429					      ENDIF
      0  7429					      VEND	Handle_WHITE_PAWN
      1  7429				  -	      IFNCONST	Handle_WHITE_PAWN
      2  7429				  -	      ECHO	"Incorrect VEND label", Handle_WHITE_PAWN
      3  7429				  -	      ERR
      4  7429					      ENDIF
      5  7429		       00 b2	   VAREND_Handle_WHITE_PAWN =	TEMPORARY_VAR
    131  7429
    132  7429		       bc 1f fc 	      ldy	ValidSquare+_UP,x	; square above must be blank (WILL NOT EVER be off-board!)
    133  742c		       b9 79 fc 	      lda	Board,y
    134  742f		       d0 26		      bne	.pMoved	; occupied
    135  7431		       85 9d		      sta	capture
    136  7433
    137  7433							; we may need to promote the pawn
    138  7433							; All possibilites (Q/R/B/N) are added as individual moves
    139  7433
      0  7433					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  7433
      2  7433
      3  7433
      4  7433					      IF	WHITE = WHITE
      5  7433		       c0 5a		      cpy	#90
      6  7435		       90 06		      bcc	.standard
      7  7437		       20 00 f4 	      jsr	PromoteWhitePawn
      8  743a		       4c 40 f4 	      jmp	.pMoved
      9  743d					      ENDIF
     10  743d
     11  743d				  -	      IF	WHITE = BLACK
     12  743d				  -	      cpy	#30
     13  743d				  -	      bcs	.standard
     14  743d				  -	      jsr	PromoteBlackPawn
     15  743d				  -	      jmp	.pMoved
     16  743d					      ENDIF
     17  743d
     18  743d		       20 0e f2    .standard  jsr	AddMove
     19  7440				   .pMoved
     20  7440
    141  7440
    142  7440							; the +2 move off the home rank...
    143  7440
    144  7440		       a6 92		      ldx	currentSquare
    145  7442		       e0 28		      cpx	#WHITE_HOME_ROW
    146  7444		       b0 11		      bcs	.pMoved	; pawn has moved so can't do +2
    147  7446		       bc 29 fc 	      ldy	ValidSquare+_UP+_UP,x	; WILL be a valid square
    148  7449		       b9 79 fc 	      lda	Board,y
    149  744c		       d0 09		      bne	.pMoved	; destination square occupied
    150  744e
    151  744e		       a5 91		      lda	currentPiece
    152  7450		       09 20		      ora	#FLAG_ENPASSANT
    153  7452		       85 91		      sta	currentPiece	; GENERATE en-passant opportunity
    154  7454
    155  7454		       20 0e f2 	      jsr	AddMove	; add the +2UP move off home row
    156  7457
    157  7457				   .pMoved
    158  7457
    159  7457							; regular captures...
    160  7457
      0  7457					      TAKE	_UP+_LEFT, WHITE
      1  7457
      2  7457
      3  7457
      4  7457		       a6 92		      ldx	currentSquare
      5  7459		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      6  745c		       30 1d		      bmi	.invalid2
      7  745e		       b9 79 fc 	      lda	Board,y
      8  7461		       f0 18		      beq	.invalid2
      9  7463		       85 9d		      sta	capture
     10  7465		       45 91		      eor	currentPiece
     11  7467		       10 10		      bpl	.invalid
     12  7469
      0  7469					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  7469
      2  7469
      3  7469
      4  7469					      IF	WHITE = WHITE
      5  7469		       c0 5a		      cpy	#90
      6  746b		       90 06		      bcc	.standard
      7  746d		       20 00 f4 	      jsr	PromoteWhitePawn
      8  7470		       4c 76 f4 	      jmp	.pMoved
      9  7473					      ENDIF
     10  7473
     11  7473				  -	      IF	WHITE = BLACK
     12  7473				  -	      cpy	#30
     13  7473				  -	      bcs	.standard
     14  7473				  -	      jsr	PromoteBlackPawn
     15  7473				  -	      jmp	.pMoved
     16  7473					      ENDIF
     17  7473
     18  7473		       20 0e f2    .standard  jsr	AddMove
     19  7476				   .pMoved
     20  7476
     14  7476
     15  7476		       4c 7b f4 	      jmp	.invalid2
     16  7479		       e6 9f	   .invalid   inc	protecting
     17  747b				   .invalid2
      0  747b					      TAKE	_UP+_RIGHT, WHITE
      1  747b
      2  747b
      3  747b
      4  747b		       a6 92		      ldx	currentSquare
      5  747d		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      6  7480		       30 1d		      bmi	.invalid2
      7  7482		       b9 79 fc 	      lda	Board,y
      8  7485		       f0 18		      beq	.invalid2
      9  7487		       85 9d		      sta	capture
     10  7489		       45 91		      eor	currentPiece
     11  748b		       10 10		      bpl	.invalid
     12  748d
      0  748d					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  748d
      2  748d
      3  748d
      4  748d					      IF	WHITE = WHITE
      5  748d		       c0 5a		      cpy	#90
      6  748f		       90 06		      bcc	.standard
      7  7491		       20 00 f4 	      jsr	PromoteWhitePawn
      8  7494		       4c 9a f4 	      jmp	.pMoved
      9  7497					      ENDIF
     10  7497
     11  7497				  -	      IF	WHITE = BLACK
     12  7497				  -	      cpy	#30
     13  7497				  -	      bcs	.standard
     14  7497				  -	      jsr	PromoteBlackPawn
     15  7497				  -	      jmp	.pMoved
     16  7497					      ENDIF
     17  7497
     18  7497		       20 0e f2    .standard  jsr	AddMove
     19  749a				   .pMoved
     20  749a
     14  749a
     15  749a		       4c 9f f4 	      jmp	.invalid2
     16  749d		       e6 9f	   .invalid   inc	protecting
     17  749f				   .invalid2
    163  749f
    164  749f
    165  749f				  -	      IF	ENPASSANT_ENABLED
    166  749f				  -			; en-passant captures...
    167  749f				  -
    168  749f				  -	      lda	enPassantPawn
    169  749f				  -	      beq	.noEnPassant	; previous move (opponent) enpassant square?
    170  749f				  -
    171  749f				  -	      lda	currentPiece
    172  749f				  -	      ora	#FLAG_ENPASSANT
    173  749f				  -	      sta	currentPiece	; CONSUME en-passant opportunity
    174  749f				  -
    175  749f				  -	      EN_PASSANT	_LEFT, _UP
    176  749f				  -	      EN_PASSANT	_RIGHT, _UP
    177  749f				  -
    178  749f				  -.noEnPassant
    179  749f					      ENDIF
    180  749f
    181  749f		       4c 99 f1 	      jmp	MoveReturn
    182  74a2
    183  74a2
    184  74a2							;---------------------------------------------------------------------------------------------------
    185  74a2							; BLACK PAWN
    186  74a2							;---------------------------------------------------------------------------------------------------
    187  74a2
      0  74a2					      DEF	PromoteBlackPawn
      1  74a2				   SLOT_PromoteBlackPawn SET	_BANK_SLOT
      2  74a2				   BANK_PromoteBlackPawn SET	SLOT_PromoteBlackPawn + _CURRENT_BANK
      3  74a2				   PromoteBlackPawn
      4  74a2				   TEMPORARY_VAR SET	Overlay
      5  74a2				   TEMPORARY_OFFSET SET	0
      6  74a2				   VAR_BOUNDARY_PromoteBlackPawn SET	TEMPORARY_OFFSET
      7  74a2				   FUNCTION_NAME SET	PromoteBlackPawn
    189  74a2					      SUBROUTINE
    190  74a2
      0  74a2					      REFER	Handle_BLACK_PAWN
      1  74a2					      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  74a2				   TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  74a2					      ENDIF
      0  74a2					      VAR	__temp, 1
      1  74a2		       00 b2	   __temp     =	TEMPORARY_VAR
      2  74a2				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  74a2
      4  74a2				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  74a2				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  74a2				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  74a2					      ENDIF
      8  74a2				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  74a2				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  74a2				  -	      ERR
     11  74a2					      ENDIF
     12  74a2					      LIST	ON
      0  74a2					      VEND	PromoteBlackPawn
      1  74a2				  -	      IFNCONST	PromoteBlackPawn
      2  74a2				  -	      ECHO	"Incorrect VEND label", PromoteBlackPawn
      3  74a2				  -	      ERR
      4  74a2					      ENDIF
      5  74a2		       00 b3	   VAREND_PromoteBlackPawn =	TEMPORARY_VAR
    194  74a2
      0  74a2					      PROMOTE_PAWN	BLACK
      1  74a2
      2  74a2
      3  74a2
      4  74a2
      5  74a2
      6  74a2		       84 b2		      sty	__temp
      7  74a4		       a9 86		      lda	#BLACK|QUEEN
      8  74a6		       85 91		      sta	currentPiece
      9  74a8		       20 0e f2 	      jsr	AddMove
     10  74ab
     11  74ab		       a9 85		      lda	#BLACK|ROOK
     12  74ad		       85 91		      sta	currentPiece
     13  74af		       a4 b2		      ldy	__temp
     14  74b1		       20 0e f2 	      jsr	AddMove
     15  74b4
     16  74b4		       a9 84		      lda	#BLACK|BISHOP
     17  74b6		       85 91		      sta	currentPiece
     18  74b8		       a4 b2		      ldy	__temp
     19  74ba		       20 0e f2 	      jsr	AddMove
     20  74bd
     21  74bd		       a9 83		      lda	#BLACK|KNIGHT
     22  74bf		       85 91		      sta	currentPiece
     23  74c1		       a4 b2		      ldy	__temp
     24  74c3		       20 0e f2 	      jsr	AddMove
     25  74c6
     26  74c6				  -	      IF	BLACK = WHITE
     27  74c6				  -	      lda	#WHITE|WP
     28  74c6					      ENDIF
     29  74c6					      IF	BLACK = BLACK
     30  74c6		       a9 82		      lda	#BLACK|BP
     31  74c8					      ENDIF
     32  74c8		       85 91		      sta	currentPiece
    196  74ca		       60		      rts
    197  74cb
      0  74cb					      DEF	Handle_BLACK_PAWN
      1  74cb				   SLOT_Handle_BLACK_PAWN SET	_BANK_SLOT
      2  74cb				   BANK_Handle_BLACK_PAWN SET	SLOT_Handle_BLACK_PAWN + _CURRENT_BANK
      3  74cb				   Handle_BLACK_PAWN
      4  74cb				   TEMPORARY_VAR SET	Overlay
      5  74cb				   TEMPORARY_OFFSET SET	0
      6  74cb				   VAR_BOUNDARY_Handle_BLACK_PAWN SET	TEMPORARY_OFFSET
      7  74cb				   FUNCTION_NAME SET	Handle_BLACK_PAWN
    199  74cb					      SUBROUTINE
    200  74cb
      0  74cb					      REFER	GenerateAllMoves
      1  74cb					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  74cb				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  74cb					      ENDIF
      0  74cb					      VEND	Handle_BLACK_PAWN
      1  74cb				  -	      IFNCONST	Handle_BLACK_PAWN
      2  74cb				  -	      ECHO	"Incorrect VEND label", Handle_BLACK_PAWN
      3  74cb				  -	      ERR
      4  74cb					      ENDIF
      5  74cb		       00 b2	   VAREND_Handle_BLACK_PAWN =	TEMPORARY_VAR
    203  74cb
    204  74cb		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x	; square below must be blank (WILL NOT EVER be off-board!)
    205  74ce		       b9 79 fc 	      lda	Board,y
    206  74d1		       d0 26		      bne	.pMoved	; occupied
    207  74d3		       85 9d		      sta	capture
    208  74d5
    209  74d5							; we may need to promote the pawn
    210  74d5							; All possibilites (Q/R/B/N) are added as individual moves
    211  74d5
      0  74d5					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  74d5
      2  74d5
      3  74d5
      4  74d5				  -	      IF	BLACK = WHITE
      5  74d5				  -	      cpy	#90
      6  74d5				  -	      bcc	.standard
      7  74d5				  -	      jsr	PromoteWhitePawn
      8  74d5				  -	      jmp	.pMoved
      9  74d5					      ENDIF
     10  74d5
     11  74d5					      IF	BLACK = BLACK
     12  74d5		       c0 1e		      cpy	#30
     13  74d7		       b0 06		      bcs	.standard
     14  74d9		       20 a2 f4 	      jsr	PromoteBlackPawn
     15  74dc		       4c e2 f4 	      jmp	.pMoved
     16  74df					      ENDIF
     17  74df
     18  74df		       20 0e f2    .standard  jsr	AddMove
     19  74e2				   .pMoved
     20  74e2
    213  74e2
    214  74e2							; the +2 move off the home rank...
    215  74e2
    216  74e2		       a6 92		      ldx	currentSquare
    217  74e4		       e0 52		      cpx	#BLACK_HOME_ROW
    218  74e6		       90 11		      bcc	.pMoved	; pawn has moved so can't do +2
    219  74e8
    220  74e8
    221  74e8		       bc 01 fc 	      ldy	ValidSquare+_DOWN+_DOWN,x	; WILL be a valid square
    222  74eb		       b9 79 fc 	      lda	Board,y
    223  74ee		       d0 09		      bne	.pMoved	; destination square occupied
    224  74f0
    225  74f0		       a5 91		      lda	currentPiece
    226  74f2		       09 20		      ora	#FLAG_ENPASSANT
    227  74f4		       85 91		      sta	currentPiece	; CAN en-passant
    228  74f6
    229  74f6		       20 0e f2 	      jsr	AddMove	; add the +2DOWN move off home row
    230  74f9
    231  74f9				   .pMoved
    232  74f9
    233  74f9							; regular captures... (with promotion)
    234  74f9
      0  74f9					      TAKE	_DOWN+_LEFT, BLACK
      1  74f9
      2  74f9
      3  74f9
      4  74f9		       a6 92		      ldx	currentSquare
      5  74fb		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      6  74fe		       30 1d		      bmi	.invalid2
      7  7500		       b9 79 fc 	      lda	Board,y
      8  7503		       f0 18		      beq	.invalid2
      9  7505		       85 9d		      sta	capture
     10  7507		       45 91		      eor	currentPiece
     11  7509		       10 10		      bpl	.invalid
     12  750b
      0  750b					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  750b
      2  750b
      3  750b
      4  750b				  -	      IF	BLACK = WHITE
      5  750b				  -	      cpy	#90
      6  750b				  -	      bcc	.standard
      7  750b				  -	      jsr	PromoteWhitePawn
      8  750b				  -	      jmp	.pMoved
      9  750b					      ENDIF
     10  750b
     11  750b					      IF	BLACK = BLACK
     12  750b		       c0 1e		      cpy	#30
     13  750d		       b0 06		      bcs	.standard
     14  750f		       20 a2 f4 	      jsr	PromoteBlackPawn
     15  7512		       4c 18 f5 	      jmp	.pMoved
     16  7515					      ENDIF
     17  7515
     18  7515		       20 0e f2    .standard  jsr	AddMove
     19  7518				   .pMoved
     20  7518
     14  7518
     15  7518		       4c 1d f5 	      jmp	.invalid2
     16  751b		       e6 9f	   .invalid   inc	protecting
     17  751d				   .invalid2
      0  751d					      TAKE	_DOWN+_RIGHT, BLACK
      1  751d
      2  751d
      3  751d
      4  751d		       a6 92		      ldx	currentSquare
      5  751f		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      6  7522		       30 1d		      bmi	.invalid2
      7  7524		       b9 79 fc 	      lda	Board,y
      8  7527		       f0 18		      beq	.invalid2
      9  7529		       85 9d		      sta	capture
     10  752b		       45 91		      eor	currentPiece
     11  752d		       10 10		      bpl	.invalid
     12  752f
      0  752f					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  752f
      2  752f
      3  752f
      4  752f				  -	      IF	BLACK = WHITE
      5  752f				  -	      cpy	#90
      6  752f				  -	      bcc	.standard
      7  752f				  -	      jsr	PromoteWhitePawn
      8  752f				  -	      jmp	.pMoved
      9  752f					      ENDIF
     10  752f
     11  752f					      IF	BLACK = BLACK
     12  752f		       c0 1e		      cpy	#30
     13  7531		       b0 06		      bcs	.standard
     14  7533		       20 a2 f4 	      jsr	PromoteBlackPawn
     15  7536		       4c 3c f5 	      jmp	.pMoved
     16  7539					      ENDIF
     17  7539
     18  7539		       20 0e f2    .standard  jsr	AddMove
     19  753c				   .pMoved
     20  753c
     14  753c
     15  753c		       4c 41 f5 	      jmp	.invalid2
     16  753f		       e6 9f	   .invalid   inc	protecting
     17  7541				   .invalid2
    237  7541
    238  7541
    239  7541				  -	      IF	ENPASSANT_ENABLED
    240  7541				  -			; en-passant captures...
    241  7541				  -
    242  7541				  -	      lda	enPassantPawn
    243  7541				  -	      beq	.noEnPassant	; was last move en-passantable?
    244  7541				  -
    245  7541				  -	      lda	currentPiece
    246  7541				  -	      ora	#FLAG_ENPASSANT
    247  7541				  -	      sta	currentPiece	; any en-passant move added will have flag set
    248  7541				  -
    249  7541				  -	      EN_PASSANT	_LEFT, _DOWN
    250  7541				  -	      EN_PASSANT	_RIGHT, _DOWN
    251  7541				  -
    252  7541				  -.noEnPassant
    253  7541					      ENDIF
    254  7541
    255  7541		       4c 99 f1 	      jmp	MoveReturn
    256  7544
    257  7544							; EOF
------- FILE PIECE_HANDLER@1#1.asm
------- FILE PIECE_KNIGHT.asm LEVEL 3 PASS 4
      0  7544					      include	"PIECE_KNIGHT.asm"
      1  7544							; Copyright (C)2020 Andrew Davie
      2  7544							; Knight move handler
      3  7544
      4  7544							;---------------------------------------------------------------------------------------------------
      5  7544							; KNIGHT
      6  7544							;---------------------------------------------------------------------------------------------------
      7  7544
      0  7544					      DEF	Handle_KNIGHT
      1  7544				   SLOT_Handle_KNIGHT SET	_BANK_SLOT
      2  7544				   BANK_Handle_KNIGHT SET	SLOT_Handle_KNIGHT + _CURRENT_BANK
      3  7544				   Handle_KNIGHT
      4  7544				   TEMPORARY_VAR SET	Overlay
      5  7544				   TEMPORARY_OFFSET SET	0
      6  7544				   VAR_BOUNDARY_Handle_KNIGHT SET	TEMPORARY_OFFSET
      7  7544				   FUNCTION_NAME SET	Handle_KNIGHT
      9  7544					      SUBROUTINE
     10  7544
      0  7544					      REFER	GenerateAllMoves
      1  7544					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  7544				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  7544					      ENDIF
      0  7544					      VEND	Handle_KNIGHT
      1  7544				  -	      IFNCONST	Handle_KNIGHT
      2  7544				  -	      ECHO	"Incorrect VEND label", Handle_KNIGHT
      3  7544				  -	      ERR
      4  7544					      ENDIF
      5  7544		       00 b2	   VAREND_Handle_KNIGHT =	TEMPORARY_VAR
     13  7544
     14  7544							; x = currentSquare (square the piece is on)
     15  7544							; currentPiece (with flags/colour attached)
     16  7544
      0  7544					      MOVE_TO	_DOWN+_DOWN+_LEFT
      1  7544					      SUBROUTINE
      2  7544		       bc 00 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_LEFT,x
      3  7547		       30 0e		      bmi	.invalid
      4  7549		       b9 79 fc 	      lda	Board,y
      5  754c		       85 9d		      sta	capture
      6  754e		       f0 04		      beq	.squareEmpty
      7  7550		       45 91		      eor	currentPiece
      8  7552		       10 03		      bpl	.invalid
      9  7554		       20 0e f2    .squareEmpty jsr	AddMove
     10  7557				   .invalid
      0  7557					      MOVE_TO_X	_DOWN+_DOWN+_RIGHT
      1  7557		       a6 92		      ldx	currentSquare
      0  7559					      MOVE_TO	_DOWN+_DOWN+_RIGHT
      1  7559					      SUBROUTINE
      2  7559		       bc 02 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_RIGHT,x
      3  755c		       30 0e		      bmi	.invalid
      4  755e		       b9 79 fc 	      lda	Board,y
      5  7561		       85 9d		      sta	capture
      6  7563		       f0 04		      beq	.squareEmpty
      7  7565		       45 91		      eor	currentPiece
      8  7567		       10 03		      bpl	.invalid
      9  7569		       20 0e f2    .squareEmpty jsr	AddMove
     10  756c				   .invalid
      0  756c					      MOVE_TO_X	_UP+_UP+_LEFT
      1  756c		       a6 92		      ldx	currentSquare
      0  756e					      MOVE_TO	_UP+_UP+_LEFT
      1  756e					      SUBROUTINE
      2  756e		       bc 28 fc 	      ldy	ValidSquare+_UP+_UP+_LEFT,x
      3  7571		       30 0e		      bmi	.invalid
      4  7573		       b9 79 fc 	      lda	Board,y
      5  7576		       85 9d		      sta	capture
      6  7578		       f0 04		      beq	.squareEmpty
      7  757a		       45 91		      eor	currentPiece
      8  757c		       10 03		      bpl	.invalid
      9  757e		       20 0e f2    .squareEmpty jsr	AddMove
     10  7581				   .invalid
      0  7581					      MOVE_TO_X	_UP+_UP+_RIGHT
      1  7581		       a6 92		      ldx	currentSquare
      0  7583					      MOVE_TO	_UP+_UP+_RIGHT
      1  7583					      SUBROUTINE
      2  7583		       bc 2a fc 	      ldy	ValidSquare+_UP+_UP+_RIGHT,x
      3  7586		       30 0e		      bmi	.invalid
      4  7588		       b9 79 fc 	      lda	Board,y
      5  758b		       85 9d		      sta	capture
      6  758d		       f0 04		      beq	.squareEmpty
      7  758f		       45 91		      eor	currentPiece
      8  7591		       10 03		      bpl	.invalid
      9  7593		       20 0e f2    .squareEmpty jsr	AddMove
     10  7596				   .invalid
     21  7596
      0  7596					      MOVE_TO_X	_DOWN+_LEFT+_LEFT
      1  7596		       a6 92		      ldx	currentSquare
      0  7598					      MOVE_TO	_DOWN+_LEFT+_LEFT
      1  7598					      SUBROUTINE
      2  7598		       bc 09 fc 	      ldy	ValidSquare+_DOWN+_LEFT+_LEFT,x
      3  759b		       30 0e		      bmi	.invalid
      4  759d		       b9 79 fc 	      lda	Board,y
      5  75a0		       85 9d		      sta	capture
      6  75a2		       f0 04		      beq	.squareEmpty
      7  75a4		       45 91		      eor	currentPiece
      8  75a6		       10 03		      bpl	.invalid
      9  75a8		       20 0e f2    .squareEmpty jsr	AddMove
     10  75ab				   .invalid
      0  75ab					      MOVE_TO_X	_DOWN+_RIGHT+_RIGHT
      1  75ab		       a6 92		      ldx	currentSquare
      0  75ad					      MOVE_TO	_DOWN+_RIGHT+_RIGHT
      1  75ad					      SUBROUTINE
      2  75ad		       bc 0d fc 	      ldy	ValidSquare+_DOWN+_RIGHT+_RIGHT,x
      3  75b0		       30 0e		      bmi	.invalid
      4  75b2		       b9 79 fc 	      lda	Board,y
      5  75b5		       85 9d		      sta	capture
      6  75b7		       f0 04		      beq	.squareEmpty
      7  75b9		       45 91		      eor	currentPiece
      8  75bb		       10 03		      bpl	.invalid
      9  75bd		       20 0e f2    .squareEmpty jsr	AddMove
     10  75c0				   .invalid
      0  75c0					      MOVE_TO_X	_UP+_LEFT+_LEFT
      1  75c0		       a6 92		      ldx	currentSquare
      0  75c2					      MOVE_TO	_UP+_LEFT+_LEFT
      1  75c2					      SUBROUTINE
      2  75c2		       bc 1d fc 	      ldy	ValidSquare+_UP+_LEFT+_LEFT,x
      3  75c5		       30 0e		      bmi	.invalid
      4  75c7		       b9 79 fc 	      lda	Board,y
      5  75ca		       85 9d		      sta	capture
      6  75cc		       f0 04		      beq	.squareEmpty
      7  75ce		       45 91		      eor	currentPiece
      8  75d0		       10 03		      bpl	.invalid
      9  75d2		       20 0e f2    .squareEmpty jsr	AddMove
     10  75d5				   .invalid
      0  75d5					      MOVE_TO_X	_UP+_RIGHT+_RIGHT
      1  75d5		       a6 92		      ldx	currentSquare
      0  75d7					      MOVE_TO	_UP+_RIGHT+_RIGHT
      1  75d7					      SUBROUTINE
      2  75d7		       bc 21 fc 	      ldy	ValidSquare+_UP+_RIGHT+_RIGHT,x
      3  75da		       30 0e		      bmi	.invalid
      4  75dc		       b9 79 fc 	      lda	Board,y
      5  75df		       85 9d		      sta	capture
      6  75e1		       f0 04		      beq	.squareEmpty
      7  75e3		       45 91		      eor	currentPiece
      8  75e5		       10 03		      bpl	.invalid
      9  75e7		       20 0e f2    .squareEmpty jsr	AddMove
     10  75ea				   .invalid
     26  75ea
     27  75ea		       4c 99 f1 	      jmp	MoveReturn
     28  75ed
     29  75ed							; EOF
------- FILE PIECE_HANDLER@1#1.asm
------- FILE PIECE_BISHOP.asm LEVEL 3 PASS 4
      0  75ed					      include	"PIECE_BISHOP.asm"
      1  75ed							; Copyright (C)2020 Andrew Davie
      2  75ed
      3  75ed							;---------------------------------------------------------------------------------------------------
      4  75ed							; BISHOP
      5  75ed							;---------------------------------------------------------------------------------------------------
      6  75ed
      0  75ed					      DEF	Handle_BISHOP
      1  75ed				   SLOT_Handle_BISHOP SET	_BANK_SLOT
      2  75ed				   BANK_Handle_BISHOP SET	SLOT_Handle_BISHOP + _CURRENT_BANK
      3  75ed				   Handle_BISHOP
      4  75ed				   TEMPORARY_VAR SET	Overlay
      5  75ed				   TEMPORARY_OFFSET SET	0
      6  75ed				   VAR_BOUNDARY_Handle_BISHOP SET	TEMPORARY_OFFSET
      7  75ed				   FUNCTION_NAME SET	Handle_BISHOP
      8  75ed					      SUBROUTINE
      9  75ed
      0  75ed					      REFER	GenerateAllMoves
      1  75ed					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  75ed				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  75ed					      ENDIF
      0  75ed					      VEND	Handle_BISHOP
      1  75ed				  -	      IFNCONST	Handle_BISHOP
      2  75ed				  -	      ECHO	"Incorrect VEND label", Handle_BISHOP
      3  75ed				  -	      ERR
      4  75ed					      ENDIF
      5  75ed		       00 b2	   VAREND_Handle_BISHOP =	TEMPORARY_VAR
     12  75ed
     13  75ed							; x = currentSquare (square the piece is on)
     14  75ed							; currentPiece (with flags/colour attached)
     15  75ed
      0  75ed					      MOVE_TOWARDS	_DOWN+_LEFT
      1  75ed					      SUBROUTINE
      2  75ed
      3  75ed
      4  75ed
      5  75ed		       a9 00		      lda	#0
      6  75ef		       85 9d		      sta	capture
      7  75f1
      8  75f1		       a6 92		      ldx	currentSquare
      9  75f3		       d0 03		      bne	.project
     10  75f5
     11  75f5		       20 00 f4    .empty     jsr	AddMoveSlider
     12  75f8		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  75fb		       30 0e		      bmi	.invalid
     14  75fd		       b9 79 fc 	      lda	Board,y
     15  7600		       f0 f3		      beq	.empty
     16  7602		       85 9d		      sta	capture
     17  7604		       45 91		      eor	currentPiece
     18  7606		       10 03		      bpl	.invalid
     19  7608		       20 0e f2 	      jsr	AddMove
     20  760b
     21  760b				   .invalid
      0  760b					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  760b					      SUBROUTINE
      2  760b
      3  760b
      4  760b
      5  760b		       a9 00		      lda	#0
      6  760d		       85 9d		      sta	capture
      7  760f
      8  760f		       a6 92		      ldx	currentSquare
      9  7611		       d0 03		      bne	.project
     10  7613
     11  7613		       20 00 f4    .empty     jsr	AddMoveSlider
     12  7616		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  7619		       30 0e		      bmi	.invalid
     14  761b		       b9 79 fc 	      lda	Board,y
     15  761e		       f0 f3		      beq	.empty
     16  7620		       85 9d		      sta	capture
     17  7622		       45 91		      eor	currentPiece
     18  7624		       10 03		      bpl	.invalid
     19  7626		       20 0e f2 	      jsr	AddMove
     20  7629
     21  7629				   .invalid
      0  7629					      MOVE_TOWARDS	_UP+_LEFT
      1  7629					      SUBROUTINE
      2  7629
      3  7629
      4  7629
      5  7629		       a9 00		      lda	#0
      6  762b		       85 9d		      sta	capture
      7  762d
      8  762d		       a6 92		      ldx	currentSquare
      9  762f		       d0 03		      bne	.project
     10  7631
     11  7631		       20 00 f4    .empty     jsr	AddMoveSlider
     12  7634		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  7637		       30 0e		      bmi	.invalid
     14  7639		       b9 79 fc 	      lda	Board,y
     15  763c		       f0 f3		      beq	.empty
     16  763e		       85 9d		      sta	capture
     17  7640		       45 91		      eor	currentPiece
     18  7642		       10 03		      bpl	.invalid
     19  7644		       20 0e f2 	      jsr	AddMove
     20  7647
     21  7647				   .invalid
      0  7647					      MOVE_TOWARDS	_UP+_RIGHT
      1  7647					      SUBROUTINE
      2  7647
      3  7647
      4  7647
      5  7647		       a9 00		      lda	#0
      6  7649		       85 9d		      sta	capture
      7  764b
      8  764b		       a6 92		      ldx	currentSquare
      9  764d		       d0 03		      bne	.project
     10  764f
     11  764f		       20 00 f4    .empty     jsr	AddMoveSlider
     12  7652		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  7655		       30 0e		      bmi	.invalid
     14  7657		       b9 79 fc 	      lda	Board,y
     15  765a		       f0 f3		      beq	.empty
     16  765c		       85 9d		      sta	capture
     17  765e		       45 91		      eor	currentPiece
     18  7660		       10 03		      bpl	.invalid
     19  7662		       20 0e f2 	      jsr	AddMove
     20  7665
     21  7665				   .invalid
     20  7665
     21  7665		       4c 99 f1 	      jmp	MoveReturn
     22  7668
     23  7668							;---------------------------------------------------------------------------------------------------
     24  7668							; EOF
------- FILE PIECE_HANDLER@1#1.asm
      7  7668
      8  7668							;---------------------------------------------------------------------------------------------------
      9  7668
      0  7668					      CHECK_BANK_SIZE	"PIECE_HANDLER_1"
      1  7668		       02 68	   .TEMP      =	* - _BANK_START
 PIECE_HANDLER_1 (1K) SIZE =  $268 , FREE= $198
      2  7668					      ECHO	"PIECE_HANDLER_1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  7668				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  7668				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_HANDLER_1", " size=", * - ORIGIN
      5  7668				  -	      ERR
      6  7668					      ENDIF
     11  7668
     12  7668							;---------------------------------------------------------------------------------------------------
     13  7668							; EOF
------- FILE ./chess.asm
------- FILE PIECE_HANDLER@1#2.asm LEVEL 2 PASS 4
      0  7668					      include	"PIECE_HANDLER@1#2.asm"
      0  7668					      SLOT	1
      1  7668				  -	      IF	(1 < 0) || (1 > 3)
      2  7668				  -	      ECHO	"Illegal bank address/segment location", 1
      3  7668				  -	      ERR
      4  7668					      ENDIF
      5  7668				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  7668				   _BANK_SLOT SET	1 * 64
      0  7668					      NEWBANK	PIECE_HANDLER_2
      1  7a5c ????				      SEG	PIECE_HANDLER_2
      2  7800					      ORG	_ORIGIN
      3  7800					      RORG	_BANK_ADDRESS_ORIGIN
      4  7800				   _BANK_START SET	*
      5  7800				   PIECE_HANDLER_2_START SET	*
      6  7800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7800				   PIECE_HANDLER_2 SET	_BANK_SLOT + _CURRENT_BANK
      8  7800				   _ORIGIN    SET	_ORIGIN + 1024
      3  7800
------- FILE PIECE_ROOK.asm LEVEL 3 PASS 4
      0  7800					      include	"PIECE_ROOK.asm"
      1  7800							; Copyright (C)2020 Andrew Davie
      2  7800							; Rook move handler
      3  7800
      4  7800							;---------------------------------------------------------------------------------------------------
      5  7800							; ROOK
      6  7800							;---------------------------------------------------------------------------------------------------
      7  7800
      0  7800					      DEF	Handle_ROOK
      1  7800				   SLOT_Handle_ROOK SET	_BANK_SLOT
      2  7800				   BANK_Handle_ROOK SET	SLOT_Handle_ROOK + _CURRENT_BANK
      3  7800				   Handle_ROOK
      4  7800				   TEMPORARY_VAR SET	Overlay
      5  7800				   TEMPORARY_OFFSET SET	0
      6  7800				   VAR_BOUNDARY_Handle_ROOK SET	TEMPORARY_OFFSET
      7  7800				   FUNCTION_NAME SET	Handle_ROOK
      9  7800					      SUBROUTINE
     10  7800
      0  7800					      REFER	GenerateAllMoves
      1  7800					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  7800				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  7800					      ENDIF
      0  7800					      VEND	Handle_ROOK
      1  7800				  -	      IFNCONST	Handle_ROOK
      2  7800				  -	      ECHO	"Incorrect VEND label", Handle_ROOK
      3  7800				  -	      ERR
      4  7800					      ENDIF
      5  7800		       00 b2	   VAREND_Handle_ROOK =	TEMPORARY_VAR
     13  7800
     14  7800							; Pass...
     15  7800							; x = currentSquare (square the piece is on)
     16  7800							; currentPiece (with flags/colour attached)
     17  7800
      0  7800					      MOVE_TOWARDS	_DOWN
      1  7800					      SUBROUTINE
      2  7800
      3  7800
      4  7800
      5  7800		       a9 00		      lda	#0
      6  7802		       85 9d		      sta	capture
      7  7804
      8  7804		       a6 92		      ldx	currentSquare
      9  7806		       d0 03		      bne	.project
     10  7808
     11  7808		       20 00 f4    .empty     jsr	AddMoveSlider
     12  780b		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  780e		       30 0e		      bmi	.invalid
     14  7810		       b9 79 fc 	      lda	Board,y
     15  7813		       f0 f3		      beq	.empty
     16  7815		       85 9d		      sta	capture
     17  7817		       45 91		      eor	currentPiece
     18  7819		       10 03		      bpl	.invalid
     19  781b		       20 0e f2 	      jsr	AddMove
     20  781e
     21  781e				   .invalid
      0  781e					      MOVE_TOWARDS	_RIGHT
      1  781e					      SUBROUTINE
      2  781e
      3  781e
      4  781e
      5  781e		       a9 00		      lda	#0
      6  7820		       85 9d		      sta	capture
      7  7822
      8  7822		       a6 92		      ldx	currentSquare
      9  7824		       d0 03		      bne	.project
     10  7826
     11  7826		       20 00 f4    .empty     jsr	AddMoveSlider
     12  7829		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  782c		       30 0e		      bmi	.invalid
     14  782e		       b9 79 fc 	      lda	Board,y
     15  7831		       f0 f3		      beq	.empty
     16  7833		       85 9d		      sta	capture
     17  7835		       45 91		      eor	currentPiece
     18  7837		       10 03		      bpl	.invalid
     19  7839		       20 0e f2 	      jsr	AddMove
     20  783c
     21  783c				   .invalid
      0  783c					      MOVE_TOWARDS	_UP
      1  783c					      SUBROUTINE
      2  783c
      3  783c
      4  783c
      5  783c		       a9 00		      lda	#0
      6  783e		       85 9d		      sta	capture
      7  7840
      8  7840		       a6 92		      ldx	currentSquare
      9  7842		       d0 03		      bne	.project
     10  7844
     11  7844		       20 00 f4    .empty     jsr	AddMoveSlider
     12  7847		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  784a		       30 0e		      bmi	.invalid
     14  784c		       b9 79 fc 	      lda	Board,y
     15  784f		       f0 f3		      beq	.empty
     16  7851		       85 9d		      sta	capture
     17  7853		       45 91		      eor	currentPiece
     18  7855		       10 03		      bpl	.invalid
     19  7857		       20 0e f2 	      jsr	AddMove
     20  785a
     21  785a				   .invalid
      0  785a					      MOVE_TOWARDS	_LEFT
      1  785a					      SUBROUTINE
      2  785a
      3  785a
      4  785a
      5  785a		       a9 00		      lda	#0
      6  785c		       85 9d		      sta	capture
      7  785e
      8  785e		       a6 92		      ldx	currentSquare
      9  7860		       d0 03		      bne	.project
     10  7862
     11  7862		       20 00 f4    .empty     jsr	AddMoveSlider
     12  7865		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  7868		       30 0e		      bmi	.invalid
     14  786a		       b9 79 fc 	      lda	Board,y
     15  786d		       f0 f3		      beq	.empty
     16  786f		       85 9d		      sta	capture
     17  7871		       45 91		      eor	currentPiece
     18  7873		       10 03		      bpl	.invalid
     19  7875		       20 0e f2 	      jsr	AddMove
     20  7878
     21  7878				   .invalid
     22  7878
     23  7878		       4c 99 f1 	      jmp	MoveReturn
     24  787b
     25  787b							;---------------------------------------------------------------------------------------------------
     26  787b							; EOF
------- FILE PIECE_HANDLER@1#2.asm
------- FILE PIECE_QUEEN.asm LEVEL 3 PASS 4
      0  787b					      include	"PIECE_QUEEN.asm"
      1  787b							; Copyright (C)2020 Andrew Davie
      2  787b
      3  787b							;---------------------------------------------------------------------------------------------------
      4  787b							; QUEEN
      5  787b							;---------------------------------------------------------------------------------------------------
      6  787b
      0  787b					      DEF	Handle_QUEEN
      1  787b				   SLOT_Handle_QUEEN SET	_BANK_SLOT
      2  787b				   BANK_Handle_QUEEN SET	SLOT_Handle_QUEEN + _CURRENT_BANK
      3  787b				   Handle_QUEEN
      4  787b				   TEMPORARY_VAR SET	Overlay
      5  787b				   TEMPORARY_OFFSET SET	0
      6  787b				   VAR_BOUNDARY_Handle_QUEEN SET	TEMPORARY_OFFSET
      7  787b				   FUNCTION_NAME SET	Handle_QUEEN
      8  787b					      SUBROUTINE
      9  787b
      0  787b					      REFER	GenerateAllMoves
      1  787b					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  787b				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  787b					      ENDIF
      0  787b					      VEND	Handle_QUEEN
      1  787b				  -	      IFNCONST	Handle_QUEEN
      2  787b				  -	      ECHO	"Incorrect VEND label", Handle_QUEEN
      3  787b				  -	      ERR
      4  787b					      ENDIF
      5  787b		       00 b2	   VAREND_Handle_QUEEN =	TEMPORARY_VAR
     12  787b
     13  787b							; Pass...
     14  787b							; x = currentSquare (square the piece is on)
     15  787b							; currentPiece (with flags/colour attached)
     16  787b
      0  787b					      MOVE_TOWARDS	_DOWN+_LEFT
      1  787b					      SUBROUTINE
      2  787b
      3  787b
      4  787b
      5  787b		       a9 00		      lda	#0
      6  787d		       85 9d		      sta	capture
      7  787f
      8  787f		       a6 92		      ldx	currentSquare
      9  7881		       d0 03		      bne	.project
     10  7883
     11  7883		       20 00 f4    .empty     jsr	AddMoveSlider
     12  7886		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  7889		       30 0e		      bmi	.invalid
     14  788b		       b9 79 fc 	      lda	Board,y
     15  788e		       f0 f3		      beq	.empty
     16  7890		       85 9d		      sta	capture
     17  7892		       45 91		      eor	currentPiece
     18  7894		       10 03		      bpl	.invalid
     19  7896		       20 0e f2 	      jsr	AddMove
     20  7899
     21  7899				   .invalid
      0  7899					      MOVE_TOWARDS	_DOWN
      1  7899					      SUBROUTINE
      2  7899
      3  7899
      4  7899
      5  7899		       a9 00		      lda	#0
      6  789b		       85 9d		      sta	capture
      7  789d
      8  789d		       a6 92		      ldx	currentSquare
      9  789f		       d0 03		      bne	.project
     10  78a1
     11  78a1		       20 00 f4    .empty     jsr	AddMoveSlider
     12  78a4		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  78a7		       30 0e		      bmi	.invalid
     14  78a9		       b9 79 fc 	      lda	Board,y
     15  78ac		       f0 f3		      beq	.empty
     16  78ae		       85 9d		      sta	capture
     17  78b0		       45 91		      eor	currentPiece
     18  78b2		       10 03		      bpl	.invalid
     19  78b4		       20 0e f2 	      jsr	AddMove
     20  78b7
     21  78b7				   .invalid
      0  78b7					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  78b7					      SUBROUTINE
      2  78b7
      3  78b7
      4  78b7
      5  78b7		       a9 00		      lda	#0
      6  78b9		       85 9d		      sta	capture
      7  78bb
      8  78bb		       a6 92		      ldx	currentSquare
      9  78bd		       d0 03		      bne	.project
     10  78bf
     11  78bf		       20 00 f4    .empty     jsr	AddMoveSlider
     12  78c2		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  78c5		       30 0e		      bmi	.invalid
     14  78c7		       b9 79 fc 	      lda	Board,y
     15  78ca		       f0 f3		      beq	.empty
     16  78cc		       85 9d		      sta	capture
     17  78ce		       45 91		      eor	currentPiece
     18  78d0		       10 03		      bpl	.invalid
     19  78d2		       20 0e f2 	      jsr	AddMove
     20  78d5
     21  78d5				   .invalid
      0  78d5					      MOVE_TOWARDS	_RIGHT
      1  78d5					      SUBROUTINE
      2  78d5
      3  78d5
      4  78d5
      5  78d5		       a9 00		      lda	#0
      6  78d7		       85 9d		      sta	capture
      7  78d9
      8  78d9		       a6 92		      ldx	currentSquare
      9  78db		       d0 03		      bne	.project
     10  78dd
     11  78dd		       20 00 f4    .empty     jsr	AddMoveSlider
     12  78e0		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  78e3		       30 0e		      bmi	.invalid
     14  78e5		       b9 79 fc 	      lda	Board,y
     15  78e8		       f0 f3		      beq	.empty
     16  78ea		       85 9d		      sta	capture
     17  78ec		       45 91		      eor	currentPiece
     18  78ee		       10 03		      bpl	.invalid
     19  78f0		       20 0e f2 	      jsr	AddMove
     20  78f3
     21  78f3				   .invalid
      0  78f3					      MOVE_TOWARDS	_UP+_RIGHT
      1  78f3					      SUBROUTINE
      2  78f3
      3  78f3
      4  78f3
      5  78f3		       a9 00		      lda	#0
      6  78f5		       85 9d		      sta	capture
      7  78f7
      8  78f7		       a6 92		      ldx	currentSquare
      9  78f9		       d0 03		      bne	.project
     10  78fb
     11  78fb		       20 00 f4    .empty     jsr	AddMoveSlider
     12  78fe		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  7901		       30 0e		      bmi	.invalid
     14  7903		       b9 79 fc 	      lda	Board,y
     15  7906		       f0 f3		      beq	.empty
     16  7908		       85 9d		      sta	capture
     17  790a		       45 91		      eor	currentPiece
     18  790c		       10 03		      bpl	.invalid
     19  790e		       20 0e f2 	      jsr	AddMove
     20  7911
     21  7911				   .invalid
      0  7911					      MOVE_TOWARDS	_UP
      1  7911					      SUBROUTINE
      2  7911
      3  7911
      4  7911
      5  7911		       a9 00		      lda	#0
      6  7913		       85 9d		      sta	capture
      7  7915
      8  7915		       a6 92		      ldx	currentSquare
      9  7917		       d0 03		      bne	.project
     10  7919
     11  7919		       20 00 f4    .empty     jsr	AddMoveSlider
     12  791c		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  791f		       30 0e		      bmi	.invalid
     14  7921		       b9 79 fc 	      lda	Board,y
     15  7924		       f0 f3		      beq	.empty
     16  7926		       85 9d		      sta	capture
     17  7928		       45 91		      eor	currentPiece
     18  792a		       10 03		      bpl	.invalid
     19  792c		       20 0e f2 	      jsr	AddMove
     20  792f
     21  792f				   .invalid
      0  792f					      MOVE_TOWARDS	_UP+_LEFT
      1  792f					      SUBROUTINE
      2  792f
      3  792f
      4  792f
      5  792f		       a9 00		      lda	#0
      6  7931		       85 9d		      sta	capture
      7  7933
      8  7933		       a6 92		      ldx	currentSquare
      9  7935		       d0 03		      bne	.project
     10  7937
     11  7937		       20 00 f4    .empty     jsr	AddMoveSlider
     12  793a		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  793d		       30 0e		      bmi	.invalid
     14  793f		       b9 79 fc 	      lda	Board,y
     15  7942		       f0 f3		      beq	.empty
     16  7944		       85 9d		      sta	capture
     17  7946		       45 91		      eor	currentPiece
     18  7948		       10 03		      bpl	.invalid
     19  794a		       20 0e f2 	      jsr	AddMove
     20  794d
     21  794d				   .invalid
      0  794d					      MOVE_TOWARDS	_LEFT
      1  794d					      SUBROUTINE
      2  794d
      3  794d
      4  794d
      5  794d		       a9 00		      lda	#0
      6  794f		       85 9d		      sta	capture
      7  7951
      8  7951		       a6 92		      ldx	currentSquare
      9  7953		       d0 03		      bne	.project
     10  7955
     11  7955		       20 00 f4    .empty     jsr	AddMoveSlider
     12  7958		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  795b		       30 0e		      bmi	.invalid
     14  795d		       b9 79 fc 	      lda	Board,y
     15  7960		       f0 f3		      beq	.empty
     16  7962		       85 9d		      sta	capture
     17  7964		       45 91		      eor	currentPiece
     18  7966		       10 03		      bpl	.invalid
     19  7968		       20 0e f2 	      jsr	AddMove
     20  796b
     21  796b				   .invalid
     25  796b
     26  796b		       4c 99 f1 	      jmp	MoveReturn
     27  796e
     28  796e							; EOF
------- FILE PIECE_HANDLER@1#2.asm
------- FILE PIECE_KING.asm LEVEL 3 PASS 4
      0  796e					      include	"PIECE_KING.asm"
      1  796e							; Copyright (C)2020 Andrew Davie
      2  796e
      3  796e							;---------------------------------------------------------------------------------------------------
      4  796e							; KING
      5  796e							; This is the move handler for a KING
      6  796e							; "Check" is detected in the next ply of the search.
      7  796e
      8  796e
      9  796e							;---------------------------------------------------------------------------------------------------
     10  796e
     11  796e							; MACRO - Castling
     12  796e
     13  796e		       00 03	   KINGSIDE   =	3
     14  796e		       ff ff ff fc QUEENSIDE  =	-4
     15  796e
     16  796e					      MAC	castle
     17  796e							; {1} = "KINGSIDE" or "QUEENSIDE"
     18  796e
     19  796e					      ldx	currentSquare
     20  796e					      lda	Board+{1},x	; kingside/queenside R position
     21  796e					      and	#PIECE_MASK|FLAG_MOVED
     22  796e					      cmp	#ROOK
     23  796e					      bne	.noCastle	; not a R that hasn't moved
     24  796e
     25  796e							; It's a R and it *HAS* to be correct colour because it hasn't moved!
     26  796e							; AND the K hasn't moved (earlier check), so check for vacant squares between K and R
     27  796e
     28  796e					      IF	{1} = QUEENSIDE
     29  796e					      lda	Board-3,x	; N pos
     30  796e					      ora	Board-2,x	; B pos
     31  796e					      ora	Board-1,x	; Q pos
     32  796e					      bne	.noCastle	; not vacant?
     33  796e
     34  796e					      ENDIF
     35  796e
     36  796e					      IF	{1} = KINGSIDE
     37  796e					      lda	Board+2,x	; N pos
     38  796e					      ora	Board+1,x	; B pos
     39  796e					      bne	.noCastle	; not vacant?
     40  796e					      ENDIF
     41  796e
     42  796e							; appropriate N/B/(Q) squares are vacant so we proceed...
     43  796e
     44  796e							; FINALLY -- king can castle
     45  796e							; note: when we actually DO the move we MUST insert "Phantom" kings onto the board over the
     46  796e							; squares the king traverses so that "check" (and thus illegal moves) can be detected on the
     47  796e							; next move. Castling will be detected by K moving > 1 square. (TODO: FIX?? not CASTLE flag??)
     48  796e
     49  796e					      lda	currentPiece
     50  796e					      ora	#FLAG_CASTLE	; flag it's a castling move
     51  796e					      sta	currentPiece
     52  796e
     53  796e					      IF	{1} = KINGSIDE
     54  796e					      ldy	ValidSquare+2,x
     55  796e					      ENDIF
     56  796e
     57  796e					      IF	{1} = QUEENSIDE
     58  796e					      ldy	ValidSquare-2,x
     59  796e					      ENDIF
     60  796e
     61  796e					      jsr	AddMove	; 57
     62  796e
     63  796e				   .noCastle
     64  796e					      ENDM
     65  796e
     66  796e
     67  796e							;---------------------------------------------------------------------------------------------------
     68  796e
      0  796e					      DEF	Handle_KING
      1  796e				   SLOT_Handle_KING SET	_BANK_SLOT
      2  796e				   BANK_Handle_KING SET	SLOT_Handle_KING + _CURRENT_BANK
      3  796e				   Handle_KING
      4  796e				   TEMPORARY_VAR SET	Overlay
      5  796e				   TEMPORARY_OFFSET SET	0
      6  796e				   VAR_BOUNDARY_Handle_KING SET	TEMPORARY_OFFSET
      7  796e				   FUNCTION_NAME SET	Handle_KING
     70  796e					      SUBROUTINE
     71  796e
      0  796e					      REFER	GenerateAllMoves
      1  796e					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  796e				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  796e					      ENDIF
      0  796e					      VEND	Handle_KING
      1  796e				  -	      IFNCONST	Handle_KING
      2  796e				  -	      ECHO	"Incorrect VEND label", Handle_KING
      3  796e				  -	      ERR
      4  796e					      ENDIF
      5  796e		       00 b2	   VAREND_Handle_KING =	TEMPORARY_VAR
     74  796e
     75  796e							; x = currentSquare (square the KING is on)
     76  796e							; currentPiece (KING of course, but with flags/colour attached)
     77  796e
      0  796e					      MOVE_TO	_DOWN+_LEFT
      1  796e					      SUBROUTINE
      2  796e		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      3  7971		       30 0e		      bmi	.invalid
      4  7973		       b9 79 fc 	      lda	Board,y
      5  7976		       85 9d		      sta	capture
      6  7978		       f0 04		      beq	.squareEmpty
      7  797a		       45 91		      eor	currentPiece
      8  797c		       10 03		      bpl	.invalid
      9  797e		       20 0e f2    .squareEmpty jsr	AddMove
     10  7981				   .invalid
      0  7981					      MOVE_TO_X	_DOWN
      1  7981		       a6 92		      ldx	currentSquare
      0  7983					      MOVE_TO	_DOWN
      1  7983					      SUBROUTINE
      2  7983		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x
      3  7986		       30 0e		      bmi	.invalid
      4  7988		       b9 79 fc 	      lda	Board,y
      5  798b		       85 9d		      sta	capture
      6  798d		       f0 04		      beq	.squareEmpty
      7  798f		       45 91		      eor	currentPiece
      8  7991		       10 03		      bpl	.invalid
      9  7993		       20 0e f2    .squareEmpty jsr	AddMove
     10  7996				   .invalid
      0  7996					      MOVE_TO_X	_DOWN+_RIGHT
      1  7996		       a6 92		      ldx	currentSquare
      0  7998					      MOVE_TO	_DOWN+_RIGHT
      1  7998					      SUBROUTINE
      2  7998		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      3  799b		       30 0e		      bmi	.invalid
      4  799d		       b9 79 fc 	      lda	Board,y
      5  79a0		       85 9d		      sta	capture
      6  79a2		       f0 04		      beq	.squareEmpty
      7  79a4		       45 91		      eor	currentPiece
      8  79a6		       10 03		      bpl	.invalid
      9  79a8		       20 0e f2    .squareEmpty jsr	AddMove
     10  79ab				   .invalid
      0  79ab					      MOVE_TO_X	_RIGHT
      1  79ab		       a6 92		      ldx	currentSquare
      0  79ad					      MOVE_TO	_RIGHT
      1  79ad					      SUBROUTINE
      2  79ad		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      3  79b0		       30 0e		      bmi	.invalid
      4  79b2		       b9 79 fc 	      lda	Board,y
      5  79b5		       85 9d		      sta	capture
      6  79b7		       f0 04		      beq	.squareEmpty
      7  79b9		       45 91		      eor	currentPiece
      8  79bb		       10 03		      bpl	.invalid
      9  79bd		       20 0e f2    .squareEmpty jsr	AddMove
     10  79c0				   .invalid
      0  79c0					      MOVE_TO_X	_UP+_RIGHT
      1  79c0		       a6 92		      ldx	currentSquare
      0  79c2					      MOVE_TO	_UP+_RIGHT
      1  79c2					      SUBROUTINE
      2  79c2		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      3  79c5		       30 0e		      bmi	.invalid
      4  79c7		       b9 79 fc 	      lda	Board,y
      5  79ca		       85 9d		      sta	capture
      6  79cc		       f0 04		      beq	.squareEmpty
      7  79ce		       45 91		      eor	currentPiece
      8  79d0		       10 03		      bpl	.invalid
      9  79d2		       20 0e f2    .squareEmpty jsr	AddMove
     10  79d5				   .invalid
      0  79d5					      MOVE_TO_X	_UP
      1  79d5		       a6 92		      ldx	currentSquare
      0  79d7					      MOVE_TO	_UP
      1  79d7					      SUBROUTINE
      2  79d7		       bc 1f fc 	      ldy	ValidSquare+_UP,x
      3  79da		       30 0e		      bmi	.invalid
      4  79dc		       b9 79 fc 	      lda	Board,y
      5  79df		       85 9d		      sta	capture
      6  79e1		       f0 04		      beq	.squareEmpty
      7  79e3		       45 91		      eor	currentPiece
      8  79e5		       10 03		      bpl	.invalid
      9  79e7		       20 0e f2    .squareEmpty jsr	AddMove
     10  79ea				   .invalid
      0  79ea					      MOVE_TO_X	_UP+_LEFT
      1  79ea		       a6 92		      ldx	currentSquare
      0  79ec					      MOVE_TO	_UP+_LEFT
      1  79ec					      SUBROUTINE
      2  79ec		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      3  79ef		       30 0e		      bmi	.invalid
      4  79f1		       b9 79 fc 	      lda	Board,y
      5  79f4		       85 9d		      sta	capture
      6  79f6		       f0 04		      beq	.squareEmpty
      7  79f8		       45 91		      eor	currentPiece
      8  79fa		       10 03		      bpl	.invalid
      9  79fc		       20 0e f2    .squareEmpty jsr	AddMove
     10  79ff				   .invalid
      0  79ff					      MOVE_TO_X	_LEFT
      1  79ff		       a6 92		      ldx	currentSquare
      0  7a01					      MOVE_TO	_LEFT
      1  7a01					      SUBROUTINE
      2  7a01		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      3  7a04		       30 0e		      bmi	.invalid
      4  7a06		       b9 79 fc 	      lda	Board,y
      5  7a09		       85 9d		      sta	capture
      6  7a0b		       f0 04		      beq	.squareEmpty
      7  7a0d		       45 91		      eor	currentPiece
      8  7a0f		       10 03		      bpl	.invalid
      9  7a11		       20 0e f2    .squareEmpty jsr	AddMove
     10  7a14				   .invalid
     86  7a14
     87  7a14							;IF CASTLING_ENABLED
     88  7a14
     89  7a14		       24 91		      bit	currentPiece
     90  7a16		       70 41		      bvs	.exit	; king has moved, so no castling
     91  7a18
      0  7a18					      CASTLE	KINGSIDE
      1  7a18
      2  7a18
      3  7a18		       a6 92		      ldx	currentSquare
      4  7a1a		       bd 7c fc 	      lda	Board+KINGSIDE,x
      5  7a1d		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  7a1f		       c9 05		      cmp	#ROOK
      7  7a21		       d0 14		      bne	.noCastle
      8  7a23
      9  7a23
     10  7a23
     11  7a23
     12  7a23				  -	      IF	KINGSIDE = QUEENSIDE
     13  7a23				  -	      lda	Board-3,x
     14  7a23				  -	      ora	Board-2,x
     15  7a23				  -	      ora	Board-1,x
     16  7a23				  -	      bne	.noCastle
     17  7a23				  -
     18  7a23					      ENDIF
     19  7a23
     20  7a23					      IF	KINGSIDE = KINGSIDE
     21  7a23		       bd 7b fc 	      lda	Board+2,x
     22  7a26		       1d 7a fc 	      ora	Board+1,x
     23  7a29		       d0 0c		      bne	.noCastle
     24  7a2b					      ENDIF
     25  7a2b
     26  7a2b
     27  7a2b
     28  7a2b
     29  7a2b
     30  7a2b
     31  7a2b
     32  7a2b
     33  7a2b		       a5 91		      lda	currentPiece
     34  7a2d		       09 10		      ora	#FLAG_CASTLE
     35  7a2f		       85 91		      sta	currentPiece
     36  7a31
     37  7a31					      IF	KINGSIDE = KINGSIDE
     38  7a31		       bc 17 fc 	      ldy	ValidSquare+2,x
     39  7a34					      ENDIF
     40  7a34
     41  7a34				  -	      IF	KINGSIDE = QUEENSIDE
     42  7a34				  -	      ldy	ValidSquare-2,x
     43  7a34					      ENDIF
     44  7a34
     45  7a34		       20 0e f2 	      jsr	AddMove
     46  7a37
     47  7a37				   .noCastle
      0  7a37					      CASTLE	QUEENSIDE
      1  7a37
      2  7a37
      3  7a37		       a6 92		      ldx	currentSquare
      4  7a39		       bd 75 fc 	      lda	Board+QUEENSIDE,x
      5  7a3c		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  7a3e		       c9 05		      cmp	#ROOK
      7  7a40		       d0 17		      bne	.noCastle
      8  7a42
      9  7a42
     10  7a42
     11  7a42
     12  7a42					      IF	QUEENSIDE = QUEENSIDE
     13  7a42		       bd 76 fc 	      lda	Board-3,x
     14  7a45		       1d 77 fc 	      ora	Board-2,x
     15  7a48		       1d 78 fc 	      ora	Board-1,x
     16  7a4b		       d0 0c		      bne	.noCastle
     17  7a4d
     18  7a4d					      ENDIF
     19  7a4d
     20  7a4d				  -	      IF	QUEENSIDE = KINGSIDE
     21  7a4d				  -	      lda	Board+2,x
     22  7a4d				  -	      ora	Board+1,x
     23  7a4d				  -	      bne	.noCastle
     24  7a4d					      ENDIF
     25  7a4d
     26  7a4d
     27  7a4d
     28  7a4d
     29  7a4d
     30  7a4d
     31  7a4d
     32  7a4d
     33  7a4d		       a5 91		      lda	currentPiece
     34  7a4f		       09 10		      ora	#FLAG_CASTLE
     35  7a51		       85 91		      sta	currentPiece
     36  7a53
     37  7a53				  -	      IF	QUEENSIDE = KINGSIDE
     38  7a53				  -	      ldy	ValidSquare+2,x
     39  7a53					      ENDIF
     40  7a53
     41  7a53					      IF	QUEENSIDE = QUEENSIDE
     42  7a53		       bc 13 fc 	      ldy	ValidSquare-2,x
     43  7a56					      ENDIF
     44  7a56
     45  7a56		       20 0e f2 	      jsr	AddMove
     46  7a59
     47  7a59				   .noCastle
     94  7a59
     95  7a59							;ENDIF
     96  7a59
     97  7a59		       4c 99 f1    .exit      jmp	MoveReturn
     98  7a5c
     99  7a5c							;---------------------------------------------------------------------------------------------------
    100  7a5c							; EOF
------- FILE PIECE_HANDLER@1#2.asm
      7  7a5c
      8  7a5c							;---------------------------------------------------------------------------------------------------
      9  7a5c
      0  7a5c					      CHECK_BANK_SIZE	"PIECE_HANDLER_2"
      1  7a5c		       02 5c	   .TEMP      =	* - _BANK_START
 PIECE_HANDLER_2 (1K) SIZE =  $25c , FREE= $1a4
      2  7a5c					      ECHO	"PIECE_HANDLER_2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  7a5c				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  7a5c				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_HANDLER_2", " size=", * - ORIGIN
      5  7a5c				  -	      ERR
      6  7a5c					      ENDIF
     11  7a5c
     12  7a5c							;---------------------------------------------------------------------------------------------------
     13  7a5c							; EOF
------- FILE ./chess.asm
------- FILE BANK_3.asm LEVEL 2 PASS 4
      0  7a5c					      include	"BANK_3.asm"
      1  7a5c							; Chess
      2  7a5c							; Copyright (c) 2019-2020 Andrew Davie
      3  7a5c							; andrew@taswegian.com
      4  7a5c
      0  7a5c					      SLOT	3	; this code assembles for bank #1
      1  7a5c				  -	      IF	(3 < 0) || (3 > 3)
      2  7a5c				  -	      ECHO	"Illegal bank address/segment location", 3
      3  7a5c				  -	      ERR
      4  7a5c					      ENDIF
      5  7a5c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  7a5c				   _BANK_SLOT SET	3 * 64
      0  7a5c					      NEWBANK	THREE
      1  7c65 ????				      SEG	THREE
      2  7c00					      ORG	_ORIGIN
      3  7c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  7c00				   _BANK_START SET	*
      5  7c00				   THREE_START SET	*
      6  7c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7c00				   THREE      SET	_BANK_SLOT + _CURRENT_BANK
      8  7c00				   _ORIGIN    SET	_ORIGIN + 1024
      7  7c00
      8  7c00							;---------------------------------------------------------------------------------------------------
      9  7c00
      0  7c00					      DEF	GetPiece
      1  7c00				   SLOT_GetPiece SET	_BANK_SLOT
      2  7c00				   BANK_GetPiece SET	SLOT_GetPiece + _CURRENT_BANK
      3  7c00				   GetPiece
      4  7c00				   TEMPORARY_VAR SET	Overlay
      5  7c00				   TEMPORARY_OFFSET SET	0
      6  7c00				   VAR_BOUNDARY_GetPiece SET	TEMPORARY_OFFSET
      7  7c00				   FUNCTION_NAME SET	GetPiece
     11  7c00					      SUBROUTINE
     12  7c00
      0  7c00					      REFER	aiSelectDestinationSquare
      1  7c00				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  7c00				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  7c00					      ENDIF
      0  7c00					      REFER	aiQuiescent
      1  7c00				  -	      IF	VAREND_aiQuiescent > TEMPORARY_VAR
      2  7c00				  -TEMPORARY_VAR SET	VAREND_aiQuiescent
      3  7c00					      ENDIF
      0  7c00					      VEND	GetPiece
      1  7c00				  -	      IFNCONST	GetPiece
      2  7c00				  -	      ECHO	"Incorrect VEND label", GetPiece
      3  7c00				  -	      ERR
      4  7c00					      ENDIF
      5  7c00		       00 a1	   VAREND_GetPiece =	TEMPORARY_VAR
     16  7c00
     17  7c00							; Retrieve the piece+flags from the movelist, given from/to squares
     18  7c00							; Required as moves have different flags but same origin squares (e.g., castling)
     19  7c00
     20  7c00		       a5 94		      lda	currentPly
     21  7c02		       85 3e		      sta	SET_BANK_RAM	;@2
     22  7c04
     23  7c04							; returns piece in A+fromPiece
     24  7c04							; or Y=-1 if not found
     25  7c04
     26  7c04							; We need to get the piece from the movelist because it contains flags (e.g., castling) about
     27  7c04							; the move. We need to do from/to checks because moves can have multiple origin/desinations.
     28  7c04							; This fixes the move with/without castle flag
     29  7c04
     30  7c04
      0  7c04					      ldy@PLY	moveIndex
      1  7c04		       ac d0 f9 	      ldy	moveIndex
     32  7c07		       30 11		      bmi	.fail	; shouldn't happen
     33  7c09
     34  7c09		       a5 85	   .scan      lda	fromX12
      0  7c0b					      cmp@PLY	MoveFrom,y
      1  7c0b		       d9 00 f8 	      cmp	MoveFrom,y
     36  7c0e		       d0 07		      bne	.next
     37  7c10		       a5 86		      lda	toX12
      0  7c12					      cmp@PLY	MoveTo,y
      1  7c12		       d9 64 f8 	      cmp	MoveTo,y
     39  7c15		       f0 04		      beq	.found
     40  7c17		       88	   .next      dey
     41  7c18		       10 ef		      bpl	.scan
     42  7c1a		       60	   .fail      rts
     43  7c1b
      0  7c1b				   .found     lda@PLY	MovePiece,y
      1  7c1b		       b9 00 f9 	      lda	MovePiece,y
     45  7c1e		       85 96		      sta	fromPiece
     46  7c20
     47  7c20		       60		      rts
     48  7c21
     49  7c21
     50  7c21							;---------------------------------------------------------------------------------------------------
     51  7c21
     52  7c21
      0  7c21					      DEF	selectmove
      1  7c21				   SLOT_selectmove SET	_BANK_SLOT
      2  7c21				   BANK_selectmove SET	SLOT_selectmove + _CURRENT_BANK
      3  7c21				   selectmove
      4  7c21				   TEMPORARY_VAR SET	Overlay
      5  7c21				   TEMPORARY_OFFSET SET	0
      6  7c21				   VAR_BOUNDARY_selectmove SET	TEMPORARY_OFFSET
      7  7c21				   FUNCTION_NAME SET	selectmove
     54  7c21					      SUBROUTINE
     55  7c21
      0  7c21					      COMMON_VARS_ALPHABETA
      1  7c21
      0  7c21					      VAR	__thinkbar, 1
      1  7c21		       00 a1	   __thinkbar =	TEMPORARY_VAR
      2  7c21				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7c21
      4  7c21				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7c21				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7c21				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7c21					      ENDIF
      8  7c21				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7c21				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  7c21				  -	      ERR
     11  7c21					      ENDIF
     12  7c21					      LIST	ON
      0  7c21					      VAR	__toggle, 1
      1  7c21		       00 a2	   __toggle   =	TEMPORARY_VAR
      2  7c21				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7c21
      4  7c21				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7c21				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7c21				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7c21					      ENDIF
      8  7c21				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7c21				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  7c21				  -	      ERR
     11  7c21					      ENDIF
     12  7c21					      LIST	ON
      4  7c21
      0  7c21					      VAR	__bestMove, 1
      1  7c21		       00 a3	   __bestMove =	TEMPORARY_VAR
      2  7c21				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7c21
      4  7c21				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7c21				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7c21				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7c21					      ENDIF
      8  7c21				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7c21				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  7c21				  -	      ERR
     11  7c21					      ENDIF
     12  7c21					      LIST	ON
      0  7c21					      VAR	__alpha, 2
      1  7c21		       00 a4	   __alpha    =	TEMPORARY_VAR
      2  7c21				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7c21
      4  7c21				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7c21				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7c21				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7c21					      ENDIF
      8  7c21				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7c21				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  7c21				  -	      ERR
     11  7c21					      ENDIF
     12  7c21					      LIST	ON
      0  7c21					      VAR	__beta, 2
      1  7c21		       00 a6	   __beta     =	TEMPORARY_VAR
      2  7c21				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7c21
      4  7c21				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7c21				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7c21				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7c21					      ENDIF
      8  7c21				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7c21				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  7c21				  -	      ERR
     11  7c21					      ENDIF
     12  7c21					      LIST	ON
      0  7c21					      VAR	__negaMax, 2
      1  7c21		       00 a8	   __negaMax  =	TEMPORARY_VAR
      2  7c21				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7c21
      4  7c21				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7c21				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7c21				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7c21					      ENDIF
      8  7c21				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7c21				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  7c21				  -	      ERR
     11  7c21					      ENDIF
     12  7c21					      LIST	ON
      0  7c21					      VAR	__value, 2
      1  7c21		       00 aa	   __value    =	TEMPORARY_VAR
      2  7c21				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7c21
      4  7c21				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7c21				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7c21				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7c21					      ENDIF
      8  7c21				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7c21				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  7c21				  -	      ERR
     11  7c21					      ENDIF
     12  7c21					      LIST	ON
     10  7c21
      0  7c21					      VAR	__quiesceCapOnly, 1
      1  7c21		       00 ac	   __quiesceCapOnly =	TEMPORARY_VAR
      2  7c21				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7c21
      4  7c21				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7c21				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7c21				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7c21					      ENDIF
      8  7c21				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7c21				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  7c21				  -	      ERR
     11  7c21					      ENDIF
     12  7c21					      LIST	ON
     12  7c21
      0  7c21					      REFER	aiComputerMove
      1  7c21				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  7c21				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  7c21					      ENDIF
      0  7c21					      VEND	selectmove
      1  7c21				  -	      IFNCONST	selectmove
      2  7c21				  -	      ECHO	"Incorrect VEND label", selectmove
      3  7c21				  -	      ERR
      4  7c21					      ENDIF
      5  7c21		       00 ad	   VAREND_selectmove =	TEMPORARY_VAR
     59  7c21
     60  7c21
     61  7c21
     62  7c21							; RAM bank already switched in!!!
     63  7c21							; returns with RAM bank switched
     64  7c21
     65  7c21
     66  7c21				  -	      IF	DIAGNOSTICS
     67  7c21				  -
     68  7c21				  -	      lda	#0
     69  7c21				  -	      sta	positionCount
     70  7c21				  -	      sta	positionCount+1
     71  7c21				  -	      sta	positionCount+2
     72  7c21				  -			;sta maxPly
     73  7c21					      ENDIF
     74  7c21
     75  7c21
     76  7c21		       a9 00		      lda	#<INFINITY
     77  7c23		       85 a6		      sta	__beta
     78  7c25		       a9 70		      lda	#>INFINITY
     79  7c27		       85 a7		      sta	__beta+1
     80  7c29
     81  7c29		       a9 00		      lda	#<-INFINITY
     82  7c2b		       85 a4		      sta	__alpha
     83  7c2d		       a9 90		      lda	#>-INFINITY
     84  7c2f		       85 a5		      sta	__alpha+1	; player tries to maximise
     85  7c31
     86  7c31		       a2 03		      ldx	#SEARCH_DEPTH
     87  7c33		       a9 00		      lda	#0	; no captured piece
     88  7c35		       85 ac		      sta	__quiesceCapOnly	; ALL moves to be generated
     89  7c37
     90  7c37							;tmp jsr negaMax
     91  7c37
      0  7c37					      ldx@PLY	bestMove
      1  7c37		       ae d2 f9 	      ldx	bestMove
     93  7c3a		       30 28		      bmi	.nomove
     94  7c3c
     95  7c3c							; Generate player's moves in reply
     96  7c3c							; Make the computer move, list player moves (PLY+1), unmake computer move
     97  7c3c
      0  7c3c					      stx@PLY	movePtr
      1  7c3c		       8e d1 fb 	      stx	[RAM]+movePtr
      0  7c3f					      CALL	MakeMove	;@1
      1  7c3f				  -	      IF	SLOT_MakeMove == _BANK_SLOT
      2  7c3f				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  7c3f				  -	      ECHO	"Cannot switch bank in use for", MakeMove
      4  7c3f				  -	      ERR
      5  7c3f					      ENDIF
      6  7c3f		       a9 41		      lda	#BANK_MakeMove
      7  7c41		       85 3f		      sta	SET_BANK
      8  7c43		       20 64 f6 	      jsr	MakeMove
    100  7c46		       20 d1 f1 	      jsr	ListPlayerMoves	;@0
    101  7c49		       20 32 f2 	      jsr	unmakeMove	;@0
    102  7c4c
    103  7c4c							; Grab the computer move details for the UI animation
    104  7c4c
    105  7c4c		       a9 88		      lda	#RAMBANK_PLY
    106  7c4e		       85 3e		      sta	SET_BANK_RAM
    107  7c50
      0  7c50					      ldx@PLY	bestMove
      1  7c50		       ae d2 f9 	      ldx	bestMove
      0  7c53					      lda@PLY	MoveTo,x
      1  7c53		       bd 64 f8 	      lda	MoveTo,x
    110  7c56		       85 86		      sta	toX12
      0  7c58					      lda@PLY	MoveFrom,x
      1  7c58		       bd 00 f8 	      lda	MoveFrom,x
    112  7c5b		       85 87		      sta	originX12
    113  7c5d		       85 85		      sta	fromX12
      0  7c5f					      lda@PLY	MovePiece,x
      1  7c5f		       bd 00 f9 	      lda	MovePiece,x
    115  7c62		       85 96		      sta	fromPiece
    116  7c64
    117  7c64				   .nomove
    118  7c64		       60		      rts
    119  7c65
    120  7c65
    121  7c65
    122  7c65							;---------------------------------------------------------------------------------------------------
    123  7c65
      0  7c65					      CHECK_BANK_SIZE	"BANK_3"
      1  7c65		       00 65	   .TEMP      =	* - _BANK_START
 BANK_3 (1K) SIZE =  $65 , FREE= $39b
      2  7c65					      ECHO	"BANK_3", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  7c65				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  7c65				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_3", " size=", * - ORIGIN
      5  7c65				  -	      ERR
      6  7c65					      ENDIF
    125  7c65
    126  7c65							;---------------------------------------------------------------------------------------------------
    127  7c65							; EOF
------- FILE ./chess.asm
    637  7c65
------- FILE BANK_LAST.asm LEVEL 2 PASS 4
      0  7c65					      include	"BANK_LAST.asm"
      1  7c65							; Chess
      2  7c65							; Copyright (c) 2019-2020 Andrew Davie
      3  7c65							; andrew@taswegian.com
      4  7c65
      0  7c65					      SLOT	3
      1  7c65				  -	      IF	(3 < 0) || (3 > 3)
      2  7c65				  -	      ECHO	"Illegal bank address/segment location", 3
      3  7c65				  -	      ERR
      4  7c65					      ENDIF
      5  7c65				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  7c65				   _BANK_SLOT SET	3 * 64
      0  7c65					      NEWBANK	LAST
      1  8400 ????				      SEG	LAST
      2  8000					      ORG	_ORIGIN
      3  8000					      RORG	_BANK_ADDRESS_ORIGIN
      4  8000				   _BANK_START SET	*
      5  8000				   LAST_START SET	*
      6  8000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  8000				   LAST       SET	_BANK_SLOT + _CURRENT_BANK
      8  8000				   _ORIGIN    SET	_ORIGIN + 1024
      7  8000
      8  8000
      9  8000		       00 00 00 00*	      ds	1024
     10  8400
     11  8400							; EOF
------- FILE ./chess.asm
    639  8400
    640  8400							;---------------------------------------------------------------------------------------------------
    641  8400							;EOF
