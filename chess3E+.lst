------- FILE ./chess.asm LEVEL 1 PASS 4
      1  7c00 ????						; Chess
      2  7c00 ????						; Atari 2600 Chess display system
      3  7c00 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  7c00 ????						; andrew@taswegian.com
      5  7c00 ????
      6  7c00 ????
      7  7c00 ????	       00 40	   TIA_BASE_ADDRESS =	$40
      8  7c00 ????
      9  7c00 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 4
      0  7c00 ????				      include	"vcs.h"
      1  7c00 ????						; VCS.H
      2  7c00 ????						; Version 1.05, 13/November/2003
      3  7c00 ????
      4  7c00 ????	       00 69	   VERSION_VCS =	105
      5  7c00 ????
      6  7c00 ????						; This file defines hardware registers and memory mapping for the
      7  7c00 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  7c00 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  7c00 ????						; available at at http://www.atari2600.org/dasm
     10  7c00 ????						;
     11  7c00 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  7c00 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  7c00 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  7c00 ????						; with your views.  Please contribute, if you think you can improve this
     15  7c00 ????						; file!
     16  7c00 ????						;
     17  7c00 ????						; Latest Revisions...
     18  7c00 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  7c00 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  7c00 ????						;			    This will allow conditional code to verify VCS.H being
     21  7c00 ????						;			    used for code assembly.
     22  7c00 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  7c00 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  7c00 ????						;			 mirrored reading/writing differences.	This is more a
     25  7c00 ????						;			 readability issue, and binary compatibility with disassembled
     26  7c00 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  7c00 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  7c00 ????						;			 which was broken by the use of segments in this file, as
     29  7c00 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  7c00 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  7c00 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  7c00 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  7c00 ????						;						   it is safe to leave it undefined, and the base address will
     34  7c00 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  7c00 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  7c00 ????						;			  - register definitions are now generated through assignment
     37  7c00 ????						;			    in uninitialised segments.	This allows a changeable base
     38  7c00 ????						;			    address architecture.
     39  7c00 ????						; 1.0	22/MAR/2003		Initial release
     40  7c00 ????
     41  7c00 ????
     42  7c00 ????						;-------------------------------------------------------------------------------
     43  7c00 ????
     44  7c00 ????						; TIA_BASE_ADDRESS
     45  7c00 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  7c00 ????						; Normally 0, the base address should (externally, before including this file)
     47  7c00 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  7c00 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  7c00 ????						; < $40 as a bankswitch.
     50  7c00 ????
     51  7c00 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  7c00 ????			  -TIA_BASE_ADDRESS =	0
     53  7c00 ????				      ENDIF
     54  7c00 ????
     55  7c00 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  7c00 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  7c00 ????						; *OR* by declaring the label before including this file, eg:
     58  7c00 ????						; TIA_BASE_ADDRESS = $40
     59  7c00 ????						;   include "vcs.h"
     60  7c00 ????
     61  7c00 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  7c00 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  7c00 ????						; for the mirrored ROM hardware registers.
     64  7c00 ????
     65  7c00 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  7c00 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  7c00 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  7c00 ????
     69  7c00 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  7c00 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  7c00 ????				      ENDIF
     72  7c00 ????
     73  7c00 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  7c00 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  7c00 ????				      ENDIF
     76  7c00 ????
     77  7c00 ????						;-------------------------------------------------------------------------------
     78  7c00 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE macro.h LEVEL 2 PASS 4
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE piece_defines.h LEVEL 2 PASS 4
      0  0000 ????				      include	"piece_defines.h"
      1  0000 ????						; Copyright (C)2020 Andrew Davie
      2  0000 ????
      3  0000 ????	       00 80	   BLACK      =	128
      4  0000 ????	       00 00	   WHITE      =	0
      5  0000 ????
      6  0000 ????	       00 80	   FLAG_COLOUR =	128	; mask
      7  0000 ????	       00 40	   FLAG_MOVED =	64	; mark ALL pieces when moved. Used for castling
      8  0000 ????						; but maybe useful for evaluation of development
      9  0000 ????	       00 20	   FLAG_ENPASSANT =	32
     10  0000 ????	       00 10	   FLAG_CASTLE =	16
     11  0000 ????
     12  0000 ????						;---------------------------------------------------------------------------------------------------
     13  0000 ????						; DEFINE THE PIECES
     14  0000 ????						; ID lives in bits 0-2
     15  0000 ????
     16  0000 ????	       00 00	   BLANK      =	0
     17  0000 ????	       00 00	   ███  =	BLANK
     18  0000 ????
     19  0000 ????	       00 01	   WPAWN      =	1
     20  0000 ????	       00 01	   WP	      =	WPAWN
     21  0000 ????	       00 02	   BPAWN      =	2
     22  0000 ????	       00 02	   BP	      =	BPAWN
     23  0000 ????	       00 03	   KNIGHT     =	3
     24  0000 ????	       00 03	   N	      =	KNIGHT
     25  0000 ????	       00 04	   BISHOP     =	4
     26  0000 ????	       00 04	   B	      =	BISHOP
     27  0000 ????	       00 05	   ROOK       =	5
     28  0000 ????	       00 05	   R	      =	ROOK
     29  0000 ????	       00 06	   QUEEN      =	6
     30  0000 ????	       00 06	   Q	      =	QUEEN
     31  0000 ????	       00 07	   KING       =	7
     32  0000 ????	       00 07	   K	      =	KING
     33  0000 ????
     34  0000 ????	       00 0f	   PIECE_MASK =	15	; trim off the flags leaving just piece ID
     35  0000 ????
     36  0000 ????						;---------------------------------------------------------------------------------------------------
     37  0000 ????
     38  0000 ????						; Movements
     39  0000 ????
     40  0000 ????	       00 0a	   _UP	      =	10	; up
     41  0000 ????	       ff ff ff ff _LEFT      =	-1	; left
     42  0000 ????	       ff ff ff f6 _DOWN      =	-10	; down
     43  0000 ????	       00 01	   _RIGHT     =	1	; right
     44  0000 ????
     45  0000 ????						; EOF
------- FILE ./chess.asm
     13  0000 ????
     14  0000 ????	       00 00	   VERBOSE    =	0	; set to 1 for compile messages
     15  0000 ????
     16  0000 ????			   ORIGIN     SET	0
     17  0000 ????			   ORIGIN_RAM SET	0
     18  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	segtime_c
     89  0000 ????			   {1}	      SET	({2}+32)/64 + 2
     90  0000 ????			   TEST_{1}   =	0
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????						; Pathways
     94  0000 ????						; StealPart3, not enough time for SCD_SLOW --> 79✅
     95  0000 ????						; if QuickDraw does immediate exit, 58✅
     96  0000 ????
     97  0000 ????						;---------------------------------------------------------------------------------------------------
     98  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_MINIMUM_TIMESLICE, 54	;✅ abort time maximum requirement for timeslice
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	(54+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    100  0000 ????
    101  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    102  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    103  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    104  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    105  0000 ????						; uses ...
    106  0000 ????
    107  0000 ????
    108  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    109  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    110  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    111  0000 ????
    112  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    113  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    114  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,22	;18 ;12	  ;NFI
      1  0000 ????			   SEGTIME_MAN SET	22
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
------- FILE ./chess.asm
     20  0000 ????
     21  0000 ????
     22  0000 ????	       00 00	   _FIRST_BANK =	0	; 3E+ 1st bank holds reset vectors
     23  0000 ????
     24  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     25  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     26  0000 ????						;FIXED_BANK		 = 15 * 2048	       ; ->> 32K
     27  0000 ????						;FIXED_BANK		 = 31 * 2048	       ; ->> 64K
     28  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     29  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     30  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     31  0000 ????
     32  0000 ????	       00 01	   YES	      =	1
     33  0000 ????	       00 00	   NO	      =	0
     34  0000 ????
     35  0000 ????	       70 00	   INFINITY   =	$7000	;32767
     36  0000 ????
     37  0000 ????
     38  0000 ????						; assemble diagnostics. Remove for release.
     39  0000 ????
     40  0000 ????	       00 00	   TEST_POSITION =	0	; 0=normal, 1 = setup test position
     41  0000 ????	       00 01	   DIAGNOSTICS =	1
     42  0000 ????	       00 01	   QUIESCENCE =	1
     43  0000 ????	       00 00	   ASSERTS    =	0
     44  0000 ????	       00 00	   PVSP       =	0	; player versus player =1
     45  0000 ????	       00 00	   ENPASSANT_ENABLED =	0
     46  0000 ????	       00 00	   CASTLING_ENABLED =	0
     47  0000 ????
     48  0000 ????						; NOTE: SEARCH_DEPTH cannot be < 3, because the player's moves are generated from PLY+1, and use
     49  0000 ????						; PLY+2 for computer response (thus, 3). The bank allocation gets stomped!
     50  0000 ????
     51  0000 ????
     52  0000 ????	       00 04	   SEARCH_DEPTH =	4
     53  0000 ????	       00 00	   QUIESCE_EXTRA_DEPTH =	0
     54  0000 ????
     55  0000 ????
     56  0000 ????	       00 04	   PLY_BANKS  =	SEARCH_DEPTH + QUIESCE_EXTRA_DEPTH
     57  0000 ????	       00 04	   MAX_PLY_DEPTH_BANK =	PLY_BANKS	;TODO -- RAMBANK_PLY + PLY_BANKS
     58  0000 ????
     59  0000 ????						;IF RAMBANK_PLY + MAX_PLY_DEPTH_BANK > 31
     60  0000 ????						;    ERR "Not enough RAM for PLY banks"
     61  0000 ????						;ENDIF
     62  0000 ????
     63  0000 ????
     64  0000 ????
     65  0000 ????
     66  0000 ????	       00 80	   SWAP_SIDE  =	128	;TODO + (RAMBANK_PLY ^ (RAMBANK_PLY+1))
     67  0000 ????
     68  0000 ????
     69  0000 ????
     70  0000 ????						; DELAYS
     71  0000 ????
     72  0000 ????	       00 0a	   READY_TO_MOVE_FLASH =	10
     73  0000 ????
     74  0000 ????						;===================================
     75  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     76  0000 ????						;===================================
     77  0000 ????
     78  0000 ????						;-------------------------------------------------------------------------------
     79  0000 ????						; The following are optional YES/NO depending on phase of the moon
     80  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     81  0000 ????						;-------------------------------------------------------------------------------
     82  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     83  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     84  0000 ????			  -	      IF	FINAL_VERSION = YES
     85  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     86  0000 ????				      ENDIF
     87  0000 ????
     88  0000 ????						;-------------------------------------------------------------------------------
     89  0000 ????
     90  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     91  0000 ????
     92  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
     93  0000 ????
     94  0000 ????						;------------------------------------------------------------------------------
     95  0000 ????
     96  0000 ????	       00 01	   PLUSCART   =	YES
     97  0000 ????
     98  0000 ????						;------------------------------------------------------------------------------
     99  0000 ????
    100  0000 ????
    101  0000 ????	       00 08	   CHESSBOARD_ROWS =	8	; number of ROWS of chessboard
    102  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    103  0000 ????	       00 48	   PIECE_SHAPE_SIZE =	72	; 3 PF bytes x 24 scanlines
    104  0000 ????
    105  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    106  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    107  0000 ????
    108  0000 ????
    109  0000 ????	       04 00	   RAM_SIZE   =	$400	; address space for write AND read
    110  0000 ????	       02 00	   RAM_WRITE  =	$200	; add this to RAM address when doing writes
    111  0000 ????	       02 00	   RAM	      =	RAM_WRITE
    112  0000 ????
    113  0000 ????	       04 00	   _ROM_BANK_SIZE =	$400
    114  0000 ????	       02 00	   _RAM_BANK_SIZE =	$200
    115  0000 ????
    116  0000 ????
    117  0000 ????						; Platform constants:
    118  0000 ????	       00 02	   PAL	      =	%10
    119  0000 ????	       00 02	   PAL_50     =	PAL|0
    120  0000 ????	       00 03	   PAL_60     =	PAL|1
    121  0000 ????
    122  0000 ????
    123  0000 ????				      IF	L276
    124  0000 ????	       00 30	   VBLANK_TIM_NTSC =	48	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    125  0000 ????			  -	      ELSE
    126  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    127  0000 ????				      ENDIF
    128  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    129  0000 ????
    130  0000 ????				      IF	L276
    131  0000 ????	       00 23	   OVERSCAN_TIM_NTSC =	35	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    132  0000 ????			  -	      ELSE
    133  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    134  0000 ????				      ENDIF
    135  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    136  0000 ????
    137  0000 ????				      IF	L276
    138  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    139  0000 ????			  -	      ELSE
    140  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    141  0000 ????				      ENDIF
    142  0000 ????	       01 38	   SCANLINES_PAL =	312
    143  0000 ????
    144  0000 ????
    145  0000 ????	       00 2e	   TIME_PART_2 =	46
    146  0000 ????	       00 2e	   TIME_PART_1 =	46
    147  0000 ????
    148  0000 ????
    149  0000 ????	       00 00	   SLOT0      =	0
    150  0000 ????	       00 40	   SLOT1      =	64
    151  0000 ????	       00 80	   SLOT2      =	128
    152  0000 ????	       00 c0	   SLOT3      =	192
    153  0000 ????
    154  0000 ????						;------------------------------------------------------------------------------
    155  0000 ????						; MACRO definitions
    156  0000 ????
    157  0000 ????
    158  0000 ????
    159  0000 ????				      MAC	newbank
    160  0000 ????				      SEG	{1}
    161  0000 ????				      ORG	_ORIGIN
    162  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    163  0000 ????			   _BANK_START SET	*
    164  0000 ????			   {1}_START  SET	*
    165  0000 ????			   _CURRENT_BANK SET	_ORIGIN/1024
    166  0000 ????			   {1}	      SET	_BANK_SLOT + _CURRENT_BANK
    167  0000 ????			   _ORIGIN    SET	_ORIGIN + 1024
    168  0000 ????				      ENDM		; bank name
    169  0000 ????
    170  0000 ????						;	      MAC DEFINE_1K_SEGMENT ; {seg name}
    171  0000 ????						;		  ALIGN $400
    172  0000 ????						;SEGMENT_{1}	  SET *
    173  0000 ????						;BANK_{1}	  SET _CURRENT_BANK
    174  0000 ????						;	      ENDM
    175  0000 ????
    176  0000 ????				      MAC	check_bank_size
    177  0000 ????			   .TEMP      =	* - _BANK_START
    178  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
    179  0000 ????				      IF	( .TEMP ) > _ROM_BANK_SIZE
    180  0000 ????				      ECHO	"BANK OVERFLOW @ ", {1}, " size=", * - ORIGIN
    181  0000 ????				      ERR
    182  0000 ????				      ENDIF
    183  0000 ????				      ENDM		; name
    184  0000 ????
    185  0000 ????				      MAC	check_ram_bank_size
    186  0000 ????			   .TEMP      =	* - _BANK_START
    187  0000 ????				      ECHO	{1}, "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
    188  0000 ????				      IF	( .TEMP ) > _RAM_BANK_SIZE
    189  0000 ????				      ECHO	"BANK OVERFLOW @ ", {1}, " size=", * - ORIGIN
    190  0000 ????				      ERR
    191  0000 ????				      ENDIF
    192  0000 ????				      ENDM		; name
    193  0000 ????
    194  0000 ????						;---------------------------------------------------------------------------------------------------
    195  0000 ????
    196  0000 ????						; Macro inserts a page break if the object would overlap a page
    197  0000 ????
    198  0000 ????				      MAC	optional_pagebreak
    199  0000 ????				      LIST	OFF
    200  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    201  0000 ????			   EARLY_LOCATION SET	*
    202  0000 ????				      ALIGN	256
    203  0000 ????				      IF	VERBOSE=1
    204  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR", {1}
    205  0000 ????				      ECHO	"REQUESTED SIZE =", {2}
    206  0000 ????				      ECHO	"WASTED SPACE =", *-EARLY_LOCATION
    207  0000 ????				      ECHO	"PAGEBREAK LOCATION =", *
    208  0000 ????				      ENDIF
    209  0000 ????				      ENDIF
    210  0000 ????				      LIST	ON
    211  0000 ????				      ENDM		; { string, size }
    212  0000 ????
    213  0000 ????
    214  0000 ????				      MAC	check_page_crossing
    215  0000 ????				      LIST	OFF
    216  0000 ????				      IF	( >BLOCK_END != >BLOCK_START )
    217  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    218  0000 ????				      ENDIF
    219  0000 ????				      LIST	ON
    220  0000 ????				      ENDM
    221  0000 ????
    222  0000 ????				      MAC	checkpage
    223  0000 ????				      LIST	OFF
    224  0000 ????				      IF	>. != >{1}
    225  0000 ????				      ECHO	""
    226  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    227  0000 ????				      ECHO	""
    228  0000 ????				      ERR
    229  0000 ????				      ENDIF
    230  0000 ????				      LIST	ON
    231  0000 ????				      ENDM
    232  0000 ????
    233  0000 ????				      MAC	checkpagex
    234  0000 ????				      LIST	OFF
    235  0000 ????				      IF	>. != >{1}
    236  0000 ????				      ECHO	""
    237  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    238  0000 ????				      ECHO	{2}
    239  0000 ????				      ECHO	""
    240  0000 ????				      ERR
    241  0000 ????				      ENDIF
    242  0000 ????				      LIST	ON
    243  0000 ????				      ENDM
    244  0000 ????
    245  0000 ????						;---------------------------------------------------------------------------------------------------
    246  0000 ????
    247  0000 ????						; Defines a variable of the given size, making sure it doesn't cross a page
    248  0000 ????				      MAC	variable
    249  0000 ????				      OPTIONAL_PAGEBREAK	"Variable", {2}
    250  0000 ????			   {1}	      ds	{2}
    251  0000 ????				      ENDM		; {name, size}
    252  0000 ????
    253  0000 ????
    254  0000 ????						;---------------------------------------------------------------------------------------------------
    255  0000 ????
    256  0000 ????				      MAC	def
    257  0000 ????			   SLOT_{1}   SET	_BANK_SLOT
    258  0000 ????			   BANK_{1}   SET	SLOT_{1} + _CURRENT_BANK	; bank in which this subroutine resides
    259  0000 ????			   {1}			; entry point
    260  0000 ????			   TEMPORARY_VAR SET	Overlay
    261  0000 ????			   TEMPORARY_OFFSET SET	0
    262  0000 ????			   VAR_BOUNDARY_{1} SET	TEMPORARY_OFFSET
    263  0000 ????			   FUNCTION_NAME SET	{1}
    264  0000 ????				      ENDM		; name of subroutine
    265  0000 ????
    266  0000 ????
    267  0000 ????						;---------------------------------------------------------------------------------------------------
    268  0000 ????
    269  0000 ????				      MAC	allocate
    270  0000 ????				      OPTIONAL_PAGEBREAK	"Table", {2}
    271  0000 ????				      DEF	{1}
    272  0000 ????				      ENDM
    273  0000 ????
    274  0000 ????						;---------------------------------------------------------------------------------------------------
    275  0000 ????
    276  0000 ????				      MAC	slot
    277  0000 ????				      IF	({1} < 0) || ({1} > 3)
    278  0000 ????				      ECHO	"Illegal bank address/segment location", {1}
    279  0000 ????				      ERR
    280  0000 ????				      ENDIF
    281  0000 ????			   _BANK_ADDRESS_ORIGIN SET	$F000 + ({1} * _ROM_BANK_SIZE)
    282  0000 ????			   _BANK_SLOT SET	{1} * 64	; D7/D6 selector
    283  0000 ????				      ENDM		; {1}
    284  0000 ????
    285  0000 ????
    286  0000 ????						;---------------------------------------------------------------------------------------------------
    287  0000 ????
    288  0000 ????				      MAC	negeval
    289  0000 ????
    290  0000 ????				      sec
    291  0000 ????				      lda	#0
    292  0000 ????				      sbc	Evaluation
    293  0000 ????				      sta	Evaluation
    294  0000 ????				      lda	#0
    295  0000 ????				      sbc	Evaluation+1
    296  0000 ????				      sta	Evaluation+1
    297  0000 ????				      ENDM
    298  0000 ????
    299  0000 ????
    300  0000 ????				      MAC	swap
    301  0000 ????				      lda	sideToMove
    302  0000 ????				      eor	#SWAP_SIDE
    303  0000 ????				      sta	sideToMove
    304  0000 ????
    305  0000 ????						;NEGEVAL
    306  0000 ????				      ENDM
    307  0000 ????
    308  0000 ????
    309  0000 ????						;---------------------------------------------------------------------------------------------------
    310  0000 ????
    311  0000 ????			   TEMPORARY_OFFSET SET	0
    312  0000 ????
    313  0000 ????
    314  0000 ????				      MAC	vend
    315  0000 ????				      IFNCONST	{1}
    316  0000 ????				      ECHO	"Incorrect VEND label", {1}
    317  0000 ????				      ERR
    318  0000 ????				      ENDIF
    319  0000 ????			   VAREND_{1} =	TEMPORARY_VAR
    320  0000 ????				      ENDM		; {1}
    321  0000 ????
    322  0000 ????
    323  0000 ????				      MAC	refer
    324  0000 ????				      IF	VAREND_{1} > TEMPORARY_VAR
    325  0000 ????			   TEMPORARY_VAR SET	VAREND_{1}
    326  0000 ????				      ENDIF
    327  0000 ????				      ENDM		; {1}
    328  0000 ????
    329  0000 ????
    330  0000 ????
    331  0000 ????						; Define a temporary variable for use in a subroutine
    332  0000 ????						; Will allocate appropriate bytes, and also check for overflow of the available overlay buffer
    333  0000 ????
    334  0000 ????				      MAC	var
    335  0000 ????			   {1}	      =	TEMPORARY_VAR
    336  0000 ????			   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + {2}
    337  0000 ????
    338  0000 ????			   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
    339  0000 ????				      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
    340  0000 ????			   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
    341  0000 ????				      ENDIF
    342  0000 ????				      IF	OVERLAY_DELTA > OVERLAY_SIZE
    343  0000 ????				      ECHO	"Temporary Variable", {1}, "overflow!"
    344  0000 ????				      ERR
    345  0000 ????				      ENDIF
    346  0000 ????				      LIST	ON
    347  0000 ????				      ENDM		; { name, size }
    348  0000 ????
    349  0000 ????
    350  0000 ????						;---------------------------------------------------------------------------------------------------
    351  0000 ????
    352  0000 ????				      MAC	tag
    353  0000 ????						; {0}
    354  0000 ????				      ENDM		; {ident/tag}
    355  0000 ????
    356  0000 ????						;---------------------------------------------------------------------------------------------------
    357  0000 ????
    358  0000 ????				      MAC	sta@ram
    359  0000 ????				      sta	[RAM]+{0}
    360  0000 ????				      ENDM		;{}
    361  0000 ????
    362  0000 ????				      MAC	stx@ram
    363  0000 ????				      stx	[RAM]+{0}
    364  0000 ????				      ENDM
    365  0000 ????
    366  0000 ????				      MAC	sty@ram
    367  0000 ????				      sty	[RAM]+{0}
    368  0000 ????				      ENDM
    369  0000 ????
    370  0000 ????				      MAC	sta@ply
    371  0000 ????				      sta	[RAM]+{0}
    372  0000 ????				      ENDM		;{}
    373  0000 ????
    374  0000 ????				      MAC	stx@ply
    375  0000 ????				      stx	[RAM]+{0}
    376  0000 ????				      ENDM
    377  0000 ????
    378  0000 ????				      MAC	sty@ply
    379  0000 ????				      sty	[RAM]+{0}
    380  0000 ????				      ENDM
    381  0000 ????
    382  0000 ????
    383  0000 ????				      MAC	lda@ram
    384  0000 ????				      lda	{0}
    385  0000 ????				      ENDM		;{}
    386  0000 ????
    387  0000 ????				      MAC	ldx@ram
    388  0000 ????				      ldx	{0}
    389  0000 ????				      ENDM		;{}
    390  0000 ????
    391  0000 ????				      MAC	ldy@ram
    392  0000 ????				      ldy	{0}
    393  0000 ????				      ENDM		;{}
    394  0000 ????
    395  0000 ????
    396  0000 ????				      MAC	lda@ply
    397  0000 ????				      lda	{0}
    398  0000 ????				      ENDM		;{}
    399  0000 ????
    400  0000 ????				      MAC	ldx@ply
    401  0000 ????				      ldx	{0}
    402  0000 ????				      ENDM		;{}
    403  0000 ????
    404  0000 ????				      MAC	ldy@ply
    405  0000 ????				      ldy	{0}
    406  0000 ????				      ENDM		;{}
    407  0000 ????
    408  0000 ????
    409  0000 ????				      MAC	adc@ply
    410  0000 ????				      adc	{0}
    411  0000 ????				      ENDM		;{}
    412  0000 ????
    413  0000 ????				      MAC	sbc@ply
    414  0000 ????				      sbc	{0}
    415  0000 ????				      ENDM		;{}
    416  0000 ????
    417  0000 ????				      MAC	cmp@ply
    418  0000 ????				      cmp	{0}
    419  0000 ????				      ENDM		;{}
    420  0000 ????
    421  0000 ????						;---------------------------------------------------------------------------------------------------
    422  0000 ????
    423  0000 ????				      MAC	newrambank
    424  0000 ????						; {1}	     bank name
    425  0000 ????						; {2}	     RAM bank number
    426  0000 ????
    427  0000 ????				      SEG.U	{1}
    428  0000 ????				      ORG	ORIGIN_RAM
    429  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    430  0000 ????			   _BANK_START SET	*
    431  0000 ????			   RAMBANK_{1} SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
    432  0000 ????			   _CURRENT_RAMBANK SET	RAMBANK_{1}
    433  0000 ????			   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    434  0000 ????				      ENDM		; bank name
    435  0000 ????
    436  0000 ????						;---------------------------------------------------------------------------------------------------
    437  0000 ????
    438  0000 ????				      MAC	resync
    439  0000 ????						; resync screen, X and Y == 0 afterwards
    440  0000 ????				      lda	#%10	; make sure VBLANK is ON
    441  0000 ????				      sta	VBLANK
    442  0000 ????
    443  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    444  0000 ????			   .loopResync
    445  0000 ????				      VERTICAL_SYNC
    446  0000 ????
    447  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    448  0000 ????				      lda	Platform
    449  0000 ????				      eor	#PAL_50	; PAL-50?
    450  0000 ????				      bne	.ntsc
    451  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    452  0000 ????			   .ntsc
    453  0000 ????			   .loopWait
    454  0000 ????				      sta	WSYNC
    455  0000 ????				      sta	WSYNC
    456  0000 ????				      dey
    457  0000 ????				      bne	.loopWait
    458  0000 ????				      dex
    459  0000 ????				      bne	.loopResync
    460  0000 ????				      ENDM
    461  0000 ????
    462  0000 ????				      MAC	set_platform
    463  0000 ????						; 00 = NTSC
    464  0000 ????						; 01 = NTSC
    465  0000 ????						; 10 = PAL-50
    466  0000 ????						; 11 = PAL-60
    467  0000 ????				      lda	SWCHB
    468  0000 ????				      rol
    469  0000 ????				      rol
    470  0000 ????				      rol
    471  0000 ????				      and	#%11
    472  0000 ????				      eor	#PAL
    473  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    474  0000 ????				      ENDM
    475  0000 ????
    476  0000 ????
    477  0000 ????						;---------------------------------------------------------------------------------------------------
    478  0000 ????
    479  0000 ????						;    MAC JSROM_SAFE ; {routine}
    480  0000 ????						;    ; Saves bank of routine to variable for later restore.
    481  0000 ????						;    ; Switches to the bank and does a JSR to the routine.
    482  0000 ????
    483  0000 ????						;		  lda #BANK_{1}
    484  0000 ????						;		  sta savedBank
    485  0000 ????						;		  sta SET_BANK
    486  0000 ????						;		  jsr {1}
    487  0000 ????						;    ENDM
    488  0000 ????
    489  0000 ????
    490  0000 ????						;    MAC JSROM ; {routine}
    491  0000 ????
    492  0000 ????						;		  lda #BANK_{1}
    493  0000 ????						;		  sta SET_BANK
    494  0000 ????						;		  jsr {1}
    495  0000 ????						;    ENDM
    496  0000 ????
    497  0000 ????
    498  0000 ????						;    MAC JSRAM
    499  0000 ????						;		  lda #BANK_{1}
    500  0000 ????						;		  sta SET_BANK_RAM
    501  0000 ????						;		  jsr {1}
    502  0000 ????						;    ENDM
    503  0000 ????
    504  0000 ????
    505  0000 ????
    506  0000 ????				      MAC	timecheck
    507  0000 ????				      lda	INTIM
    508  0000 ????				      cmp	#SPEEDOF_{1}
    509  0000 ????				      bcc	{2}
    510  0000 ????				      ENDM		; {ident}, {branch if out of time}
    511  0000 ????
    512  0000 ????
    513  0000 ????				      MAC	timing
    514  0000 ????			   SPEEDOF_{1} =	({2}/64) + 1
    515  0000 ????				      ENDM		; {label}, {cycles}
    516  0000 ????
    517  0000 ????
    518  0000 ????						;---------------------------------------------------------------------------------------------------
    519  0000 ????
    520  0000 ????						; Failsafe call of function in another bank
    521  0000 ????						; This will check the slot #s for current, call to make sure they're not the same!
    522  0000 ????
    523  0000 ????				      MAC	call
    524  0000 ????				      IF	SLOT_{1} == _BANK_SLOT
    525  0000 ????				      ECHO	"ERROR: Incompatible call to function requiring same slot..."
    526  0000 ????				      ECHO	"Cannot switch bank in use for", {0}
    527  0000 ????				      ERR
    528  0000 ????				      ENDIF
    529  0000 ????				      lda	#BANK_{1}
    530  0000 ????				      sta	SET_BANK
    531  0000 ????				      jsr	{1}
    532  0000 ????				      ENDM		; function name
    533  0000 ????
    534  0000 ????
    535  0000 ????
    536  0000 ????						;---------------------------------------------------------------------------------------------------
    537  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						; Chess
      2  0000 ????						; Atari 2600 Chess display system
      3  0000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  0000 ????						; andrew@taswegian.com
      5  0000 ????
      6 U00fc ????				      SEG.U	variables
      7 U0080					      ORG	$80
      8 U0080
      9 U0080		       00	   squareToDraw ds	1
     10 U0081		       00	   rnd	      ds	1	; random
     11 U0082		       00	   drawDelay  ds	1
     12 U0083		       00	   lastSquareX12 ds	1
     13 U0084
     14 U0084		       00	   drawCount  ds	1
     15 U0085		       00	   fromX12    ds	1
     16 U0086		       00	   toX12      ds	1
     17 U0087		       00	   originX12  ds	1
     18 U0088
     19 U0088		       00	   cursorX12  ds	1
     20 U0089
     21 U0089		       00	   mdelay     ds	1
     22 U008a		       00	   ccur       ds	1
     23 U008b		       00	   aiState    ds	1	; state
     24 U008c		       00	   aiFlashDelay ds	1
     25 U008d
     26 U008d		       00	   aiMoveIndex ds	1
     27 U008e
     28 U008e		       00	   aiFlashPhase ds	1
     29 U008f
     30 U008f		       00 00	   Evaluation ds	2	; tracks value of the board position
     31 U0091
     32 U0091		       00	   currentPiece ds	1
     33 U0092		       00	   currentSquare ds	1
     34 U0093		       00	   enPassantPawn ds	1	; TODO - this belongs in PLY bank
     35 U0094		       00	   currentPly ds	1
     36 U0095
     37 U0095		       00	   sideToMove ds	1	; d7 == side, 0=white, 128 = black
     38 U0096		       00	   fromPiece  ds	1
     39 U0097		       00	   lastPiece  ds	1
     40 U0098		       00	   previousPiece ds	1
     41 U0099
     42 U0099		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     43 U009a		       00 00	   speech_addr ds	2
     44 U009c		       00	   bg	      ds	1
     45 U009d
     46 U009d		       00	   capture    ds	1
     47 U009e
     48 U009e					      IF	DIAGNOSTICS
     49 U009e		       00 00 00    positionCount ds	3
     50 U00a1					      ENDIF
     51 U00a1
     52 U00a1							;maxPly			  ds 1
     53 U00a1		       00	   flagCheck  ds	1	; -1 = no, #KING = yes
     54 U00a2		       00	   protecting ds	1
     55 U00a3		       00	   randomness ds	1
------- FILE ./chess.asm
------- FILE overlays.asm LEVEL 2 PASS 4
      0 U00a4					      include	"overlays.asm"
      1 U00a4							; Chess
      2 U00a4							; Atari 2600 Chess display system
      3 U00a4							; Copyright (c) 2019-2020 Andrew Davie
      4 U00a4							; andrew@taswegian.com
      5 U00a4
      6 U00a4							;---------------------------------------------------------------------------------------------------
      7 U00a4							; OVERLAYS!
      8 U00a4							; These variables are overlays, and should be managed with care
      9 U00a4							; They co-exist (each "OVERLAY" starts at the zero-page variable "Overlay"
     10 U00a4							; and thus, overlays cannot be used at the same time (that is, you cannot
     11 U00a4							; use a variable in overlay #1 while at the same time using a variable in
     12 U00a4							; overlay #2
     13 U00a4
     14 U00a4							; for clarity, prefix ALL overlay variables with double-underscore (__)
     15 U00a4
     16 U00a4							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
     17 U00a4							; ensure this by using the VALIDATE_OVERLAY macro
     18 U00a4							;---------------------------------------------------------------------------------------------------
     19 U00a4
     20 U00a4					      MAC	overlay
     21 U00a4				   OVERLAY_NAME SET	{1}
     22 U00a4					      SEG.U	OVERLAY_{1}
     23 U00a4					      org	Overlay
     24 U00a4					      ENDM		; {name}
     25 U00a4
     26 U00a4							;---------------------------------------------------------------------------------------------------
     27 U00a4
     28 U00a4					      MAC	validate_overlay
     29 U00a4					      LIST	OFF
     30 U00a4				   OVERLAY_DELTA SET	* - Overlay
     31 U00a4					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
     32 U00a4				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
     33 U00a4					      ENDIF
     34 U00a4					      IF	OVERLAY_DELTA > OVERLAY_SIZE
     35 U00a4					      ECHO	"Overlay", OVERLAY_NAME, "is too big!"
     36 U00a4					      ECHO	"REQUIRED SIZE =", OVERLAY_DELTA
     37 U00a4					      ERR
     38 U00a4					      ENDIF
     39 U00a4					      LIST	ON
     40 U00a4					      ECHO	OVERLAY_NAME, "-", OVERLAY_SIZE - ( * - Overlay ), "bytes available"
     41 U00a4					      ENDM
     42 U00a4
     43 U00a4							;---------------------------------------------------------------------------------------------------
     44 U00a4
     45 U00a4				   OVERLAY_SIZE SET	$4C	; maximum size
     46 U00a4				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	0
     47 U00a4
     48 U00a4
     49 U00a4							; This overlay variable is used for the overlay variables.  That's OK.
     50 U00a4							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
     51 U00a4							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
     52 U00a4							; (especially the latter ones) are only used in rare occasions.
     53 U00a4
     54 U00a4							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
     55 U00a4							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
     56 U00a4
      0 U00a4					      DEF	Overlay
      1 U00a4				   SLOT_Overlay SET	_BANK_SLOT
      2 U00a4				   BANK_Overlay SET	SLOT_Overlay + _CURRENT_BANK
      3 U00a4				   Overlay
      4 U00a4				   TEMPORARY_VAR SET	Overlay
      5 U00a4				   TEMPORARY_OFFSET SET	0
      6 U00a4				   VAR_BOUNDARY_Overlay SET	TEMPORARY_OFFSET
      7 U00a4				   FUNCTION_NAME SET	Overlay
     58 U00a4		       00 00 00 00*	      ds	OVERLAY_SIZE	;--> overlay (share) variables
     59 U00f0				   END_OF_OVERLAY
     60 U00f0
     61 U00f0							;---------------------------------------------------------------------------------------------------
     62 U00f0							; And now... the overlays....
     63 U00f0
 ---- OVERLAYS ( $4c bytes ) ----
     64 U00f0					      ECHO	"---- OVERLAYS (", OVERLAY_SIZE, "bytes ) ----"
     65 U00f0
     66 U00f0							;---------------------------------------------------------------------------------------------------
     67 U00f0
     68 U00f0							; Some overlays are used across multiple routines/calls, and they will need to be defined
     69 U00f0							; "globally" in this file.
     70 U00f0
      0 U00f0					      VAR	__pieceShapeBuffer, PIECE_SHAPE_SIZE
      1 U00f0		       00 a4	   __pieceShapeBuffer =	TEMPORARY_VAR
      2 U00f0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + PIECE_SHAPE_SIZE
      3 U00f0
      4 U00f0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00f0					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00f0				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00f0					      ENDIF
      8 U00f0				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00f0				  -	      ECHO	"Temporary Variable", __pieceShapeBuffer, "overflow!"
     10 U00f0				  -	      ERR
     11 U00f0					      ENDIF
     12 U00f0					      LIST	ON
      0 U00f0					      VAR	__ptr, 2
      1 U00f0		       00 ec	   __ptr      =	TEMPORARY_VAR
      2 U00f0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3 U00f0
      4 U00f0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00f0					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00f0				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00f0					      ENDIF
      8 U00f0				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00f0				  -	      ECHO	"Temporary Variable", __ptr, "overflow!"
     10 U00f0				  -	      ERR
     11 U00f0					      ENDIF
     12 U00f0					      LIST	ON
      0 U00f0					      VAR	__ptr2, 2
      1 U00f0		       00 ee	   __ptr2     =	TEMPORARY_VAR
      2 U00f0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3 U00f0
      4 U00f0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00f0					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00f0				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00f0					      ENDIF
      8 U00f0				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00f0				  -	      ECHO	"Temporary Variable", __ptr2, "overflow!"
     10 U00f0				  -	      ERR
     11 U00f0					      ENDIF
     12 U00f0					      LIST	ON
     74 U00f0
     75 U00f0							;---------------------------------------------------------------------------------------------------
     76 U00f0
     77 U00f0
     78 U00f0					      ORG	END_OF_OVERLAY
 ---- END OF OVERLAYS ----
     79 U00f0					      ECHO	"---- END OF OVERLAYS ----"
 MAXIMUM OVERLAY SIZE NEEDED =  $4c
     80 U00f0					      ECHO	"MAXIMUM OVERLAY SIZE NEEDED = ", MAXIMUM_REQUIRED_OVERLAY_SIZE
     81 U00f0
     82 U00f0							;EOF
------- FILE ./chess.asm
------- FILE stack.asm LEVEL 2 PASS 4
      0 U00f0					      include	"stack.asm"
      1 U00f0							; Chess
      2 U00f0							; Atari 2600 Chess display system
      3 U00f0							; Copyright (c) 2019-2020 Andrew Davie
      4 U00f0							; andrew@taswegian.com
      5 U00f0
      6 U00f0
      7 U00f0		       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
      8 U00f0
      9 U00f0		       00 00 00 00*	      ds	RESERVED_FOR_STACK
     10 U00fc
     11 U00fc							; WARNING/NOTE - the alphabeta search violates the above size constraints
     12 U00fc							; HOWEVER, the "OVERLAY" segment is beneath this, and will be stomped, depending on # plys
     13 U00fc							;  but since overlay is not generally stressed during alphabeta, we're good.
------- FILE ./chess.asm
    541 U00fc
 FREE BYTES IN ZERO PAGE =  $3
    542 U00fc					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    543 U00fc				  -	      IF	* > $FF
    544 U00fc				  -	      ERR	"Zero Page overflow!"
    545 U00fc					      ENDIF
    546 U00fc
    547 U00fc							;------------------------------------------------------------------------------
    548 U00fc							;##############################################################################
    549 U00fc							;------------------------------------------------------------------------------
    550 U00fc
    551 U00fc							; NOW THE VERY INTERESTING '3E' RAM BANKS
    552 U00fc							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 512 bytes TOTAL ACCESSIBLE
    553 U00fc							; IN A 1K MEMORY SPACE
    554 U00fc
      0 U00fc					      SLOT	0
      1 U00fc				  -	      IF	(0 < 0) || (0 > 3)
      2 U00fc				  -	      ECHO	"Illegal bank address/segment location", 0
      3 U00fc				  -	      ERR
      4 U00fc					      ENDIF
      5 U00fc				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      6 U00fc				   _BANK_SLOT SET	0 * 64
      0 U00fc					      NEWRAMBANK	CHESS_BOARD_ROW
      1 U00fc
      2 U00fc
      3 U00fc
      4 U0000 ????				      SEG.U	CHESS_BOARD_ROW
      5 U0000					      ORG	ORIGIN_RAM
      6 U0000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0000				   _BANK_START SET	*
      8 U0000				   RAMBANK_CHESS_BOARD_ROW SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0000				   _CURRENT_RAMBANK SET	RAMBANK_CHESS_BOARD_ROW
     10 U0000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    557 U0000					      REPEAT	(CHESSBOARD_ROWS) - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U0000
      2 U0000
      3 U0000
      4 U1c00 ????				      SEG.U	.DUMMY
      5 U0400					      ORG	ORIGIN_RAM
      6 U0400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0400				   _BANK_START SET	*
      8 U0400				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    557 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400
      2 U0400
      3 U0400
      4 U0400					      SEG.U	.DUMMY
      5 U0800					      ORG	ORIGIN_RAM
      6 U0800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0800				   _BANK_START SET	*
      8 U0800				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    557 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800
      2 U0800
      3 U0800
      4 U0800					      SEG.U	.DUMMY
      5 U0c00					      ORG	ORIGIN_RAM
      6 U0c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0c00				   _BANK_START SET	*
      8 U0c00				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    557 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00
      2 U0c00
      3 U0c00
      4 U0c00					      SEG.U	.DUMMY
      5 U1000					      ORG	ORIGIN_RAM
      6 U1000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1000				   _BANK_START SET	*
      8 U1000				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    557 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000
      2 U1000
      3 U1000
      4 U1000					      SEG.U	.DUMMY
      5 U1400					      ORG	ORIGIN_RAM
      6 U1400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1400				   _BANK_START SET	*
      8 U1400				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    557 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400
      2 U1400
      3 U1400
      4 U1400					      SEG.U	.DUMMY
      5 U1800					      ORG	ORIGIN_RAM
      6 U1800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1800				   _BANK_START SET	*
      8 U1800				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    557 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800
      2 U1800
      3 U1800
      4 U1800					      SEG.U	.DUMMY
      5 U1c00					      ORG	ORIGIN_RAM
      6 U1c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1c00				   _BANK_START SET	*
      8 U1c00				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    559 U1c00					      REPEND
    560 U1c00
    561 U1c00							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    562 U1c00							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    563 U1c00							; The variable definitions are also in that ROM bank (even though they're RAM :)
    564 U1c00
    565 U1c00							; Now we have the actual graphics data for each of the rows.  This consists of an
    566 U1c00							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    567 U1c00							; character shapes are masked/copied. The depth of the character shapes may be
    568 U1c00							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    569 U1c00							; a multiple of 3, so that the RGB scanlines match at character joins.
    570 U1c00
    571 U1c00							; We have one bank for each chessboard row.  These banks are duplicates of the above,
    572 U1c00							; accessed via the above labels but with the appropriate bank switched in.
    573 U1c00
    574 U1c00							;---------------------------------------------------------------------------------------------------
    575 U1c00
    576 U1c00
    577 U1c00		       00 fe	   RND_EOR_VAL =	$FE	;B4
    578 U1c00
    579 U1c00					      MAC	next_random
    580 U1c00					      lda	rnd
    581 U1c00					      lsr
    582 U1c00					      bcc	.skipEOR
    583 U1c00					      eor	#RND_EOR_VAL
    584 U1c00				   .skipEOR   sta	rnd
    585 U1c00					      ENDM
    586 U1c00
    587 U1c00							;--------------------------------------------------------------------------------
    588 U1c00
    589 U1c00					      MAC	phase
    590 U1c00					      lda	#{1}
    591 U1c00					      sta	aiState
    592 U1c00					      ENDM		;#
    593 U1c00
    594 U1c00
    595 U1c00							;--------------------------------------------------------------------------------
    596 U1c00
    597 U1c00					      MAC	common_vars_alphabeta
    598 U1c00
    599 U1c00					      VAR	__thinkbar, 1
    600 U1c00					      VAR	__toggle, 1
    601 U1c00
    602 U1c00					      VAR	__bestMove, 1
    603 U1c00					      VAR	__alpha, 2
    604 U1c00					      VAR	__beta, 2
    605 U1c00					      VAR	__negaMax, 2
    606 U1c00					      VAR	__value, 2
    607 U1c00
    608 U1c00					      VAR	__quiesceCapOnly, 1
    609 U1c00
    610 U1c00					      ENDM
    611 U1c00
    612 U1c00
    613 U1c00							;---------------------------------------------------------------------------------------------------
    614 U1c00
------- FILE BANK_FIRST@0.asm LEVEL 2 PASS 4
      0 U1c00					      include	"BANK_FIRST@0.asm"	; MUST be first in ROM - contains reset vectors
      1 U1c00							; Chess
      2 U1c00							; Copyright (c) 2019-2020 Andrew Davie
      3 U1c00							; andrew@taswegian.com
      4 U1c00
      5 U1c00
      6 U1c00							; SLOT0 - screen draw, state machine dispatcher
      7 U1c00							; SLOT1 - anything
      8 U1c00							; SLOT2 - moves/ply
      9 U1c00							; SLOT3 - board
     10 U1c00
     11 U1c00
     12 U1c00
     13 U1c00
     14 U1c00
     15 U1c00
      0 U1c00					      SLOT	0
      1 U1c00				  -	      IF	(0 < 0) || (0 > 3)
      2 U1c00				  -	      ECHO	"Illegal bank address/segment location", 0
      3 U1c00				  -	      ERR
      4 U1c00					      ENDIF
      5 U1c00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      6 U1c00				   _BANK_SLOT SET	0 * 64
     17 U1c00
     18 U1c00							;---------------------------------------------------------------------------------------------------
     19 U1c00							;#########################################  FIXED BANK  ############################################
     20 U1c00							;---------------------------------------------------------------------------------------------------
     21 U1c00
     22 U1c00				   _ORIGIN    SET	_FIRST_BANK
     23 U1c00
      0 U1c00					      NEWBANK	THE_FIRST_BANK
      1  035b ????				      SEG	THE_FIRST_BANK
      2  0000					      ORG	_ORIGIN
      3  0000					      RORG	_BANK_ADDRESS_ORIGIN
      4  0000				   _BANK_START SET	*
      5  0000				   THE_FIRST_BANK_START SET	*
      6  0000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0000				   THE_FIRST_BANK SET	_BANK_SLOT + _CURRENT_BANK
      8  0000				   _ORIGIN    SET	_ORIGIN + 1024
     25  0000					      RORG	$f000
     26  0000
     27  0000							;---------------------------------------------------------------------------------------------------
     28  0000
      0  0000					      DEF	StartupBankReset
      1  0000				   SLOT_StartupBankReset SET	_BANK_SLOT
      2  0000				   BANK_StartupBankReset SET	SLOT_StartupBankReset + _CURRENT_BANK
      3  0000				   StartupBankReset
      4  0000				   TEMPORARY_VAR SET	Overlay
      5  0000				   TEMPORARY_OFFSET SET	0
      6  0000				   VAR_BOUNDARY_StartupBankReset SET	TEMPORARY_OFFSET
      7  0000				   FUNCTION_NAME SET	StartupBankReset
     30  0000					      SUBROUTINE
     31  0000
      0  0000					      VEND	StartupBankReset
      1  0000				  -	      IFNCONST	StartupBankReset
      2  0000				  -	      ECHO	"Incorrect VEND label", StartupBankReset
      3  0000				  -	      ERR
      4  0000					      ENDIF
      5  0000		       00 a4	   VAREND_StartupBankReset =	TEMPORARY_VAR
     33  0000
     34  0000							; On startup, 3E+ switches banks 0 and 3 to the 1st ROM bank (1K), from which the reset
     35  0000							; vector is obtained from bank 0 (+$FFC). Chess3E+ (maybe) will leave this bank (3) alone
     36  0000							; so that a system reset will always have the reset vectors available at FFFC, where expected
     37  0000
     38  0000		       a2 ff		      ldx	#$FF
     39  0002		       9a		      txs
     40  0003
      0  0003					      CALL	CartInit
      1  0003				  -	      IF	SLOT_CartInit == _BANK_SLOT
      2  0003				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0003				  -	      ECHO	"Cannot switch bank in use for", CartInit
      4  0003				  -	      ERR
      5  0003					      ENDIF
      6  0003		       a9 41		      lda	#BANK_CartInit
      7  0005		       85 3f		      sta	SET_BANK
      8  0007		       20 00 f4 	      jsr	CartInit
      0  000a					      CALL	SetupBanks
      1  000a				  -	      IF	SLOT_SetupBanks == _BANK_SLOT
      2  000a				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  000a				  -	      ECHO	"Cannot switch bank in use for", SetupBanks
      4  000a				  -	      ERR
      5  000a					      ENDIF
      6  000a		       a9 41		      lda	#BANK_SetupBanks
      7  000c		       85 3f		      sta	SET_BANK
      8  000e		       20 3a f4 	      jsr	SetupBanks
      0  0011					      CALL	InitialisePieceSquares
      1  0011				  -	      IF	SLOT_InitialisePieceSquares == _BANK_SLOT
      2  0011				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0011				  -	      ECHO	"Cannot switch bank in use for", InitialisePieceSquares
      4  0011				  -	      ERR
      5  0011					      ENDIF
      6  0011		       a9 41		      lda	#BANK_InitialisePieceSquares
      7  0013		       85 3f		      sta	SET_BANK
      8  0015		       20 9a f4 	      jsr	InitialisePieceSquares
     44  0018		       20 ed f1 	      jsr	ListPlayerMoves	;@0
     45  001b
     46  001b
     47  001b				   .StartFrame
     48  001b
     49  001b
     50  001b							; START OF FRAME
     51  001b
     52  001b		       a9 0e		      lda	#%1110	; VSYNC ON
     53  001d		       85 42	   .loopVSync3 sta	WSYNC
     54  001f		       85 40		      sta	VSYNC
     55  0021		       4a		      lsr
     56  0022		       d0 f9		      bne	.loopVSync3	; branch until VYSNC has been reset
     57  0024
     58  0024		       85 41		      sta	VBLANK
     59  0026
     60  0026		       a0 2e		      ldy	#TIME_PART_1
     61  0028		       8c 96 02 	      sty	TIM64T
     62  002b
     63  002b							; LOTS OF PROCESSING TIME - USE IT
     64  002b
     65  002b
     66  002b
     67  002b		       20 63 f1 	      jsr	AiStateMachine
     68  002e
     69  002e				  -	      IF	ASSERTS
     70  002e				  -			; Catch timer expired already
     71  002e				  -			;		      bit TIMINT
     72  002e				  -			;.whoops	      bmi .whoops
     73  002e					      ENDIF
     74  002e
     75  002e
     76  002e		       2c 85 02    .wait      bit	TIMINT
     77  0031		       10 fb		      bpl	.wait
     78  0033
     79  0033
     80  0033							; START OF VISIBLE SCANLINES
     81  0033
     82  0033
      0  0033					      CALL	longD
      1  0033				  -	      IF	SLOT_longD == _BANK_SLOT
      2  0033				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0033				  -	      ECHO	"Cannot switch bank in use for", longD
      4  0033				  -	      ERR
      5  0033					      ENDIF
      6  0033		       a9 91		      lda	#BANK_longD
      7  0035		       85 3f		      sta	SET_BANK
      8  0037		       20 14 f8 	      jsr	longD
     84  003a
     85  003a
     86  003a		       a2 80		      ldx	#SLOT_DrawRow	; + BANK_DrawRow
     87  003c		       86 3e		      stx	SET_BANK_RAM
     88  003e		       20 03 f9 	      jsr	DrawRow	; draw the ENTIRE visible screen!
     89  0041
      0  0041					      CALL	tidySc
      1  0041				  -	      IF	SLOT_tidySc == _BANK_SLOT
      2  0041				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0041				  -	      ECHO	"Cannot switch bank in use for", tidySc
      4  0041				  -	      ERR
      5  0041					      ENDIF
      6  0041		       a9 91		      lda	#BANK_tidySc
      7  0043		       85 3f		      sta	SET_BANK
      8  0045		       20 00 f8 	      jsr	tidySc
     91  0048
     92  0048		       20 63 f1 	      jsr	AiStateMachine
     93  004b
     94  004b		       ad 84 02 	      lda	INTIM
     95  004e		       c9 14		      cmp	#20
     96  0050		       90 24		      bcc	.notnow
     97  0052
     98  0052							;CALL GameSpeak
      0  0052					      CALL	PositionSprites
      1  0052				  -	      IF	SLOT_PositionSprites == _BANK_SLOT
      2  0052				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0052				  -	      ECHO	"Cannot switch bank in use for", PositionSprites
      4  0052				  -	      ERR
      5  0052					      ENDIF
      6  0052		       a9 47		      lda	#BANK_PositionSprites
      7  0054		       85 3f		      sta	SET_BANK
      8  0056		       20 00 f6 	      jsr	PositionSprites
    100  0059
    101  0059
    102  0059					      IF	1
    103  0059							; "draw" sprite shapes into row banks
    104  0059
    105  0059		       a2 07		      ldx	#7
    106  005b		       8a	   zapem      txa
    107  005c		       18		      clc
    108  005d		       69 80		      adc	#SLOT_DrawRow
    109  005f		       85 3e		      sta	SET_BANK_RAM
      0  0061					      CALL	WriteBlank	;@3
      1  0061				  -	      IF	SLOT_WriteBlank == _BANK_SLOT
      2  0061				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0061				  -	      ECHO	"Cannot switch bank in use for", WriteBlank
      4  0061				  -	      ERR
      5  0061					      ENDIF
      6  0061		       a9 c3		      lda	#BANK_WriteBlank
      7  0063		       85 3f		      sta	SET_BANK
      8  0065		       20 0b fc 	      jsr	WriteBlank
    111  0068		       ca		      dex
    112  0069		       10 f0		      bpl	zapem
    113  006b
    114  006b		       a9 c3		      lda	#BANK_WriteCursor
    115  006d		       85 3f		      sta	SET_BANK
      0  006f					      CALL	WriteCursor	;@3
      1  006f				  -	      IF	SLOT_WriteCursor == _BANK_SLOT
      2  006f				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  006f				  -	      ECHO	"Cannot switch bank in use for", WriteCursor
      4  006f				  -	      ERR
      5  006f					      ENDIF
      6  006f		       a9 c3		      lda	#BANK_WriteCursor
      7  0071		       85 3f		      sta	SET_BANK
      8  0073		       20 34 fc 	      jsr	WriteCursor
    117  0076					      ENDIF
    118  0076
    119  0076				   .notnow
    120  0076
    121  0076		       2c 85 02    .waitTime  bit	TIMINT
    122  0079		       10 fb		      bpl	.waitTime
    123  007b
    124  007b		       4c 1b f0 	      jmp	.StartFrame
    125  007e
    126  007e
    127  007e							;---------------------------------------------------------------------------------------------------
    128  007e
      0  007e					      DEF	ThinkBar
      1  007e				   SLOT_ThinkBar SET	_BANK_SLOT
      2  007e				   BANK_ThinkBar SET	SLOT_ThinkBar + _CURRENT_BANK
      3  007e				   ThinkBar
      4  007e				   TEMPORARY_VAR SET	Overlay
      5  007e				   TEMPORARY_OFFSET SET	0
      6  007e				   VAR_BOUNDARY_ThinkBar SET	TEMPORARY_OFFSET
      7  007e				   FUNCTION_NAME SET	ThinkBar
    130  007e					      SUBROUTINE
    131  007e
      0  007e					      REFER	negaMax
      1  007e					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  007e				   TEMPORARY_VAR SET	VAREND_negaMax
      3  007e					      ENDIF
      0  007e					      VEND	ThinkBar
      1  007e				  -	      IFNCONST	ThinkBar
      2  007e				  -	      ECHO	"Incorrect VEND label", ThinkBar
      3  007e				  -	      ERR
      4  007e					      ENDIF
      5  007e		       00 b0	   VAREND_ThinkBar =	TEMPORARY_VAR
    134  007e
    135  007e					      IF	DIAGNOSTICS
    136  007e
    137  007e		       e6 9e		      inc	positionCount
    138  0080		       d0 06		      bne	.p1
    139  0082		       e6 9f		      inc	positionCount+1
    140  0084		       d0 02		      bne	.p1
    141  0086		       e6 a0		      inc	positionCount+2
    142  0088				   .p1
    143  0088					      ENDIF
    144  0088
    145  0088							; The 'thinkbar' pattern...
    146  0088
    147  0088		       a9 00		      lda	#0
    148  008a		       a4 4c		      ldy	INPT4
    149  008c		       30 0a		      bmi	.doThink
    150  008e
      0  008e					      DEF	ThinkBarDebug
      1  008e				   SLOT_ThinkBarDebug SET	_BANK_SLOT
      2  008e				   BANK_ThinkBarDebug SET	SLOT_ThinkBarDebug + _CURRENT_BANK
      3  008e				   ThinkBarDebug
      4  008e				   TEMPORARY_VAR SET	Overlay
      5  008e				   TEMPORARY_OFFSET SET	0
      6  008e				   VAR_BOUNDARY_ThinkBarDebug SET	TEMPORARY_OFFSET
      7  008e				   FUNCTION_NAME SET	ThinkBarDebug
    152  008e
    153  008e		       e6 a4		      inc	__thinkbar
    154  0090		       a5 a4		      lda	__thinkbar
    155  0092		       29 0f		      and	#15
    156  0094		       a8		      tay
    157  0095		       b9 9d f0 	      lda	SynapsePattern,y
    158  0098
    159  0098		       85 4f	   .doThink   sta	PF2
    160  009a		       85 4e		      sta	PF1
    161  009c		       60		      rts
    162  009d
    163  009d
    164  009d
    165  009d				   SynapsePattern
    166  009d
    167  009d		       c1		      .byte.b	%11000001
    168  009e		       60		      .byte.b	%01100000
    169  009f		       30		      .byte.b	%00110000
    170  00a0		       18		      .byte.b	%00011000
    171  00a1		       0c		      .byte.b	%00001100
    172  00a2		       06		      .byte.b	%00000110
    173  00a3		       83		      .byte.b	%10000011
    174  00a4		       c1		      .byte.b	%11000001
    175  00a5
    176  00a5		       83		      .byte.b	%10000011
    177  00a6		       06		      .byte.b	%00000110
    178  00a7		       0c		      .byte.b	%00001100
    179  00a8		       18		      .byte.b	%00011000
    180  00a9		       30		      .byte.b	%00110000
    181  00aa		       60		      .byte.b	%01100000
    182  00ab		       c1		      .byte.b	%11000001
    183  00ac		       83		      .byte.b	%10000011
    184  00ad
    185  00ad
    186  00ad							;---------------------------------------------------------------------------------------------------
    187  00ad
      0  00ad					      DEF	CopySinglePiece	;@0 - uses @2
      1  00ad				   SLOT_CopySinglePiece SET	_BANK_SLOT
      2  00ad				   BANK_CopySinglePiece SET	SLOT_CopySinglePiece + _CURRENT_BANK
      3  00ad				   CopySinglePiece
      4  00ad				   TEMPORARY_VAR SET	Overlay
      5  00ad				   TEMPORARY_OFFSET SET	0
      6  00ad				   VAR_BOUNDARY_CopySinglePiece SET	TEMPORARY_OFFSET
      7  00ad				   FUNCTION_NAME SET	CopySinglePiece
    189  00ad					      SUBROUTINE
      0  00ad					      TIMING	COPYSINGLEPIECE, (2600)
      1  00ad		       00 29	   SPEEDOF_COPYSINGLEPIECE =	((2600)/64) + 1
    191  00ad
      0  00ad					      REFER	showMoveCaptures
      1  00ad					      IF	VAREND_showMoveCaptures > TEMPORARY_VAR
      2  00ad				   TEMPORARY_VAR SET	VAREND_showMoveCaptures
      3  00ad					      ENDIF
      0  00ad					      REFER	aiDrawEntireBoard
      1  00ad				  -	      IF	VAREND_aiDrawEntireBoard > TEMPORARY_VAR
      2  00ad				  -TEMPORARY_VAR SET	VAREND_aiDrawEntireBoard
      3  00ad					      ENDIF
      0  00ad					      REFER	aiDrawPart2
      1  00ad				  -	      IF	VAREND_aiDrawPart2 > TEMPORARY_VAR
      2  00ad				  -TEMPORARY_VAR SET	VAREND_aiDrawPart2
      3  00ad					      ENDIF
      0  00ad					      REFER	aiMarchB
      1  00ad				  -	      IF	VAREND_aiMarchB > TEMPORARY_VAR
      2  00ad				  -TEMPORARY_VAR SET	VAREND_aiMarchB
      3  00ad					      ENDIF
      0  00ad					      REFER	aiFlashComputerMove
      1  00ad				  -	      IF	VAREND_aiFlashComputerMove > TEMPORARY_VAR
      2  00ad				  -TEMPORARY_VAR SET	VAREND_aiFlashComputerMove
      3  00ad					      ENDIF
      0  00ad					      REFER	aiSelectDestinationSquare
      1  00ad				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  00ad				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  00ad					      ENDIF
      0  00ad					      REFER	aiMarchA2
      1  00ad				  -	      IF	VAREND_aiMarchA2 > TEMPORARY_VAR
      2  00ad				  -TEMPORARY_VAR SET	VAREND_aiMarchA2
      3  00ad					      ENDIF
      0  00ad					      REFER	aiMarchB2
      1  00ad				  -	      IF	VAREND_aiMarchB2 > TEMPORARY_VAR
      2  00ad				  -TEMPORARY_VAR SET	VAREND_aiMarchB2
      3  00ad					      ENDIF
      0  00ad					      REFER	aiWriteStartPieceBlank
      1  00ad				  -	      IF	VAREND_aiWriteStartPieceBlank > TEMPORARY_VAR
      2  00ad				  -TEMPORARY_VAR SET	VAREND_aiWriteStartPieceBlank
      3  00ad					      ENDIF
      0  00ad					      REFER	aiChoosePromotePiece
      1  00ad				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  00ad				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  00ad					      ENDIF
      0  00ad					      REFER	aiMarchToTargetB
      1  00ad				  -	      IF	VAREND_aiMarchToTargetB > TEMPORARY_VAR
      2  00ad				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetB
      3  00ad					      ENDIF
      0  00ad					      REFER	aiPromotePawnStart
      1  00ad				  -	      IF	VAREND_aiPromotePawnStart > TEMPORARY_VAR
      2  00ad				  -TEMPORARY_VAR SET	VAREND_aiPromotePawnStart
      3  00ad					      ENDIF
      0  00ad					      REFER	aiFinalFlash
      1  00ad				  -	      IF	VAREND_aiFinalFlash > TEMPORARY_VAR
      2  00ad				  -TEMPORARY_VAR SET	VAREND_aiFinalFlash
      3  00ad					      ENDIF
    205  00ad
    206  00ad				  -	      IF	ENPASSANT_ENABLED
    207  00ad				  -	      REFER	EnPassantCheck
    208  00ad					      ENDIF
    209  00ad
      0  00ad					      VEND	CopySinglePiece
      1  00ad				  -	      IFNCONST	CopySinglePiece
      2  00ad				  -	      ECHO	"Incorrect VEND label", CopySinglePiece
      3  00ad				  -	      ERR
      4  00ad					      ENDIF
      5  00ad		       00 a7	   VAREND_CopySinglePiece =	TEMPORARY_VAR
    211  00ad
    212  00ad							; WARNING: CANNOT USE VAR/OVERLAY IN ANY ROUTINE CALLING THIS!!
    213  00ad							; ALSO CAN'T USE IN THIS ROUTINE
    214  00ad							; This routine will STOMP on those vars due to __pieceShapeBuffer occupying whole overlay
    215  00ad							; @2150 max
    216  00ad							; = 33 TIM64T
    217  00ad
    218  00ad							; Board is [SLOT3]
    219  00ad
    220  00ad
      0  00ad					      CALL	CopySetup	;@2
      1  00ad				  -	      IF	SLOT_CopySetup == _BANK_SLOT
      2  00ad				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  00ad				  -	      ECHO	"Cannot switch bank in use for", CopySetup
      4  00ad				  -	      ERR
      5  00ad					      ENDIF
      6  00ad		       a9 91		      lda	#BANK_CopySetup
      7  00af		       85 3f		      sta	SET_BANK
      8  00b1		       20 54 f8 	      jsr	CopySetup
    222  00b4
    223  00b4
      0  00b4					      DEF	InterceptMarkerCopy
      1  00b4				   SLOT_InterceptMarkerCopy SET	_BANK_SLOT
      2  00b4				   BANK_InterceptMarkerCopy SET	SLOT_InterceptMarkerCopy + _CURRENT_BANK
      3  00b4				   InterceptMarkerCopy
      4  00b4				   TEMPORARY_VAR SET	Overlay
      5  00b4				   TEMPORARY_OFFSET SET	0
      6  00b4				   VAR_BOUNDARY_InterceptMarkerCopy SET	TEMPORARY_OFFSET
      7  00b4				   FUNCTION_NAME SET	InterceptMarkerCopy
    225  00b4					      SUBROUTINE
    226  00b4
      0  00b4					      REFER	CopySinglePiece
      1  00b4					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  00b4				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  00b4					      ENDIF
      0  00b4					      REFER	showPromoteOptions
      1  00b4				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  00b4				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  00b4					      ENDIF
      0  00b4					      REFER	showMoveOptions
      1  00b4				  -	      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  00b4				  -TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  00b4					      ENDIF
      0  00b4					      VEND	InterceptMarkerCopy
      1  00b4				  -	      IFNCONST	InterceptMarkerCopy
      2  00b4				  -	      ECHO	"Incorrect VEND label", InterceptMarkerCopy
      3  00b4				  -	      ERR
      4  00b4					      ENDIF
      5  00b4		       00 a7	   VAREND_InterceptMarkerCopy =	TEMPORARY_VAR
    231  00b4
    232  00b4							; Copy a piece shape (3 PF bytes wide x 24 lines) to the RAM buffer
    233  00b4							; y = piece index
    234  00b4
    235  00b4		       a9 91		      lda	#BANK_PIECE_VECTOR_BANK
    236  00b6		       85 3f		      sta	SET_BANK	;@2
    237  00b8
    238  00b8		       b9 63 f9 	      lda	PIECE_VECTOR_LO,y
    239  00bb		       85 ec		      sta	__ptr
    240  00bd		       b9 f3 f9 	      lda	PIECE_VECTOR_HI,y
    241  00c0		       85 ed		      sta	__ptr+1
    242  00c2		       b9 83 fa 	      lda	PIECE_VECTOR_BANK,y
    243  00c5		       85 3f		      sta	SET_BANK	;@2
    244  00c7
    245  00c7		       a0 47		      ldy	#PIECE_SHAPE_SIZE-1
    246  00c9		       b1 ec	   .copy      lda	(__ptr),y
    247  00cb		       99 a4 00 	      sta	__pieceShapeBuffer,y
    248  00ce		       88		      dey
    249  00cf		       10 f8		      bpl	.copy
    250  00d1
    251  00d1		       a5 80		      lda	squareToDraw
    252  00d3		       38		      sec
    253  00d4		       a2 0a		      ldx	#10
    254  00d6		       e9 0a	   .sub10     sbc	#10
    255  00d8		       ca		      dex
    256  00d9		       b0 fb		      bcs	.sub10
    257  00db
    258  00db		       69 08		      adc	#8
    259  00dd		       c9 04		      cmp	#4	; CS = right side of screen
    260  00df
    261  00df		       8a		      txa
    262  00e0		       09 80		      ora	#[SLOT2]
    263  00e2		       85 3e		      sta	SET_BANK_RAM	;@2		 ; bank row
    264  00e4
    265  00e4		       20 f7 f2 	      jsr	CopyPieceToRowBitmap	;@3
    266  00e7		       60		      rts
    267  00e8
    268  00e8
    269  00e8							;---------------------------------------------------------------------------------------------------
    270  00e8
    271  00e8				   P	      SET	0
    272  00e8					      MAC	ain
    273  00e8				   AI_{1}     SET	P
    274  00e8				   P	      SET	P+1
    275  00e8					      ENDM
    276  00e8
    277  00e8					      MAC	lo
    278  00e8					      .byte	<ai{1}
    279  00e8					      ENDM
    280  00e8
    281  00e8					      MAC	hi
    282  00e8					      .byte	>ai{1}
    283  00e8					      ENDM
    284  00e8
    285  00e8					      MAC	bk
    286  00e8					      .byte	BANK_ai{1}
    287  00e8					      ENDM
    288  00e8
    289  00e8
    290  00e8		       00 28	   ONCEPERFRAME =	40
    291  00e8
    292  00e8					      MAC	tabdef
    293  00e8
    294  00e8					      {1}	FlashComputerMove	; 0
    295  00e8					      {1}	BeginSelectMovePhase	; 1
    296  00e8					      {1}	SelectStartSquare	; 2
    297  00e8					      {1}	StartSquareSelected	; 3
    298  00e8					      {1}	DrawMoves	; 4
    299  00e8					      {1}	ShowMoveCaptures	; 5
    300  00e8					      {1}	SlowFlash	; 6
    301  00e8					      {1}	UnDrawTargetSquares	; 7
    302  00e8					      {1}	SelectDestinationSquare	; 8
    303  00e8					      {1}	Quiescent	; 9
    304  00e8					      {1}	ReselectDebounce	; 10
    305  00e8					      {1}	StartMoveGen	; 11
    306  00e8					      {1}	StepMoveGen	; 12
    307  00e8					      {1}	StartClearBoard	; 13
    308  00e8					      {1}	ClearEachRow	; 14
    309  00e8					      {1}	DrawEntireBoard	; 15
    310  00e8					      {1}	DrawPart2	; 16
    311  00e8					      {1}	DrawPart3	; 17
    312  00e8					      {1}	GenerateMoves	; 18
    313  00e8					      {1}	ComputerMove	; 19
    314  00e8					      {1}	MoveIsSelected	; 20
    315  00e8					      {1}	WriteStartPieceBlank	; 21
    316  00e8					      {1}	MarchToTargetA	; 22
    317  00e8					      {1}	MarchA2	; 23
    318  00e8					      {1}	MarchB	; 24
    319  00e8					      {1}	MarchToTargetB	; 25
    320  00e8					      {1}	MarchB2	; 26
    321  00e8					      {1}	FinalFlash	; 27
    322  00e8					      {1}	SpecialMoveFixup	; 28
    323  00e8					      {1}	InCheckBackup	; 29
    324  00e8					      {1}	InCheckDelay	; 30
    325  00e8					      {1}	PromotePawnStart	; 31
    326  00e8					      {1}	RollPromotionPiece	; 32
    327  00e8					      {1}	ChoosePromotePiece	; 33
    328  00e8					      {1}	ChooseDebounce	; 34
    329  00e8					      {1}	CheckMate	; 35
    330  00e8					      {1}	Draw	; 36
    331  00e8					      {1}	DelayAfterMove	; 37
    332  00e8					      {1}	DelayAfterMove2	; 38
    333  00e8					      {1}	DelayAfterPlaced	; 39
    334  00e8					      {1}	DelayAfterPlaced2	; 40
    335  00e8
    336  00e8					      ENDM		; {1} = macro to use
    337  00e8
      0  00e8					      TABDEF	AIN
      1  00e8
      0  00e8					      AIN	FlashComputerMove
      1  00e8				   AI_FlashComputerMove SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	BeginSelectMovePhase
      1  00e8				   AI_BeginSelectMovePhase SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	SelectStartSquare
      1  00e8				   AI_SelectStartSquare SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	StartSquareSelected
      1  00e8				   AI_StartSquareSelected SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	DrawMoves
      1  00e8				   AI_DrawMoves SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	ShowMoveCaptures
      1  00e8				   AI_ShowMoveCaptures SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	SlowFlash
      1  00e8				   AI_SlowFlash SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	UnDrawTargetSquares
      1  00e8				   AI_UnDrawTargetSquares SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	SelectDestinationSquare
      1  00e8				   AI_SelectDestinationSquare SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	Quiescent
      1  00e8				   AI_Quiescent SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	ReselectDebounce
      1  00e8				   AI_ReselectDebounce SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	StartMoveGen
      1  00e8				   AI_StartMoveGen SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	StepMoveGen
      1  00e8				   AI_StepMoveGen SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	StartClearBoard
      1  00e8				   AI_StartClearBoard SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	ClearEachRow
      1  00e8				   AI_ClearEachRow SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	DrawEntireBoard
      1  00e8				   AI_DrawEntireBoard SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	DrawPart2
      1  00e8				   AI_DrawPart2 SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	DrawPart3
      1  00e8				   AI_DrawPart3 SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	GenerateMoves
      1  00e8				   AI_GenerateMoves SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	ComputerMove
      1  00e8				   AI_ComputerMove SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	MoveIsSelected
      1  00e8				   AI_MoveIsSelected SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	WriteStartPieceBlank
      1  00e8				   AI_WriteStartPieceBlank SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	MarchToTargetA
      1  00e8				   AI_MarchToTargetA SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	MarchA2
      1  00e8				   AI_MarchA2 SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	MarchB
      1  00e8				   AI_MarchB  SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	MarchToTargetB
      1  00e8				   AI_MarchToTargetB SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	MarchB2
      1  00e8				   AI_MarchB2 SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	FinalFlash
      1  00e8				   AI_FinalFlash SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	SpecialMoveFixup
      1  00e8				   AI_SpecialMoveFixup SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	InCheckBackup
      1  00e8				   AI_InCheckBackup SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	InCheckDelay
      1  00e8				   AI_InCheckDelay SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	PromotePawnStart
      1  00e8				   AI_PromotePawnStart SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	RollPromotionPiece
      1  00e8				   AI_RollPromotionPiece SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	ChoosePromotePiece
      1  00e8				   AI_ChoosePromotePiece SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	ChooseDebounce
      1  00e8				   AI_ChooseDebounce SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	CheckMate
      1  00e8				   AI_CheckMate SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	Draw
      1  00e8				   AI_Draw    SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	DelayAfterMove
      1  00e8				   AI_DelayAfterMove SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	DelayAfterMove2
      1  00e8				   AI_DelayAfterMove2 SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	DelayAfterPlaced
      1  00e8				   AI_DelayAfterPlaced SET	P
      2  00e8				   P	      SET	P+1
      0  00e8					      AIN	DelayAfterPlaced2
      1  00e8				   AI_DelayAfterPlaced2 SET	P
      2  00e8				   P	      SET	P+1
     43  00e8
    339  00e8
      0  00e8					      DEF	AiVectorLO
      1  00e8				   SLOT_AiVectorLO SET	_BANK_SLOT
      2  00e8				   BANK_AiVectorLO SET	SLOT_AiVectorLO + _CURRENT_BANK
      3  00e8				   AiVectorLO
      4  00e8				   TEMPORARY_VAR SET	Overlay
      5  00e8				   TEMPORARY_OFFSET SET	0
      6  00e8				   VAR_BOUNDARY_AiVectorLO SET	TEMPORARY_OFFSET
      7  00e8				   FUNCTION_NAME SET	AiVectorLO
      0  00e8					      TABDEF	LO
      1  00e8
      0  00e8					      LO	FlashComputerMove
      1  00e8		       3c		      .byte.b	<aiFlashComputerMove
      0  00e9					      LO	BeginSelectMovePhase
      1  00e9		       1d		      .byte.b	<aiBeginSelectMovePhase
      0  00ea					      LO	SelectStartSquare
      1  00ea		       64		      .byte.b	<aiSelectStartSquare
      0  00eb					      LO	StartSquareSelected
      1  00eb		       e4		      .byte.b	<aiStartSquareSelected
      0  00ec					      LO	DrawMoves
      1  00ec		       ff		      .byte.b	<aiDrawMoves
      0  00ed					      LO	ShowMoveCaptures
      1  00ed		       e2		      .byte.b	<aiShowMoveCaptures
      0  00ee					      LO	SlowFlash
      1  00ee		       04		      .byte.b	<aiSlowFlash
      0  00ef					      LO	UnDrawTargetSquares
      1  00ef		       bc		      .byte.b	<aiUnDrawTargetSquares
      0  00f0					      LO	SelectDestinationSquare
      1  00f0		       5b		      .byte.b	<aiSelectDestinationSquare
      0  00f1					      LO	Quiescent
      1  00f1		       bd		      .byte.b	<aiQuiescent
      0  00f2					      LO	ReselectDebounce
      1  00f2		       b4		      .byte.b	<aiReselectDebounce
      0  00f3					      LO	StartMoveGen
      1  00f3		       00		      .byte.b	<aiStartMoveGen
      0  00f4					      LO	StepMoveGen
      1  00f4		       fc		      .byte.b	<aiStepMoveGen
      0  00f5					      LO	StartClearBoard
      1  00f5		       28		      .byte.b	<aiStartClearBoard
      0  00f6					      LO	ClearEachRow
      1  00f6		       35		      .byte.b	<aiClearEachRow
      0  00f7					      LO	DrawEntireBoard
      1  00f7		       5a		      .byte.b	<aiDrawEntireBoard
      0  00f8					      LO	DrawPart2
      1  00f8		       00		      .byte.b	<aiDrawPart2
      0  00f9					      LO	DrawPart3
      1  00f9		       03		      .byte.b	<aiDrawPart3
      0  00fa					      LO	GenerateMoves
      1  00fa		       ea		      .byte.b	<aiGenerateMoves
      0  00fb					      LO	ComputerMove
      1  00fb		       00		      .byte.b	<aiComputerMove
      0  00fc					      LO	MoveIsSelected
      1  00fc		       42		      .byte.b	<aiMoveIsSelected
      0  00fd					      LO	WriteStartPieceBlank
      1  00fd		       84		      .byte.b	<aiWriteStartPieceBlank
      0  00fe					      LO	MarchToTargetA
      1  00fe		       38		      .byte.b	<aiMarchToTargetA
      0  00ff					      LO	MarchA2
      1  00ff		       2b		      .byte.b	<aiMarchA2
      0  0100					      LO	MarchB
      1  0100		       1d		      .byte.b	<aiMarchB
      0  0101					      LO	MarchToTargetB
      1  0101		       ab		      .byte.b	<aiMarchToTargetB
      0  0102					      LO	MarchB2
      1  0102		       58		      .byte.b	<aiMarchB2
      0  0103					      LO	FinalFlash
      1  0103		       87		      .byte.b	<aiFinalFlash
      0  0104					      LO	SpecialMoveFixup
      1  0104		       27		      .byte.b	<aiSpecialMoveFixup
      0  0105					      LO	InCheckBackup
      1  0105		       05		      .byte.b	<aiInCheckBackup
      0  0106					      LO	InCheckDelay
      1  0106		       10		      .byte.b	<aiInCheckDelay
      0  0107					      LO	PromotePawnStart
      1  0107		       c6		      .byte.b	<aiPromotePawnStart
      0  0108					      LO	RollPromotionPiece
      1  0108		       e5		      .byte.b	<aiRollPromotionPiece
      0  0109					      LO	ChoosePromotePiece
      1  0109		       00		      .byte.b	<aiChoosePromotePiece
      0  010a					      LO	ChooseDebounce
      1  010a		       6f		      .byte.b	<aiChooseDebounce
      0  010b					      LO	CheckMate
      1  010b		       32		      .byte.b	<aiCheckMate
      0  010c					      LO	Draw
      1  010c		       2d		      .byte.b	<aiDraw
      0  010d					      LO	DelayAfterMove
      1  010d		       81		      .byte.b	<aiDelayAfterMove
      0  010e					      LO	DelayAfterMove2
      1  010e		       8a		      .byte.b	<aiDelayAfterMove2
      0  010f					      LO	DelayAfterPlaced
      1  010f		       93		      .byte.b	<aiDelayAfterPlaced
      0  0110					      LO	DelayAfterPlaced2
      1  0110		       a2		      .byte.b	<aiDelayAfterPlaced2
     43  0111
    342  0111
      0  0111					      DEF	AiVectorHI
      1  0111				   SLOT_AiVectorHI SET	_BANK_SLOT
      2  0111				   BANK_AiVectorHI SET	SLOT_AiVectorHI + _CURRENT_BANK
      3  0111				   AiVectorHI
      4  0111				   TEMPORARY_VAR SET	Overlay
      5  0111				   TEMPORARY_OFFSET SET	0
      6  0111				   VAR_BOUNDARY_AiVectorHI SET	TEMPORARY_OFFSET
      7  0111				   FUNCTION_NAME SET	AiVectorHI
      0  0111					      TABDEF	HI
      1  0111
      0  0111					      HI	FlashComputerMove
      1  0111		       f4		      .byte.b	>aiFlashComputerMove
      0  0112					      HI	BeginSelectMovePhase
      1  0112		       f4		      .byte.b	>aiBeginSelectMovePhase
      0  0113					      HI	SelectStartSquare
      1  0113		       f4		      .byte.b	>aiSelectStartSquare
      0  0114					      HI	StartSquareSelected
      1  0114		       f4		      .byte.b	>aiStartSquareSelected
      0  0115					      HI	DrawMoves
      1  0115		       f4		      .byte.b	>aiDrawMoves
      0  0116					      HI	ShowMoveCaptures
      1  0116		       f5		      .byte.b	>aiShowMoveCaptures
      0  0117					      HI	SlowFlash
      1  0117		       f6		      .byte.b	>aiSlowFlash
      0  0118					      HI	UnDrawTargetSquares
      1  0118		       f5		      .byte.b	>aiUnDrawTargetSquares
      0  0119					      HI	SelectDestinationSquare
      1  0119		       f6		      .byte.b	>aiSelectDestinationSquare
      0  011a					      HI	Quiescent
      1  011a		       f6		      .byte.b	>aiQuiescent
      0  011b					      HI	ReselectDebounce
      1  011b		       f6		      .byte.b	>aiReselectDebounce
      0  011c					      HI	StartMoveGen
      1  011c		       f4		      .byte.b	>aiStartMoveGen
      0  011d					      HI	StepMoveGen
      1  011d		       f4		      .byte.b	>aiStepMoveGen
      0  011e					      HI	StartClearBoard
      1  011e		       f8		      .byte.b	>aiStartClearBoard
      0  011f					      HI	ClearEachRow
      1  011f		       f8		      .byte.b	>aiClearEachRow
      0  0120					      HI	DrawEntireBoard
      1  0120		       f4		      .byte.b	>aiDrawEntireBoard
      0  0121					      HI	DrawPart2
      1  0121		       f4		      .byte.b	>aiDrawPart2
      0  0122					      HI	DrawPart3
      1  0122		       f4		      .byte.b	>aiDrawPart3
      0  0123					      HI	GenerateMoves
      1  0123		       f4		      .byte.b	>aiGenerateMoves
      0  0124					      HI	ComputerMove
      1  0124		       f4		      .byte.b	>aiComputerMove
      0  0125					      HI	MoveIsSelected
      1  0125		       f8		      .byte.b	>aiMoveIsSelected
      0  0126					      HI	WriteStartPieceBlank
      1  0126		       f7		      .byte.b	>aiWriteStartPieceBlank
      0  0127					      HI	MarchToTargetA
      1  0127		       f6		      .byte.b	>aiMarchToTargetA
      0  0128					      HI	MarchA2
      1  0128		       f7		      .byte.b	>aiMarchA2
      0  0129					      HI	MarchB
      1  0129		       f4		      .byte.b	>aiMarchB
      0  012a					      HI	MarchToTargetB
      1  012a		       f4		      .byte.b	>aiMarchToTargetB
      0  012b					      HI	MarchB2
      1  012b		       f7		      .byte.b	>aiMarchB2
      0  012c					      HI	FinalFlash
      1  012c		       f6		      .byte.b	>aiFinalFlash
      0  012d					      HI	SpecialMoveFixup
      1  012d		       f4		      .byte.b	>aiSpecialMoveFixup
      0  012e					      HI	InCheckBackup
      1  012e		       f4		      .byte.b	>aiInCheckBackup
      0  012f					      HI	InCheckDelay
      1  012f		       f4		      .byte.b	>aiInCheckDelay
      0  0130					      HI	PromotePawnStart
      1  0130		       f4		      .byte.b	>aiPromotePawnStart
      0  0131					      HI	RollPromotionPiece
      1  0131		       f6		      .byte.b	>aiRollPromotionPiece
      0  0132					      HI	ChoosePromotePiece
      1  0132		       f4		      .byte.b	>aiChoosePromotePiece
      0  0133					      HI	ChooseDebounce
      1  0133		       f4		      .byte.b	>aiChooseDebounce
      0  0134					      HI	CheckMate
      1  0134		       f4		      .byte.b	>aiCheckMate
      0  0135					      HI	Draw
      1  0135		       f4		      .byte.b	>aiDraw
      0  0136					      HI	DelayAfterMove
      1  0136		       f4		      .byte.b	>aiDelayAfterMove
      0  0137					      HI	DelayAfterMove2
      1  0137		       f4		      .byte.b	>aiDelayAfterMove2
      0  0138					      HI	DelayAfterPlaced
      1  0138		       f4		      .byte.b	>aiDelayAfterPlaced
      0  0139					      HI	DelayAfterPlaced2
      1  0139		       f4		      .byte.b	>aiDelayAfterPlaced2
     43  013a
    345  013a
      0  013a					      DEF	AiVectorBANK
      1  013a				   SLOT_AiVectorBANK SET	_BANK_SLOT
      2  013a				   BANK_AiVectorBANK SET	SLOT_AiVectorBANK + _CURRENT_BANK
      3  013a				   AiVectorBANK
      4  013a				   TEMPORARY_VAR SET	Overlay
      5  013a				   TEMPORARY_OFFSET SET	0
      6  013a				   VAR_BOUNDARY_AiVectorBANK SET	TEMPORARY_OFFSET
      7  013a				   FUNCTION_NAME SET	AiVectorBANK
      0  013a					      TABDEF	BK
      1  013a
      0  013a					      BK	FlashComputerMove
      1  013a		       46		      .byte.b	BANK_aiFlashComputerMove
      0  013b					      BK	BeginSelectMovePhase
      1  013b		       46		      .byte.b	BANK_aiBeginSelectMovePhase
      0  013c					      BK	SelectStartSquare
      1  013c		       46		      .byte.b	BANK_aiSelectStartSquare
      0  013d					      BK	StartSquareSelected
      1  013d		       46		      .byte.b	BANK_aiStartSquareSelected
      0  013e					      BK	DrawMoves
      1  013e		       46		      .byte.b	BANK_aiDrawMoves
      0  013f					      BK	ShowMoveCaptures
      1  013f		       46		      .byte.b	BANK_aiShowMoveCaptures
      0  0140					      BK	SlowFlash
      1  0140		       46		      .byte.b	BANK_aiSlowFlash
      0  0141					      BK	UnDrawTargetSquares
      1  0141		       46		      .byte.b	BANK_aiUnDrawTargetSquares
      0  0142					      BK	SelectDestinationSquare
      1  0142		       46		      .byte.b	BANK_aiSelectDestinationSquare
      0  0143					      BK	Quiescent
      1  0143		       46		      .byte.b	BANK_aiQuiescent
      0  0144					      BK	ReselectDebounce
      1  0144		       46		      .byte.b	BANK_aiReselectDebounce
      0  0145					      BK	StartMoveGen
      1  0145		       46		      .byte.b	BANK_aiStartMoveGen
      0  0146					      BK	StepMoveGen
      1  0146		       47		      .byte.b	BANK_aiStepMoveGen
      0  0147					      BK	StartClearBoard
      1  0147		       91		      .byte.b	BANK_aiStartClearBoard
      0  0148					      BK	ClearEachRow
      1  0148		       91		      .byte.b	BANK_aiClearEachRow
      0  0149					      BK	DrawEntireBoard
      1  0149		       5a		      .byte.b	BANK_aiDrawEntireBoard
      0  014a					      BK	DrawPart2
      1  014a		       52		      .byte.b	BANK_aiDrawPart2
      0  014b					      BK	DrawPart3
      1  014b		       52		      .byte.b	BANK_aiDrawPart3
      0  014c					      BK	GenerateMoves
      1  014c		       47		      .byte.b	BANK_aiGenerateMoves
      0  014d					      BK	ComputerMove
      1  014d		       57		      .byte.b	BANK_aiComputerMove
      0  014e					      BK	MoveIsSelected
      1  014e		       91		      .byte.b	BANK_aiMoveIsSelected
      0  014f					      BK	WriteStartPieceBlank
      1  014f		       46		      .byte.b	BANK_aiWriteStartPieceBlank
      0  0150					      BK	MarchToTargetA
      1  0150		       47		      .byte.b	BANK_aiMarchToTargetA
      0  0151					      BK	MarchA2
      1  0151		       46		      .byte.b	BANK_aiMarchA2
      0  0152					      BK	MarchB
      1  0152		       52		      .byte.b	BANK_aiMarchB
      0  0153					      BK	MarchToTargetB
      1  0153		       47		      .byte.b	BANK_aiMarchToTargetB
      0  0154					      BK	MarchB2
      1  0154		       46		      .byte.b	BANK_aiMarchB2
      0  0155					      BK	FinalFlash
      1  0155		       47		      .byte.b	BANK_aiFinalFlash
      0  0156					      BK	SpecialMoveFixup
      1  0156		       5a		      .byte.b	BANK_aiSpecialMoveFixup
      0  0157					      BK	InCheckBackup
      1  0157		       46		      .byte.b	BANK_aiInCheckBackup
      0  0158					      BK	InCheckDelay
      1  0158		       46		      .byte.b	BANK_aiInCheckDelay
      0  0159					      BK	PromotePawnStart
      1  0159		       47		      .byte.b	BANK_aiPromotePawnStart
      0  015a					      BK	RollPromotionPiece
      1  015a		       46		      .byte.b	BANK_aiRollPromotionPiece
      0  015b					      BK	ChoosePromotePiece
      1  015b		       47		      .byte.b	BANK_aiChoosePromotePiece
      0  015c					      BK	ChooseDebounce
      1  015c		       47		      .byte.b	BANK_aiChooseDebounce
      0  015d					      BK	CheckMate
      1  015d		       52		      .byte.b	BANK_aiCheckMate
      0  015e					      BK	Draw
      1  015e		       52		      .byte.b	BANK_aiDraw
      0  015f					      BK	DelayAfterMove
      1  015f		       47		      .byte.b	BANK_aiDelayAfterMove
      0  0160					      BK	DelayAfterMove2
      1  0160		       47		      .byte.b	BANK_aiDelayAfterMove2
      0  0161					      BK	DelayAfterPlaced
      1  0161		       47		      .byte.b	BANK_aiDelayAfterPlaced
      0  0162					      BK	DelayAfterPlaced2
      1  0162		       47		      .byte.b	BANK_aiDelayAfterPlaced2
     43  0163
    348  0163
    349  0163
    350  0163							;---------------------------------------------------------------------------------------------------
    351  0163
      0  0163					      DEF	AiStateMachine
      1  0163				   SLOT_AiStateMachine SET	_BANK_SLOT
      2  0163				   BANK_AiStateMachine SET	SLOT_AiStateMachine + _CURRENT_BANK
      3  0163				   AiStateMachine
      4  0163				   TEMPORARY_VAR SET	Overlay
      5  0163				   TEMPORARY_OFFSET SET	0
      6  0163				   VAR_BOUNDARY_AiStateMachine SET	TEMPORARY_OFFSET
      7  0163				   FUNCTION_NAME SET	AiStateMachine
    353  0163					      SUBROUTINE
    354  0163
      0  0163					      REFER	StartupBankReset
      1  0163				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0163				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0163					      ENDIF
      0  0163					      VEND	AiStateMachine
      1  0163				  -	      IFNCONST	AiStateMachine
      2  0163				  -	      ECHO	"Incorrect VEND label", AiStateMachine
      3  0163				  -	      ERR
      4  0163					      ENDIF
      5  0163		       00 a4	   VAREND_AiStateMachine =	TEMPORARY_VAR
    357  0163
    358  0163
    359  0163							; State machine vector setup - points to current routine to execute
    360  0163
    361  0163		       a6 8b		      ldx	aiState
    362  0165		       bd e8 f0 	      lda	AiVectorLO,x
    363  0168		       85 ec		      sta	__ptr
    364  016a		       bd 11 f1 	      lda	AiVectorHI,x
    365  016d		       85 ed		      sta	__ptr+1
    366  016f
    367  016f		       bd 3a f1 	      lda	AiVectorBANK,x
    368  0172		       85 3f		      sta	SET_BANK
    369  0174		       6c ec 00 	      jmp	(__ptr)	; NOTE: could branch back to squeeze cycles
    370  0177
    371  0177
    372  0177							;---------------------------------------------------------------------------------------------------
    373  0177
      0  0177					      DEF	GenerateAllMoves
      1  0177				   SLOT_GenerateAllMoves SET	_BANK_SLOT
      2  0177				   BANK_GenerateAllMoves SET	SLOT_GenerateAllMoves + _CURRENT_BANK
      3  0177				   GenerateAllMoves
      4  0177				   TEMPORARY_VAR SET	Overlay
      5  0177				   TEMPORARY_OFFSET SET	0
      6  0177				   VAR_BOUNDARY_GenerateAllMoves SET	TEMPORARY_OFFSET
      7  0177				   FUNCTION_NAME SET	GenerateAllMoves
    375  0177					      SUBROUTINE
    376  0177
      0  0177					      REFER	ListPlayerMoves
      1  0177					      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  0177				   TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  0177					      ENDIF
      0  0177					      REFER	aiComputerMove
      1  0177				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  0177				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  0177					      ENDIF
      0  0177					      REFER	quiesce
      1  0177				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  0177				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  0177					      ENDIF
      0  0177					      REFER	negaMax
      1  0177				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0177				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  0177					      ENDIF
    381  0177
      0  0177					      VAR	__vector, 2
      1  0177		       00 b0	   __vector   =	TEMPORARY_VAR
      2  0177				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0177
      4  0177				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0177				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0177				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0177					      ENDIF
      8  0177				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0177				  -	      ECHO	"Temporary Variable", __vector, "overflow!"
     10  0177				  -	      ERR
     11  0177					      ENDIF
     12  0177					      LIST	ON
      0  0177					      VAR	__masker, 2
      1  0177		       00 b2	   __masker   =	TEMPORARY_VAR
      2  0177				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0177
      4  0177				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0177				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0177				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0177					      ENDIF
      8  0177				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0177				  -	      ECHO	"Temporary Variable", __masker, "overflow!"
     10  0177				  -	      ERR
     11  0177					      ENDIF
     12  0177					      LIST	ON
      0  0177					      VAR	__pieceFilter, 1
      1  0177		       00 b4	   __pieceFilter =	TEMPORARY_VAR
      2  0177				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0177
      4  0177				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0177				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0177				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0177					      ENDIF
      8  0177				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0177				  -	      ECHO	"Temporary Variable", __pieceFilter, "overflow!"
     10  0177				  -	      ERR
     11  0177					      ENDIF
     12  0177					      LIST	ON
    385  0177
      0  0177					      VEND	GenerateAllMoves
      1  0177				  -	      IFNCONST	GenerateAllMoves
      2  0177				  -	      ECHO	"Incorrect VEND label", GenerateAllMoves
      3  0177				  -	      ERR
      4  0177					      ENDIF
      5  0177		       00 b5	   VAREND_GenerateAllMoves =	TEMPORARY_VAR
    387  0177
    388  0177							; Do the move generation in two passes - pawns then pieces
    389  0177							; This is an effort to get the alphabeta pruning happening with major pieces handled first in list
    390  0177
    391  0177							;...
    392  0177							; This MUST be called at the start of a new ply
    393  0177							; It initialises the movelist to empty
    394  0177							; x must be preserved
    395  0177
    396  0177		       a5 94		      lda	currentPly
    397  0179		       85 3e		      sta	SET_BANK_RAM	;@2
    398  017b
    399  017b							; note that 'alpha' and 'beta' are set externally!!
    400  017b
    401  017b		       a9 ff		      lda	#-1
      0  017d					      sta@PLY	moveIndex	; no valid moves
      1  017d		       8d d0 fb 	      sta	[RAM]+moveIndex
      0  0180					      sta@PLY	bestMove
      1  0180		       8d d2 fb 	      sta	[RAM]+bestMove
    404  0183
    405  0183		       a5 93		      lda	enPassantPawn	; flag/square from last actual move made
      0  0185					      sta@PLY	enPassantSquare	; used for backtracking, to reset the flag
      1  0185		       8d ca fb 	      sta	[RAM]+enPassantSquare
    407  0188
    408  0188
    409  0188							; The value of the material (signed, 16-bit) is restored to the saved value at the reversion
    410  0188							; of a move. It's quicker to restore than to re-sum. So we save the current evaluation at the
    411  0188							; start of each new ply.
    412  0188
    413  0188		       a5 8f		      lda	Evaluation
      0  018a					      sta@PLY	savedEvaluation
      1  018a		       8d c8 fb 	      sta	[RAM]+savedEvaluation
    415  018d		       a5 90		      lda	Evaluation+1
      0  018f					      sta@PLY	savedEvaluation+1
      1  018f		       8d c9 fb 	      sta	[RAM]+savedEvaluation+1
    417  0192							;^
    418  0192
    419  0192
    420  0192
    421  0192		       a9 08		      lda	#8	; pawns
    422  0194		       85 b4		      sta	__pieceFilter
    423  0196		       20 ab f1 	      jsr	MoveGenX
    424  0199		       a9 63		      lda	#99
    425  019b		       85 92		      sta	currentSquare
    426  019d		       a9 00		      lda	#0
    427  019f		       85 b4		      sta	__pieceFilter
    428  01a1		       20 ab f1 	      jsr	MoveGenX
    429  01a4
    430  01a4		       a9 57		      lda	#BANK_Sort
    431  01a6		       85 3f		      sta	SET_BANK
    432  01a8		       4c 0f f6 	      jmp	Sort	;@1
    433  01ab
    434  01ab
    435  01ab
      0  01ab					      DEF	MoveGenX
      1  01ab				   SLOT_MoveGenX SET	_BANK_SLOT
      2  01ab				   BANK_MoveGenX SET	SLOT_MoveGenX + _CURRENT_BANK
      3  01ab				   MoveGenX
      4  01ab				   TEMPORARY_VAR SET	Overlay
      5  01ab				   TEMPORARY_OFFSET SET	0
      6  01ab				   VAR_BOUNDARY_MoveGenX SET	TEMPORARY_OFFSET
      7  01ab				   FUNCTION_NAME SET	MoveGenX
    437  01ab					      SUBROUTINE
    438  01ab
    439  01ab		       a9 cc		      lda	#RAMBANK_BOARD
    440  01ad		       85 3e		      sta	SET_BANK_RAM	;@3		 ; should be hardwired forever, right?
    441  01af
    442  01af		       a2 64		      ldx	#100
    443  01b1		       d0 02		      bne	.next
    444  01b3
      0  01b3					      DEF	MoveReturn
      1  01b3				   SLOT_MoveReturn SET	_BANK_SLOT
      2  01b3				   BANK_MoveReturn SET	SLOT_MoveReturn + _CURRENT_BANK
      3  01b3				   MoveReturn
      4  01b3				   TEMPORARY_VAR SET	Overlay
      5  01b3				   TEMPORARY_OFFSET SET	0
      6  01b3				   VAR_BOUNDARY_MoveReturn SET	TEMPORARY_OFFSET
      7  01b3				   FUNCTION_NAME SET	MoveReturn
    446  01b3
    447  01b3		       a6 92		      ldx	currentSquare
    448  01b5		       ca	   .next      dex
    449  01b6		       e0 16		      cpx	#22
    450  01b8		       90 30		      bcc	.exit
    451  01ba
    452  01ba		       bd 79 fc 	      lda	Board,x
    453  01bd		       f0 f6		      beq	.next
    454  01bf		       c9 ff		      cmp	#-1
    455  01c1		       f0 f2		      beq	.next
    456  01c3		       45 95		      eor	sideToMove
    457  01c5		       30 ee		      bmi	.next
    458  01c7
    459  01c7		       86 92		      stx	currentSquare
    460  01c9
    461  01c9		       45 95		      eor	sideToMove
    462  01cb		       29 ef		      and	#~FLAG_CASTLE	; todo: better part of the move, mmh?
    463  01cd		       85 91		      sta	currentPiece
    464  01cf		       29 0f		      and	#PIECE_MASK
    465  01d1		       05 b4		      ora	__pieceFilter
    466  01d3		       a8		      tay
    467  01d4
    468  01d4		       a9 58		      lda	#BANK_HandlerVectorLO
    469  01d6		       85 3f		      sta	SET_BANK
    470  01d8
    471  01d8		       b9 10 f4 	      lda	HandlerVectorHI,y
    472  01db		       85 b1		      sta	__vector+1
    473  01dd		       b9 00 f4 	      lda	HandlerVectorLO,y
    474  01e0		       85 b0		      sta	__vector
    475  01e2
    476  01e2		       b9 20 f4 	      lda	HandlerVectorBANK,y
    477  01e5		       85 3f		      sta	SET_BANK	;@1
    478  01e7
    479  01e7		       6c b0 00 	      jmp	(__vector)
    480  01ea
    481  01ea
    482  01ea
    483  01ea		       4c 2e f2    .exit      jmp	fixBank
    484  01ed
    485  01ed
    486  01ed							;---------------------------------------------------------------------------------------------------
    487  01ed
      0  01ed					      DEF	ListPlayerMoves
      1  01ed				   SLOT_ListPlayerMoves SET	_BANK_SLOT
      2  01ed				   BANK_ListPlayerMoves SET	SLOT_ListPlayerMoves + _CURRENT_BANK
      3  01ed				   ListPlayerMoves
      4  01ed				   TEMPORARY_VAR SET	Overlay
      5  01ed				   TEMPORARY_OFFSET SET	0
      6  01ed				   VAR_BOUNDARY_ListPlayerMoves SET	TEMPORARY_OFFSET
      7  01ed				   FUNCTION_NAME SET	ListPlayerMoves
    489  01ed					      SUBROUTINE
    490  01ed
      0  01ed					      REFER	selectmove
      1  01ed					      IF	VAREND_selectmove > TEMPORARY_VAR
      2  01ed				   TEMPORARY_VAR SET	VAREND_selectmove
      3  01ed					      ENDIF
      0  01ed					      REFER	StartupBankReset
      1  01ed				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  01ed				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  01ed					      ENDIF
    493  01ed
      0  01ed					      VEND	ListPlayerMoves
      1  01ed				  -	      IFNCONST	ListPlayerMoves
      2  01ed				  -	      ECHO	"Incorrect VEND label", ListPlayerMoves
      3  01ed				  -	      ERR
      4  01ed					      ENDIF
      5  01ed		       00 b0	   VAREND_ListPlayerMoves =	TEMPORARY_VAR
    495  01ed
    496  01ed
    497  01ed		       a9 00		      lda	#0
    498  01ef		       85 af		      sta	__quiesceCapOnly	; gen ALL moves
    499  01f1
    500  01f1		       a9 89		      lda	#RAMBANK_PLY+1
    501  01f3		       85 94		      sta	currentPly
    502  01f5
    503  01f5							;inc currentPly ;tmp
    504  01f5		       20 77 f1 	      jsr	GenerateAllMoves	;@this
    505  01f8
      0  01f8					      ldx@PLY	moveIndex
      1  01f8		       ae d0 f9 	      ldx	moveIndex
      0  01fb				   .scan      stx@PLY	movePtr
      1  01fb		       8e d1 fb 	      stx	[RAM]+movePtr
    508  01fe
    509  01fe
    510  01fe		       a9 cc		      lda	#RAMBANK_BOARD
    511  0200		       85 3e		      sta	SET_BANK_RAM
    512  0202
      0  0202					      CALL	MakeMove	;@1
      1  0202				  -	      IF	SLOT_MakeMove == _BANK_SLOT
      2  0202				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0202				  -	      ECHO	"Cannot switch bank in use for", MakeMove
      4  0202				  -	      ERR
      5  0202					      ENDIF
      6  0202		       a9 57		      lda	#BANK_MakeMove
      7  0204		       85 3f		      sta	SET_BANK
      8  0206		       20 87 f4 	      jsr	MakeMove
    514  0209
    515  0209		       e6 94		      inc	currentPly
    516  020b		       20 77 f1 	      jsr	GenerateAllMoves	;@this
    517  020e
    518  020e		       c6 94		      dec	currentPly
    519  0210		       a5 94		      lda	currentPly
    520  0212		       85 3e		      sta	SET_BANK_RAM	;@2
    521  0214
    522  0214		       20 5b f2 	      jsr	unmakeMove	;@this
    523  0217
    524  0217		       a5 94		      lda	currentPly
    525  0219		       85 3e		      sta	SET_BANK_RAM	;@2
    526  021b
    527  021b		       a5 a1		      lda	flagCheck
    528  021d		       f0 08		      beq	.next
    529  021f
      0  021f					      ldx@PLY	movePtr
      1  021f		       ae d1 f9 	      ldx	movePtr
    531  0222		       a9 00		      lda	#0
      0  0224					      sta@PLY	MoveFrom,x	; invalidate move (still in check!)
      1  0224		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
    533  0227
      0  0227				   .next      ldx@PLY	movePtr
      1  0227		       ae d1 f9 	      ldx	movePtr
    535  022a		       ca		      dex
    536  022b		       10 ce		      bpl	.scan
    537  022d
    538  022d		       60		      rts
    539  022e
      0  022e					      DEF	fixBank
      1  022e				   SLOT_fixBank SET	_BANK_SLOT
      2  022e				   BANK_fixBank SET	SLOT_fixBank + _CURRENT_BANK
      3  022e				   fixBank
      4  022e				   TEMPORARY_VAR SET	Overlay
      5  022e				   TEMPORARY_OFFSET SET	0
      6  022e				   VAR_BOUNDARY_fixBank SET	TEMPORARY_OFFSET
      7  022e				   FUNCTION_NAME SET	fixBank
    541  022e					      SUBROUTINE
    542  022e
    543  022e		       a9 57		      lda	#BANK_negaMax
    544  0230		       85 3f		      sta	SET_BANK
    545  0232		       60		      rts
    546  0233
    547  0233							;---------------------------------------------------------------------------------------------------
    548  0233
      0  0233					      DEF	AddMove
      1  0233				   SLOT_AddMove SET	_BANK_SLOT
      2  0233				   BANK_AddMove SET	SLOT_AddMove + _CURRENT_BANK
      3  0233				   AddMove
      4  0233				   TEMPORARY_VAR SET	Overlay
      5  0233				   TEMPORARY_OFFSET SET	0
      6  0233				   VAR_BOUNDARY_AddMove SET	TEMPORARY_OFFSET
      7  0233				   FUNCTION_NAME SET	AddMove
    550  0233					      SUBROUTINE
    551  0233
      0  0233					      REFER	Handle_KING
      1  0233					      IF	VAREND_Handle_KING > TEMPORARY_VAR
      2  0233				   TEMPORARY_VAR SET	VAREND_Handle_KING
      3  0233					      ENDIF
      0  0233					      REFER	Handle_QUEEN
      1  0233				  -	      IF	VAREND_Handle_QUEEN > TEMPORARY_VAR
      2  0233				  -TEMPORARY_VAR SET	VAREND_Handle_QUEEN
      3  0233					      ENDIF
      0  0233					      REFER	Handle_ROOK
      1  0233				  -	      IF	VAREND_Handle_ROOK > TEMPORARY_VAR
      2  0233				  -TEMPORARY_VAR SET	VAREND_Handle_ROOK
      3  0233					      ENDIF
      0  0233					      REFER	Handle_BISHOP
      1  0233				  -	      IF	VAREND_Handle_BISHOP > TEMPORARY_VAR
      2  0233				  -TEMPORARY_VAR SET	VAREND_Handle_BISHOP
      3  0233					      ENDIF
      0  0233					      REFER	Handle_KNIGHT
      1  0233				  -	      IF	VAREND_Handle_KNIGHT > TEMPORARY_VAR
      2  0233				  -TEMPORARY_VAR SET	VAREND_Handle_KNIGHT
      3  0233					      ENDIF
      0  0233					      REFER	Handle_WHITE_PAWN
      1  0233				  -	      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  0233				  -TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  0233					      ENDIF
      0  0233					      REFER	Handle_BLACK_PAWN
      1  0233				  -	      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  0233				  -TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  0233					      ENDIF
    559  0233
      0  0233					      VEND	AddMove
      1  0233				  -	      IFNCONST	AddMove
      2  0233				  -	      ECHO	"Incorrect VEND label", AddMove
      3  0233				  -	      ERR
      4  0233					      ENDIF
      5  0233		       00 b5	   VAREND_AddMove =	TEMPORARY_VAR
    561  0233
    562  0233							; add square in y register to movelist as destination (X12 format)
    563  0233							; [y]		     to square (X12)
    564  0233							; currentSquare     from square (X12)
    565  0233							; currentPiece      piece.
    566  0233							;   ENPASSANT flag set if pawn double-moving off opening rank
    567  0233							; capture	     captured piece
    568  0233
    569  0233
    570  0233		       a5 9d		      lda	capture
    571  0235		       d0 04		      bne	.always
    572  0237		       a5 af		      lda	__quiesceCapOnly
    573  0239		       d0 1c		      bne	.abort
    574  023b
    575  023b		       98	   .always    tya
    576  023c		       aa		      tax
    577  023d
      0  023d					      ldy@PLY	moveIndex
      1  023d		       ac d0 f9 	      ldy	moveIndex
    579  0240		       c8		      iny
      0  0241					      sty@PLY	moveIndex
      1  0241		       8c d0 fb 	      sty	[RAM]+moveIndex
    581  0244
      0  0244					      sta@PLY	MoveTo,y
      1  0244		       99 64 fa 	      sta	[RAM]+MoveTo,y
    583  0247		       a5 92		      lda	currentSquare
      0  0249					      sta@PLY	MoveFrom,y
      1  0249		       99 00 fa 	      sta	[RAM]+MoveFrom,y
    585  024c		       a5 91		      lda	currentPiece
      0  024e					      sta@PLY	MovePiece,y
      1  024e		       99 00 fb 	      sta	[RAM]+MovePiece,y
    587  0251		       a5 9d		      lda	capture
      0  0253					      sta@PLY	MoveCapture,y
      1  0253		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    589  0256		       60		      rts
    590  0257
    591  0257		       98	   .abort     tya
    592  0258		       aa		      tax
    593  0259		       60		      rts
    594  025a
    595  025a
    596  025a
    597  025a							;---------------------------------------------------------------------------------------------------
    598  025a
      0  025a					      DEF	debug
      1  025a				   SLOT_debug SET	_BANK_SLOT
      2  025a				   BANK_debug SET	SLOT_debug + _CURRENT_BANK
      3  025a				   debug
      4  025a				   TEMPORARY_VAR SET	Overlay
      5  025a				   TEMPORARY_OFFSET SET	0
      6  025a				   VAR_BOUNDARY_debug SET	TEMPORARY_OFFSET
      7  025a				   FUNCTION_NAME SET	debug
    600  025a					      SUBROUTINE
    601  025a		       60		      rts
    602  025b
    603  025b
    604  025b							;---------------------------------------------------------------------------------------------------
    605  025b
      0  025b					      DEF	unmakeMove
      1  025b				   SLOT_unmakeMove SET	_BANK_SLOT
      2  025b				   BANK_unmakeMove SET	SLOT_unmakeMove + _CURRENT_BANK
      3  025b				   unmakeMove
      4  025b				   TEMPORARY_VAR SET	Overlay
      5  025b				   TEMPORARY_OFFSET SET	0
      6  025b				   VAR_BOUNDARY_unmakeMove SET	TEMPORARY_OFFSET
      7  025b				   FUNCTION_NAME SET	unmakeMove
    607  025b					      SUBROUTINE
    608  025b
      0  025b					      REFER	selectmove
      1  025b					      IF	VAREND_selectmove > TEMPORARY_VAR
      2  025b				   TEMPORARY_VAR SET	VAREND_selectmove
      3  025b					      ENDIF
      0  025b					      REFER	ListPlayerMoves
      1  025b				  -	      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  025b				  -TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  025b					      ENDIF
      0  025b					      REFER	quiesce
      1  025b				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  025b				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  025b					      ENDIF
      0  025b					      REFER	negaMax
      1  025b				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  025b				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  025b					      ENDIF
    613  025b
      0  025b					      VAR	__unmake_capture, 1
      1  025b		       00 b0	   __unmake_capture =	TEMPORARY_VAR
      2  025b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  025b
      4  025b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  025b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  025b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  025b					      ENDIF
      8  025b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  025b				  -	      ECHO	"Temporary Variable", __unmake_capture, "overflow!"
     10  025b				  -	      ERR
     11  025b					      ENDIF
     12  025b					      LIST	ON
      0  025b					      VAR	__secondaryBlank, 1
      1  025b		       00 b1	   __secondaryBlank =	TEMPORARY_VAR
      2  025b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  025b
      4  025b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  025b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  025b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  025b					      ENDIF
      8  025b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  025b				  -	      ECHO	"Temporary Variable", __secondaryBlank, "overflow!"
     10  025b				  -	      ERR
     11  025b					      ENDIF
     12  025b					      LIST	ON
    616  025b
      0  025b					      VEND	unmakeMove
      1  025b				  -	      IFNCONST	unmakeMove
      2  025b				  -	      ECHO	"Incorrect VEND label", unmakeMove
      3  025b				  -	      ERR
      4  025b					      ENDIF
      5  025b		       00 b2	   VAREND_unmakeMove =	TEMPORARY_VAR
    618  025b
    619  025b							; restore the board evaluation to what it was at the start of this ply
    620  025b							; TODO: note: moved flag seems wrong on restoration
    621  025b
    622  025b		       a5 94		      lda	currentPly
    623  025d		       85 3e		      sta	SET_BANK_RAM	;@2
    624  025f
      0  025f					      lda@PLY	savedEvaluation
      1  025f		       ad c8 f9 	      lda	savedEvaluation
    626  0262		       85 8f		      sta	Evaluation
      0  0264					      lda@PLY	savedEvaluation+1
      1  0264		       ad c9 f9 	      lda	savedEvaluation+1
    628  0267		       85 90		      sta	Evaluation+1
    629  0269
    630  0269		       ae d1 f9 	      ldx	movePtr
      0  026c					      lda@PLY	MoveFrom,x
      1  026c		       bd 00 f8 	      lda	MoveFrom,x
    632  026f		       85 85		      sta	fromX12
      0  0271					      ldy@PLY	MoveTo,x
      1  0271		       bc 64 f8 	      ldy	MoveTo,x
    634  0274
      0  0274					      lda@PLY	restorePiece
      1  0274		       ad da f9 	      lda	restorePiece
    636  0277		       48		      pha
      0  0278					      lda@PLY	capturedPiece
      1  0278		       ad cb f9 	      lda	capturedPiece
    638  027b
    639  027b		       a2 cc		      ldx	#RAMBANK_BOARD
    640  027d		       86 3e		      stx	SET_BANK_RAM	;@3
      0  027f					      sta@RAM	Board,y
      1  027f		       99 79 fe 	      sta	[RAM]+Board,y
    642  0282		       a4 85		      ldy	fromX12
    643  0284		       68		      pla
      0  0285					      sta@RAM	Board,y
      1  0285		       99 79 fe 	      sta	[RAM]+Board,y
    645  0288
    646  0288
    647  0288							;lda currentPly
    648  0288							;sta SET_BANK_RAM
    649  0288
    650  0288							; See if there are any 'secondary' pieces that moved
    651  0288							; here we're dealing with reverting a castling or enPassant move
    652  0288
      0  0288					      lda@PLY	secondaryPiece
      1  0288		       ad cd f9 	      lda	secondaryPiece
    654  028b		       f0 12		      beq	.noSecondary
      0  028d					      ldy@PLY	secondaryBlank
      1  028d		       ac cf f9 	      ldy	secondaryBlank
    656  0290		       84 b1		      sty	__secondaryBlank
      0  0292					      ldy@PLY	secondarySquare
      1  0292		       ac ce f9 	      ldy	secondarySquare
      0  0295					      sta@RAM	Board,y	; put piece back
      1  0295		       99 79 fe 	      sta	[RAM]+Board,y
    659  0298
    660  0298		       a4 b1		      ldy	__secondaryBlank
    661  029a		       a9 00		      lda	#0
      0  029c					      sta@RAM	Board,y	; blank piece origin
      1  029c		       99 79 fe 	      sta	[RAM]+Board,y
    663  029f
    664  029f
    665  029f				   .noSecondary
    666  029f							;NEGEVAL
      0  029f					      SWAP
      1  029f		       a5 95		      lda	sideToMove
      2  02a1		       49 80		      eor	#SWAP_SIDE
      3  02a3		       85 95		      sta	sideToMove
      4  02a5
      5  02a5
    668  02a5		       60		      rts
    669  02a6
    670  02a6
    671  02a6							;---------------------------------------------------------------------------------------------------
    672  02a6
      0  02a6					      DEF	showMoveCaptures
      1  02a6				   SLOT_showMoveCaptures SET	_BANK_SLOT
      2  02a6				   BANK_showMoveCaptures SET	SLOT_showMoveCaptures + _CURRENT_BANK
      3  02a6				   showMoveCaptures
      4  02a6				   TEMPORARY_VAR SET	Overlay
      5  02a6				   TEMPORARY_OFFSET SET	0
      6  02a6				   VAR_BOUNDARY_showMoveCaptures SET	TEMPORARY_OFFSET
      7  02a6				   FUNCTION_NAME SET	showMoveCaptures
    674  02a6					      SUBROUTINE
    675  02a6
      0  02a6					      REFER	aiShowMoveCaptures
      1  02a6				  -	      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  02a6				  -TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  02a6					      ENDIF
    677  02a6
      0  02a6					      VAR	__toSquareX12, 1
      1  02a6		       00 a4	   __toSquareX12 =	TEMPORARY_VAR
      2  02a6				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  02a6
      4  02a6				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  02a6				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  02a6				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  02a6					      ENDIF
      8  02a6				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  02a6				  -	      ECHO	"Temporary Variable", __toSquareX12, "overflow!"
     10  02a6				  -	      ERR
     11  02a6					      ENDIF
     12  02a6					      LIST	ON
      0  02a6					      VAR	__fromPiece, 1
      1  02a6		       00 a5	   __fromPiece =	TEMPORARY_VAR
      2  02a6				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  02a6
      4  02a6				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  02a6				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  02a6				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  02a6					      ENDIF
      8  02a6				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  02a6				  -	      ECHO	"Temporary Variable", __fromPiece, "overflow!"
     10  02a6				  -	      ERR
     11  02a6					      ENDIF
     12  02a6					      LIST	ON
      0  02a6					      VAR	__aiMoveIndex, 1
      1  02a6		       00 a6	   __aiMoveIndex =	TEMPORARY_VAR
      2  02a6				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  02a6
      4  02a6				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  02a6				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  02a6				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  02a6					      ENDIF
      8  02a6				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  02a6				  -	      ECHO	"Temporary Variable", __aiMoveIndex, "overflow!"
     10  02a6				  -	      ERR
     11  02a6					      ENDIF
     12  02a6					      LIST	ON
    681  02a6
      0  02a6					      VEND	showMoveCaptures
      1  02a6				  -	      IFNCONST	showMoveCaptures
      2  02a6				  -	      ECHO	"Incorrect VEND label", showMoveCaptures
      3  02a6				  -	      ERR
      4  02a6					      ENDIF
      5  02a6		       00 a7	   VAREND_showMoveCaptures =	TEMPORARY_VAR
    683  02a6
    684  02a6							; place a marker on the board for any square matching the piece
    685  02a6							; EXCEPT for squares which are occupied (we'll flash those later)
    686  02a6							; x = movelist item # being checked
    687  02a6
    688  02a6
    689  02a6		       a6 8d	   .next      ldx	aiMoveIndex
    690  02a8		       86 a6		      stx	__aiMoveIndex
    691  02aa		       30 4a		      bmi	.skip	; no moves in list
    692  02ac
    693  02ac		       ad 84 02 	      lda	INTIM
    694  02af		       c9 14		      cmp	#20
    695  02b1		       90 43		      bcc	.skip
    696  02b3
    697  02b3		       c6 8d		      dec	aiMoveIndex
    698  02b5
    699  02b5		       a9 89		      lda	#RAMBANK_PLY+1
    700  02b7		       85 3e		      sta	SET_BANK_RAM
      0  02b9					      lda@PLY	MoveFrom,x
      1  02b9		       bd 00 f8 	      lda	MoveFrom,x
    702  02bc		       c5 85		      cmp	fromX12
    703  02be		       d0 e6		      bne	.next
    704  02c0
      0  02c0					      lda@PLY	MoveTo,x
      1  02c0		       bd 64 f8 	      lda	MoveTo,x
    706  02c3		       85 a4		      sta	__toSquareX12
    707  02c5		       a8		      tay
    708  02c6
    709  02c6		       a9 cc		      lda	#RAMBANK_BOARD
    710  02c8		       85 3e		      sta	SET_BANK_RAM	;@3
    711  02ca		       b9 79 fc 	      lda	Board,y
    712  02cd		       29 0f		      and	#PIECE_MASK
    713  02cf		       f0 d5		      beq	.next
    714  02d1
    715  02d1							; There's something on the board at destination, so it's a capture
    716  02d1							; Let's see if we are doing a pawn promote...
    717  02d1
    718  02d1		       a4 85		      ldy	fromX12
    719  02d3
    720  02d3		       a9 cc		      lda	#RAMBANK_BOARD
    721  02d5		       85 3e		      sta	SET_BANK_RAM	;@3
    722  02d7		       b9 79 fc 	      lda	Board,y
    723  02da		       85 a5		      sta	__fromPiece
    724  02dc
    725  02dc		       a9 89		      lda	#RAMBANK_PLY+1
    726  02de		       85 3e		      sta	SET_BANK_RAM
      0  02e0					      lda@PLY	MovePiece,x
      1  02e0		       bd 00 f9 	      lda	MovePiece,x
    728  02e3		       45 a5		      eor	__fromPiece
    729  02e5		       29 0f		      and	#PIECE_MASK
    730  02e7		       f0 06		      beq	.legit	; from == to, so not a promote
    731  02e9
    732  02e9							; Have detected a promotion duplicate - skip all 3 of them
    733  02e9
    734  02e9		       c6 8d		      dec	aiMoveIndex	; skip "KBRQ" promotes
    735  02eb		       c6 8d		      dec	aiMoveIndex
    736  02ed		       c6 8d		      dec	aiMoveIndex
    737  02ef
    738  02ef				   .legit
    739  02ef
    740  02ef							;TIMECHECK COPYSINGLEPIECE, restoreIndex     ; not enough time to draw
    741  02ef
    742  02ef		       a5 a4		      lda	__toSquareX12
    743  02f1		       85 80		      sta	squareToDraw
    744  02f3
    745  02f3		       20 ad f0 	      jsr	CopySinglePiece	;@0
    746  02f6
    747  02f6		       60	   .skip      rts
    748  02f7
    749  02f7
    750  02f7							;---------------------------------------------------------------------------------------------------
    751  02f7
      0  02f7					      DEF	CopyPieceToRowBitmap	;@3
      1  02f7				   SLOT_CopyPieceToRowBitmap SET	_BANK_SLOT
      2  02f7				   BANK_CopyPieceToRowBitmap SET	SLOT_CopyPieceToRowBitmap + _CURRENT_BANK
      3  02f7				   CopyPieceToRowBitmap
      4  02f7				   TEMPORARY_VAR SET	Overlay
      5  02f7				   TEMPORARY_OFFSET SET	0
      6  02f7				   VAR_BOUNDARY_CopyPieceToRowBitmap SET	TEMPORARY_OFFSET
      7  02f7				   FUNCTION_NAME SET	CopyPieceToRowBitmap
    753  02f7					      SUBROUTINE
    754  02f7
      0  02f7					      REFER	InterceptMarkerCopy
      1  02f7					      IF	VAREND_InterceptMarkerCopy > TEMPORARY_VAR
      2  02f7				   TEMPORARY_VAR SET	VAREND_InterceptMarkerCopy
      3  02f7					      ENDIF
      0  02f7					      VEND	CopyPieceToRowBitmap
      1  02f7				  -	      IFNCONST	CopyPieceToRowBitmap
      2  02f7				  -	      ECHO	"Incorrect VEND label", CopyPieceToRowBitmap
      3  02f7				  -	      ERR
      4  02f7					      ENDIF
      5  02f7		       00 a7	   VAREND_CopyPieceToRowBitmap =	TEMPORARY_VAR
    757  02f7
    758  02f7		       a0 11		      ldy	#17
    759  02f9		       b0 30		      bcs	.rightSide
    760  02fb
    761  02fb		       b9 a4 00    .copyPiece lda	__pieceShapeBuffer,y
    762  02fe		       f0 06		      beq	.blank1
    763  0300		       59 00 f8 	      eor	ChessBitmap,y
      0  0303					      sta@RAM	ChessBitmap,y
      1  0303		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
    765  0306
    766  0306		       b9 b6 00    .blank1    lda	__pieceShapeBuffer+18,y
    767  0309		       f0 06		      beq	.blank2
    768  030b		       59 12 f8 	      eor	ChessBitmap+18,y
      0  030e					      sta@RAM	ChessBitmap+18,y
      1  030e		       99 12 fa 	      sta	[RAM]+ChessBitmap+18,y
    770  0311
    771  0311		       b9 c8 00    .blank2    lda	__pieceShapeBuffer+36,y
    772  0314		       f0 06		      beq	.blank3
    773  0316		       59 24 f8 	      eor	ChessBitmap+36,y
      0  0319					      sta@RAM	ChessBitmap+36,y
      1  0319		       99 24 fa 	      sta	[RAM]+ChessBitmap+36,y
    775  031c
    776  031c		       b9 da 00    .blank3    lda	__pieceShapeBuffer+54,y
    777  031f		       f0 06		      beq	.blank4
    778  0321		       59 36 f8 	      eor	ChessBitmap+54,y
      0  0324					      sta@RAM	ChessBitmap+54,y
      1  0324		       99 36 fa 	      sta	[RAM]+ChessBitmap+54,y
    780  0327
    781  0327		       88	   .blank4    dey
    782  0328		       10 d1		      bpl	.copyPiece
    783  032a		       60		      rts
    784  032b
    785  032b				   .rightSide
    786  032b
    787  032b					      SUBROUTINE
    788  032b
    789  032b		       b9 a4 00    .copyPieceR lda	__pieceShapeBuffer,y
    790  032e		       f0 06		      beq	.blank1
    791  0330		       59 48 f8 	      eor	ChessBitmap+72,y
      0  0333					      sta@RAM	ChessBitmap+72,y
      1  0333		       99 48 fa 	      sta	[RAM]+ChessBitmap+72,y
    793  0336
    794  0336		       b9 b6 00    .blank1    lda	__pieceShapeBuffer+18,y
    795  0339		       f0 06		      beq	.blank2
    796  033b		       59 5a f8 	      eor	ChessBitmap+72+18,y
      0  033e					      sta@RAM	ChessBitmap+72+18,y
      1  033e		       99 5a fa 	      sta	[RAM]+ChessBitmap+72+18,y
    798  0341
    799  0341		       b9 c8 00    .blank2    lda	__pieceShapeBuffer+36,y
    800  0344		       f0 06		      beq	.blank3
    801  0346		       59 6c f8 	      eor	ChessBitmap+72+36,y
      0  0349					      sta@RAM	ChessBitmap+72+36,y
      1  0349		       99 6c fa 	      sta	[RAM]+ChessBitmap+72+36,y
    803  034c
    804  034c		       b9 da 00    .blank3    lda	__pieceShapeBuffer+54,y
    805  034f		       f0 06		      beq	.blank4
    806  0351		       59 7e f8 	      eor	ChessBitmap+72+54,y
      0  0354					      sta@RAM	ChessBitmap+72+54,y
      1  0354		       99 7e fa 	      sta	[RAM]+ChessBitmap+72+54,y
    808  0357
    809  0357		       88	   .blank4    dey
    810  0358		       10 d1		      bpl	.copyPieceR
    811  035a		       60		      rts
    812  035b
    813  035b							;---------------------------------------------------------------------------------------------------
    814  035b
 FREE BYTES IN STARTUP BANK =  $a1
    815  035b					      ECHO	"FREE BYTES IN STARTUP BANK = ", $F3FC - *
    816  035b
    817  035b							;---------------------------------------------------------------------------------------------------
    818  035b							; The reset vectors
    819  035b							; these must live in the first 1K bank of the ROM
    820  035b
    821  0400 ????				      SEG	StartupInterruptVectors
    822  03fc					      ORG	_FIRST_BANK + $3FC
    823  03fc
    824  03fc		       00 f0		      .word.w	StartupBankReset	; RESET
    825  03fe		       00 f0		      .word.w	StartupBankReset	; IRQ	      (not used)
    826  0400
    827  0400							;---------------------------------------------------------------------------------------------------
    828  0400
    829  0400
    830  0400							; EOF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@1#1.asm LEVEL 2 PASS 4
      0  0400					      include	"BANK_GENERIC@1#1.asm"
      1  0400							; Chess
      2  0400							; Copyright (c) 2019-2020 Andrew Davie
      3  0400							; andrew@taswegian.com
      4  0400
      0  0400					      SLOT	1	; which bank this code switches to
      1  0400				  -	      IF	(1 < 0) || (1 > 3)
      2  0400				  -	      ECHO	"Illegal bank address/segment location", 1
      3  0400				  -	      ERR
      4  0400					      ENDIF
      5  0400				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  0400				   _BANK_SLOT SET	1 * 64
      0  0400					      NEWBANK	ONE
      1  05ec ????				      SEG	ONE
      2  0400					      ORG	_ORIGIN
      3  0400					      RORG	_BANK_ADDRESS_ORIGIN
      4  0400				   _BANK_START SET	*
      5  0400				   ONE_START  SET	*
      6  0400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0400				   ONE	      SET	_BANK_SLOT + _CURRENT_BANK
      8  0400				   _ORIGIN    SET	_ORIGIN + 1024
      7  0400
      8  0400
      9  0400							;---------------------------------------------------------------------------------------------------
     10  0400							; ... the above is a (potentially) RAM-copied section -- the following is ROM-only.  Note that
     11  0400							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     12  0400							; bank finishes.  Just continue on from where it left off...
     13  0400							;---------------------------------------------------------------------------------------------------
     14  0400
      0  0400					      DEF	CartInit
      1  0400				   SLOT_CartInit SET	_BANK_SLOT
      2  0400				   BANK_CartInit SET	SLOT_CartInit + _CURRENT_BANK
      3  0400				   CartInit
      4  0400				   TEMPORARY_VAR SET	Overlay
      5  0400				   TEMPORARY_OFFSET SET	0
      6  0400				   VAR_BOUNDARY_CartInit SET	TEMPORARY_OFFSET
      7  0400				   FUNCTION_NAME SET	CartInit
     16  0400					      SUBROUTINE
     17  0400
      0  0400					      REFER	StartupBankReset
      1  0400				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0400				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0400					      ENDIF
      0  0400					      VEND	CartInit
      1  0400				  -	      IFNCONST	CartInit
      2  0400				  -	      ECHO	"Incorrect VEND label", CartInit
      3  0400				  -	      ERR
      4  0400					      ENDIF
      5  0400		       00 a4	   VAREND_CartInit =	TEMPORARY_VAR
     20  0400
     21  0400		       78		      sei
     22  0401		       d8		      cld
     23  0402							; See if we can come up with something 'random' for startup
     24  0402
     25  0402		       ac 84 02 	      ldy	INTIM
     26  0405		       d0 02		      bne	.toR
     27  0407		       a0 9a		      ldy	#$9A
     28  0409		       84 81	   .toR       sty	rnd
     29  040b
     30  040b		       a9 ff		      lda	#255
     31  040d		       85 a3		      sta	randomness
     32  040f
     33  040f		       a9 00		      lda	#0
     34  0411		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     35  0414		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     36  0417		       85 6b		      sta	HMCLR
     37  0419
     38  0419							; cleanup remains of title screen
     39  0419		       85 5b		      sta	GRP0
     40  041b		       85 5c		      sta	GRP1
     41  041d
     42  041d		       a9 10		      lda	#%00010000	; double width missile, double width player
     43  041f		       85 44		      sta	NUSIZ0
     44  0421		       85 45		      sta	NUSIZ1
     45  0423
     46  0423		       a9 04		      lda	#%100	; players/missiles BEHIND BG
     47  0425		       85 4a		      sta	CTRLPF
     48  0427		       a9 07		      lda	#%111
     49  0429		       85 44		      sta	NUSIZ0
     50  042b		       85 45		      sta	NUSIZ1	; quad-width
     51  042d
     52  042d		       a9 04		      lda	#%00000100
     53  042f		       85 4a		      sta	CTRLPF
     54  0431		       a9 00		      lda	#BACKGCOL
     55  0433		       85 49		      sta	COLUBK
     56  0435
     57  0435
     58  0435		       a9 00		      lda	#WHITE	;tmp+RAMBANK_PLY
     59  0437		       85 95		      sta	sideToMove
     60  0439
     61  0439		       60		      rts
     62  043a
     63  043a
     64  043a							;---------------------------------------------------------------------------------------------------
     65  043a
      0  043a					      DEF	SetupBanks
      1  043a				   SLOT_SetupBanks SET	_BANK_SLOT
      2  043a				   BANK_SetupBanks SET	SLOT_SetupBanks + _CURRENT_BANK
      3  043a				   SetupBanks
      4  043a				   TEMPORARY_VAR SET	Overlay
      5  043a				   TEMPORARY_OFFSET SET	0
      6  043a				   VAR_BOUNDARY_SetupBanks SET	TEMPORARY_OFFSET
      7  043a				   FUNCTION_NAME SET	SetupBanks
     67  043a					      SUBROUTINE
     68  043a
     69  043a							; Move a copy of the row bank template to the first 8 banks of RAM
     70  043a							; and then terminate the draw subroutine by substituting in a RTS on the last one
     71  043a
      0  043a					      REFER	StartupBankReset
      1  043a				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  043a				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  043a					      ENDIF
      0  043a					      VAR	__plyBank, 1
      1  043a		       00 a4	   __plyBank  =	TEMPORARY_VAR
      2  043a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  043a
      4  043a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  043a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  043a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  043a					      ENDIF
      8  043a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  043a				  -	      ECHO	"Temporary Variable", __plyBank, "overflow!"
     10  043a				  -	      ERR
     11  043a					      ENDIF
     12  043a					      LIST	ON
      0  043a					      VEND	SetupBanks
      1  043a				  -	      IFNCONST	SetupBanks
      2  043a				  -	      ECHO	"Incorrect VEND label", SetupBanks
      3  043a				  -	      ERR
      4  043a					      ENDIF
      5  043a		       00 a5	   VAREND_SetupBanks =	TEMPORARY_VAR
     75  043a
     76  043a							; Copy the bitmap shadow into the first 8 RAM banks via x(SLOT3)-->y(SLOT2)
     77  043a
     78  043a				   .ROWBANK   SET	0
     79  043a					      REPEAT	8
     80  043a		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  043c		       a0 c0		      ldy	#[SLOT3] + .ROWBANK
     82  043e		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     83  043e				   .ROWBANK   SET	.ROWBANK+1
     79  043e					      REPEND
     80  0441		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  0443		       a0 c1		      ldy	#[SLOT3] + .ROWBANK
     82  0445		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     83  0445				   .ROWBANK   SET	.ROWBANK+1
     79  0445					      REPEND
     80  0448		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  044a		       a0 c2		      ldy	#[SLOT3] + .ROWBANK
     82  044c		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     83  044c				   .ROWBANK   SET	.ROWBANK+1
     79  044c					      REPEND
     80  044f		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  0451		       a0 c3		      ldy	#[SLOT3] + .ROWBANK
     82  0453		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     83  0453				   .ROWBANK   SET	.ROWBANK+1
     79  0453					      REPEND
     80  0456		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  0458		       a0 c4		      ldy	#[SLOT3] + .ROWBANK
     82  045a		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     83  045a				   .ROWBANK   SET	.ROWBANK+1
     79  045a					      REPEND
     80  045d		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  045f		       a0 c5		      ldy	#[SLOT3] + .ROWBANK
     82  0461		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     83  0461				   .ROWBANK   SET	.ROWBANK+1
     79  0461					      REPEND
     80  0464		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  0466		       a0 c6		      ldy	#[SLOT3] + .ROWBANK
     82  0468		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     83  0468				   .ROWBANK   SET	.ROWBANK+1
     79  0468					      REPEND
     80  046b		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     81  046d		       a0 c7		      ldy	#[SLOT3] + .ROWBANK
     82  046f		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     83  046f				   .ROWBANK   SET	.ROWBANK+1
     84  0472					      REPEND
     85  0472
     86  0472
     87  0472							; Patch the final row's "loop" to a RTS
     88  0472
     89  0472		       a2 87		      ldx	#[SLOT2] + 7	; last ROW BITMAP bank
     90  0474		       86 3e		      stx	SET_BANK_RAM
     91  0476		       a9 60		      lda	#$60	; "rts"
      0  0478					      sta@RAM	SELFMOD_RTS_ON_LAST_ROW
      1  0478		       8d 00 fb 	      sta	[RAM]+SELFMOD_RTS_ON_LAST_ROW
     93  047b
     94  047b
     95  047b
     96  047b							; copy the BOARD/MOVES bank
     97  047b
     98  047b		       a2 84		      ldx	#SHADOW_BOARD
     99  047d		       a0 cc		      ldy	#RAMBANK_BOARD
    100  047f		       20 83 f4 	      jsr	CopyShadowROMtoRAM	; this auto-initialises Board too
    101  0482
    102  0482
    103  0482							; copy the PLY banks
    104  0482							; If there's no content (only variable decs) then we don't really need to do this.
    105  0482
    106  0482							;.PLY SET 0
    107  0482							;    REPEAT PLY_BANKS
    108  0482
    109  0482							;		      ldx #SHADOW_PLY
    110  0482							;		      ldy #RAMBANK_PLY + .PLY
    111  0482							;jsr CopyShadowROMtoRAM
    112  0482							;.PLY SET .PLY + 1
    113  0482							;    REPEND
    114  0482
    115  0482							; copy the evaluation code/tables
    116  0482							; 3E+ moved from RAM to ROM
    117  0482
    118  0482							;		      ldx #[SLOT2] + SHADOW_EVAL
    119  0482							;		      ldy #[SLOT3] + EVAL
    120  0482							;		      jsr CopyShadowROMtoRAM
    121  0482
    122  0482
    123  0482							;		      ldy #RAMBANK_RAM_PIECELIST
    124  0482							;		      ldx #ROM_PIECELIST
    125  0482							;		      jsr CopyShadowROMtoRAM
    126  0482
    127  0482		       60		      rts
    128  0483
    129  0483
    130  0483							;---------------------------------------------------------------------------------------------------
    131  0483
      0  0483					      DEF	CopyShadowROMtoRAM
      1  0483				   SLOT_CopyShadowROMtoRAM SET	_BANK_SLOT
      2  0483				   BANK_CopyShadowROMtoRAM SET	SLOT_CopyShadowROMtoRAM + _CURRENT_BANK
      3  0483				   CopyShadowROMtoRAM
      4  0483				   TEMPORARY_VAR SET	Overlay
      5  0483				   TEMPORARY_OFFSET SET	0
      6  0483				   VAR_BOUNDARY_CopyShadowROMtoRAM SET	TEMPORARY_OFFSET
      7  0483				   FUNCTION_NAME SET	CopyShadowROMtoRAM
    133  0483					      SUBROUTINE
    134  0483
      0  0483					      REFER	SetupBanks
      1  0483					      IF	VAREND_SetupBanks > TEMPORARY_VAR
      2  0483				   TEMPORARY_VAR SET	VAREND_SetupBanks
      3  0483					      ENDIF
      0  0483					      VEND	CopyShadowROMtoRAM
      1  0483				  -	      IFNCONST	CopyShadowROMtoRAM
      2  0483				  -	      ECHO	"Incorrect VEND label", CopyShadowROMtoRAM
      3  0483				  -	      ERR
      4  0483					      ENDIF
      5  0483		       00 a5	   VAREND_CopyShadowROMtoRAM =	TEMPORARY_VAR
    137  0483
    138  0483							; Copy a whole ROM SHADOW into a destination RAM 512 byte bank
    139  0483							; used to setup callable RAM code from ROM templates
    140  0483
    141  0483							; x = source ROM bank
    142  0483							; y = destination RAM bank (preserved)
    143  0483
    144  0483		       86 3f		      stx	SET_BANK
    145  0485		       84 3e		      sty	SET_BANK_RAM
    146  0487
    147  0487		       a2 00		      ldx	#0
    148  0489		       bd 00 f8    .copyPage  lda	$F800,x
      0  048c					      sta@RAM	$FC00,x
      1  048c		       9d 00 fe 	      sta	[RAM]+$FC00,x
    150  048f		       bd 00 f9 	      lda	$F900,x
      0  0492					      sta@RAM	$FD00,x
      1  0492		       9d 00 ff 	      sta	[RAM]+$FD00,x
    152  0495		       ca		      dex
    153  0496		       d0 f1		      bne	.copyPage
    154  0498		       60		      rts
    155  0499
    156  0499
    157  0499							;---------------------------------------------------------------------------------------------------
    158  0499
      0  0499					      DEF	CallClear
      1  0499				   SLOT_CallClear SET	_BANK_SLOT
      2  0499				   BANK_CallClear SET	SLOT_CallClear + _CURRENT_BANK
      3  0499				   CallClear
      4  0499				   TEMPORARY_VAR SET	Overlay
      5  0499				   TEMPORARY_OFFSET SET	0
      6  0499				   VAR_BOUNDARY_CallClear SET	TEMPORARY_OFFSET
      7  0499				   FUNCTION_NAME SET	CallClear
    160  0499					      SUBROUTINE
    161  0499
    162  0499				  -	      IF	0
    163  0499				  -	      REFER	aiClearEachRow
    164  0499					      ENDIF
      0  0499					      VEND	CallClear
      1  0499				  -	      IFNCONST	CallClear
      2  0499				  -	      ECHO	"Incorrect VEND label", CallClear
      3  0499				  -	      ERR
      4  0499					      ENDIF
      5  0499		       00 a4	   VAREND_CallClear =	TEMPORARY_VAR
    166  0499
    167  0499				  -	      IF	0
    168  0499				  -			; No transient variable dependencies/calls
    169  0499				  -
    170  0499				  -	      sty	SET_BANK_RAM
    171  0499				  -	      jsr	ClearRowBitmap
    172  0499					      ENDIF
    173  0499		       60		      rts
    174  049a
    175  049a
    176  049a							;---------------------------------------------------------------------------------------------------
    177  049a
      0  049a					      DEF	InitialisePieceSquares
      1  049a				   SLOT_InitialisePieceSquares SET	_BANK_SLOT
      2  049a				   BANK_InitialisePieceSquares SET	SLOT_InitialisePieceSquares + _CURRENT_BANK
      3  049a				   InitialisePieceSquares
      4  049a				   TEMPORARY_VAR SET	Overlay
      5  049a				   TEMPORARY_OFFSET SET	0
      6  049a				   VAR_BOUNDARY_InitialisePieceSquares SET	TEMPORARY_OFFSET
      7  049a				   FUNCTION_NAME SET	InitialisePieceSquares
    179  049a					      SUBROUTINE
    180  049a
      0  049a					      REFER	StartupBankReset
      1  049a				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  049a				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  049a					      ENDIF
      0  049a					      VAR	__initPiece, 1
      1  049a		       00 a4	   __initPiece =	TEMPORARY_VAR
      2  049a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  049a
      4  049a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  049a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  049a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  049a					      ENDIF
      8  049a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  049a				  -	      ECHO	"Temporary Variable", __initPiece, "overflow!"
     10  049a				  -	      ERR
     11  049a					      ENDIF
     12  049a					      LIST	ON
      0  049a					      VAR	__initSquare, 1
      1  049a		       00 a5	   __initSquare =	TEMPORARY_VAR
      2  049a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  049a
      4  049a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  049a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  049a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  049a					      ENDIF
      8  049a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  049a				  -	      ECHO	"Temporary Variable", __initSquare, "overflow!"
     10  049a				  -	      ERR
     11  049a					      ENDIF
     12  049a					      LIST	ON
      0  049a					      VAR	__initListPtr, 1
      1  049a		       00 a6	   __initListPtr =	TEMPORARY_VAR
      2  049a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  049a
      4  049a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  049a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  049a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  049a					      ENDIF
      8  049a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  049a				  -	      ECHO	"Temporary Variable", __initListPtr, "overflow!"
     10  049a				  -	      ERR
     11  049a					      ENDIF
     12  049a					      LIST	ON
      0  049a					      VEND	InitialisePieceSquares
      1  049a				  -	      IFNCONST	InitialisePieceSquares
      2  049a				  -	      ECHO	"Incorrect VEND label", InitialisePieceSquares
      3  049a				  -	      ERR
      4  049a					      ENDIF
      5  049a		       00 a7	   VAREND_InitialisePieceSquares =	TEMPORARY_VAR
    186  049a
    187  049a		       a9 00		      lda	#0
    188  049c		       85 8f		      sta	Evaluation
    189  049e		       85 90		      sta	Evaluation+1	; tracks CURRENT value of everything (signed 16-bit)
    190  04a0		       85 93		      sta	enPassantPawn	; no en-passant
    191  04a2
    192  04a2
      0  04a2					      PHASE	AI_StartClearBoard
      1  04a2		       a9 0d		      lda	#AI_StartClearBoard
      2  04a4		       85 8b		      sta	aiState
    194  04a6
    195  04a6		       a2 00		      ldx	#0
    196  04a8				   .fillPieceLists
    197  04a8
    198  04a8
    199  04a8		       bd fa f4 	      lda	InitPieceList,x	; colour/-1
    200  04ab		       f0 4c		      beq	.exit
    201  04ad		       85 b2		      sta	__originalPiece	; type
    202  04af		       bc fb f4 	      ldy	InitPieceList+1,x	; square
    203  04b2		       84 a5		      sty	__initSquare
    204  04b4
    205  04b4		       a9 cc		      lda	#RAMBANK_BOARD
    206  04b6		       85 3e		      sta	SET_BANK_RAM
    207  04b8		       a5 b2		      lda	__originalPiece
      0  04ba					      sta@RAM	Board,y
      1  04ba		       99 79 fe 	      sta	[RAM]+Board,y
    209  04bd		       10 0d		      bpl	.white
    210  04bf
      0  04bf					      NEGEVAL
      1  04bf
      2  04bf		       38		      sec
      3  04c0		       a9 00		      lda	#0
      4  04c2		       e5 8f		      sbc	Evaluation
      5  04c4		       85 8f		      sta	Evaluation
      6  04c6		       a9 00		      lda	#0
      7  04c8		       e5 90		      sbc	Evaluation+1
      8  04ca		       85 90		      sta	Evaluation+1
    212  04cc				   .white
    213  04cc
    214  04cc		       86 a6		      stx	__initListPtr
    215  04ce
    216  04ce							; Add the material value of the piece to the evaluation
    217  04ce
    218  04ce		       a5 b2		      lda	__originalPiece
    219  04d0		       a2 91		      ldx	#BANK_AddPieceMaterialValue
    220  04d2		       86 3f		      stx	SET_BANK	;@2
    221  04d4		       20 1b f9 	      jsr	AddPieceMaterialValue
    222  04d7
    223  04d7
    224  04d7							; add the positional value of the piece to the evaluation
    225  04d7
    226  04d7		       a4 a5		      ldy	__initSquare
    227  04d9		       a5 b2		      lda	__originalPiece
    228  04db		       a2 91		      ldx	#BANK_AddPiecePositionValue
    229  04dd		       86 3f		      stx	SET_BANK
    230  04df		       20 32 f9 	      jsr	AddPiecePositionValue
    231  04e2
    232  04e2		       a5 b2		      lda	__originalPiece	; type/colour
    233  04e4		       10 0d		      bpl	.white2
      0  04e6					      NEGEVAL
      1  04e6
      2  04e6		       38		      sec
      3  04e7		       a9 00		      lda	#0
      4  04e9		       e5 8f		      sbc	Evaluation
      5  04eb		       85 8f		      sta	Evaluation
      6  04ed		       a9 00		      lda	#0
      7  04ef		       e5 90		      sbc	Evaluation+1
      8  04f1		       85 90		      sta	Evaluation+1
    235  04f3				   .white2
    236  04f3
    237  04f3		       a6 a6		      ldx	__initListPtr
    238  04f5		       e8		      inx
    239  04f6		       e8		      inx
    240  04f7		       10 af		      bpl	.fillPieceLists
    241  04f9
    242  04f9				   .exit
    243  04f9		       60		      rts
    244  04fa
    245  04fa
    246  04fa				   InitPieceList
    247  04fa
    248  04fa
    249  04fa					      IF	!TEST_POSITION
    250  04fa
    251  04fa		       06 19		      .byte.b	WHITE|Q, 25
    252  04fc		       04 18		      .byte.b	WHITE|B, 24
    253  04fe		       04 1b		      .byte.b	WHITE|B, 27
    254  0500		       05 16		      .byte.b	WHITE|R, 22
    255  0502		       05 1d		      .byte.b	WHITE|R, 29
    256  0504		       03 17		      .byte.b	WHITE|N, 23
    257  0506		       03 1c		      .byte.b	WHITE|N, 28
    258  0508
    259  0508		       01 23		      .byte.b	WHITE|WP, 35
    260  050a		       01 24		      .byte.b	WHITE|WP, 36
    261  050c		       01 22		      .byte.b	WHITE|WP, 34
    262  050e		       01 25		      .byte.b	WHITE|WP, 37
    263  0510		       01 21		      .byte.b	WHITE|WP, 33
    264  0512		       01 26		      .byte.b	WHITE|WP, 38
    265  0514		       01 20		      .byte.b	WHITE|WP, 32
    266  0516		       01 27		      .byte.b	WHITE|WP, 39
    267  0518
    268  0518		       07 1a		      .byte.b	WHITE|K, 26
    269  051a
    270  051a		       86 5f		      .byte.b	BLACK|Q, 95
    271  051c		       84 5e		      .byte.b	BLACK|B, 94
    272  051e		       84 61		      .byte.b	BLACK|B, 97
    273  0520		       85 5c		      .byte.b	BLACK|R, 92
    274  0522		       85 63		      .byte.b	BLACK|R, 99
    275  0524		       83 5d		      .byte.b	BLACK|N, 93
    276  0526		       83 62		      .byte.b	BLACK|N, 98
    277  0528
    278  0528		       82 55		      .byte.b	BLACK|BP, 85
    279  052a		       82 56		      .byte.b	BLACK|BP, 86
    280  052c		       82 54		      .byte.b	BLACK|BP, 84
    281  052e		       82 57		      .byte.b	BLACK|BP, 87
    282  0530		       82 53		      .byte.b	BLACK|BP, 83
    283  0532		       82 58		      .byte.b	BLACK|BP, 88
    284  0534		       82 52		      .byte.b	BLACK|BP, 82
    285  0536		       82 59		      .byte.b	BLACK|BP, 89
    286  0538
    287  0538		       87 60		      .byte.b	BLACK|K, 96
    288  053a
    289  053a		       00		      .byte.b	0	;end
    290  053b
    291  053b				  -	      ELSE		; test position...
    292  053b				  -
    293  053b				  -
    294  053b				  -	      IF	0
    295  053b				  -
    296  053b				  -	      .byte	WHITE|K, 28
    297  053b				  -	      .byte	WHITE|WP, 37
    298  053b				  -	      .byte	WHITE|WP, 38
    299  053b				  -	      .byte	WHITE|WP, 53
    300  053b				  -	      .byte	WHITE|WP, 49
    301  053b				  -	      .byte	WHITE|WP, 32
    302  053b				  -	      .byte	WHITE|R, 27
    303  053b				  -	      .byte	WHITE|B, 46
    304  053b				  -	      .byte	WHITE|R, 54
    305  053b				  -
    306  053b				  -	      .byte	BLACK|BP, 56
    307  053b				  -	      .byte	BLACK|BP, 87
    308  053b				  -	      .byte	BLACK|BP, 88
    309  053b				  -	      .byte	BLACK|BP, 89
    310  053b				  -	      .byte	BLACK|BP, 84
    311  053b				  -	      .byte	BLACK|B, 66
    312  053b				  -	      .byte	BLACK|R, 69
    313  053b				  -	      .byte	BLACK|K, 98
    314  053b				  -
    315  053b				  -	      .byte	BLACK|R, 92
    316  053b				  -
    317  053b				  -
    318  053b				  -
    319  053b				  -	      ENDIF
    320  053b				  -
    321  053b				  -
    322  053b				  -	      IF	0
    323  053b				  -			; En passant test
    324  053b				  -
    325  053b				  -	      .byte	BLACK|BP, 88
    326  053b				  -	      .byte	BLACK|BP, 86
    327  053b				  -
    328  053b				  -	      .byte	WHITE|WP, 67
    329  053b				  -	      .byte	WHITE|K, 52
    330  053b				  -
    331  053b				  -
    332  053b				  -	      ENDIF
    333  053b				  -
    334  053b				  -
    335  053b				  -
    336  053b				  -
    337  053b				  -	      IF	1
    338  053b				  -
    339  053b				  -
    340  053b				  -			;.byte BLACK|R, 97
    341  053b				  -	      .byte	BLACK|K, 98
    342  053b				  -	      .byte	BLACK|BP, 87
    343  053b				  -	      .byte	BLACK|BP, 88
    344  053b				  -	      .byte	BLACK|BP, 89
    345  053b				  -			;    .byte BLACK|B, 76
    346  053b				  -
    347  053b				  -
    348  053b				  -	      .byte	WHITE|R,28
    349  053b				  -	      .byte	WHITE|Q,58
    350  053b				  -			;   .byte WHITE|N,65
    351  053b				  -	      ENDIF
    352  053b				  -
    353  053b				  -	      IF	0
    354  053b				  -			;.byte WHITE|WP, 56
    355  053b				  -
    356  053b				  -
    357  053b				  -	      .byte	BLACK|K, 98
    358  053b				  -
    359  053b				  -
    360  053b				  -	      .byte	WHITE|R,29
    361  053b				  -	      .byte	WHITE|Q,49
    362  053b				  -	      .byte	WHITE|N,65
    363  053b				  -	      ENDIF
    364  053b				  -	      .byte	0	;end
    365  053b				  -
    366  053b					      ENDIF
    367  053b
    368  053b
    369  053b							;---------------------------------------------------------------------------------------------------
    370  053b
      0  053b					      DEF	EnPassantRemovePiece
      1  053b				   SLOT_EnPassantRemovePiece SET	_BANK_SLOT
      2  053b				   BANK_EnPassantRemovePiece SET	SLOT_EnPassantRemovePiece + _CURRENT_BANK
      3  053b				   EnPassantRemovePiece
      4  053b				   TEMPORARY_VAR SET	Overlay
      5  053b				   TEMPORARY_OFFSET SET	0
      6  053b				   VAR_BOUNDARY_EnPassantRemovePiece SET	TEMPORARY_OFFSET
      7  053b				   FUNCTION_NAME SET	EnPassantRemovePiece
    372  053b					      SUBROUTINE
    373  053b
      0  053b					      REFER	MakeMove
      1  053b					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  053b				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  053b					      ENDIF
    375  053b
    376  053b				  -	      IF	ENPASSANT_ENABLED
    377  053b				  -	      REFER	EnPassantCheck
    378  053b					      ENDIF
    379  053b
      0  053b					      VAR	__y, 1
      1  053b		       00 b2	   __y	      =	TEMPORARY_VAR
      2  053b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  053b
      4  053b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  053b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  053b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  053b					      ENDIF
      8  053b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  053b				  -	      ECHO	"Temporary Variable", __y, "overflow!"
     10  053b				  -	      ERR
     11  053b					      ENDIF
     12  053b					      LIST	ON
      0  053b					      VAR	__col, 1
      1  053b		       00 b3	   __col      =	TEMPORARY_VAR
      2  053b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  053b
      4  053b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  053b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  053b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  053b					      ENDIF
      8  053b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  053b				  -	      ECHO	"Temporary Variable", __col, "overflow!"
     10  053b				  -	      ERR
     11  053b					      ENDIF
     12  053b					      LIST	ON
    382  053b
      0  053b					      VEND	EnPassantRemovePiece
      1  053b				  -	      IFNCONST	EnPassantRemovePiece
      2  053b				  -	      ECHO	"Incorrect VEND label", EnPassantRemovePiece
      3  053b				  -	      ERR
      4  053b					      ENDIF
      5  053b		       00 b4	   VAREND_EnPassantRemovePiece =	TEMPORARY_VAR
    384  053b
    385  053b
    386  053b							; Based on piece square, adjust material and position value with piece deleted
    387  053b							; y = piece square
    388  053b
    389  053b		       84 b2		      sty	__y
    390  053d
    391  053d		       a9 cc		      lda	#RAMBANK_BOARD
    392  053f		       85 3e		      sta	SET_BANK_RAM	;@3
    393  0541		       b9 79 fc 	      lda	Board,y
    394  0544		       85 b3		      sta	__col
    395  0546		       a2 91		      ldx	#BANK_AddPieceMaterialValue
    396  0548		       86 3f		      stx	SET_BANK	;@2
    397  054a		       20 1b f9 	      jsr	AddPieceMaterialValue	; adding for opponent = taking
    398  054d
    399  054d		       a5 b3		      lda	__col
    400  054f		       a4 b2		      ldy	__y
    401  0551		       20 32 f9 	      jsr	AddPiecePositionValue	; adding for opponent = taking
    402  0554
    403  0554		       60		      rts
    404  0555
    405  0555
    406  0555							;---------------------------------------------------------------------------------------------------
    407  0555
      0  0555					      ALLOCATE	FlipSquareIndex, 100
      0  0555					      OPTIONAL_PAGEBREAK	"Table", 100
     12  0555					      LIST	ON
      0  0555					      DEF	FlipSquareIndex
      1  0555				   SLOT_FlipSquareIndex SET	_BANK_SLOT
      2  0555				   BANK_FlipSquareIndex SET	SLOT_FlipSquareIndex + _CURRENT_BANK
      3  0555				   FlipSquareIndex
      4  0555				   TEMPORARY_VAR SET	Overlay
      5  0555				   TEMPORARY_OFFSET SET	0
      6  0555				   VAR_BOUNDARY_FlipSquareIndex SET	TEMPORARY_OFFSET
      7  0555				   FUNCTION_NAME SET	FlipSquareIndex
    409  0555
    410  0555		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    411  055f		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    412  0569
    413  0569				   .SQBASE    SET	90-1
    414  0569					      REPEAT	8
    415  0569		       00 00		      .byte.b	0,0
    416  0569				   .SQX       SET	2
    417  056b					      REPEAT	8
    418  056b		       5b		      .byte.b	(.SQBASE+.SQX)
    419  056b				   .SQX       SET	.SQX + 1
    417  056b					      REPEND
    418  056c		       5c		      .byte.b	(.SQBASE+.SQX)
    419  056c				   .SQX       SET	.SQX + 1
    417  056c					      REPEND
    418  056d		       5d		      .byte.b	(.SQBASE+.SQX)
    419  056d				   .SQX       SET	.SQX + 1
    417  056d					      REPEND
    418  056e		       5e		      .byte.b	(.SQBASE+.SQX)
    419  056e				   .SQX       SET	.SQX + 1
    417  056e					      REPEND
    418  056f		       5f		      .byte.b	(.SQBASE+.SQX)
    419  056f				   .SQX       SET	.SQX + 1
    417  056f					      REPEND
    418  0570		       60		      .byte.b	(.SQBASE+.SQX)
    419  0570				   .SQX       SET	.SQX + 1
    417  0570					      REPEND
    418  0571		       61		      .byte.b	(.SQBASE+.SQX)
    419  0571				   .SQX       SET	.SQX + 1
    417  0571					      REPEND
    418  0572		       62		      .byte.b	(.SQBASE+.SQX)
    419  0572				   .SQX       SET	.SQX + 1
    420  0573					      REPEND
    421  0573				   .SQBASE    SET	.SQBASE - 10
    414  0573					      REPEND
    415  0573		       00 00		      .byte.b	0,0
    416  0573				   .SQX       SET	2
    417  0575					      REPEAT	8
    418  0575		       51		      .byte.b	(.SQBASE+.SQX)
    419  0575				   .SQX       SET	.SQX + 1
    417  0575					      REPEND
    418  0576		       52		      .byte.b	(.SQBASE+.SQX)
    419  0576				   .SQX       SET	.SQX + 1
    417  0576					      REPEND
    418  0577		       53		      .byte.b	(.SQBASE+.SQX)
    419  0577				   .SQX       SET	.SQX + 1
    417  0577					      REPEND
    418  0578		       54		      .byte.b	(.SQBASE+.SQX)
    419  0578				   .SQX       SET	.SQX + 1
    417  0578					      REPEND
    418  0579		       55		      .byte.b	(.SQBASE+.SQX)
    419  0579				   .SQX       SET	.SQX + 1
    417  0579					      REPEND
    418  057a		       56		      .byte.b	(.SQBASE+.SQX)
    419  057a				   .SQX       SET	.SQX + 1
    417  057a					      REPEND
    418  057b		       57		      .byte.b	(.SQBASE+.SQX)
    419  057b				   .SQX       SET	.SQX + 1
    417  057b					      REPEND
    418  057c		       58		      .byte.b	(.SQBASE+.SQX)
    419  057c				   .SQX       SET	.SQX + 1
    420  057d					      REPEND
    421  057d				   .SQBASE    SET	.SQBASE - 10
    414  057d					      REPEND
    415  057d		       00 00		      .byte.b	0,0
    416  057d				   .SQX       SET	2
    417  057f					      REPEAT	8
    418  057f		       47		      .byte.b	(.SQBASE+.SQX)
    419  057f				   .SQX       SET	.SQX + 1
    417  057f					      REPEND
    418  0580		       48		      .byte.b	(.SQBASE+.SQX)
    419  0580				   .SQX       SET	.SQX + 1
    417  0580					      REPEND
    418  0581		       49		      .byte.b	(.SQBASE+.SQX)
    419  0581				   .SQX       SET	.SQX + 1
    417  0581					      REPEND
    418  0582		       4a		      .byte.b	(.SQBASE+.SQX)
    419  0582				   .SQX       SET	.SQX + 1
    417  0582					      REPEND
    418  0583		       4b		      .byte.b	(.SQBASE+.SQX)
    419  0583				   .SQX       SET	.SQX + 1
    417  0583					      REPEND
    418  0584		       4c		      .byte.b	(.SQBASE+.SQX)
    419  0584				   .SQX       SET	.SQX + 1
    417  0584					      REPEND
    418  0585		       4d		      .byte.b	(.SQBASE+.SQX)
    419  0585				   .SQX       SET	.SQX + 1
    417  0585					      REPEND
    418  0586		       4e		      .byte.b	(.SQBASE+.SQX)
    419  0586				   .SQX       SET	.SQX + 1
    420  0587					      REPEND
    421  0587				   .SQBASE    SET	.SQBASE - 10
    414  0587					      REPEND
    415  0587		       00 00		      .byte.b	0,0
    416  0587				   .SQX       SET	2
    417  0589					      REPEAT	8
    418  0589		       3d		      .byte.b	(.SQBASE+.SQX)
    419  0589				   .SQX       SET	.SQX + 1
    417  0589					      REPEND
    418  058a		       3e		      .byte.b	(.SQBASE+.SQX)
    419  058a				   .SQX       SET	.SQX + 1
    417  058a					      REPEND
    418  058b		       3f		      .byte.b	(.SQBASE+.SQX)
    419  058b				   .SQX       SET	.SQX + 1
    417  058b					      REPEND
    418  058c		       40		      .byte.b	(.SQBASE+.SQX)
    419  058c				   .SQX       SET	.SQX + 1
    417  058c					      REPEND
    418  058d		       41		      .byte.b	(.SQBASE+.SQX)
    419  058d				   .SQX       SET	.SQX + 1
    417  058d					      REPEND
    418  058e		       42		      .byte.b	(.SQBASE+.SQX)
    419  058e				   .SQX       SET	.SQX + 1
    417  058e					      REPEND
    418  058f		       43		      .byte.b	(.SQBASE+.SQX)
    419  058f				   .SQX       SET	.SQX + 1
    417  058f					      REPEND
    418  0590		       44		      .byte.b	(.SQBASE+.SQX)
    419  0590				   .SQX       SET	.SQX + 1
    420  0591					      REPEND
    421  0591				   .SQBASE    SET	.SQBASE - 10
    414  0591					      REPEND
    415  0591		       00 00		      .byte.b	0,0
    416  0591				   .SQX       SET	2
    417  0593					      REPEAT	8
    418  0593		       33		      .byte.b	(.SQBASE+.SQX)
    419  0593				   .SQX       SET	.SQX + 1
    417  0593					      REPEND
    418  0594		       34		      .byte.b	(.SQBASE+.SQX)
    419  0594				   .SQX       SET	.SQX + 1
    417  0594					      REPEND
    418  0595		       35		      .byte.b	(.SQBASE+.SQX)
    419  0595				   .SQX       SET	.SQX + 1
    417  0595					      REPEND
    418  0596		       36		      .byte.b	(.SQBASE+.SQX)
    419  0596				   .SQX       SET	.SQX + 1
    417  0596					      REPEND
    418  0597		       37		      .byte.b	(.SQBASE+.SQX)
    419  0597				   .SQX       SET	.SQX + 1
    417  0597					      REPEND
    418  0598		       38		      .byte.b	(.SQBASE+.SQX)
    419  0598				   .SQX       SET	.SQX + 1
    417  0598					      REPEND
    418  0599		       39		      .byte.b	(.SQBASE+.SQX)
    419  0599				   .SQX       SET	.SQX + 1
    417  0599					      REPEND
    418  059a		       3a		      .byte.b	(.SQBASE+.SQX)
    419  059a				   .SQX       SET	.SQX + 1
    420  059b					      REPEND
    421  059b				   .SQBASE    SET	.SQBASE - 10
    414  059b					      REPEND
    415  059b		       00 00		      .byte.b	0,0
    416  059b				   .SQX       SET	2
    417  059d					      REPEAT	8
    418  059d		       29		      .byte.b	(.SQBASE+.SQX)
    419  059d				   .SQX       SET	.SQX + 1
    417  059d					      REPEND
    418  059e		       2a		      .byte.b	(.SQBASE+.SQX)
    419  059e				   .SQX       SET	.SQX + 1
    417  059e					      REPEND
    418  059f		       2b		      .byte.b	(.SQBASE+.SQX)
    419  059f				   .SQX       SET	.SQX + 1
    417  059f					      REPEND
    418  05a0		       2c		      .byte.b	(.SQBASE+.SQX)
    419  05a0				   .SQX       SET	.SQX + 1
    417  05a0					      REPEND
    418  05a1		       2d		      .byte.b	(.SQBASE+.SQX)
    419  05a1				   .SQX       SET	.SQX + 1
    417  05a1					      REPEND
    418  05a2		       2e		      .byte.b	(.SQBASE+.SQX)
    419  05a2				   .SQX       SET	.SQX + 1
    417  05a2					      REPEND
    418  05a3		       2f		      .byte.b	(.SQBASE+.SQX)
    419  05a3				   .SQX       SET	.SQX + 1
    417  05a3					      REPEND
    418  05a4		       30		      .byte.b	(.SQBASE+.SQX)
    419  05a4				   .SQX       SET	.SQX + 1
    420  05a5					      REPEND
    421  05a5				   .SQBASE    SET	.SQBASE - 10
    414  05a5					      REPEND
    415  05a5		       00 00		      .byte.b	0,0
    416  05a5				   .SQX       SET	2
    417  05a7					      REPEAT	8
    418  05a7		       1f		      .byte.b	(.SQBASE+.SQX)
    419  05a7				   .SQX       SET	.SQX + 1
    417  05a7					      REPEND
    418  05a8		       20		      .byte.b	(.SQBASE+.SQX)
    419  05a8				   .SQX       SET	.SQX + 1
    417  05a8					      REPEND
    418  05a9		       21		      .byte.b	(.SQBASE+.SQX)
    419  05a9				   .SQX       SET	.SQX + 1
    417  05a9					      REPEND
    418  05aa		       22		      .byte.b	(.SQBASE+.SQX)
    419  05aa				   .SQX       SET	.SQX + 1
    417  05aa					      REPEND
    418  05ab		       23		      .byte.b	(.SQBASE+.SQX)
    419  05ab				   .SQX       SET	.SQX + 1
    417  05ab					      REPEND
    418  05ac		       24		      .byte.b	(.SQBASE+.SQX)
    419  05ac				   .SQX       SET	.SQX + 1
    417  05ac					      REPEND
    418  05ad		       25		      .byte.b	(.SQBASE+.SQX)
    419  05ad				   .SQX       SET	.SQX + 1
    417  05ad					      REPEND
    418  05ae		       26		      .byte.b	(.SQBASE+.SQX)
    419  05ae				   .SQX       SET	.SQX + 1
    420  05af					      REPEND
    421  05af				   .SQBASE    SET	.SQBASE - 10
    414  05af					      REPEND
    415  05af		       00 00		      .byte.b	0,0
    416  05af				   .SQX       SET	2
    417  05b1					      REPEAT	8
    418  05b1		       15		      .byte.b	(.SQBASE+.SQX)
    419  05b1				   .SQX       SET	.SQX + 1
    417  05b1					      REPEND
    418  05b2		       16		      .byte.b	(.SQBASE+.SQX)
    419  05b2				   .SQX       SET	.SQX + 1
    417  05b2					      REPEND
    418  05b3		       17		      .byte.b	(.SQBASE+.SQX)
    419  05b3				   .SQX       SET	.SQX + 1
    417  05b3					      REPEND
    418  05b4		       18		      .byte.b	(.SQBASE+.SQX)
    419  05b4				   .SQX       SET	.SQX + 1
    417  05b4					      REPEND
    418  05b5		       19		      .byte.b	(.SQBASE+.SQX)
    419  05b5				   .SQX       SET	.SQX + 1
    417  05b5					      REPEND
    418  05b6		       1a		      .byte.b	(.SQBASE+.SQX)
    419  05b6				   .SQX       SET	.SQX + 1
    417  05b6					      REPEND
    418  05b7		       1b		      .byte.b	(.SQBASE+.SQX)
    419  05b7				   .SQX       SET	.SQX + 1
    417  05b7					      REPEND
    418  05b8		       1c		      .byte.b	(.SQBASE+.SQX)
    419  05b8				   .SQX       SET	.SQX + 1
    420  05b9					      REPEND
    421  05b9				   .SQBASE    SET	.SQBASE - 10
    422  05b9					      REPEND
    423  05b9
    424  05b9
    425  05b9							;---------------------------------------------------------------------------------------------------
    426  05b9
      0  05b9					      DEF	GenCastleMoveForRook
      1  05b9				   SLOT_GenCastleMoveForRook SET	_BANK_SLOT
      2  05b9				   BANK_GenCastleMoveForRook SET	SLOT_GenCastleMoveForRook + _CURRENT_BANK
      3  05b9				   GenCastleMoveForRook
      4  05b9				   TEMPORARY_VAR SET	Overlay
      5  05b9				   TEMPORARY_OFFSET SET	0
      6  05b9				   VAR_BOUNDARY_GenCastleMoveForRook SET	TEMPORARY_OFFSET
      7  05b9				   FUNCTION_NAME SET	GenCastleMoveForRook
    428  05b9					      SUBROUTINE
    429  05b9
      0  05b9					      REFER	MakeMove
      1  05b9					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  05b9				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  05b9					      ENDIF
      0  05b9					      REFER	CastleFixupDraw
      1  05b9				  -	      IF	VAREND_CastleFixupDraw > TEMPORARY_VAR
      2  05b9				  -TEMPORARY_VAR SET	VAREND_CastleFixupDraw
      3  05b9					      ENDIF
      0  05b9					      VEND	GenCastleMoveForRook
      1  05b9				  -	      IFNCONST	GenCastleMoveForRook
      2  05b9				  -	      ECHO	"Incorrect VEND label", GenCastleMoveForRook
      3  05b9				  -	      ERR
      4  05b9					      ENDIF
      5  05b9		       00 b2	   VAREND_GenCastleMoveForRook =	TEMPORARY_VAR
    433  05b9
    434  05b9		       18		      clc
    435  05ba
    436  05ba		       a5 96		      lda	fromPiece
    437  05bc		       29 10		      and	#FLAG_CASTLE
    438  05be		       f0 2b		      beq	.exit	; NOT involved in castle!
    439  05c0
    440  05c0		       a2 04		      ldx	#4
    441  05c2		       a5 85		      lda	fromX12	; *destination*
    442  05c4		       18	   .findCast  clc
    443  05c5		       ca		      dex
    444  05c6		       30 23		      bmi	.exit
    445  05c8		       dd 4e f4 	      cmp	KSquare,x
    446  05cb		       d0 f7		      bne	.findCast
    447  05cd
    448  05cd		       bd 56 f4 	      lda	RSquareEnd,x
    449  05d0		       85 86		      sta	toX12
      0  05d2					      sta@PLY	secondaryBlank
      1  05d2		       8d cf fb 	      sta	[RAM]+secondaryBlank
    451  05d5		       bc 52 f4 	      ldy	RSquareStart,x
    452  05d8		       84 85		      sty	fromX12
    453  05da		       84 87		      sty	originX12
      0  05dc					      sty@PLY	secondarySquare
      1  05dc		       8c ce fb 	      sty	[RAM]+secondarySquare
    455  05df
    456  05df		       a5 96		      lda	fromPiece
    457  05e1		       29 80		      and	#128	; colour bit
    458  05e3		       09 05		      ora	#ROOK	; preserve colour
    459  05e5		       85 96		      sta	fromPiece
      0  05e7					      sta@PLY	secondaryPiece
      1  05e7		       8d cd fb 	      sta	[RAM]+secondaryPiece
    461  05ea
    462  05ea		       38		      sec
    463  05eb		       60	   .exit      rts
    464  05ec
    465  05ec
    466  05ec							;---------------------------------------------------------------------------------------------------
    467  05ec
      0  05ec					      CHECK_BANK_SIZE	"BANK_GENERIC@1#1"
      1  05ec		       01 ec	   .TEMP      =	* - _BANK_START
 BANK_GENERIC@1#1 (1K) SIZE =  $1ec , FREE= $214
      2  05ec					      ECHO	"BANK_GENERIC@1#1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  05ec				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  05ec				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC@1#1", " size=", * - ORIGIN
      5  05ec				  -	      ERR
      6  05ec					      ENDIF
    469  05ec
    470  05ec							;---------------------------------------------------------------------------------------------------
    471  05ec							; EOF
------- FILE ./chess.asm
------- FILE BANK_ROM_SHADOW_SCREEN.asm LEVEL 2 PASS 4
      0  05ec					      include	"BANK_ROM_SHADOW_SCREEN.asm"
      1  05ec
      0  05ec					      SLOT	2
      1  05ec				  -	      IF	(2 < 0) || (2 > 3)
      2  05ec				  -	      ECHO	"Illegal bank address/segment location", 2
      3  05ec				  -	      ERR
      4  05ec					      ENDIF
      5  05ec				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  05ec				   _BANK_SLOT SET	2 * 64
      0  05ec					      NEWBANK	BITMAP
      1  09a6 ????				      SEG	BITMAP
      2  0800					      ORG	_ORIGIN
      3  0800					      RORG	_BANK_ADDRESS_ORIGIN
      4  0800				   _BANK_START SET	*
      5  0800				   BITMAP_START SET	*
      6  0800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0800				   BITMAP     SET	_BANK_SLOT + _CURRENT_BANK
      8  0800				   _ORIGIN    SET	_ORIGIN + 1024
      4  0800
      5  0800							; These equates allow revectoring (address offset) if the RAM slot is not the same as the SHADOW slot
      6  0800
      7  0800		       f8 00	   ChessBitmap =	SHADOW_ChessBitmap
      8  0800
      9  0800		       f8 00	   ChessBitmap0 =	SHADOW_ChessBitmap0
     10  0800		       f8 18	   ChessBitmap1 =	SHADOW_ChessBitmap1
     11  0800		       f8 30	   ChessBitmap2 =	SHADOW_ChessBitmap2
     12  0800		       f8 48	   ChessBitmap3 =	SHADOW_ChessBitmap3
     13  0800		       f8 60	   ChessBitmap4 =	SHADOW_ChessBitmap4
     14  0800		       f8 78	   ChessBitmap5 =	SHADOW_ChessBitmap5
     15  0800
     16  0800							; Template bank for a SINGLE ROW of the chessboard display.
     17  0800							; There are 8x of these.
     18  0800							; The bank contains the definition of the bitmap, and also the code to draw the bitmap
     19  0800							; The bank is copied from ROM into RAM at startup.
     20  0800							; The draw switches between consecutive row banks, with the last returning
     21  0800							; we effectively have 1K
     22  0800							;---------------------------------------------------------------------------------------------------
     23  0800
     24  0800		       00 84	   COLOUR_LINE_1 =	$84
     25  0800		       00 36	   COLOUR_LINE_2 =	$36
     26  0800		       00 28	   COLOUR_LINE_3 =	$28
     27  0800		       00 00	   BACKGCOL   =	$00
     28  0800
     29  0800
     30  0800		       00 90	   ROW_BITMAP_SIZE =	6 * 24	; PF0/PF1/PF2/(PF0)/(PF1)/(PF2) x 8 ICC pixels
     31  0800
     32  0800
      0  0800					      ALLOCATE	SHADOW_ChessBitmap, ROW_BITMAP_SIZE
      0  0800					      OPTIONAL_PAGEBREAK	"Table", ROW_BITMAP_SIZE
     12  0800					      LIST	ON
      0  0800					      DEF	SHADOW_ChessBitmap
      1  0800				   SLOT_SHADOW_ChessBitmap SET	_BANK_SLOT
      2  0800				   BANK_SHADOW_ChessBitmap SET	SLOT_SHADOW_ChessBitmap + _CURRENT_BANK
      3  0800				   SHADOW_ChessBitmap
      4  0800				   TEMPORARY_VAR SET	Overlay
      5  0800				   TEMPORARY_OFFSET SET	0
      6  0800				   VAR_BOUNDARY_SHADOW_ChessBitmap SET	TEMPORARY_OFFSET
      7  0800				   FUNCTION_NAME SET	SHADOW_ChessBitmap
     34  0800		       00 00 00 00*SHADOW_ChessBitmap0 ds	24
     35  0818		       00 00 00 00*SHADOW_ChessBitmap1 ds	24
     36  0830		       00 00 00 00*SHADOW_ChessBitmap2 ds	24
     37  0848		       00 00 00 00*SHADOW_ChessBitmap3 ds	24
     38  0860		       00 00 00 00*SHADOW_ChessBitmap4 ds	24
     39  0878		       00 00 00 00*SHADOW_ChessBitmap5 ds	24
     40  0890
      0  0890					      ALLOCATE	BlankSprite, 8
      0  0890					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0890					      LIST	ON
      0  0890					      DEF	BlankSprite
      1  0890				   SLOT_BlankSprite SET	_BANK_SLOT
      2  0890				   BANK_BlankSprite SET	SLOT_BlankSprite + _CURRENT_BANK
      3  0890				   BlankSprite
      4  0890				   TEMPORARY_VAR SET	Overlay
      5  0890				   TEMPORARY_OFFSET SET	0
      6  0890				   VAR_BOUNDARY_BlankSprite SET	TEMPORARY_OFFSET
      7  0890				   FUNCTION_NAME SET	BlankSprite
     42  0890		       00 00 00 00*	      ds	8, 0
     43  0898
      0  0898					      ALLOCATE	SpriteBuffer, 8
      0  0898					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0898					      LIST	ON
      0  0898					      DEF	SpriteBuffer
      1  0898				   SLOT_SpriteBuffer SET	_BANK_SLOT
      2  0898				   BANK_SpriteBuffer SET	SLOT_SpriteBuffer + _CURRENT_BANK
      3  0898				   SpriteBuffer
      4  0898				   TEMPORARY_VAR SET	Overlay
      5  0898				   TEMPORARY_OFFSET SET	0
      6  0898				   VAR_BOUNDARY_SpriteBuffer SET	TEMPORARY_OFFSET
      7  0898				   FUNCTION_NAME SET	SpriteBuffer
     45  0898				   SpriteBuffer2
     46  0898		       f8		      .byte.b	%11111000
     47  0899		       f8		      .byte.b	%11111000
     48  089a		       f8		      .byte.b	%11111000
     49  089b		       f8		      .byte.b	%11111000
     50  089c		       f8		      .byte.b	%11111000
     51  089d		       f8		      .byte.b	%11111000
     52  089e		       f8		      .byte.b	%11111000
     53  089f		       f8		      .byte.b	%11111000
     54  08a0
     55  08a0				  -	      IF	0
     56  08a0				  -	      ALLOCATE	BackupBitmap, ROW_BITMAP_SIZE
     57  08a0				  -	      ds	ROW_BITMAP_SIZE, 0
     58  08a0					      ENDIF
     59  08a0
     60  08a0							;---------------------------------------------------------------------------------------------------
     61  08a0
     62  0900		       00 00 00 00*	      ALIGN	256
     63  0900					      SUBROUTINE
     64  0900
      0  0900					      REFER	StartupBankReset
      1  0900				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0900				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0900					      ENDIF
     66  0900				   __dummy
      0  0900					      VEND	__dummy
      1  0900				  -	      IFNCONST	__dummy
      2  0900				  -	      ECHO	"Incorrect VEND label", __dummy
      3  0900				  -	      ERR
      4  0900					      ENDIF
      5  0900		       00 a4	   VAREND___dummy =	TEMPORARY_VAR
     68  0900
     69  0900							; x = row # (and bank#)
     70  0900
     71  0900				   .endline
     72  0900
     73  0900							;@59
     74  0900
     75  0900							; The following 'inx' is replaced in the LAST row bank with a 'RTS', thus ending the draw loop
     76  0900							; Note that the other 7 row banks are unmodified (keeping the 'inx')
     77  0900				   SELFMOD_RTS_ON_LAST_ROW
     78  0900
     79  0900		       e8		      inx		; 2
     80  0901		       86 3e		      stx	SET_BANK_RAM	; 3 @64     BANK switch to next row
     81  0903
      0  0903					      DEF	DrawRow
      1  0903				   SLOT_DrawRow SET	_BANK_SLOT
      2  0903				   BANK_DrawRow SET	SLOT_DrawRow + _CURRENT_BANK
      3  0903				   DrawRow
      4  0903				   TEMPORARY_VAR SET	Overlay
      5  0903				   TEMPORARY_OFFSET SET	0
      6  0903				   VAR_BOUNDARY_DrawRow SET	TEMPORARY_OFFSET
      7  0903				   FUNCTION_NAME SET	DrawRow
     83  0903
     84  0903							;@64
     85  0903		       a0 07		      ldy	#7	; 2
     86  0905		       10 3b		      bpl	.dl2	; 3   (must be 69 here)
     87  0907
     88  0907							;@58...
     89  0907
     90  0907				   .l3
     91  0907
     92  0907		       b9 a8 f8    SMSPRITE16_0 lda	SpriteBuffer+16,y	; 4
     93  090a		       85 5b		      sta	GRP0	; 3
     94  090c		       b9 a8 f8    SMSPRITE16_1 lda	SpriteBuffer2+16,y	; 4
     95  090f		       85 5c		      sta	GRP1	; 3
     96  0911
     97  0911							;@-4
     98  0911
     99  0911		       a9 84		      lda	#COLOUR_LINE_1	;#$94			  ; 2
    100  0913		       85 48		      sta	COLUPF	; 3 @1
    101  0915
    102  0915		       b9 10 f8 	      lda	ChessBitmap0+16,y	; 4
    103  0918		       85 4d		      sta	PF0	; 3
    104  091a		       b9 28 f8 	      lda	ChessBitmap1+16,y	; 4
    105  091d		       85 4e		      sta	PF1	; 3
    106  091f		       b9 40 f8 	      lda	ChessBitmap2+16,y	; 4
    107  0922		       85 4f		      sta	PF2	; 3 @22
    108  0924
      0  0924					      SLEEP	6	; 6 @28
      1  0924				   .CYCLES    SET	6
      2  0924
      3  0924				  -	      IF	.CYCLES < 2
      4  0924				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0924				  -	      ERR
      6  0924					      ENDIF
      7  0924
      8  0924				  -	      IF	.CYCLES & 1
      9  0924				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0924				  -	      nop	0
     11  0924				  -	      ELSE
     12  0924				  -	      bit	VSYNC
     13  0924				  -	      ENDIF
     14  0924				  -.CYCLES    SET	.CYCLES - 3
     15  0924					      ENDIF
     16  0924
     17  0924					      REPEAT	.CYCLES / 2
     18  0924		       ea		      nop
     17  0924					      REPEND
     18  0925		       ea		      nop
     17  0925					      REPEND
     18  0926		       ea		      nop
     19  0927					      REPEND
    110  0927
    111  0927		       b9 58 f8 	      lda	ChessBitmap3+16,y	; 4
    112  092a		       85 4d		      sta	PF0	; 3
    113  092c		       b9 70 f8 	      lda	ChessBitmap4+16,y	; 4
    114  092f		       85 4e		      sta	PF1	; 3
    115  0931		       b9 88 f8 	      lda	ChessBitmap5+16,y	; 4
    116  0934		       8d 4f 00 	      sta.w	PF2	; 4 @50
    117  0937
      0  0937					      SLEEP	4	; 4
      1  0937				   .CYCLES    SET	4
      2  0937
      3  0937				  -	      IF	.CYCLES < 2
      4  0937				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0937				  -	      ERR
      6  0937					      ENDIF
      7  0937
      8  0937				  -	      IF	.CYCLES & 1
      9  0937				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0937				  -	      nop	0
     11  0937				  -	      ELSE
     12  0937				  -	      bit	VSYNC
     13  0937				  -	      ENDIF
     14  0937				  -.CYCLES    SET	.CYCLES - 3
     15  0937					      ENDIF
     16  0937
     17  0937					      REPEAT	.CYCLES / 2
     18  0937		       ea		      nop
     17  0937					      REPEND
     18  0938		       ea		      nop
     19  0939					      REPEND
    119  0939
    120  0939		       88		      dey		; 2
    121  093a		       30 c4		      bmi	.endline	; 2 (3)
    122  093c
    123  093c							;@57
    124  093c				   .drawLine
    125  093c
      0  093c					      SLEEP	11
      1  093c				   .CYCLES    SET	11
      2  093c
      3  093c				  -	      IF	.CYCLES < 2
      4  093c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  093c				  -	      ERR
      6  093c					      ENDIF
      7  093c
      8  093c					      IF	.CYCLES & 1
      9  093c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  093c		       04 00		      nop	0
     11  093e				  -	      ELSE
     12  093e				  -	      bit	VSYNC
     13  093e					      ENDIF
     14  093e				   .CYCLES    SET	.CYCLES - 3
     15  093e					      ENDIF
     16  093e
     17  093e					      REPEAT	.CYCLES / 2
     18  093e		       ea		      nop
     17  093e					      REPEND
     18  093f		       ea		      nop
     17  093f					      REPEND
     18  0940		       ea		      nop
     17  0940					      REPEND
     18  0941		       ea		      nop
     19  0942					      REPEND
    127  0942
    128  0942				   .dl2
    129  0942		       b9 98 f8    SMSPRITE0_0 lda	SpriteBuffer,y	; 4
    130  0945		       85 5b		      sta	GRP0	; 3
    131  0947		       b9 98 f8    SMSPRITE0_1 lda	SpriteBuffer2,y	; 4
    132  094a		       85 5c		      sta	GRP1	; 3
    133  094c
    134  094c							;@7
    135  094c
    136  094c		       a9 36		      lda	#COLOUR_LINE_2	;#$4A			  ; 2
    137  094e		       85 48		      sta	COLUPF	; 3 @12
    138  0950
    139  0950		       b9 00 f8 	      lda	ChessBitmap0,y	; 4
    140  0953		       85 4d		      sta	PF0	; 3
    141  0955		       b9 18 f8 	      lda	ChessBitmap1,y	; 4
    142  0958		       85 4e		      sta	PF1	; 3
    143  095a		       b9 30 f8 	      lda	ChessBitmap2,y	; 4
    144  095d		       85 4f		      sta	PF2	; 3 @33
    145  095f
      0  095f					      SLEEP	3	; 3 @36
      1  095f				   .CYCLES    SET	3
      2  095f
      3  095f				  -	      IF	.CYCLES < 2
      4  095f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  095f				  -	      ERR
      6  095f					      ENDIF
      7  095f
      8  095f					      IF	.CYCLES & 1
      9  095f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  095f		       04 00		      nop	0
     11  0961				  -	      ELSE
     12  0961				  -	      bit	VSYNC
     13  0961					      ENDIF
     14  0961				   .CYCLES    SET	.CYCLES - 3
     15  0961					      ENDIF
     16  0961
     17  0961				  -	      REPEAT	.CYCLES / 2
     18  0961				  -	      nop
     19  0961					      REPEND
    147  0961
    148  0961		       b9 48 f8 	      lda	ChessBitmap3,y	; 4
    149  0964		       85 4d		      sta	PF0	; 3
    150  0966		       b9 60 f8 	      lda	ChessBitmap4,y	; 4
    151  0969		       85 4e		      sta	PF1	; 3
    152  096b		       b9 78 f8 	      lda	ChessBitmap5,y	; 4
    153  096e		       85 4f		      sta	PF2	; 3 @57
    154  0970
      0  0970					      SLEEP	5
      1  0970				   .CYCLES    SET	5
      2  0970
      3  0970				  -	      IF	.CYCLES < 2
      4  0970				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0970				  -	      ERR
      6  0970					      ENDIF
      7  0970
      8  0970					      IF	.CYCLES & 1
      9  0970					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0970		       04 00		      nop	0
     11  0972				  -	      ELSE
     12  0972				  -	      bit	VSYNC
     13  0972					      ENDIF
     14  0972				   .CYCLES    SET	.CYCLES - 3
     15  0972					      ENDIF
     16  0972
     17  0972					      REPEAT	.CYCLES / 2
     18  0972		       ea		      nop
     19  0973					      REPEND
    156  0973
    157  0973		       b9 a0 f8    SMSPRITE8_0 lda	SpriteBuffer+8,y	; 4
    158  0976		       85 5b		      sta	GRP0	; 3
    159  0978		       b9 a0 f8    SMSPRITE8_1 lda	SpriteBuffer2+8,y	; 4
    160  097b		       85 5c		      sta	GRP1	; 3
    161  097d
    162  097d							;@0
    163  097d		       a9 28		      lda	#COLOUR_LINE_3	;#$28			  ; 2
    164  097f		       85 48		      sta	COLUPF	; 3 @5
    165  0981
    166  0981		       b9 08 f8 	      lda	ChessBitmap0+8,y	; 4
    167  0984		       85 4d		      sta	PF0	; 3
    168  0986		       b9 20 f8 	      lda	ChessBitmap1+8,y	; 4
    169  0989		       85 4e		      sta	PF1	; 3
    170  098b		       b9 38 f8 	      lda	ChessBitmap2+8,y	; 4
    171  098e		       85 4f		      sta	PF2	; 3 @26
    172  0990
      0  0990					      SLEEP	8	; 6 @34
      1  0990				   .CYCLES    SET	8
      2  0990
      3  0990				  -	      IF	.CYCLES < 2
      4  0990				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0990				  -	      ERR
      6  0990					      ENDIF
      7  0990
      8  0990				  -	      IF	.CYCLES & 1
      9  0990				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0990				  -	      nop	0
     11  0990				  -	      ELSE
     12  0990				  -	      bit	VSYNC
     13  0990				  -	      ENDIF
     14  0990				  -.CYCLES    SET	.CYCLES - 3
     15  0990					      ENDIF
     16  0990
     17  0990					      REPEAT	.CYCLES / 2
     18  0990		       ea		      nop
     17  0990					      REPEND
     18  0991		       ea		      nop
     17  0991					      REPEND
     18  0992		       ea		      nop
     17  0992					      REPEND
     18  0993		       ea		      nop
     19  0994					      REPEND
    174  0994
    175  0994		       b9 50 f8 	      lda	ChessBitmap3+8,y	; 4
    176  0997		       85 4d		      sta	PF0	; 3
    177  0999		       b9 68 f8 	      lda	ChessBitmap4+8,y	; 4
    178  099c		       85 4e		      sta	PF1	; 3
    179  099e		       b9 80 f8 	      lda	ChessBitmap5+8,y	; 4
    180  09a1		       85 4f		      sta	PF2	; 3 @55
    181  09a3
    182  09a3		       4c 07 f9 	      jmp	.l3	; 3 @58
    183  09a6
    184  09a6
    185  09a6
    186  09a6							;---------------------------------------------------------------------------------------------------
    187  09a6
      0  09a6					      CHECK_RAM_BANK_SIZE	"ROM_SHADOW_SCREEN"
      1  09a6		       01 a6	   .TEMP      =	* - _BANK_START
 ROM_SHADOW_SCREEN (512 byte) SIZE =  $1a6 , FREE= $5a
      2  09a6					      ECHO	"ROM_SHADOW_SCREEN", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3  09a6				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  09a6				  -	      ECHO	"BANK OVERFLOW @ ", "ROM_SHADOW_SCREEN", " size=", * - ORIGIN
      5  09a6				  -	      ERR
      6  09a6					      ENDIF
    189  09a6
    190  09a6							;---------------------------------------------------------------------------------------------------
    191  09a6							;EOF
------- FILE ./chess.asm
------- FILE ROM_SCREEN@3.asm LEVEL 2 PASS 4
      0  09a6					      include	"ROM_SCREEN@3.asm"
      1  09a6
      0  09a6					      SLOT	3
      1  09a6				  -	      IF	(3 < 0) || (3 > 3)
      2  09a6				  -	      ECHO	"Illegal bank address/segment location", 3
      3  09a6				  -	      ERR
      4  09a6					      ENDIF
      5  09a6				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  09a6				   _BANK_SLOT SET	3 * 64
      0  09a6					      NEWBANK	BITMAP2
      1  0c5c ????				      SEG	BITMAP2
      2  0c00					      ORG	_ORIGIN
      3  0c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  0c00				   _BANK_START SET	*
      5  0c00				   BITMAP2_START SET	*
      6  0c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0c00				   BITMAP2    SET	_BANK_SLOT + _CURRENT_BANK
      8  0c00				   _ORIGIN    SET	_ORIGIN + 1024
      4  0c00
      5  0c00							;---------------------------------------------------------------------------------------------------
      6  0c00
      0  0c00					      DEF	ClearRowBitmap
      1  0c00				   SLOT_ClearRowBitmap SET	_BANK_SLOT
      2  0c00				   BANK_ClearRowBitmap SET	SLOT_ClearRowBitmap + _CURRENT_BANK
      3  0c00				   ClearRowBitmap
      4  0c00				   TEMPORARY_VAR SET	Overlay
      5  0c00				   TEMPORARY_OFFSET SET	0
      6  0c00				   VAR_BOUNDARY_ClearRowBitmap SET	TEMPORARY_OFFSET
      7  0c00				   FUNCTION_NAME SET	ClearRowBitmap
      8  0c00					      SUBROUTINE
      9  0c00
      0  0c00					      REFER	CallClear
      1  0c00				  -	      IF	VAREND_CallClear > TEMPORARY_VAR
      2  0c00				  -TEMPORARY_VAR SET	VAREND_CallClear
      3  0c00					      ENDIF
      0  0c00					      VEND	ClearRowBitmap
      1  0c00				  -	      IFNCONST	ClearRowBitmap
      2  0c00				  -	      ECHO	"Incorrect VEND label", ClearRowBitmap
      3  0c00				  -	      ERR
      4  0c00					      ENDIF
      5  0c00		       00 a4	   VAREND_ClearRowBitmap =	TEMPORARY_VAR
     12  0c00
     13  0c00							; No transient variable dependencies/calls
     14  0c00
     15  0c00		       a9 00		      lda	#0
     16  0c02		       a0 90		      ldy	#ROW_BITMAP_SIZE
      0  0c04				   .clearRow  sta@RAM	ChessBitmap-1,y
      1  0c04		       99 ff f9 	      sta	[RAM]+ChessBitmap-1,y
     18  0c07		       88		      dey
     19  0c08		       d0 fa		      bne	.clearRow
     20  0c0a		       60		      rts
     21  0c0b
     22  0c0b
     23  0c0b							;---------------------------------------------------------------------------------------------------
     24  0c0b
     25  0c0b
     26  0c0b							;---------------------------------------------------------------------------------------------------
     27  0c0b
     28  0c0b					      IF	1
      0  0c0b					      DEF	WriteBlank
      1  0c0b				   SLOT_WriteBlank SET	_BANK_SLOT
      2  0c0b				   BANK_WriteBlank SET	SLOT_WriteBlank + _CURRENT_BANK
      3  0c0b				   WriteBlank
      4  0c0b				   TEMPORARY_VAR SET	Overlay
      5  0c0b				   TEMPORARY_OFFSET SET	0
      6  0c0b				   VAR_BOUNDARY_WriteBlank SET	TEMPORARY_OFFSET
      7  0c0b				   FUNCTION_NAME SET	WriteBlank
     30  0c0b					      SUBROUTINE
     31  0c0b
      0  0c0b					      REFER	StartupBankReset
      1  0c0b				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0c0b				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0c0b					      ENDIF
      0  0c0b					      VEND	WriteBlank
      1  0c0b				  -	      IFNCONST	WriteBlank
      2  0c0b				  -	      ECHO	"Incorrect VEND label", WriteBlank
      3  0c0b				  -	      ERR
      4  0c0b					      ENDIF
      5  0c0b		       00 a4	   VAREND_WriteBlank =	TEMPORARY_VAR
     34  0c0b
     35  0c0b		       a9 90		      lda	#<BlankSprite
      0  0c0d					      sta@RAM	SMSPRITE0_0+1
      1  0c0d		       8d 43 fb 	      sta	[RAM]+SMSPRITE0_0+1
      0  0c10					      sta@RAM	SMSPRITE8_0+1
      1  0c10		       8d 74 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  0c13					      sta@RAM	SMSPRITE16_0+1
      1  0c13		       8d 08 fb 	      sta	[RAM]+SMSPRITE16_0+1
      0  0c16					      sta@RAM	SMSPRITE0_1+1
      1  0c16		       8d 48 fb 	      sta	[RAM]+SMSPRITE0_1+1
      0  0c19					      sta@RAM	SMSPRITE8_1+1
      1  0c19		       8d 79 fb 	      sta	[RAM]+SMSPRITE8_1+1
      0  0c1c					      sta@RAM	SMSPRITE16_1+1
      1  0c1c		       8d 0d fb 	      sta	[RAM]+SMSPRITE16_1+1
     42  0c1f
     43  0c1f		       a9 f8		      lda	#>BlankSprite
      0  0c21					      sta@RAM	SMSPRITE0_0+2
      1  0c21		       8d 44 fb 	      sta	[RAM]+SMSPRITE0_0+2
      0  0c24					      sta@RAM	SMSPRITE8_0+2
      1  0c24		       8d 75 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  0c27					      sta@RAM	SMSPRITE16_0+2
      1  0c27		       8d 09 fb 	      sta	[RAM]+SMSPRITE16_0+2
      0  0c2a					      sta@RAM	SMSPRITE0_1+2
      1  0c2a		       8d 49 fb 	      sta	[RAM]+SMSPRITE0_1+2
      0  0c2d					      sta@RAM	SMSPRITE8_1+2
      1  0c2d		       8d 7a fb 	      sta	[RAM]+SMSPRITE8_1+2
      0  0c30					      sta@RAM	SMSPRITE16_1+2
      1  0c30		       8d 0e fb 	      sta	[RAM]+SMSPRITE16_1+2
     50  0c33
     51  0c33		       60		      rts
     52  0c34					      ENDIF
     53  0c34
     54  0c34							;---------------------------------------------------------------------------------------------------
     55  0c34
     56  0c34					      IF	1
      0  0c34					      DEF	WriteCursor
      1  0c34				   SLOT_WriteCursor SET	_BANK_SLOT
      2  0c34				   BANK_WriteCursor SET	SLOT_WriteCursor + _CURRENT_BANK
      3  0c34				   WriteCursor
      4  0c34				   TEMPORARY_VAR SET	Overlay
      5  0c34				   TEMPORARY_OFFSET SET	0
      6  0c34				   VAR_BOUNDARY_WriteCursor SET	TEMPORARY_OFFSET
      7  0c34				   FUNCTION_NAME SET	WriteCursor
     58  0c34					      SUBROUTINE
     59  0c34
      0  0c34					      REFER	StartupBankReset
      1  0c34				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0c34				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0c34					      ENDIF
      0  0c34					      VEND	WriteCursor
      1  0c34				  -	      IFNCONST	WriteCursor
      2  0c34				  -	      ECHO	"Incorrect VEND label", WriteCursor
      3  0c34				  -	      ERR
      4  0c34					      ENDIF
      5  0c34		       00 a4	   VAREND_WriteCursor =	TEMPORARY_VAR
     62  0c34
     63  0c34		       38		      sec
     64  0c35		       a5 88		      lda	cursorX12
     65  0c37		       30 22		      bmi	.exit
     66  0c39		       a2 0a		      ldx	#10
     67  0c3b		       e9 0a	   .sub10     sbc	#10
     68  0c3d		       ca		      dex
     69  0c3e		       b0 fb		      bcs	.sub10
     70  0c40
     71  0c40		       8a		      txa
     72  0c41		       69 80		      adc	#SLOT_DrawRow	;cc implied
     73  0c43		       85 3e		      sta	SET_BANK_RAM
     74  0c45
     75  0c45		       a9 98		      lda	#<SpriteBuffer
      0  0c47					      sta@RAM	SMSPRITE0_0+1
      1  0c47		       8d 43 fb 	      sta	[RAM]+SMSPRITE0_0+1
      0  0c4a					      sta@RAM	SMSPRITE8_0+1
      1  0c4a		       8d 74 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  0c4d					      sta@RAM	SMSPRITE16_0+1
      1  0c4d		       8d 08 fb 	      sta	[RAM]+SMSPRITE16_0+1
     79  0c50		       a9 f8		      lda	#>SpriteBuffer
      0  0c52					      sta@RAM	SMSPRITE0_0+2
      1  0c52		       8d 44 fb 	      sta	[RAM]+SMSPRITE0_0+2
      0  0c55					      sta@RAM	SMSPRITE8_0+2
      1  0c55		       8d 75 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  0c58					      sta@RAM	SMSPRITE16_0+2
      1  0c58		       8d 09 fb 	      sta	[RAM]+SMSPRITE16_0+2
     83  0c5b
     84  0c5b		       60	   .exit      rts
     85  0c5c					      ENDIF
     86  0c5c
     87  0c5c
     88  0c5c							;---------------------------------------------------------------------------------------------------
     89  0c5c
     90  0c5c				  -	      IF	0
     91  0c5c				  -	      DEF	SaveBitmap
     92  0c5c				  -	      SUBROUTINE
     93  0c5c				  -
     94  0c5c				  -	      REFER	SAFE_BackupBitmaps
     95  0c5c				  -	      VEND	SaveBitmap
     96  0c5c				  -
     97  0c5c				  -	      ldy	#71
     98  0c5c				  -.fromTo    lda	ChessBitmap,y
     99  0c5c				  -	      sta@RAM	BackupBitmap,y
    100  0c5c				  -	      lda	ChessBitmap+72,y
    101  0c5c				  -	      sta@RAM	BackupBitmap+72,y
    102  0c5c				  -	      dey
    103  0c5c				  -	      bpl	.fromTo
    104  0c5c				  -	      rts
    105  0c5c					      ENDIF
    106  0c5c
    107  0c5c							;---------------------------------------------------------------------------------------------------
    108  0c5c
    109  0c5c				  -	      IF	0
    110  0c5c				  -
    111  0c5c				  -	      DEF	RestoreBitmap
    112  0c5c				  -	      SUBROUTINE
    113  0c5c				  -
    114  0c5c				  -	      VEND	RestoreBitmap
    115  0c5c				  -
    116  0c5c				  -	      ldy	#71
    117  0c5c				  -.fromTo    lda	BackupBitmap,y
    118  0c5c				  -	      sta@RAM	ChessBitmap,y
    119  0c5c				  -	      lda	BackupBitmap+72,y
    120  0c5c				  -	      sta@RAM	ChessBitmap+72,y
    121  0c5c				  -	      dey
    122  0c5c				  -	      bpl	.fromTo
    123  0c5c				  -	      rts
    124  0c5c					      ENDIF
    125  0c5c
    126  0c5c							;---------------------------------------------------------------------------------------------------
    127  0c5c
    128  0c5c				  -	      IF	0
    129  0c5c				  -
    130  0c5c				  -	      DEF	CopyTextToRowBitmap
    131  0c5c				  -	      SUBROUTINE
    132  0c5c				  -
    133  0c5c				  -	      VEND	CopyTextToRowBitmap
    134  0c5c				  -
    135  0c5c				  -			; An OR-draw, used for placing matricies/text onscreen
    136  0c5c				  -			; Similar to the EOR - first copy data into __pieceShapeBuffer, then call this function
    137  0c5c				  -			; The draw can be bracketed by "SaveBitmap" and "RestoreBitmap" to leave screen
    138  0c5c				  -			; in original state once text disappears
    139  0c5c				  -
    140  0c5c				  -	      ldy	#71
    141  0c5c				  -	      bcs	.rightSide
    142  0c5c				  -
    143  0c5c				  -.copy      lda	__pieceShapeBuffer,y
    144  0c5c				  -	      ora	ChessBitmap,y
    145  0c5c				  -	      sta@RAM	ChessBitmap,y
    146  0c5c				  -	      dey
    147  0c5c				  -	      bpl	.copy
    148  0c5c				  -
    149  0c5c				  -	      rts
    150  0c5c				  -
    151  0c5c				  -.rightSide
    152  0c5c				  -
    153  0c5c				  -	      SUBROUTINE
    154  0c5c				  -
    155  0c5c				  -.copy      lda	__pieceShapeBuffer,y
    156  0c5c				  -	      ora	ChessBitmap+72,y
    157  0c5c				  -	      sta@RAM	ChessBitmap+72,y
    158  0c5c				  -	      dey
    159  0c5c				  -	      bpl	.copy
    160  0c5c				  -
    161  0c5c				  -	      rts
    162  0c5c				  -
    163  0c5c					      ENDIF
    164  0c5c
    165  0c5c							;---------------------------------------------------------------------------------------------------
    166  0c5c
      0  0c5c					      CHECK_RAM_BANK_SIZE	"ROM_SHADOW_SCREEN"
      1  0c5c		       00 5c	   .TEMP      =	* - _BANK_START
 ROM_SHADOW_SCREEN (512 byte) SIZE =  $5c , FREE= $1a4
      2  0c5c					      ECHO	"ROM_SHADOW_SCREEN", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3  0c5c				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  0c5c				  -	      ECHO	"BANK OVERFLOW @ ", "ROM_SHADOW_SCREEN", " size=", * - ORIGIN
      5  0c5c				  -	      ERR
      6  0c5c					      ENDIF
    168  0c5c
    169  0c5c							;---------------------------------------------------------------------------------------------------
    170  0c5c							;EOF
------- FILE ./chess.asm
------- FILE SHADOW_PLY.asm LEVEL 2 PASS 4
      0  0c5c					      include	"SHADOW_PLY.asm"
      1  0c5c							; Chess
      2  0c5c							; Copyright (c) 2019-2020 Andrew Davie
      3  0c5c							; andrew@taswegian.com
      4  0c5c
      5  0c5c
      6  0c5c							;---------------------------------------------------------------------------------------------------
      7  0c5c							; Define the RAM banks
      8  0c5c							; A "PLY" bank represents all the data required on any single ply of the search tree.
      9  0c5c							; The banks are organised sequentially, PLY_BANKS of them starting at RAMBANK_PLY
     10  0c5c							; The startup code copies the ROM shadow into each of these PLY banks, and from then on
     11  0c5c							; they act as independant switchable banks usable for data on each ply during the search.
     12  0c5c							; A ply will hold the move list for that position
     13  0c5c
     14  0c5c
      0  0c5c					      SLOT	2
      1  0c5c				  -	      IF	(2 < 0) || (2 > 3)
      2  0c5c				  -	      ECHO	"Illegal bank address/segment location", 2
      3  0c5c				  -	      ERR
      4  0c5c					      ENDIF
      5  0c5c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  0c5c				   _BANK_SLOT SET	2 * 64
      0  0c5c					      NEWRAMBANK	PLY	; RAM bank for holding the following ROM shadow
      1  0c5c
      2  0c5c
      3  0c5c
      4 U21de ????				      SEG.U	PLY
      5 U2000					      ORG	ORIGIN_RAM
      6 U2000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2000				   _BANK_START SET	*
      8 U2000				   RAMBANK_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2000				   _CURRENT_RAMBANK SET	RAMBANK_PLY
     10 U2000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U2000
     18 U2000							;---------------------------------------------------------------------------------------------------
     19 U2000
     20 U2000		       00 64	   MAX_MOVES  =	100	; big is good
     21 U2000
      0 U2000					      VARIABLE	MoveFrom, MAX_MOVES
      0 U2000					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2000					      LIST	ON
      2 U2000		       00 00 00 00*MoveFrom   ds	MAX_MOVES
      0 U2064					      VARIABLE	MoveTo, MAX_MOVES
      0 U2064					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2064					      LIST	ON
      2 U2064		       00 00 00 00*MoveTo     ds	MAX_MOVES
      0 U20c8					      VARIABLE	MovePiece, MAX_MOVES
      0 U20c8					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2100					      LIST	ON
      2 U2100		       00 00 00 00*MovePiece  ds	MAX_MOVES
      0 U2164					      VARIABLE	MoveCapture, MAX_MOVES
      0 U2164					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2164					      LIST	ON
      2 U2164		       00 00 00 00*MoveCapture ds	MAX_MOVES
     26 U21c8
     27 U21c8
     28 U21c8							;---------------------------------------------------------------------------------------------------
     29 U21c8
     30 U21c8							; The X12 square at which a pawn CAN be taken en-passant. Normally 0.
     31 U21c8							; This is set/cleared whenever a move is made. The flag is indicated in the move description.
     32 U21c8
      0 U21c8					      VARIABLE	savedEvaluation, 2	; THIS node's evaluation - used for reverting moves!
      0 U21c8					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21c8					      LIST	ON
      2 U21c8		       00 00	   savedEvaluation ds	2
      0 U21ca					      VARIABLE	enPassantSquare, 1
      0 U21ca					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21ca					      LIST	ON
      2 U21ca		       00	   enPassantSquare ds	1
      0 U21cb					      VARIABLE	capturedPiece, 1
      0 U21cb					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cb					      LIST	ON
      2 U21cb		       00	   capturedPiece ds	1
      0 U21cc					      VARIABLE	originalPiece, 1
      0 U21cc					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cc					      LIST	ON
      2 U21cc		       00	   originalPiece ds	1
      0 U21cd					      VARIABLE	secondaryPiece, 1	; original piece on secondary (castle, enpassant)
      0 U21cd					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cd					      LIST	ON
      2 U21cd		       00	   secondaryPiece ds	1
      0 U21ce					      VARIABLE	secondarySquare, 1	; original square of secondary piece
      0 U21ce					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21ce					      LIST	ON
      2 U21ce		       00	   secondarySquare ds	1
      0 U21cf					      VARIABLE	secondaryBlank, 1	; square to blank on secondary
      0 U21cf					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cf					      LIST	ON
      2 U21cf		       00	   secondaryBlank ds	1
      0 U21d0					      VARIABLE	moveIndex, 1	; points to first available 'slot' for move storage
      0 U21d0					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d0					      LIST	ON
      2 U21d0		       00	   moveIndex  ds	1
      0 U21d1					      VARIABLE	movePtr, 1
      0 U21d1					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d1					      LIST	ON
      2 U21d1		       00	   movePtr    ds	1
      0 U21d2					      VARIABLE	bestMove, 1
      0 U21d2					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d2					      LIST	ON
      2 U21d2		       00	   bestMove   ds	1
      0 U21d3					      VARIABLE	alpha, 2
      0 U21d3					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21d3					      LIST	ON
      2 U21d3		       00 00	   alpha      ds	2
      0 U21d5					      VARIABLE	beta, 2
      0 U21d5					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21d5					      LIST	ON
      2 U21d5		       00 00	   beta       ds	2
      0 U21d7					      VARIABLE	value, 2
      0 U21d7					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21d7					      LIST	ON
      2 U21d7		       00 00	   value      ds	2
      0 U21d9					      VARIABLE	depthLeft, 1
      0 U21d9					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d9					      LIST	ON
      2 U21d9		       00	   depthLeft  ds	1
      0 U21da					      VARIABLE	restorePiece, 1
      0 U21da					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21da					      LIST	ON
      2 U21da		       00	   restorePiece ds	1
      0 U21db					      VARIABLE	kingSquare, 3	; traversing squares for castle/check
      0 U21db					      OPTIONAL_PAGEBREAK	"Variable", 3
     12 U21db					      LIST	ON
      2 U21db		       00 00 00    kingSquare ds	3
     49 U21de
     50 U21de
      0 U21de					      CHECK_RAM_BANK_SIZE	"SHADOW_PLY"
      1 U21de		       01 de	   .TEMP      =	* - _BANK_START
 SHADOW_PLY (512 byte) SIZE =  $1de , FREE= $22
      2 U21de					      ECHO	"SHADOW_PLY", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3 U21de				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U21de				  -	      ECHO	"BANK OVERFLOW @ ", "SHADOW_PLY", " size=", * - ORIGIN
      5 U21de				  -	      ERR
      6 U21de					      ENDIF
     52 U21de
     53 U21de					      REPEAT	PLY_BANKS-1
      0 U21de					      NEWRAMBANK	.DUMMY_PLY
      1 U21de
      2 U21de
      3 U21de
      4 U2c00 ????				      SEG.U	.DUMMY_PLY
      5 U2400					      ORG	ORIGIN_RAM
      6 U2400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2400				   _BANK_START SET	*
      8 U2400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U2400					      REPEND
      0 U2400					      NEWRAMBANK	.DUMMY_PLY
      1 U2400
      2 U2400
      3 U2400
      4 U2400					      SEG.U	.DUMMY_PLY
      5 U2800					      ORG	ORIGIN_RAM
      6 U2800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2800				   _BANK_START SET	*
      8 U2800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U2800					      REPEND
      0 U2800					      NEWRAMBANK	.DUMMY_PLY
      1 U2800
      2 U2800
      3 U2800
      4 U2800					      SEG.U	.DUMMY_PLY
      5 U2c00					      ORG	ORIGIN_RAM
      6 U2c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2c00				   _BANK_START SET	*
      8 U2c00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     55 U2c00					      REPEND
     56 U2c00
     57 U2c00
     58 U2c00							;---------------------------------------------------------------------------------------------------
     59 U2c00							; EOF
------- FILE ./chess.asm
------- FILE SHADOW_BOARD.asm LEVEL 2 PASS 4
      0 U2c00					      include	"SHADOW_BOARD.asm"
      1 U2c00							; Copyright (C)2020 Andrew Davie
      2 U2c00
      3 U2c00
      4 U2c00							;---------------------------------------------------------------------------------------------------
      0 U2c00					      SLOT	3
      1 U2c00				  -	      IF	(3 < 0) || (3 > 3)
      2 U2c00				  -	      ECHO	"Illegal bank address/segment location", 3
      3 U2c00				  -	      ERR
      4 U2c00					      ENDIF
      5 U2c00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6 U2c00				   _BANK_SLOT SET	3 * 64
      0 U2c00					      NEWRAMBANK	BOARD	; RAM bank for holding the following ROM shadow
      1 U2c00
      2 U2c00
      3 U2c00
      4 U3000 ????				      SEG.U	BOARD
      5 U3000					      ORG	ORIGIN_RAM
      6 U3000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3000				   _BANK_START SET	*
      8 U3000				   RAMBANK_BOARD SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3000				   _CURRENT_RAMBANK SET	RAMBANK_BOARD
     10 U3000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      7 U3000
      8 U3000		       fc 15	   ValidSquare =	ShadowValidSquare + $400
      9 U3000		       fc 79	   Board      =	ShadowBoard + $400
     10 U3000
      0 U3000					      SLOT	2
      1 U3000				  -	      IF	(2 < 0) || (2 > 3)
      2 U3000				  -	      ECHO	"Illegal bank address/segment location", 2
      3 U3000				  -	      ERR
      4 U3000					      ENDIF
      5 U3000				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6 U3000				   _BANK_SLOT SET	2 * 64
      0 U3000					      NEWBANK	SHADOW_BOARD	; copy the following bank to RAMBANK_BOARD
      1  10dd ????				      SEG	SHADOW_BOARD
      2  1000					      ORG	_ORIGIN
      3  1000					      RORG	_BANK_ADDRESS_ORIGIN
      4  1000				   _BANK_START SET	*
      5  1000				   SHADOW_BOARD_START SET	*
      6  1000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1000				   SHADOW_BOARD SET	_BANK_SLOT + _CURRENT_BANK
      8  1000				   _ORIGIN    SET	_ORIGIN + 1024
     13  1000
     14  1000							; Board is a 10 x 12 object which simplifies the generation of moves
     15  1000							; The squares marked '░░░' are illegal. The ("X12") index of each square is the left
     16  1000							; number + the bottom number. Bottom left legal square (AS VISIBLE ON SCREEN) is #22
     17  1000
     18  1000							;     X12 numbering
     19  1000							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     20  1000							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     21  1000							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     22  1000							; 90 ┃░░░┊░░░┊ 92┊ 93┊ 94┊ 95┊ 96┊ 97┊ 98┊ 99┃ 8 BLACK
     23  1000							; 80 ┃░░░┊░░░┊ 82┊ 83┊ 84┊ 85┊ 86┊ 87┊ 88┊ 89┃ 7 BLACK
     24  1000							; 70 ┃░░░┊░░░┊ 72┊ 73┊ 74┊ 75┊ 76┊ 77┊ 78┊ 79┃ 6
     25  1000							; 60 ┃░░░┊░░░┊ 62┊ 63┊ 64┊ 65┊ 66┊ 67┊ 68┊ 69┃ 5
     26  1000							; 50 ┃░░░┊░░░┊ 52┊ 53┊ 54┊ 55┊ 56┊ 57┊ 58┊ 59┃ 4
     27  1000							; 40 ┃░░░┊░░░┊ 42┊ 43┊ 44┊ 45┊ 46┊ 47┊ 48┊ 49┃ 3
     28  1000							; 30 ┃░░░┊░░░┊ 32┊ 33┊ 34┊ 35┊ 36┊ 37┊ 38┊ 39┃ 2 WHITE
     29  1000							; 20 ┃░░░┊░░░┊ 22┊ 23┊ 24┊ 25┊ 26┊ 27┊ 28┊ 29┃ 1 WHITE
     30  1000							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     31  1000							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     32  1000							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     33  1000							;	0   1	2   3	4   5	6   7	8   9
     34  1000							;		A   B	C   D	E   F	G   H
     35  1000
     36  1000							;     HEX X12
     37  1000							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     38  1000							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     39  1000							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     40  1000							; 90 ┃░░░┊░░░┊$5C┊$5D┊$5E┊$5F┊$60┊$61┊$62┊$63┃ 8
     41  1000							; 80 ┃░░░┊░░░┊$52┊$53┊$54┊$55┊$56┊$57┊$58┊$59┃ 7
     42  1000							; 70 ┃░░░┊░░░┊$48┊$49┊$4A┊$4B┊$4C┊$4D┊$4E┊$4F┃ 6
     43  1000							; 60 ┃░░░┊░░░┊$3E┊$3F┊$40┊$41┊$42┊$43┊$44┊$45┃ 5
     44  1000							; 50 ┃░░░┊░░░┊$34┊$35┊$36┊$37┊$38┊$39┊$3A┊$3B┃ 4
     45  1000							; 40 ┃░░░┊░░░┊$2A┊$2B┊$2C┊$2D┊$2E┊$2F┊$30┊$31┃ 3
     46  1000							; 30 ┃░░░┊░░░┊$20┊$21┊$22┊$23┊$24┊$25┊$26|$27┃ 2
     47  1000							; 20 ┃░░░┊░░░┊$16┊$17┊$18┊$19┊$1A┊$1B┊$1C┊$1D┃ 1
     48  1000							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     49  1000							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     50  1000							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     51  1000							;	0   1	2   3	4   5	6   7	8   9
     52  1000							;		A   B	C   D	E   F	G   H
     53  1000
     54  1000
     55  1000							; We put a short buffer before 'ValidSquare' when it is at the start of the bank, so that
     56  1000							; the move indexing (ie., "ValidSquare+{1},x" won't drop off the beginning of the bank
     57  1000							; and sause "segfaults". 21 is the max offset (a knight move). These spare bytes can
     58  1000							; be re-used for something else - we just need to guarantee there are 21 of them there
     59  1000
      0  1000					      ALLOCATE	Valid, 120 + 80 + 21
      0  1000					      OPTIONAL_PAGEBREAK	"Table", 120 + 80 + 21
     12  1000					      LIST	ON
      0  1000					      DEF	Valid
      1  1000				   SLOT_Valid SET	_BANK_SLOT
      2  1000				   BANK_Valid SET	SLOT_Valid + _CURRENT_BANK
      3  1000				   Valid
      4  1000				   TEMPORARY_VAR SET	Overlay
      5  1000				   TEMPORARY_OFFSET SET	0
      6  1000				   VAR_BOUNDARY_Valid SET	TEMPORARY_OFFSET
      7  1000				   FUNCTION_NAME SET	Valid
     61  1000		       00 00 00 00*	      ds	21	; so indexing of "ValidSquare-21,x" won't fail
     62  1015							; Note, we will never index INTO the above bytes - x will always be >= 21
     63  1015							; We just need to make sure that the actual indexing will not have an address before
     64  1015							; the index of outside the page.
     65  1015
      0  1015					      DEF	ShadowValidSquare
      1  1015				   SLOT_ShadowValidSquare SET	_BANK_SLOT
      2  1015				   BANK_ShadowValidSquare SET	SLOT_ShadowValidSquare + _CURRENT_BANK
      3  1015				   ShadowValidSquare
      4  1015				   TEMPORARY_VAR SET	Overlay
      5  1015				   TEMPORARY_OFFSET SET	0
      6  1015				   VAR_BOUNDARY_ShadowValidSquare SET	TEMPORARY_OFFSET
      7  1015				   FUNCTION_NAME SET	ShadowValidSquare
     67  1015
     68  1015
     69  1015							; Use this table to
     70  1015							;   a) Determine if a square is valid (-1 = NO)
     71  1015							;   b) Move pieces without addition.  e.g., "lda ValidSquareTable+10,x" will let you know
     72  1015							;	if a white pawn on square "x" can move "up" the board.
     73  1015
     74  1015		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     75  101f		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     76  1029		       ff ff 16 17*	      .byte.b	-1, -1, 22, 23, 24, 25, 26, 27, 28, 29
     77  1033		       ff ff 20 21*	      .byte.b	-1, -1, 32, 33, 34, 35, 36, 37, 38, 39
     78  103d		       ff ff 2a 2b*	      .byte.b	-1, -1, 42, 43, 44, 45, 46, 47, 48, 49
     79  1047		       ff ff 34 35*	      .byte.b	-1, -1, 52, 53, 54, 55, 56, 57, 58, 59
     80  1051		       ff ff 3e 3f*	      .byte.b	-1, -1, 62, 63, 64, 65, 66, 67, 68, 69
     81  105b		       ff ff 48 49*	      .byte.b	-1, -1, 72, 73, 74, 75, 76, 77, 78, 79
     82  1065		       ff ff 52 53*	      .byte.b	-1, -1, 82, 83, 84, 85, 86, 87, 88, 89
     83  106f		       ff ff 5c 5d*	      .byte.b	-1, -1, 92, 93, 94, 95, 96, 97, 98, 99	; CONTINUES...
     84  1079
      0  1079					      DEF	ShadowBoard
      1  1079				   SLOT_ShadowBoard SET	_BANK_SLOT
      2  1079				   BANK_ShadowBoard SET	SLOT_ShadowBoard + _CURRENT_BANK
      3  1079				   ShadowBoard
      4  1079				   TEMPORARY_VAR SET	Overlay
      5  1079				   TEMPORARY_OFFSET SET	0
      6  1079				   VAR_BOUNDARY_ShadowBoard SET	TEMPORARY_OFFSET
      7  1079				   FUNCTION_NAME SET	ShadowBoard
     86  1079
     87  1079							; A 10X10... we should never write using invalid square
     88  1079							; ON COPY TO RAM BANK, 'BOARD' SELF-INITIALISES TO THE FOLLOWING VALUES
     89  1079							; FROM THEN ON IT'S WRITEABLE (REMEMBER TO +RAM_WRITE) FOR MODIFICATIONS
     90  1079
     91  1079		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     92  1083		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     93  108d
     94  108d					      REPEAT	8
     95  108d		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  108d					      REPEND
     95  1097		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  1097					      REPEND
     95  10a1		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10a1					      REPEND
     95  10ab		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10ab					      REPEND
     95  10b5		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10b5					      REPEND
     95  10bf		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10bf					      REPEND
     95  10c9		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10c9					      REPEND
     95  10d3		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     96  10dd					      REPEND
     97  10dd
     98  10dd							; DON'T OVERSTEP BOUNDS WHEN WRITING BOARD - MAXIMUM INDEX = 99
     99  10dd
    100  10dd
    101  10dd							;---------------------------------------------------------------------------------------------------
    102  10dd							; EOF
------- FILE ./chess.asm
------- FILE BANK_EVAL.asm LEVEL 2 PASS 4
      0  10dd					      include	"BANK_EVAL.asm"
      1  10dd
      0  10dd					      SLOT	3
      1  10dd				  -	      IF	(3 < 0) || (3 > 3)
      2  10dd				  -	      ECHO	"Illegal bank address/segment location", 3
      3  10dd				  -	      ERR
      4  10dd					      ENDIF
      5  10dd				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  10dd				   _BANK_SLOT SET	3 * 64
      3  10dd
      4  10dd
      0  10dd					      NEWRAMBANK	BANK_EVAL
      1  10dd
      2  10dd
      3  10dd
      4 U3400 ????				      SEG.U	BANK_EVAL
      5 U3400					      ORG	ORIGIN_RAM
      6 U3400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3400				   _BANK_START SET	*
      8 U3400				   RAMBANK_BANK_EVAL SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3400				   _CURRENT_RAMBANK SET	RAMBANK_BANK_EVAL
     10 U3400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U3400					      NEWBANK	EVAL
      1  1650 ????				      SEG	EVAL
      2  1400					      ORG	_ORIGIN
      3  1400					      RORG	_BANK_ADDRESS_ORIGIN
      4  1400				   _BANK_START SET	*
      5  1400				   EVAL_START SET	*
      6  1400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1400				   EVAL       SET	_BANK_SLOT + _CURRENT_BANK
      8  1400				   _ORIGIN    SET	_ORIGIN + 1024
      7  1400
      8  1400
      9  1400							; see https://www.chessprogramming.org/Simplified_Evaluation_Function
     10  1400
     11  1400
     12  1400
     13  1400					      MAC	vequ
     14  1400				   VALUE_{1}  =	{2}
     15  1400					      ENDM
     16  1400
     17  1400					      MAC	lobyte
     18  1400					      .byte	<{2}
     19  1400					      ENDM
     20  1400
     21  1400					      MAC	hibyte
     22  1400					      .byte	>{2}
     23  1400					      ENDM
     24  1400
     25  1400
     26  1400					      MAC	valuetable
     27  1400					      {1}	BLANK, 0
     28  1400					      {1}	PAWN, 100	; white
     29  1400					      {1}	PAWN, 100	; black
     30  1400					      {1}	KNIGHT, 320
     31  1400					      {1}	BISHOP, 375
     32  1400					      {1}	ROOK, 575
     33  1400					      {1}	QUEEN, 900
     34  1400					      {1}	KING, 10000
     35  1400					      ENDM
     36  1400
     37  1400
      0  1400					      VALUETABLE	VEQU
      0  1400					      VEQU	BLANK, 0
      1  1400		       00 00	   VALUE_BLANK =	0
      0  1400					      VEQU	PAWN, 100
      1  1400		       00 64	   VALUE_PAWN =	100
      0  1400					      VEQU	PAWN, 100
      1  1400		       00 64	   VALUE_PAWN =	100
      0  1400					      VEQU	KNIGHT, 320
      1  1400		       01 40	   VALUE_KNIGHT =	320
      0  1400					      VEQU	BISHOP, 375
      1  1400		       01 77	   VALUE_BISHOP =	375
      0  1400					      VEQU	ROOK, 575
      1  1400		       02 3f	   VALUE_ROOK =	575
      0  1400					      VEQU	QUEEN, 900
      1  1400		       03 84	   VALUE_QUEEN =	900
      0  1400					      VEQU	KING, 10000
      1  1400		       27 10	   VALUE_KING =	10000
     39  1400
      0  1400					      DEF	PieceValueLO
      1  1400				   SLOT_PieceValueLO SET	_BANK_SLOT
      2  1400				   BANK_PieceValueLO SET	SLOT_PieceValueLO + _CURRENT_BANK
      3  1400				   PieceValueLO
      4  1400				   TEMPORARY_VAR SET	Overlay
      5  1400				   TEMPORARY_OFFSET SET	0
      6  1400				   VAR_BOUNDARY_PieceValueLO SET	TEMPORARY_OFFSET
      7  1400				   FUNCTION_NAME SET	PieceValueLO
      0  1400					      VALUETABLE	LOBYTE
      0  1400					      LOBYTE	BLANK, 0
      1  1400		       00		      .byte.b	<0
      0  1401					      LOBYTE	PAWN, 100
      1  1401		       64		      .byte.b	<100
      0  1402					      LOBYTE	PAWN, 100
      1  1402		       64		      .byte.b	<100
      0  1403					      LOBYTE	KNIGHT, 320
      1  1403		       40		      .byte.b	<320
      0  1404					      LOBYTE	BISHOP, 375
      1  1404		       77		      .byte.b	<375
      0  1405					      LOBYTE	ROOK, 575
      1  1405		       3f		      .byte.b	<575
      0  1406					      LOBYTE	QUEEN, 900
      1  1406		       84		      .byte.b	<900
      0  1407					      LOBYTE	KING, 10000
      1  1407		       10		      .byte.b	<10000
     42  1408
      0  1408					      DEF	PieceValueHI
      1  1408				   SLOT_PieceValueHI SET	_BANK_SLOT
      2  1408				   BANK_PieceValueHI SET	SLOT_PieceValueHI + _CURRENT_BANK
      3  1408				   PieceValueHI
      4  1408				   TEMPORARY_VAR SET	Overlay
      5  1408				   TEMPORARY_OFFSET SET	0
      6  1408				   VAR_BOUNDARY_PieceValueHI SET	TEMPORARY_OFFSET
      7  1408				   FUNCTION_NAME SET	PieceValueHI
      0  1408					      VALUETABLE	HIBYTE
      0  1408					      HIBYTE	BLANK, 0
      1  1408		       00		      .byte.b	>0
      0  1409					      HIBYTE	PAWN, 100
      1  1409		       00		      .byte.b	>100
      0  140a					      HIBYTE	PAWN, 100
      1  140a		       00		      .byte.b	>100
      0  140b					      HIBYTE	KNIGHT, 320
      1  140b		       01		      .byte.b	>320
      0  140c					      HIBYTE	BISHOP, 375
      1  140c		       01		      .byte.b	>375
      0  140d					      HIBYTE	ROOK, 575
      1  140d		       02		      .byte.b	>575
      0  140e					      HIBYTE	QUEEN, 900
      1  140e		       03		      .byte.b	>900
      0  140f					      HIBYTE	KING, 10000
      1  140f		       27		      .byte.b	>10000
     45  1410
     46  1410
     47  1410							;---------------------------------------------------------------------------------------------------
     48  1410							; Vectors to the position value tables for each piece
     49  1410
     50  1410					      MAC	posval
     51  1410					      .byte	0
     52  1410					      .byte	{1}(PositionalValue_PAWN - 22)
     53  1410					      .byte	{1}(PositionalValue_PAWN - 22)
     54  1410					      .byte	{1}(PositionalValue_KNIGHT - 22)
     55  1410					      .byte	{1}(PositionalValue_BISHOP - 22)
     56  1410					      .byte	{1}(PositionalValue_ROOK - 22)
     57  1410					      .byte	{1}(PositionalValue_QUEEN - 22)
     58  1410					      .byte	{1}(PositionalValue_KING_MIDGAME - 22)
     59  1410					      ENDM
     60  1410
      0  1410					      ALLOCATE	PosValVecLO, 8
      0  1410					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1410					      LIST	ON
      0  1410					      DEF	PosValVecLO
      1  1410				   SLOT_PosValVecLO SET	_BANK_SLOT
      2  1410				   BANK_PosValVecLO SET	SLOT_PosValVecLO + _CURRENT_BANK
      3  1410				   PosValVecLO
      4  1410				   TEMPORARY_VAR SET	Overlay
      5  1410				   TEMPORARY_OFFSET SET	0
      6  1410				   VAR_BOUNDARY_PosValVecLO SET	TEMPORARY_OFFSET
      7  1410				   FUNCTION_NAME SET	PosValVecLO
      0  1410					      POSVAL	<
      1  1410		       00		      .byte.b	0
      2  1411		       0a		      .byte.b	<(PositionalValue_PAWN - 22)
      3  1412		       0a		      .byte.b	<(PositionalValue_PAWN - 22)
      4  1413		       5a		      .byte.b	<(PositionalValue_KNIGHT - 22)
      5  1414		       aa		      .byte.b	<(PositionalValue_BISHOP - 22)
      6  1415		       fa		      .byte.b	<(PositionalValue_ROOK - 22)
      7  1416		       4a		      .byte.b	<(PositionalValue_QUEEN - 22)
      8  1417		       9a		      .byte.b	<(PositionalValue_KING_MIDGAME - 22)
      0  1418					      ALLOCATE	PosValVecHI, 8
      0  1418					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1418					      LIST	ON
      0  1418					      DEF	PosValVecHI
      1  1418				   SLOT_PosValVecHI SET	_BANK_SLOT
      2  1418				   BANK_PosValVecHI SET	SLOT_PosValVecHI + _CURRENT_BANK
      3  1418				   PosValVecHI
      4  1418				   TEMPORARY_VAR SET	Overlay
      5  1418				   TEMPORARY_OFFSET SET	0
      6  1418				   VAR_BOUNDARY_PosValVecHI SET	TEMPORARY_OFFSET
      7  1418				   FUNCTION_NAME SET	PosValVecHI
      0  1418					      POSVAL	>
      1  1418		       00		      .byte.b	0
      2  1419		       fc		      .byte.b	>(PositionalValue_PAWN - 22)
      3  141a		       fc		      .byte.b	>(PositionalValue_PAWN - 22)
      4  141b		       fc		      .byte.b	>(PositionalValue_KNIGHT - 22)
      5  141c		       fc		      .byte.b	>(PositionalValue_BISHOP - 22)
      6  141d		       fc		      .byte.b	>(PositionalValue_ROOK - 22)
      7  141e		       fd		      .byte.b	>(PositionalValue_QUEEN - 22)
      8  141f		       fd		      .byte.b	>(PositionalValue_KING_MIDGAME - 22)
     65  1420
     66  1420		       00 32	   BZ	      =	50
     67  1420
     68  1420					      MAC	pval
     69  1420					      .byte	BZ + {1}
     70  1420					      .byte	BZ + {2}
     71  1420					      .byte	BZ + {3}
     72  1420					      .byte	BZ + {4}
     73  1420					      .byte	BZ + {5}
     74  1420					      .byte	BZ + {6}
     75  1420					      .byte	BZ + {7}
     76  1420					      .byte	BZ + {8}
     77  1420					      .byte	BZ
     78  1420					      .byte	BZ
     79  1420					      ENDM		;{ 10 entries }
     80  1420
     81  1420							;---------------------------------------------------------------------------------------------------
     82  1420
     83  1420				   PositionalValue_PAWN
     84  1420
      0  1420					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  1420		       32		      .byte.b	BZ + 0
      2  1421		       32		      .byte.b	BZ + 0
      3  1422		       32		      .byte.b	BZ + 0
      4  1423		       32		      .byte.b	BZ + 0
      5  1424		       32		      .byte.b	BZ + 0
      6  1425		       32		      .byte.b	BZ + 0
      7  1426		       32		      .byte.b	BZ + 0
      8  1427		       32		      .byte.b	BZ + 0
      9  1428		       32		      .byte.b	BZ
     10  1429		       32		      .byte.b	BZ
      0  142a					      PVAL	15, 10, 0, -20, -20, 0, 10, 15
      1  142a		       41		      .byte.b	BZ + 15
      2  142b		       3c		      .byte.b	BZ + 10
      3  142c		       32		      .byte.b	BZ + 0
      4  142d		       1e		      .byte.b	BZ + -20
      5  142e		       1e		      .byte.b	BZ + -20
      6  142f		       32		      .byte.b	BZ + 0
      7  1430		       3c		      .byte.b	BZ + 10
      8  1431		       41		      .byte.b	BZ + 15
      9  1432		       32		      .byte.b	BZ
     10  1433		       32		      .byte.b	BZ
      0  1434					      PVAL	5, -5, -10, 0, 0, -10, -5, 5
      1  1434		       37		      .byte.b	BZ + 5
      2  1435		       2d		      .byte.b	BZ + -5
      3  1436		       28		      .byte.b	BZ + -10
      4  1437		       32		      .byte.b	BZ + 0
      5  1438		       32		      .byte.b	BZ + 0
      6  1439		       28		      .byte.b	BZ + -10
      7  143a		       2d		      .byte.b	BZ + -5
      8  143b		       37		      .byte.b	BZ + 5
      9  143c		       32		      .byte.b	BZ
     10  143d		       32		      .byte.b	BZ
      0  143e					      PVAL	0, 0, 0, 10, 40, 0, 0, 0
      1  143e		       32		      .byte.b	BZ + 0
      2  143f		       32		      .byte.b	BZ + 0
      3  1440		       32		      .byte.b	BZ + 0
      4  1441		       3c		      .byte.b	BZ + 10
      5  1442		       5a		      .byte.b	BZ + 40
      6  1443		       32		      .byte.b	BZ + 0
      7  1444		       32		      .byte.b	BZ + 0
      8  1445		       32		      .byte.b	BZ + 0
      9  1446		       32		      .byte.b	BZ
     10  1447		       32		      .byte.b	BZ
      0  1448					      PVAL	15, 15, 20, 20, 50, 20, 15, 15
      1  1448		       41		      .byte.b	BZ + 15
      2  1449		       41		      .byte.b	BZ + 15
      3  144a		       46		      .byte.b	BZ + 20
      4  144b		       46		      .byte.b	BZ + 20
      5  144c		       64		      .byte.b	BZ + 50
      6  144d		       46		      .byte.b	BZ + 20
      7  144e		       41		      .byte.b	BZ + 15
      8  144f		       41		      .byte.b	BZ + 15
      9  1450		       32		      .byte.b	BZ
     10  1451		       32		      .byte.b	BZ
      0  1452					      PVAL	30, 30, 40, 50, 50, 40, 30, 30
      1  1452		       50		      .byte.b	BZ + 30
      2  1453		       50		      .byte.b	BZ + 30
      3  1454		       5a		      .byte.b	BZ + 40
      4  1455		       64		      .byte.b	BZ + 50
      5  1456		       64		      .byte.b	BZ + 50
      6  1457		       5a		      .byte.b	BZ + 40
      7  1458		       50		      .byte.b	BZ + 30
      8  1459		       50		      .byte.b	BZ + 30
      9  145a		       32		      .byte.b	BZ
     10  145b		       32		      .byte.b	BZ
      0  145c					      PVAL	40, 50, 60, 70, 70, 60, 50, 40
      1  145c		       5a		      .byte.b	BZ + 40
      2  145d		       64		      .byte.b	BZ + 50
      3  145e		       6e		      .byte.b	BZ + 60
      4  145f		       78		      .byte.b	BZ + 70
      5  1460		       78		      .byte.b	BZ + 70
      6  1461		       6e		      .byte.b	BZ + 60
      7  1462		       64		      .byte.b	BZ + 50
      8  1463		       5a		      .byte.b	BZ + 40
      9  1464		       32		      .byte.b	BZ
     10  1465		       32		      .byte.b	BZ
      0  1466					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  1466		       32		      .byte.b	BZ + 0
      2  1467		       32		      .byte.b	BZ + 0
      3  1468		       32		      .byte.b	BZ + 0
      4  1469		       32		      .byte.b	BZ + 0
      5  146a		       32		      .byte.b	BZ + 0
      6  146b		       32		      .byte.b	BZ + 0
      7  146c		       32		      .byte.b	BZ + 0
      8  146d		       32		      .byte.b	BZ + 0
      9  146e		       32		      .byte.b	BZ
     10  146f		       32		      .byte.b	BZ
     93  1470
     94  1470							;---------------------------------------------------------------------------------------------------
     95  1470
     96  1470				   PositionalValue_KNIGHT
     97  1470
      0  1470					      PVAL	-50, -40, -30, -30, -30, -30, -40, -50
      1  1470		       00		      .byte.b	BZ + -50
      2  1471		       0a		      .byte.b	BZ + -40
      3  1472		       14		      .byte.b	BZ + -30
      4  1473		       14		      .byte.b	BZ + -30
      5  1474		       14		      .byte.b	BZ + -30
      6  1475		       14		      .byte.b	BZ + -30
      7  1476		       0a		      .byte.b	BZ + -40
      8  1477		       00		      .byte.b	BZ + -50
      9  1478		       32		      .byte.b	BZ
     10  1479		       32		      .byte.b	BZ
      0  147a					      PVAL	-40, -20, 0, 5, 5, 0, -20, -40
      1  147a		       0a		      .byte.b	BZ + -40
      2  147b		       1e		      .byte.b	BZ + -20
      3  147c		       32		      .byte.b	BZ + 0
      4  147d		       37		      .byte.b	BZ + 5
      5  147e		       37		      .byte.b	BZ + 5
      6  147f		       32		      .byte.b	BZ + 0
      7  1480		       1e		      .byte.b	BZ + -20
      8  1481		       0a		      .byte.b	BZ + -40
      9  1482		       32		      .byte.b	BZ
     10  1483		       32		      .byte.b	BZ
      0  1484					      PVAL	-30, 0, 20, 15, 15, 20, 0, -30
      1  1484		       14		      .byte.b	BZ + -30
      2  1485		       32		      .byte.b	BZ + 0
      3  1486		       46		      .byte.b	BZ + 20
      4  1487		       41		      .byte.b	BZ + 15
      5  1488		       41		      .byte.b	BZ + 15
      6  1489		       46		      .byte.b	BZ + 20
      7  148a		       32		      .byte.b	BZ + 0
      8  148b		       14		      .byte.b	BZ + -30
      9  148c		       32		      .byte.b	BZ
     10  148d		       32		      .byte.b	BZ
      0  148e					      PVAL	-30, 0, 15, 30, 30, 15, 0, -30
      1  148e		       14		      .byte.b	BZ + -30
      2  148f		       32		      .byte.b	BZ + 0
      3  1490		       41		      .byte.b	BZ + 15
      4  1491		       50		      .byte.b	BZ + 30
      5  1492		       50		      .byte.b	BZ + 30
      6  1493		       41		      .byte.b	BZ + 15
      7  1494		       32		      .byte.b	BZ + 0
      8  1495		       14		      .byte.b	BZ + -30
      9  1496		       32		      .byte.b	BZ
     10  1497		       32		      .byte.b	BZ
      0  1498					      PVAL	-30, 5, 15, 30, 30, 15, 5, -30
      1  1498		       14		      .byte.b	BZ + -30
      2  1499		       37		      .byte.b	BZ + 5
      3  149a		       41		      .byte.b	BZ + 15
      4  149b		       50		      .byte.b	BZ + 30
      5  149c		       50		      .byte.b	BZ + 30
      6  149d		       41		      .byte.b	BZ + 15
      7  149e		       37		      .byte.b	BZ + 5
      8  149f		       14		      .byte.b	BZ + -30
      9  14a0		       32		      .byte.b	BZ
     10  14a1		       32		      .byte.b	BZ
      0  14a2					      PVAL	-30, 0, 10, 15, 15, 10, 0, -30
      1  14a2		       14		      .byte.b	BZ + -30
      2  14a3		       32		      .byte.b	BZ + 0
      3  14a4		       3c		      .byte.b	BZ + 10
      4  14a5		       41		      .byte.b	BZ + 15
      5  14a6		       41		      .byte.b	BZ + 15
      6  14a7		       3c		      .byte.b	BZ + 10
      7  14a8		       32		      .byte.b	BZ + 0
      8  14a9		       14		      .byte.b	BZ + -30
      9  14aa		       32		      .byte.b	BZ
     10  14ab		       32		      .byte.b	BZ
      0  14ac					      PVAL	-40, -20, 30, 0, 0, 30, -20, -40
      1  14ac		       0a		      .byte.b	BZ + -40
      2  14ad		       1e		      .byte.b	BZ + -20
      3  14ae		       50		      .byte.b	BZ + 30
      4  14af		       32		      .byte.b	BZ + 0
      5  14b0		       32		      .byte.b	BZ + 0
      6  14b1		       50		      .byte.b	BZ + 30
      7  14b2		       1e		      .byte.b	BZ + -20
      8  14b3		       0a		      .byte.b	BZ + -40
      9  14b4		       32		      .byte.b	BZ
     10  14b5		       32		      .byte.b	BZ
      0  14b6					      PVAL	-50, -20, -30, -30, -30, -30, -20, -50
      1  14b6		       00		      .byte.b	BZ + -50
      2  14b7		       1e		      .byte.b	BZ + -20
      3  14b8		       14		      .byte.b	BZ + -30
      4  14b9		       14		      .byte.b	BZ + -30
      5  14ba		       14		      .byte.b	BZ + -30
      6  14bb		       14		      .byte.b	BZ + -30
      7  14bc		       1e		      .byte.b	BZ + -20
      8  14bd		       00		      .byte.b	BZ + -50
      9  14be		       32		      .byte.b	BZ
     10  14bf		       32		      .byte.b	BZ
    106  14c0
    107  14c0
    108  14c0							;---------------------------------------------------------------------------------------------------
    109  14c0
    110  14c0				   PositionalValue_BISHOP
    111  14c0
      0  14c0					      PVAL	-20, -10, -50, -10, -10, -50, -10, -20
      1  14c0		       1e		      .byte.b	BZ + -20
      2  14c1		       28		      .byte.b	BZ + -10
      3  14c2		       00		      .byte.b	BZ + -50
      4  14c3		       28		      .byte.b	BZ + -10
      5  14c4		       28		      .byte.b	BZ + -10
      6  14c5		       00		      .byte.b	BZ + -50
      7  14c6		       28		      .byte.b	BZ + -10
      8  14c7		       1e		      .byte.b	BZ + -20
      9  14c8		       32		      .byte.b	BZ
     10  14c9		       32		      .byte.b	BZ
      0  14ca					      PVAL	-10, 5, 0, 0, 0, 0, 5, -10
      1  14ca		       28		      .byte.b	BZ + -10
      2  14cb		       37		      .byte.b	BZ + 5
      3  14cc		       32		      .byte.b	BZ + 0
      4  14cd		       32		      .byte.b	BZ + 0
      5  14ce		       32		      .byte.b	BZ + 0
      6  14cf		       32		      .byte.b	BZ + 0
      7  14d0		       37		      .byte.b	BZ + 5
      8  14d1		       28		      .byte.b	BZ + -10
      9  14d2		       32		      .byte.b	BZ
     10  14d3		       32		      .byte.b	BZ
      0  14d4					      PVAL	-10, 10, 10, 10, 10, 10, 10, -10
      1  14d4		       28		      .byte.b	BZ + -10
      2  14d5		       3c		      .byte.b	BZ + 10
      3  14d6		       3c		      .byte.b	BZ + 10
      4  14d7		       3c		      .byte.b	BZ + 10
      5  14d8		       3c		      .byte.b	BZ + 10
      6  14d9		       3c		      .byte.b	BZ + 10
      7  14da		       3c		      .byte.b	BZ + 10
      8  14db		       28		      .byte.b	BZ + -10
      9  14dc		       32		      .byte.b	BZ
     10  14dd		       32		      .byte.b	BZ
      0  14de					      PVAL	-10, 0, 10, 20, 20, 10, 0, -10
      1  14de		       28		      .byte.b	BZ + -10
      2  14df		       32		      .byte.b	BZ + 0
      3  14e0		       3c		      .byte.b	BZ + 10
      4  14e1		       46		      .byte.b	BZ + 20
      5  14e2		       46		      .byte.b	BZ + 20
      6  14e3		       3c		      .byte.b	BZ + 10
      7  14e4		       32		      .byte.b	BZ + 0
      8  14e5		       28		      .byte.b	BZ + -10
      9  14e6		       32		      .byte.b	BZ
     10  14e7		       32		      .byte.b	BZ
      0  14e8					      PVAL	-10, 5, 5, 20, 20, 5, 5, -10
      1  14e8		       28		      .byte.b	BZ + -10
      2  14e9		       37		      .byte.b	BZ + 5
      3  14ea		       37		      .byte.b	BZ + 5
      4  14eb		       46		      .byte.b	BZ + 20
      5  14ec		       46		      .byte.b	BZ + 20
      6  14ed		       37		      .byte.b	BZ + 5
      7  14ee		       37		      .byte.b	BZ + 5
      8  14ef		       28		      .byte.b	BZ + -10
      9  14f0		       32		      .byte.b	BZ
     10  14f1		       32		      .byte.b	BZ
      0  14f2					      PVAL	-10, 0, 5, 10, 10, 5, 0, -10
      1  14f2		       28		      .byte.b	BZ + -10
      2  14f3		       32		      .byte.b	BZ + 0
      3  14f4		       37		      .byte.b	BZ + 5
      4  14f5		       3c		      .byte.b	BZ + 10
      5  14f6		       3c		      .byte.b	BZ + 10
      6  14f7		       37		      .byte.b	BZ + 5
      7  14f8		       32		      .byte.b	BZ + 0
      8  14f9		       28		      .byte.b	BZ + -10
      9  14fa		       32		      .byte.b	BZ
     10  14fb		       32		      .byte.b	BZ
      0  14fc					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      1  14fc		       28		      .byte.b	BZ + -10
      2  14fd		       32		      .byte.b	BZ + 0
      3  14fe		       32		      .byte.b	BZ + 0
      4  14ff		       32		      .byte.b	BZ + 0
      5  1500		       32		      .byte.b	BZ + 0
      6  1501		       32		      .byte.b	BZ + 0
      7  1502		       32		      .byte.b	BZ + 0
      8  1503		       28		      .byte.b	BZ + -10
      9  1504		       32		      .byte.b	BZ
     10  1505		       32		      .byte.b	BZ
      0  1506					      PVAL	-20, -10, -10, -10, -10, -10, -10, -20
      1  1506		       1e		      .byte.b	BZ + -20
      2  1507		       28		      .byte.b	BZ + -10
      3  1508		       28		      .byte.b	BZ + -10
      4  1509		       28		      .byte.b	BZ + -10
      5  150a		       28		      .byte.b	BZ + -10
      6  150b		       28		      .byte.b	BZ + -10
      7  150c		       28		      .byte.b	BZ + -10
      8  150d		       1e		      .byte.b	BZ + -20
      9  150e		       32		      .byte.b	BZ
     10  150f		       32		      .byte.b	BZ
    120  1510
    121  1510
    122  1510							;---------------------------------------------------------------------------------------------------
    123  1510
    124  1510				   PositionalValue_ROOK
    125  1510
      0  1510					      PVAL	-120, -10, 10, 25, 25, 10, -10, -200
      1  1510		       ba		      .byte.b	BZ + -120
      2  1511		       28		      .byte.b	BZ + -10
      3  1512		       3c		      .byte.b	BZ + 10
      4  1513		       4b		      .byte.b	BZ + 25
      5  1514		       4b		      .byte.b	BZ + 25
      6  1515		       3c		      .byte.b	BZ + 10
      7  1516		       28		      .byte.b	BZ + -10
      8  1517		       6a		      .byte.b	BZ + -200
      9  1518		       32		      .byte.b	BZ
     10  1519		       32		      .byte.b	BZ
      0  151a					      PVAL	-75, 0, 0, 0, 0, 0, 0, -200
      1  151a		       e7		      .byte.b	BZ + -75
      2  151b		       32		      .byte.b	BZ + 0
      3  151c		       32		      .byte.b	BZ + 0
      4  151d		       32		      .byte.b	BZ + 0
      5  151e		       32		      .byte.b	BZ + 0
      6  151f		       32		      .byte.b	BZ + 0
      7  1520		       32		      .byte.b	BZ + 0
      8  1521		       6a		      .byte.b	BZ + -200
      9  1522		       32		      .byte.b	BZ
     10  1523		       32		      .byte.b	BZ
      0  1524					      PVAL	-75, 0, 0, 0, 0, 0, 0, -150
      1  1524		       e7		      .byte.b	BZ + -75
      2  1525		       32		      .byte.b	BZ + 0
      3  1526		       32		      .byte.b	BZ + 0
      4  1527		       32		      .byte.b	BZ + 0
      5  1528		       32		      .byte.b	BZ + 0
      6  1529		       32		      .byte.b	BZ + 0
      7  152a		       32		      .byte.b	BZ + 0
      8  152b		       9c		      .byte.b	BZ + -150
      9  152c		       32		      .byte.b	BZ
     10  152d		       32		      .byte.b	BZ
      0  152e					      PVAL	-50, 0, 0, 0, 0, 0, 0, -100
      1  152e		       00		      .byte.b	BZ + -50
      2  152f		       32		      .byte.b	BZ + 0
      3  1530		       32		      .byte.b	BZ + 0
      4  1531		       32		      .byte.b	BZ + 0
      5  1532		       32		      .byte.b	BZ + 0
      6  1533		       32		      .byte.b	BZ + 0
      7  1534		       32		      .byte.b	BZ + 0
      8  1535		       ce		      .byte.b	BZ + -100
      9  1536		       32		      .byte.b	BZ
     10  1537		       32		      .byte.b	BZ
      0  1538					      PVAL	-5, 0, 0, 0, 0, 0, 0, -50
      1  1538		       2d		      .byte.b	BZ + -5
      2  1539		       32		      .byte.b	BZ + 0
      3  153a		       32		      .byte.b	BZ + 0
      4  153b		       32		      .byte.b	BZ + 0
      5  153c		       32		      .byte.b	BZ + 0
      6  153d		       32		      .byte.b	BZ + 0
      7  153e		       32		      .byte.b	BZ + 0
      8  153f		       00		      .byte.b	BZ + -50
      9  1540		       32		      .byte.b	BZ
     10  1541		       32		      .byte.b	BZ
      0  1542					      PVAL	-5, 0, 30, 30, 30, 30, 0, -5
      1  1542		       2d		      .byte.b	BZ + -5
      2  1543		       32		      .byte.b	BZ + 0
      3  1544		       50		      .byte.b	BZ + 30
      4  1545		       50		      .byte.b	BZ + 30
      5  1546		       50		      .byte.b	BZ + 30
      6  1547		       50		      .byte.b	BZ + 30
      7  1548		       32		      .byte.b	BZ + 0
      8  1549		       2d		      .byte.b	BZ + -5
      9  154a		       32		      .byte.b	BZ
     10  154b		       32		      .byte.b	BZ
      0  154c					      PVAL	5, 10, 50, 50, 50, 50, 10, 5
      1  154c		       37		      .byte.b	BZ + 5
      2  154d		       3c		      .byte.b	BZ + 10
      3  154e		       64		      .byte.b	BZ + 50
      4  154f		       64		      .byte.b	BZ + 50
      5  1550		       64		      .byte.b	BZ + 50
      6  1551		       64		      .byte.b	BZ + 50
      7  1552		       3c		      .byte.b	BZ + 10
      8  1553		       37		      .byte.b	BZ + 5
      9  1554		       32		      .byte.b	BZ
     10  1555		       32		      .byte.b	BZ
      0  1556					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  1556		       32		      .byte.b	BZ + 0
      2  1557		       32		      .byte.b	BZ + 0
      3  1558		       32		      .byte.b	BZ + 0
      4  1559		       32		      .byte.b	BZ + 0
      5  155a		       32		      .byte.b	BZ + 0
      6  155b		       32		      .byte.b	BZ + 0
      7  155c		       32		      .byte.b	BZ + 0
      8  155d		       32		      .byte.b	BZ + 0
      9  155e		       32		      .byte.b	BZ
     10  155f		       32		      .byte.b	BZ
    134  1560
    135  1560
    136  1560							;---------------------------------------------------------------------------------------------------
    137  1560
    138  1560				   PositionalValue_QUEEN
    139  1560
      0  1560					      PVAL	-20, -10, -5, -5, -5, -10, -10, -20
      1  1560		       1e		      .byte.b	BZ + -20
      2  1561		       28		      .byte.b	BZ + -10
      3  1562		       2d		      .byte.b	BZ + -5
      4  1563		       2d		      .byte.b	BZ + -5
      5  1564		       2d		      .byte.b	BZ + -5
      6  1565		       28		      .byte.b	BZ + -10
      7  1566		       28		      .byte.b	BZ + -10
      8  1567		       1e		      .byte.b	BZ + -20
      9  1568		       32		      .byte.b	BZ
     10  1569		       32		      .byte.b	BZ
      0  156a					      PVAL	-10, 0, 5, 0, 0, 0, 0, -10
      1  156a		       28		      .byte.b	BZ + -10
      2  156b		       32		      .byte.b	BZ + 0
      3  156c		       37		      .byte.b	BZ + 5
      4  156d		       32		      .byte.b	BZ + 0
      5  156e		       32		      .byte.b	BZ + 0
      6  156f		       32		      .byte.b	BZ + 0
      7  1570		       32		      .byte.b	BZ + 0
      8  1571		       28		      .byte.b	BZ + -10
      9  1572		       32		      .byte.b	BZ
     10  1573		       32		      .byte.b	BZ
      0  1574					      PVAL	-10, 5, 5, 5, 5, 25, 0, -10
      1  1574		       28		      .byte.b	BZ + -10
      2  1575		       37		      .byte.b	BZ + 5
      3  1576		       37		      .byte.b	BZ + 5
      4  1577		       37		      .byte.b	BZ + 5
      5  1578		       37		      .byte.b	BZ + 5
      6  1579		       4b		      .byte.b	BZ + 25
      7  157a		       32		      .byte.b	BZ + 0
      8  157b		       28		      .byte.b	BZ + -10
      9  157c		       32		      .byte.b	BZ
     10  157d		       32		      .byte.b	BZ
      0  157e					      PVAL	-10, 0, 5, 25, 25, 25, 0, -10
      1  157e		       28		      .byte.b	BZ + -10
      2  157f		       32		      .byte.b	BZ + 0
      3  1580		       37		      .byte.b	BZ + 5
      4  1581		       4b		      .byte.b	BZ + 25
      5  1582		       4b		      .byte.b	BZ + 25
      6  1583		       4b		      .byte.b	BZ + 25
      7  1584		       32		      .byte.b	BZ + 0
      8  1585		       28		      .byte.b	BZ + -10
      9  1586		       32		      .byte.b	BZ
     10  1587		       32		      .byte.b	BZ
      0  1588					      PVAL	-5, 0, 15, 55, 55, 55, 0, -5
      1  1588		       2d		      .byte.b	BZ + -5
      2  1589		       32		      .byte.b	BZ + 0
      3  158a		       41		      .byte.b	BZ + 15
      4  158b		       69		      .byte.b	BZ + 55
      5  158c		       69		      .byte.b	BZ + 55
      6  158d		       69		      .byte.b	BZ + 55
      7  158e		       32		      .byte.b	BZ + 0
      8  158f		       2d		      .byte.b	BZ + -5
      9  1590		       32		      .byte.b	BZ
     10  1591		       32		      .byte.b	BZ
      0  1592					      PVAL	-10, 0, 25, 75, 75, 75, 0, -10
      1  1592		       28		      .byte.b	BZ + -10
      2  1593		       32		      .byte.b	BZ + 0
      3  1594		       4b		      .byte.b	BZ + 25
      4  1595		       7d		      .byte.b	BZ + 75
      5  1596		       7d		      .byte.b	BZ + 75
      6  1597		       7d		      .byte.b	BZ + 75
      7  1598		       32		      .byte.b	BZ + 0
      8  1599		       28		      .byte.b	BZ + -10
      9  159a		       32		      .byte.b	BZ
     10  159b		       32		      .byte.b	BZ
      0  159c					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      1  159c		       28		      .byte.b	BZ + -10
      2  159d		       32		      .byte.b	BZ + 0
      3  159e		       32		      .byte.b	BZ + 0
      4  159f		       32		      .byte.b	BZ + 0
      5  15a0		       32		      .byte.b	BZ + 0
      6  15a1		       32		      .byte.b	BZ + 0
      7  15a2		       32		      .byte.b	BZ + 0
      8  15a3		       28		      .byte.b	BZ + -10
      9  15a4		       32		      .byte.b	BZ
     10  15a5		       32		      .byte.b	BZ
      0  15a6					      PVAL	-20, -10, -10, -5, -5, -10, -10, -20
      1  15a6		       1e		      .byte.b	BZ + -20
      2  15a7		       28		      .byte.b	BZ + -10
      3  15a8		       28		      .byte.b	BZ + -10
      4  15a9		       2d		      .byte.b	BZ + -5
      5  15aa		       2d		      .byte.b	BZ + -5
      6  15ab		       28		      .byte.b	BZ + -10
      7  15ac		       28		      .byte.b	BZ + -10
      8  15ad		       1e		      .byte.b	BZ + -20
      9  15ae		       32		      .byte.b	BZ
     10  15af		       32		      .byte.b	BZ
    148  15b0
    149  15b0
    150  15b0							;---------------------------------------------------------------------------------------------------
    151  15b0
    152  15b0				   PositionalValue_KING_MIDGAME
    153  15b0
      0  15b0					      PVAL	0, 0, 30, -20, 0, 10, 40, 10
      1  15b0		       32		      .byte.b	BZ + 0
      2  15b1		       32		      .byte.b	BZ + 0
      3  15b2		       50		      .byte.b	BZ + 30
      4  15b3		       1e		      .byte.b	BZ + -20
      5  15b4		       32		      .byte.b	BZ + 0
      6  15b5		       3c		      .byte.b	BZ + 10
      7  15b6		       5a		      .byte.b	BZ + 40
      8  15b7		       3c		      .byte.b	BZ + 10
      9  15b8		       32		      .byte.b	BZ
     10  15b9		       32		      .byte.b	BZ
      0  15ba					      PVAL	20, 20, 0, -10, -10, 0, 20, 20
      1  15ba		       46		      .byte.b	BZ + 20
      2  15bb		       46		      .byte.b	BZ + 20
      3  15bc		       32		      .byte.b	BZ + 0
      4  15bd		       28		      .byte.b	BZ + -10
      5  15be		       28		      .byte.b	BZ + -10
      6  15bf		       32		      .byte.b	BZ + 0
      7  15c0		       46		      .byte.b	BZ + 20
      8  15c1		       46		      .byte.b	BZ + 20
      9  15c2		       32		      .byte.b	BZ
     10  15c3		       32		      .byte.b	BZ
      0  15c4					      PVAL	-10, -20, -20, -20, -20, -20, -20, -10
      1  15c4		       28		      .byte.b	BZ + -10
      2  15c5		       1e		      .byte.b	BZ + -20
      3  15c6		       1e		      .byte.b	BZ + -20
      4  15c7		       1e		      .byte.b	BZ + -20
      5  15c8		       1e		      .byte.b	BZ + -20
      6  15c9		       1e		      .byte.b	BZ + -20
      7  15ca		       1e		      .byte.b	BZ + -20
      8  15cb		       28		      .byte.b	BZ + -10
      9  15cc		       32		      .byte.b	BZ
     10  15cd		       32		      .byte.b	BZ
      0  15ce					      PVAL	-20, -30, -30, -40, -40, -30, -30, -20
      1  15ce		       1e		      .byte.b	BZ + -20
      2  15cf		       14		      .byte.b	BZ + -30
      3  15d0		       14		      .byte.b	BZ + -30
      4  15d1		       0a		      .byte.b	BZ + -40
      5  15d2		       0a		      .byte.b	BZ + -40
      6  15d3		       14		      .byte.b	BZ + -30
      7  15d4		       14		      .byte.b	BZ + -30
      8  15d5		       1e		      .byte.b	BZ + -20
      9  15d6		       32		      .byte.b	BZ
     10  15d7		       32		      .byte.b	BZ
      0  15d8					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  15d8		       14		      .byte.b	BZ + -30
      2  15d9		       0a		      .byte.b	BZ + -40
      3  15da		       0a		      .byte.b	BZ + -40
      4  15db		       00		      .byte.b	BZ + -50
      5  15dc		       00		      .byte.b	BZ + -50
      6  15dd		       0a		      .byte.b	BZ + -40
      7  15de		       0a		      .byte.b	BZ + -40
      8  15df		       14		      .byte.b	BZ + -30
      9  15e0		       32		      .byte.b	BZ
     10  15e1		       32		      .byte.b	BZ
      0  15e2					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  15e2		       14		      .byte.b	BZ + -30
      2  15e3		       0a		      .byte.b	BZ + -40
      3  15e4		       0a		      .byte.b	BZ + -40
      4  15e5		       00		      .byte.b	BZ + -50
      5  15e6		       00		      .byte.b	BZ + -50
      6  15e7		       0a		      .byte.b	BZ + -40
      7  15e8		       0a		      .byte.b	BZ + -40
      8  15e9		       14		      .byte.b	BZ + -30
      9  15ea		       32		      .byte.b	BZ
     10  15eb		       32		      .byte.b	BZ
      0  15ec					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  15ec		       14		      .byte.b	BZ + -30
      2  15ed		       0a		      .byte.b	BZ + -40
      3  15ee		       0a		      .byte.b	BZ + -40
      4  15ef		       00		      .byte.b	BZ + -50
      5  15f0		       00		      .byte.b	BZ + -50
      6  15f1		       0a		      .byte.b	BZ + -40
      7  15f2		       0a		      .byte.b	BZ + -40
      8  15f3		       14		      .byte.b	BZ + -30
      9  15f4		       32		      .byte.b	BZ
     10  15f5		       32		      .byte.b	BZ
      0  15f6					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  15f6		       14		      .byte.b	BZ + -30
      2  15f7		       0a		      .byte.b	BZ + -40
      3  15f8		       0a		      .byte.b	BZ + -40
      4  15f9		       00		      .byte.b	BZ + -50
      5  15fa		       00		      .byte.b	BZ + -50
      6  15fb		       0a		      .byte.b	BZ + -40
      7  15fc		       0a		      .byte.b	BZ + -40
      8  15fd		       14		      .byte.b	BZ + -30
      9  15fe		       32		      .byte.b	BZ
     10  15ff		       32		      .byte.b	BZ
    162  1600
    163  1600
    164  1600							;---------------------------------------------------------------------------------------------------
    165  1600
    166  1600				   PositionalValue_KING_ENDGAME
    167  1600
      0  1600					      PVAL	-50, -30, -30, -30, -30, -30, -30, -50
      1  1600		       00		      .byte.b	BZ + -50
      2  1601		       14		      .byte.b	BZ + -30
      3  1602		       14		      .byte.b	BZ + -30
      4  1603		       14		      .byte.b	BZ + -30
      5  1604		       14		      .byte.b	BZ + -30
      6  1605		       14		      .byte.b	BZ + -30
      7  1606		       14		      .byte.b	BZ + -30
      8  1607		       00		      .byte.b	BZ + -50
      9  1608		       32		      .byte.b	BZ
     10  1609		       32		      .byte.b	BZ
      0  160a					      PVAL	-30, -30, 0, 0, 0, 0, -30, -30
      1  160a		       14		      .byte.b	BZ + -30
      2  160b		       14		      .byte.b	BZ + -30
      3  160c		       32		      .byte.b	BZ + 0
      4  160d		       32		      .byte.b	BZ + 0
      5  160e		       32		      .byte.b	BZ + 0
      6  160f		       32		      .byte.b	BZ + 0
      7  1610		       14		      .byte.b	BZ + -30
      8  1611		       14		      .byte.b	BZ + -30
      9  1612		       32		      .byte.b	BZ
     10  1613		       32		      .byte.b	BZ
      0  1614					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      1  1614		       14		      .byte.b	BZ + -30
      2  1615		       28		      .byte.b	BZ + -10
      3  1616		       46		      .byte.b	BZ + 20
      4  1617		       50		      .byte.b	BZ + 30
      5  1618		       50		      .byte.b	BZ + 30
      6  1619		       46		      .byte.b	BZ + 20
      7  161a		       28		      .byte.b	BZ + -10
      8  161b		       14		      .byte.b	BZ + -30
      9  161c		       32		      .byte.b	BZ
     10  161d		       32		      .byte.b	BZ
      0  161e					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      1  161e		       14		      .byte.b	BZ + -30
      2  161f		       28		      .byte.b	BZ + -10
      3  1620		       50		      .byte.b	BZ + 30
      4  1621		       5a		      .byte.b	BZ + 40
      5  1622		       5a		      .byte.b	BZ + 40
      6  1623		       50		      .byte.b	BZ + 30
      7  1624		       28		      .byte.b	BZ + -10
      8  1625		       14		      .byte.b	BZ + -30
      9  1626		       32		      .byte.b	BZ
     10  1627		       32		      .byte.b	BZ
      0  1628					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      1  1628		       14		      .byte.b	BZ + -30
      2  1629		       28		      .byte.b	BZ + -10
      3  162a		       50		      .byte.b	BZ + 30
      4  162b		       5a		      .byte.b	BZ + 40
      5  162c		       5a		      .byte.b	BZ + 40
      6  162d		       50		      .byte.b	BZ + 30
      7  162e		       28		      .byte.b	BZ + -10
      8  162f		       14		      .byte.b	BZ + -30
      9  1630		       32		      .byte.b	BZ
     10  1631		       32		      .byte.b	BZ
      0  1632					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      1  1632		       14		      .byte.b	BZ + -30
      2  1633		       28		      .byte.b	BZ + -10
      3  1634		       46		      .byte.b	BZ + 20
      4  1635		       50		      .byte.b	BZ + 30
      5  1636		       50		      .byte.b	BZ + 30
      6  1637		       46		      .byte.b	BZ + 20
      7  1638		       28		      .byte.b	BZ + -10
      8  1639		       14		      .byte.b	BZ + -30
      9  163a		       32		      .byte.b	BZ
     10  163b		       32		      .byte.b	BZ
      0  163c					      PVAL	-30, -20, -10, 0, 0, -10, -20, -30
      1  163c		       14		      .byte.b	BZ + -30
      2  163d		       1e		      .byte.b	BZ + -20
      3  163e		       28		      .byte.b	BZ + -10
      4  163f		       32		      .byte.b	BZ + 0
      5  1640		       32		      .byte.b	BZ + 0
      6  1641		       28		      .byte.b	BZ + -10
      7  1642		       1e		      .byte.b	BZ + -20
      8  1643		       14		      .byte.b	BZ + -30
      9  1644		       32		      .byte.b	BZ
     10  1645		       32		      .byte.b	BZ
      0  1646					      PVAL	-50, -40, -30, -20,- 20, -30, -40, -50
      1  1646		       00		      .byte.b	BZ + -50
      2  1647		       0a		      .byte.b	BZ + -40
      3  1648		       14		      .byte.b	BZ + -30
      4  1649		       1e		      .byte.b	BZ + -20
      5  164a		       1e		      .byte.b	BZ + - 20
      6  164b		       14		      .byte.b	BZ + -30
      7  164c		       0a		      .byte.b	BZ + -40
      8  164d		       00		      .byte.b	BZ + -50
      9  164e		       32		      .byte.b	BZ
     10  164f		       32		      .byte.b	BZ
    176  1650
    177  1650
      0  1650					      CHECK_BANK_SIZE	"BANK_EVAL"
      1  1650		       02 50	   .TEMP      =	* - _BANK_START
 BANK_EVAL (1K) SIZE =  $250 , FREE= $1b0
      2  1650					      ECHO	"BANK_EVAL", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1650				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1650				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_EVAL", " size=", * - ORIGIN
      5  1650				  -	      ERR
      6  1650					      ENDIF
    179  1650
    180  1650							;---------------------------------------------------------------------------------------------------
    181  1650							; EOF
------- FILE ./chess.asm
------- FILE BANK_StateMachine@1#1.asm LEVEL 2 PASS 4
      0  1650					      include	"BANK_StateMachine@1#1.asm"
      0  1650					      SLOT	1
      1  1650				  -	      IF	(1 < 0) || (1 > 3)
      2  1650				  -	      ECHO	"Illegal bank address/segment location", 1
      3  1650				  -	      ERR
      4  1650					      ENDIF
      5  1650				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  1650				   _BANK_SLOT SET	1 * 64
      0  1650					      NEWBANK	STATEMACHINE
      1  1bad ????				      SEG	STATEMACHINE
      2  1800					      ORG	_ORIGIN
      3  1800					      RORG	_BANK_ADDRESS_ORIGIN
      4  1800				   _BANK_START SET	*
      5  1800				   STATEMACHINE_START SET	*
      6  1800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1800				   STATEMACHINE SET	_BANK_SLOT + _CURRENT_BANK
      8  1800				   _ORIGIN    SET	_ORIGIN + 1024
      3  1800
      4  1800
      5  1800							; Banks holding data (ply 0 doubles as WHITE, and ply 1 as BLACK)
      6  1800
      7  1800
      8  1800		       00 10	   CURSOR_MOVE_SPEED =	16
      9  1800		       00 14	   CAP_SPEED  =	20
     10  1800		       00 28	   HOLD_DELAY =	40
     11  1800
     12  1800
     13  1800							;---------------------------------------------------------------------------------------------------
     14  1800
     15  1800
     16  1800							;---------------------------------------------------------------------------------------------------
     17  1800
      0  1800					      DEF	aiStartMoveGen
      1  1800				   SLOT_aiStartMoveGen SET	_BANK_SLOT
      2  1800				   BANK_aiStartMoveGen SET	SLOT_aiStartMoveGen + _CURRENT_BANK
      3  1800				   aiStartMoveGen
      4  1800				   TEMPORARY_VAR SET	Overlay
      5  1800				   TEMPORARY_OFFSET SET	0
      6  1800				   VAR_BOUNDARY_aiStartMoveGen SET	TEMPORARY_OFFSET
      7  1800				   FUNCTION_NAME SET	aiStartMoveGen
     19  1800					      SUBROUTINE
     20  1800
      0  1800					      REFER	AiStateMachine
      1  1800				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1800				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1800					      ENDIF
      0  1800					      VEND	aiStartMoveGen
      1  1800				  -	      IFNCONST	aiStartMoveGen
      2  1800				  -	      ECHO	"Incorrect VEND label", aiStartMoveGen
      3  1800				  -	      ERR
      4  1800					      ENDIF
      5  1800		       00 a4	   VAREND_aiStartMoveGen =	TEMPORARY_VAR
     23  1800
     24  1800							; To assist with castling, generate the moves for the opponent, giving us effectively
     25  1800							; a list of squares that are being attacked. The castling can't happen if the king is
     26  1800							; in check or if the squares it would have to move over are in check
     27  1800
     28  1800							; we don't need to worry about this if K has moved, or relevant R has moved or if
     29  1800							; the squares between are occupied. We can tell THAT by examining the movelist to see
     30  1800							; if there are K-moves marked "FLAG_CASTLE" - and the relevant squares
     31  1800
     32  1800							;inc currentPly
     33  1800							;jsr InitialiseMoveGeneration
     34  1800
      0  1800					      PHASE	AI_StepMoveGen
      1  1800		       a9 0c		      lda	#AI_StepMoveGen
      2  1802		       85 8b		      sta	aiState
     36  1804		       60		      rts
     37  1805
     38  1805
     39  1805							;---------------------------------------------------------------------------------------------------
     40  1805
      0  1805					      DEF	aiInCheckBackup
      1  1805				   SLOT_aiInCheckBackup SET	_BANK_SLOT
      2  1805				   BANK_aiInCheckBackup SET	SLOT_aiInCheckBackup + _CURRENT_BANK
      3  1805				   aiInCheckBackup
      4  1805				   TEMPORARY_VAR SET	Overlay
      5  1805				   TEMPORARY_OFFSET SET	0
      6  1805				   VAR_BOUNDARY_aiInCheckBackup SET	TEMPORARY_OFFSET
      7  1805				   FUNCTION_NAME SET	aiInCheckBackup
     42  1805					      SUBROUTINE
     43  1805
      0  1805					      REFER	AiStateMachine
      1  1805				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1805				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1805					      ENDIF
      0  1805					      VEND	aiInCheckBackup
      1  1805				  -	      IFNCONST	aiInCheckBackup
      2  1805				  -	      ECHO	"Incorrect VEND label", aiInCheckBackup
      3  1805				  -	      ERR
      4  1805					      ENDIF
      5  1805		       00 a4	   VAREND_aiInCheckBackup =	TEMPORARY_VAR
     46  1805
     47  1805							; We're about to draw some large text on the screen
     48  1805							; Make a backup copy of all of the row bitmaps, so that we can restore once text is done
     49  1805
     50  1805		       c6 84		      dec	drawCount
     51  1807		       30 02		      bmi	.exit	; done all rows
     52  1809		       a4 84		      ldy	drawCount
     53  180b				  -	      IF	0
     54  180b				  -	      jmp	SAFE_BackupBitmaps
     55  180b					      ENDIF
     56  180b
      0  180b				   .exit      PHASE	AI_InCheckDelay
      1  180b		       a9 1e		      lda	#AI_InCheckDelay
      2  180d		       85 8b		      sta	aiState
     58  180f		       60		      rts
     59  1810
     60  1810
     61  1810							;---------------------------------------------------------------------------------------------------
     62  1810
      0  1810					      DEF	aiInCheckDelay
      1  1810				   SLOT_aiInCheckDelay SET	_BANK_SLOT
      2  1810				   BANK_aiInCheckDelay SET	SLOT_aiInCheckDelay + _CURRENT_BANK
      3  1810				   aiInCheckDelay
      4  1810				   TEMPORARY_VAR SET	Overlay
      5  1810				   TEMPORARY_OFFSET SET	0
      6  1810				   VAR_BOUNDARY_aiInCheckDelay SET	TEMPORARY_OFFSET
      7  1810				   FUNCTION_NAME SET	aiInCheckDelay
     64  1810					      SUBROUTINE
     65  1810
      0  1810					      REFER	AiStateMachine
      1  1810				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1810				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1810					      ENDIF
      0  1810					      VEND	aiInCheckDelay
      1  1810				  -	      IFNCONST	aiInCheckDelay
      2  1810				  -	      ECHO	"Incorrect VEND label", aiInCheckDelay
      3  1810				  -	      ERR
      4  1810					      ENDIF
      5  1810		       00 a4	   VAREND_aiInCheckDelay =	TEMPORARY_VAR
     68  1810
     69  1810		       c6 89		      dec	mdelay
     70  1812		       d0 08		      bne	.exit
     71  1814
     72  1814		       a9 00		      lda	#0
     73  1816		       85 49		      sta	COLUBK
     74  1818
      0  1818					      PHASE	AI_BeginSelectMovePhase
      1  1818		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  181a		       85 8b		      sta	aiState
     76  181c		       60	   .exit      rts
     77  181d
     78  181d
     79  181d							;---------------------------------------------------------------------------------------------------
     80  181d
      0  181d					      DEF	aiBeginSelectMovePhase
      1  181d				   SLOT_aiBeginSelectMovePhase SET	_BANK_SLOT
      2  181d				   BANK_aiBeginSelectMovePhase SET	SLOT_aiBeginSelectMovePhase + _CURRENT_BANK
      3  181d				   aiBeginSelectMovePhase
      4  181d				   TEMPORARY_VAR SET	Overlay
      5  181d				   TEMPORARY_OFFSET SET	0
      6  181d				   VAR_BOUNDARY_aiBeginSelectMovePhase SET	TEMPORARY_OFFSET
      7  181d				   FUNCTION_NAME SET	aiBeginSelectMovePhase
     82  181d					      SUBROUTINE
     83  181d
      0  181d					      REFER	AiStateMachine
      1  181d				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  181d				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  181d					      ENDIF
      0  181d					      VEND	aiBeginSelectMovePhase
      1  181d				  -	      IFNCONST	aiBeginSelectMovePhase
      2  181d				  -	      ECHO	"Incorrect VEND label", aiBeginSelectMovePhase
      3  181d				  -	      ERR
      4  181d					      ENDIF
      5  181d		       00 a4	   VAREND_aiBeginSelectMovePhase =	TEMPORARY_VAR
     86  181d
     87  181d
     88  181d		       a9 02		      lda	#$2
     89  181f		       85 46		      sta	COLUP0
     90  1821		       a2 04		      ldx	#%100
     91  1823		       86 4a		      stx	CTRLPF	; under
     92  1825
     93  1825		       a9 00		      lda	#0
     94  1827		       85 89		      sta	mdelay	;?
     95  1829		       85 8e		      sta	aiFlashPhase	; odd/even for flashing pieces
     96  182b
     97  182b		       a9 28		      lda	#CAP_SPEED*2
     98  182d		       85 8c		      sta	aiFlashDelay
     99  182f
    100  182f		       a9 ff		      lda	#-1
    101  1831		       85 85		      sta	fromX12
    102  1833		       85 86		      sta	toX12
    103  1835
    104  1835		       46 a3		      lsr	randomness
    105  1837
    106  1837
      0  1837					      PHASE	AI_FlashComputerMove
      1  1837		       a9 00		      lda	#AI_FlashComputerMove
      2  1839		       85 8b		      sta	aiState
    108  183b		       60		      rts
    109  183c
    110  183c							;---------------------------------------------------------------------------------------------------
    111  183c
      0  183c					      DEF	aiFlashComputerMove
      1  183c				   SLOT_aiFlashComputerMove SET	_BANK_SLOT
      2  183c				   BANK_aiFlashComputerMove SET	SLOT_aiFlashComputerMove + _CURRENT_BANK
      3  183c				   aiFlashComputerMove
      4  183c				   TEMPORARY_VAR SET	Overlay
      5  183c				   TEMPORARY_OFFSET SET	0
      6  183c				   VAR_BOUNDARY_aiFlashComputerMove SET	TEMPORARY_OFFSET
      7  183c				   FUNCTION_NAME SET	aiFlashComputerMove
    113  183c					      SUBROUTINE
    114  183c
      0  183c					      REFER	AiStateMachine
      1  183c				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  183c				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  183c					      ENDIF
      0  183c					      VEND	aiFlashComputerMove
      1  183c				  -	      IFNCONST	aiFlashComputerMove
      2  183c				  -	      ECHO	"Incorrect VEND label", aiFlashComputerMove
      3  183c				  -	      ERR
      4  183c					      ENDIF
      5  183c		       00 a4	   VAREND_aiFlashComputerMove =	TEMPORARY_VAR
    117  183c
    118  183c		       a5 80		      lda	squareToDraw
    119  183e		       30 1f		      bmi	.initial2	; startup - no computer move to show
    120  1840
    121  1840							; "squareToDraw" is the piece that should flash while human waits
    122  1840
    123  1840		       ad 80 02 	      lda	SWCHA
    124  1843		       29 f0		      and	#$F0
    125  1845		       c9 f0		      cmp	#$F0
    126  1847		       f0 08		      beq	.nodir
    127  1849
    128  1849		       a9 01		      lda	#1
    129  184b		       85 8c		      sta	aiFlashDelay
    130  184d		       25 8e		      and	aiFlashPhase
    131  184f		       f0 0e		      beq	.initial
    132  1851
    133  1851		       c6 8c	   .nodir     dec	aiFlashDelay
    134  1853		       d0 0e		      bne	.exit	; don't flash
    135  1855		       a9 28		      lda	#CAP_SPEED*2
    136  1857		       85 8c		      sta	aiFlashDelay
    137  1859
    138  1859		       e6 8e		      inc	aiFlashPhase
    139  185b
    140  185b		       20 ad f0 	      jsr	CopySinglePiece	;@0
    141  185e		       60		      rts
    142  185f
    143  185f				   .initial
    144  185f
    145  185f							;SWAP
      0  185f				   .initial2  PHASE	AI_SelectStartSquare
      1  185f		       a9 02		      lda	#AI_SelectStartSquare
      2  1861		       85 8b		      sta	aiState
    147  1863
    148  1863		       60	   .exit      rts
    149  1864
    150  1864
    151  1864							;---------------------------------------------------------------------------------------------------
    152  1864
      0  1864					      DEF	aiSelectStartSquare
      1  1864				   SLOT_aiSelectStartSquare SET	_BANK_SLOT
      2  1864				   BANK_aiSelectStartSquare SET	SLOT_aiSelectStartSquare + _CURRENT_BANK
      3  1864				   aiSelectStartSquare
      4  1864				   TEMPORARY_VAR SET	Overlay
      5  1864				   TEMPORARY_OFFSET SET	0
      6  1864				   VAR_BOUNDARY_aiSelectStartSquare SET	TEMPORARY_OFFSET
      7  1864				   FUNCTION_NAME SET	aiSelectStartSquare
    154  1864					      SUBROUTINE
    155  1864
      0  1864					      REFER	AiStateMachine
      1  1864				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1864				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1864					      ENDIF
      0  1864					      VEND	aiSelectStartSquare
      1  1864				  -	      IFNCONST	aiSelectStartSquare
      2  1864				  -	      ECHO	"Incorrect VEND label", aiSelectStartSquare
      3  1864				  -	      ERR
      4  1864					      ENDIF
      5  1864		       00 a4	   VAREND_aiSelectStartSquare =	TEMPORARY_VAR
    158  1864
      0  1864					      NEXT_RANDOM
      1  1864		       a5 81		      lda	rnd
      2  1866		       4a		      lsr
      3  1867		       90 02		      bcc	.skipEOR
      4  1869		       49 fe		      eor	#RND_EOR_VAL
      5  186b		       85 81	   .skipEOR   sta	rnd
    160  186d
    161  186d		       20 29 f6 	      jsr	moveCursor
    162  1870
    163  1870							; Search the player's movelist for the square, so we can set cursor colour
    164  1870
    165  1870		       a9 89		      lda	#RAMBANK_PLY+1	;currentPly
    166  1872		       85 3e		      sta	SET_BANK_RAM	;@2
    167  1874
    168  1874		       a5 88		      lda	cursorX12
    169  1876		       85 85		      sta	fromX12
    170  1878
      0  1878					      ldy@PLY	moveIndex
      1  1878		       ac d0 f9 	      ldy	moveIndex
    172  187b		       30 0d		      bmi	.done
    173  187d
    174  187d		       d9 00 f8    .scan      cmp	MoveFrom,y
    175  1880		       f0 03		      beq	.scanned
    176  1882		       88		      dey
    177  1883		       10 f8		      bpl	.scan
    178  1885
      0  1885				   .scanned   lda@PLY	MovePiece,y
      1  1885		       b9 00 f9 	      lda	MovePiece,y
    180  1888		       85 96		      sta	fromPiece
    181  188a
    182  188a		       c6 8a	   .done      dec	ccur	; pulse colour for valid squares
    183  188c		       20 b1 f4 	      jsr	setCursorColours
    184  188f
    185  188f		       98		      tya
    186  1890		       05 4c		      ora	INPT4
    187  1892		       30 04		      bmi	.exit	; illegal square or no button press
    188  1894
      0  1894					      PHASE	AI_StartSquareSelected
      1  1894		       a9 03		      lda	#AI_StartSquareSelected
      2  1896		       85 8b		      sta	aiState
    190  1898
    191  1898		       60	   .exit      rts
    192  1899
    193  1899							;---------------------------------------------------------------------------------------------------
    194  1899
      0  1899					      DEF	setCursorPriority
      1  1899				   SLOT_setCursorPriority SET	_BANK_SLOT
      2  1899				   BANK_setCursorPriority SET	SLOT_setCursorPriority + _CURRENT_BANK
      3  1899				   setCursorPriority
      4  1899				   TEMPORARY_VAR SET	Overlay
      5  1899				   TEMPORARY_OFFSET SET	0
      6  1899				   VAR_BOUNDARY_setCursorPriority SET	TEMPORARY_OFFSET
      7  1899				   FUNCTION_NAME SET	setCursorPriority
    196  1899					      SUBROUTINE
    197  1899
      0  1899					      REFER	moveCursor
      1  1899					      IF	VAREND_moveCursor > TEMPORARY_VAR
      2  1899				   TEMPORARY_VAR SET	VAREND_moveCursor
      3  1899					      ENDIF
      0  1899					      VEND	setCursorPriority
      1  1899				  -	      IFNCONST	setCursorPriority
      2  1899				  -	      ECHO	"Incorrect VEND label", setCursorPriority
      3  1899				  -	      ERR
      4  1899					      ENDIF
      5  1899		       00 a5	   VAREND_setCursorPriority =	TEMPORARY_VAR
    200  1899
    201  1899		       98		      tya
    202  189a		       48		      pha
    203  189b
    204  189b		       a2 04		      ldx	#%100
    205  189d
    206  189d		       a4 88		      ldy	cursorX12
    207  189f		       30 0b		      bmi	.under
    208  18a1
    209  18a1		       a9 cc		      lda	#RAMBANK_BOARD
    210  18a3		       85 3e		      sta	SET_BANK_RAM	;@3
    211  18a5		       b9 79 fc 	      lda	Board,y
    212  18a8		       d0 02		      bne	.under
    213  18aa		       a2 00		      ldx	#0
    214  18ac		       86 4a	   .under     stx	CTRLPF	; UNDER
    215  18ae
    216  18ae		       68		      pla
    217  18af		       a8		      tay
    218  18b0		       60		      rts
    219  18b1
    220  18b1							;---------------------------------------------------------------------------------------------------
    221  18b1
      0  18b1					      DEF	setCursorColours
      1  18b1				   SLOT_setCursorColours SET	_BANK_SLOT
      2  18b1				   BANK_setCursorColours SET	SLOT_setCursorColours + _CURRENT_BANK
      3  18b1				   setCursorColours
      4  18b1				   TEMPORARY_VAR SET	Overlay
      5  18b1				   TEMPORARY_OFFSET SET	0
      6  18b1				   VAR_BOUNDARY_setCursorColours SET	TEMPORARY_OFFSET
      7  18b1				   FUNCTION_NAME SET	setCursorColours
    223  18b1					      SUBROUTINE
    224  18b1
      0  18b1					      REFER	aiSelectStartSquare
      1  18b1				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  18b1					      ENDIF
      0  18b1					      REFER	aiDrawMoves
      1  18b1				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  18b1					      ENDIF
      0  18b1					      REFER	aiUnDrawTargetSquares
      1  18b1				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  18b1					      ENDIF
      0  18b1					      REFER	aiShowMoveCaptures
      1  18b1				  -	      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  18b1					      ENDIF
      0  18b1					      REFER	aiSlowFlash
      1  18b1				  -	      IF	VAREND_aiSlowFlash > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiSlowFlash
      3  18b1					      ENDIF
      0  18b1					      REFER	aiSelectDestinationSquare
      1  18b1				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  18b1					      ENDIF
      0  18b1					      VEND	setCursorColours
      1  18b1				  -	      IFNCONST	setCursorColours
      2  18b1				  -	      ECHO	"Incorrect VEND label", setCursorColours
      3  18b1				  -	      ERR
      4  18b1					      ENDIF
      5  18b1		       00 a4	   VAREND_setCursorColours =	TEMPORARY_VAR
    232  18b1
    233  18b1							; pass y=-1 if move is NOT in the movelist
    234  18b1							; preserve y
    235  18b1
    236  18b1		       a9 40		      lda	#$40
    237  18b3
    238  18b3		       c0 ff		      cpy	#-1
    239  18b5		       f0 0a		      beq	.writeCursorCol	; NOT in the movelist
    240  18b7
    241  18b7		       a5 8a		      lda	ccur
    242  18b9		       4a		      lsr
    243  18ba		       4a		      lsr
    244  18bb		       4a		      lsr
    245  18bc		       29 03		      and	#3
    246  18be		       18		      clc
    247  18bf		       69 d0		      adc	#$D0	;COLOUR_LINE_1
    248  18c1
    249  18c1		       85 46	   .writeCursorCol sta	COLUP0
    250  18c3		       60		      rts
    251  18c4
    252  18c4
    253  18c4							;---------------------------------------------------------------------------------------------------
    254  18c4
    255  18c4							;	    RLDU RLD  RL U RL	R DU R D  R  U R     LDU  LD   L U  L	  DU   D     U
    256  18c4							;	    0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    257  18c4
      0  18c4					      ALLOCATE	JoyCombined, 16
      0  18c4					      OPTIONAL_PAGEBREAK	"Table", 16
     12  18c4					      LIST	ON
      0  18c4					      DEF	JoyCombined
      1  18c4				   SLOT_JoyCombined SET	_BANK_SLOT
      2  18c4				   BANK_JoyCombined SET	SLOT_JoyCombined + _CURRENT_BANK
      3  18c4				   JoyCombined
      4  18c4				   TEMPORARY_VAR SET	Overlay
      5  18c4				   TEMPORARY_OFFSET SET	0
      6  18c4				   VAR_BOUNDARY_JoyCombined SET	TEMPORARY_OFFSET
      7  18c4				   FUNCTION_NAME SET	JoyCombined
    259  18c4		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, -1, 0
    260  18d4
      0  18d4					      ALLOCATE	JoyMoveCursor, 16
      0  18d4					      OPTIONAL_PAGEBREAK	"Table", 16
     12  18d4					      LIST	ON
      0  18d4					      DEF	JoyMoveCursor
      1  18d4				   SLOT_JoyMoveCursor SET	_BANK_SLOT
      2  18d4				   BANK_JoyMoveCursor SET	SLOT_JoyMoveCursor + _CURRENT_BANK
      3  18d4				   JoyMoveCursor
      4  18d4				   TEMPORARY_VAR SET	Overlay
      5  18d4				   TEMPORARY_OFFSET SET	0
      6  18d4				   VAR_BOUNDARY_JoyMoveCursor SET	TEMPORARY_OFFSET
      7  18d4				   FUNCTION_NAME SET	JoyMoveCursor
    262  18d4		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, -9, 11, 1, 0, -11, 9, -1, 0, -10, 10, 0
    263  18e4
    264  18e4
    265  18e4							;---------------------------------------------------------------------------------------------------
    266  18e4
      0  18e4					      DEF	aiStartSquareSelected
      1  18e4				   SLOT_aiStartSquareSelected SET	_BANK_SLOT
      2  18e4				   BANK_aiStartSquareSelected SET	SLOT_aiStartSquareSelected + _CURRENT_BANK
      3  18e4				   aiStartSquareSelected
      4  18e4				   TEMPORARY_VAR SET	Overlay
      5  18e4				   TEMPORARY_OFFSET SET	0
      6  18e4				   VAR_BOUNDARY_aiStartSquareSelected SET	TEMPORARY_OFFSET
      7  18e4				   FUNCTION_NAME SET	aiStartSquareSelected
    268  18e4					      SUBROUTINE
    269  18e4
      0  18e4					      REFER	AiStateMachine
      1  18e4				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  18e4				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  18e4					      ENDIF
      0  18e4					      VEND	aiStartSquareSelected
      1  18e4				  -	      IFNCONST	aiStartSquareSelected
      2  18e4				  -	      ECHO	"Incorrect VEND label", aiStartSquareSelected
      3  18e4				  -	      ERR
      4  18e4					      ENDIF
      5  18e4		       00 a4	   VAREND_aiStartSquareSelected =	TEMPORARY_VAR
    272  18e4
    273  18e4
    274  18e4							; Mark all the valid moves for the selected piece on the board
    275  18e4							; and then start pulsing the piece
    276  18e4							; AND start choosing for selection of TO square
    277  18e4
    278  18e4							; Iterate the movelist and for all from squares which = drawPieceNumber
    279  18e4							; then draw a BLANK at that square
    280  18e4							; do 1 by one, when none found then increment state
    281  18e4
    282  18e4		       a5 88		      lda	cursorX12
    283  18e6		       85 80		      sta	squareToDraw
    284  18e8
    285  18e8		       a9 0a		      lda	#10
    286  18ea		       85 8c		      sta	aiFlashDelay
    287  18ec
    288  18ec		       a9 00		      lda	#0
    289  18ee		       85 86		      sta	toX12	;aiToSquareX12
    290  18f0		       85 8e		      sta	aiFlashPhase	; for debounce exit timing
    291  18f2
    292  18f2		       a9 ff		      lda	#-1
    293  18f4		       85 8d		      sta	aiMoveIndex
    294  18f6
    295  18f6		       a9 28		      lda	#HOLD_DELAY
    296  18f8		       85 89		      sta	mdelay	; hold-down delay before moves are shown
    297  18fa
      0  18fa					      PHASE	AI_DrawMoves
      1  18fa		       a9 04		      lda	#AI_DrawMoves
      2  18fc		       85 8b		      sta	aiState
    299  18fe		       60		      rts
    300  18ff
    301  18ff
    302  18ff							;---------------------------------------------------------------------------------------------------
    303  18ff
      0  18ff					      DEF	aiDrawMoves
      1  18ff				   SLOT_aiDrawMoves SET	_BANK_SLOT
      2  18ff				   BANK_aiDrawMoves SET	SLOT_aiDrawMoves + _CURRENT_BANK
      3  18ff				   aiDrawMoves
      4  18ff				   TEMPORARY_VAR SET	Overlay
      5  18ff				   TEMPORARY_OFFSET SET	0
      6  18ff				   VAR_BOUNDARY_aiDrawMoves SET	TEMPORARY_OFFSET
      7  18ff				   FUNCTION_NAME SET	aiDrawMoves
    305  18ff					      SUBROUTINE
    306  18ff
      0  18ff					      REFER	AiStateMachine
      1  18ff				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  18ff				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  18ff					      ENDIF
      0  18ff					      VEND	aiDrawMoves
      1  18ff				  -	      IFNCONST	aiDrawMoves
      2  18ff				  -	      ECHO	"Incorrect VEND label", aiDrawMoves
      3  18ff				  -	      ERR
      4  18ff					      ENDIF
      5  18ff		       00 a4	   VAREND_aiDrawMoves =	TEMPORARY_VAR
    309  18ff
    310  18ff		       c6 8a		      dec	ccur
    311  1901		       20 b1 f4 	      jsr	setCursorColours
    312  1904
    313  1904		       c6 89		      dec	mdelay
    314  1906		       d0 25		      bne	.exit
    315  1908		       a9 01		      lda	#1	; larger number will slow the draw of available moves
    316  190a		       85 89		      sta	mdelay	; once triggered, runs always
    317  190c
    318  190c		       a5 8d		      lda	aiMoveIndex
    319  190e		       10 09		      bpl	.valid
    320  1910
    321  1910		       a9 89		      lda	#RAMBANK_PLY+1
    322  1912		       85 3e		      sta	SET_BANK_RAM	;@2
      0  1914					      lda@PLY	moveIndex
      1  1914		       ad d0 f9 	      lda	moveIndex
    324  1917		       85 8d		      sta	aiMoveIndex
    325  1919				   .valid
    326  1919
    327  1919		       20 3a f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    328  191c		       a5 8d		      lda	aiMoveIndex
    329  191e		       10 19		      bpl	.unsure	; still drawing in this phase
    330  1920
    331  1920		       a9 14		      lda	#CAP_SPEED
    332  1922		       85 89		      sta	mdelay
    333  1924
    334  1924		       a9 00		      lda	#0
    335  1926		       85 8e		      sta	aiFlashPhase	; controls odd/even exit of flashing
    336  1928
      0  1928					      PHASE	AI_ShowMoveCaptures
      1  1928		       a9 05		      lda	#AI_ShowMoveCaptures
      2  192a		       85 8b		      sta	aiState
    338  192c		       60		      rts
    339  192d
    340  192d				   .exit
    341  192d
    342  192d							; Initial piece selection has happened, but the button hasn't been released yet
    343  192d							; AND we're still in the waiting phase to see if the button was held long enough for move show
    344  192d
    345  192d		       a5 4c		      lda	INPT4
    346  192f		       10 08		      bpl	.unsure	; button still pressed, so still unsure what to do
    347  1931
    348  1931							; Aha! Button released, so we know the selected piece and can start flashing it
    349  1931							; and allowing movement of the selector to a destination square...
    350  1931
    351  1931		       a9 18		      lda	#6*4
    352  1933		       85 8a		      sta	ccur	; bright green square for selection
    353  1935
      0  1935					      PHASE	AI_SelectDestinationSquare
      1  1935		       a9 08		      lda	#AI_SelectDestinationSquare
      2  1937		       85 8b		      sta	aiState
    355  1939
    356  1939		       60	   .unsure    rts
    357  193a
    358  193a
    359  193a							;---------------------------------------------------------------------------------------------------
    360  193a
      0  193a					      DEF	showMoveOptions
      1  193a				   SLOT_showMoveOptions SET	_BANK_SLOT
      2  193a				   BANK_showMoveOptions SET	SLOT_showMoveOptions + _CURRENT_BANK
      3  193a				   showMoveOptions
      4  193a				   TEMPORARY_VAR SET	Overlay
      5  193a				   TEMPORARY_OFFSET SET	0
      6  193a				   VAR_BOUNDARY_showMoveOptions SET	TEMPORARY_OFFSET
      7  193a				   FUNCTION_NAME SET	showMoveOptions
    362  193a					      SUBROUTINE
    363  193a
      0  193a					      REFER	aiDrawMoves
      1  193a				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  193a				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  193a					      ENDIF
      0  193a					      REFER	aiUnDrawTargetSquares
      1  193a				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  193a				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  193a					      ENDIF
    366  193a
      0  193a					      VAR	__saveIdx, 1
      1  193a		       00 a4	   __saveIdx  =	TEMPORARY_VAR
      2  193a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  193a
      4  193a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  193a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  193a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  193a					      ENDIF
      8  193a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  193a				  -	      ECHO	"Temporary Variable", __saveIdx, "overflow!"
     10  193a				  -	      ERR
     11  193a					      ENDIF
     12  193a					      LIST	ON
      0  193a					      VAR	__piece, 1
      1  193a		       00 a5	   __piece    =	TEMPORARY_VAR
      2  193a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  193a
      4  193a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  193a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  193a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  193a					      ENDIF
      8  193a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  193a				  -	      ECHO	"Temporary Variable", __piece, "overflow!"
     10  193a				  -	      ERR
     11  193a					      ENDIF
     12  193a					      LIST	ON
    369  193a
      0  193a					      VEND	showMoveOptions
      1  193a				  -	      IFNCONST	showMoveOptions
      2  193a				  -	      ECHO	"Incorrect VEND label", showMoveOptions
      3  193a				  -	      ERR
      4  193a					      ENDIF
      5  193a		       00 a6	   VAREND_showMoveOptions =	TEMPORARY_VAR
    371  193a
    372  193a							; place a marker on the board for any square matching the piece
    373  193a							; EXCEPT for squares which are occupied (we'll flash those later)
    374  193a
    375  193a		       a6 8d	   .next      ldx	aiMoveIndex
    376  193c		       86 a4		      stx	__saveIdx
    377  193e		       30 4c		      bmi	.skip
    378  1940
    379  1940		       ad 84 02 	      lda	INTIM
    380  1943		       c9 2b		      cmp	#2+SPEEDOF_COPYSINGLEPIECE
    381  1945		       90 45		      bcc	.skip
    382  1947
    383  1947		       c6 8d		      dec	aiMoveIndex
    384  1949
    385  1949		       a9 89		      lda	#RAMBANK_PLY+1
    386  194b		       85 3e		      sta	SET_BANK_RAM	;@2
    387  194d
      0  194d					      lda@PLY	MoveFrom,x
      1  194d		       bd 00 f8 	      lda	MoveFrom,x
    389  1950		       c5 85		      cmp	fromX12
    390  1952		       d0 e6		      bne	.next
    391  1954
      0  1954					      lda@PLY	MoveTo,x
      1  1954		       bd 64 f8 	      lda	MoveTo,x
    393  1957		       85 80		      sta	squareToDraw
    394  1959
      0  1959					      lda@PLY	MovePiece,x
      1  1959		       bd 00 f9 	      lda	MovePiece,x
    396  195c		       85 a5		      sta	__piece
    397  195e
    398  195e							; If it's a pawn promote (duplicate "to" AND piece different (TODO) then skip others)
    399  195e							; TODO this could/will fail on sorted lists. MMh.
    400  195e
    401  195e		       ca		      dex
    402  195f		       30 16		      bmi	.prom
    403  1961
      0  1961					      lda@PLY	MoveTo,x
      1  1961		       bd 64 f8 	      lda	MoveTo,x
    405  1964		       c5 80		      cmp	squareToDraw
    406  1966		       d0 0f		      bne	.prom
    407  1968
      0  1968					      lda@PLY	MovePiece,x
      1  1968		       bd 00 f9 	      lda	MovePiece,x
    409  196b		       45 a5		      eor	__piece
    410  196d		       29 0f		      and	#PIECE_MASK
    411  196f		       f0 06		      beq	.prom	; same piece type so not a promote
    412  1971
    413  1971		       c6 8d		      dec	aiMoveIndex
    414  1973		       c6 8d		      dec	aiMoveIndex
    415  1975		       c6 8d		      dec	aiMoveIndex
    416  1977				   .prom
    417  1977
    418  1977		       a4 80		      ldy	squareToDraw
    419  1979
    420  1979		       a9 cc		      lda	#RAMBANK_BOARD
    421  197b		       85 3e		      sta	SET_BANK_RAM	;@3
    422  197d		       b9 79 fc 	      lda	Board,y
    423  1980		       29 0f		      and	#PIECE_MASK
    424  1982		       d0 b6		      bne	.next	; don't draw dots on captures - they are flashed later
    425  1984
    426  1984
    427  1984							;lda INTIM
    428  1984							;cmp #SPEEDOF_COPYSINGLEPIECE
    429  1984							;bcc .skip
    430  1984
    431  1984							;lda aiMoveIndex
    432  1984							;sta __saveIdx
    433  1984
    434  1984							; Draw the marker...?
    435  1984
    436  1984		       a2 1c		      ldx	#INDEX_WHITE_MARKER_on_WHITE_SQUARE_0
    437  1986		       20 91 f5 	      jsr	CopySetupForMarker	;@1
    438  1989		       4c b4 f0 	      jmp	InterceptMarkerCopy	;@0
    439  198c
    440  198c
    441  198c
    442  198c		       a5 a4	   .skip      lda	__saveIdx
    443  198e		       85 8d		      sta	aiMoveIndex
    444  1990		       60		      rts
    445  1991
    446  1991
    447  1991							;---------------------------------------------------------------------------------------------------
    448  1991
      0  1991					      DEF	CopySetupForMarker
      1  1991				   SLOT_CopySetupForMarker SET	_BANK_SLOT
      2  1991				   BANK_CopySetupForMarker SET	SLOT_CopySetupForMarker + _CURRENT_BANK
      3  1991				   CopySetupForMarker
      4  1991				   TEMPORARY_VAR SET	Overlay
      5  1991				   TEMPORARY_OFFSET SET	0
      6  1991				   VAR_BOUNDARY_CopySetupForMarker SET	TEMPORARY_OFFSET
      7  1991				   FUNCTION_NAME SET	CopySetupForMarker
    450  1991					      SUBROUTINE
    451  1991
      0  1991					      REFER	showMoveOptions
      1  1991					      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  1991				   TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  1991					      ENDIF
      0  1991					      REFER	showPromoteOptions
      1  1991				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  1991				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  1991					      ENDIF
    454  1991
      0  1991					      VAR	__pieceColour, 1
      1  1991		       00 a6	   __pieceColour =	TEMPORARY_VAR
      2  1991				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1991
      4  1991				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1991				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1991				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1991					      ENDIF
      8  1991				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1991				  -	      ECHO	"Temporary Variable", __pieceColour, "overflow!"
     10  1991				  -	      ERR
     11  1991					      ENDIF
     12  1991					      LIST	ON
      0  1991					      VAR	__oddeven, 1
      1  1991		       00 a7	   __oddeven  =	TEMPORARY_VAR
      2  1991				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1991
      4  1991				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1991				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1991				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1991					      ENDIF
      8  1991				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1991				  -	      ECHO	"Temporary Variable", __oddeven, "overflow!"
     10  1991				  -	      ERR
     11  1991					      ENDIF
     12  1991					      LIST	ON
      0  1991					      VAR	__pmcol, 1
      1  1991		       00 a8	   __pmcol    =	TEMPORARY_VAR
      2  1991				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1991
      4  1991				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1991				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1991				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1991					      ENDIF
      8  1991				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1991				  -	      ECHO	"Temporary Variable", __pmcol, "overflow!"
     10  1991				  -	      ERR
     11  1991					      ENDIF
     12  1991					      LIST	ON
    458  1991
      0  1991					      VEND	CopySetupForMarker
      1  1991				  -	      IFNCONST	CopySetupForMarker
      2  1991				  -	      ECHO	"Incorrect VEND label", CopySetupForMarker
      3  1991				  -	      ERR
      4  1991					      ENDIF
      5  1991		       00 a9	   VAREND_CopySetupForMarker =	TEMPORARY_VAR
    460  1991
    461  1991		       a5 80		      lda	squareToDraw
    462  1993		       38		      sec
    463  1994		       a0 0a		      ldy	#10
    464  1996		       e9 0a	   .sub10     sbc	#10
    465  1998		       88		      dey
    466  1999		       b0 fb		      bcs	.sub10
    467  199b		       84 a7		      sty	__oddeven
    468  199d		       69 08		      adc	#8
    469  199f		       85 a8		      sta	__pmcol
    470  19a1		       65 a7		      adc	__oddeven
    471  19a3
    472  19a3		       29 01		      and	#1
    473  19a5		       49 01		      eor	#1
    474  19a7		       f0 02		      beq	.white
    475  19a9		       a9 24		      lda	#36
    476  19ab				   .white
    477  19ab		       85 a6		      sta	__pieceColour	; actually SQUARE black/white
    478  19ad
    479  19ad		       8a		      txa
    480  19ae		       18		      clc
    481  19af		       65 a6		      adc	__pieceColour
    482  19b1		       85 a6		      sta	__pieceColour
    483  19b3
    484  19b3		       a5 a8		      lda	__pmcol
    485  19b5		       29 03		      and	#3
    486  19b7
    487  19b7		       18		      clc
    488  19b8		       65 a6		      adc	__pieceColour
    489  19ba		       a8		      tay
    490  19bb		       60		      rts
    491  19bc
    492  19bc
    493  19bc							;---------------------------------------------------------------------------------------------------
    494  19bc
      0  19bc					      DEF	aiUnDrawTargetSquares
      1  19bc				   SLOT_aiUnDrawTargetSquares SET	_BANK_SLOT
      2  19bc				   BANK_aiUnDrawTargetSquares SET	SLOT_aiUnDrawTargetSquares + _CURRENT_BANK
      3  19bc				   aiUnDrawTargetSquares
      4  19bc				   TEMPORARY_VAR SET	Overlay
      5  19bc				   TEMPORARY_OFFSET SET	0
      6  19bc				   VAR_BOUNDARY_aiUnDrawTargetSquares SET	TEMPORARY_OFFSET
      7  19bc				   FUNCTION_NAME SET	aiUnDrawTargetSquares
    496  19bc					      SUBROUTINE
    497  19bc
      0  19bc					      REFER	AiStateMachine
      1  19bc				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  19bc				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  19bc					      ENDIF
      0  19bc					      VEND	aiUnDrawTargetSquares
      1  19bc				  -	      IFNCONST	aiUnDrawTargetSquares
      2  19bc				  -	      ECHO	"Incorrect VEND label", aiUnDrawTargetSquares
      3  19bc				  -	      ERR
      4  19bc					      ENDIF
      5  19bc		       00 a4	   VAREND_aiUnDrawTargetSquares =	TEMPORARY_VAR
    500  19bc
    501  19bc
    502  19bc		       c6 8a		      dec	ccur
    503  19be		       20 b1 f4 	      jsr	setCursorColours
    504  19c1
    505  19c1		       c6 89		      dec	mdelay
    506  19c3		       d0 1c		      bne	.exit
    507  19c5		       a9 01		      lda	#1
    508  19c7		       85 89		      sta	mdelay	; once triggered, runs always
    509  19c9
    510  19c9		       a5 8d		      lda	aiMoveIndex
    511  19cb		       10 09		      bpl	.valid
    512  19cd
    513  19cd		       a9 89		      lda	#RAMBANK_PLY+1
    514  19cf		       85 3e		      sta	SET_BANK_RAM	;@2
      0  19d1					      lda@PLY	moveIndex
      1  19d1		       ad d0 f9 	      lda	moveIndex
    516  19d4		       85 8d		      sta	aiMoveIndex
    517  19d6				   .valid
    518  19d6
    519  19d6		       20 3a f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    520  19d9		       a5 8d		      lda	aiMoveIndex
    521  19db		       10 04		      bpl	.exit	; still drawing in this phase
    522  19dd
      0  19dd					      PHASE	AI_SelectStartSquare
      1  19dd		       a9 02		      lda	#AI_SelectStartSquare
      2  19df		       85 8b		      sta	aiState
    524  19e1
    525  19e1		       60	   .exit      rts
    526  19e2
    527  19e2
    528  19e2							;---------------------------------------------------------------------------------------------------
    529  19e2
    530  19e2
      0  19e2					      DEF	aiShowMoveCaptures
      1  19e2				   SLOT_aiShowMoveCaptures SET	_BANK_SLOT
      2  19e2				   BANK_aiShowMoveCaptures SET	SLOT_aiShowMoveCaptures + _CURRENT_BANK
      3  19e2				   aiShowMoveCaptures
      4  19e2				   TEMPORARY_VAR SET	Overlay
      5  19e2				   TEMPORARY_OFFSET SET	0
      6  19e2				   VAR_BOUNDARY_aiShowMoveCaptures SET	TEMPORARY_OFFSET
      7  19e2				   FUNCTION_NAME SET	aiShowMoveCaptures
    532  19e2					      SUBROUTINE
    533  19e2
      0  19e2					      REFER	AiStateMachine
      1  19e2				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  19e2				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  19e2					      ENDIF
      0  19e2					      VEND	aiShowMoveCaptures
      1  19e2				  -	      IFNCONST	aiShowMoveCaptures
      2  19e2				  -	      ECHO	"Incorrect VEND label", aiShowMoveCaptures
      3  19e2				  -	      ERR
      4  19e2					      ENDIF
      5  19e2		       00 a4	   VAREND_aiShowMoveCaptures =	TEMPORARY_VAR
    536  19e2
    537  19e2							; draw/undraw ALL captured pieces
    538  19e2							; we should do this an even number of times so that pieces don't disappEOR
    539  19e2
    540  19e2		       c6 8a		      dec	ccur
    541  19e4		       20 b1 f4 	      jsr	setCursorColours
    542  19e7
    543  19e7		       c6 89		      dec	mdelay	; flash speed UNVARYING despite draw happening
    544  19e9
    545  19e9		       a5 8d		      lda	aiMoveIndex
    546  19eb		       10 09		      bpl	.valid	; guaranteed -1 on 1st call
    547  19ed		       a9 89		      lda	#RAMBANK_PLY+1
    548  19ef		       85 3e		      sta	SET_BANK_RAM	;@2
      0  19f1					      lda@PLY	moveIndex
      1  19f1		       ad d0 f9 	      lda	moveIndex
    550  19f4		       85 8d		      sta	aiMoveIndex
    551  19f6				   .valid
    552  19f6
    553  19f6							;lda #BANK_showMoveCaptures
    554  19f6							;sta SET_BANK;@0
    555  19f6
    556  19f6		       20 a6 f2 	      jsr	showMoveCaptures	;@0
    557  19f9		       a5 8d		      lda	aiMoveIndex
    558  19fb		       10 06		      bpl	.exit
    559  19fd
    560  19fd		       e6 8e		      inc	aiFlashPhase
    561  19ff
      0  19ff					      PHASE	AI_SlowFlash
      1  19ff		       a9 06		      lda	#AI_SlowFlash
      2  1a01		       85 8b		      sta	aiState
    563  1a03
    564  1a03		       60	   .exit      rts
    565  1a04
    566  1a04
    567  1a04							;---------------------------------------------------------------------------------------------------
    568  1a04
      0  1a04					      DEF	aiSlowFlash
      1  1a04				   SLOT_aiSlowFlash SET	_BANK_SLOT
      2  1a04				   BANK_aiSlowFlash SET	SLOT_aiSlowFlash + _CURRENT_BANK
      3  1a04				   aiSlowFlash
      4  1a04				   TEMPORARY_VAR SET	Overlay
      5  1a04				   TEMPORARY_OFFSET SET	0
      6  1a04				   VAR_BOUNDARY_aiSlowFlash SET	TEMPORARY_OFFSET
      7  1a04				   FUNCTION_NAME SET	aiSlowFlash
    570  1a04					      SUBROUTINE
    571  1a04
      0  1a04					      REFER	AiStateMachine
      1  1a04				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1a04				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1a04					      ENDIF
      0  1a04					      VEND	aiSlowFlash
      1  1a04				  -	      IFNCONST	aiSlowFlash
      2  1a04				  -	      ECHO	"Incorrect VEND label", aiSlowFlash
      3  1a04				  -	      ERR
      4  1a04					      ENDIF
      5  1a04		       00 a4	   VAREND_aiSlowFlash =	TEMPORARY_VAR
    574  1a04
    575  1a04							; Joystick button is held down, so we're displaying the available moves
    576  1a04							; They have all been drawn, so now we "slow" flash any pieces that can be captures
    577  1a04
    578  1a04		       c6 8a		      dec	ccur
    579  1a06		       20 b1 f4 	      jsr	setCursorColours
    580  1a09
    581  1a09		       a5 8e		      lda	aiFlashPhase
    582  1a0b		       29 01		      and	#1
    583  1a0d		       d0 04		      bne	.notEven	; only exit after even # EOR-draws
    584  1a0f
    585  1a0f		       a5 4c		      lda	INPT4
    586  1a11		       30 0d		      bmi	.butpress	; exit on button release
    587  1a13
    588  1a13				   .notEven
    589  1a13
    590  1a13							; Wait for delay to expire then back and flash 'em again
    591  1a13
    592  1a13		       c6 89		      dec	mdelay
    593  1a15		       10 08		      bpl	.slowWait
    594  1a17
    595  1a17		       a9 14		      lda	#CAP_SPEED
    596  1a19		       85 89		      sta	mdelay
    597  1a1b
      0  1a1b					      PHASE	AI_ShowMoveCaptures	; go back and rEORdraw all captures again
      1  1a1b		       a9 05		      lda	#AI_ShowMoveCaptures
      2  1a1d		       85 8b		      sta	aiState
    599  1a1f
    600  1a1f		       60	   .slowWait  rts
    601  1a20
    602  1a20
    603  1a20		       a9 01	   .butpress  lda	#1
    604  1a22		       85 89		      sta	mdelay
    605  1a24
      0  1a24					      PHASE	AI_UnDrawTargetSquares
      1  1a24		       a9 07		      lda	#AI_UnDrawTargetSquares
      2  1a26		       85 8b		      sta	aiState
    607  1a28		       60		      rts
    608  1a29
    609  1a29
    610  1a29							;---------------------------------------------------------------------------------------------------
    611  1a29
      0  1a29					      DEF	moveCursor
      1  1a29				   SLOT_moveCursor SET	_BANK_SLOT
      2  1a29				   BANK_moveCursor SET	SLOT_moveCursor + _CURRENT_BANK
      3  1a29				   moveCursor
      4  1a29				   TEMPORARY_VAR SET	Overlay
      5  1a29				   TEMPORARY_OFFSET SET	0
      6  1a29				   VAR_BOUNDARY_moveCursor SET	TEMPORARY_OFFSET
      7  1a29				   FUNCTION_NAME SET	moveCursor
    613  1a29					      SUBROUTINE
    614  1a29
      0  1a29					      REFER	aiSelectStartSquare
      1  1a29				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  1a29				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  1a29					      ENDIF
      0  1a29					      REFER	aiSelectDestinationSquare
      1  1a29				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  1a29				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  1a29					      ENDIF
    617  1a29
      0  1a29					      VAR	__newCursor, 1
      1  1a29		       00 a4	   __newCursor =	TEMPORARY_VAR
      2  1a29				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1a29
      4  1a29				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1a29				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1a29				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1a29					      ENDIF
      8  1a29				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1a29				  -	      ECHO	"Temporary Variable", __newCursor, "overflow!"
     10  1a29				  -	      ERR
     11  1a29					      ENDIF
     12  1a29					      LIST	ON
    619  1a29
      0  1a29					      VEND	moveCursor
      1  1a29				  -	      IFNCONST	moveCursor
      2  1a29				  -	      ECHO	"Incorrect VEND label", moveCursor
      3  1a29				  -	      ERR
      4  1a29					      ENDIF
      5  1a29		       00 a5	   VAREND_moveCursor =	TEMPORARY_VAR
    621  1a29
    622  1a29							; Part (a) move cursor around the board waiting for joystick press
    623  1a29
    624  1a29		       a2 00		      ldx	#0	; delay
    625  1a2b
    626  1a2b		       ad 80 02 	      lda	SWCHA
    627  1a2e		       4a		      lsr
    628  1a2f		       4a		      lsr
    629  1a30		       4a		      lsr
    630  1a31		       4a		      lsr
    631  1a32		       a8		      tay
    632  1a33
    633  1a33		       c9 0f		      cmp	#15
    634  1a35		       f0 1e		      beq	.cursor	; nothing pressed - skip delays
    635  1a37
    636  1a37		       c6 89		      dec	mdelay
    637  1a39		       10 1f		      bpl	.delaym
    638  1a3b
    639  1a3b		       18		      clc
    640  1a3c		       a5 88		      lda	cursorX12
    641  1a3e		       79 d4 f4 	      adc	JoyMoveCursor,y
    642  1a41		       85 a4		      sta	__newCursor
    643  1a43		       a8		      tay
    644  1a44
    645  1a44		       a9 cc		      lda	#RAMBANK_BOARD
    646  1a46		       85 3e		      sta	SET_BANK_RAM	;@3
    647  1a48		       b9 15 fc 	      lda	ValidSquare,y
    648  1a4b		       c9 ff		      cmp	#-1
    649  1a4d		       f0 04		      beq	.invalid
    650  1a4f		       a5 a4		      lda	__newCursor
    651  1a51		       85 88		      sta	cursorX12
    652  1a53				   .invalid
    653  1a53
    654  1a53		       a2 10		      ldx	#CURSOR_MOVE_SPEED
    655  1a55		       86 89	   .cursor    stx	mdelay
    656  1a57		       20 99 f4 	      jsr	setCursorPriority
    657  1a5a		       60	   .delaym    rts
    658  1a5b
    659  1a5b
    660  1a5b							;---------------------------------------------------------------------------------------------------
    661  1a5b
      0  1a5b					      DEF	aiSelectDestinationSquare
      1  1a5b				   SLOT_aiSelectDestinationSquare SET	_BANK_SLOT
      2  1a5b				   BANK_aiSelectDestinationSquare SET	SLOT_aiSelectDestinationSquare + _CURRENT_BANK
      3  1a5b				   aiSelectDestinationSquare
      4  1a5b				   TEMPORARY_VAR SET	Overlay
      5  1a5b				   TEMPORARY_OFFSET SET	0
      6  1a5b				   VAR_BOUNDARY_aiSelectDestinationSquare SET	TEMPORARY_OFFSET
      7  1a5b				   FUNCTION_NAME SET	aiSelectDestinationSquare
    663  1a5b					      SUBROUTINE
    664  1a5b
      0  1a5b					      REFER	AiStateMachine
      1  1a5b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1a5b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1a5b					      ENDIF
      0  1a5b					      VEND	aiSelectDestinationSquare
      1  1a5b				  -	      IFNCONST	aiSelectDestinationSquare
      2  1a5b				  -	      ECHO	"Incorrect VEND label", aiSelectDestinationSquare
      3  1a5b				  -	      ERR
      4  1a5b					      ENDIF
      5  1a5b		       00 a4	   VAREND_aiSelectDestinationSquare =	TEMPORARY_VAR
    667  1a5b
    668  1a5b							; Piece is selected and now we're looking for a button press on a destination square
    669  1a5b							; we flash the piece on-and-off while we're doing that
    670  1a5b							; Flash the selected piece
    671  1a5b
    672  1a5b		       ad 84 02 	      lda	INTIM
    673  1a5e		       c9 28		      cmp	#ONCEPERFRAME
    674  1a60		       90 0e		      bcc	.exit
    675  1a62
    676  1a62
    677  1a62		       c6 8c		      dec	aiFlashDelay
    678  1a64		       d0 0a		      bne	.exit	; don't flash
    679  1a66		       a9 14		      lda	#CAP_SPEED
    680  1a68		       85 8c		      sta	aiFlashDelay
    681  1a6a
    682  1a6a		       e6 8e		      inc	aiFlashPhase
    683  1a6c
    684  1a6c		       20 ad f0 	      jsr	CopySinglePiece	;@0
    685  1a6f		       60		      rts
    686  1a70
    687  1a70				   .exit
    688  1a70		       20 29 f6 	      jsr	moveCursor
    689  1a73
    690  1a73		       ad 84 02 	      lda	INTIM
    691  1a76		       c9 14		      cmp	#20
    692  1a78		       90 39		      bcc	.noButton
    693  1a7a
    694  1a7a
    695  1a7a		       a4 88		      ldy	cursorX12
    696  1a7c		       84 86		      sty	toX12
    697  1a7e
      0  1a7e					      CALL	GetPiece	;@3
      1  1a7e				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  1a7e				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1a7e				  -	      ECHO	"Cannot switch bank in use for", GetPiece
      4  1a7e				  -	      ERR
      5  1a7e					      ENDIF
      6  1a7e		       a9 dd		      lda	#BANK_GetPiece
      7  1a80		       85 3f		      sta	SET_BANK
      8  1a82		       20 00 fc 	      jsr	GetPiece
    699  1a85		       20 b1 f4 	      jsr	setCursorColours
    700  1a88
    701  1a88
    702  1a88							; y = valid square
    703  1a88
    704  1a88		       a5 4c		      lda	INPT4
    705  1a8a		       30 27		      bmi	.noButton
    706  1a8c
    707  1a8c		       a5 86		      lda	toX12
    708  1a8e		       c5 85		      cmp	fromX12
    709  1a90		       f0 0d		      beq	.cancel
    710  1a92
    711  1a92		       c0 ff		      cpy	#-1
    712  1a94		       f0 1d		      beq	.noButton	; not a valid square
    713  1a96
    714  1a96		       a5 8e		      lda	aiFlashPhase
    715  1a98		       29 01		      and	#1
    716  1a9a		       f0 13		      beq	.done
    717  1a9c		       85 8c		      sta	aiFlashDelay	; EOR-phase incorrect - force quick fix to allow next-frame button detect
    718  1a9e		       60		      rts
    719  1a9f
    720  1a9f				   .cancel
    721  1a9f
    722  1a9f		       a5 8e		      lda	aiFlashPhase
    723  1aa1		       29 01		      and	#1
    724  1aa3		       f0 05		      beq	.doCancel
    725  1aa5
    726  1aa5							; EOR-phase incorrect - force quick fix to allow next-frame button detect
    727  1aa5
    728  1aa5		       a9 01		      lda	#1
    729  1aa7		       85 8c		      sta	aiFlashDelay
    730  1aa9		       60		      rts
    731  1aaa
    732  1aaa
      0  1aaa				   .doCancel  PHASE	AI_ReselectDebounce
      1  1aaa		       a9 0a		      lda	#AI_ReselectDebounce
      2  1aac		       85 8b		      sta	aiState
    734  1aae		       60		      rts
    735  1aaf
      0  1aaf				   .done      PHASE	AI_Quiescent	; destination selected!
      1  1aaf		       a9 09		      lda	#AI_Quiescent
      2  1ab1		       85 8b		      sta	aiState
    737  1ab3		       60	   .noButton  rts
    738  1ab4
    739  1ab4
    740  1ab4
    741  1ab4
    742  1ab4							;---------------------------------------------------------------------------------------------------
    743  1ab4
      0  1ab4					      DEF	aiReselectDebounce
      1  1ab4				   SLOT_aiReselectDebounce SET	_BANK_SLOT
      2  1ab4				   BANK_aiReselectDebounce SET	SLOT_aiReselectDebounce + _CURRENT_BANK
      3  1ab4				   aiReselectDebounce
      4  1ab4				   TEMPORARY_VAR SET	Overlay
      5  1ab4				   TEMPORARY_OFFSET SET	0
      6  1ab4				   VAR_BOUNDARY_aiReselectDebounce SET	TEMPORARY_OFFSET
      7  1ab4				   FUNCTION_NAME SET	aiReselectDebounce
    745  1ab4					      SUBROUTINE
    746  1ab4
      0  1ab4					      REFER	AiStateMachine
      1  1ab4				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1ab4				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1ab4					      ENDIF
      0  1ab4					      VEND	aiReselectDebounce
      1  1ab4				  -	      IFNCONST	aiReselectDebounce
      2  1ab4				  -	      ECHO	"Incorrect VEND label", aiReselectDebounce
      3  1ab4				  -	      ERR
      4  1ab4					      ENDIF
      5  1ab4		       00 a4	   VAREND_aiReselectDebounce =	TEMPORARY_VAR
    749  1ab4
    750  1ab4							; We've just cancelled the move. Wait for the button to be released
    751  1ab4							; and then go back to selecting a piece to move
    752  1ab4
    753  1ab4		       a5 4c		      lda	INPT4
    754  1ab6		       10 04		      bpl	.exit	; button still pressed, so wait
    755  1ab8
      0  1ab8					      PHASE	AI_SelectStartSquare
      1  1ab8		       a9 02		      lda	#AI_SelectStartSquare
      2  1aba		       85 8b		      sta	aiState
    757  1abc		       60	   .exit      rts
    758  1abd
    759  1abd
    760  1abd							;---------------------------------------------------------------------------------------------------
    761  1abd
      0  1abd					      DEF	aiQuiescent
      1  1abd				   SLOT_aiQuiescent SET	_BANK_SLOT
      2  1abd				   BANK_aiQuiescent SET	SLOT_aiQuiescent + _CURRENT_BANK
      3  1abd				   aiQuiescent
      4  1abd				   TEMPORARY_VAR SET	Overlay
      5  1abd				   TEMPORARY_OFFSET SET	0
      6  1abd				   VAR_BOUNDARY_aiQuiescent SET	TEMPORARY_OFFSET
      7  1abd				   FUNCTION_NAME SET	aiQuiescent
    763  1abd					      SUBROUTINE
    764  1abd
      0  1abd					      REFER	AiStateMachine
      1  1abd				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1abd				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1abd					      ENDIF
      0  1abd					      VEND	aiQuiescent
      1  1abd				  -	      IFNCONST	aiQuiescent
      2  1abd				  -	      ECHO	"Incorrect VEND label", aiQuiescent
      3  1abd				  -	      ERR
      4  1abd					      ENDIF
      5  1abd		       00 a4	   VAREND_aiQuiescent =	TEMPORARY_VAR
    767  1abd
    768  1abd							; Move has been selected
    769  1abd
    770  1abd		       a9 ff		      lda	#-1
    771  1abf		       85 88		      sta	cursorX12
    772  1ac1
    773  1ac1		       a5 85		      lda	fromX12
    774  1ac3		       85 87		      sta	originX12
      0  1ac5					      CALL	GetPiece	;@3		    ; from the movelist
      1  1ac5				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  1ac5				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1ac5				  -	      ECHO	"Cannot switch bank in use for", GetPiece
      4  1ac5				  -	      ERR
      5  1ac5					      ENDIF
      6  1ac5		       a9 dd		      lda	#BANK_GetPiece
      7  1ac7		       85 3f		      sta	SET_BANK
      8  1ac9		       20 00 fc 	      jsr	GetPiece
    776  1acc
    777  1acc		       a4 85		      ldy	fromX12
    778  1ace		       a9 cc		      lda	#RAMBANK_BOARD
    779  1ad0		       85 3e		      sta	SET_BANK_RAM	;@3
    780  1ad2		       b9 79 fc 	      lda	Board,y
    781  1ad5		       45 96		      eor	fromPiece
    782  1ad7		       29 0f		      and	#PIECE_MASK	; if not the same piece board/movelist...
    783  1ad9		       d0 05		      bne	.promote	; promote a pawn
    784  1adb
      0  1adb					      PHASE	AI_MoveIsSelected
      1  1adb		       a9 14		      lda	#AI_MoveIsSelected
      2  1add		       85 8b		      sta	aiState
    786  1adf		       60		      rts
    787  1ae0
      0  1ae0				   .promote   PHASE	AI_PromotePawnStart
      1  1ae0		       a9 1f		      lda	#AI_PromotePawnStart
      2  1ae2		       85 8b		      sta	aiState
    789  1ae4		       60		      rts
    790  1ae5
    791  1ae5
    792  1ae5							;---------------------------------------------------------------------------------------------------
    793  1ae5
      0  1ae5					      DEF	aiRollPromotionPiece
      1  1ae5				   SLOT_aiRollPromotionPiece SET	_BANK_SLOT
      2  1ae5				   BANK_aiRollPromotionPiece SET	SLOT_aiRollPromotionPiece + _CURRENT_BANK
      3  1ae5				   aiRollPromotionPiece
      4  1ae5				   TEMPORARY_VAR SET	Overlay
      5  1ae5				   TEMPORARY_OFFSET SET	0
      6  1ae5				   VAR_BOUNDARY_aiRollPromotionPiece SET	TEMPORARY_OFFSET
      7  1ae5				   FUNCTION_NAME SET	aiRollPromotionPiece
    795  1ae5					      SUBROUTINE
    796  1ae5
      0  1ae5					      REFER	AiStateMachine
      1  1ae5				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1ae5				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1ae5					      ENDIF
      0  1ae5					      VEND	aiRollPromotionPiece
      1  1ae5				  -	      IFNCONST	aiRollPromotionPiece
      2  1ae5				  -	      ECHO	"Incorrect VEND label", aiRollPromotionPiece
      3  1ae5				  -	      ERR
      4  1ae5					      ENDIF
      5  1ae5		       00 a4	   VAREND_aiRollPromotionPiece =	TEMPORARY_VAR
    799  1ae5
    800  1ae5							; Flash the '?' and wait for an UDLR move
    801  1ae5
    802  1ae5		       ad 84 02 	      lda	INTIM
    803  1ae8		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    804  1aea		       90 28		      bcc	.exit
    805  1aec
    806  1aec		       ad 80 02 	      lda	SWCHA
    807  1aef		       29 f0		      and	#$F0
    808  1af1		       c9 f0		      cmp	#$F0
    809  1af3		       f0 0a		      beq	.nojoy
    810  1af5
    811  1af5		       a9 00		      lda	#0
    812  1af7		       85 8c		      sta	aiFlashDelay
    813  1af9
    814  1af9		       a5 8e		      lda	aiFlashPhase
    815  1afb		       29 01		      and	#1
    816  1afd		       f0 16		      beq	.even
    817  1aff
    818  1aff		       c6 8c	   .nojoy     dec	aiFlashDelay
    819  1b01		       10 11		      bpl	.exit
    820  1b03
    821  1b03		       a9 0a		      lda	#10
    822  1b05		       85 8c		      sta	aiFlashDelay
    823  1b07
    824  1b07		       a2 20		      ldx	#INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0
    825  1b09		       a5 95		      lda	sideToMove
    826  1b0b		       10 02		      bpl	.wtm
    827  1b0d		       a2 68		      ldx	#INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0
    828  1b0f				   .wtm
    829  1b0f		       20 21 fc 	      jsr	showPromoteOptions
    830  1b12
    831  1b12		       e6 8e		      inc	aiFlashPhase
    832  1b14
    833  1b14		       60	   .exit      rts
    834  1b15
    835  1b15
    836  1b15		       a9 03	   .even      lda	#3	; QUEEN
    837  1b17		       85 96		      sta	fromPiece	; cycles as index to NBRQ
    838  1b19
    839  1b19		       e6 8e		      inc	aiFlashPhase
    840  1b1b
    841  1b1b
    842  1b1b		       a2 14		      ldx	#INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0	;TODO: fix for colour
    843  1b1d		       a5 95		      lda	sideToMove
    844  1b1f		       10 02		      bpl	.whiteToMove
    845  1b21		       a2 5c		      ldx	#INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    846  1b23				   .whiteToMove
    847  1b23
    848  1b23		       20 21 fc 	      jsr	showPromoteOptions
    849  1b26
      0  1b26					      PHASE	AI_ChooseDebounce
      1  1b26		       a9 22		      lda	#AI_ChooseDebounce
      2  1b28		       85 8b		      sta	aiState
    851  1b2a		       60		      rts
    852  1b2b
    853  1b2b
    854  1b2b
    855  1b2b							;---------------------------------------------------------------------------------------------------
    856  1b2b
      0  1b2b					      DEF	aiMarchA2
      1  1b2b				   SLOT_aiMarchA2 SET	_BANK_SLOT
      2  1b2b				   BANK_aiMarchA2 SET	SLOT_aiMarchA2 + _CURRENT_BANK
      3  1b2b				   aiMarchA2
      4  1b2b				   TEMPORARY_VAR SET	Overlay
      5  1b2b				   TEMPORARY_OFFSET SET	0
      6  1b2b				   VAR_BOUNDARY_aiMarchA2 SET	TEMPORARY_OFFSET
      7  1b2b				   FUNCTION_NAME SET	aiMarchA2
    858  1b2b					      SUBROUTINE
    859  1b2b
      0  1b2b					      REFER	AiStateMachine
      1  1b2b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1b2b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1b2b					      ENDIF
    861  1b2b
      0  1b2b					      VEND	aiMarchA2
      1  1b2b				  -	      IFNCONST	aiMarchA2
      2  1b2b				  -	      ECHO	"Incorrect VEND label", aiMarchA2
      3  1b2b				  -	      ERR
      4  1b2b					      ENDIF
      5  1b2b		       00 a4	   VAREND_aiMarchA2 =	TEMPORARY_VAR
    863  1b2b
    864  1b2b							; erase object in new sqare --> blank
    865  1b2b
    866  1b2b		       a4 85		      ldy	fromX12
    867  1b2d		       84 80		      sty	squareToDraw
    868  1b2f
    869  1b2f		       a9 cc		      lda	#RAMBANK_BOARD
    870  1b31		       85 3e		      sta	SET_BANK_RAM	;@3
    871  1b33		       b9 79 fc 	      lda	Board,y
    872  1b36		       f0 03		      beq	.skipbl
    873  1b38		       20 ad f0 	      jsr	CopySinglePiece	;@0	      ; erase next square along --> blank
    874  1b3b
    875  1b3b				   .skipbl
    876  1b3b		       a4 85		      ldy	fromX12
    877  1b3d		       84 a5		      sty	__boardIndex
    878  1b3f
    879  1b3f		       a9 cc		      lda	#RAMBANK_BOARD
    880  1b41		       85 3e		      sta	SET_BANK_RAM	;@3
    881  1b43		       b9 79 fc 	      lda	Board,y
    882  1b46		       85 97		      sta	lastPiece	; what we are overwriting
    883  1b48		       a5 96		      lda	fromPiece
    884  1b4a		       09 40		      ora	#FLAG_MOVED	; prevents usage in castling for K/R
    885  1b4c		       29 df		      and	#~FLAG_ENPASSANT
    886  1b4e		       a4 a5		      ldy	__boardIndex
      0  1b50					      sta@RAM	Board,y	; and what's actually moving there
      1  1b50		       99 79 fe 	      sta	[RAM]+Board,y
    888  1b53
    889  1b53
      0  1b53					      PHASE	AI_MarchB
      1  1b53		       a9 18		      lda	#AI_MarchB
      2  1b55		       85 8b		      sta	aiState
    891  1b57		       60		      rts
    892  1b58
    893  1b58
    894  1b58							;---------------------------------------------------------------------------------------------------
    895  1b58
      0  1b58					      DEF	aiMarchB2
      1  1b58				   SLOT_aiMarchB2 SET	_BANK_SLOT
      2  1b58				   BANK_aiMarchB2 SET	SLOT_aiMarchB2 + _CURRENT_BANK
      3  1b58				   aiMarchB2
      4  1b58				   TEMPORARY_VAR SET	Overlay
      5  1b58				   TEMPORARY_OFFSET SET	0
      6  1b58				   VAR_BOUNDARY_aiMarchB2 SET	TEMPORARY_OFFSET
      7  1b58				   FUNCTION_NAME SET	aiMarchB2
    897  1b58					      SUBROUTINE
    898  1b58
      0  1b58					      REFER	AiStateMachine
      1  1b58				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1b58				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1b58					      ENDIF
      0  1b58					      VEND	aiMarchB2
      1  1b58				  -	      IFNCONST	aiMarchB2
      2  1b58				  -	      ECHO	"Incorrect VEND label", aiMarchB2
      3  1b58				  -	      ERR
      4  1b58					      ENDIF
      5  1b58		       00 a4	   VAREND_aiMarchB2 =	TEMPORARY_VAR
    901  1b58
    902  1b58		       a4 83		      ldy	lastSquareX12
    903  1b5a		       84 80		      sty	squareToDraw
    904  1b5c
    905  1b5c		       a9 cc		      lda	#RAMBANK_BOARD
    906  1b5e		       85 3e		      sta	SET_BANK_RAM	;@3
    907  1b60		       b9 79 fc 	      lda	Board,y
    908  1b63		       f0 03		      beq	.skipbl2
    909  1b65
    910  1b65		       20 ad f0 	      jsr	CopySinglePiece	;@0	      ; draw previous piece back in old position
    911  1b68				   .skipbl2
    912  1b68
    913  1b68		       a5 85		      lda	fromX12
    914  1b6a		       c5 86		      cmp	toX12
    915  1b6c		       f0 09		      beq	xhalt
    916  1b6e
    917  1b6e		       a9 64		      lda	#100	;??? inter-move segment speed (can be 0)
    918  1b70		       85 82		      sta	drawDelay
      0  1b72					      PHASE	AI_MarchToTargetA
      1  1b72		       a9 16		      lda	#AI_MarchToTargetA
      2  1b74		       85 8b		      sta	aiState
    920  1b76
    921  1b76		       60		      rts
    922  1b77
    923  1b77				   xhalt
    924  1b77
    925  1b77							;??? jsr FinaliseMove
    926  1b77
    927  1b77		       a9 04		      lda	#4	; on/off count
    928  1b79		       85 84		      sta	drawCount	; flashing for piece about to move
    929  1b7b		       a9 00		      lda	#0
    930  1b7d		       85 82		      sta	drawDelay
    931  1b7f
      0  1b7f					      PHASE	AI_FinalFlash
      1  1b7f		       a9 1b		      lda	#AI_FinalFlash
      2  1b81		       85 8b		      sta	aiState
    933  1b83		       60		      rts
    934  1b84
    935  1b84
    936  1b84							;---------------------------------------------------------------------------------------------------
    937  1b84
    938  1b84
      0  1b84					      DEF	aiWriteStartPieceBlank
      1  1b84				   SLOT_aiWriteStartPieceBlank SET	_BANK_SLOT
      2  1b84				   BANK_aiWriteStartPieceBlank SET	SLOT_aiWriteStartPieceBlank + _CURRENT_BANK
      3  1b84				   aiWriteStartPieceBlank
      4  1b84				   TEMPORARY_VAR SET	Overlay
      5  1b84				   TEMPORARY_OFFSET SET	0
      6  1b84				   VAR_BOUNDARY_aiWriteStartPieceBlank SET	TEMPORARY_OFFSET
      7  1b84				   FUNCTION_NAME SET	aiWriteStartPieceBlank
    940  1b84					      SUBROUTINE
    941  1b84
      0  1b84					      REFER	AiStateMachine
      1  1b84				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1b84				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1b84					      ENDIF
      0  1b84					      VEND	aiWriteStartPieceBlank
      1  1b84				  -	      IFNCONST	aiWriteStartPieceBlank
      2  1b84				  -	      ECHO	"Incorrect VEND label", aiWriteStartPieceBlank
      3  1b84				  -	      ERR
      4  1b84					      ENDIF
      5  1b84		       00 a4	   VAREND_aiWriteStartPieceBlank =	TEMPORARY_VAR
    944  1b84
    945  1b84							; Flash the piece in-place preparatory to moving it.
    946  1b84							; drawDelay = flash speed
    947  1b84							; drawCount = # of flashes
    948  1b84
    949  1b84		       a5 87		      lda	originX12
    950  1b86		       85 88		      sta	cursorX12
    951  1b88
    952  1b88		       a9 04		      lda	#%100
    953  1b8a		       85 4a		      sta	CTRLPF
    954  1b8c		       a9 02		      lda	#2
    955  1b8e		       85 46		      sta	COLUP0
    956  1b90
    957  1b90
    958  1b90		       a5 82		      lda	drawDelay
    959  1b92		       f0 03		      beq	deCount
    960  1b94		       c6 82		      dec	drawDelay
    961  1b96		       60		      rts
    962  1b97				   deCount
    963  1b97
    964  1b97		       a5 84		      lda	drawCount
    965  1b99		       f0 0d		      beq	flashDone
    966  1b9b		       c6 84		      dec	drawCount
    967  1b9d
    968  1b9d		       a9 0a		      lda	#READY_TO_MOVE_FLASH
    969  1b9f		       85 82		      sta	drawDelay	; "getting ready to move" flash
    970  1ba1
    971  1ba1		       a5 85		      lda	fromX12
    972  1ba3		       85 80		      sta	squareToDraw
    973  1ba5
    974  1ba5		       4c ad f0 	      jmp	CopySinglePiece	;@0	      ; EOR-draw = flash
    975  1ba8
    976  1ba8				   flashDone
    977  1ba8
      0  1ba8					      PHASE	AI_MarchToTargetA
      1  1ba8		       a9 16		      lda	#AI_MarchToTargetA
      2  1baa		       85 8b		      sta	aiState
    979  1bac		       60		      rts
    980  1bad
    981  1bad
    982  1bad							;---------------------------------------------------------------------------------------------------
    983  1bad
      0  1bad					      CHECK_BANK_SIZE	"BANK_StateMachine"
      1  1bad		       03 ad	   .TEMP      =	* - _BANK_START
 BANK_StateMachine (1K) SIZE =  $3ad , FREE= $53
      2  1bad					      ECHO	"BANK_StateMachine", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1bad				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1bad				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_StateMachine", " size=", * - ORIGIN
      5  1bad				  -	      ERR
      6  1bad					      ENDIF
    985  1bad
    986  1bad
    987  1bad							;---------------------------------------------------------------------------------------------------
    988  1bad
    989  1bad							; EOF
------- FILE ./chess.asm
------- FILE BANK_StateMachine@1#2.asm LEVEL 2 PASS 4
      0  1bad					      include	"BANK_StateMachine@1#2.asm"
      0  1bad					      SLOT	1
      1  1bad				  -	      IF	(1 < 0) || (1 > 3)
      2  1bad				  -	      ECHO	"Illegal bank address/segment location", 1
      3  1bad				  -	      ERR
      4  1bad					      ENDIF
      5  1bad				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  1bad				   _BANK_SLOT SET	1 * 64
      0  1bad					      NEWBANK	STATEMACHINE2
      1  1ea9 ????				      SEG	STATEMACHINE2
      2  1c00					      ORG	_ORIGIN
      3  1c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  1c00				   _BANK_START SET	*
      5  1c00				   STATEMACHINE2_START SET	*
      6  1c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1c00				   STATEMACHINE2 SET	_BANK_SLOT + _CURRENT_BANK
      8  1c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  1c00
      4  1c00							;---------------------------------------------------------------------------------------------------
      5  1c00
      0  1c00					      DEF	aiChoosePromotePiece
      1  1c00				   SLOT_aiChoosePromotePiece SET	_BANK_SLOT
      2  1c00				   BANK_aiChoosePromotePiece SET	SLOT_aiChoosePromotePiece + _CURRENT_BANK
      3  1c00				   aiChoosePromotePiece
      4  1c00				   TEMPORARY_VAR SET	Overlay
      5  1c00				   TEMPORARY_OFFSET SET	0
      6  1c00				   VAR_BOUNDARY_aiChoosePromotePiece SET	TEMPORARY_OFFSET
      7  1c00				   FUNCTION_NAME SET	aiChoosePromotePiece
      7  1c00					      SUBROUTINE
      8  1c00
      0  1c00					      REFER	AiStateMachine
      1  1c00				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c00				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c00					      ENDIF
      0  1c00					      VEND	aiChoosePromotePiece
      1  1c00				  -	      IFNCONST	aiChoosePromotePiece
      2  1c00				  -	      ECHO	"Incorrect VEND label", aiChoosePromotePiece
      3  1c00				  -	      ERR
      4  1c00					      ENDIF
      5  1c00		       00 a4	   VAREND_aiChoosePromotePiece =	TEMPORARY_VAR
     11  1c00
     12  1c00							; Question-mark phase has exited via joystick direction
     13  1c00							; Now we cycle through the selectable pieces
     14  1c00
     15  1c00		       ad 84 02 	      lda	INTIM
     16  1c03		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
     17  1c05		       90 40		      bcc	.exit
     18  1c07
     19  1c07		       a5 4c		      lda	INPT4
     20  1c09		       30 0a		      bmi	.nobut	; no press
     21  1c0b
     22  1c0b							; button pressed but make sure phase is correct for exit
     23  1c0b
     24  1c0b		       a9 00		      lda	#0
     25  1c0d		       85 8c		      sta	aiFlashDelay
     26  1c0f
     27  1c0f		       a5 8e		      lda	aiFlashPhase
     28  1c11		       29 01		      and	#1
     29  1c13		       f0 33		      beq	.chosen	; button pressed --> selection made
     30  1c15
     31  1c15				   .nobut
     32  1c15		       ad 80 02 	      lda	SWCHA
     33  1c18		       29 f0		      and	#$F0
     34  1c1a		       c9 f0		      cmp	#$F0
     35  1c1c		       f0 17		      beq	.odd	; no direction pressed
     36  1c1e
     37  1c1e		       4a		      lsr
     38  1c1f		       4a		      lsr
     39  1c20		       4a		      lsr
     40  1c21		       4a		      lsr
     41  1c22		       a8		      tay
     42  1c23
     43  1c23							; joystick but make sure phase is correct
     44  1c23
     45  1c23		       a5 8e		      lda	aiFlashPhase
     46  1c25		       4a		      lsr
     47  1c26		       b0 0d		      bcs	.odd	; must wait until piece undrawn
     48  1c28
     49  1c28							; cycle to the next promotable piece (N/B/R/Q)
     50  1c28							; TODO; use joy table for mod instead of just incrementing all the time
     51  1c28
     52  1c28							;clc
     53  1c28		       a5 96		      lda	fromPiece
     54  1c2a		       79 c4 f4 	      adc	JoyCombined,y
     55  1c2d		       29 03		      and	#3
     56  1c2f		       85 96		      sta	fromPiece
     57  1c31
      0  1c31					      PHASE	AI_ChooseDebounce	; wait for release
      1  1c31		       a9 22		      lda	#AI_ChooseDebounce
      2  1c33		       85 8b		      sta	aiState
     59  1c35
     60  1c35		       c6 8c	   .odd       dec	aiFlashDelay
     61  1c37		       10 0e		      bpl	.exit
     62  1c39
     63  1c39		       a9 0a	   .force     lda	#10
     64  1c3b		       85 8c		      sta	aiFlashDelay
     65  1c3d
     66  1c3d		       e6 8e		      inc	aiFlashPhase
     67  1c3f
     68  1c3f		       a4 96		      ldy	fromPiece
     69  1c41		       be 67 f4 	      ldx	promotePiece,y
     70  1c44		       20 21 fc 	      jsr	showPromoteOptions
     71  1c47
     72  1c47		       60	   .exit      rts
     73  1c48
     74  1c48
     75  1c48				   .chosen
     76  1c48		       a5 96		      lda	fromPiece
     77  1c4a		       29 0f		      and	#PIECE_MASK
     78  1c4c		       aa		      tax
     79  1c4d
     80  1c4d		       bd 6b f4 	      lda	promoteType,x
     81  1c50		       85 96		      sta	fromPiece
     82  1c52
     83  1c52		       a4 86		      ldy	toX12
     84  1c54		       a9 cc		      lda	#RAMBANK_BOARD
     85  1c56		       85 3e		      sta	SET_BANK_RAM	;@3
     86  1c58		       b9 79 fc 	      lda	Board,y
     87  1c5b		       29 0f		      and	#PIECE_MASK
     88  1c5d		       f0 03		      beq	.nothing
     89  1c5f
     90  1c5f		       20 ad f0 	      jsr	CopySinglePiece	;@0	      ; put back whatever was there to start
     91  1c62
      0  1c62				   .nothing   PHASE	AI_MoveIsSelected
      1  1c62		       a9 14		      lda	#AI_MoveIsSelected
      2  1c64		       85 8b		      sta	aiState
     93  1c66		       60		      rts
     94  1c67
      0  1c67					      ALLOCATE	promotePiece, 4
      0  1c67					      OPTIONAL_PAGEBREAK	"Table", 4
     12  1c67					      LIST	ON
      0  1c67					      DEF	promotePiece
      1  1c67				   SLOT_promotePiece SET	_BANK_SLOT
      2  1c67				   BANK_promotePiece SET	SLOT_promotePiece + _CURRENT_BANK
      3  1c67				   promotePiece
      4  1c67				   TEMPORARY_VAR SET	Overlay
      5  1c67				   TEMPORARY_OFFSET SET	0
      6  1c67				   VAR_BOUNDARY_promotePiece SET	TEMPORARY_OFFSET
      7  1c67				   FUNCTION_NAME SET	promotePiece
     96  1c67		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
     97  1c68		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
     98  1c69		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
     99  1c6a		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    100  1c6b
      0  1c6b					      ALLOCATE	promoteType,4
      0  1c6b					      OPTIONAL_PAGEBREAK	"Table", 4
     12  1c6b					      LIST	ON
      0  1c6b					      DEF	promoteType
      1  1c6b				   SLOT_promoteType SET	_BANK_SLOT
      2  1c6b				   BANK_promoteType SET	SLOT_promoteType + _CURRENT_BANK
      3  1c6b				   promoteType
      4  1c6b				   TEMPORARY_VAR SET	Overlay
      5  1c6b				   TEMPORARY_OFFSET SET	0
      6  1c6b				   VAR_BOUNDARY_promoteType SET	TEMPORARY_OFFSET
      7  1c6b				   FUNCTION_NAME SET	promoteType
    102  1c6b		       03 04 05 06	      .byte.b	KNIGHT, BISHOP, ROOK, QUEEN
    103  1c6f
    104  1c6f
    105  1c6f							;---------------------------------------------------------------------------------------------------
    106  1c6f
      0  1c6f					      DEF	aiChooseDebounce
      1  1c6f				   SLOT_aiChooseDebounce SET	_BANK_SLOT
      2  1c6f				   BANK_aiChooseDebounce SET	SLOT_aiChooseDebounce + _CURRENT_BANK
      3  1c6f				   aiChooseDebounce
      4  1c6f				   TEMPORARY_VAR SET	Overlay
      5  1c6f				   TEMPORARY_OFFSET SET	0
      6  1c6f				   VAR_BOUNDARY_aiChooseDebounce SET	TEMPORARY_OFFSET
      7  1c6f				   FUNCTION_NAME SET	aiChooseDebounce
    108  1c6f					      SUBROUTINE
    109  1c6f
      0  1c6f					      REFER	AiStateMachine
      1  1c6f				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c6f				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c6f					      ENDIF
      0  1c6f					      VEND	aiChooseDebounce
      1  1c6f				  -	      IFNCONST	aiChooseDebounce
      2  1c6f				  -	      ECHO	"Incorrect VEND label", aiChooseDebounce
      3  1c6f				  -	      ERR
      4  1c6f					      ENDIF
      5  1c6f		       00 a4	   VAREND_aiChooseDebounce =	TEMPORARY_VAR
    112  1c6f
    113  1c6f							; We've changed promotion piece, but wait for joystick to be released
    114  1c6f
    115  1c6f		       ad 80 02 	      lda	SWCHA
    116  1c72		       29 f0		      and	#$F0
    117  1c74		       c9 f0		      cmp	#$F0
    118  1c76		       d0 08		      bne	.exit	; wait while joystick still pressed
    119  1c78
    120  1c78		       a9 01		      lda	#1
    121  1c7a		       85 8c		      sta	aiFlashDelay
    122  1c7c
      0  1c7c					      PHASE	AI_ChoosePromotePiece
      1  1c7c		       a9 21		      lda	#AI_ChoosePromotePiece
      2  1c7e		       85 8b		      sta	aiState
    124  1c80		       60	   .exit      rts
    125  1c81
    126  1c81
    127  1c81							;---------------------------------------------------------------------------------------------------
    128  1c81
      0  1c81					      DEF	aiDelayAfterMove
      1  1c81				   SLOT_aiDelayAfterMove SET	_BANK_SLOT
      2  1c81				   BANK_aiDelayAfterMove SET	SLOT_aiDelayAfterMove + _CURRENT_BANK
      3  1c81				   aiDelayAfterMove
      4  1c81				   TEMPORARY_VAR SET	Overlay
      5  1c81				   TEMPORARY_OFFSET SET	0
      6  1c81				   VAR_BOUNDARY_aiDelayAfterMove SET	TEMPORARY_OFFSET
      7  1c81				   FUNCTION_NAME SET	aiDelayAfterMove
    130  1c81					      SUBROUTINE
    131  1c81
      0  1c81					      REFER	AiStateMachine
      1  1c81				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c81				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c81					      ENDIF
      0  1c81					      VEND	aiDelayAfterMove
      1  1c81				  -	      IFNCONST	aiDelayAfterMove
      2  1c81				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  1c81				  -	      ERR
      4  1c81					      ENDIF
      5  1c81		       00 a4	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
    134  1c81
    135  1c81		       a9 32		      lda	#50
    136  1c83		       85 8c		      sta	aiFlashDelay
      0  1c85					      PHASE	AI_DelayAfterMove2
      1  1c85		       a9 26		      lda	#AI_DelayAfterMove2
      2  1c87		       85 8b		      sta	aiState
    138  1c89		       60	   .exit      rts
    139  1c8a
    140  1c8a
    141  1c8a							;---------------------------------------------------------------------------------------------------
    142  1c8a
      0  1c8a					      DEF	aiDelayAfterMove2
      1  1c8a				   SLOT_aiDelayAfterMove2 SET	_BANK_SLOT
      2  1c8a				   BANK_aiDelayAfterMove2 SET	SLOT_aiDelayAfterMove2 + _CURRENT_BANK
      3  1c8a				   aiDelayAfterMove2
      4  1c8a				   TEMPORARY_VAR SET	Overlay
      5  1c8a				   TEMPORARY_OFFSET SET	0
      6  1c8a				   VAR_BOUNDARY_aiDelayAfterMove2 SET	TEMPORARY_OFFSET
      7  1c8a				   FUNCTION_NAME SET	aiDelayAfterMove2
    144  1c8a					      SUBROUTINE
    145  1c8a
      0  1c8a					      REFER	AiStateMachine
      1  1c8a				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c8a				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c8a					      ENDIF
      0  1c8a					      VEND	aiDelayAfterMove
      1  1c8a				  -	      IFNCONST	aiDelayAfterMove
      2  1c8a				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  1c8a				  -	      ERR
      4  1c8a					      ENDIF
      5  1c8a		       00 a4	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
    148  1c8a
    149  1c8a		       c6 8c		      dec	aiFlashDelay
    150  1c8c		       d0 04		      bne	.exit
      0  1c8e					      PHASE	AI_MoveIsSelected
      1  1c8e		       a9 14		      lda	#AI_MoveIsSelected
      2  1c90		       85 8b		      sta	aiState
    152  1c92		       60	   .exit      rts
    153  1c93
    154  1c93
    155  1c93							;---------------------------------------------------------------------------------------------------
    156  1c93
      0  1c93					      DEF	aiDelayAfterPlaced
      1  1c93				   SLOT_aiDelayAfterPlaced SET	_BANK_SLOT
      2  1c93				   BANK_aiDelayAfterPlaced SET	SLOT_aiDelayAfterPlaced + _CURRENT_BANK
      3  1c93				   aiDelayAfterPlaced
      4  1c93				   TEMPORARY_VAR SET	Overlay
      5  1c93				   TEMPORARY_OFFSET SET	0
      6  1c93				   VAR_BOUNDARY_aiDelayAfterPlaced SET	TEMPORARY_OFFSET
      7  1c93				   FUNCTION_NAME SET	aiDelayAfterPlaced
    158  1c93					      SUBROUTINE
    159  1c93
      0  1c93					      REFER	AiStateMachine
      1  1c93				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c93				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c93					      ENDIF
      0  1c93					      VEND	aiDelayAfterPlaced
      1  1c93				  -	      IFNCONST	aiDelayAfterPlaced
      2  1c93				  -	      ECHO	"Incorrect VEND label", aiDelayAfterPlaced
      3  1c93				  -	      ERR
      4  1c93					      ENDIF
      5  1c93		       00 a4	   VAREND_aiDelayAfterPlaced =	TEMPORARY_VAR
    162  1c93
    163  1c93		       a2 4b		      ldx	#75	; delay after human move
    164  1c95		       a5 95		      lda	sideToMove
    165  1c97		       30 02		      bmi	.computer
    166  1c99		       a2 01		      ldx	#1	; delay after computer move
    167  1c9b		       86 8c	   .computer  stx	aiFlashDelay
    168  1c9d
      0  1c9d					      PHASE	AI_DelayAfterPlaced2
      1  1c9d		       a9 28		      lda	#AI_DelayAfterPlaced2
      2  1c9f		       85 8b		      sta	aiState
    170  1ca1		       60		      rts
    171  1ca2
    172  1ca2
    173  1ca2							;---------------------------------------------------------------------------------------------------
    174  1ca2
      0  1ca2					      DEF	aiDelayAfterPlaced2
      1  1ca2				   SLOT_aiDelayAfterPlaced2 SET	_BANK_SLOT
      2  1ca2				   BANK_aiDelayAfterPlaced2 SET	SLOT_aiDelayAfterPlaced2 + _CURRENT_BANK
      3  1ca2				   aiDelayAfterPlaced2
      4  1ca2				   TEMPORARY_VAR SET	Overlay
      5  1ca2				   TEMPORARY_OFFSET SET	0
      6  1ca2				   VAR_BOUNDARY_aiDelayAfterPlaced2 SET	TEMPORARY_OFFSET
      7  1ca2				   FUNCTION_NAME SET	aiDelayAfterPlaced2
    176  1ca2					      SUBROUTINE
    177  1ca2
      0  1ca2					      REFER	AiStateMachine
      1  1ca2				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1ca2				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1ca2					      ENDIF
      0  1ca2					      VEND	aiDelayAfterPlaced2
      1  1ca2				  -	      IFNCONST	aiDelayAfterPlaced2
      2  1ca2				  -	      ECHO	"Incorrect VEND label", aiDelayAfterPlaced2
      3  1ca2				  -	      ERR
      4  1ca2					      ENDIF
      5  1ca2		       00 a4	   VAREND_aiDelayAfterPlaced2 =	TEMPORARY_VAR
    180  1ca2
    181  1ca2		       c6 8c		      dec	aiFlashDelay
    182  1ca4		       d0 04		      bne	.exit
    183  1ca6
    184  1ca6							;SWAP
    185  1ca6
      0  1ca6					      PHASE	AI_GenerateMoves
      1  1ca6		       a9 12		      lda	#AI_GenerateMoves
      2  1ca8		       85 8b		      sta	aiState
    187  1caa		       60	   .exit      rts
    188  1cab
    189  1cab
    190  1cab							;---------------------------------------------------------------------------------------------------
    191  1cab
      0  1cab					      DEF	aiMarchToTargetB
      1  1cab				   SLOT_aiMarchToTargetB SET	_BANK_SLOT
      2  1cab				   BANK_aiMarchToTargetB SET	SLOT_aiMarchToTargetB + _CURRENT_BANK
      3  1cab				   aiMarchToTargetB
      4  1cab				   TEMPORARY_VAR SET	Overlay
      5  1cab				   TEMPORARY_OFFSET SET	0
      6  1cab				   VAR_BOUNDARY_aiMarchToTargetB SET	TEMPORARY_OFFSET
      7  1cab				   FUNCTION_NAME SET	aiMarchToTargetB
    193  1cab					      SUBROUTINE
    194  1cab
      0  1cab					      REFER	AiStateMachine
      1  1cab				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1cab				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1cab					      ENDIF
      0  1cab					      VEND	aiMarchToTargetB
      1  1cab				  -	      IFNCONST	aiMarchToTargetB
      2  1cab				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetB
      3  1cab				  -	      ERR
      4  1cab					      ENDIF
      5  1cab		       00 a4	   VAREND_aiMarchToTargetB =	TEMPORARY_VAR
    197  1cab
    198  1cab							; now we want to undraw the piece in the old square
    199  1cab
    200  1cab		       a5 83		      lda	lastSquareX12
    201  1cad		       85 80		      sta	squareToDraw
    202  1caf
    203  1caf		       20 ad f0 	      jsr	CopySinglePiece	;@0	      ; erase whatever was on the previous square (completely blank)
    204  1cb2
    205  1cb2		       a4 83		      ldy	lastSquareX12
    206  1cb4		       a5 98		      lda	previousPiece
    207  1cb6
    208  1cb6		       a2 cc		      ldx	#RAMBANK_BOARD
    209  1cb8		       86 3e		      stx	SET_BANK_RAM	;@3
      0  1cba					      sta@RAM	Board,y	; and what's actually moving there
      1  1cba		       99 79 fe 	      sta	[RAM]+Board,y
    211  1cbd
    212  1cbd		       a5 97		      lda	lastPiece
    213  1cbf		       85 98		      sta	previousPiece
    214  1cc1
      0  1cc1					      PHASE	AI_MarchB2
      1  1cc1		       a9 1a		      lda	#AI_MarchB2
      2  1cc3		       85 8b		      sta	aiState
    216  1cc5		       60		      rts
    217  1cc6
    218  1cc6
    219  1cc6							;---------------------------------------------------------------------------------------------------
    220  1cc6
      0  1cc6					      DEF	aiPromotePawnStart
      1  1cc6				   SLOT_aiPromotePawnStart SET	_BANK_SLOT
      2  1cc6				   BANK_aiPromotePawnStart SET	SLOT_aiPromotePawnStart + _CURRENT_BANK
      3  1cc6				   aiPromotePawnStart
      4  1cc6				   TEMPORARY_VAR SET	Overlay
      5  1cc6				   TEMPORARY_OFFSET SET	0
      6  1cc6				   VAR_BOUNDARY_aiPromotePawnStart SET	TEMPORARY_OFFSET
      7  1cc6				   FUNCTION_NAME SET	aiPromotePawnStart
    222  1cc6					      SUBROUTINE
    223  1cc6
      0  1cc6					      REFER	AiStateMachine
      1  1cc6				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1cc6				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1cc6					      ENDIF
      0  1cc6					      VEND	aiPromotePawnStart
      1  1cc6				  -	      IFNCONST	aiPromotePawnStart
      2  1cc6				  -	      ECHO	"Incorrect VEND label", aiPromotePawnStart
      3  1cc6				  -	      ERR
      4  1cc6					      ENDIF
      5  1cc6		       00 a4	   VAREND_aiPromotePawnStart =	TEMPORARY_VAR
    226  1cc6
    227  1cc6
    228  1cc6		       ad 84 02 	      lda	INTIM
    229  1cc9		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    230  1ccb		       90 1c		      bcc	.exit
    231  1ccd
    232  1ccd		       a9 00		      lda	#0
    233  1ccf		       85 8e		      sta	aiFlashPhase
    234  1cd1		       85 8c		      sta	aiFlashDelay
    235  1cd3
    236  1cd3		       a4 86		      ldy	toX12
    237  1cd5		       84 80		      sty	squareToDraw
    238  1cd7
    239  1cd7		       a9 cc		      lda	#RAMBANK_BOARD
    240  1cd9		       85 3e		      sta	SET_BANK_RAM	;@3
    241  1cdb		       b9 79 fc 	      lda	Board,y
    242  1cde		       29 0f		      and	#PIECE_MASK
    243  1ce0		       f0 03		      beq	.empty
    244  1ce2
    245  1ce2		       20 ad f0 	      jsr	CopySinglePiece	;@0	      ; remove any capturable piece for display purposes
    246  1ce5
      0  1ce5				   .empty     PHASE	AI_RollPromotionPiece
      1  1ce5		       a9 20		      lda	#AI_RollPromotionPiece
      2  1ce7		       85 8b		      sta	aiState
    248  1ce9		       60	   .exit      rts
    249  1cea
    250  1cea
    251  1cea							;---------------------------------------------------------------------------------------------------
    252  1cea
      0  1cea					      DEF	aiGenerateMoves
      1  1cea				   SLOT_aiGenerateMoves SET	_BANK_SLOT
      2  1cea				   BANK_aiGenerateMoves SET	SLOT_aiGenerateMoves + _CURRENT_BANK
      3  1cea				   aiGenerateMoves
      4  1cea				   TEMPORARY_VAR SET	Overlay
      5  1cea				   TEMPORARY_OFFSET SET	0
      6  1cea				   VAR_BOUNDARY_aiGenerateMoves SET	TEMPORARY_OFFSET
      7  1cea				   FUNCTION_NAME SET	aiGenerateMoves
    254  1cea					      SUBROUTINE
    255  1cea
      0  1cea					      REFER	AiStateMachine
      1  1cea				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1cea				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1cea					      ENDIF
      0  1cea					      VEND	aiGenerateMoves
      1  1cea				  -	      IFNCONST	aiGenerateMoves
      2  1cea				  -	      ECHO	"Incorrect VEND label", aiGenerateMoves
      3  1cea				  -	      ERR
      4  1cea					      ENDIF
      5  1cea		       00 a4	   VAREND_aiGenerateMoves =	TEMPORARY_VAR
    258  1cea
    259  1cea		       a5 86		      lda	toX12
    260  1cec		       85 80		      sta	squareToDraw	; for showing move (display square)
    261  1cee
    262  1cee		       a6 95		      ldx	sideToMove
    263  1cf0		       10 05		      bpl	.player
    264  1cf2
    265  1cf2
      0  1cf2				   .computer  PHASE	AI_ComputerMove	; computer select move
      1  1cf2		       a9 13		      lda	#AI_ComputerMove
      2  1cf4		       85 8b		      sta	aiState
    267  1cf6		       60		      rts
    268  1cf7
    269  1cf7
      0  1cf7				   .player    PHASE	AI_StartMoveGen
      1  1cf7		       a9 0b		      lda	#AI_StartMoveGen
      2  1cf9		       85 8b		      sta	aiState
    271  1cfb		       60		      rts
    272  1cfc
    273  1cfc
    274  1cfc							;---------------------------------------------------------------------------------------------------
    275  1cfc
      0  1cfc					      DEF	aiStepMoveGen
      1  1cfc				   SLOT_aiStepMoveGen SET	_BANK_SLOT
      2  1cfc				   BANK_aiStepMoveGen SET	SLOT_aiStepMoveGen + _CURRENT_BANK
      3  1cfc				   aiStepMoveGen
      4  1cfc				   TEMPORARY_VAR SET	Overlay
      5  1cfc				   TEMPORARY_OFFSET SET	0
      6  1cfc				   VAR_BOUNDARY_aiStepMoveGen SET	TEMPORARY_OFFSET
      7  1cfc				   FUNCTION_NAME SET	aiStepMoveGen
    277  1cfc					      SUBROUTINE
    278  1cfc
      0  1cfc					      REFER	AiStateMachine
      1  1cfc				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1cfc				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1cfc					      ENDIF
      0  1cfc					      VEND	aiStepMoveGen
      1  1cfc				  -	      IFNCONST	aiStepMoveGen
      2  1cfc				  -	      ECHO	"Incorrect VEND label", aiStepMoveGen
      3  1cfc				  -	      ERR
      4  1cfc					      ENDIF
      5  1cfc		       00 a4	   VAREND_aiStepMoveGen =	TEMPORARY_VAR
    281  1cfc
    282  1cfc		       a5 87		      lda	originX12	; location of cursor (show move)
    283  1cfe		       85 88		      sta	cursorX12
      0  1d00					      PHASE	AI_BeginSelectMovePhase
      1  1d00		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  1d02		       85 8b		      sta	aiState
    285  1d04		       60		      rts
    286  1d05
    287  1d05
    288  1d05							;---------------------------------------------------------------------------------------------------
    289  1d05
    290  1e00		       00 00 00 00*	      align	256	; TODO?
      0  1e00					      DEF	PositionSprites
      1  1e00				   SLOT_PositionSprites SET	_BANK_SLOT
      2  1e00				   BANK_PositionSprites SET	SLOT_PositionSprites + _CURRENT_BANK
      3  1e00				   PositionSprites
      4  1e00				   TEMPORARY_VAR SET	Overlay
      5  1e00				   TEMPORARY_OFFSET SET	0
      6  1e00				   VAR_BOUNDARY_PositionSprites SET	TEMPORARY_OFFSET
      7  1e00				   FUNCTION_NAME SET	PositionSprites
    292  1e00					      SUBROUTINE
    293  1e00
      0  1e00					      REFER	StartupBankReset
      1  1e00				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  1e00				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  1e00					      ENDIF
      0  1e00					      VEND	PositionSprites
      1  1e00				  -	      IFNCONST	PositionSprites
      2  1e00				  -	      ECHO	"Incorrect VEND label", PositionSprites
      3  1e00				  -	      ERR
      4  1e00					      ENDIF
      5  1e00		       00 a4	   VAREND_PositionSprites =	TEMPORARY_VAR
    296  1e00
    297  1e00
    298  1e00		       a5 88		      lda	cursorX12
    299  1e02		       38		      sec
    300  1e03		       e9 0a	   .sub10     sbc	#10
    301  1e05		       b0 fc		      bcs	.sub10
    302  1e07		       69 08		      adc	#8
    303  1e09		       a8		      tay
    304  1e0a
    305  1e0a		       85 42		      sta	WSYNC	; 00	  Sync to start of scanline.
    306  1e0c
    307  1e0c		       b9 30 f6 	      lda	colToPixel,y
    308  1e0f
    309  1e0f		       38		      sec		; 02	  Set the carry flag so no borrow will be applied during the division.
    310  1e10		       e9 0f	   .divideby15 sbc	#15	; 04	  Waste the necessary amount of time dividing X-pos by 15!
    311  1e12		       b0 fc		      bcs	.divideby15	; 06/07  11/16/21/26/31/36/41/46/51/56/61/66
    312  1e14
    313  1e14		       a8		      tay
    314  1e15		       b9 30 f5 	      lda	fineAdjustTable,y	; 13 -> Consume 5 cycles by guaranteeing we cross a page boundary
    315  1e18		       85 60		      sta	HMP0
    316  1e1a		       85 50		      sta	RESP0	; 21/ 26/31/36/41/46/51/56/61/66/71 - Set the rough position.
    317  1e1c
    318  1e1c		       85 42		      sta	WSYNC
    319  1e1e		       85 6a		      sta	HMOVE
    320  1e20
    321  1e20		       60		      rts
    322  1e21
    323  1e21							; This table converts the "remainder" of the division by 15 (-1 to -15) to the correct
    324  1e21							; fine adjustment value. This table is on a page boundary to guarantee the processor
    325  1e21							; will cross a page boundary and waste a cycle in order to be at the precise position
    326  1e21							; for a RESP0,x write
    327  1e21
    328  1e21				   fineAdjustBegin
    329  1e21
    330  1e21		       70		      DC.B	%01110000	; Left 7
    331  1e22		       60		      DC.B	%01100000	; Left 6
    332  1e23		       50		      DC.B	%01010000	; Left 5
    333  1e24		       40		      DC.B	%01000000	; Left 4
    334  1e25		       30		      DC.B	%00110000	; Left 3
    335  1e26		       20		      DC.B	%00100000	; Left 2
    336  1e27		       10		      DC.B	%00010000	; Left 1
    337  1e28		       00		      DC.B	%00000000	; No movement.
    338  1e29		       f0		      DC.B	%11110000	; Right 1
    339  1e2a		       e0		      DC.B	%11100000	; Right 2
    340  1e2b		       d0		      DC.B	%11010000	; Right 3
    341  1e2c		       c0		      DC.B	%11000000	; Right 4
    342  1e2d		       b0		      DC.B	%10110000	; Right 5
    343  1e2e		       a0		      DC.B	%10100000	; Right 6
    344  1e2f		       90		      DC.B	%10010000	; Right 7
    345  1e30
    346  1e30		       f5 30	   fineAdjustTable EQU	fineAdjustBegin - %11110001	; NOTE: %11110001 = -15
    347  1e30
    348  1e30
      0  1e30					      ALLOCATE	colToPixel, 8
      0  1e30					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1e30					      LIST	ON
      0  1e30					      DEF	colToPixel
      1  1e30				   SLOT_colToPixel SET	_BANK_SLOT
      2  1e30				   BANK_colToPixel SET	SLOT_colToPixel + _CURRENT_BANK
      3  1e30				   colToPixel
      4  1e30				   TEMPORARY_VAR SET	Overlay
      5  1e30				   TEMPORARY_OFFSET SET	0
      6  1e30				   VAR_BOUNDARY_colToPixel SET	TEMPORARY_OFFSET
      7  1e30				   FUNCTION_NAME SET	colToPixel
    350  1e30		       00 14 28 3c*	      .byte.b	0,20,40,60,80,100,120,140
    351  1e38
    352  1e38
    353  1e38							;---------------------------------------------------------------------------------------------------
    354  1e38
      0  1e38					      DEF	aiMarchToTargetA
      1  1e38				   SLOT_aiMarchToTargetA SET	_BANK_SLOT
      2  1e38				   BANK_aiMarchToTargetA SET	SLOT_aiMarchToTargetA + _CURRENT_BANK
      3  1e38				   aiMarchToTargetA
      4  1e38				   TEMPORARY_VAR SET	Overlay
      5  1e38				   TEMPORARY_OFFSET SET	0
      6  1e38				   VAR_BOUNDARY_aiMarchToTargetA SET	TEMPORARY_OFFSET
      7  1e38				   FUNCTION_NAME SET	aiMarchToTargetA
    356  1e38					      SUBROUTINE
    357  1e38
      0  1e38					      REFER	AiStateMachine
      1  1e38				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1e38				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1e38					      ENDIF
    359  1e38
      0  1e38					      VAR	__fromRow, 1
      1  1e38		       00 a4	   __fromRow  =	TEMPORARY_VAR
      2  1e38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1e38
      4  1e38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1e38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1e38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1e38					      ENDIF
      8  1e38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1e38				  -	      ECHO	"Temporary Variable", __fromRow, "overflow!"
     10  1e38				  -	      ERR
     11  1e38					      ENDIF
     12  1e38					      LIST	ON
      0  1e38					      VAR	__boardIndex, 1
      1  1e38		       00 a5	   __boardIndex =	TEMPORARY_VAR
      2  1e38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1e38
      4  1e38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1e38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1e38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1e38					      ENDIF
      8  1e38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1e38				  -	      ECHO	"Temporary Variable", __boardIndex, "overflow!"
     10  1e38				  -	      ERR
     11  1e38					      ENDIF
     12  1e38					      LIST	ON
      0  1e38					      VAR	__fromCol, 1
      1  1e38		       00 a6	   __fromCol  =	TEMPORARY_VAR
      2  1e38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1e38
      4  1e38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1e38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1e38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1e38					      ENDIF
      8  1e38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1e38				  -	      ECHO	"Temporary Variable", __fromCol, "overflow!"
     10  1e38				  -	      ERR
     11  1e38					      ENDIF
     12  1e38					      LIST	ON
      0  1e38					      VAR	__toCol, 1
      1  1e38		       00 a7	   __toCol    =	TEMPORARY_VAR
      2  1e38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1e38
      4  1e38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1e38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1e38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1e38					      ENDIF
      8  1e38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1e38				  -	      ECHO	"Temporary Variable", __toCol, "overflow!"
     10  1e38				  -	      ERR
     11  1e38					      ENDIF
     12  1e38					      LIST	ON
    364  1e38
      0  1e38					      VEND	aiMarchToTargetA
      1  1e38				  -	      IFNCONST	aiMarchToTargetA
      2  1e38				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetA
      3  1e38				  -	      ERR
      4  1e38					      ENDIF
      5  1e38		       00 a8	   VAREND_aiMarchToTargetA =	TEMPORARY_VAR
    366  1e38
    367  1e38
    368  1e38							; Now we calculate move to new square
    369  1e38
    370  1e38		       a5 85		      lda	fromX12
    371  1e3a		       c5 86		      cmp	toX12
    372  1e3c		       f0 44		      beq	.unmovedx
    373  1e3e		       85 83		      sta	lastSquareX12
    374  1e40
    375  1e40		       38		      sec
    376  1e41		       a2 fd		      ldx	#-3
    377  1e43		       e9 0a	   .sub10     sbc	#10
    378  1e45		       e8		      inx
    379  1e46		       b0 fb		      bcs	.sub10
    380  1e48		       69 08		      adc	#8
    381  1e4a		       85 a6		      sta	__fromCol
    382  1e4c		       86 a4		      stx	__fromRow
    383  1e4e
    384  1e4e		       a5 86		      lda	toX12
    385  1e50		       38		      sec
    386  1e51		       a2 fd		      ldx	#-3
    387  1e53		       e9 0a	   .sub10b    sbc	#10
    388  1e55		       e8		      inx
    389  1e56		       b0 fb		      bcs	.sub10b
    390  1e58		       69 08		      adc	#8
    391  1e5a		       85 a7		      sta	__toCol
    392  1e5c
    393  1e5c
    394  1e5c		       e4 a4		      cpx	__fromRow
    395  1e5e		       f0 13		      beq	.rowDone
    396  1e60
    397  1e60		       b0 0a		      bcs	.incRow
    398  1e62
    399  1e62		       38		      sec
    400  1e63		       a5 85		      lda	fromX12
    401  1e65		       e9 0a		      sbc	#10
    402  1e67		       85 85		      sta	fromX12
    403  1e69		       4c 73 f6 	      jmp	.rowDone
    404  1e6c
    405  1e6c		       18	   .incRow    clc
    406  1e6d		       a5 85		      lda	fromX12
    407  1e6f		       69 0a		      adc	#10
    408  1e71		       85 85		      sta	fromX12
    409  1e73
    410  1e73				   .rowDone
    411  1e73
    412  1e73		       a5 a7		      lda	__toCol
    413  1e75		       c5 a6		      cmp	__fromCol
    414  1e77		       f0 09		      beq	.colDone
    415  1e79
    416  1e79		       b0 05		      bcs	.incCol
    417  1e7b
    418  1e7b		       c6 85		      dec	fromX12
    419  1e7d		       4c 82 f6 	      jmp	.colDone
    420  1e80
    421  1e80		       e6 85	   .incCol    inc	fromX12
    422  1e82				   .colDone
    423  1e82				   .unmovedx
    424  1e82
      0  1e82					      PHASE	AI_MarchA2
      1  1e82		       a9 17		      lda	#AI_MarchA2
      2  1e84		       85 8b		      sta	aiState
    426  1e86		       60		      rts
    427  1e87
    428  1e87
    429  1e87							;---------------------------------------------------------------------------------------------------
    430  1e87
      0  1e87					      DEF	aiFinalFlash
      1  1e87				   SLOT_aiFinalFlash SET	_BANK_SLOT
      2  1e87				   BANK_aiFinalFlash SET	SLOT_aiFinalFlash + _CURRENT_BANK
      3  1e87				   aiFinalFlash
      4  1e87				   TEMPORARY_VAR SET	Overlay
      5  1e87				   TEMPORARY_OFFSET SET	0
      6  1e87				   VAR_BOUNDARY_aiFinalFlash SET	TEMPORARY_OFFSET
      7  1e87				   FUNCTION_NAME SET	aiFinalFlash
    432  1e87					      SUBROUTINE
    433  1e87
      0  1e87					      REFER	AiStateMachine
      1  1e87				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1e87				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1e87					      ENDIF
      0  1e87					      VEND	aiFinalFlash
      1  1e87				  -	      IFNCONST	aiFinalFlash
      2  1e87				  -	      ECHO	"Incorrect VEND label", aiFinalFlash
      3  1e87				  -	      ERR
      4  1e87					      ENDIF
      5  1e87		       00 a4	   VAREND_aiFinalFlash =	TEMPORARY_VAR
    436  1e87
    437  1e87							; Piece has finished the animated move and is now in destination square.
    438  1e87							; Flash the piece
    439  1e87
    440  1e87		       a5 82		      lda	drawDelay
    441  1e89		       f0 03		      beq	.deCount
    442  1e8b		       c6 82		      dec	drawDelay
    443  1e8d		       60		      rts
    444  1e8e
    445  1e8e		       a5 84	   .deCount   lda	drawCount
    446  1e90		       f0 0e		      beq	.flashDone2
    447  1e92		       c6 84		      dec	drawCount
    448  1e94
    449  1e94		       a9 0a		      lda	#10
    450  1e96		       85 82		      sta	drawDelay	; "getting ready to move" flash
    451  1e98
    452  1e98		       a5 85		      lda	fromX12
    453  1e9a		       85 80		      sta	squareToDraw
    454  1e9c
    455  1e9c		       20 ad f0 	      jsr	CopySinglePiece	;@0
    456  1e9f		       60		      rts
    457  1ea0
    458  1ea0				   .flashDone2
    459  1ea0
    460  1ea0		       a9 64		      lda	#100
    461  1ea2		       85 8c		      sta	aiFlashDelay
    462  1ea4
      0  1ea4					      PHASE	AI_SpecialMoveFixup
      1  1ea4		       a9 1c		      lda	#AI_SpecialMoveFixup
      2  1ea6		       85 8b		      sta	aiState
    464  1ea8		       60		      rts
    465  1ea9
    466  1ea9
    467  1ea9							;---------------------------------------------------------------------------------------------------
    468  1ea9
    469  1ea9
      0  1ea9					      CHECK_BANK_SIZE	"BANK_StateMachine2"
      1  1ea9		       02 a9	   .TEMP      =	* - _BANK_START
 BANK_StateMachine2 (1K) SIZE =  $2a9 , FREE= $157
      2  1ea9					      ECHO	"BANK_StateMachine2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1ea9				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1ea9				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_StateMachine2", " size=", * - ORIGIN
      5  1ea9				  -	      ERR
      6  1ea9					      ENDIF
    471  1ea9
    472  1ea9
    473  1ea9							;---------------------------------------------------------------------------------------------------
    474  1ea9
    475  1ea9							; EOF
------- FILE ./chess.asm
------- FILE piece_graphics.asm LEVEL 2 PASS 4
      0  1ea9					      include	"piece_graphics.asm"
      1  1ea9							; Import the graphics definitions generated by ConvertChessPieces.py
      2  1ea9
      0  1ea9					      SLOT	2
      1  1ea9				  -	      IF	(2 < 0) || (2 > 3)
      2  1ea9				  -	      ECHO	"Illegal bank address/segment location", 2
      3  1ea9				  -	      ERR
      4  1ea9					      ENDIF
      5  1ea9				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  1ea9				   _BANK_SLOT SET	2 * 64
      0  1ea9					      NEWBANK	PIECES_0
      1  23d8 ????				      SEG	PIECES_0
      2  2000					      ORG	_ORIGIN
      3  2000					      RORG	_BANK_ADDRESS_ORIGIN
      4  2000				   _BANK_START SET	*
      5  2000				   PIECES_0_START SET	*
      6  2000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2000				   PIECES_0   SET	_BANK_SLOT + _CURRENT_BANK
      8  2000				   _ORIGIN    SET	_ORIGIN + 1024
      5  2000
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2000					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm"
      0  2000					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_0", 72
     12  2000					      LIST	ON
      0  2000					      DEF	WHITE_BLANK_on_WHITE_SQUARE_0
      1  2000				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2000				   BANK_WHITE_BLANK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2000				   WHITE_BLANK_on_WHITE_SQUARE_0
      4  2000				   TEMPORARY_VAR SET	Overlay
      5  2000				   TEMPORARY_OFFSET SET	0
      6  2000				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2000				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_0
      3  2000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$e0,$f0,$f0,$f0,$f0,$f0,$f0,$e0	;PF0
      4  2018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$00	;PF1
      5  2030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2048					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm"
      0  2048					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_1", 72
     12  2048					      LIST	ON
      0  2048					      DEF	WHITE_BLANK_on_WHITE_SQUARE_1
      1  2048				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2048				   BANK_WHITE_BLANK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2048				   WHITE_BLANK_on_WHITE_SQUARE_1
      4  2048				   TEMPORARY_VAR SET	Overlay
      5  2048				   TEMPORARY_OFFSET SET	0
      6  2048				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2048				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_1
      3  2048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2060		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$38,$7c,$7c,$7c,$7c,$7c,$7c,$38	;PF1
      5  2078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2090					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm"
      0  2090					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_2", 72
     12  2090					      LIST	ON
      0  2090					      DEF	WHITE_BLANK_on_WHITE_SQUARE_2
      1  2090				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2090				   BANK_WHITE_BLANK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2090				   WHITE_BLANK_on_WHITE_SQUARE_2
      4  2090				   TEMPORARY_VAR SET	Overlay
      5  2090				   TEMPORARY_OFFSET SET	0
      6  2090				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2090				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_2
      3  2090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  20a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$03,$03,$03,$01	;PF1
      5  20c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$07,$07,$07,$07,$07,$07,$03	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  20d8					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm"
      0  20d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_3", 72
     12  2100					      LIST	ON
      0  2100					      DEF	WHITE_BLANK_on_WHITE_SQUARE_3
      1  2100				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2100				   BANK_WHITE_BLANK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2100				   WHITE_BLANK_on_WHITE_SQUARE_3
      4  2100				   TEMPORARY_VAR SET	Overlay
      5  2100				   TEMPORARY_OFFSET SET	0
      6  2100				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2100				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_3
      3  2100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2130		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$70,$f8,$f8,$f8,$f8,$f8,$f8,$70	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2148					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm"
      0  2148					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_0", 72
     12  2148					      LIST	ON
      0  2148					      DEF	WHITE_PAWN_on_WHITE_SQUARE_0
      1  2148				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2148				   BANK_WHITE_PAWN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2148				   WHITE_PAWN_on_WHITE_SQUARE_0
      4  2148				   TEMPORARY_VAR SET	Overlay
      5  2148				   TEMPORARY_OFFSET SET	0
      6  2148				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2148				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_0
      3  2148		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$00,$00,$40,$00,$00,$00,$00	;PF0
      4  2160		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2190					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm"
      0  2190					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_1", 72
     12  2190					      LIST	ON
      0  2190					      DEF	WHITE_PAWN_on_WHITE_SQUARE_1
      1  2190				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2190				   BANK_WHITE_PAWN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2190				   WHITE_PAWN_on_WHITE_SQUARE_1
      4  2190				   TEMPORARY_VAR SET	Overlay
      5  2190				   TEMPORARY_OFFSET SET	0
      6  2190				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2190				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_1
      3  2190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  21a8		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$00,$00,$10,$00,$00,$00,$00	;PF1
      5  21c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  21d8					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm"
      0  21d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_2", 72
     12  2200					      LIST	ON
      0  2200					      DEF	WHITE_PAWN_on_WHITE_SQUARE_2
      1  2200				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2200				   BANK_WHITE_PAWN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2200				   WHITE_PAWN_on_WHITE_SQUARE_2
      4  2200				   TEMPORARY_VAR SET	Overlay
      5  2200				   TEMPORARY_OFFSET SET	0
      6  2200				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2200				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_2
      3  2200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2218		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2230		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$00,$00,$01,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2248					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm"
      0  2248					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_3", 72
     12  2248					      LIST	ON
      0  2248					      DEF	WHITE_PAWN_on_WHITE_SQUARE_3
      1  2248				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2248				   BANK_WHITE_PAWN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2248				   WHITE_PAWN_on_WHITE_SQUARE_3
      4  2248				   TEMPORARY_VAR SET	Overlay
      5  2248				   TEMPORARY_OFFSET SET	0
      6  2248				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2248				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_3
      3  2248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2278		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$00,$00,$20,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2290					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  2290					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_0", 72
     12  2290					      LIST	ON
      0  2290					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_0
      1  2290				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2290				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2290				   WHITE_KNIGHT_on_WHITE_SQUARE_0
      4  2290				   TEMPORARY_VAR SET	Overlay
      5  2290				   TEMPORARY_OFFSET SET	0
      6  2290				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2290				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_0
      3  2290		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$10,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  22a8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  22c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  22d8					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  22d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_1", 72
     12  2300					      LIST	ON
      0  2300					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_1
      1  2300				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2300				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2300				   WHITE_KNIGHT_on_WHITE_SQUARE_1
      4  2300				   TEMPORARY_VAR SET	Overlay
      5  2300				   TEMPORARY_OFFSET SET	0
      6  2300				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2300				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_1
      3  2300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2318		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$44,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2348					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  2348					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_2", 72
     12  2348					      LIST	ON
      0  2348					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_2
      1  2348				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2348				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2348				   WHITE_KNIGHT_on_WHITE_SQUARE_2
      4  2348				   TEMPORARY_VAR SET	Overlay
      5  2348				   TEMPORARY_OFFSET SET	0
      6  2348				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2348				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_2
      3  2348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2360		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$02,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2378		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$04,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2390					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  2390					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_3", 72
     12  2390					      LIST	ON
      0  2390					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_3
      1  2390				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2390				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2390				   WHITE_KNIGHT_on_WHITE_SQUARE_3
      4  2390				   TEMPORARY_VAR SET	Overlay
      5  2390				   TEMPORARY_OFFSET SET	0
      6  2390				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2390				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_3
      3  2390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  23a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  23c0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$88,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  23d8					      CHECK_BANK_SIZE	"PIECES_0 (1K)"
      1  23d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_0 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  23d8					      ECHO	"PIECES_0 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  23d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  23d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_0 (1K)", " size=", * - ORIGIN
      5  23d8				  -	      ERR
      6  23d8					      ENDIF
     19  23d8
      0  23d8					      SLOT	2
      1  23d8				  -	      IF	(2 < 0) || (2 > 3)
      2  23d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  23d8				  -	      ERR
      4  23d8					      ENDIF
      5  23d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  23d8				   _BANK_SLOT SET	2 * 64
      0  23d8					      NEWBANK	PIECES_1
      1  27d8 ????				      SEG	PIECES_1
      2  2400					      ORG	_ORIGIN
      3  2400					      RORG	_BANK_ADDRESS_ORIGIN
      4  2400				   _BANK_START SET	*
      5  2400				   PIECES_1_START SET	*
      6  2400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2400				   PIECES_1   SET	_BANK_SLOT + _CURRENT_BANK
      8  2400				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2400					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm"
      0  2400					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_0", 72
     12  2400					      LIST	ON
      0  2400					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_0
      1  2400				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2400				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2400				   WHITE_BISHOP_on_WHITE_SQUARE_0
      4  2400				   TEMPORARY_VAR SET	Overlay
      5  2400				   TEMPORARY_OFFSET SET	0
      6  2400				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2400				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_0
      3  2400		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$10,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2418		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2448					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm"
      0  2448					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_1", 72
     12  2448					      LIST	ON
      0  2448					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_1
      1  2448				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2448				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2448				   WHITE_BISHOP_on_WHITE_SQUARE_1
      4  2448				   TEMPORARY_VAR SET	Overlay
      5  2448				   TEMPORARY_OFFSET SET	0
      6  2448				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2448				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_1
      3  2448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2460		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$44,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2490					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm"
      0  2490					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_2", 72
     12  2490					      LIST	ON
      0  2490					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_2
      1  2490				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2490				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2490				   WHITE_BISHOP_on_WHITE_SQUARE_2
      4  2490				   TEMPORARY_VAR SET	Overlay
      5  2490				   TEMPORARY_OFFSET SET	0
      6  2490				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2490				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_2
      3  2490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  24a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$02,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  24c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$04,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  24d8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm"
      0  24d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_3", 72
     12  2500					      LIST	ON
      0  2500					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_3
      1  2500				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2500				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2500				   WHITE_BISHOP_on_WHITE_SQUARE_3
      4  2500				   TEMPORARY_VAR SET	Overlay
      5  2500				   TEMPORARY_OFFSET SET	0
      6  2500				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2500				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_3
      3  2500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2530		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$88,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2548					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm"
      0  2548					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_0", 72
     12  2548					      LIST	ON
      0  2548					      DEF	WHITE_ROOK_on_WHITE_SQUARE_0
      1  2548				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2548				   BANK_WHITE_ROOK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2548				   WHITE_ROOK_on_WHITE_SQUARE_0
      4  2548				   TEMPORARY_VAR SET	Overlay
      5  2548				   TEMPORARY_OFFSET SET	0
      6  2548				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2548				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_0
      3  2548		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$10,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2560		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2590					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm"
      0  2590					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_1", 72
     12  2590					      LIST	ON
      0  2590					      DEF	WHITE_ROOK_on_WHITE_SQUARE_1
      1  2590				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2590				   BANK_WHITE_ROOK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2590				   WHITE_ROOK_on_WHITE_SQUARE_1
      4  2590				   TEMPORARY_VAR SET	Overlay
      5  2590				   TEMPORARY_OFFSET SET	0
      6  2590				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2590				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_1
      3  2590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  25a8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$44,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  25c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  25d8					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm"
      0  25d8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_2", 72
     12  2600					      LIST	ON
      0  2600					      DEF	WHITE_ROOK_on_WHITE_SQUARE_2
      1  2600				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2600				   BANK_WHITE_ROOK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2600				   WHITE_ROOK_on_WHITE_SQUARE_2
      4  2600				   TEMPORARY_VAR SET	Overlay
      5  2600				   TEMPORARY_OFFSET SET	0
      6  2600				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2600				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_2
      3  2600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2618		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$02,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2630		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$04,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2648					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm"
      0  2648					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_3", 72
     12  2648					      LIST	ON
      0  2648					      DEF	WHITE_ROOK_on_WHITE_SQUARE_3
      1  2648				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2648				   BANK_WHITE_ROOK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2648				   WHITE_ROOK_on_WHITE_SQUARE_3
      4  2648				   TEMPORARY_VAR SET	Overlay
      5  2648				   TEMPORARY_OFFSET SET	0
      6  2648				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2648				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_3
      3  2648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2678		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$88,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2690					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm"
      0  2690					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_0", 72
     12  2690					      LIST	ON
      0  2690					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_0
      1  2690				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2690				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2690				   WHITE_QUEEN_on_WHITE_SQUARE_0
      4  2690				   TEMPORARY_VAR SET	Overlay
      5  2690				   TEMPORARY_OFFSET SET	0
      6  2690				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2690				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_0
      3  2690		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  26a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  26c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  26d8					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm"
      0  26d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_1", 72
     12  2700					      LIST	ON
      0  2700					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_1
      1  2700				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2700				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2700				   WHITE_QUEEN_on_WHITE_SQUARE_1
      4  2700				   TEMPORARY_VAR SET	Overlay
      5  2700				   TEMPORARY_OFFSET SET	0
      6  2700				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2700				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_1
      3  2700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2718		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2748					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm"
      0  2748					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_2", 72
     12  2748					      LIST	ON
      0  2748					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_2
      1  2748				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2748				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2748				   WHITE_QUEEN_on_WHITE_SQUARE_2
      4  2748				   TEMPORARY_VAR SET	Overlay
      5  2748				   TEMPORARY_OFFSET SET	0
      6  2748				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2748				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_2
      3  2748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2760		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2778		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2790					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm"
      0  2790					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_3", 72
     12  2790					      LIST	ON
      0  2790					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_3
      1  2790				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2790				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2790				   WHITE_QUEEN_on_WHITE_SQUARE_3
      4  2790				   TEMPORARY_VAR SET	Overlay
      5  2790				   TEMPORARY_OFFSET SET	0
      6  2790				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2790				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_3
      3  2790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  27a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  27c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  27d8					      CHECK_BANK_SIZE	"PIECES_1 (1K)"
      1  27d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_1 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  27d8					      ECHO	"PIECES_1 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  27d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  27d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_1 (1K)", " size=", * - ORIGIN
      5  27d8				  -	      ERR
      6  27d8					      ENDIF
      0  27d8					      SLOT	2
      1  27d8				  -	      IF	(2 < 0) || (2 > 3)
      2  27d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  27d8				  -	      ERR
      4  27d8					      ENDIF
      5  27d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  27d8				   _BANK_SLOT SET	2 * 64
      0  27d8					      NEWBANK	PIECES_2
      1  2bd8 ????				      SEG	PIECES_2
      2  2800					      ORG	_ORIGIN
      3  2800					      RORG	_BANK_ADDRESS_ORIGIN
      4  2800				   _BANK_START SET	*
      5  2800				   PIECES_2_START SET	*
      6  2800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2800				   PIECES_2   SET	_BANK_SLOT + _CURRENT_BANK
      8  2800				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2800					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_0.asm"
      0  2800					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_0", 72
     12  2800					      LIST	ON
      0  2800					      DEF	WHITE_KING_on_WHITE_SQUARE_0
      1  2800				   SLOT_WHITE_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2800				   BANK_WHITE_KING_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2800				   WHITE_KING_on_WHITE_SQUARE_0
      4  2800				   TEMPORARY_VAR SET	Overlay
      5  2800				   TEMPORARY_OFFSET SET	0
      6  2800				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2800				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_0
      3  2800		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$80,$40,$00,$00	;PF0
      4  2818		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2848					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_1.asm"
      0  2848					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_1", 72
     12  2848					      LIST	ON
      0  2848					      DEF	WHITE_KING_on_WHITE_SQUARE_1
      1  2848				   SLOT_WHITE_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2848				   BANK_WHITE_KING_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2848				   WHITE_KING_on_WHITE_SQUARE_1
      4  2848				   TEMPORARY_VAR SET	Overlay
      5  2848				   TEMPORARY_OFFSET SET	0
      6  2848				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2848				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_1
      3  2848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2860		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$08,$10,$00,$00	;PF1
      5  2878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2890					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_2.asm"
      0  2890					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_2", 72
     12  2890					      LIST	ON
      0  2890					      DEF	WHITE_KING_on_WHITE_SQUARE_2
      1  2890				   SLOT_WHITE_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2890				   BANK_WHITE_KING_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2890				   WHITE_KING_on_WHITE_SQUARE_2
      4  2890				   TEMPORARY_VAR SET	Overlay
      5  2890				   TEMPORARY_OFFSET SET	0
      6  2890				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2890				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_2
      3  2890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  28a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  28c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$02,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  28d8					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_3.asm"
      0  28d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_3", 72
     12  2900					      LIST	ON
      0  2900					      DEF	WHITE_KING_on_WHITE_SQUARE_3
      1  2900				   SLOT_WHITE_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2900				   BANK_WHITE_KING_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2900				   WHITE_KING_on_WHITE_SQUARE_3
      4  2900				   TEMPORARY_VAR SET	Overlay
      5  2900				   TEMPORARY_OFFSET SET	0
      6  2900				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2900				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_3
      3  2900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2930		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$40,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2948					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm"
      0  2948					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_0", 72
     12  2948					      LIST	ON
      0  2948					      DEF	WHITE_BLANK_on_BLACK_SQUARE_0
      1  2948				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2948				   BANK_WHITE_BLANK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2948				   WHITE_BLANK_on_BLACK_SQUARE_0
      4  2948				   TEMPORARY_VAR SET	Overlay
      5  2948				   TEMPORARY_OFFSET SET	0
      6  2948				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2948				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_0
      3  2948		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2990					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm"
      0  2990					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_1", 72
     12  2990					      LIST	ON
      0  2990					      DEF	WHITE_BLANK_on_BLACK_SQUARE_1
      1  2990				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2990				   BANK_WHITE_BLANK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2990				   WHITE_BLANK_on_BLACK_SQUARE_1
      4  2990				   TEMPORARY_VAR SET	Overlay
      5  2990				   TEMPORARY_OFFSET SET	0
      6  2990				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2990				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_1
      3  2990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  29a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  29c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  29d8					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm"
      0  29d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_2", 72
     12  2a00					      LIST	ON
      0  2a00					      DEF	WHITE_BLANK_on_BLACK_SQUARE_2
      1  2a00				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2a00				   BANK_WHITE_BLANK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2a00				   WHITE_BLANK_on_BLACK_SQUARE_2
      4  2a00				   TEMPORARY_VAR SET	Overlay
      5  2a00				   TEMPORARY_OFFSET SET	0
      6  2a00				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2a00				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_2
      3  2a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2a30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2a48					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm"
      0  2a48					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_3", 72
     12  2a48					      LIST	ON
      0  2a48					      DEF	WHITE_BLANK_on_BLACK_SQUARE_3
      1  2a48				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2a48				   BANK_WHITE_BLANK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2a48				   WHITE_BLANK_on_BLACK_SQUARE_3
      4  2a48				   TEMPORARY_VAR SET	Overlay
      5  2a48				   TEMPORARY_OFFSET SET	0
      6  2a48				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2a48				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_3
      3  2a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2a78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2a90					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm"
      0  2a90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_0", 72
     12  2a90					      LIST	ON
      0  2a90					      DEF	WHITE_PAWN_on_BLACK_SQUARE_0
      1  2a90				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2a90				   BANK_WHITE_PAWN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2a90				   WHITE_PAWN_on_BLACK_SQUARE_0
      4  2a90				   TEMPORARY_VAR SET	Overlay
      5  2a90				   TEMPORARY_OFFSET SET	0
      6  2a90				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2a90				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_0
      3  2a90		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$e0,$40,$00,$e0,$40,$40,$00	;PF0
      4  2aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2ad8					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm"
      0  2ad8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_1", 72
     12  2b00					      LIST	ON
      0  2b00					      DEF	WHITE_PAWN_on_BLACK_SQUARE_1
      1  2b00				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2b00				   BANK_WHITE_PAWN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2b00				   WHITE_PAWN_on_BLACK_SQUARE_1
      4  2b00				   TEMPORARY_VAR SET	Overlay
      5  2b00				   TEMPORARY_OFFSET SET	0
      6  2b00				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2b00				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_1
      3  2b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b18		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$38,$10,$00,$38,$10,$10,$00	;PF1
      5  2b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2b48					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm"
      0  2b48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_2", 72
     12  2b48					      LIST	ON
      0  2b48					      DEF	WHITE_PAWN_on_BLACK_SQUARE_2
      1  2b48				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2b48				   BANK_WHITE_PAWN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2b48				   WHITE_PAWN_on_BLACK_SQUARE_2
      4  2b48				   TEMPORARY_VAR SET	Overlay
      5  2b48				   TEMPORARY_OFFSET SET	0
      6  2b48				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2b48				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_2
      3  2b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b60		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  2b78		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$03,$01,$00,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2b90					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm"
      0  2b90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_3", 72
     12  2b90					      LIST	ON
      0  2b90					      DEF	WHITE_PAWN_on_BLACK_SQUARE_3
      1  2b90				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2b90				   BANK_WHITE_PAWN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2b90				   WHITE_PAWN_on_BLACK_SQUARE_3
      4  2b90				   TEMPORARY_VAR SET	Overlay
      5  2b90				   TEMPORARY_OFFSET SET	0
      6  2b90				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2b90				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_3
      3  2b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2bc0		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$70,$20,$00,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
      0  2bd8					      CHECK_BANK_SIZE	"PIECES_2 (1K)"
      1  2bd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_2 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  2bd8					      ECHO	"PIECES_2 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2bd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_2 (1K)", " size=", * - ORIGIN
      5  2bd8				  -	      ERR
      6  2bd8					      ENDIF
      0  2bd8					      SLOT	2
      1  2bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  2bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  2bd8				  -	      ERR
      4  2bd8					      ENDIF
      5  2bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  2bd8				   _BANK_SLOT SET	2 * 64
      0  2bd8					      NEWBANK	PIECES_3
      1  2fd8 ????				      SEG	PIECES_3
      2  2c00					      ORG	_ORIGIN
      3  2c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  2c00				   _BANK_START SET	*
      5  2c00				   PIECES_3_START SET	*
      6  2c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2c00				   PIECES_3   SET	_BANK_SLOT + _CURRENT_BANK
      8  2c00				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2c00					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  2c00					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_0", 72
     12  2c00					      LIST	ON
      0  2c00					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_0
      1  2c00				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2c00				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2c00				   WHITE_KNIGHT_on_BLACK_SQUARE_0
      4  2c00				   TEMPORARY_VAR SET	Overlay
      5  2c00				   TEMPORARY_OFFSET SET	0
      6  2c00				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2c00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_0
      3  2c00		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$f0,$e0,$e0,$f0,$f0,$40,$00	;PF0
      4  2c18		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  2c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2c48					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  2c48					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_1", 72
     12  2c48					      LIST	ON
      0  2c48					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_1
      1  2c48				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2c48				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2c48				   WHITE_KNIGHT_on_BLACK_SQUARE_1
      4  2c48				   TEMPORARY_VAR SET	Overlay
      5  2c48				   TEMPORARY_OFFSET SET	0
      6  2c48				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2c48				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_1
      3  2c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c60		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$78,$38,$3c,$7c,$7c,$14,$00	;PF1
      5  2c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2c90					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  2c90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_2", 72
     12  2c90					      LIST	ON
      0  2c90					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_2
      1  2c90				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2c90				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2c90				   WHITE_KNIGHT_on_BLACK_SQUARE_2
      4  2c90				   TEMPORARY_VAR SET	Overlay
      5  2c90				   TEMPORARY_OFFSET SET	0
      6  2c90				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2c90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_2
      3  2c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ca8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$01,$03,$03,$00,$00	;PF1
      5  2cc0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$03,$03,$07,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2cd8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  2cd8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_3", 72
     12  2d00					      LIST	ON
      0  2d00					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_3
      1  2d00				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2d00				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2d00				   WHITE_KNIGHT_on_BLACK_SQUARE_3
      4  2d00				   TEMPORARY_VAR SET	Overlay
      5  2d00				   TEMPORARY_OFFSET SET	0
      6  2d00				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2d00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_3
      3  2d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d30		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$78,$70,$f0,$f8,$f8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2d48					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm"
      0  2d48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_0", 72
     12  2d48					      LIST	ON
      0  2d48					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_0
      1  2d48				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2d48				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2d48				   WHITE_BISHOP_on_BLACK_SQUARE_0
      4  2d48				   TEMPORARY_VAR SET	Overlay
      5  2d48				   TEMPORARY_OFFSET SET	0
      6  2d48				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2d48				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_0
      3  2d48		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$b0,$d0,$e0,$40,$40	;PF0
      4  2d60		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  2d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2d90					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm"
      0  2d90					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_1", 72
     12  2d90					      LIST	ON
      0  2d90					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_1
      1  2d90				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2d90				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2d90				   WHITE_BISHOP_on_BLACK_SQUARE_1
      4  2d90				   TEMPORARY_VAR SET	Overlay
      5  2d90				   TEMPORARY_OFFSET SET	0
      6  2d90				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2d90				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_1
      3  2d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2da8		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$6c,$5c,$38,$10,$10	;PF1
      5  2dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2dd8					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm"
      0  2dd8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_2", 72
     12  2e00					      LIST	ON
      0  2e00					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_2
      1  2e00				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2e00				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2e00				   WHITE_BISHOP_on_BLACK_SQUARE_2
      4  2e00				   TEMPORARY_VAR SET	Overlay
      5  2e00				   TEMPORARY_OFFSET SET	0
      6  2e00				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2e00				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_2
      3  2e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e18		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  2e30		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$06,$07,$03,$01,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2e48					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm"
      0  2e48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_3", 72
     12  2e48					      LIST	ON
      0  2e48					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_3
      1  2e48				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2e48				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2e48				   WHITE_BISHOP_on_BLACK_SQUARE_3
      4  2e48				   TEMPORARY_VAR SET	Overlay
      5  2e48				   TEMPORARY_OFFSET SET	0
      6  2e48				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2e48				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_3
      3  2e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e78		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$d8,$e8,$70,$20,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2e90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm"
      0  2e90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_0", 72
     12  2e90					      LIST	ON
      0  2e90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_0
      1  2e90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2e90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2e90				   WHITE_ROOK_on_BLACK_SQUARE_0
      4  2e90				   TEMPORARY_VAR SET	Overlay
      5  2e90				   TEMPORARY_OFFSET SET	0
      6  2e90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2e90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_0
      3  2e90		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$f0,$50,$00	;PF0
      4  2ea8		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  2ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2ed8					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm"
      0  2ed8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_1", 72
     12  2f00					      LIST	ON
      0  2f00					      DEF	WHITE_ROOK_on_BLACK_SQUARE_1
      1  2f00				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2f00				   BANK_WHITE_ROOK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2f00				   WHITE_ROOK_on_BLACK_SQUARE_1
      4  2f00				   TEMPORARY_VAR SET	Overlay
      5  2f00				   TEMPORARY_OFFSET SET	0
      6  2f00				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2f00				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_1
      3  2f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f18		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$7c,$54,$00	;PF1
      5  2f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2f48					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm"
      0  2f48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_2", 72
     12  2f48					      LIST	ON
      0  2f48					      DEF	WHITE_ROOK_on_BLACK_SQUARE_2
      1  2f48				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2f48				   BANK_WHITE_ROOK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2f48				   WHITE_ROOK_on_BLACK_SQUARE_2
      4  2f48				   TEMPORARY_VAR SET	Overlay
      5  2f48				   TEMPORARY_OFFSET SET	0
      6  2f48				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2f48				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_2
      3  2f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f60		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$03,$02,$00	;PF1
      5  2f78		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2f90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm"
      0  2f90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_3", 72
     12  2f90					      LIST	ON
      0  2f90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_3
      1  2f90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2f90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2f90				   WHITE_ROOK_on_BLACK_SQUARE_3
      4  2f90				   TEMPORARY_VAR SET	Overlay
      5  2f90				   TEMPORARY_OFFSET SET	0
      6  2f90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2f90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_3
      3  2f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2fc0		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$f8,$a8,$00	;PF2
------- FILE piece_graphics.asm
      0  2fd8					      CHECK_BANK_SIZE	"PIECES_3 (1K)"
      1  2fd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_3 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  2fd8					      ECHO	"PIECES_3 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2fd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_3 (1K)", " size=", * - ORIGIN
      5  2fd8				  -	      ERR
      6  2fd8					      ENDIF
      0  2fd8					      SLOT	2
      1  2fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  2fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  2fd8				  -	      ERR
      4  2fd8					      ENDIF
      5  2fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  2fd8				   _BANK_SLOT SET	2 * 64
      0  2fd8					      NEWBANK	PIECE_4
      1  33d8 ????				      SEG	PIECE_4
      2  3000					      ORG	_ORIGIN
      3  3000					      RORG	_BANK_ADDRESS_ORIGIN
      4  3000				   _BANK_START SET	*
      5  3000				   PIECE_4_START SET	*
      6  3000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3000				   PIECE_4    SET	_BANK_SLOT + _CURRENT_BANK
      8  3000				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3000					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm"
      0  3000					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_0", 72
     12  3000					      LIST	ON
      0  3000					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_0
      1  3000				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3000				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3000				   WHITE_QUEEN_on_BLACK_SQUARE_0
      4  3000				   TEMPORARY_VAR SET	Overlay
      5  3000				   TEMPORARY_OFFSET SET	0
      6  3000				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3000				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_0
      3  3000		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  3018		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00,$80,$00	;PF1
      5  3030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3048					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm"
      0  3048					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_1", 72
     12  3048					      LIST	ON
      0  3048					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_1
      1  3048				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3048				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3048				   WHITE_QUEEN_on_BLACK_SQUARE_1
      4  3048				   TEMPORARY_VAR SET	Overlay
      5  3048				   TEMPORARY_OFFSET SET	0
      6  3048				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3048				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_1
      3  3048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3060		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$7c,$7c,$54,$00,$54,$00	;PF1
      5  3078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3090					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm"
      0  3090					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_2", 72
     12  3090					      LIST	ON
      0  3090					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_2
      1  3090				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3090				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3090				   WHITE_QUEEN_on_BLACK_SQUARE_2
      4  3090				   TEMPORARY_VAR SET	Overlay
      5  3090				   TEMPORARY_OFFSET SET	0
      6  3090				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3090				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_2
      3  3090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  30a8		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  30c0		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$07,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  30d8					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm"
      0  30d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_3", 72
     12  3100					      LIST	ON
      0  3100					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_3
      1  3100				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3100				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3100				   WHITE_QUEEN_on_BLACK_SQUARE_3
      4  3100				   TEMPORARY_VAR SET	Overlay
      5  3100				   TEMPORARY_OFFSET SET	0
      6  3100				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3100				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_3
      3  3100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3130		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$f8,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3148					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_0.asm"
      0  3148					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_0", 72
     12  3148					      LIST	ON
      0  3148					      DEF	WHITE_KING_on_BLACK_SQUARE_0
      1  3148				   SLOT_WHITE_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3148				   BANK_WHITE_KING_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3148				   WHITE_KING_on_BLACK_SQUARE_0
      4  3148				   TEMPORARY_VAR SET	Overlay
      5  3148				   TEMPORARY_OFFSET SET	0
      6  3148				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3148				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_0
      3  3148		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$70,$00,$e0,$40	;PF0
      4  3160		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  3178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3190					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_1.asm"
      0  3190					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_1", 72
     12  3190					      LIST	ON
      0  3190					      DEF	WHITE_KING_on_BLACK_SQUARE_1
      1  3190				   SLOT_WHITE_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3190				   BANK_WHITE_KING_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3190				   WHITE_KING_on_BLACK_SQUARE_1
      4  3190				   TEMPORARY_VAR SET	Overlay
      5  3190				   TEMPORARY_OFFSET SET	0
      6  3190				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3190				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_1
      3  3190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  31a8		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$74,$00,$38,$10	;PF1
      5  31c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  31d8					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_2.asm"
      0  31d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_2", 72
     12  3200					      LIST	ON
      0  3200					      DEF	WHITE_KING_on_BLACK_SQUARE_2
      1  3200				   SLOT_WHITE_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3200				   BANK_WHITE_KING_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3200				   WHITE_KING_on_BLACK_SQUARE_2
      4  3200				   TEMPORARY_VAR SET	Overlay
      5  3200				   TEMPORARY_OFFSET SET	0
      6  3200				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3200				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_2
      3  3200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3218		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  3230		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$05,$00,$03,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3248					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_3.asm"
      0  3248					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_3", 72
     12  3248					      LIST	ON
      0  3248					      DEF	WHITE_KING_on_BLACK_SQUARE_3
      1  3248				   SLOT_WHITE_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3248				   BANK_WHITE_KING_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3248				   WHITE_KING_on_BLACK_SQUARE_3
      4  3248				   TEMPORARY_VAR SET	Overlay
      5  3248				   TEMPORARY_OFFSET SET	0
      6  3248				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3248				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_3
      3  3248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3278		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$b8,$00,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3290					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm"
      0  3290					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_0", 72
     12  3290					      LIST	ON
      0  3290					      DEF	BLACK_BLANK_on_WHITE_SQUARE_0
      1  3290				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3290				   BANK_BLACK_BLANK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3290				   BLACK_BLANK_on_WHITE_SQUARE_0
      4  3290				   TEMPORARY_VAR SET	Overlay
      5  3290				   TEMPORARY_OFFSET SET	0
      6  3290				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3290				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_0
      3  3290		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$e0,$f0,$f0,$f0,$f0,$f0,$f0,$e0	;PF0
      4  32a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$00	;PF1
      5  32c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  32d8					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm"
      0  32d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_1", 72
     12  3300					      LIST	ON
      0  3300					      DEF	BLACK_BLANK_on_WHITE_SQUARE_1
      1  3300				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3300				   BANK_BLACK_BLANK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3300				   BLACK_BLANK_on_WHITE_SQUARE_1
      4  3300				   TEMPORARY_VAR SET	Overlay
      5  3300				   TEMPORARY_OFFSET SET	0
      6  3300				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3300				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_1
      3  3300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3318		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$38,$7c,$7c,$7c,$7c,$7c,$7c,$38	;PF1
      5  3330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3348					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm"
      0  3348					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_2", 72
     12  3348					      LIST	ON
      0  3348					      DEF	BLACK_BLANK_on_WHITE_SQUARE_2
      1  3348				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3348				   BANK_BLACK_BLANK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3348				   BLACK_BLANK_on_WHITE_SQUARE_2
      4  3348				   TEMPORARY_VAR SET	Overlay
      5  3348				   TEMPORARY_OFFSET SET	0
      6  3348				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3348				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_2
      3  3348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$03,$03,$03,$01	;PF1
      5  3378		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$07,$07,$07,$07,$07,$07,$03	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3390					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm"
      0  3390					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_3", 72
     12  3390					      LIST	ON
      0  3390					      DEF	BLACK_BLANK_on_WHITE_SQUARE_3
      1  3390				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3390				   BANK_BLACK_BLANK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3390				   BLACK_BLANK_on_WHITE_SQUARE_3
      4  3390				   TEMPORARY_VAR SET	Overlay
      5  3390				   TEMPORARY_OFFSET SET	0
      6  3390				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3390				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_3
      3  3390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  33a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  33c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$70,$f8,$f8,$f8,$f8,$f8,$f8,$70	;PF2
------- FILE piece_graphics.asm
      0  33d8					      CHECK_BANK_SIZE	"PIECES_4 (1K)"
      1  33d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_4 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  33d8					      ECHO	"PIECES_4 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  33d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  33d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_4 (1K)", " size=", * - ORIGIN
      5  33d8				  -	      ERR
      6  33d8					      ENDIF
      0  33d8					      SLOT	2
      1  33d8				  -	      IF	(2 < 0) || (2 > 3)
      2  33d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  33d8				  -	      ERR
      4  33d8					      ENDIF
      5  33d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  33d8				   _BANK_SLOT SET	2 * 64
      0  33d8					      NEWBANK	PIECE_5
      1  37d8 ????				      SEG	PIECE_5
      2  3400					      ORG	_ORIGIN
      3  3400					      RORG	_BANK_ADDRESS_ORIGIN
      4  3400				   _BANK_START SET	*
      5  3400				   PIECE_5_START SET	*
      6  3400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3400				   PIECE_5    SET	_BANK_SLOT + _CURRENT_BANK
      8  3400				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3400					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm"
      0  3400					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_0", 72
     12  3400					      LIST	ON
      0  3400					      DEF	BLACK_PAWN_on_WHITE_SQUARE_0
      1  3400				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3400				   BANK_BLACK_PAWN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3400				   BLACK_PAWN_on_WHITE_SQUARE_0
      4  3400				   TEMPORARY_VAR SET	Overlay
      5  3400				   TEMPORARY_OFFSET SET	0
      6  3400				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3400				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_0
      3  3400		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00	;PF0
      4  3418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3448					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm"
      0  3448					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_1", 72
     12  3448					      LIST	ON
      0  3448					      DEF	BLACK_PAWN_on_WHITE_SQUARE_1
      1  3448				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3448				   BANK_BLACK_PAWN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3448				   BLACK_PAWN_on_WHITE_SQUARE_1
      4  3448				   TEMPORARY_VAR SET	Overlay
      5  3448				   TEMPORARY_OFFSET SET	0
      6  3448				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3448				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_1
      3  3448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3460		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00	;PF1
      5  3478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3490					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm"
      0  3490					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_2", 72
     12  3490					      LIST	ON
      0  3490					      DEF	BLACK_PAWN_on_WHITE_SQUARE_2
      1  3490				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3490				   BANK_BLACK_PAWN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3490				   BLACK_PAWN_on_WHITE_SQUARE_2
      4  3490				   TEMPORARY_VAR SET	Overlay
      5  3490				   TEMPORARY_OFFSET SET	0
      6  3490				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3490				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_2
      3  3490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  34a8		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  34c0		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  34d8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm"
      0  34d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_3", 72
     12  3500					      LIST	ON
      0  3500					      DEF	BLACK_PAWN_on_WHITE_SQUARE_3
      1  3500				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3500				   BANK_BLACK_PAWN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3500				   BLACK_PAWN_on_WHITE_SQUARE_3
      4  3500				   TEMPORARY_VAR SET	Overlay
      5  3500				   TEMPORARY_OFFSET SET	0
      6  3500				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3500				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_3
      3  3500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3530		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3548					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  3548					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_0", 72
     12  3548					      LIST	ON
      0  3548					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_0
      1  3548				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3548				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3548				   BLACK_KNIGHT_on_WHITE_SQUARE_0
      4  3548				   TEMPORARY_VAR SET	Overlay
      5  3548				   TEMPORARY_OFFSET SET	0
      6  3548				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3548				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_0
      3  3548		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$e0,$70,$e0,$c0,$f0,$b0,$40,$00	;PF0
      4  3560		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  3578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3590					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  3590					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_1", 72
     12  3590					      LIST	ON
      0  3590					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_1
      1  3590				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3590				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3590				   BLACK_KNIGHT_on_WHITE_SQUARE_1
      4  3590				   TEMPORARY_VAR SET	Overlay
      5  3590				   TEMPORARY_OFFSET SET	0
      6  3590				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3590				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_1
      3  3590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  35a8		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$38,$70,$38,$1c,$7c,$6c,$14,$00	;PF1
      5  35c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  35d8					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  35d8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_2", 72
     12  3600					      LIST	ON
      0  3600					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_2
      1  3600				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3600				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3600				   BLACK_KNIGHT_on_WHITE_SQUARE_2
      4  3600				   TEMPORARY_VAR SET	Overlay
      5  3600				   TEMPORARY_OFFSET SET	0
      6  3600				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3600				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_2
      3  3600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3618		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$01,$03,$01,$00,$03,$03,$00,$00	;PF1
      5  3630		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$03,$01,$03,$07,$07,$06,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3648					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  3648					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_3", 72
     12  3648					      LIST	ON
      0  3648					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_3
      1  3648				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3648				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3648				   BLACK_KNIGHT_on_WHITE_SQUARE_3
      4  3648				   TEMPORARY_VAR SET	Overlay
      5  3648				   TEMPORARY_OFFSET SET	0
      6  3648				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3648				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_3
      3  3648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3678		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$70,$38,$70,$e0,$f8,$d8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3690					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm"
      0  3690					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_0", 72
     12  3690					      LIST	ON
      0  3690					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_0
      1  3690				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3690				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3690				   BLACK_BISHOP_on_WHITE_SQUARE_0
      4  3690				   TEMPORARY_VAR SET	Overlay
      5  3690				   TEMPORARY_OFFSET SET	0
      6  3690				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3690				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_0
      3  3690		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$e0,$e0,$f0,$b0,$d0,$e0,$00,$40	;PF0
      4  36a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  36c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  36d8					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm"
      0  36d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_1", 72
     12  3700					      LIST	ON
      0  3700					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_1
      1  3700				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3700				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3700				   BLACK_BISHOP_on_WHITE_SQUARE_1
      4  3700				   TEMPORARY_VAR SET	Overlay
      5  3700				   TEMPORARY_OFFSET SET	0
      6  3700				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3700				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_1
      3  3700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3718		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$38,$38,$78,$6c,$5c,$38,$00,$10	;PF1
      5  3730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3748					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm"
      0  3748					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_2", 72
     12  3748					      LIST	ON
      0  3748					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_2
      1  3748				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3748				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3748				   BLACK_BISHOP_on_WHITE_SQUARE_2
      4  3748				   TEMPORARY_VAR SET	Overlay
      5  3748				   TEMPORARY_OFFSET SET	0
      6  3748				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3748				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_2
      3  3748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3760		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$01,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  3778		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$03,$03,$03,$06,$07,$03,$00,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3790					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm"
      0  3790					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_3", 72
     12  3790					      LIST	ON
      0  3790					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_3
      1  3790				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3790				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3790				   BLACK_BISHOP_on_WHITE_SQUARE_3
      4  3790				   TEMPORARY_VAR SET	Overlay
      5  3790				   TEMPORARY_OFFSET SET	0
      6  3790				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3790				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_3
      3  3790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  37a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  37c0		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$70,$70,$78,$d8,$e8,$70,$00,$20	;PF2
------- FILE piece_graphics.asm
      0  37d8					      CHECK_BANK_SIZE	"PIECES_5 (1K)"
      1  37d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_5 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  37d8					      ECHO	"PIECES_5 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  37d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  37d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_5 (1K)", " size=", * - ORIGIN
      5  37d8				  -	      ERR
      6  37d8					      ENDIF
      0  37d8					      SLOT	2
      1  37d8				  -	      IF	(2 < 0) || (2 > 3)
      2  37d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  37d8				  -	      ERR
      4  37d8					      ENDIF
      5  37d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  37d8				   _BANK_SLOT SET	2 * 64
      0  37d8					      NEWBANK	PIECE_6
      1  3b90 ????				      SEG	PIECE_6
      2  3800					      ORG	_ORIGIN
      3  3800					      RORG	_BANK_ADDRESS_ORIGIN
      4  3800				   _BANK_START SET	*
      5  3800				   PIECE_6_START SET	*
      6  3800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3800				   PIECE_6    SET	_BANK_SLOT + _CURRENT_BANK
      8  3800				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3800					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm"
      0  3800					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_0", 72
     12  3800					      LIST	ON
      0  3800					      DEF	BLACK_ROOK_on_WHITE_SQUARE_0
      1  3800				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3800				   BANK_BLACK_ROOK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3800				   BLACK_ROOK_on_WHITE_SQUARE_0
      4  3800				   TEMPORARY_VAR SET	Overlay
      5  3800				   TEMPORARY_OFFSET SET	0
      6  3800				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3800				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_0
      3  3800		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$e0,$e0,$e0,$e0,$f0,$50,$50,$00	;PF0
      4  3818		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  3830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3848					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm"
      0  3848					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_1", 72
     12  3848					      LIST	ON
      0  3848					      DEF	BLACK_ROOK_on_WHITE_SQUARE_1
      1  3848				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3848				   BANK_BLACK_ROOK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3848				   BLACK_ROOK_on_WHITE_SQUARE_1
      4  3848				   TEMPORARY_VAR SET	Overlay
      5  3848				   TEMPORARY_OFFSET SET	0
      6  3848				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3848				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_1
      3  3848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3860		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$38,$38,$38,$38,$7c,$54,$54,$00	;PF1
      5  3878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3890					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm"
      0  3890					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_2", 72
     12  3890					      LIST	ON
      0  3890					      DEF	BLACK_ROOK_on_WHITE_SQUARE_2
      1  3890				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3890				   BANK_BLACK_ROOK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3890				   BLACK_ROOK_on_WHITE_SQUARE_2
      4  3890				   TEMPORARY_VAR SET	Overlay
      5  3890				   TEMPORARY_OFFSET SET	0
      6  3890				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3890				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_2
      3  3890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  38a8		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$01,$01,$01,$01,$03,$02,$02,$00	;PF1
      5  38c0		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$03,$03,$03,$03,$07,$05,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  38d8					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm"
      0  38d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_3", 72
     12  3900					      LIST	ON
      0  3900					      DEF	BLACK_ROOK_on_WHITE_SQUARE_3
      1  3900				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3900				   BANK_BLACK_ROOK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3900				   BLACK_ROOK_on_WHITE_SQUARE_3
      4  3900				   TEMPORARY_VAR SET	Overlay
      5  3900				   TEMPORARY_OFFSET SET	0
      6  3900				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3900				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_3
      3  3900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3930		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$70,$70,$70,$70,$f8,$a8,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3948					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm"
      0  3948					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_0", 72
     12  3948					      LIST	ON
      0  3948					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_0
      1  3948				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3948				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3948				   BLACK_QUEEN_on_WHITE_SQUARE_0
      4  3948				   TEMPORARY_VAR SET	Overlay
      5  3948				   TEMPORARY_OFFSET SET	0
      6  3948				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3948				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_0
      3  3948		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  3960		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$80,$80,$00,$80,$00	;PF1
      5  3978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3990					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm"
      0  3990					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_1", 72
     12  3990					      LIST	ON
      0  3990					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_1
      1  3990				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3990				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3990				   BLACK_QUEEN_on_WHITE_SQUARE_1
      4  3990				   TEMPORARY_VAR SET	Overlay
      5  3990				   TEMPORARY_OFFSET SET	0
      6  3990				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3990				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_1
      3  3990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  39a8		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$78,$7c,$54,$00,$54,$00	;PF1
      5  39c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  39d8					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm"
      0  39d8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_2", 72
     12  3a00					      LIST	ON
      0  3a00					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_2
      1  3a00				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3a00				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3a00				   BLACK_QUEEN_on_WHITE_SQUARE_2
      4  3a00				   TEMPORARY_VAR SET	Overlay
      5  3a00				   TEMPORARY_OFFSET SET	0
      6  3a00				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3a00				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_2
      3  3a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a18		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  3a30		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$03,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3a48					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm"
      0  3a48					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_3", 72
     12  3a48					      LIST	ON
      0  3a48					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_3
      1  3a48				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3a48				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3a48				   BLACK_QUEEN_on_WHITE_SQUARE_3
      4  3a48				   TEMPORARY_VAR SET	Overlay
      5  3a48				   TEMPORARY_OFFSET SET	0
      6  3a48				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3a48				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_3
      3  3a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3a78		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$78,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3a90					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_0.asm"
      0  3a90					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_0", 72
     12  3a90					      LIST	ON
      0  3a90					      DEF	BLACK_KING_on_WHITE_SQUARE_0
      1  3a90				   SLOT_BLACK_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3a90				   BANK_BLACK_KING_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3a90				   BLACK_KING_on_WHITE_SQUARE_0
      4  3a90				   TEMPORARY_VAR SET	Overlay
      5  3a90				   TEMPORARY_OFFSET SET	0
      6  3a90				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3a90				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_0
      3  3a90		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$f0,$40,$e0,$40	;PF0
      4  3aa8		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  3ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ad8					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_1.asm"
      0  3ad8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_1", 72
     12  3b00					      LIST	ON
      0  3b00					      DEF	BLACK_KING_on_WHITE_SQUARE_1
      1  3b00				   SLOT_BLACK_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3b00				   BANK_BLACK_KING_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3b00				   BLACK_KING_on_WHITE_SQUARE_1
      4  3b00				   TEMPORARY_VAR SET	Overlay
      5  3b00				   TEMPORARY_OFFSET SET	0
      6  3b00				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3b00				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_1
      3  3b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b18		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$7c,$10,$38,$10	;PF1
      5  3b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3b48					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_2.asm"
      0  3b48					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_2", 72
     12  3b48					      LIST	ON
      0  3b48					      DEF	BLACK_KING_on_WHITE_SQUARE_2
      1  3b48				   SLOT_BLACK_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3b48				   BANK_BLACK_KING_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3b48				   BLACK_KING_on_WHITE_SQUARE_2
      4  3b48				   TEMPORARY_VAR SET	Overlay
      5  3b48				   TEMPORARY_OFFSET SET	0
      6  3b48				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3b48				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_2
      3  3b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b60		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  3b78		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$07,$01,$03,$01	;PF2
------- FILE piece_graphics.asm
      0  3b90					      CHECK_BANK_SIZE	"PIECES_6 (1K)"
      1  3b90		       03 90	   .TEMP      =	* - _BANK_START
 PIECES_6 (1K) (1K) SIZE =  $390 , FREE= $70
      2  3b90					      ECHO	"PIECES_6 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  3b90				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3b90				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_6 (1K)", " size=", * - ORIGIN
      5  3b90				  -	      ERR
      6  3b90					      ENDIF
      0  3b90					      SLOT	2
      1  3b90				  -	      IF	(2 < 0) || (2 > 3)
      2  3b90				  -	      ECHO	"Illegal bank address/segment location", 2
      3  3b90				  -	      ERR
      4  3b90					      ENDIF
      5  3b90				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  3b90				   _BANK_SLOT SET	2 * 64
      0  3b90					      NEWBANK	PIECE_7
      1  3fd8 ????				      SEG	PIECE_7
      2  3c00					      ORG	_ORIGIN
      3  3c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  3c00				   _BANK_START SET	*
      5  3c00				   PIECE_7_START SET	*
      6  3c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3c00				   PIECE_7    SET	_BANK_SLOT + _CURRENT_BANK
      8  3c00				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3c00					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_3.asm"
      0  3c00					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_3", 72
     12  3c00					      LIST	ON
      0  3c00					      DEF	BLACK_KING_on_WHITE_SQUARE_3
      1  3c00				   SLOT_BLACK_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3c00				   BANK_BLACK_KING_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3c00				   BLACK_KING_on_WHITE_SQUARE_3
      4  3c00				   TEMPORARY_VAR SET	Overlay
      5  3c00				   TEMPORARY_OFFSET SET	0
      6  3c00				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3c00				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_3
      3  3c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3c30		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$f8,$20,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3c48					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm"
      0  3c48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_0", 72
     12  3c48					      LIST	ON
      0  3c48					      DEF	BLACK_BLANK_on_BLACK_SQUARE_0
      1  3c48				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3c48				   BANK_BLACK_BLANK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3c48				   BLACK_BLANK_on_BLACK_SQUARE_0
      4  3c48				   TEMPORARY_VAR SET	Overlay
      5  3c48				   TEMPORARY_OFFSET SET	0
      6  3c48				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3c48				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_0
      3  3c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3c60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3c90					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm"
      0  3c90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_1", 72
     12  3c90					      LIST	ON
      0  3c90					      DEF	BLACK_BLANK_on_BLACK_SQUARE_1
      1  3c90				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3c90				   BANK_BLACK_BLANK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3c90				   BLACK_BLANK_on_BLACK_SQUARE_1
      4  3c90				   TEMPORARY_VAR SET	Overlay
      5  3c90				   TEMPORARY_OFFSET SET	0
      6  3c90				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3c90				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_1
      3  3c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3cd8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm"
      0  3cd8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_2", 72
     12  3d00					      LIST	ON
      0  3d00					      DEF	BLACK_BLANK_on_BLACK_SQUARE_2
      1  3d00				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3d00				   BANK_BLACK_BLANK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3d00				   BLACK_BLANK_on_BLACK_SQUARE_2
      4  3d00				   TEMPORARY_VAR SET	Overlay
      5  3d00				   TEMPORARY_OFFSET SET	0
      6  3d00				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3d00				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_2
      3  3d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3d48					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm"
      0  3d48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_3", 72
     12  3d48					      LIST	ON
      0  3d48					      DEF	BLACK_BLANK_on_BLACK_SQUARE_3
      1  3d48				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3d48				   BANK_BLACK_BLANK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3d48				   BLACK_BLANK_on_BLACK_SQUARE_3
      4  3d48				   TEMPORARY_VAR SET	Overlay
      5  3d48				   TEMPORARY_OFFSET SET	0
      6  3d48				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3d48				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_3
      3  3d48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3d90					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm"
      0  3d90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_0", 72
     12  3d90					      LIST	ON
      0  3d90					      DEF	BLACK_PAWN_on_BLACK_SQUARE_0
      1  3d90				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3d90				   BANK_BLACK_PAWN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3d90				   BLACK_PAWN_on_BLACK_SQUARE_0
      4  3d90				   TEMPORARY_VAR SET	Overlay
      5  3d90				   TEMPORARY_OFFSET SET	0
      6  3d90				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3d90				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_0
      3  3d90		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$40,$00,$00	;PF0
      4  3da8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3dd8					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm"
      0  3dd8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_1", 72
     12  3e00					      LIST	ON
      0  3e00					      DEF	BLACK_PAWN_on_BLACK_SQUARE_1
      1  3e00				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3e00				   BANK_BLACK_PAWN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3e00				   BLACK_PAWN_on_BLACK_SQUARE_1
      4  3e00				   TEMPORARY_VAR SET	Overlay
      5  3e00				   TEMPORARY_OFFSET SET	0
      6  3e00				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3e00				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_1
      3  3e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e18		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$00,$00,$00,$00,$10,$00,$00	;PF1
      5  3e30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3e48					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm"
      0  3e48					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_2", 72
     12  3e48					      LIST	ON
      0  3e48					      DEF	BLACK_PAWN_on_BLACK_SQUARE_2
      1  3e48				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3e48				   BANK_BLACK_PAWN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3e48				   BLACK_PAWN_on_BLACK_SQUARE_2
      4  3e48				   TEMPORARY_VAR SET	Overlay
      5  3e48				   TEMPORARY_OFFSET SET	0
      6  3e48				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3e48				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_2
      3  3e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e60		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e78		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3e90					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm"
      0  3e90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_3", 72
     12  3e90					      LIST	ON
      0  3e90					      DEF	BLACK_PAWN_on_BLACK_SQUARE_3
      1  3e90				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3e90				   BANK_BLACK_PAWN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3e90				   BLACK_PAWN_on_BLACK_SQUARE_3
      4  3e90				   TEMPORARY_VAR SET	Overlay
      5  3e90				   TEMPORARY_OFFSET SET	0
      6  3e90				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3e90				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_3
      3  3e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3ec0		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$00,$00,$00,$00,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3ed8					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  3ed8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_0", 72
     12  3f00					      LIST	ON
      0  3f00					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_0
      1  3f00				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3f00				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3f00				   BLACK_KNIGHT_on_BLACK_SQUARE_0
      4  3f00				   TEMPORARY_VAR SET	Overlay
      5  3f00				   TEMPORARY_OFFSET SET	0
      6  3f00				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3f00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_0
      3  3f00		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$40,$00,$00	;PF0
      4  3f18		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3f48					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  3f48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_1", 72
     12  3f48					      LIST	ON
      0  3f48					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_1
      1  3f48				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3f48				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3f48				   BLACK_KNIGHT_on_BLACK_SQUARE_1
      4  3f48				   TEMPORARY_VAR SET	Overlay
      5  3f48				   TEMPORARY_OFFSET SET	0
      6  3f48				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3f48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_1
      3  3f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f60		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$10,$00,$00	;PF1
      5  3f78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3f90					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  3f90					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_2", 72
     12  3f90					      LIST	ON
      0  3f90					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_2
      1  3f90				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3f90				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3f90				   BLACK_KNIGHT_on_BLACK_SQUARE_2
      4  3f90				   TEMPORARY_VAR SET	Overlay
      5  3f90				   TEMPORARY_OFFSET SET	0
      6  3f90				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3f90				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_2
      3  3f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3fa8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3fc0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  3fd8					      CHECK_BANK_SIZE	"PIECE_7 (1K)"
      1  3fd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_7 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  3fd8					      ECHO	"PIECE_7 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  3fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3fd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_7 (1K)", " size=", * - ORIGIN
      5  3fd8				  -	      ERR
      6  3fd8					      ENDIF
      0  3fd8					      SLOT	2
      1  3fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  3fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  3fd8				  -	      ERR
      4  3fd8					      ENDIF
      5  3fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  3fd8				   _BANK_SLOT SET	2 * 64
      0  3fd8					      NEWBANK	PIECE_8
      1  4048 ????				      SEG	PIECE_8
      2  4000					      ORG	_ORIGIN
      3  4000					      RORG	_BANK_ADDRESS_ORIGIN
      4  4000				   _BANK_START SET	*
      5  4000				   PIECE_8_START SET	*
      6  4000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4000				   PIECE_8    SET	_BANK_SLOT + _CURRENT_BANK
      8  4000				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4000					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  4000					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_3", 72
     12  4000					      LIST	ON
      0  4000					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_3
      1  4000				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4000				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4000				   BLACK_KNIGHT_on_BLACK_SQUARE_3
      4  4000				   TEMPORARY_VAR SET	Overlay
      5  4000				   TEMPORARY_OFFSET SET	0
      6  4000				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4000				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_3
      3  4000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4030		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
    127  4048
      0  4048					      CHECK_BANK_SIZE	"PIECES_8 (1K)"
      1  4048		       00 48	   .TEMP      =	* - _BANK_START
 PIECES_8 (1K) (1K) SIZE =  $48 , FREE= $3b8
      2  4048					      ECHO	"PIECES_8 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4048				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4048				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_8 (1K)", " size=", * - ORIGIN
      5  4048				  -	      ERR
      6  4048					      ENDIF
    129  4048
    130  4048							;    NEWBANK PIECES_5
    131  4048
    132  4048							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
    133  4048							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
    134  4048							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
    135  4048							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
    136  4048							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
    137  4048							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
    138  4048							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
    139  4048							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
    140  4048
    141  4048
    142  4048				  -	      IF	0
    143  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    144  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    145  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    146  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    147  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    148  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    149  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    150  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    151  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    152  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    153  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    154  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    155  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    156  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    157  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    158  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    159  4048					      ENDIF
    160  4048
    161  4048							;    CHECK_BANK_SIZE "PIECES_5 (2K)"
    162  4048
    163  4048				  -	      IF	0
    164  4048				  -	      NEWBANK	PIECES_6
    165  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    166  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    167  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    168  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    169  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    170  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    171  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    172  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    173  4048				  -
    174  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_0.asm"
    175  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_1.asm"
    176  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_2.asm"
    177  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_3.asm"
    178  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    179  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    180  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    181  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    182  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    183  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    184  4048				  -
    185  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    186  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    187  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    188  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    189  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    190  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    191  4048				  -	      CHECK_BANK_SIZE	"PIECES_6 (2K)"
    192  4048				  -
    193  4048				  -
    194  4048				  -	      NEWBANK	PIECES_7
    195  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    196  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    197  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    198  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    199  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    200  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    201  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    202  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    203  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    204  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    205  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    206  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    207  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_0.asm"
    208  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_1.asm"
    209  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_2.asm"
    210  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_3.asm"
    211  4048				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    212  4048				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    213  4048				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    214  4048				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    215  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    216  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    217  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    218  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    219  4048				  -	      CHECK_BANK_SIZE	"PIECES_7 (2K)"
    220  4048				  -
    221  4048				  -
    222  4048				  -	      NEWBANK	PIECES_8
    223  4048				  -
    224  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    225  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    226  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    227  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    228  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    229  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    230  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    231  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    232  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    233  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    234  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    235  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    236  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    237  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    238  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    239  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    240  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_0.asm"
    241  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_1.asm"
    242  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_2.asm"
    243  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_3.asm"
    244  4048				  -
    245  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    246  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    247  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    248  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    249  4048				  -	      CHECK_BANK_SIZE	"PIECES_8 (2K)"
    250  4048				  -
    251  4048					      ENDIF
    252  4048
    253  4048							;    NEWBANK PIECES_9
    254  4048
    255  4048							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    256  4048							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    257  4048							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    258  4048							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    259  4048							; include "gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    260  4048
    261  4048				  -	      IF	0
    262  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    263  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    264  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    265  4048					      ENDIF
    266  4048
    267  4048							;    CHECK_BANK_SIZE "PIECES_9 (2K)"
    268  4048
    269  4048				  -	      IF	0
    270  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    271  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    272  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    273  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    274  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    275  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    276  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    277  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    278  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    279  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    280  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    281  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    282  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_0.asm"
    283  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_1.asm"
    284  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_2.asm"
    285  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_3.asm"
    286  4048					      ENDIF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@2.asm LEVEL 2 PASS 4
      0  4048					      include	"BANK_GENERIC@2.asm"
      1  4048
      0  4048					      SLOT	2
      1  4048				  -	      IF	(2 < 0) || (2 > 3)
      2  4048				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4048				  -	      ERR
      4  4048					      ENDIF
      5  4048				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4048				   _BANK_SLOT SET	2 * 64
      0  4048					      NEWBANK	GENERIC_BANK@2
      1  4713 ????				      SEG	GENERIC_BANK@2
      2  4400					      ORG	_ORIGIN
      3  4400					      RORG	_BANK_ADDRESS_ORIGIN
      4  4400				   _BANK_START SET	*
      5  4400				   GENERIC_BANK@2_START SET	*
      6  4400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4400				   GENERIC_BANK@2 SET	_BANK_SLOT + _CURRENT_BANK
      8  4400				   _ORIGIN    SET	_ORIGIN + 1024
      4  4400
      5  4400							;    DEFINE_1K_SEGMENT DECODE_LEVEL_SHADOW
      6  4400
      7  4400				  -	      IF	0
      8  4400				  -	      IF	PLUSCART = YES
      9  4400				  -	      .byte	"ChessAPI.php", #0 //TODO: change!
     10  4400				  -	      .byte	"pluscart.firmaplus.de", #0
     11  4400				  -	      ENDIF
     12  4400					      ENDIF
     13  4400
     14  4400							;STELLA_AUTODETECT .byte $85,$3e,$a9,$00 ; 3E
     15  4400
     16  4400
     17  4400
     18  4400
     19  4400							;---------------------------------------------------------------------------------------------------
     20  4400
      0  4400					      DEF	tidySc
      1  4400				   SLOT_tidySc SET	_BANK_SLOT
      2  4400				   BANK_tidySc SET	SLOT_tidySc + _CURRENT_BANK
      3  4400				   tidySc
      4  4400				   TEMPORARY_VAR SET	Overlay
      5  4400				   TEMPORARY_OFFSET SET	0
      6  4400				   VAR_BOUNDARY_tidySc SET	TEMPORARY_OFFSET
      7  4400				   FUNCTION_NAME SET	tidySc
     22  4400					      SUBROUTINE
     23  4400
      0  4400					      REFER	StartupBankReset
      1  4400				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  4400				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  4400					      ENDIF
      0  4400					      VEND	tidySc
      1  4400				  -	      IFNCONST	tidySc
      2  4400				  -	      ECHO	"Incorrect VEND label", tidySc
      3  4400				  -	      ERR
      4  4400					      ENDIF
      5  4400		       00 a4	   VAREND_tidySc =	TEMPORARY_VAR
     26  4400
     27  4400		       a9 00		      lda	#0
     28  4402		       85 4d		      sta	PF0
     29  4404		       85 4e		      sta	PF1
     30  4406		       85 4f		      sta	PF2
     31  4408		       85 5b		      sta	GRP0
     32  440a		       85 5c		      sta	GRP1
     33  440c
     34  440c		       a9 42		      lda	#%01000010	; bit6 is not required
     35  440e							;sta VBLANK			  ; end of screen - enter blanking
     36  440e
     37  440e
     38  440e							; END OF VISIBLE SCREEN
     39  440e							; HERE'S SOME TIME TO DO STUFF
     40  440e
     41  440e		       a9 2e		      lda	#TIME_PART_2
     42  4410		       8d 96 02 	      sta	TIM64T
     43  4413		       60		      rts
     44  4414
     45  4414
     46  4414							;---------------------------------------------------------------------------------------------------
     47  4414
      0  4414					      DEF	longD
      1  4414				   SLOT_longD SET	_BANK_SLOT
      2  4414				   BANK_longD SET	SLOT_longD + _CURRENT_BANK
      3  4414				   longD
      4  4414				   TEMPORARY_VAR SET	Overlay
      5  4414				   TEMPORARY_OFFSET SET	0
      6  4414				   VAR_BOUNDARY_longD SET	TEMPORARY_OFFSET
      7  4414				   FUNCTION_NAME SET	longD
     49  4414					      SUBROUTINE
     50  4414
     51  4414		       85 42		      sta	WSYNC
     52  4416
     53  4416		       20 27 f8 	      jsr	_rts
     54  4419		       20 27 f8 	      jsr	_rts
     55  441c		       20 27 f8 	      jsr	_rts
      0  441f					      SLEEP	7
      1  441f				   .CYCLES    SET	7
      2  441f
      3  441f				  -	      IF	.CYCLES < 2
      4  441f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  441f				  -	      ERR
      6  441f					      ENDIF
      7  441f
      8  441f					      IF	.CYCLES & 1
      9  441f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  441f		       04 00		      nop	0
     11  4421				  -	      ELSE
     12  4421				  -	      bit	VSYNC
     13  4421					      ENDIF
     14  4421				   .CYCLES    SET	.CYCLES - 3
     15  4421					      ENDIF
     16  4421
     17  4421					      REPEAT	.CYCLES / 2
     18  4421		       ea		      nop
     17  4421					      REPEND
     18  4422		       ea		      nop
     19  4423					      REPEND
     57  4423
     58  4423		       a2 00		      ldx	#0
     59  4425		       86 41		      stx	VBLANK
     60  4427		       60	   _rts       rts
     61  4428
     62  4428				  -	      IF	0
     63  4428				  -	      DEF	Resync
     64  4428				  -	      SUBROUTINE
     65  4428				  -
     66  4428				  -	      RESYNC
     67  4428				  -	      rts
     68  4428					      ENDIF
     69  4428
     70  4428
     71  4428							;---------------------------------------------------------------------------------------------------
     72  4428
      0  4428					      DEF	aiStartClearBoard
      1  4428				   SLOT_aiStartClearBoard SET	_BANK_SLOT
      2  4428				   BANK_aiStartClearBoard SET	SLOT_aiStartClearBoard + _CURRENT_BANK
      3  4428				   aiStartClearBoard
      4  4428				   TEMPORARY_VAR SET	Overlay
      5  4428				   TEMPORARY_OFFSET SET	0
      6  4428				   VAR_BOUNDARY_aiStartClearBoard SET	TEMPORARY_OFFSET
      7  4428				   FUNCTION_NAME SET	aiStartClearBoard
     74  4428					      SUBROUTINE
     75  4428
      0  4428					      REFER	AiStateMachine
      1  4428				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  4428				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  4428					      ENDIF
      0  4428					      VEND	aiStartClearBoard
      1  4428				  -	      IFNCONST	aiStartClearBoard
      2  4428				  -	      ECHO	"Incorrect VEND label", aiStartClearBoard
      3  4428				  -	      ERR
      4  4428					      ENDIF
      5  4428		       00 a4	   VAREND_aiStartClearBoard =	TEMPORARY_VAR
     78  4428
     79  4428		       a2 08		      ldx	#8
     80  442a		       86 84		      stx	drawCount	; = bank
     81  442c
     82  442c		       a9 ff		      lda	#-1
     83  442e		       85 88		      sta	cursorX12
     84  4430
      0  4430					      PHASE	AI_ClearEachRow
      1  4430		       a9 0e		      lda	#AI_ClearEachRow
      2  4432		       85 8b		      sta	aiState
     86  4434		       60		      rts
     87  4435
     88  4435							;---------------------------------------------------------------------------------------------------
     89  4435
      0  4435					      DEF	aiClearEachRow
      1  4435				   SLOT_aiClearEachRow SET	_BANK_SLOT
      2  4435				   BANK_aiClearEachRow SET	SLOT_aiClearEachRow + _CURRENT_BANK
      3  4435				   aiClearEachRow
      4  4435				   TEMPORARY_VAR SET	Overlay
      5  4435				   TEMPORARY_OFFSET SET	0
      6  4435				   VAR_BOUNDARY_aiClearEachRow SET	TEMPORARY_OFFSET
      7  4435				   FUNCTION_NAME SET	aiClearEachRow
     91  4435					      SUBROUTINE
     92  4435
      0  4435					      REFER	AiStateMachine
      1  4435				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  4435				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  4435					      ENDIF
      0  4435					      VEND	aiClearEachRow
      1  4435				  -	      IFNCONST	aiClearEachRow
      2  4435				  -	      ECHO	"Incorrect VEND label", aiClearEachRow
      3  4435				  -	      ERR
      4  4435					      ENDIF
      5  4435		       00 a4	   VAREND_aiClearEachRow =	TEMPORARY_VAR
     95  4435
     96  4435		       c6 84		      dec	drawCount
     97  4437		       30 00		      bmi	.bitmapCleared
     98  4439							;TODOldy drawCount
     99  4439							;TODO jmp CallClear
    100  4439
    101  4439				   .bitmapCleared
    102  4439
    103  4439		       a9 63		      lda	#99
    104  443b		       85 80		      sta	squareToDraw
    105  443d
      0  443d					      PHASE	AI_DrawEntireBoard
      1  443d		       a9 0f		      lda	#AI_DrawEntireBoard
      2  443f		       85 8b		      sta	aiState
    107  4441		       60		      rts
    108  4442
    109  4442
    110  4442
    111  4442							;---------------------------------------------------------------------------------------------------
    112  4442
      0  4442					      DEF	aiMoveIsSelected
      1  4442				   SLOT_aiMoveIsSelected SET	_BANK_SLOT
      2  4442				   BANK_aiMoveIsSelected SET	SLOT_aiMoveIsSelected + _CURRENT_BANK
      3  4442				   aiMoveIsSelected
      4  4442				   TEMPORARY_VAR SET	Overlay
      5  4442				   TEMPORARY_OFFSET SET	0
      6  4442				   VAR_BOUNDARY_aiMoveIsSelected SET	TEMPORARY_OFFSET
      7  4442				   FUNCTION_NAME SET	aiMoveIsSelected
    114  4442					      SUBROUTINE
    115  4442
      0  4442					      REFER	AiStateMachine
      1  4442				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  4442				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  4442					      ENDIF
      0  4442					      VEND	aiMoveIsSelected
      1  4442				  -	      IFNCONST	aiMoveIsSelected
      2  4442				  -	      ECHO	"Incorrect VEND label", aiMoveIsSelected
      3  4442				  -	      ERR
      4  4442					      ENDIF
      5  4442		       00 a4	   VAREND_aiMoveIsSelected =	TEMPORARY_VAR
    118  4442
    119  4442							; Both computer and human have now seleted a move, and converge here
    120  4442
    121  4442
    122  4442							; fromPiece	 piece doing the move
    123  4442							; fromX12	 current square X12
    124  4442							; originX12	 starting square X12
    125  4442							; toX12	 ending square X12
    126  4442
    127  4442		       20 af f8 	      jsr	AdjustMaterialPositionalValue	;@this
    128  4445
    129  4445		       a9 00		      lda	#0
    130  4447		       85 98		      sta	previousPiece
    131  4449		       85 82		      sta	drawDelay
    132  444b
    133  444b		       a9 0a		      lda	#10	; on/off count
    134  444d		       85 84		      sta	drawCount	; flashing for piece about to move
    135  444f
      0  444f					      PHASE	AI_WriteStartPieceBlank
      1  444f		       a9 15		      lda	#AI_WriteStartPieceBlank
      2  4451		       85 8b		      sta	aiState
    137  4453		       60	   .idleErase rts
    138  4454
    139  4454
    140  4454							;---------------------------------------------------------------------------------------------------
    141  4454
      0  4454					      DEF	CopySetup
      1  4454				   SLOT_CopySetup SET	_BANK_SLOT
      2  4454				   BANK_CopySetup SET	SLOT_CopySetup + _CURRENT_BANK
      3  4454				   CopySetup
      4  4454				   TEMPORARY_VAR SET	Overlay
      5  4454				   TEMPORARY_OFFSET SET	0
      6  4454				   VAR_BOUNDARY_CopySetup SET	TEMPORARY_OFFSET
      7  4454				   FUNCTION_NAME SET	CopySetup
    143  4454					      SUBROUTINE
    144  4454
      0  4454					      REFER	CopySinglePiece
      1  4454					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  4454				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  4454					      ENDIF
    146  4454
      0  4454					      VAR	__tmp, 1
      1  4454		       00 a7	   __tmp      =	TEMPORARY_VAR
      2  4454				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4454
      4  4454				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4454				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4454				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4454					      ENDIF
      8  4454				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4454				  -	      ECHO	"Temporary Variable", __tmp, "overflow!"
     10  4454				  -	      ERR
     11  4454					      ENDIF
     12  4454					      LIST	ON
      0  4454					      VAR	__shiftx, 1
      1  4454		       00 a8	   __shiftx   =	TEMPORARY_VAR
      2  4454				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4454
      4  4454				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4454				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4454				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4454					      ENDIF
      8  4454				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4454				  -	      ECHO	"Temporary Variable", __shiftx, "overflow!"
     10  4454				  -	      ERR
     11  4454					      ENDIF
     12  4454					      LIST	ON
      0  4454					      VAR	__pieceColour2, 1
      1  4454		       00 a9	   __pieceColour2 =	TEMPORARY_VAR
      2  4454				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4454
      4  4454				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4454				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4454				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4454					      ENDIF
      8  4454				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4454				  -	      ECHO	"Temporary Variable", __pieceColour2, "overflow!"
     10  4454				  -	      ERR
     11  4454					      ENDIF
     12  4454					      LIST	ON
    150  4454
      0  4454					      VEND	CopySetup
      1  4454				  -	      IFNCONST	CopySetup
      2  4454				  -	      ECHO	"Incorrect VEND label", CopySetup
      3  4454				  -	      ERR
      4  4454					      ENDIF
      5  4454		       00 aa	   VAREND_CopySetup =	TEMPORARY_VAR
    152  4454
    153  4454							; figure colouration of square
    154  4454
    155  4454		       a5 80		      lda	squareToDraw
    156  4456
    157  4456					      IF	DIAGNOSTICS
    158  4456							; Catch out-of-range piece square
    159  4456							; will not catch off left/right edge
    160  4456
    161  4456		       c9 64	   .fail      cmp	#100
    162  4458		       b0 fc		      bcs	.fail
    163  445a		       c9 16		      cmp	#22
    164  445c		       90 f8		      bcc	.fail
    165  445e					      ENDIF
    166  445e
    167  445e
    168  445e		       a2 0a		      ldx	#10
    169  4460		       38		      sec
    170  4461		       e9 0a	   .sub10     sbc	#10
    171  4463		       ca		      dex
    172  4464		       b0 fb		      bcs	.sub10
    173  4466		       69 08		      adc	#8
    174  4468		       85 a8		      sta	__shiftx
    175  446a					      IF	DIAGNOSTICS
    176  446a		       c9 08	   .fail2     cmp	#8
    177  446c		       b0 fc		      bcs	.fail2
    178  446e		       e0 08		      cpx	#8
    179  4470		       b0 f8		      bcs	.fail2
    180  4472					      ENDIF
    181  4472		       86 a7		      stx	__tmp
    182  4474		       65 a7		      adc	__tmp
    183  4476
    184  4476
    185  4476		       29 01		      and	#1
    186  4478		       49 01		      eor	#1
    187  447a		       f0 02		      beq	.white
    188  447c		       a9 24		      lda	#36
    189  447e				   .white
    190  447e		       85 a9		      sta	__pieceColour2	; actually SQUARE black/white
    191  4480
    192  4480							; PieceColour = 0 for white square, 36 for black square
    193  4480
    194  4480		       a9 cc		      lda	#RAMBANK_BOARD
    195  4482		       85 3e		      sta	SET_BANK_RAM	;@3
    196  4484
    197  4484		       a4 80		      ldy	squareToDraw
    198  4486		       b9 79 fc 	      lda	Board,y
    199  4489							;and #$87
    200  4489		       0a		      asl
    201  448a		       90 02		      bcc	.blackAdjust
    202  448c		       09 10		      ora	#16	; switch white pieces
    203  448e		       4a	   .blackAdjust lsr
    204  448f		       29 0f		      and	#%1111
    205  4491		       aa		      tax
    206  4492
    207  4492		       a5 a8		      lda	__shiftx
    208  4494		       29 03		      and	#3	; shift position in P
    209  4496
    210  4496		       18		      clc
    211  4497		       7d 9f f8 	      adc	PieceToShape,x
    212  449a		       18		      clc
    213  449b		       65 a9		      adc	__pieceColour2
    214  449d		       a8		      tay
    215  449e		       60		      rts
    216  449f
    217  449f				   PieceToShape
    218  449f
    219  449f		       00		      .byte.b	INDEX_WHITE_BLANK_on_WHITE_SQUARE_0
    220  44a0		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    221  44a1		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (black P)
    222  44a2		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    223  44a3		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    224  44a4		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    225  44a5		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    226  44a6		       18		      .byte.b	INDEX_WHITE_KING_on_WHITE_SQUARE_0
    227  44a7
    228  44a7		       48		      .byte.b	INDEX_BLACK_BLANK_on_WHITE_SQUARE_0
    229  44a8		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (white P)
    230  44a9		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    231  44aa		       50		      .byte.b	INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0
    232  44ab		       54		      .byte.b	INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0
    233  44ac		       58		      .byte.b	INDEX_BLACK_ROOK_on_WHITE_SQUARE_0
    234  44ad		       5c		      .byte.b	INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    235  44ae		       60		      .byte.b	INDEX_BLACK_KING_on_WHITE_SQUARE_0
    236  44af
    237  44af
    238  44af							;---------------------------------------------------------------------------------------------------
    239  44af
      0  44af					      DEF	AdjustMaterialPositionalValue
      1  44af				   SLOT_AdjustMaterialPositionalValue SET	_BANK_SLOT
      2  44af				   BANK_AdjustMaterialPositionalValue SET	SLOT_AdjustMaterialPositionalValue + _CURRENT_BANK
      3  44af				   AdjustMaterialPositionalValue
      4  44af				   TEMPORARY_VAR SET	Overlay
      5  44af				   TEMPORARY_OFFSET SET	0
      6  44af				   VAR_BOUNDARY_AdjustMaterialPositionalValue SET	TEMPORARY_OFFSET
      7  44af				   FUNCTION_NAME SET	AdjustMaterialPositionalValue
    241  44af					      SUBROUTINE
    242  44af
    243  44af							; A move is about to be made, so  adjust material and positional values based on from/to and
    244  44af							; capture.
    245  44af
    246  44af							; First, nominate referencing subroutines so that local variables can be adjusted properly
    247  44af
      0  44af					      REFER	MakeMove
      1  44af					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  44af				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  44af					      ENDIF
      0  44af					      REFER	aiMoveIsSelected
      1  44af				  -	      IF	VAREND_aiMoveIsSelected > TEMPORARY_VAR
      2  44af				  -TEMPORARY_VAR SET	VAREND_aiMoveIsSelected
      3  44af					      ENDIF
    250  44af
      0  44af					      VAR	__originalPiece, 1
      1  44af		       00 b2	   __originalPiece =	TEMPORARY_VAR
      2  44af				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  44af
      4  44af				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44af				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44af				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44af					      ENDIF
      8  44af				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44af				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  44af				  -	      ERR
     11  44af					      ENDIF
     12  44af					      LIST	ON
      0  44af					      VAR	__capturedPiece, 1
      1  44af		       00 b3	   __capturedPiece =	TEMPORARY_VAR
      2  44af				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  44af
      4  44af				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44af				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44af				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44af					      ENDIF
      8  44af				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44af				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  44af				  -	      ERR
     11  44af					      ENDIF
     12  44af					      LIST	ON
    253  44af
      0  44af					      VEND	AdjustMaterialPositionalValue
      1  44af				  -	      IFNCONST	AdjustMaterialPositionalValue
      2  44af				  -	      ECHO	"Incorrect VEND label", AdjustMaterialPositionalValue
      3  44af				  -	      ERR
      4  44af					      ENDIF
      5  44af		       00 b4	   VAREND_AdjustMaterialPositionalValue =	TEMPORARY_VAR
    255  44af
    256  44af							; fromPiece	 piece doing the move (promoted type)
    257  44af							; fromX12	 current square
    258  44af							; originX12	 starting square
    259  44af							; toX12	 ending square
    260  44af
    261  44af
    262  44af							; get the piece types from the board
    263  44af
    264  44af		       a9 cc		      lda	#RAMBANK_BOARD
    265  44b1		       85 3e		      sta	SET_BANK_RAM	;@3
    266  44b3		       a4 87		      ldy	originX12
    267  44b5		       b9 79 fc 	      lda	Board,y
    268  44b8		       85 b2		      sta	__originalPiece
    269  44ba		       a4 86		      ldy	toX12
    270  44bc		       b9 79 fc 	      lda	Board,y
    271  44bf		       85 b3		      sta	__capturedPiece
    272  44c1
    273  44c1							; {
    274  44c1							;   adjust the positional value  (originX12 --> fromX12)
    275  44c1
    276  44c1		       a9 cd		      lda	#RAMBANK_BANK_EVAL
    277  44c3		       85 3e		      sta	SET_BANK_RAM	;@3
    278  44c5
    279  44c5
    280  44c5							;ldy toX12			 ; already loaded
    281  44c5		       a5 96		      lda	fromPiece
    282  44c7		       20 32 f9 	      jsr	AddPiecePositionValue	; add pos value for new position
    283  44ca
    284  44ca
    285  44ca		       a5 b2		      lda	__originalPiece
    286  44cc		       45 96		      eor	fromPiece	; the new piece
    287  44ce		       29 0f		      and	#PIECE_MASK
    288  44d0		       f0 09		      beq	.same1	; unchanged, so skip
    289  44d2
    290  44d2		       a5 96		      lda	fromPiece	; new piece
    291  44d4
    292  44d4		       a2 91		      ldx	#BANK_AddPieceMaterialValue
    293  44d6		       86 3f		      stx	SET_BANK	;@2
    294  44d8
    295  44d8		       20 1b f9 	      jsr	AddPieceMaterialValue
    296  44db
    297  44db				   .same1
    298  44db
    299  44db							; and now the 'subtracts'
    300  44db
      0  44db					      NEGEVAL
      1  44db
      2  44db		       38		      sec
      3  44dc		       a9 00		      lda	#0
      4  44de		       e5 8f		      sbc	Evaluation
      5  44e0		       85 8f		      sta	Evaluation
      6  44e2		       a9 00		      lda	#0
      7  44e4		       e5 90		      sbc	Evaluation+1
      8  44e6		       85 90		      sta	Evaluation+1
    302  44e8
    303  44e8		       a4 87		      ldy	originX12
    304  44ea		       a5 b2		      lda	__originalPiece
    305  44ec		       20 32 f9 	      jsr	AddPiecePositionValue	; remove pos value for original position
    306  44ef
    307  44ef
    308  44ef		       a5 b2		      lda	__originalPiece
    309  44f1		       45 96		      eor	fromPiece	; the new piece
    310  44f3		       29 0f		      and	#PIECE_MASK
    311  44f5		       f0 09		      beq	.same2	; unchanged, so skip
    312  44f7
    313  44f7		       a5 b2		      lda	__originalPiece
    314  44f9		       a2 91		      ldx	#BANK_AddPieceMaterialValue
    315  44fb		       86 3f		      stx	SET_BANK	;@2
    316  44fd		       20 1b f9 	      jsr	AddPieceMaterialValue	; remove material for original type
    317  4500				   .same2
    318  4500
      0  4500					      NEGEVAL
      1  4500
      2  4500		       38		      sec
      3  4501		       a9 00		      lda	#0
      4  4503		       e5 8f		      sbc	Evaluation
      5  4505		       85 8f		      sta	Evaluation
      6  4507		       a9 00		      lda	#0
      7  4509		       e5 90		      sbc	Evaluation+1
      8  450b		       85 90		      sta	Evaluation+1
    320  450d
    321  450d							; If there's a capture, we adjust the material value
    322  450d
    323  450d							;		      lda __capturedPiece
    324  450d							;		      eor __originalPiece
    325  450d							;		      bpl .noCapture		      ; special-case capture rook castling onto king
    326  450d
    327  450d
    328  450d		       a5 b3		      lda	__capturedPiece
    329  450f		       29 0f		      and	#PIECE_MASK
    330  4511		       f0 07		      beq	.noCapture
    331  4513		       a2 91		      ldx	#BANK_AddPieceMaterialValue
    332  4515		       86 3f		      stx	SET_BANK	;@2
    333  4517		       20 1b f9 	      jsr	AddPieceMaterialValue	; -other colour = + my colour!
    334  451a				   .noCapture
    335  451a
    336  451a							; }
    337  451a		       60		      rts
    338  451b
    339  451b
    340  451b							;---------------------------------------------------------------------------------------------------
    341  451b
      0  451b					      DEF	AddPieceMaterialValue
      1  451b				   SLOT_AddPieceMaterialValue SET	_BANK_SLOT
      2  451b				   BANK_AddPieceMaterialValue SET	SLOT_AddPieceMaterialValue + _CURRENT_BANK
      3  451b				   AddPieceMaterialValue
      4  451b				   TEMPORARY_VAR SET	Overlay
      5  451b				   TEMPORARY_OFFSET SET	0
      6  451b				   VAR_BOUNDARY_AddPieceMaterialValue SET	TEMPORARY_OFFSET
      7  451b				   FUNCTION_NAME SET	AddPieceMaterialValue
    343  451b					      SUBROUTINE
    344  451b
      0  451b					      REFER	InitialisePieceSquares
      1  451b					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  451b				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  451b					      ENDIF
      0  451b					      REFER	AdjustMaterialPositionalValue
      1  451b					      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  451b				   TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  451b					      ENDIF
      0  451b					      REFER	EnPassantRemovePiece
      1  451b				  -	      IF	VAREND_EnPassantRemovePiece > TEMPORARY_VAR
      2  451b				  -TEMPORARY_VAR SET	VAREND_EnPassantRemovePiece
      3  451b					      ENDIF
    348  451b
      0  451b					      VEND	AddPieceMaterialValue
      1  451b				  -	      IFNCONST	AddPieceMaterialValue
      2  451b				  -	      ECHO	"Incorrect VEND label", AddPieceMaterialValue
      3  451b				  -	      ERR
      4  451b					      ENDIF
      5  451b		       00 b4	   VAREND_AddPieceMaterialValue =	TEMPORARY_VAR
    350  451b
    351  451b							; Adjust the material score based on the piece
    352  451b							; a = piece type + flags
    353  451b
    354  451b		       29 0f		      and	#PIECE_MASK
    355  451d		       a8		      tay
    356  451e
    357  451e		       a9 c5		      lda	#EVAL
    358  4520		       85 3f		      sta	SET_BANK	;@3
    359  4522
    360  4522		       18		      clc
    361  4523		       b9 00 fc 	      lda	PieceValueLO,y
    362  4526		       65 8f		      adc	Evaluation
    363  4528		       85 8f		      sta	Evaluation
    364  452a		       b9 08 fc 	      lda	PieceValueHI,y
    365  452d		       65 90		      adc	Evaluation+1
    366  452f		       85 90		      sta	Evaluation+1
    367  4531		       60		      rts
    368  4532
    369  4532							;---------------------------------------------------------------------------------------------------
    370  4532
    371  4532
      0  4532					      DEF	AddPiecePositionValue
      1  4532				   SLOT_AddPiecePositionValue SET	_BANK_SLOT
      2  4532				   BANK_AddPiecePositionValue SET	SLOT_AddPiecePositionValue + _CURRENT_BANK
      3  4532				   AddPiecePositionValue
      4  4532				   TEMPORARY_VAR SET	Overlay
      5  4532				   TEMPORARY_OFFSET SET	0
      6  4532				   VAR_BOUNDARY_AddPiecePositionValue SET	TEMPORARY_OFFSET
      7  4532				   FUNCTION_NAME SET	AddPiecePositionValue
    373  4532					      SUBROUTINE
    374  4532
      0  4532					      REFER	InitialisePieceSquares
      1  4532					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  4532				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  4532					      ENDIF
      0  4532					      REFER	AdjustMaterialPositionalValue
      1  4532					      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  4532				   TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  4532					      ENDIF
      0  4532					      REFER	EnPassantRemovePiece
      1  4532				  -	      IF	VAREND_EnPassantRemovePiece > TEMPORARY_VAR
      2  4532				  -TEMPORARY_VAR SET	VAREND_EnPassantRemovePiece
      3  4532					      ENDIF
    378  4532
      0  4532					      VAR	__valPtr, 2
      1  4532		       00 b4	   __valPtr   =	TEMPORARY_VAR
      2  4532				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4532
      4  4532				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4532				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4532				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4532					      ENDIF
      8  4532				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4532				  -	      ECHO	"Temporary Variable", __valPtr, "overflow!"
     10  4532				  -	      ERR
     11  4532					      ENDIF
     12  4532					      LIST	ON
      0  4532					      VAR	__valHi, 1
      1  4532		       00 b6	   __valHi    =	TEMPORARY_VAR
      2  4532				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4532
      4  4532				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4532				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4532				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4532					      ENDIF
      8  4532				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4532				  -	      ECHO	"Temporary Variable", __valHi, "overflow!"
     10  4532				  -	      ERR
     11  4532					      ENDIF
     12  4532					      LIST	ON
    381  4532
      0  4532					      VEND	AddPiecePositionValue
      1  4532				  -	      IFNCONST	AddPiecePositionValue
      2  4532				  -	      ECHO	"Incorrect VEND label", AddPiecePositionValue
      3  4532				  -	      ERR
      4  4532					      ENDIF
      5  4532		       00 b7	   VAREND_AddPiecePositionValue =	TEMPORARY_VAR
    383  4532
    384  4532
    385  4532							; adds value of square piece is on to the evaluation
    386  4532							; note to do the subtraction as -( -x + val) == x - val
    387  4532
    388  4532							; y = square
    389  4532							; a = piece type (+flags)
    390  4532
    391  4532
    392  4532
    393  4532		       c9 80		      cmp	#128	; black = CS
    394  4534		       29 0f		      and	#PIECE_MASK
    395  4536		       aa		      tax
    396  4537
    397  4537		       a9 c5		      lda	#EVAL
    398  4539		       85 3f		      sta	SET_BANK	;@3
    399  453b
    400  453b							; black pieces flip rows so we can use the same eval tables
    401  453b
    402  453b		       98		      tya
    403  453c		       90 03		      bcc	.white
    404  453e		       b9 55 f5 	      lda	FlipSquareIndex,y
    405  4541							;clc
    406  4541				   .white
    407  4541		       7d 10 fc 	      adc	PosValVecLO,x
    408  4544		       85 b4		      sta	__valPtr
    409  4546		       bd 18 fc 	      lda	PosValVecHI,x
    410  4549		       69 00		      adc	#0
    411  454b		       85 b5		      sta	__valPtr+1
    412  454d
    413  454d		       a0 00		      ldy	#0
    414  454f		       84 b6		      sty	__valHi
    415  4551		       b1 b4		      lda	(__valPtr),y
    416  4553		       10 02		      bpl	.sum
    417  4555		       c6 b6		      dec	__valHi
    418  4557
    419  4557		       18	   .sum       clc
    420  4558		       65 8f		      adc	Evaluation
    421  455a		       85 8f		      sta	Evaluation
    422  455c		       a5 90		      lda	Evaluation+1
    423  455e		       65 b6		      adc	__valHi
    424  4560		       85 90		      sta	Evaluation+1
    425  4562		       60		      rts
    426  4563
    427  4563
    428  4563							;---------------------------------------------------------------------------------------------------
    429  4563
------- FILE piece_vectors.asm LEVEL 3 PASS 4
      0  4563					      include	"piece_vectors.asm"
      1  4563							; Created by ConvertChessPieces.py
      0  4563					      DEF	PIECE_VECTOR_LO
      1  4563				   SLOT_PIECE_VECTOR_LO SET	_BANK_SLOT
      2  4563				   BANK_PIECE_VECTOR_LO SET	SLOT_PIECE_VECTOR_LO + _CURRENT_BANK
      3  4563				   PIECE_VECTOR_LO
      4  4563				   TEMPORARY_VAR SET	Overlay
      5  4563				   TEMPORARY_OFFSET SET	0
      6  4563				   VAR_BOUNDARY_PIECE_VECTOR_LO SET	TEMPORARY_OFFSET
      7  4563				   FUNCTION_NAME SET	PIECE_VECTOR_LO
      3  4563		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_0
      4  4564		       48		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_1
      5  4565		       90		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_2
      6  4566		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_3
      7  4567		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_0
      8  4568		       90		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_1
      9  4569		       00		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_2
     10  456a		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_3
     11  456b		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_0
     12  456c		       00		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_1
     13  456d		       48		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_2
     14  456e		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_3
     15  456f		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_0
     16  4570		       48		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_1
     17  4571		       90		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_2
     18  4572		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_3
     19  4573		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_0
     20  4574		       90		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_1
     21  4575		       00		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_2
     22  4576		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_3
     23  4577		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_0
     24  4578		       00		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_1
     25  4579		       48		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_2
     26  457a		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_3
     27  457b		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_0
     28  457c		       48		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_1
     29  457d		       90		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_2
     30  457e		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_3
     31  457f		       00		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_0
     32  4580		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_1
     33  4581		       90		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_2
     34  4582		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_3
     35  4583		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_0
     36  4584		       00		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_1
     37  4585		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_2
     38  4586		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_3
     39  4587		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_0
     40  4588		       90		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_1
     41  4589		       00		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_2
     42  458a		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_3
     43  458b		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_0
     44  458c		       00		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_1
     45  458d		       48		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_2
     46  458e		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_3
     47  458f		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_0
     48  4590		       48		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_1
     49  4591		       90		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_2
     50  4592		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_3
     51  4593		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_0
     52  4594		       90		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_1
     53  4595		       00		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_2
     54  4596		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_3
     55  4597		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_0
     56  4598		       00		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_1
     57  4599		       48		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_2
     58  459a		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_3
     59  459b		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_0
     60  459c		       48		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_1
     61  459d		       90		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_2
     62  459e		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_3
     63  459f		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_0
     64  45a0		       90		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_1
     65  45a1		       00		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_2
     66  45a2		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_3
     67  45a3		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_0
     68  45a4		       00		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_1
     69  45a5		       48		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_2
     70  45a6		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_3
     71  45a7		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_0
     72  45a8		       90		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_1
     73  45a9		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_2
     74  45aa		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_3
     75  45ab		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_0
     76  45ac		       00		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_1
     77  45ad		       48		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_2
     78  45ae		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_3
     79  45af		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_0
     80  45b0		       48		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_1
     81  45b1		       90		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_2
     82  45b2		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_3
     83  45b3		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_0
     84  45b4		       90		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_1
     85  45b5		       00		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_2
     86  45b6		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_3
     87  45b7		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_0
     88  45b8		       00		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_1
     89  45b9		       48		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_2
     90  45ba		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_3
     91  45bb		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_0
     92  45bc		       48		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_1
     93  45bd		       90		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_2
     94  45be		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_3
     95  45bf		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_0
     96  45c0		       90		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_1
     97  45c1		       00		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_2
     98  45c2		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_3
     99  45c3		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_0
    100  45c4		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_1
    101  45c5		       48		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_2
    102  45c6		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_3
    103  45c7		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_0
    104  45c8		       48		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_1
    105  45c9		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_2
    106  45ca		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_3
    107  45cb		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_0
    108  45cc		       90		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_1
    109  45cd		       00		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_2
    110  45ce		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_3
    111  45cf		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_0
    112  45d0		       90		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_1
    113  45d1		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_2
    114  45d2		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_3
    115  45d3		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_0
    116  45d4		       00		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_1
    117  45d5		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_2
    118  45d6		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_3
    119  45d7		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_0
    120  45d8		       48		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_1
    121  45d9		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_2
    122  45da		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_3
    123  45db		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_0
    124  45dc		       48		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_1
    125  45dd		       90		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_2
    126  45de		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_3
    127  45df		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_0
    128  45e0		       90		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_1
    129  45e1		       00		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_2
    130  45e2		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_3
    131  45e3		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_0
    132  45e4		       00		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_1
    133  45e5		       48		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_2
    134  45e6		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_3
    135  45e7		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_0
    136  45e8		       48		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_1
    137  45e9		       90		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_2
    138  45ea		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_3
    139  45eb		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_0
    140  45ec		       00		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_1
    141  45ed		       48		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_2
    142  45ee		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_3
    143  45ef		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_0
    144  45f0		       48		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_1
    145  45f1		       90		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_2
    146  45f2		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  45f3					      DEF	PIECE_VECTOR_HI
      1  45f3				   SLOT_PIECE_VECTOR_HI SET	_BANK_SLOT
      2  45f3				   BANK_PIECE_VECTOR_HI SET	SLOT_PIECE_VECTOR_HI + _CURRENT_BANK
      3  45f3				   PIECE_VECTOR_HI
      4  45f3				   TEMPORARY_VAR SET	Overlay
      5  45f3				   TEMPORARY_OFFSET SET	0
      6  45f3				   VAR_BOUNDARY_PIECE_VECTOR_HI SET	TEMPORARY_OFFSET
      7  45f3				   FUNCTION_NAME SET	PIECE_VECTOR_HI
    148  45f3		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_0
    149  45f4		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_1
    150  45f5		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_2
    151  45f6		       f9		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_3
    152  45f7		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_0
    153  45f8		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_1
    154  45f9		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_2
    155  45fa		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_3
    156  45fb		       fa		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_0
    157  45fc		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_1
    158  45fd		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_2
    159  45fe		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_3
    160  45ff		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_0
    161  4600		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_1
    162  4601		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_2
    163  4602		       f9		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_3
    164  4603		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_0
    165  4604		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_1
    166  4605		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_2
    167  4606		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_3
    168  4607		       fa		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_0
    169  4608		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_1
    170  4609		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_2
    171  460a		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_3
    172  460b		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_0
    173  460c		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_1
    174  460d		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_2
    175  460e		       f9		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_3
    176  460f		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_0
    177  4610		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_1
    178  4611		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_2
    179  4612		       fa		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_3
    180  4613		       fa		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_0
    181  4614		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_1
    182  4615		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_2
    183  4616		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_3
    184  4617		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_0
    185  4618		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_1
    186  4619		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_2
    187  461a		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_3
    188  461b		       fa		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_0
    189  461c		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_1
    190  461d		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_2
    191  461e		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_3
    192  461f		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_0
    193  4620		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_1
    194  4621		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_2
    195  4622		       f9		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_3
    196  4623		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_0
    197  4624		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_1
    198  4625		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_2
    199  4626		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_3
    200  4627		       fa		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_0
    201  4628		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_1
    202  4629		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_2
    203  462a		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_3
    204  462b		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_0
    205  462c		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_1
    206  462d		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_2
    207  462e		       f9		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_3
    208  462f		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_0
    209  4630		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_1
    210  4631		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_2
    211  4632		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_3
    212  4633		       fa		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_0
    213  4634		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_1
    214  4635		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_2
    215  4636		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_3
    216  4637		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_0
    217  4638		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_1
    218  4639		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_2
    219  463a		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_3
    220  463b		       fa		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_0
    221  463c		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_1
    222  463d		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_2
    223  463e		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_3
    224  463f		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_0
    225  4640		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_1
    226  4641		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_2
    227  4642		       f9		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_3
    228  4643		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_0
    229  4644		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_1
    230  4645		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_2
    231  4646		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_3
    232  4647		       fa		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_0
    233  4648		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_1
    234  4649		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_2
    235  464a		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_3
    236  464b		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_0
    237  464c		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_1
    238  464d		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_2
    239  464e		       f9		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_3
    240  464f		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_0
    241  4650		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_1
    242  4651		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_2
    243  4652		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_3
    244  4653		       fa		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_0
    245  4654		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_1
    246  4655		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_2
    247  4656		       f8		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_3
    248  4657		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_0
    249  4658		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_1
    250  4659		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_2
    251  465a		       f9		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_3
    252  465b		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_0
    253  465c		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_1
    254  465d		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_2
    255  465e		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_3
    256  465f		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_0
    257  4660		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_1
    258  4661		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_2
    259  4662		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_3
    260  4663		       f9		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_0
    261  4664		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_1
    262  4665		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_2
    263  4666		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_3
    264  4667		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_0
    265  4668		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_1
    266  4669		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_2
    267  466a		       f8		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_3
    268  466b		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_0
    269  466c		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_1
    270  466d		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_2
    271  466e		       fa		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_3
    272  466f		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_0
    273  4670		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_1
    274  4671		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_2
    275  4672		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_3
    276  4673		       fb		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_0
    277  4674		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_1
    278  4675		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_2
    279  4676		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_3
    280  4677		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_0
    281  4678		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_1
    282  4679		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_2
    283  467a		       fa		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_3
    284  467b		       fa		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_0
    285  467c		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_1
    286  467d		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_2
    287  467e		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_3
    288  467f		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_0
    289  4680		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_1
    290  4681		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_2
    291  4682		       f9		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  4683					      DEF	PIECE_VECTOR_BANK
      1  4683				   SLOT_PIECE_VECTOR_BANK SET	_BANK_SLOT
      2  4683				   BANK_PIECE_VECTOR_BANK SET	SLOT_PIECE_VECTOR_BANK + _CURRENT_BANK
      3  4683				   PIECE_VECTOR_BANK
      4  4683				   TEMPORARY_VAR SET	Overlay
      5  4683				   TEMPORARY_OFFSET SET	0
      6  4683				   VAR_BOUNDARY_PIECE_VECTOR_BANK SET	TEMPORARY_OFFSET
      7  4683				   FUNCTION_NAME SET	PIECE_VECTOR_BANK
    293  4683		       88		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_0
    294  4684		       88		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_1
    295  4685		       88		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_2
    296  4686		       88		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_3
    297  4687		       88		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_0
    298  4688		       88		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_1
    299  4689		       88		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_2
    300  468a		       88		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_3
    301  468b		       88		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0
    302  468c		       88		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1
    303  468d		       88		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2
    304  468e		       88		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3
    305  468f		       89		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_0
    306  4690		       89		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_1
    307  4691		       89		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_2
    308  4692		       89		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_3
    309  4693		       89		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_0
    310  4694		       89		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_1
    311  4695		       89		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_2
    312  4696		       89		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_3
    313  4697		       89		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_0
    314  4698		       89		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_1
    315  4699		       89		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_2
    316  469a		       89		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_3
    317  469b		       8a		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_0
    318  469c		       8a		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_1
    319  469d		       8a		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_2
    320  469e		       8a		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_3
    321  469f		       94		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_0
    322  46a0		       94		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_1
    323  46a1		       94		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_2
    324  46a2		       95		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_3
    325  46a3		       96		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0
    326  46a4		       96		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1
    327  46a5		       96		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2
    328  46a6		       96		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3
    329  46a7		       8a		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_0
    330  46a8		       8a		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_1
    331  46a9		       8a		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_2
    332  46aa		       8a		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_3
    333  46ab		       8a		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_0
    334  46ac		       8a		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_1
    335  46ad		       8a		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_2
    336  46ae		       8a		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_3
    337  46af		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0
    338  46b0		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1
    339  46b1		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2
    340  46b2		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3
    341  46b3		       8b		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_0
    342  46b4		       8b		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_1
    343  46b5		       8b		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_2
    344  46b6		       8b		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_3
    345  46b7		       8b		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_0
    346  46b8		       8b		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_1
    347  46b9		       8b		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_2
    348  46ba		       8b		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_3
    349  46bb		       8c		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_0
    350  46bc		       8c		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_1
    351  46bd		       8c		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_2
    352  46be		       8c		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_3
    353  46bf		       8c		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_0
    354  46c0		       8c		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_1
    355  46c1		       8c		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_2
    356  46c2		       8c		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_3
    357  46c3		       93		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_0
    358  46c4		       93		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_1
    359  46c5		       93		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_2
    360  46c6		       93		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_3
    361  46c7		       96		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0
    362  46c8		       96		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1
    363  46c9		       96		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2
    364  46ca		       96		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3
    365  46cb		       8c		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_0
    366  46cc		       8c		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_1
    367  46cd		       8c		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_2
    368  46ce		       8c		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_3
    369  46cf		       8d		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_0
    370  46d0		       8d		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_1
    371  46d1		       8d		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_2
    372  46d2		       8d		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_3
    373  46d3		       8d		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0
    374  46d4		       8d		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1
    375  46d5		       8d		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2
    376  46d6		       8d		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3
    377  46d7		       8d		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_0
    378  46d8		       8d		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_1
    379  46d9		       8d		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_2
    380  46da		       8d		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_3
    381  46db		       8e		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_0
    382  46dc		       8e		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_1
    383  46dd		       8e		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_2
    384  46de		       8e		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_3
    385  46df		       8e		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_0
    386  46e0		       8e		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_1
    387  46e1		       8e		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_2
    388  46e2		       8e		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_3
    389  46e3		       8e		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_0
    390  46e4		       8e		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_1
    391  46e5		       8e		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_2
    392  46e6		       8f		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_3
    393  46e7		       96		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_0
    394  46e8		       96		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_1
    395  46e9		       96		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_2
    396  46ea		       96		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_3
    397  46eb		       93		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0
    398  46ec		       93		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1
    399  46ed		       93		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2
    400  46ee		       93		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3
    401  46ef		       8f		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_0
    402  46f0		       8f		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_1
    403  46f1		       8f		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_2
    404  46f2		       8f		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_3
    405  46f3		       8f		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_0
    406  46f4		       8f		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_1
    407  46f5		       8f		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_2
    408  46f6		       8f		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_3
    409  46f7		       8f		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0
    410  46f8		       8f		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1
    411  46f9		       8f		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2
    412  46fa		       90		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3
    413  46fb		       94		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_0
    414  46fc		       94		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_1
    415  46fd		       94		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_2
    416  46fe		       94		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_3
    417  46ff		       94		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_0
    418  4700		       94		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_1
    419  4701		       94		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_2
    420  4702		       94		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_3
    421  4703		       94		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_0
    422  4704		       95		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_1
    423  4705		       95		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_2
    424  4706		       95		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_3
    425  4707		       95		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_0
    426  4708		       95		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_1
    427  4709		       95		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_2
    428  470a		       95		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_3
    429  470b		       95		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_0
    430  470c		       95		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_1
    431  470d		       95		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_2
    432  470e		       95		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_3
    433  470f		       93		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0
    434  4710		       93		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1
    435  4711		       93		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2
    436  4712		       93		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3
    437  4713
    438  4713							; piece index equates...
    439  4713		       00 00	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_0 =	0
    440  4713		       00 01	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_1 =	1
    441  4713		       00 02	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_2 =	2
    442  4713		       00 03	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_3 =	3
    443  4713		       00 04	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_0 =	4
    444  4713		       00 05	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_1 =	5
    445  4713		       00 06	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_2 =	6
    446  4713		       00 07	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_3 =	7
    447  4713		       00 08	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0 =	8
    448  4713		       00 09	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_1 =	9
    449  4713		       00 0a	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_2 =	10
    450  4713		       00 0b	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_3 =	11
    451  4713		       00 0c	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0 =	12
    452  4713		       00 0d	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_1 =	13
    453  4713		       00 0e	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_2 =	14
    454  4713		       00 0f	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_3 =	15
    455  4713		       00 10	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_0 =	16
    456  4713		       00 11	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_1 =	17
    457  4713		       00 12	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_2 =	18
    458  4713		       00 13	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_3 =	19
    459  4713		       00 14	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0 =	20
    460  4713		       00 15	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_1 =	21
    461  4713		       00 16	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_2 =	22
    462  4713		       00 17	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_3 =	23
    463  4713		       00 18	   INDEX_WHITE_KING_on_WHITE_SQUARE_0 =	24
    464  4713		       00 19	   INDEX_WHITE_KING_on_WHITE_SQUARE_1 =	25
    465  4713		       00 1a	   INDEX_WHITE_KING_on_WHITE_SQUARE_2 =	26
    466  4713		       00 1b	   INDEX_WHITE_KING_on_WHITE_SQUARE_3 =	27
    467  4713		       00 1c	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_0 =	28
    468  4713		       00 1d	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_1 =	29
    469  4713		       00 1e	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_2 =	30
    470  4713		       00 1f	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_3 =	31
    471  4713		       00 20	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0 =	32
    472  4713		       00 21	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_1 =	33
    473  4713		       00 22	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_2 =	34
    474  4713		       00 23	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_3 =	35
    475  4713		       00 24	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_0 =	36
    476  4713		       00 25	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_1 =	37
    477  4713		       00 26	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_2 =	38
    478  4713		       00 27	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_3 =	39
    479  4713		       00 28	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_0 =	40
    480  4713		       00 29	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_1 =	41
    481  4713		       00 2a	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_2 =	42
    482  4713		       00 2b	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_3 =	43
    483  4713		       00 2c	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_0 =	44
    484  4713		       00 2d	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_1 =	45
    485  4713		       00 2e	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_2 =	46
    486  4713		       00 2f	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_3 =	47
    487  4713		       00 30	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_0 =	48
    488  4713		       00 31	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_1 =	49
    489  4713		       00 32	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_2 =	50
    490  4713		       00 33	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_3 =	51
    491  4713		       00 34	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_0 =	52
    492  4713		       00 35	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_1 =	53
    493  4713		       00 36	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_2 =	54
    494  4713		       00 37	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_3 =	55
    495  4713		       00 38	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_0 =	56
    496  4713		       00 39	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_1 =	57
    497  4713		       00 3a	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_2 =	58
    498  4713		       00 3b	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_3 =	59
    499  4713		       00 3c	   INDEX_WHITE_KING_on_BLACK_SQUARE_0 =	60
    500  4713		       00 3d	   INDEX_WHITE_KING_on_BLACK_SQUARE_1 =	61
    501  4713		       00 3e	   INDEX_WHITE_KING_on_BLACK_SQUARE_2 =	62
    502  4713		       00 3f	   INDEX_WHITE_KING_on_BLACK_SQUARE_3 =	63
    503  4713		       00 40	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_0 =	64
    504  4713		       00 41	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_1 =	65
    505  4713		       00 42	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_2 =	66
    506  4713		       00 43	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_3 =	67
    507  4713		       00 44	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_0 =	68
    508  4713		       00 45	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_1 =	69
    509  4713		       00 46	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_2 =	70
    510  4713		       00 47	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_3 =	71
    511  4713		       00 48	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_0 =	72
    512  4713		       00 49	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_1 =	73
    513  4713		       00 4a	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_2 =	74
    514  4713		       00 4b	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_3 =	75
    515  4713		       00 4c	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_0 =	76
    516  4713		       00 4d	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_1 =	77
    517  4713		       00 4e	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_2 =	78
    518  4713		       00 4f	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_3 =	79
    519  4713		       00 50	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0 =	80
    520  4713		       00 51	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_1 =	81
    521  4713		       00 52	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_2 =	82
    522  4713		       00 53	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_3 =	83
    523  4713		       00 54	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0 =	84
    524  4713		       00 55	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_1 =	85
    525  4713		       00 56	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_2 =	86
    526  4713		       00 57	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_3 =	87
    527  4713		       00 58	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_0 =	88
    528  4713		       00 59	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_1 =	89
    529  4713		       00 5a	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_2 =	90
    530  4713		       00 5b	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_3 =	91
    531  4713		       00 5c	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0 =	92
    532  4713		       00 5d	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_1 =	93
    533  4713		       00 5e	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_2 =	94
    534  4713		       00 5f	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_3 =	95
    535  4713		       00 60	   INDEX_BLACK_KING_on_WHITE_SQUARE_0 =	96
    536  4713		       00 61	   INDEX_BLACK_KING_on_WHITE_SQUARE_1 =	97
    537  4713		       00 62	   INDEX_BLACK_KING_on_WHITE_SQUARE_2 =	98
    538  4713		       00 63	   INDEX_BLACK_KING_on_WHITE_SQUARE_3 =	99
    539  4713		       00 64	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_0 =	100
    540  4713		       00 65	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_1 =	101
    541  4713		       00 66	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_2 =	102
    542  4713		       00 67	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_3 =	103
    543  4713		       00 68	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0 =	104
    544  4713		       00 69	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_1 =	105
    545  4713		       00 6a	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_2 =	106
    546  4713		       00 6b	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_3 =	107
    547  4713		       00 6c	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_0 =	108
    548  4713		       00 6d	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_1 =	109
    549  4713		       00 6e	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_2 =	110
    550  4713		       00 6f	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_3 =	111
    551  4713		       00 70	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_0 =	112
    552  4713		       00 71	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_1 =	113
    553  4713		       00 72	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_2 =	114
    554  4713		       00 73	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_3 =	115
    555  4713		       00 74	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_0 =	116
    556  4713		       00 75	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_1 =	117
    557  4713		       00 76	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_2 =	118
    558  4713		       00 77	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_3 =	119
    559  4713		       00 78	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_0 =	120
    560  4713		       00 79	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_1 =	121
    561  4713		       00 7a	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_2 =	122
    562  4713		       00 7b	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_3 =	123
    563  4713		       00 7c	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_0 =	124
    564  4713		       00 7d	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_1 =	125
    565  4713		       00 7e	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_2 =	126
    566  4713		       00 7f	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_3 =	127
    567  4713		       00 80	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_0 =	128
    568  4713		       00 81	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_1 =	129
    569  4713		       00 82	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_2 =	130
    570  4713		       00 83	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_3 =	131
    571  4713		       00 84	   INDEX_BLACK_KING_on_BLACK_SQUARE_0 =	132
    572  4713		       00 85	   INDEX_BLACK_KING_on_BLACK_SQUARE_1 =	133
    573  4713		       00 86	   INDEX_BLACK_KING_on_BLACK_SQUARE_2 =	134
    574  4713		       00 87	   INDEX_BLACK_KING_on_BLACK_SQUARE_3 =	135
    575  4713		       00 88	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_0 =	136
    576  4713		       00 89	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_1 =	137
    577  4713		       00 8a	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_2 =	138
    578  4713		       00 8b	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_3 =	139
    579  4713		       00 8c	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_0 =	140
    580  4713		       00 8d	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_1 =	141
    581  4713		       00 8e	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_2 =	142
    582  4713		       00 8f	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_3 =	143
------- FILE BANK_GENERIC@2.asm
    431  4713
    432  4713							;---------------------------------------------------------------------------------------------------
    433  4713
      0  4713					      CHECK_BANK_SIZE	"BANK_GENERIC@2"
      1  4713		       03 13	   .TEMP      =	* - _BANK_START
 BANK_GENERIC@2 (1K) SIZE =  $313 , FREE= $ed
      2  4713					      ECHO	"BANK_GENERIC@2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4713				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4713				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC@2", " size=", * - ORIGIN
      5  4713				  -	      ERR
      6  4713					      ENDIF
    435  4713
    436  4713							;---------------------------------------------------------------------------------------------------
    437  4713							;EOF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@1#3.asm LEVEL 2 PASS 4
      0  4713					      include	"BANK_GENERIC@1#3.asm"
      0  4713					      SLOT	1
      1  4713				  -	      IF	(1 < 0) || (1 > 3)
      2  4713				  -	      ECHO	"Illegal bank address/segment location", 1
      3  4713				  -	      ERR
      4  4713					      ENDIF
      5  4713				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  4713				   _BANK_SLOT SET	1 * 64
      0  4713					      NEWBANK	GENERIC_BANK_2
      1  4837 ????				      SEG	GENERIC_BANK_2
      2  4800					      ORG	_ORIGIN
      3  4800					      RORG	_BANK_ADDRESS_ORIGIN
      4  4800				   _BANK_START SET	*
      5  4800				   GENERIC_BANK_2_START SET	*
      6  4800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4800				   GENERIC_BANK_2 SET	_BANK_SLOT + _CURRENT_BANK
      8  4800				   _ORIGIN    SET	_ORIGIN + 1024
      3  4800
      4  4800
      5  4800							;---------------------------------------------------------------------------------------------------
      6  4800
      0  4800					      DEF	aiDrawPart2
      1  4800				   SLOT_aiDrawPart2 SET	_BANK_SLOT
      2  4800				   BANK_aiDrawPart2 SET	SLOT_aiDrawPart2 + _CURRENT_BANK
      3  4800				   aiDrawPart2
      4  4800				   TEMPORARY_VAR SET	Overlay
      5  4800				   TEMPORARY_OFFSET SET	0
      6  4800				   VAR_BOUNDARY_aiDrawPart2 SET	TEMPORARY_OFFSET
      7  4800				   FUNCTION_NAME SET	aiDrawPart2
      8  4800					      SUBROUTINE
      9  4800
      0  4800					      REFER	AiStateMachine
      1  4800				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  4800				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  4800					      ENDIF
      0  4800					      VEND	aiDrawPart2
      1  4800				  -	      IFNCONST	aiDrawPart2
      2  4800				  -	      ECHO	"Incorrect VEND label", aiDrawPart2
      3  4800				  -	      ERR
      4  4800					      ENDIF
      5  4800		       00 a4	   VAREND_aiDrawPart2 =	TEMPORARY_VAR
     12  4800
     13  4800		       20 ad f0 	      jsr	CopySinglePiece	;@0
     14  4803
      0  4803					      DEF	aiDrawPart3
      1  4803				   SLOT_aiDrawPart3 SET	_BANK_SLOT
      2  4803				   BANK_aiDrawPart3 SET	SLOT_aiDrawPart3 + _CURRENT_BANK
      3  4803				   aiDrawPart3
      4  4803				   TEMPORARY_VAR SET	Overlay
      5  4803				   TEMPORARY_OFFSET SET	0
      6  4803				   VAR_BOUNDARY_aiDrawPart3 SET	TEMPORARY_OFFSET
      7  4803				   FUNCTION_NAME SET	aiDrawPart3
     16  4803					      SUBROUTINE
     17  4803
     18  4803		       c6 80		      dec	squareToDraw
     19  4805		       a5 80		      lda	squareToDraw
     20  4807		       c9 16		      cmp	#22
     21  4809		       90 05		      bcc	.comp
     22  480b
      0  480b					      PHASE	AI_DrawEntireBoard
      1  480b		       a9 0f		      lda	#AI_DrawEntireBoard
      2  480d		       85 8b		      sta	aiState
     24  480f		       60		      rts
     25  4810
     26  4810				   .comp
     27  4810
     28  4810		       a9 ff		      lda	#-1
     29  4812		       85 86		      sta	toX12	; becomes startup flash square
     30  4814		       a9 24		      lda	#36	; becomes cursor position
     31  4816		       85 87		      sta	originX12
     32  4818
     33  4818
      0  4818					      PHASE	AI_GenerateMoves
      1  4818		       a9 12		      lda	#AI_GenerateMoves
      2  481a		       85 8b		      sta	aiState
     35  481c		       60		      rts
     36  481d
     37  481d
     38  481d
     39  481d
     40  481d							;---------------------------------------------------------------------------------------------------
     41  481d
      0  481d					      DEF	aiMarchB
      1  481d				   SLOT_aiMarchB SET	_BANK_SLOT
      2  481d				   BANK_aiMarchB SET	SLOT_aiMarchB + _CURRENT_BANK
      3  481d				   aiMarchB
      4  481d				   TEMPORARY_VAR SET	Overlay
      5  481d				   TEMPORARY_OFFSET SET	0
      6  481d				   VAR_BOUNDARY_aiMarchB SET	TEMPORARY_OFFSET
      7  481d				   FUNCTION_NAME SET	aiMarchB
     43  481d					      SUBROUTINE
     44  481d
      0  481d					      REFER	AiStateMachine
      1  481d				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  481d				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  481d					      ENDIF
      0  481d					      VEND	aiMarchB
      1  481d				  -	      IFNCONST	aiMarchB
      2  481d				  -	      ECHO	"Incorrect VEND label", aiMarchB
      3  481d				  -	      ERR
      4  481d					      ENDIF
      5  481d		       00 a4	   VAREND_aiMarchB =	TEMPORARY_VAR
     47  481d
     48  481d							; Draw the piece in the new square
     49  481d
     50  481d		       a5 85		      lda	fromX12
     51  481f		       85 80		      sta	squareToDraw
     52  4821
     53  4821		       20 ad f0 	      jsr	CopySinglePiece	;@0	      ; draw the moving piece into the new square
     54  4824
     55  4824		       a9 0a		      lda	#10	; snail trail delay ??
     56  4826		       85 82		      sta	drawDelay
     57  4828
      0  4828					      PHASE	AI_MarchToTargetB
      1  4828		       a9 19		      lda	#AI_MarchToTargetB
      2  482a		       85 8b		      sta	aiState
     59  482c		       60		      rts
     60  482d
     61  482d
     62  482d
     63  482d							;---------------------------------------------------------------------------------------------------
     64  482d
      0  482d					      DEF	aiDraw
      1  482d				   SLOT_aiDraw SET	_BANK_SLOT
      2  482d				   BANK_aiDraw SET	SLOT_aiDraw + _CURRENT_BANK
      3  482d				   aiDraw
      4  482d				   TEMPORARY_VAR SET	Overlay
      5  482d				   TEMPORARY_OFFSET SET	0
      6  482d				   VAR_BOUNDARY_aiDraw SET	TEMPORARY_OFFSET
      7  482d				   FUNCTION_NAME SET	aiDraw
     66  482d					      SUBROUTINE
     67  482d		       a9 c0		      lda	#$C0
     68  482f		       85 49		      sta	COLUBK
     69  4831		       60		      rts
     70  4832
     71  4832
     72  4832							;---------------------------------------------------------------------------------------------------
     73  4832
      0  4832					      DEF	aiCheckMate
      1  4832				   SLOT_aiCheckMate SET	_BANK_SLOT
      2  4832				   BANK_aiCheckMate SET	SLOT_aiCheckMate + _CURRENT_BANK
      3  4832				   aiCheckMate
      4  4832				   TEMPORARY_VAR SET	Overlay
      5  4832				   TEMPORARY_OFFSET SET	0
      6  4832				   VAR_BOUNDARY_aiCheckMate SET	TEMPORARY_OFFSET
      7  4832				   FUNCTION_NAME SET	aiCheckMate
     75  4832					      SUBROUTINE
     76  4832		       a9 44		      lda	#$44
     77  4834		       85 49		      sta	COLUBK
     78  4836		       60		      rts
     79  4837
     80  4837							;---------------------------------------------------------------------------------------------------
     81  4837
      0  4837					      CHECK_BANK_SIZE	"BANK_GENERIC2"
      1  4837		       00 37	   .TEMP      =	* - _BANK_START
 BANK_GENERIC2 (1K) SIZE =  $37 , FREE= $3c9
      2  4837					      ECHO	"BANK_GENERIC2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4837				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4837				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC2", " size=", * - ORIGIN
      5  4837				  -	      ERR
      6  4837					      ENDIF
     83  4837
     84  4837							;---------------------------------------------------------------------------------------------------
     85  4837							;EOF
------- FILE ./chess.asm
------- FILE GFX1.asm LEVEL 2 PASS 4
      0  4837					      include	"GFX1.asm"
      0  4837					      SLOT	2
      1  4837				  -	      IF	(2 < 0) || (2 > 3)
      2  4837				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4837				  -	      ERR
      4  4837					      ENDIF
      5  4837				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4837				   _BANK_SLOT SET	2 * 64
      0  4837					      NEWBANK	GFX1
      1  4fd8 ????				      SEG	GFX1
      2  4c00					      ORG	_ORIGIN
      3  4c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  4c00				   _BANK_START SET	*
      5  4c00				   GFX1_START SET	*
      6  4c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4c00				   GFX1       SET	_BANK_SLOT + _CURRENT_BANK
      8  4c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  4c00
      4  4c00
      5  4c00							;---------------------------------------------------------------------------------------------------
      6  4c00
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4c00					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  4c00					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_0", 72
     12  4c00					      LIST	ON
      0  4c00					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_0
      1  4c00				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4c00				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4c00				   BLACK_PROMOTE_on_BLACK_SQUARE_0
      4  4c00				   TEMPORARY_VAR SET	Overlay
      5  4c00				   TEMPORARY_OFFSET SET	0
      6  4c00				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4c00				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_0
      3  4c00		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4c48					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  4c48					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_1", 72
     12  4c48					      LIST	ON
      0  4c48					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_1
      1  4c48				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4c48				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4c48				   BLACK_PROMOTE_on_BLACK_SQUARE_1
      4  4c48				   TEMPORARY_VAR SET	Overlay
      5  4c48				   TEMPORARY_OFFSET SET	0
      6  4c48				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4c48				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_1
      3  4c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4c60		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4c90					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  4c90					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_2", 72
     12  4c90					      LIST	ON
      0  4c90					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_2
      1  4c90				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4c90				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4c90				   BLACK_PROMOTE_on_BLACK_SQUARE_2
      4  4c90				   TEMPORARY_VAR SET	Overlay
      5  4c90				   TEMPORARY_OFFSET SET	0
      6  4c90				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4c90				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_2
      3  4c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4cc0		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4cd8					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  4cd8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_3", 72
     12  4d00					      LIST	ON
      0  4d00					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_3
      1  4d00				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4d00				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4d00				   BLACK_PROMOTE_on_BLACK_SQUARE_3
      4  4d00				   TEMPORARY_VAR SET	Overlay
      5  4d00				   TEMPORARY_OFFSET SET	0
      6  4d00				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4d00				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_3
      3  4d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4d30		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4d48					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  4d48					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_0", 72
     12  4d48					      LIST	ON
      0  4d48					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_0
      1  4d48				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4d48				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4d48				   BLACK_PROMOTE_on_WHITE_SQUARE_0
      4  4d48				   TEMPORARY_VAR SET	Overlay
      5  4d48				   TEMPORARY_OFFSET SET	0
      6  4d48				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4d48				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_0
      3  4d48		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  4d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4d90					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  4d90					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_1", 72
     12  4d90					      LIST	ON
      0  4d90					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_1
      1  4d90				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4d90				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4d90				   BLACK_PROMOTE_on_WHITE_SQUARE_1
      4  4d90				   TEMPORARY_VAR SET	Overlay
      5  4d90				   TEMPORARY_OFFSET SET	0
      6  4d90				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4d90				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_1
      3  4d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4da8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  4dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4dd8					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  4dd8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_2", 72
     12  4e00					      LIST	ON
      0  4e00					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_2
      1  4e00				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4e00				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4e00				   BLACK_PROMOTE_on_WHITE_SQUARE_2
      4  4e00				   TEMPORARY_VAR SET	Overlay
      5  4e00				   TEMPORARY_OFFSET SET	0
      6  4e00				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4e00				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_2
      3  4e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4e18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  4e30		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4e48					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  4e48					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_3", 72
     12  4e48					      LIST	ON
      0  4e48					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_3
      1  4e48				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4e48				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4e48				   BLACK_PROMOTE_on_WHITE_SQUARE_3
      4  4e48				   TEMPORARY_VAR SET	Overlay
      5  4e48				   TEMPORARY_OFFSET SET	0
      6  4e48				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4e48				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_3
      3  4e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4e78		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE GFX1.asm
     15  4e90
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4e90					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm"
      0  4e90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_0", 72
     12  4e90					      LIST	ON
      0  4e90					      DEF	WHITE_MARKER_on_BLACK_SQUARE_0
      1  4e90				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4e90				   BANK_WHITE_MARKER_on_BLACK_SQUARE_0 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4e90				   WHITE_MARKER_on_BLACK_SQUARE_0
      4  4e90				   TEMPORARY_VAR SET	Overlay
      5  4e90				   TEMPORARY_OFFSET SET	0
      6  4e90				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4e90				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_0
      3  4e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4ed8					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm"
      0  4ed8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_1", 72
     12  4f00					      LIST	ON
      0  4f00					      DEF	WHITE_MARKER_on_BLACK_SQUARE_1
      1  4f00				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4f00				   BANK_WHITE_MARKER_on_BLACK_SQUARE_1 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4f00				   WHITE_MARKER_on_BLACK_SQUARE_1
      4  4f00				   TEMPORARY_VAR SET	Overlay
      5  4f00				   TEMPORARY_OFFSET SET	0
      6  4f00				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4f00				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_1
      3  4f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4f18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4f48					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm"
      0  4f48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_2", 72
     12  4f48					      LIST	ON
      0  4f48					      DEF	WHITE_MARKER_on_BLACK_SQUARE_2
      1  4f48				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4f48				   BANK_WHITE_MARKER_on_BLACK_SQUARE_2 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4f48				   WHITE_MARKER_on_BLACK_SQUARE_2
      4  4f48				   TEMPORARY_VAR SET	Overlay
      5  4f48				   TEMPORARY_OFFSET SET	0
      6  4f48				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4f48				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_2
      3  4f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4f78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4f90					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm"
      0  4f90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_3", 72
     12  4f90					      LIST	ON
      0  4f90					      DEF	WHITE_MARKER_on_BLACK_SQUARE_3
      1  4f90				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4f90				   BANK_WHITE_MARKER_on_BLACK_SQUARE_3 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4f90				   WHITE_MARKER_on_BLACK_SQUARE_3
      4  4f90				   TEMPORARY_VAR SET	Overlay
      5  4f90				   TEMPORARY_OFFSET SET	0
      6  4f90				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4f90				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_3
      3  4f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4fc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
     20  4fd8
     21  4fd8
     22  4fd8							;---------------------------------------------------------------------------------------------------
     23  4fd8
      0  4fd8					      CHECK_BANK_SIZE	"BANK_GFX1"
      1  4fd8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX1 (1K) SIZE =  $3d8 , FREE= $28
      2  4fd8					      ECHO	"BANK_GFX1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4fd8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX1", " size=", * - ORIGIN
      5  4fd8				  -	      ERR
      6  4fd8					      ENDIF
     25  4fd8
     26  4fd8							;---------------------------------------------------------------------------------------------------
     27  4fd8							;EOF
------- FILE ./chess.asm
------- FILE GFX2.asm LEVEL 2 PASS 4
      0  4fd8					      include	"GFX2.asm"
      0  4fd8					      SLOT	2
      1  4fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  4fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4fd8				  -	      ERR
      4  4fd8					      ENDIF
      5  4fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4fd8				   _BANK_SLOT SET	2 * 64
      0  4fd8					      NEWBANK	GFX2
      1  53d8 ????				      SEG	GFX2
      2  5000					      ORG	_ORIGIN
      3  5000					      RORG	_BANK_ADDRESS_ORIGIN
      4  5000				   _BANK_START SET	*
      5  5000				   GFX2_START SET	*
      6  5000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5000				   GFX2       SET	_BANK_SLOT + _CURRENT_BANK
      8  5000				   _ORIGIN    SET	_ORIGIN + 1024
      3  5000
      4  5000							;---------------------------------------------------------------------------------------------------
      5  5000
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5000					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm"
      0  5000					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_0", 72
     12  5000					      LIST	ON
      0  5000					      DEF	WHITE_MARKER_on_WHITE_SQUARE_0
      1  5000				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5000				   BANK_WHITE_MARKER_on_WHITE_SQUARE_0 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5000				   WHITE_MARKER_on_WHITE_SQUARE_0
      4  5000				   TEMPORARY_VAR SET	Overlay
      5  5000				   TEMPORARY_OFFSET SET	0
      6  5000				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5000				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_0
      3  5000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00	;PF0
      4  5018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5048					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm"
      0  5048					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_1", 72
     12  5048					      LIST	ON
      0  5048					      DEF	WHITE_MARKER_on_WHITE_SQUARE_1
      1  5048				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5048				   BANK_WHITE_MARKER_on_WHITE_SQUARE_1 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5048				   WHITE_MARKER_on_WHITE_SQUARE_1
      4  5048				   TEMPORARY_VAR SET	Overlay
      5  5048				   TEMPORARY_OFFSET SET	0
      6  5048				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5048				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_1
      3  5048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5060		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00	;PF1
      5  5078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5090					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm"
      0  5090					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_2", 72
     12  5090					      LIST	ON
      0  5090					      DEF	WHITE_MARKER_on_WHITE_SQUARE_2
      1  5090				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5090				   BANK_WHITE_MARKER_on_WHITE_SQUARE_2 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5090				   WHITE_MARKER_on_WHITE_SQUARE_2
      4  5090				   TEMPORARY_VAR SET	Overlay
      5  5090				   TEMPORARY_OFFSET SET	0
      6  5090				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5090				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_2
      3  5090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  50a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00	;PF1
      5  50c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00	;PF2
------- FILE GFX2.asm
      9  50d8
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  50d8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm"
      0  50d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_0", 72
     12  5100					      LIST	ON
      0  5100					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_0
      1  5100				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5100				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5100				   BLACK_BISHOP_on_BLACK_SQUARE_0
      4  5100				   TEMPORARY_VAR SET	Overlay
      5  5100				   TEMPORARY_OFFSET SET	0
      6  5100				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5100				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_0
      3  5100		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$40,$00	;PF0
      4  5118		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5130		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5148					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm"
      0  5148					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_1", 72
     12  5148					      LIST	ON
      0  5148					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_1
      1  5148				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5148				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5148				   BLACK_BISHOP_on_BLACK_SQUARE_1
      4  5148				   TEMPORARY_VAR SET	Overlay
      5  5148				   TEMPORARY_OFFSET SET	0
      6  5148				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5148				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_1
      3  5148		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5160		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$00,$00,$00,$10,$00	;PF1
      5  5178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5190					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm"
      0  5190					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_2", 72
     12  5190					      LIST	ON
      0  5190					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_2
      1  5190				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5190				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5190				   BLACK_BISHOP_on_BLACK_SQUARE_2
      4  5190				   TEMPORARY_VAR SET	Overlay
      5  5190				   TEMPORARY_OFFSET SET	0
      6  5190				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5190				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_2
      3  5190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  51a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  51c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$00,$00,$00,$01,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  51d8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm"
      0  51d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_3", 72
     12  5200					      LIST	ON
      0  5200					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_3
      1  5200				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5200				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5200				   BLACK_BISHOP_on_BLACK_SQUARE_3
      4  5200				   TEMPORARY_VAR SET	Overlay
      5  5200				   TEMPORARY_OFFSET SET	0
      6  5200				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5200				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_3
      3  5200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5218		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5230		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$00,$00,$00,$20,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5248					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm"
      0  5248					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_0", 72
     12  5248					      LIST	ON
      0  5248					      DEF	BLACK_ROOK_on_BLACK_SQUARE_0
      1  5248				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5248				   BANK_BLACK_ROOK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5248				   BLACK_ROOK_on_BLACK_SQUARE_0
      4  5248				   TEMPORARY_VAR SET	Overlay
      5  5248				   TEMPORARY_OFFSET SET	0
      6  5248				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5248				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_0
      3  5248		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$a0,$00,$00	;PF0
      4  5260		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5278		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5290					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm"
      0  5290					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_1", 72
     12  5290					      LIST	ON
      0  5290					      DEF	BLACK_ROOK_on_BLACK_SQUARE_1
      1  5290				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5290				   BANK_BLACK_ROOK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5290				   BLACK_ROOK_on_BLACK_SQUARE_1
      4  5290				   TEMPORARY_VAR SET	Overlay
      5  5290				   TEMPORARY_OFFSET SET	0
      6  5290				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5290				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_1
      3  5290		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  52a8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$28,$00,$00	;PF1
      5  52c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  52d8					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm"
      0  52d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_2", 72
     12  5300					      LIST	ON
      0  5300					      DEF	BLACK_ROOK_on_BLACK_SQUARE_2
      1  5300				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5300				   BANK_BLACK_ROOK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5300				   BLACK_ROOK_on_BLACK_SQUARE_2
      4  5300				   TEMPORARY_VAR SET	Overlay
      5  5300				   TEMPORARY_OFFSET SET	0
      6  5300				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5300				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_2
      3  5300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5318		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF1
      5  5330		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$02,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5348					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm"
      0  5348					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_3", 72
     12  5348					      LIST	ON
      0  5348					      DEF	BLACK_ROOK_on_BLACK_SQUARE_3
      1  5348				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5348				   BANK_BLACK_ROOK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5348				   BLACK_ROOK_on_BLACK_SQUARE_3
      4  5348				   TEMPORARY_VAR SET	Overlay
      5  5348				   TEMPORARY_OFFSET SET	0
      6  5348				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5348				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_3
      3  5348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5378		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00	;PF2
------- FILE GFX2.asm
     18  5390
     19  5390
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5390					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm"
      0  5390					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_0", 72
     12  5390					      LIST	ON
      0  5390					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_0
      1  5390				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5390				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5390				   BLACK_QUEEN_on_BLACK_SQUARE_0
      4  5390				   TEMPORARY_VAR SET	Overlay
      5  5390				   TEMPORARY_OFFSET SET	0
      6  5390				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5390				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_0
      3  5390		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  53a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  53c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
     21  53d8
     22  53d8
     23  53d8							;---------------------------------------------------------------------------------------------------
     24  53d8
      0  53d8					      CHECK_BANK_SIZE	"BANK_GFX2"
      1  53d8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX2 (1K) SIZE =  $3d8 , FREE= $28
      2  53d8					      ECHO	"BANK_GFX2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  53d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  53d8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX2", " size=", * - ORIGIN
      5  53d8				  -	      ERR
      6  53d8					      ENDIF
     26  53d8
     27  53d8							;---------------------------------------------------------------------------------------------------
     28  53d8							;EOF
------- FILE ./chess.asm
------- FILE GFX3.asm LEVEL 2 PASS 4
      0  53d8					      include	"GFX3.asm"
      0  53d8					      SLOT	2
      1  53d8				  -	      IF	(2 < 0) || (2 > 3)
      2  53d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  53d8				  -	      ERR
      4  53d8					      ENDIF
      5  53d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  53d8				   _BANK_SLOT SET	2 * 64
      0  53d8					      NEWBANK	GFX3
      1  57d8 ????				      SEG	GFX3
      2  5400					      ORG	_ORIGIN
      3  5400					      RORG	_BANK_ADDRESS_ORIGIN
      4  5400				   _BANK_START SET	*
      5  5400				   GFX3_START SET	*
      6  5400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5400				   GFX3       SET	_BANK_SLOT + _CURRENT_BANK
      8  5400				   _ORIGIN    SET	_ORIGIN + 1024
      3  5400
      4  5400							;---------------------------------------------------------------------------------------------------
      5  5400
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5400					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm"
      0  5400					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_1", 72
     12  5400					      LIST	ON
      0  5400					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_1
      1  5400				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5400				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5400				   BLACK_QUEEN_on_BLACK_SQUARE_1
      4  5400				   TEMPORARY_VAR SET	Overlay
      5  5400				   TEMPORARY_OFFSET SET	0
      6  5400				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5400				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_1
      3  5400		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5418		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
      7  5448
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5448					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm"
      0  5448					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_2", 72
     12  5448					      LIST	ON
      0  5448					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_2
      1  5448				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5448				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5448				   BLACK_QUEEN_on_BLACK_SQUARE_2
      4  5448				   TEMPORARY_VAR SET	Overlay
      5  5448				   TEMPORARY_OFFSET SET	0
      6  5448				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5448				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_2
      3  5448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5460		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5478		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5490					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm"
      0  5490					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_3", 72
     12  5490					      LIST	ON
      0  5490					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_3
      1  5490				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5490				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5490				   BLACK_QUEEN_on_BLACK_SQUARE_3
      4  5490				   TEMPORARY_VAR SET	Overlay
      5  5490				   TEMPORARY_OFFSET SET	0
      6  5490				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5490				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_3
      3  5490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  54a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  54c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     10  54d8
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  54d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_0.asm"
      0  54d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_0", 72
     12  5500					      LIST	ON
      0  5500					      DEF	BLACK_KING_on_BLACK_SQUARE_0
      1  5500				   SLOT_BLACK_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5500				   BANK_BLACK_KING_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5500				   BLACK_KING_on_BLACK_SQUARE_0
      4  5500				   TEMPORARY_VAR SET	Overlay
      5  5500				   TEMPORARY_OFFSET SET	0
      6  5500				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5500				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_0
      3  5500		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5518		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5530		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5548					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_1.asm"
      0  5548					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_1", 72
     12  5548					      LIST	ON
      0  5548					      DEF	BLACK_KING_on_BLACK_SQUARE_1
      1  5548				   SLOT_BLACK_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5548				   BANK_BLACK_KING_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5548				   BLACK_KING_on_BLACK_SQUARE_1
      4  5548				   TEMPORARY_VAR SET	Overlay
      5  5548				   TEMPORARY_OFFSET SET	0
      6  5548				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5548				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_1
      3  5548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5560		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5590					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_2.asm"
      0  5590					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_2", 72
     12  5590					      LIST	ON
      0  5590					      DEF	BLACK_KING_on_BLACK_SQUARE_2
      1  5590				   SLOT_BLACK_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5590				   BANK_BLACK_KING_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5590				   BLACK_KING_on_BLACK_SQUARE_2
      4  5590				   TEMPORARY_VAR SET	Overlay
      5  5590				   TEMPORARY_OFFSET SET	0
      6  5590				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5590				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_2
      3  5590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  55a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  55c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  55d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_3.asm"
      0  55d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_3", 72
     12  5600					      LIST	ON
      0  5600					      DEF	BLACK_KING_on_BLACK_SQUARE_3
      1  5600				   SLOT_BLACK_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5600				   BANK_BLACK_KING_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5600				   BLACK_KING_on_BLACK_SQUARE_3
      4  5600				   TEMPORARY_VAR SET	Overlay
      5  5600				   TEMPORARY_OFFSET SET	0
      6  5600				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5600				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_3
      3  5600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5630		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     15  5648
     16  5648
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5648					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm"
      0  5648					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_3", 72
     12  5648					      LIST	ON
      0  5648					      DEF	WHITE_MARKER_on_WHITE_SQUARE_3
      1  5648				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5648				   BANK_WHITE_MARKER_on_WHITE_SQUARE_3 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5648				   WHITE_MARKER_on_WHITE_SQUARE_3
      4  5648				   TEMPORARY_VAR SET	Overlay
      5  5648				   TEMPORARY_OFFSET SET	0
      6  5648				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5648				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_3
      3  5648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5678		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00	;PF2
------- FILE GFX3.asm
     18  5690
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5690					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
      0  5690					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_0", 72
     12  5690					      LIST	ON
      0  5690					      DEF	BLACK_MARKER_on_BLACK_SQUARE_0
      1  5690				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5690				   BANK_BLACK_MARKER_on_BLACK_SQUARE_0 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5690				   BLACK_MARKER_on_BLACK_SQUARE_0
      4  5690				   TEMPORARY_VAR SET	Overlay
      5  5690				   TEMPORARY_OFFSET SET	0
      6  5690				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5690				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_0
      3  5690		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  56a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  56c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  56d8					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
      0  56d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_1", 72
     12  5700					      LIST	ON
      0  5700					      DEF	BLACK_MARKER_on_BLACK_SQUARE_1
      1  5700				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5700				   BANK_BLACK_MARKER_on_BLACK_SQUARE_1 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5700				   BLACK_MARKER_on_BLACK_SQUARE_1
      4  5700				   TEMPORARY_VAR SET	Overlay
      5  5700				   TEMPORARY_OFFSET SET	0
      6  5700				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5700				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_1
      3  5700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5718		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5748					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
      0  5748					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_2", 72
     12  5748					      LIST	ON
      0  5748					      DEF	BLACK_MARKER_on_BLACK_SQUARE_2
      1  5748				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5748				   BANK_BLACK_MARKER_on_BLACK_SQUARE_2 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5748				   BLACK_MARKER_on_BLACK_SQUARE_2
      4  5748				   TEMPORARY_VAR SET	Overlay
      5  5748				   TEMPORARY_OFFSET SET	0
      6  5748				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5748				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_2
      3  5748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5760		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5778		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5790					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
      0  5790					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_3", 72
     12  5790					      LIST	ON
      0  5790					      DEF	BLACK_MARKER_on_BLACK_SQUARE_3
      1  5790				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5790				   BANK_BLACK_MARKER_on_BLACK_SQUARE_3 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5790				   BLACK_MARKER_on_BLACK_SQUARE_3
      4  5790				   TEMPORARY_VAR SET	Overlay
      5  5790				   TEMPORARY_OFFSET SET	0
      6  5790				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5790				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_3
      3  5790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  57a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  57c0		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     23  57d8
     24  57d8							;---------------------------------------------------------------------------------------------------
     25  57d8
      0  57d8					      CHECK_BANK_SIZE	"BANK_GFX3"
      1  57d8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX3 (1K) SIZE =  $3d8 , FREE= $28
      2  57d8					      ECHO	"BANK_GFX3", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  57d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  57d8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX3", " size=", * - ORIGIN
      5  57d8				  -	      ERR
      6  57d8					      ENDIF
     27  57d8
     28  57d8							;---------------------------------------------------------------------------------------------------
     29  57d8							;EOF
------- FILE ./chess.asm
------- FILE GFX4.asm LEVEL 2 PASS 4
      0  57d8					      include	"GFX4.asm"
      0  57d8					      SLOT	2
      1  57d8				  -	      IF	(2 < 0) || (2 > 3)
      2  57d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  57d8				  -	      ERR
      4  57d8					      ENDIF
      5  57d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  57d8				   _BANK_SLOT SET	2 * 64
      0  57d8					      NEWBANK	GFX4
      1  5bd8 ????				      SEG	GFX4
      2  5800					      ORG	_ORIGIN
      3  5800					      RORG	_BANK_ADDRESS_ORIGIN
      4  5800				   _BANK_START SET	*
      5  5800				   GFX4_START SET	*
      6  5800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5800				   GFX4       SET	_BANK_SLOT + _CURRENT_BANK
      8  5800				   _ORIGIN    SET	_ORIGIN + 1024
      3  5800
      4  5800							;---------------------------------------------------------------------------------------------------
      5  5800
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5800					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
      0  5800					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_0", 72
     12  5800					      LIST	ON
      0  5800					      DEF	BLACK_MARKER_on_WHITE_SQUARE_0
      1  5800				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5800				   BANK_BLACK_MARKER_on_WHITE_SQUARE_0 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5800				   BLACK_MARKER_on_WHITE_SQUARE_0
      4  5800				   TEMPORARY_VAR SET	Overlay
      5  5800				   TEMPORARY_OFFSET SET	0
      6  5800				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5800				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_0
      3  5800		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00	;PF0
      4  5818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5848					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
      0  5848					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_1", 72
     12  5848					      LIST	ON
      0  5848					      DEF	BLACK_MARKER_on_WHITE_SQUARE_1
      1  5848				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5848				   BANK_BLACK_MARKER_on_WHITE_SQUARE_1 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5848				   BLACK_MARKER_on_WHITE_SQUARE_1
      4  5848				   TEMPORARY_VAR SET	Overlay
      5  5848				   TEMPORARY_OFFSET SET	0
      6  5848				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5848				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_1
      3  5848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5860		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00	;PF1
      5  5878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5890					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
      0  5890					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_2", 72
     12  5890					      LIST	ON
      0  5890					      DEF	BLACK_MARKER_on_WHITE_SQUARE_2
      1  5890				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5890				   BANK_BLACK_MARKER_on_WHITE_SQUARE_2 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5890				   BLACK_MARKER_on_WHITE_SQUARE_2
      4  5890				   TEMPORARY_VAR SET	Overlay
      5  5890				   TEMPORARY_OFFSET SET	0
      6  5890				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5890				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_2
      3  5890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  58a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  58c0		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  58d8					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
      0  58d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_3", 72
     12  5900					      LIST	ON
      0  5900					      DEF	BLACK_MARKER_on_WHITE_SQUARE_3
      1  5900				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5900				   BANK_BLACK_MARKER_on_WHITE_SQUARE_3 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5900				   BLACK_MARKER_on_WHITE_SQUARE_3
      4  5900				   TEMPORARY_VAR SET	Overlay
      5  5900				   TEMPORARY_OFFSET SET	0
      6  5900				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5900				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_3
      3  5900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5930		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00	;PF2
------- FILE GFX4.asm
     10  5948
     11  5948
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5948					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  5948					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_0", 72
     12  5948					      LIST	ON
      0  5948					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_0
      1  5948				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5948				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5948				   WHITE_PROMOTE_on_BLACK_SQUARE_0
      4  5948				   TEMPORARY_VAR SET	Overlay
      5  5948				   TEMPORARY_OFFSET SET	0
      6  5948				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5948				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_0
      3  5948		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  5960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5990					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  5990					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_1", 72
     12  5990					      LIST	ON
      0  5990					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_1
      1  5990				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5990				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5990				   WHITE_PROMOTE_on_BLACK_SQUARE_1
      4  5990				   TEMPORARY_VAR SET	Overlay
      5  5990				   TEMPORARY_OFFSET SET	0
      6  5990				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5990				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_1
      3  5990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  59a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  59c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  59d8					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  59d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_2", 72
     12  5a00					      LIST	ON
      0  5a00					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_2
      1  5a00				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5a00				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5a00				   WHITE_PROMOTE_on_BLACK_SQUARE_2
      4  5a00				   TEMPORARY_VAR SET	Overlay
      5  5a00				   TEMPORARY_OFFSET SET	0
      6  5a00				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5a00				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_2
      3  5a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  5a30		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5a48					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  5a48					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_3", 72
     12  5a48					      LIST	ON
      0  5a48					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_3
      1  5a48				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5a48				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5a48				   WHITE_PROMOTE_on_BLACK_SQUARE_3
      4  5a48				   TEMPORARY_VAR SET	Overlay
      5  5a48				   TEMPORARY_OFFSET SET	0
      6  5a48				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5a48				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_3
      3  5a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5a78		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5a90					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  5a90					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_0", 72
     12  5a90					      LIST	ON
      0  5a90					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_0
      1  5a90				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5a90				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5a90				   WHITE_PROMOTE_on_WHITE_SQUARE_0
      4  5a90				   TEMPORARY_VAR SET	Overlay
      5  5a90				   TEMPORARY_OFFSET SET	0
      6  5a90				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5a90				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_0
      3  5a90		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5ad8					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  5ad8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_1", 72
     12  5b00					      LIST	ON
      0  5b00					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_1
      1  5b00				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5b00				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5b00				   WHITE_PROMOTE_on_WHITE_SQUARE_1
      4  5b00				   TEMPORARY_VAR SET	Overlay
      5  5b00				   TEMPORARY_OFFSET SET	0
      6  5b00				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5b00				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_1
      3  5b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5b18		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5b48					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  5b48					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_2", 72
     12  5b48					      LIST	ON
      0  5b48					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_2
      1  5b48				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5b48				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5b48				   WHITE_PROMOTE_on_WHITE_SQUARE_2
      4  5b48				   TEMPORARY_VAR SET	Overlay
      5  5b48				   TEMPORARY_OFFSET SET	0
      6  5b48				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5b48				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_2
      3  5b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5b60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5b78		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5b90					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  5b90					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_3", 72
     12  5b90					      LIST	ON
      0  5b90					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_3
      1  5b90				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5b90				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5b90				   WHITE_PROMOTE_on_WHITE_SQUARE_3
      4  5b90				   TEMPORARY_VAR SET	Overlay
      5  5b90				   TEMPORARY_OFFSET SET	0
      6  5b90				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5b90				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_3
      3  5b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5bc0		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
     20  5bd8
     21  5bd8
     22  5bd8							;---------------------------------------------------------------------------------------------------
     23  5bd8
      0  5bd8					      CHECK_BANK_SIZE	"BANK_GFX4"
      1  5bd8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX4 (1K) SIZE =  $3d8 , FREE= $28
      2  5bd8					      ECHO	"BANK_GFX4", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5bd8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX4", " size=", * - ORIGIN
      5  5bd8				  -	      ERR
      6  5bd8					      ENDIF
     25  5bd8
     26  5bd8							;---------------------------------------------------------------------------------------------------
     27  5bd8							;EOF
------- FILE ./chess.asm
------- FILE NEGAMAX@1.asm LEVEL 2 PASS 4
      0  5bd8					      include	"NEGAMAX@1.asm"
      1  5bd8							; Chess
      2  5bd8							; Copyright (c) 2019-2020 Andrew Davie
      3  5bd8							; andrew@taswegian.com
      4  5bd8
      0  5bd8					      SLOT	1
      1  5bd8				  -	      IF	(1 < 0) || (1 > 3)
      2  5bd8				  -	      ECHO	"Illegal bank address/segment location", 1
      3  5bd8				  -	      ERR
      4  5bd8					      ENDIF
      5  5bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  5bd8				   _BANK_SLOT SET	1 * 64
      0  5bd8					      NEWBANK	NEGAMAX
      1  5f8c ????				      SEG	NEGAMAX
      2  5c00					      ORG	_ORIGIN
      3  5c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  5c00				   _BANK_START SET	*
      5  5c00				   NEGAMAX_START SET	*
      6  5c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5c00				   NEGAMAX    SET	_BANK_SLOT + _CURRENT_BANK
      8  5c00				   _ORIGIN    SET	_ORIGIN + 1024
      7  5c00
      8  5c00							;---------------------------------------------------------------------------------------------------
      9  5c00
      0  5c00					      DEF	aiComputerMove
      1  5c00				   SLOT_aiComputerMove SET	_BANK_SLOT
      2  5c00				   BANK_aiComputerMove SET	SLOT_aiComputerMove + _CURRENT_BANK
      3  5c00				   aiComputerMove
      4  5c00				   TEMPORARY_VAR SET	Overlay
      5  5c00				   TEMPORARY_OFFSET SET	0
      6  5c00				   VAR_BOUNDARY_aiComputerMove SET	TEMPORARY_OFFSET
      7  5c00				   FUNCTION_NAME SET	aiComputerMove
     11  5c00					      SUBROUTINE
     12  5c00
      0  5c00					      REFER	AiStateMachine
      1  5c00				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5c00				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5c00					      ENDIF
      0  5c00					      VEND	aiComputerMove
      1  5c00				  -	      IFNCONST	aiComputerMove
      2  5c00				  -	      ECHO	"Incorrect VEND label", aiComputerMove
      3  5c00				  -	      ERR
      4  5c00					      ENDIF
      5  5c00		       00 a4	   VAREND_aiComputerMove =	TEMPORARY_VAR
     15  5c00
     16  5c00
     17  5c00		       a9 88		      lda	#RAMBANK_PLY
     18  5c02		       85 94		      sta	currentPly
     19  5c04		       85 3e		      sta	SET_BANK_RAM	;@2		 ; switch in movelist
     20  5c06
     21  5c06		       a9 01		      lda	#1
     22  5c08		       85 4a		      sta	CTRLPF	; mirroring for thinkbars
     23  5c0a
     24  5c0a
     25  5c0a		       20 3a f4 	      jsr	selectmove	;@this
     26  5c0d
     27  5c0d
     28  5c0d		       a9 00		      lda	#0
     29  5c0f		       85 4a		      sta	CTRLPF	; clear mirroring
     30  5c11		       85 4e		      sta	PF1
     31  5c13		       85 4f		      sta	PF2
     32  5c15
     33  5c15							; correct ply is already switched
     34  5c15
      0  5c15					      lda@PLY	bestMove
      1  5c15		       ad d2 f9 	      lda	bestMove
     36  5c18		       10 17		      bpl	.notComputer
     37  5c1a
     38  5c1a							; Computer could not find a valid move. It's checkmate or stalemate. Find which...
     39  5c1a
      0  5c1a					      SWAP
      1  5c1a		       a5 95		      lda	sideToMove
      2  5c1c		       49 80		      eor	#SWAP_SIDE
      3  5c1e		       85 95		      sta	sideToMove
      4  5c20
      5  5c20
     41  5c20		       20 77 f1 	      jsr	GenerateAllMoves	;@0
     42  5c23		       a5 a1		      lda	flagCheck
     43  5c25		       f0 05		      beq	.gameDrawn
     44  5c27
      0  5c27					      PHASE	AI_CheckMate
      1  5c27		       a9 23		      lda	#AI_CheckMate
      2  5c29		       85 8b		      sta	aiState
     46  5c2b		       60		      rts
     47  5c2c
     48  5c2c
      0  5c2c				   .gameDrawn PHASE	AI_Draw
      1  5c2c		       a9 24		      lda	#AI_Draw
      2  5c2e		       85 8b		      sta	aiState
     50  5c30		       60		      rts
     51  5c31
     52  5c31				   .notComputer
     53  5c31
     54  5c31
     55  5c31		       a9 ff		      lda	#-1
     56  5c33		       85 88		      sta	cursorX12
     57  5c35
      0  5c35					      PHASE	AI_DelayAfterMove
      1  5c35		       a9 25		      lda	#AI_DelayAfterMove
      2  5c37		       85 8b		      sta	aiState
     59  5c39		       60	   .halted    rts
     60  5c3a
     61  5c3a
     62  5c3a							;---------------------------------------------------------------------------------------------------
     63  5c3a
      0  5c3a					      DEF	selectmove
      1  5c3a				   SLOT_selectmove SET	_BANK_SLOT
      2  5c3a				   BANK_selectmove SET	SLOT_selectmove + _CURRENT_BANK
      3  5c3a				   selectmove
      4  5c3a				   TEMPORARY_VAR SET	Overlay
      5  5c3a				   TEMPORARY_OFFSET SET	0
      6  5c3a				   VAR_BOUNDARY_selectmove SET	TEMPORARY_OFFSET
      7  5c3a				   FUNCTION_NAME SET	selectmove
     65  5c3a					      SUBROUTINE
     66  5c3a
      0  5c3a					      COMMON_VARS_ALPHABETA
      1  5c3a
      0  5c3a					      VAR	__thinkbar, 1
      1  5c3a		       00 a4	   __thinkbar =	TEMPORARY_VAR
      2  5c3a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5c3a
      4  5c3a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5c3a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5c3a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5c3a					      ENDIF
      8  5c3a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5c3a				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  5c3a				  -	      ERR
     11  5c3a					      ENDIF
     12  5c3a					      LIST	ON
      0  5c3a					      VAR	__toggle, 1
      1  5c3a		       00 a5	   __toggle   =	TEMPORARY_VAR
      2  5c3a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5c3a
      4  5c3a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5c3a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5c3a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5c3a					      ENDIF
      8  5c3a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5c3a				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  5c3a				  -	      ERR
     11  5c3a					      ENDIF
     12  5c3a					      LIST	ON
      4  5c3a
      0  5c3a					      VAR	__bestMove, 1
      1  5c3a		       00 a6	   __bestMove =	TEMPORARY_VAR
      2  5c3a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5c3a
      4  5c3a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5c3a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5c3a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5c3a					      ENDIF
      8  5c3a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5c3a				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  5c3a				  -	      ERR
     11  5c3a					      ENDIF
     12  5c3a					      LIST	ON
      0  5c3a					      VAR	__alpha, 2
      1  5c3a		       00 a7	   __alpha    =	TEMPORARY_VAR
      2  5c3a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5c3a
      4  5c3a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5c3a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5c3a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5c3a					      ENDIF
      8  5c3a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5c3a				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  5c3a				  -	      ERR
     11  5c3a					      ENDIF
     12  5c3a					      LIST	ON
      0  5c3a					      VAR	__beta, 2
      1  5c3a		       00 a9	   __beta     =	TEMPORARY_VAR
      2  5c3a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5c3a
      4  5c3a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5c3a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5c3a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5c3a					      ENDIF
      8  5c3a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5c3a				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  5c3a				  -	      ERR
     11  5c3a					      ENDIF
     12  5c3a					      LIST	ON
      0  5c3a					      VAR	__negaMax, 2
      1  5c3a		       00 ab	   __negaMax  =	TEMPORARY_VAR
      2  5c3a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5c3a
      4  5c3a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5c3a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5c3a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5c3a					      ENDIF
      8  5c3a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5c3a				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  5c3a				  -	      ERR
     11  5c3a					      ENDIF
     12  5c3a					      LIST	ON
      0  5c3a					      VAR	__value, 2
      1  5c3a		       00 ad	   __value    =	TEMPORARY_VAR
      2  5c3a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5c3a
      4  5c3a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5c3a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5c3a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5c3a					      ENDIF
      8  5c3a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5c3a				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  5c3a				  -	      ERR
     11  5c3a					      ENDIF
     12  5c3a					      LIST	ON
     10  5c3a
      0  5c3a					      VAR	__quiesceCapOnly, 1
      1  5c3a		       00 af	   __quiesceCapOnly =	TEMPORARY_VAR
      2  5c3a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5c3a
      4  5c3a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5c3a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5c3a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5c3a					      ENDIF
      8  5c3a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5c3a				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  5c3a				  -	      ERR
     11  5c3a					      ENDIF
     12  5c3a					      LIST	ON
     12  5c3a
      0  5c3a					      REFER	aiComputerMove
      1  5c3a				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  5c3a				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  5c3a					      ENDIF
      0  5c3a					      VEND	selectmove
      1  5c3a				  -	      IFNCONST	selectmove
      2  5c3a				  -	      ECHO	"Incorrect VEND label", selectmove
      3  5c3a				  -	      ERR
      4  5c3a					      ENDIF
      5  5c3a		       00 b0	   VAREND_selectmove =	TEMPORARY_VAR
     70  5c3a
     71  5c3a
     72  5c3a							; RAM bank already switched in!!!
     73  5c3a							; returns with RAM bank switched
     74  5c3a
     75  5c3a
     76  5c3a					      IF	DIAGNOSTICS
     77  5c3a
     78  5c3a		       a9 00		      lda	#0
     79  5c3c		       85 9e		      sta	positionCount
     80  5c3e		       85 9f		      sta	positionCount+1
     81  5c40		       85 a0		      sta	positionCount+2
     82  5c42							;sta maxPly
     83  5c42					      ENDIF
     84  5c42
     85  5c42
     86  5c42		       a9 00		      lda	#<INFINITY
     87  5c44		       85 a9		      sta	__beta
     88  5c46		       a9 70		      lda	#>INFINITY
     89  5c48		       85 aa		      sta	__beta+1
     90  5c4a
     91  5c4a		       a9 00		      lda	#<-INFINITY
     92  5c4c		       85 a7		      sta	__alpha
     93  5c4e		       a9 90		      lda	#>-INFINITY
     94  5c50		       85 a8		      sta	__alpha+1	; player tries to maximise
     95  5c52
     96  5c52		       a2 04		      ldx	#SEARCH_DEPTH
     97  5c54		       a9 00		      lda	#0	; no captured piece
     98  5c56		       85 af		      sta	__quiesceCapOnly	; ALL moves to be generated
     99  5c58
    100  5c58		       20 07 f5 	      jsr	negaMax
    101  5c5b
    102  5c5b							;lda currentPly
    103  5c5b							;sta SET_BANK_RAM ;tmp?
    104  5c5b
      0  5c5b					      ldx@PLY	bestMove
      1  5c5b		       ae d2 f9 	      ldx	bestMove
    106  5c5e		       30 26		      bmi	.nomove
    107  5c60
    108  5c60							; Generate player's moves in reply
    109  5c60							; Make the computer move, list player moves (PLY+1), unmake computer move
    110  5c60
      0  5c60					      stx@PLY	movePtr
      1  5c60		       8e d1 fb 	      stx	[RAM]+movePtr
    112  5c63		       20 87 f4 	      jsr	MakeMove	;@this
    113  5c66		       20 ed f1 	      jsr	ListPlayerMoves	;@0
    114  5c69
    115  5c69		       c6 94		      dec	currentPly
    116  5c6b		       20 5b f2 	      jsr	unmakeMove	;@0
    117  5c6e
    118  5c6e							; Grab the computer move details for the UI animation
    119  5c6e
    120  5c6e		       a9 88		      lda	#RAMBANK_PLY
    121  5c70		       85 3e		      sta	SET_BANK_RAM
    122  5c72
      0  5c72					      ldx@PLY	bestMove
      1  5c72		       ae d2 f9 	      ldx	bestMove
      0  5c75					      lda@PLY	MoveTo,x
      1  5c75		       bd 64 f8 	      lda	MoveTo,x
    125  5c78		       85 86		      sta	toX12
      0  5c7a					      lda@PLY	MoveFrom,x
      1  5c7a		       bd 00 f8 	      lda	MoveFrom,x
    127  5c7d		       85 87		      sta	originX12
    128  5c7f		       85 85		      sta	fromX12
      0  5c81					      lda@PLY	MovePiece,x
      1  5c81		       bd 00 f9 	      lda	MovePiece,x
    130  5c84		       85 96		      sta	fromPiece
    131  5c86
    132  5c86				   .nomove
    133  5c86		       60		      rts
    134  5c87
    135  5c87
    136  5c87							;---------------------------------------------------------------------------------------------------
    137  5c87
      0  5c87					      DEF	MakeMove
      1  5c87				   SLOT_MakeMove SET	_BANK_SLOT
      2  5c87				   BANK_MakeMove SET	SLOT_MakeMove + _CURRENT_BANK
      3  5c87				   MakeMove
      4  5c87				   TEMPORARY_VAR SET	Overlay
      5  5c87				   TEMPORARY_OFFSET SET	0
      6  5c87				   VAR_BOUNDARY_MakeMove SET	TEMPORARY_OFFSET
      7  5c87				   FUNCTION_NAME SET	MakeMove
    139  5c87					      SUBROUTINE
    140  5c87
      0  5c87					      REFER	selectmove
      1  5c87					      IF	VAREND_selectmove > TEMPORARY_VAR
      2  5c87				   TEMPORARY_VAR SET	VAREND_selectmove
      3  5c87					      ENDIF
      0  5c87					      REFER	ListPlayerMoves
      1  5c87				  -	      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  5c87				  -TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  5c87					      ENDIF
      0  5c87					      REFER	quiesce
      1  5c87				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  5c87				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  5c87					      ENDIF
      0  5c87					      REFER	negaMax
      1  5c87				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  5c87				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  5c87					      ENDIF
    145  5c87
      0  5c87					      VAR	__capture, 1
      1  5c87		       00 b0	   __capture  =	TEMPORARY_VAR
      2  5c87				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5c87
      4  5c87				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5c87				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5c87				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5c87					      ENDIF
      8  5c87				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5c87				  -	      ECHO	"Temporary Variable", __capture, "overflow!"
     10  5c87				  -	      ERR
     11  5c87					      ENDIF
     12  5c87					      LIST	ON
      0  5c87					      VAR	__restore, 1
      1  5c87		       00 b1	   __restore  =	TEMPORARY_VAR
      2  5c87				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5c87
      4  5c87				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5c87				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5c87				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5c87					      ENDIF
      8  5c87				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5c87				  -	      ECHO	"Temporary Variable", __restore, "overflow!"
     10  5c87				  -	      ERR
     11  5c87					      ENDIF
     12  5c87					      LIST	ON
    148  5c87
      0  5c87					      VEND	MakeMove
      1  5c87				  -	      IFNCONST	MakeMove
      2  5c87				  -	      ECHO	"Incorrect VEND label", MakeMove
      3  5c87				  -	      ERR
      4  5c87					      ENDIF
      5  5c87		       00 b2	   VAREND_MakeMove =	TEMPORARY_VAR
    150  5c87
    151  5c87							; Do a move without any GUI stuff
    152  5c87							; This function is ALWAYS paired with "unmakeMove" - a call to both will leave board
    153  5c87							; and all relevant flags in original state. This is NOT used for the visible move on the
    154  5c87							; screen.
    155  5c87
    156  5c87
    157  5c87							; fromPiece	 piece doing the move
    158  5c87							; fromX12	 current square X12
    159  5c87							; originX12	 starting square X12
    160  5c87							; toX12	 ending square X12
    161  5c87
    162  5c87							; BANK:SLOT2 = currentPly
    163  5c87
    164  5c87
    165  5c87							; There are potentially "two" moves, with the following
    166  5c87							; a) Castling, moving both rook and king
    167  5c87							; b) en-Passant, capturing pawn on "odd" square
    168  5c87							; These both set "secondary" movers which are used for restoring during unmakeMove
    169  5c87
    170  5c87		       a9 00		      lda	#0
      0  5c89					      sta@PLY	secondaryPiece
      1  5c89		       8d cd fb 	      sta	[RAM]+secondaryPiece
    172  5c8c
      0  5c8c					      ldx@PLY	movePtr
      1  5c8c		       ae d1 f9 	      ldx	movePtr
      0  5c8f					      lda@PLY	MoveFrom,x
      1  5c8f		       bd 00 f8 	      lda	MoveFrom,x
    175  5c92		       85 85		      sta	fromX12
    176  5c94		       85 87		      sta	originX12
      0  5c96					      lda@PLY	MoveTo,x
      1  5c96		       bd 64 f8 	      lda	MoveTo,x
    178  5c99		       85 86		      sta	toX12
      0  5c9b					      lda@PLY	MovePiece,x
      1  5c9b		       bd 00 f9 	      lda	MovePiece,x
    180  5c9e		       85 96		      sta	fromPiece
    181  5ca0
      0  5ca0				   .move      CALL	AdjustMaterialPositionalValue
      1  5ca0				  -	      IF	SLOT_AdjustMaterialPositionalValue == _BANK_SLOT
      2  5ca0				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  5ca0				  -	      ECHO	"Cannot switch bank in use for", AdjustMaterialPositionalValue
      4  5ca0				  -	      ERR
      5  5ca0					      ENDIF
      6  5ca0		       a9 91		      lda	#BANK_AdjustMaterialPositionalValue
      7  5ca2		       85 3f		      sta	SET_BANK
      8  5ca4		       20 af f8 	      jsr	AdjustMaterialPositionalValue
    183  5ca7
    184  5ca7							; Modify the board
    185  5ca7
    186  5ca7		       a0 cc		      ldy	#RAMBANK_BOARD
    187  5ca9		       84 3e		      sty	SET_BANK_RAM	;@3
    188  5cab		       a4 87		      ldy	originX12
      0  5cad					      lda@RAM	Board,y
      1  5cad		       b9 79 fc 	      lda	Board,y
    190  5cb0		       85 b1		      sta	__restore
    191  5cb2		       a9 00		      lda	#0
      0  5cb4					      sta@RAM	Board,y
      1  5cb4		       99 79 fe 	      sta	[RAM]+Board,y
    193  5cb7		       a4 86		      ldy	toX12
      0  5cb9					      lda@RAM	Board,y
      1  5cb9		       b9 79 fc 	      lda	Board,y
    195  5cbc		       85 b0		      sta	__capture
    196  5cbe		       a5 96		      lda	fromPiece
    197  5cc0		       29 8f		      and	#PIECE_MASK|FLAG_COLOUR
    198  5cc2		       09 40		      ora	#FLAG_MOVED
      0  5cc4					      sta@RAM	Board,y
      1  5cc4		       99 79 fe 	      sta	[RAM]+Board,y
    200  5cc7
    201  5cc7		       a5 94		      lda	currentPly
    202  5cc9		       85 3e		      sta	SET_BANK_RAM	;@2
    203  5ccb		       a5 b0		      lda	__capture
      0  5ccd					      sta@PLY	capturedPiece
      1  5ccd		       8d cb fb 	      sta	[RAM]+capturedPiece
    205  5cd0		       a5 b1		      lda	__restore
      0  5cd2					      sta@PLY	restorePiece
      1  5cd2		       8d da fb 	      sta	[RAM]+restorePiece
    207  5cd5
    208  5cd5				  -	      IF	CASTLING_ENABLED
    209  5cd5				  -
    210  5cd5				  -			; If the FROM piece has the castle bit set (i.e., it's a king that's just moved 2 squares)
    211  5cd5				  -			; then we find the appropriate ROOK, set the secondary piece "undo" information, and then
    212  5cd5				  -			; redo the moving code (for the rook, this time).
    213  5cd5				  -
    214  5cd5				  -	      jsr	GenCastleMoveForRook
    215  5cd5				  -	      bcs	.move	; move the rook!
    216  5cd5					      ENDIF
    217  5cd5
    218  5cd5
    219  5cd5				  -	      IF	ENPASSANT_ENABLED
    220  5cd5				  -	      jsr	EnPassantCheck
    221  5cd5				  -	      beq	.notEnPassant
    222  5cd5				  -	      jsr	EnPassantRemovePiece	; y = origin X12
    223  5cd5				  -.notEnPassant
    224  5cd5					      ENDIF
    225  5cd5
    226  5cd5							; Swap over sides
    227  5cd5
      0  5cd5					      NEGEVAL
      1  5cd5
      2  5cd5		       38		      sec
      3  5cd6		       a9 00		      lda	#0
      4  5cd8		       e5 8f		      sbc	Evaluation
      5  5cda		       85 8f		      sta	Evaluation
      6  5cdc		       a9 00		      lda	#0
      7  5cde		       e5 90		      sbc	Evaluation+1
      8  5ce0		       85 90		      sta	Evaluation+1
      0  5ce2					      SWAP
      1  5ce2		       a5 95		      lda	sideToMove
      2  5ce4		       49 80		      eor	#SWAP_SIDE
      3  5ce6		       85 95		      sta	sideToMove
      4  5ce8
      5  5ce8
    230  5ce8		       60		      rts
    231  5ce9
    232  5ce9
    233  5ce9							;---------------------------------------------------------------------------------------------------
    234  5ce9
    235  5ce9							;function negaMax(node, depth, α, β, color) is
    236  5ce9							;    if depth = 0 or node is a terminal node then
    237  5ce9							;	  return color × the heuristic value of node
    238  5ce9
    239  5ce9							;    childNodes := generateMoves(node)
    240  5ce9							;    childNodes := orderMoves(childNodes)
    241  5ce9							;    value := −∞
    242  5ce9							;    foreach child in childNodes do
    243  5ce9							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    244  5ce9							;	  α := max(α, value)
    245  5ce9							;	  if α ≥ β then
    246  5ce9							;	      break (* cut-off *)
    247  5ce9							;    return value
    248  5ce9							;(* Initial call for Player A's root node *)
    249  5ce9							;negaMax(rootNode, depth, −∞, +∞, 1)
    250  5ce9
    251  5ce9
    252  5ce9					      SUBROUTINE
    253  5ce9
    254  5ce9		       a9 ff	   .doQ       lda	#-1
    255  5ceb		       85 af		      sta	__quiesceCapOnly
    256  5ced		       20 7a f6 	      jsr	quiesce
    257  5cf0		       e6 af		      inc	__quiesceCapOnly
    258  5cf2		       60		      rts
    259  5cf3
    260  5cf3
      0  5cf3				   .exit      lda@PLY	value
      1  5cf3		       ad d7 f9 	      lda	value
    262  5cf6		       85 ab		      sta	__negaMax
      0  5cf8					      lda@PLY	value+1
      1  5cf8		       ad d8 f9 	      lda	value+1
    264  5cfb		       85 ac		      sta	__negaMax+1
    265  5cfd		       60		      rts
    266  5cfe
    267  5cfe
    268  5cfe				   .terminal
    269  5cfe
    270  5cfe				  -	      IF	QUIESCE_EXTRA_DEPTH > 0
    271  5cfe				  -	      cmp	#0	; captured piece
    272  5cfe				  -	      bne	.doQ	; last move was capture, so quiesce
    273  5cfe					      ENDIF
    274  5cfe
    275  5cfe
    276  5cfe				  -	      IF	0
    277  5cfe				  -			; king moves will also quiesce
    278  5cfe				  -			; theory is - we need to see if it was an illegal move
    279  5cfe				  -
    280  5cfe				  -	      lda	fromPiece
    281  5cfe				  -	      and	#PIECE_MASK
    282  5cfe				  -	      cmp	#KING
    283  5cfe				  -	      beq	.doQ
    284  5cfe					      ENDIF
    285  5cfe
    286  5cfe		       a5 8f		      lda	Evaluation
    287  5d00		       85 ab		      sta	__negaMax
    288  5d02		       a5 90		      lda	Evaluation+1
    289  5d04		       85 ac		      sta	__negaMax+1
    290  5d06
    291  5d06		       60	   .inCheck2  rts
    292  5d07
    293  5d07
    294  5d07
      0  5d07					      DEF	negaMax
      1  5d07				   SLOT_negaMax SET	_BANK_SLOT
      2  5d07				   BANK_negaMax SET	SLOT_negaMax + _CURRENT_BANK
      3  5d07				   negaMax
      4  5d07				   TEMPORARY_VAR SET	Overlay
      5  5d07				   TEMPORARY_OFFSET SET	0
      6  5d07				   VAR_BOUNDARY_negaMax SET	TEMPORARY_OFFSET
      7  5d07				   FUNCTION_NAME SET	negaMax
    296  5d07
    297  5d07							; PARAMS depth-1, -beta, -alpha
    298  5d07							; pased through temporary variables (__alpha, __beta) and X reg
    299  5d07
    300  5d07							; pass...
    301  5d07							; x = depthleft
    302  5d07							; a = captured piece
    303  5d07							; SET_BANK_RAM      --> current ply
    304  5d07							; __alpha[2] = param alpha
    305  5d07							; __beta[2] = param beta
    306  5d07
    307  5d07
      0  5d07					      COMMON_VARS_ALPHABETA
      1  5d07
      0  5d07					      VAR	__thinkbar, 1
      1  5d07		       00 a4	   __thinkbar =	TEMPORARY_VAR
      2  5d07				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5d07
      4  5d07				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5d07				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5d07				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5d07					      ENDIF
      8  5d07				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5d07				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  5d07				  -	      ERR
     11  5d07					      ENDIF
     12  5d07					      LIST	ON
      0  5d07					      VAR	__toggle, 1
      1  5d07		       00 a5	   __toggle   =	TEMPORARY_VAR
      2  5d07				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5d07
      4  5d07				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5d07				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5d07				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5d07					      ENDIF
      8  5d07				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5d07				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  5d07				  -	      ERR
     11  5d07					      ENDIF
     12  5d07					      LIST	ON
      4  5d07
      0  5d07					      VAR	__bestMove, 1
      1  5d07		       00 a6	   __bestMove =	TEMPORARY_VAR
      2  5d07				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5d07
      4  5d07				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5d07				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5d07				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5d07					      ENDIF
      8  5d07				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5d07				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  5d07				  -	      ERR
     11  5d07					      ENDIF
     12  5d07					      LIST	ON
      0  5d07					      VAR	__alpha, 2
      1  5d07		       00 a7	   __alpha    =	TEMPORARY_VAR
      2  5d07				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5d07
      4  5d07				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5d07				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5d07				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5d07					      ENDIF
      8  5d07				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5d07				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  5d07				  -	      ERR
     11  5d07					      ENDIF
     12  5d07					      LIST	ON
      0  5d07					      VAR	__beta, 2
      1  5d07		       00 a9	   __beta     =	TEMPORARY_VAR
      2  5d07				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5d07
      4  5d07				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5d07				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5d07				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5d07					      ENDIF
      8  5d07				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5d07				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  5d07				  -	      ERR
     11  5d07					      ENDIF
     12  5d07					      LIST	ON
      0  5d07					      VAR	__negaMax, 2
      1  5d07		       00 ab	   __negaMax  =	TEMPORARY_VAR
      2  5d07				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5d07
      4  5d07				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5d07				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5d07				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5d07					      ENDIF
      8  5d07				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5d07				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  5d07				  -	      ERR
     11  5d07					      ENDIF
     12  5d07					      LIST	ON
      0  5d07					      VAR	__value, 2
      1  5d07		       00 ad	   __value    =	TEMPORARY_VAR
      2  5d07				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5d07
      4  5d07				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5d07				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5d07				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5d07					      ENDIF
      8  5d07				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5d07				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  5d07				  -	      ERR
     11  5d07					      ENDIF
     12  5d07					      LIST	ON
     10  5d07
      0  5d07					      VAR	__quiesceCapOnly, 1
      1  5d07		       00 af	   __quiesceCapOnly =	TEMPORARY_VAR
      2  5d07				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5d07
      4  5d07				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5d07				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5d07				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5d07					      ENDIF
      8  5d07				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5d07				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  5d07				  -	      ERR
     11  5d07					      ENDIF
     12  5d07					      LIST	ON
     12  5d07
      0  5d07					      REFER	selectmove
      1  5d07				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  5d07				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  5d07					      ENDIF
      0  5d07					      VEND	negaMax
      1  5d07				  -	      IFNCONST	negaMax
      2  5d07				  -	      ECHO	"Incorrect VEND label", negaMax
      3  5d07				  -	      ERR
      4  5d07					      ENDIF
      5  5d07		       00 b0	   VAREND_negaMax =	TEMPORARY_VAR
    311  5d07
    312  5d07		       48		      pha
    313  5d08
    314  5d08		       20 7e f0 	      jsr	ThinkBar	;@0
    315  5d0b		       a5 94		      lda	currentPly
    316  5d0d		       85 3e		      sta	SET_BANK_RAM	;@2
    317  5d0f
    318  5d0f		       68		      pla
    319  5d10		       ca		      dex
    320  5d11		       30 eb		      bmi	.terminal
      0  5d13					      stx@PLY	depthLeft
      1  5d13		       8e d9 fb 	      stx	[RAM]+depthLeft
    322  5d16
    323  5d16
    324  5d16							; Allow the player to force computer to select a move. Press the SELECT switch
    325  5d16
      0  5d16					      lda@PLY	moveIndex
      1  5d16		       ad d0 f9 	      lda	moveIndex
    327  5d19		       30 07		      bmi	.noCheat	; can't force if no move chosen!
    328  5d1b		       ad 82 02 	      lda	SWCHB
    329  5d1e		       29 02		      and	#2
    330  5d20		       f0 d1		      beq	.exit	; SELECT abort
    331  5d22				   .noCheat
    332  5d22
    333  5d22		       a9 02		      lda	#2
    334  5d24		       85 48		      sta	COLUPF	; grey thinkbars
    335  5d26
    336  5d26		       a5 a7		      lda	__alpha
      0  5d28					      sta@PLY	alpha
      1  5d28		       8d d3 fb 	      sta	[RAM]+alpha
    338  5d2b		       a5 a8		      lda	__alpha+1
      0  5d2d					      sta@PLY	alpha+1
      1  5d2d		       8d d4 fb 	      sta	[RAM]+alpha+1
    340  5d30
    341  5d30		       a5 a9		      lda	__beta
      0  5d32					      sta@PLY	beta
      1  5d32		       8d d5 fb 	      sta	[RAM]+beta
    343  5d35		       a5 aa		      lda	__beta+1
      0  5d37					      sta@PLY	beta+1
      1  5d37		       8d d6 fb 	      sta	[RAM]+beta+1
    345  5d3a
    346  5d3a
    347  5d3a					      IF	1
    348  5d3a		       a5 8f		      lda	Evaluation
    349  5d3c		       65 a3		      adc	randomness
    350  5d3e		       85 8f		      sta	Evaluation
    351  5d40		       90 02		      bcc	.evh
    352  5d42		       e6 90		      inc	Evaluation+1
    353  5d44				   .evh
    354  5d44					      ENDIF
    355  5d44
    356  5d44
    357  5d44		       20 77 f1 	      jsr	GenerateAllMoves	;@0
    358  5d47
    359  5d47		       a5 a1		      lda	flagCheck
    360  5d49		       d0 bb		      bne	.inCheck2	; OTHER guy in check
    361  5d4b
    362  5d4b				  -	      IF	0
    363  5d4b				  -	      lda@PLY	moveIndex
    364  5d4b				  -	      bmi	.none
    365  5d4b				  -	      lsr
    366  5d4b				  -	      lsr
    367  5d4b				  -	      lsr
    368  5d4b				  -	      lsr
    369  5d4b				  -	      lsr
    370  5d4b				  -	      adc	Evaluation
    371  5d4b				  -	      sta	Evaluation
    372  5d4b				  -	      lda	Evaluation+1
    373  5d4b				  -	      adc	#0
    374  5d4b				  -	      sta	Evaluation+1
    375  5d4b				  -.none
    376  5d4b					      ENDIF
    377  5d4b
    378  5d4b
    379  5d4b		       a9 00		      lda	#<-INFINITY
      0  5d4d					      sta@PLY	value
      1  5d4d		       8d d7 fb 	      sta	[RAM]+value
    381  5d50		       a9 90		      lda	#>-INFINITY
      0  5d52					      sta@PLY	value+1
      1  5d52		       8d d8 fb 	      sta	[RAM]+value+1
    383  5d55
      0  5d55					      ldx@PLY	moveIndex
      1  5d55		       ae d0 f9 	      ldx	moveIndex
    385  5d58		       10 03		      bpl	.forChild
    386  5d5a		       4c f3 f4 	      jmp	.exit
    387  5d5d
      0  5d5d				   .forChild  stx@PLY	movePtr
      1  5d5d		       8e d1 fb 	      stx	[RAM]+movePtr
    389  5d60
    390  5d60		       20 87 f4 	      jsr	MakeMove	;@this
    391  5d63
    392  5d63
    393  5d63							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    394  5d63
    395  5d63							; PARAMS depth-1, -beta, -alpha
    396  5d63							; pased through temporary variables (__alpha, __beta) and X reg
    397  5d63
    398  5d63		       38		      sec
    399  5d64		       a9 00		      lda	#0
      0  5d66					      sbc@PLY	beta
      1  5d66		       ed d5 f9 	      sbc	beta
    401  5d69		       85 a7		      sta	__alpha
    402  5d6b		       a9 00		      lda	#0
      0  5d6d					      sbc@PLY	beta+1
      1  5d6d		       ed d6 f9 	      sbc	beta+1
    404  5d70		       85 a8		      sta	__alpha+1
    405  5d72
    406  5d72		       38		      sec
    407  5d73		       a9 00		      lda	#0
      0  5d75					      sbc@PLY	alpha
      1  5d75		       ed d3 f9 	      sbc	alpha
    409  5d78		       85 a9		      sta	__beta
    410  5d7a		       a9 00		      lda	#0
      0  5d7c					      sbc@PLY	alpha+1
      1  5d7c		       ed d4 f9 	      sbc	alpha+1
    412  5d7f		       85 aa		      sta	__beta+1
    413  5d81
    414  5d81
      0  5d81					      ldx@PLY	depthLeft
      1  5d81		       ae d9 f9 	      ldx	depthLeft
      0  5d84					      lda@PLY	capturedPiece
      1  5d84		       ad cb f9 	      lda	capturedPiece
    417  5d87
    418  5d87		       e6 94		      inc	currentPly
    419  5d89		       a4 94		      ldy	currentPly
    420  5d8b		       84 3e		      sty	SET_BANK_RAM	; self-switch
    421  5d8d
    422  5d8d		       20 07 f5 	      jsr	negaMax	;@this
    423  5d90
    424  5d90		       c6 94		      dec	currentPly
    425  5d92		       a5 94		      lda	currentPly
    426  5d94		       85 3e		      sta	SET_BANK_RAM
    427  5d96
    428  5d96		       20 5b f2 	      jsr	unmakeMove	;@0
    429  5d99
    430  5d99		       38		      sec
    431  5d9a		       a9 00		      lda	#0
    432  5d9c		       e5 ab		      sbc	__negaMax
    433  5d9e		       85 ab		      sta	__negaMax
    434  5da0		       a9 00		      lda	#0
    435  5da2		       e5 ac		      sbc	__negaMax+1
    436  5da4		       85 ac		      sta	__negaMax+1	; -negaMax(...)
    437  5da6
    438  5da6		       a5 a1		      lda	flagCheck
    439  5da8		       f0 06		      beq	.notCheck
    440  5daa
    441  5daa							; at this point we've determined that the move was illegal, because the next ply detected
    442  5daa							; a king capture. So, the move should be totally discounted
    443  5daa
    444  5daa		       a9 00		      lda	#0
    445  5dac		       85 a1		      sta	flagCheck	; so we don't retrigger in future - it's been handled!
    446  5dae		       f0 53		      beq	.nextMove	; unconditional - move is not considered!
    447  5db0
    448  5db0		       38	   .notCheck  sec
      0  5db1					      lda@PLY	value
      1  5db1		       ad d7 f9 	      lda	value
    450  5db4		       e5 ab		      sbc	__negaMax
      0  5db6					      lda@PLY	value+1
      1  5db6		       ad d8 f9 	      lda	value+1
    452  5db9		       e5 ac		      sbc	__negaMax+1
    453  5dbb		       50 02		      bvc	.lab0
    454  5dbd		       49 80		      eor	#$80
    455  5dbf		       10 10	   .lab0      bpl	.lt0	; branch if value >= negaMax
    456  5dc1
    457  5dc1							; so, negaMax > value!
    458  5dc1
    459  5dc1		       a5 ab		      lda	__negaMax
      0  5dc3					      sta@PLY	value
      1  5dc3		       8d d7 fb 	      sta	[RAM]+value
    461  5dc6		       a5 ac		      lda	__negaMax+1
      0  5dc8					      sta@PLY	value+1	; max(value, -negaMax)
      1  5dc8		       8d d8 fb 	      sta	[RAM]+value+1
    463  5dcb
      0  5dcb					      lda@PLY	movePtr
      1  5dcb		       ad d1 f9 	      lda	movePtr
      0  5dce					      sta@PLY	bestMove
      1  5dce		       8d d2 fb 	      sta	[RAM]+bestMove
    466  5dd1				   .lt0
    467  5dd1
    468  5dd1							;	  α := max(α, value)
    469  5dd1
    470  5dd1		       38		      sec
      0  5dd2					      lda@PLY	value
      1  5dd2		       ad d7 f9 	      lda	value
      0  5dd5					      sbc@PLY	alpha
      1  5dd5		       ed d3 f9 	      sbc	alpha
      0  5dd8					      lda@PLY	value+1
      1  5dd8		       ad d8 f9 	      lda	value+1
      0  5ddb					      sbc@PLY	alpha+1
      1  5ddb		       ed d4 f9 	      sbc	alpha+1
    475  5dde		       50 02		      bvc	.lab1
    476  5de0		       49 80		      eor	#$80
    477  5de2		       30 0c	   .lab1      bmi	.lt1	; value < alpha
    478  5de4
      0  5de4					      lda@PLY	value
      1  5de4		       ad d7 f9 	      lda	value
      0  5de7					      sta@PLY	alpha
      1  5de7		       8d d3 fb 	      sta	[RAM]+alpha
      0  5dea					      lda@PLY	value+1
      1  5dea		       ad d8 f9 	      lda	value+1
      0  5ded					      sta@PLY	alpha+1	; alpha = max(alpha, value)
      1  5ded		       8d d4 fb 	      sta	[RAM]+alpha+1
    483  5df0
    484  5df0				   .lt1
    485  5df0
    486  5df0							;	  if α ≥ β then
    487  5df0							;	      break (* cut-off *)
    488  5df0
    489  5df0		       38		      sec
      0  5df1					      lda@PLY	alpha
      1  5df1		       ad d3 f9 	      lda	alpha
      0  5df4					      sbc@PLY	beta
      1  5df4		       ed d5 f9 	      sbc	beta
      0  5df7					      lda@PLY	alpha+1
      1  5df7		       ad d4 f9 	      lda	alpha+1
      0  5dfa					      sbc@PLY	beta+1
      1  5dfa		       ed d6 f9 	      sbc	beta+1
    494  5dfd		       50 02		      bvc	.lab2
    495  5dff		       49 80		      eor	#$80
    496  5e01		       10 09	   .lab2      bpl	.retrn	; alpha >= beta
    497  5e03
    498  5e03
      0  5e03				   .nextMove  ldx@PLY	movePtr
      1  5e03		       ae d1 f9 	      ldx	movePtr
    500  5e06		       ca	   .nextX     dex
    501  5e07		       30 03		      bmi	.retrn
    502  5e09		       4c 5d f5 	      jmp	.forChild
    503  5e0c
    504  5e0c		       4c f3 f4    .retrn     jmp	.exit
    505  5e0f
    506  5e0f							;---------------------------------------------------------------------------------------------------
    507  5e0f
    508  5e0f					      MAC	xchg
    509  5e0f					      lda@PLY	{1},x
    510  5e0f					      sta	__xchg
    511  5e0f					      lda@PLY	{1},y
    512  5e0f					      sta@PLY	{1},x
    513  5e0f					      lda	__xchg
    514  5e0f					      sta@PLY	{1},y
    515  5e0f					      ENDM		;{name}
    516  5e0f
    517  5e0f
      0  5e0f					      DEF	Sort
      1  5e0f				   SLOT_Sort  SET	_BANK_SLOT
      2  5e0f				   BANK_Sort  SET	SLOT_Sort + _CURRENT_BANK
      3  5e0f				   Sort
      4  5e0f				   TEMPORARY_VAR SET	Overlay
      5  5e0f				   TEMPORARY_OFFSET SET	0
      6  5e0f				   VAR_BOUNDARY_Sort SET	TEMPORARY_OFFSET
      7  5e0f				   FUNCTION_NAME SET	Sort
    519  5e0f					      SUBROUTINE
    520  5e0f
      0  5e0f					      REFER	GenerateAllMoves
      1  5e0f					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5e0f				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5e0f					      ENDIF
      0  5e0f					      VAR	__xchg, 1
      1  5e0f		       00 b5	   __xchg     =	TEMPORARY_VAR
      2  5e0f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5e0f
      4  5e0f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5e0f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5e0f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5e0f					      ENDIF
      8  5e0f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5e0f				  -	      ECHO	"Temporary Variable", __xchg, "overflow!"
     10  5e0f				  -	      ERR
     11  5e0f					      ENDIF
     12  5e0f					      LIST	ON
      0  5e0f					      VEND	Sort
      1  5e0f				  -	      IFNCONST	Sort
      2  5e0f				  -	      ECHO	"Incorrect VEND label", Sort
      3  5e0f				  -	      ERR
      4  5e0f					      ENDIF
      5  5e0f		       00 b6	   VAREND_Sort =	TEMPORARY_VAR
    524  5e0f
    525  5e0f		       a5 af		      lda	__quiesceCapOnly
    526  5e11		       30 51		      bmi	.exit	; only caps present so already sorted!
    527  5e13
      0  5e13					      ldx@PLY	moveIndex
      1  5e13		       ae d0 f9 	      ldx	moveIndex
      0  5e16					      ldy@PLY	moveIndex
      1  5e16		       ac d0 f9 	      ldy	moveIndex
    530  5e19		       88	   .next      dey
    531  5e1a		       30 48		      bmi	.exit
    532  5e1c
      0  5e1c					      lda@PLY	MoveCapture,y
      1  5e1c		       b9 64 f9 	      lda	MoveCapture,y
    534  5e1f		       f0 f8		      beq	.next
    535  5e21
      0  5e21					      XCHG	MoveFrom
      0  5e21					      lda@PLY	MoveFrom,x
      1  5e21		       bd 00 f8 	      lda	MoveFrom,x
      2  5e24		       85 b5		      sta	__xchg
      0  5e26					      lda@PLY	MoveFrom,y
      1  5e26		       b9 00 f8 	      lda	MoveFrom,y
      0  5e29					      sta@PLY	MoveFrom,x
      1  5e29		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
      5  5e2c		       a5 b5		      lda	__xchg
      0  5e2e					      sta@PLY	MoveFrom,y
      1  5e2e		       99 00 fa 	      sta	[RAM]+MoveFrom,y
      0  5e31					      XCHG	MoveTo
      0  5e31					      lda@PLY	MoveTo,x
      1  5e31		       bd 64 f8 	      lda	MoveTo,x
      2  5e34		       85 b5		      sta	__xchg
      0  5e36					      lda@PLY	MoveTo,y
      1  5e36		       b9 64 f8 	      lda	MoveTo,y
      0  5e39					      sta@PLY	MoveTo,x
      1  5e39		       9d 64 fa 	      sta	[RAM]+MoveTo,x
      5  5e3c		       a5 b5		      lda	__xchg
      0  5e3e					      sta@PLY	MoveTo,y
      1  5e3e		       99 64 fa 	      sta	[RAM]+MoveTo,y
      0  5e41					      XCHG	MovePiece
      0  5e41					      lda@PLY	MovePiece,x
      1  5e41		       bd 00 f9 	      lda	MovePiece,x
      2  5e44		       85 b5		      sta	__xchg
      0  5e46					      lda@PLY	MovePiece,y
      1  5e46		       b9 00 f9 	      lda	MovePiece,y
      0  5e49					      sta@PLY	MovePiece,x
      1  5e49		       9d 00 fb 	      sta	[RAM]+MovePiece,x
      5  5e4c		       a5 b5		      lda	__xchg
      0  5e4e					      sta@PLY	MovePiece,y
      1  5e4e		       99 00 fb 	      sta	[RAM]+MovePiece,y
      0  5e51					      XCHG	MoveCapture
      0  5e51					      lda@PLY	MoveCapture,x
      1  5e51		       bd 64 f9 	      lda	MoveCapture,x
      2  5e54		       85 b5		      sta	__xchg
      0  5e56					      lda@PLY	MoveCapture,y
      1  5e56		       b9 64 f9 	      lda	MoveCapture,y
      0  5e59					      sta@PLY	MoveCapture,x
      1  5e59		       9d 64 fb 	      sta	[RAM]+MoveCapture,x
      5  5e5c		       a5 b5		      lda	__xchg
      0  5e5e					      sta@PLY	MoveCapture,y
      1  5e5e		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    540  5e61
    541  5e61		       ca		      dex
    542  5e62		       10 b5		      bpl	.next
    543  5e64
    544  5e64				   .exit
    545  5e64
    546  5e64
    547  5e64
    548  5e64
    549  5e64							; Scan for capture of king
    550  5e64
      0  5e64					      ldx@PLY	moveIndex
      1  5e64		       ae d0 f9 	      ldx	moveIndex
    552  5e67
      0  5e67				   .scanCheck lda@PLY	MoveCapture,x
      1  5e67		       bd 64 f9 	      lda	MoveCapture,x
    554  5e6a		       f0 0b		      beq	.check	; since they're sorted with captures "first" we can exit
    555  5e6c		       29 0f		      and	#PIECE_MASK
    556  5e6e		       c9 07		      cmp	#KING
    557  5e70		       f0 05		      beq	.check
    558  5e72		       ca		      dex
    559  5e73		       10 f2		      bpl	.scanCheck
    560  5e75
    561  5e75		       a9 00		      lda	#0
    562  5e77		       85 a1	   .check     sta	flagCheck
    563  5e79		       60		      rts
    564  5e7a
    565  5e7a
    566  5e7a							;---------------------------------------------------------------------------------------------------
    567  5e7a							; QUIESCE!
    568  5e7a
    569  5e7a							;int Quiesce( int alpha, int beta ) {
    570  5e7a							;    int stand_pat = Evaluate();
    571  5e7a							;    if( stand_pat >= beta )
    572  5e7a							;	  return beta;
    573  5e7a							;    if( alpha < stand_pat )
    574  5e7a							;	  alpha = stand_pat;
    575  5e7a
    576  5e7a							;    until( every_capture_has_been_examined )	{
    577  5e7a							;	  MakeCapture();
    578  5e7a							;	  score = -Quiesce( -beta, -alpha );
    579  5e7a							;	  TakeBackMove();
    580  5e7a
    581  5e7a							;	  if( score >= beta )
    582  5e7a							;	      return beta;
    583  5e7a							;	  if( score > alpha )
    584  5e7a							;	     alpha = score;
    585  5e7a							;    }
    586  5e7a							;    return alpha;
    587  5e7a							;}
    588  5e7a
    589  5e7a
    590  5e7a							;---------------------------------------------------------------------------------------------------
    591  5e7a
      0  5e7a					      DEF	quiesce
      1  5e7a				   SLOT_quiesce SET	_BANK_SLOT
      2  5e7a				   BANK_quiesce SET	SLOT_quiesce + _CURRENT_BANK
      3  5e7a				   quiesce
      4  5e7a				   TEMPORARY_VAR SET	Overlay
      5  5e7a				   TEMPORARY_OFFSET SET	0
      6  5e7a				   VAR_BOUNDARY_quiesce SET	TEMPORARY_OFFSET
      7  5e7a				   FUNCTION_NAME SET	quiesce
    593  5e7a					      SUBROUTINE
    594  5e7a
    595  5e7a							; pass...
    596  5e7a							; x = depthleft
    597  5e7a							; SET_BANK_RAM      --> current ply
    598  5e7a							; __alpha[2] = param alpha
    599  5e7a							; __beta[2] = param beta
    600  5e7a
    601  5e7a
      0  5e7a					      COMMON_VARS_ALPHABETA
      1  5e7a
      0  5e7a					      VAR	__thinkbar, 1
      1  5e7a		       00 a4	   __thinkbar =	TEMPORARY_VAR
      2  5e7a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5e7a
      4  5e7a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5e7a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5e7a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5e7a					      ENDIF
      8  5e7a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5e7a				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  5e7a				  -	      ERR
     11  5e7a					      ENDIF
     12  5e7a					      LIST	ON
      0  5e7a					      VAR	__toggle, 1
      1  5e7a		       00 a5	   __toggle   =	TEMPORARY_VAR
      2  5e7a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5e7a
      4  5e7a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5e7a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5e7a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5e7a					      ENDIF
      8  5e7a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5e7a				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  5e7a				  -	      ERR
     11  5e7a					      ENDIF
     12  5e7a					      LIST	ON
      4  5e7a
      0  5e7a					      VAR	__bestMove, 1
      1  5e7a		       00 a6	   __bestMove =	TEMPORARY_VAR
      2  5e7a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5e7a
      4  5e7a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5e7a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5e7a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5e7a					      ENDIF
      8  5e7a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5e7a				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  5e7a				  -	      ERR
     11  5e7a					      ENDIF
     12  5e7a					      LIST	ON
      0  5e7a					      VAR	__alpha, 2
      1  5e7a		       00 a7	   __alpha    =	TEMPORARY_VAR
      2  5e7a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5e7a
      4  5e7a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5e7a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5e7a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5e7a					      ENDIF
      8  5e7a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5e7a				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  5e7a				  -	      ERR
     11  5e7a					      ENDIF
     12  5e7a					      LIST	ON
      0  5e7a					      VAR	__beta, 2
      1  5e7a		       00 a9	   __beta     =	TEMPORARY_VAR
      2  5e7a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5e7a
      4  5e7a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5e7a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5e7a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5e7a					      ENDIF
      8  5e7a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5e7a				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  5e7a				  -	      ERR
     11  5e7a					      ENDIF
     12  5e7a					      LIST	ON
      0  5e7a					      VAR	__negaMax, 2
      1  5e7a		       00 ab	   __negaMax  =	TEMPORARY_VAR
      2  5e7a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5e7a
      4  5e7a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5e7a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5e7a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5e7a					      ENDIF
      8  5e7a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5e7a				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  5e7a				  -	      ERR
     11  5e7a					      ENDIF
     12  5e7a					      LIST	ON
      0  5e7a					      VAR	__value, 2
      1  5e7a		       00 ad	   __value    =	TEMPORARY_VAR
      2  5e7a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5e7a
      4  5e7a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5e7a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5e7a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5e7a					      ENDIF
      8  5e7a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5e7a				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  5e7a				  -	      ERR
     11  5e7a					      ENDIF
     12  5e7a					      LIST	ON
     10  5e7a
      0  5e7a					      VAR	__quiesceCapOnly, 1
      1  5e7a		       00 af	   __quiesceCapOnly =	TEMPORARY_VAR
      2  5e7a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5e7a
      4  5e7a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5e7a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5e7a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5e7a					      ENDIF
      8  5e7a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5e7a				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  5e7a				  -	      ERR
     11  5e7a					      ENDIF
     12  5e7a					      LIST	ON
     12  5e7a
      0  5e7a					      REFER	negaMax
      1  5e7a				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  5e7a				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  5e7a					      ENDIF
      0  5e7a					      VEND	quiesce
      1  5e7a				  -	      IFNCONST	quiesce
      2  5e7a				  -	      ECHO	"Incorrect VEND label", quiesce
      3  5e7a				  -	      ERR
      4  5e7a					      ENDIF
      5  5e7a		       00 b0	   VAREND_quiesce =	TEMPORARY_VAR
    605  5e7a
    606  5e7a		       a5 94		      lda	currentPly
    607  5e7c		       c9 8b		      cmp	#RAMBANK_PLY + PLY_BANKS -1
    608  5e7e		       b0 43		      bcs	.retBeta
    609  5e80
    610  5e80							; The 'thinkbar' pattern...
    611  5e80
    612  5e80		       a9 00		      lda	#0
    613  5e82		       a4 4c		      ldy	INPT4
    614  5e84		       30 14		      bmi	.doThink
    615  5e86
    616  5e86		       a5 a4		      lda	__thinkbar
    617  5e88		       0a		      asl
    618  5e89		       0a		      asl
    619  5e8a		       0a		      asl
    620  5e8b		       0a		      asl
    621  5e8c		       09 02		      ora	#2
    622  5e8e		       85 48		      sta	COLUPF
    623  5e90
    624  5e90		       e6 a4		      inc	__thinkbar
    625  5e92		       a5 a4		      lda	__thinkbar
    626  5e94		       29 0f		      and	#15
    627  5e96		       a8		      tay
    628  5e97		       b9 7c f7 	      lda	SynapsePattern2,y
    629  5e9a
    630  5e9a		       85 4e	   .doThink   sta	PF1
    631  5e9c		       85 4f		      sta	PF2
    632  5e9e
    633  5e9e							; ^
    634  5e9e
    635  5e9e		       a5 a9		      lda	__beta
      0  5ea0					      sta@PLY	beta
      1  5ea0		       8d d5 fb 	      sta	[RAM]+beta
    637  5ea3		       a5 aa		      lda	__beta+1
      0  5ea5					      sta@PLY	beta+1
      1  5ea5		       8d d6 fb 	      sta	[RAM]+beta+1
    639  5ea8
    640  5ea8		       a5 a7		      lda	__alpha
      0  5eaa					      sta@PLY	alpha
      1  5eaa		       8d d3 fb 	      sta	[RAM]+alpha
    642  5ead		       a5 a8		      lda	__alpha+1
      0  5eaf					      sta@PLY	alpha+1
      1  5eaf		       8d d4 fb 	      sta	[RAM]+alpha+1
    644  5eb2
    645  5eb2
    646  5eb2							;    int stand_pat = Evaluate();
    647  5eb2							;    if( stand_pat >= beta )
    648  5eb2							;	  return beta;
    649  5eb2
    650  5eb2		       38		      sec
    651  5eb3		       a5 8f		      lda	Evaluation
      0  5eb5					      sbc@PLY	beta
      1  5eb5		       ed d5 f9 	      sbc	beta
    653  5eb8		       a5 90		      lda	Evaluation+1
      0  5eba					      sbc@PLY	beta+1
      1  5eba		       ed d6 f9 	      sbc	beta+1
    655  5ebd		       50 02		      bvc	.spat0
    656  5ebf		       49 80		      eor	#$80
    657  5ec1		       30 0b	   .spat0     bmi	.norb	;pl .retBeta			 ; branch if stand_pat >= beta
    658  5ec3
    659  5ec3		       ad d5 f9    .retBeta   lda	beta
    660  5ec6		       85 ab		      sta	__negaMax
    661  5ec8		       ad d6 f9 	      lda	beta+1
    662  5ecb		       85 ac		      sta	__negaMax+1
    663  5ecd
    664  5ecd		       60	   .abort     rts
    665  5ece
    666  5ece				   .norb
    667  5ece
    668  5ece
    669  5ece							;    if( alpha < stand_pat )
    670  5ece							;	  alpha = stand_pat;
    671  5ece
    672  5ece		       38		      sec
    673  5ecf		       ad d3 f9 	      lda	alpha
    674  5ed2		       e5 8f		      sbc	Evaluation
    675  5ed4		       ad d4 f9 	      lda	alpha+1
    676  5ed7		       e5 90		      sbc	Evaluation+1
    677  5ed9		       50 02		      bvc	.spat1
    678  5edb		       49 80		      eor	#$80
    679  5edd		       10 0a	   .spat1     bpl	.alpha	; branch if alpha >= stand_pat
    680  5edf
    681  5edf							; alpha < stand_pat
    682  5edf
    683  5edf		       a5 8f		      lda	Evaluation
      0  5ee1					      sta@PLY	alpha
      1  5ee1		       8d d3 fb 	      sta	[RAM]+alpha
    685  5ee4		       a5 90		      lda	Evaluation+1
      0  5ee6					      sta@PLY	alpha+1
      1  5ee6		       8d d4 fb 	      sta	[RAM]+alpha+1
    687  5ee9
    688  5ee9				   .alpha
    689  5ee9		       20 77 f1 	      jsr	GenerateAllMoves
    690  5eec		       a5 a1		      lda	flagCheck
    691  5eee		       d0 dd		      bne	.abort	; pure abort
    692  5ef0
      0  5ef0					      ldx@PLY	moveIndex
      1  5ef0		       ae d0 f9 	      ldx	moveIndex
    694  5ef3		       30 76		      bmi	.exit
    695  5ef5
      0  5ef5				   .forChild  stx@PLY	movePtr
      1  5ef5		       8e d1 fb 	      stx	[RAM]+movePtr
    697  5ef8
    698  5ef8							; The movelist has captures ONLY (ref: __quiesceCapOnly != 0)
    699  5ef8
    700  5ef8		       20 87 f4 	      jsr	MakeMove	;@this
    701  5efb
    702  5efb		       38		      sec
    703  5efc		       a9 00		      lda	#0
      0  5efe					      sbc@PLY	beta
      1  5efe		       ed d5 f9 	      sbc	beta
    705  5f01		       85 a7		      sta	__alpha
    706  5f03		       a9 00		      lda	#0
      0  5f05					      sbc@PLY	beta+1
      1  5f05		       ed d6 f9 	      sbc	beta+1
    708  5f08		       85 a8		      sta	__alpha+1
    709  5f0a
    710  5f0a		       38		      sec
    711  5f0b		       a9 00		      lda	#0
      0  5f0d					      sbc@PLY	alpha
      1  5f0d		       ed d3 f9 	      sbc	alpha
    713  5f10		       85 a9		      sta	__beta
    714  5f12		       a9 00		      lda	#0
      0  5f14					      sbc@PLY	alpha+1
      1  5f14		       ed d4 f9 	      sbc	alpha+1
    716  5f17		       85 aa		      sta	__beta+1
    717  5f19
    718  5f19		       e6 94		      inc	currentPly
    719  5f1b		       a5 94		      lda	currentPly
    720  5f1d		       85 3e		      sta	SET_BANK_RAM	; self-switch
    721  5f1f
    722  5f1f		       20 7a f6 	      jsr	quiesce	;@this
    723  5f22
    724  5f22		       c6 94		      dec	currentPly
    725  5f24							;lda currentPly
    726  5f24							;sta SET_BANK_RAM
    727  5f24
    728  5f24		       20 5b f2 	      jsr	unmakeMove	;@0
    729  5f27
    730  5f27		       a5 a1		      lda	flagCheck	; don't consider moves which leave us in check
    731  5f29		       d0 4b		      bne	.inCheck
    732  5f2b
    733  5f2b		       38		      sec
    734  5f2c							;lda #0			 ; already 0
    735  5f2c		       e5 ab		      sbc	__negaMax
    736  5f2e		       85 ab		      sta	__negaMax
    737  5f30		       a9 00		      lda	#0
    738  5f32		       e5 ac		      sbc	__negaMax+1
    739  5f34		       85 ac		      sta	__negaMax+1	; -negaMax(...)
    740  5f36
    741  5f36
    742  5f36
    743  5f36							;	  if( score >= beta )
    744  5f36							;	      return beta;
    745  5f36
    746  5f36
    747  5f36		       38		      sec
    748  5f37		       a5 ab		      lda	__negaMax
      0  5f39					      sbc@PLY	beta
      1  5f39		       ed d5 f9 	      sbc	beta
    750  5f3c		       a5 ac		      lda	__negaMax+1
      0  5f3e					      sbc@PLY	beta+1
      1  5f3e		       ed d6 f9 	      sbc	beta+1
    752  5f41		       50 02		      bvc	.lab0
    753  5f43		       49 80		      eor	#$80
    754  5f45		       30 03	   .lab0      bmi	.nrb2	; .retBeta		       ; branch if score >= beta
    755  5f47		       4c c3 f6 	      jmp	.retBeta
    756  5f4a				   .nrb2
    757  5f4a
    758  5f4a							;	  if( score > alpha )
    759  5f4a							;	     alpha = score;
    760  5f4a							;    }
    761  5f4a
    762  5f4a		       38		      sec
      0  5f4b					      lda@PLY	alpha
      1  5f4b		       ad d3 f9 	      lda	alpha
    764  5f4e		       e5 ab		      sbc	__negaMax
      0  5f50					      lda@PLY	alpha+1
      1  5f50		       ad d4 f9 	      lda	alpha+1
    766  5f53		       e5 ac		      sbc	__negaMax+1
    767  5f55		       50 02		      bvc	.lab2
    768  5f57		       49 80		      eor	#$80
    769  5f59		       10 0a	   .lab2      bpl	.nextMove	; alpha >= score
    770  5f5b
    771  5f5b							; score > alpha
    772  5f5b
    773  5f5b		       a5 ab		      lda	__negaMax
      0  5f5d					      sta@PLY	alpha
      1  5f5d		       8d d3 fb 	      sta	[RAM]+alpha
    775  5f60		       a5 ac		      lda	__negaMax+1
      0  5f62					      sta@PLY	alpha+1
      1  5f62		       8d d4 fb 	      sta	[RAM]+alpha+1
    777  5f65
      0  5f65				   .nextMove  ldx@PLY	movePtr
      1  5f65		       ae d1 f9 	      ldx	movePtr
    779  5f68		       ca		      dex
    780  5f69		       10 8a		      bpl	.forChild
    781  5f6b
    782  5f6b							;    return alpha;
    783  5f6b
    784  5f6b				   .exit
      0  5f6b					      lda@PLY	alpha
      1  5f6b		       ad d3 f9 	      lda	alpha
    786  5f6e		       85 ab		      sta	__negaMax
      0  5f70					      lda@PLY	alpha+1
      1  5f70		       ad d4 f9 	      lda	alpha+1
    788  5f73		       85 ac		      sta	__negaMax+1
    789  5f75		       60		      rts
    790  5f76
    791  5f76		       a9 00	   .inCheck   lda	#0
    792  5f78		       85 a1		      sta	flagCheck
    793  5f7a		       f0 e9		      beq	.nextMove
    794  5f7c
    795  5f7c
    796  5f7c
    797  5f7c				   SynapsePattern2
    798  5f7c
    799  5f7c		       c1		      .byte.b	%11000001
    800  5f7d		       60		      .byte.b	%01100000
    801  5f7e		       30		      .byte.b	%00110000
    802  5f7f		       18		      .byte.b	%00011000
    803  5f80		       0c		      .byte.b	%00001100
    804  5f81		       06		      .byte.b	%00000110
    805  5f82		       83		      .byte.b	%10000011
    806  5f83		       c1		      .byte.b	%11000001
    807  5f84
    808  5f84		       83		      .byte.b	%10000011
    809  5f85		       06		      .byte.b	%00000110
    810  5f86		       0c		      .byte.b	%00001100
    811  5f87		       18		      .byte.b	%00011000
    812  5f88		       30		      .byte.b	%00110000
    813  5f89		       60		      .byte.b	%01100000
    814  5f8a		       c1		      .byte.b	%11000001
    815  5f8b		       83		      .byte.b	%10000011
    816  5f8c
    817  5f8c
    818  5f8c							;---------------------------------------------------------------------------------------------------
    819  5f8c
      0  5f8c					      CHECK_BANK_SIZE	"NEGAMAX"
      1  5f8c		       03 8c	   .TEMP      =	* - _BANK_START
 NEGAMAX (1K) SIZE =  $38c , FREE= $74
      2  5f8c					      ECHO	"NEGAMAX", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5f8c				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5f8c				  -	      ECHO	"BANK OVERFLOW @ ", "NEGAMAX", " size=", * - ORIGIN
      5  5f8c				  -	      ERR
      6  5f8c					      ENDIF
    821  5f8c
    822  5f8c							;---------------------------------------------------------------------------------------------------
    823  5f8c							; EOF
------- FILE ./chess.asm
    632  5f8c
------- FILE PIECE_MACROS.asm LEVEL 2 PASS 4
      0  5f8c					      include	"PIECE_MACROS.asm"
      1  5f8c							; Copyright (C)2020 Andrew Davie
      2  5f8c							; Common macros for piece move handlers
      3  5f8c
      4  5f8c							;---------------------------------------------------------------------------------------------------
      5  5f8c							; Looks at a square offset {1} to see if piece can move to it
      6  5f8c							; Adds the square to the movelist if it can
      7  5f8c							; Keeps moving in the same direction until it's blocked/off=board
      8  5f8c
      9  5f8c					      MAC	move_towards
     10  5f8c					      SUBROUTINE
     11  5f8c
     12  5f8c							; = 76 for single square (empty/take)
     13  5f8c
     14  5f8c					      lda	#0
     15  5f8c					      sta	capture
     16  5f8c
     17  5f8c					      ldx	currentSquare	; 3
     18  5f8c					      bne	.project	; 3   unconditional
     19  5f8c
     20  5f8c				   .empty     jsr	AddMove	; 57
     21  5f8c				   .project   ldy	ValidSquare+{1},x	; 4
     22  5f8c					      bmi	.invalid	; 2/3 off board!
     23  5f8c					      lda	Board,y	; 4   piece @ destination
     24  5f8c					      beq	.empty	; 2/3
     25  5f8c					      sta	capture
     26  5f8c					      eor	currentPiece	; 3
     27  5f8c					      bpl	.invalid	; 2/3 same colour
     28  5f8c					      jsr	AddMove	; 57  and exit
     29  5f8c
     30  5f8c				   .invalid
     31  5f8c					      ENDM
     32  5f8c
     33  5f8c
     34  5f8c							;---------------------------------------------------------------------------------------------------
     35  5f8c
     36  5f8c					      MAC	move_to
     37  5f8c					      SUBROUTINE
     38  5f8c					      ldy	ValidSquare+{1},x
     39  5f8c					      bmi	.invalid	; off board!
     40  5f8c					      lda	Board,y	; piece @ destination
     41  5f8c					      sta	capture
     42  5f8c					      beq	.squareEmpty
     43  5f8c					      eor	currentPiece
     44  5f8c					      bpl	.invalid	; same colour
     45  5f8c				   .squareEmpty jsr	AddMove
     46  5f8c				   .invalid
     47  5f8c					      ENDM
     48  5f8c
     49  5f8c
     50  5f8c							;---------------------------------------------------------------------------------------------------
     51  5f8c
     52  5f8c					      MAC	move_to_x
     53  5f8c					      ldx	currentSquare
     54  5f8c					      MOVE_TO	{1}
     55  5f8c					      ENDM
     56  5f8c
     57  5f8c
     58  5f8c							;---------------------------------------------------------------------------------------------------
     59  5f8c							; EOF
------- FILE ./chess.asm
------- FILE GENMOVE.asm LEVEL 2 PASS 4
      0  5f8c					      include	"GENMOVE.asm"
      1  5f8c							; Chess
      2  5f8c							; Copyright (c) 2019-2020 Andrew Davie
      3  5f8c							; andrew@taswegian.com
      4  5f8c
      0  5f8c					      SLOT	1	; this code assembles for bank #1
      1  5f8c				  -	      IF	(1 < 0) || (1 > 3)
      2  5f8c				  -	      ECHO	"Illegal bank address/segment location", 1
      3  5f8c				  -	      ERR
      4  5f8c					      ENDIF
      5  5f8c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  5f8c				   _BANK_SLOT SET	1 * 64
      0  5f8c					      NEWBANK	GENMOVE
      1  6030 ????				      SEG	GENMOVE
      2  6000					      ORG	_ORIGIN
      3  6000					      RORG	_BANK_ADDRESS_ORIGIN
      4  6000				   _BANK_START SET	*
      5  6000				   GENMOVE_START SET	*
      6  6000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6000				   GENMOVE    SET	_BANK_SLOT + _CURRENT_BANK
      8  6000				   _ORIGIN    SET	_ORIGIN + 1024
      7  6000
      8  6000					      MAC	handlevec
      9  6000					      .byte	{1}MoveReturn
     10  6000					      .byte	{1}MoveReturn	;byte {1}Handle_WHITE_PAWN	   ; 1
     11  6000					      .byte	{1}MoveReturn	;.byte {1}Handle_BLACK_PAWN	    ; 2
     12  6000					      .byte	{1}Handle_KNIGHT	; 3
     13  6000					      .byte	{1}Handle_BISHOP	; 4
     14  6000					      .byte	{1}Handle_ROOK	; 5
     15  6000					      .byte	{1}Handle_QUEEN	; 6
     16  6000					      .byte	{1}Handle_KING	; 7
     17  6000
     18  6000					      .byte	{1}MoveReturn
     19  6000					      .byte	{1}Handle_WHITE_PAWN	; 1
     20  6000					      .byte	{1}Handle_BLACK_PAWN	; 2
     21  6000					      .byte	{1}MoveReturn	;.byte {1}Handle_KNIGHT	    ; 3
     22  6000					      .byte	{1}MoveReturn	;.byte {1}Handle_BISHOP	    ; 4
     23  6000					      .byte	{1}MoveReturn	;.byte {1}Handle_ROOK		    ; 5
     24  6000					      .byte	{1}MoveReturn	;.byte {1}Handle_QUEEN 	    ; 6
     25  6000					      .byte	{1}MoveReturn	;.byte {1}Handle_KING		    ; 7
     26  6000					      ENDM
     27  6000
     28  6000
     29  6000							;    .byte 0	  ; dummy to prevent page cross access on index 0
     30  6000
      0  6000					      DEF	HandlerVectorLO
      1  6000				   SLOT_HandlerVectorLO SET	_BANK_SLOT
      2  6000				   BANK_HandlerVectorLO SET	SLOT_HandlerVectorLO + _CURRENT_BANK
      3  6000				   HandlerVectorLO
      4  6000				   TEMPORARY_VAR SET	Overlay
      5  6000				   TEMPORARY_OFFSET SET	0
      6  6000				   VAR_BOUNDARY_HandlerVectorLO SET	TEMPORARY_OFFSET
      7  6000				   FUNCTION_NAME SET	HandlerVectorLO
      0  6000					      HANDLEVEC	<
      1  6000		       b3		      .byte.b	<MoveReturn
      2  6001		       b3		      .byte.b	<MoveReturn
      3  6002		       b3		      .byte.b	<MoveReturn
      4  6003		       44		      .byte.b	<Handle_KNIGHT
      5  6004		       ed		      .byte.b	<Handle_BISHOP
      6  6005		       00		      .byte.b	<Handle_ROOK
      7  6006		       7b		      .byte.b	<Handle_QUEEN
      8  6007		       6e		      .byte.b	<Handle_KING
      9  6008
     10  6008		       b3		      .byte.b	<MoveReturn
     11  6009		       29		      .byte.b	<Handle_WHITE_PAWN
     12  600a		       cb		      .byte.b	<Handle_BLACK_PAWN
     13  600b		       b3		      .byte.b	<MoveReturn
     14  600c		       b3		      .byte.b	<MoveReturn
     15  600d		       b3		      .byte.b	<MoveReturn
     16  600e		       b3		      .byte.b	<MoveReturn
     17  600f		       b3		      .byte.b	<MoveReturn
      0  6010					      DEF	HandlerVectorHI
      1  6010				   SLOT_HandlerVectorHI SET	_BANK_SLOT
      2  6010				   BANK_HandlerVectorHI SET	SLOT_HandlerVectorHI + _CURRENT_BANK
      3  6010				   HandlerVectorHI
      4  6010				   TEMPORARY_VAR SET	Overlay
      5  6010				   TEMPORARY_OFFSET SET	0
      6  6010				   VAR_BOUNDARY_HandlerVectorHI SET	TEMPORARY_OFFSET
      7  6010				   FUNCTION_NAME SET	HandlerVectorHI
      0  6010					      HANDLEVEC	>
      1  6010		       f1		      .byte.b	>MoveReturn
      2  6011		       f1		      .byte.b	>MoveReturn
      3  6012		       f1		      .byte.b	>MoveReturn
      4  6013		       f5		      .byte.b	>Handle_KNIGHT
      5  6014		       f5		      .byte.b	>Handle_BISHOP
      6  6015		       f4		      .byte.b	>Handle_ROOK
      7  6016		       f4		      .byte.b	>Handle_QUEEN
      8  6017		       f5		      .byte.b	>Handle_KING
      9  6018
     10  6018		       f1		      .byte.b	>MoveReturn
     11  6019		       f4		      .byte.b	>Handle_WHITE_PAWN
     12  601a		       f4		      .byte.b	>Handle_BLACK_PAWN
     13  601b		       f1		      .byte.b	>MoveReturn
     14  601c		       f1		      .byte.b	>MoveReturn
     15  601d		       f1		      .byte.b	>MoveReturn
     16  601e		       f1		      .byte.b	>MoveReturn
     17  601f		       f1		      .byte.b	>MoveReturn
      0  6020					      DEF	HandlerVectorBANK
      1  6020				   SLOT_HandlerVectorBANK SET	_BANK_SLOT
      2  6020				   BANK_HandlerVectorBANK SET	SLOT_HandlerVectorBANK + _CURRENT_BANK
      3  6020				   HandlerVectorBANK
      4  6020				   TEMPORARY_VAR SET	Overlay
      5  6020				   TEMPORARY_OFFSET SET	0
      6  6020				   VAR_BOUNDARY_HandlerVectorBANK SET	TEMPORARY_OFFSET
      7  6020				   FUNCTION_NAME SET	HandlerVectorBANK
      0  6020					      HANDLEVEC	BANK_
      1  6020		       00		      .byte.b	BANK_MoveReturn
      2  6021		       00		      .byte.b	BANK_MoveReturn
      3  6022		       00		      .byte.b	BANK_MoveReturn
      4  6023		       5b		      .byte.b	BANK_Handle_KNIGHT
      5  6024		       5b		      .byte.b	BANK_Handle_BISHOP
      6  6025		       5c		      .byte.b	BANK_Handle_ROOK
      7  6026		       5c		      .byte.b	BANK_Handle_QUEEN
      8  6027		       5c		      .byte.b	BANK_Handle_KING
      9  6028
     10  6028		       00		      .byte.b	BANK_MoveReturn
     11  6029		       5b		      .byte.b	BANK_Handle_WHITE_PAWN
     12  602a		       5b		      .byte.b	BANK_Handle_BLACK_PAWN
     13  602b		       00		      .byte.b	BANK_MoveReturn
     14  602c		       00		      .byte.b	BANK_MoveReturn
     15  602d		       00		      .byte.b	BANK_MoveReturn
     16  602e		       00		      .byte.b	BANK_MoveReturn
     17  602f		       00		      .byte.b	BANK_MoveReturn
     37  6030
     38  6030
     39  6030							;---------------------------------------------------------------------------------------------------
     40  6030
      0  6030					      CHECK_BANK_SIZE	"GENMOVE"
      1  6030		       00 30	   .TEMP      =	* - _BANK_START
 GENMOVE (1K) SIZE =  $30 , FREE= $3d0
      2  6030					      ECHO	"GENMOVE", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  6030				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6030				  -	      ECHO	"BANK OVERFLOW @ ", "GENMOVE", " size=", * - ORIGIN
      5  6030				  -	      ERR
      6  6030					      ENDIF
     42  6030
     43  6030							;---------------------------------------------------------------------------------------------------
     44  6030							; EOF
------- FILE ./chess.asm
------- FILE GENMOVE2.asm LEVEL 2 PASS 4
      0  6030					      include	"GENMOVE2.asm"
      1  6030							; Chess
      2  6030							; Copyright (c) 2019-2020 Andrew Davie
      3  6030							; andrew@taswegian.com
      4  6030
      0  6030					      SLOT	1	; this code assembles for bank #1
      1  6030				  -	      IF	(1 < 0) || (1 > 3)
      2  6030				  -	      ECHO	"Illegal bank address/segment location", 1
      3  6030				  -	      ERR
      4  6030					      ENDIF
      5  6030				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  6030				   _BANK_SLOT SET	1 * 64
      0  6030					      NEWBANK	GENMOVE2
      1  6400 ????				      SEG	GENMOVE2
      2  6400					      ORG	_ORIGIN
      3  6400					      RORG	_BANK_ADDRESS_ORIGIN
      4  6400				   _BANK_START SET	*
      5  6400				   GENMOVE2_START SET	*
      6  6400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6400				   GENMOVE2   SET	_BANK_SLOT + _CURRENT_BANK
      8  6400				   _ORIGIN    SET	_ORIGIN + 1024
      7  6400
      8  6400							;---------------------------------------------------------------------------------------------------
      9  6400
      0  6400					      CHECK_BANK_SIZE	"GENMOVE2"
      1  6400		       00 00	   .TEMP      =	* - _BANK_START
 GENMOVE2 (1K) SIZE =  $0 , FREE= $400
      2  6400					      ECHO	"GENMOVE2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  6400				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6400				  -	      ECHO	"BANK OVERFLOW @ ", "GENMOVE2", " size=", * - ORIGIN
      5  6400				  -	      ERR
      6  6400					      ENDIF
     11  6400
     12  6400							;---------------------------------------------------------------------------------------------------
     13  6400							; EOF
------- FILE ./chess.asm
    636  6400
------- FILE BANK_GENERIC@1#2.asm LEVEL 2 PASS 4
      0  6400					      include	"BANK_GENERIC@1#2.asm"
      1  6400							; Chess
      2  6400							; Copyright (c) 2019-2020 Andrew Davie
      3  6400							; andrew@taswegian.com
      4  6400
      0  6400					      SLOT	1
      1  6400				  -	      IF	(1 < 0) || (1 > 3)
      2  6400				  -	      ECHO	"Illegal bank address/segment location", 1
      3  6400				  -	      ERR
      4  6400					      ENDIF
      5  6400				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  6400				   _BANK_SLOT SET	1 * 64
      0  6400					      NEWBANK	TWO
      1  688e ????				      SEG	TWO
      2  6800					      ORG	_ORIGIN
      3  6800					      RORG	_BANK_ADDRESS_ORIGIN
      4  6800				   _BANK_START SET	*
      5  6800				   TWO_START  SET	*
      6  6800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6800				   TWO	      SET	_BANK_SLOT + _CURRENT_BANK
      8  6800				   _ORIGIN    SET	_ORIGIN + 1024
      7  6800
      8  6800
      9  6800							;---------------------------------------------------------------------------------------------------
     10  6800
     11  6800				  -	      IF	0
     12  6800				  -	      DEF	SAFE_BackupBitmaps
     13  6800				  -	      SUBROUTINE
     14  6800				  -
     15  6800				  -	      REFER	aiInCheckBackup
     16  6800				  -	      VEND	SAFE_BackupBitmaps
     17  6800				  -
     18  6800				  -	      sty	SET_BANK_RAM
     19  6800				  -	      jsr	SaveBitmap
     20  6800				  -	      rts
     21  6800					      ENDIF
     22  6800
     23  6800
     24  6800							;---------------------------------------------------------------------------------------------------
     25  6800
      0  6800					      DEF	AddMoveSlider
      1  6800				   SLOT_AddMoveSlider SET	_BANK_SLOT
      2  6800				   BANK_AddMoveSlider SET	SLOT_AddMoveSlider + _CURRENT_BANK
      3  6800				   AddMoveSlider
      4  6800				   TEMPORARY_VAR SET	Overlay
      5  6800				   TEMPORARY_OFFSET SET	0
      6  6800				   VAR_BOUNDARY_AddMoveSlider SET	TEMPORARY_OFFSET
      7  6800				   FUNCTION_NAME SET	AddMoveSlider
     27  6800					      SUBROUTINE
     28  6800
      0  6800					      REFER	Handle_BISHOP
      1  6800					      IF	VAREND_Handle_BISHOP > TEMPORARY_VAR
      2  6800				   TEMPORARY_VAR SET	VAREND_Handle_BISHOP
      3  6800					      ENDIF
      0  6800					      REFER	Handle_ROOK
      1  6800				  -	      IF	VAREND_Handle_ROOK > TEMPORARY_VAR
      2  6800				  -TEMPORARY_VAR SET	VAREND_Handle_ROOK
      3  6800					      ENDIF
      0  6800					      REFER	Handle_QUEEN
      1  6800				  -	      IF	VAREND_Handle_QUEEN > TEMPORARY_VAR
      2  6800				  -TEMPORARY_VAR SET	VAREND_Handle_QUEEN
      3  6800					      ENDIF
      0  6800					      VEND	AddMoveSlider
      1  6800				  -	      IFNCONST	AddMoveSlider
      2  6800				  -	      ECHO	"Incorrect VEND label", AddMoveSlider
      3  6800				  -	      ERR
      4  6800					      ENDIF
      5  6800		       00 b5	   VAREND_AddMoveSlider =	TEMPORARY_VAR
     33  6800
     34  6800							; add square in y register to movelist as destination (X12 format)
     35  6800							; [y]		     to square (X12)
     36  6800							; currentSquare     from square (X12)
     37  6800							; currentPiece      piece.
     38  6800							;   ENPASSANT flag set if pawn double-moving off opening rank
     39  6800							; capture	     captured piece
     40  6800
     41  6800		       a5 9d		      lda	capture
     42  6802		       d0 04		      bne	.always
     43  6804		       a5 af		      lda	__quiesceCapOnly
     44  6806		       d0 1c		      bne	.abort
     45  6808
     46  6808				   .always
     47  6808		       98		      tya
     48  6809
      0  6809					      ldy@PLY	moveIndex
      1  6809		       ac d0 f9 	      ldy	moveIndex
     50  680c		       c8		      iny
      0  680d					      sty@PLY	moveIndex
      1  680d		       8c d0 fb 	      sty	[RAM]+moveIndex
     52  6810
      0  6810					      sta@PLY	MoveTo,y
      1  6810		       99 64 fa 	      sta	[RAM]+MoveTo,y
     54  6813		       aa		      tax		; used for continuation of sliding moves
     55  6814		       a5 92		      lda	currentSquare
      0  6816					      sta@PLY	MoveFrom,y
      1  6816		       99 00 fa 	      sta	[RAM]+MoveFrom,y
     57  6819		       a5 91		      lda	currentPiece
      0  681b					      sta@PLY	MovePiece,y
      1  681b		       99 00 fb 	      sta	[RAM]+MovePiece,y
     59  681e		       a5 9d		      lda	capture
      0  6820					      sta@PLY	MoveCapture,y
      1  6820		       99 64 fb 	      sta	[RAM]+MoveCapture,y
     61  6823
     62  6823		       60		      rts
     63  6824
     64  6824		       98	   .abort     tya
     65  6825		       aa		      tax
     66  6826		       60		      rts
     67  6827
     68  6827
     69  6827							;---------------------------------------------------------------------------------------------------
     70  6827
      0  6827					      DEF	aiSpecialMoveFixup
      1  6827				   SLOT_aiSpecialMoveFixup SET	_BANK_SLOT
      2  6827				   BANK_aiSpecialMoveFixup SET	SLOT_aiSpecialMoveFixup + _CURRENT_BANK
      3  6827				   aiSpecialMoveFixup
      4  6827				   TEMPORARY_VAR SET	Overlay
      5  6827				   TEMPORARY_OFFSET SET	0
      6  6827				   VAR_BOUNDARY_aiSpecialMoveFixup SET	TEMPORARY_OFFSET
      7  6827				   FUNCTION_NAME SET	aiSpecialMoveFixup
     72  6827					      SUBROUTINE
     73  6827
      0  6827					      COMMON_VARS_ALPHABETA
      1  6827
      0  6827					      VAR	__thinkbar, 1
      1  6827		       00 a4	   __thinkbar =	TEMPORARY_VAR
      2  6827				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6827
      4  6827				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6827				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6827				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6827					      ENDIF
      8  6827				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6827				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  6827				  -	      ERR
     11  6827					      ENDIF
     12  6827					      LIST	ON
      0  6827					      VAR	__toggle, 1
      1  6827		       00 a5	   __toggle   =	TEMPORARY_VAR
      2  6827				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6827
      4  6827				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6827				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6827				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6827					      ENDIF
      8  6827				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6827				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  6827				  -	      ERR
     11  6827					      ENDIF
     12  6827					      LIST	ON
      4  6827
      0  6827					      VAR	__bestMove, 1
      1  6827		       00 a6	   __bestMove =	TEMPORARY_VAR
      2  6827				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6827
      4  6827				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6827				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6827				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6827					      ENDIF
      8  6827				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6827				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  6827				  -	      ERR
     11  6827					      ENDIF
     12  6827					      LIST	ON
      0  6827					      VAR	__alpha, 2
      1  6827		       00 a7	   __alpha    =	TEMPORARY_VAR
      2  6827				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6827
      4  6827				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6827				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6827				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6827					      ENDIF
      8  6827				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6827				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  6827				  -	      ERR
     11  6827					      ENDIF
     12  6827					      LIST	ON
      0  6827					      VAR	__beta, 2
      1  6827		       00 a9	   __beta     =	TEMPORARY_VAR
      2  6827				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6827
      4  6827				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6827				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6827				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6827					      ENDIF
      8  6827				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6827				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  6827				  -	      ERR
     11  6827					      ENDIF
     12  6827					      LIST	ON
      0  6827					      VAR	__negaMax, 2
      1  6827		       00 ab	   __negaMax  =	TEMPORARY_VAR
      2  6827				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6827
      4  6827				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6827				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6827				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6827					      ENDIF
      8  6827				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6827				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  6827				  -	      ERR
     11  6827					      ENDIF
     12  6827					      LIST	ON
      0  6827					      VAR	__value, 2
      1  6827		       00 ad	   __value    =	TEMPORARY_VAR
      2  6827				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6827
      4  6827				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6827				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6827				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6827					      ENDIF
      8  6827				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6827				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  6827				  -	      ERR
     11  6827					      ENDIF
     12  6827					      LIST	ON
     10  6827
      0  6827					      VAR	__quiesceCapOnly, 1
      1  6827		       00 af	   __quiesceCapOnly =	TEMPORARY_VAR
      2  6827				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6827
      4  6827				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6827				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6827				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6827					      ENDIF
      8  6827				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6827				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  6827				  -	      ERR
     11  6827					      ENDIF
     12  6827					      LIST	ON
     12  6827
      0  6827					      REFER	AiStateMachine
      1  6827				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  6827				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  6827					      ENDIF
      0  6827					      VEND	aiSpecialMoveFixup
      1  6827				  -	      IFNCONST	aiSpecialMoveFixup
      2  6827				  -	      ECHO	"Incorrect VEND label", aiSpecialMoveFixup
      3  6827				  -	      ERR
      4  6827					      ENDIF
      5  6827		       00 b0	   VAREND_aiSpecialMoveFixup =	TEMPORARY_VAR
     77  6827
     78  6827		       ad 84 02 	      lda	INTIM
     79  682a		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
     80  682c		       b0 01		      bcs	.cont
     81  682e		       60		      rts
     82  682f
     83  682f
     84  682f				   .cont
     85  682f
     86  682f		       20 5a f2 	      jsr	debug	;tmp
     87  6832
      0  6832					      PHASE	AI_DelayAfterPlaced
      1  6832		       a9 27		      lda	#AI_DelayAfterPlaced
      2  6834		       85 8b		      sta	aiState
     89  6836
     90  6836
     91  6836							; Special move fixup
     92  6836
     93  6836				  -	      IF	ENPASSANT_ENABLED
     94  6836				  -
     95  6836				  -			; Handle en-passant captures
     96  6836				  -			; The (dual-use) FLAG_ENPASSANT will have been cleared if it was set for a home-rank move
     97  6836				  -			; but if we're here and the flag is still set, then it's an actual en-passant CAPTURE and we
     98  6836				  -			; need to do the appropriate things...
     99  6836				  -
    100  6836				  -	      jsr	EnPassantCheck
    101  6836				  -
    102  6836					      ENDIF
    103  6836
    104  6836
    105  6836		       a5 94		      lda	currentPly
    106  6838		       85 3e		      sta	SET_BANK_RAM
    107  683a
    108  683a		       20 42 f4 	      jsr	CastleFixupDraw
    109  683d
    110  683d		       a5 85		      lda	fromX12
    111  683f		       85 80		      sta	squareToDraw
    112  6841
    113  6841		       60		      rts
    114  6842
    115  6842
    116  6842							;---------------------------------------------------------------------------------------------------
    117  6842
      0  6842					      DEF	CastleFixupDraw
      1  6842				   SLOT_CastleFixupDraw SET	_BANK_SLOT
      2  6842				   BANK_CastleFixupDraw SET	SLOT_CastleFixupDraw + _CURRENT_BANK
      3  6842				   CastleFixupDraw
      4  6842				   TEMPORARY_VAR SET	Overlay
      5  6842				   TEMPORARY_OFFSET SET	0
      6  6842				   VAR_BOUNDARY_CastleFixupDraw SET	TEMPORARY_OFFSET
      7  6842				   FUNCTION_NAME SET	CastleFixupDraw
    119  6842					      SUBROUTINE
    120  6842
      0  6842					      REFER	aiSpecialMoveFixup
      1  6842					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  6842				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  6842					      ENDIF
      0  6842					      VEND	CastleFixupDraw
      1  6842				  -	      IFNCONST	CastleFixupDraw
      2  6842				  -	      ECHO	"Incorrect VEND label", CastleFixupDraw
      3  6842				  -	      ERR
      4  6842					      ENDIF
      5  6842		       00 b0	   VAREND_CastleFixupDraw =	TEMPORARY_VAR
    123  6842
    124  6842							; fixup any castling issues
    125  6842							; at this point the king has finished his two-square march
    126  6842							; based on the finish square, we determine which rook we're interacting with
    127  6842							; and generate a 'move' for the rook to position on the other side of the king
    128  6842
    129  6842
    130  6842				  -	      IF	CASTLING_ENABLED
    131  6842				  -	      jsr	GenCastleMoveForRook
    132  6842				  -	      bcs	.phase
    133  6842					      ENDIF
    134  6842
      0  6842					      SWAP
      1  6842		       a5 95		      lda	sideToMove
      2  6844		       49 80		      eor	#SWAP_SIDE
      3  6846		       85 95		      sta	sideToMove
      4  6848
      5  6848
    136  6848		       60		      rts
    137  6849
    138  6849				   .phase
    139  6849
    140  6849							; in this siutation (castle, rook moving) we do not change sides yet!
    141  6849
      0  6849					      PHASE	AI_MoveIsSelected
      1  6849		       a9 14		      lda	#AI_MoveIsSelected
      2  684b		       85 8b		      sta	aiState
    143  684d		       60		      rts
    144  684e
    145  684e
    146  684e
    147  684e		       18 1c 5e 62 KSquare    .byte.b	24,28,94,98
    148  6852		       16 1d 5c 63 RSquareStart .byte.b	22,29,92,99
    149  6856		       19 1b 5f 61 RSquareEnd .byte.b	25,27,95,97
    150  685a
    151  685a
    152  685a							;---------------------------------------------------------------------------------------------------
    153  685a
      0  685a					      DEF	aiDrawEntireBoard
      1  685a				   SLOT_aiDrawEntireBoard SET	_BANK_SLOT
      2  685a				   BANK_aiDrawEntireBoard SET	SLOT_aiDrawEntireBoard + _CURRENT_BANK
      3  685a				   aiDrawEntireBoard
      4  685a				   TEMPORARY_VAR SET	Overlay
      5  685a				   TEMPORARY_OFFSET SET	0
      6  685a				   VAR_BOUNDARY_aiDrawEntireBoard SET	TEMPORARY_OFFSET
      7  685a				   FUNCTION_NAME SET	aiDrawEntireBoard
    155  685a					      SUBROUTINE
    156  685a
      0  685a					      REFER	AiStateMachine
      1  685a				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  685a				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  685a					      ENDIF
      0  685a					      VEND	aiDrawEntireBoard
      1  685a				  -	      IFNCONST	aiDrawEntireBoard
      2  685a				  -	      ECHO	"Incorrect VEND label", aiDrawEntireBoard
      3  685a				  -	      ERR
      4  685a					      ENDIF
      5  685a		       00 a4	   VAREND_aiDrawEntireBoard =	TEMPORARY_VAR
    159  685a
    160  685a
    161  685a		       ad 84 02 	      lda	INTIM
    162  685d		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    163  685f		       90 2c		      bcc	.exit
    164  6861
    165  6861							; We use [SLOT3] for accessing board
    166  6861
    167  6861		       a9 cc		      lda	#RAMBANK_BOARD
    168  6863		       85 3e		      sta	SET_BANK_RAM
    169  6865		       a4 80		      ldy	squareToDraw
    170  6867		       b9 15 fc 	      lda	ValidSquare,y
    171  686a		       30 1d		      bmi	.isablank2
    172  686c
    173  686c		       b9 79 fc 	      lda	Board,y
    174  686f		       f0 13		      beq	.isablank
    175  6871		       48		      pha
    176  6872		       a9 00		      lda	#BLANK
      0  6874					      sta@RAM	Board,y
      1  6874		       99 79 fe 	      sta	[RAM]+Board,y
    178  6877
    179  6877		       20 ad f0 	      jsr	CopySinglePiece	;@0
    180  687a
    181  687a		       a9 cc		      lda	#RAMBANK_BOARD
    182  687c		       85 3e		      sta	SET_BANK_RAM
    183  687e
    184  687e		       a4 80		      ldy	squareToDraw
    185  6880		       68		      pla
      0  6881					      sta@RAM	Board,y
      1  6881		       99 79 fe 	      sta	[RAM]+Board,y
    187  6884
      0  6884				   .isablank  PHASE	AI_DrawPart2
      1  6884		       a9 10		      lda	#AI_DrawPart2
      2  6886		       85 8b		      sta	aiState
    189  6888		       60		      rts
    190  6889
      0  6889				   .isablank2 PHASE	AI_DrawPart3
      1  6889		       a9 11		      lda	#AI_DrawPart3
      2  688b		       85 8b		      sta	aiState
    192  688d		       60	   .exit      rts
    193  688e
    194  688e
    195  688e							;---------------------------------------------------------------------------------------------------
    196  688e
    197  688e				  -	      IF	ENPASSANT_ENABLED
    198  688e				  -
    199  688e				  -	      DEF	EnPassantCheck
    200  688e				  -	      SUBROUTINE
    201  688e				  -
    202  688e				  -	      REFER	MakeMove
    203  688e				  -	      REFER	aiSpecialMoveFixup
    204  688e				  -	      VEND	EnPassantCheck
    205  688e				  -
    206  688e				  -			; {
    207  688e				  -			; With en-passant flag, it is essentially dual-use.
    208  688e				  -			; First, it marks if the move is *involved* somehow in an en-passant
    209  688e				  -			; if the piece has MOVED already, then it's an en-passant capture
    210  688e				  -			; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
    211  688e				  -
    212  688e				  -	      ldy	enPassantPawn	; save from previous side move
    213  688e				  -
    214  688e				  -	      ldx	#0	; (probably) NO en-passant this time
    215  688e				  -	      lda	fromPiece
    216  688e				  -	      and	#FLAG_ENPASSANT|FLAG_MOVED
    217  688e				  -	      cmp	#FLAG_ENPASSANT
    218  688e				  -	      bne	.noep	; HAS moved, or not en-passant
    219  688e				  -
    220  688e				  -	      eor	fromPiece	; clear FLAG_ENPASSANT
    221  688e				  -	      sta	fromPiece
    222  688e				  -
    223  688e				  -	      ldx	fromX12	; this IS an en-passantable opening, so record the square
    224  688e				  -.noep      stx	enPassantPawn	; capturable square for en-passant move (or none)
    225  688e				  -
    226  688e				  -			; }
    227  688e				  -
    228  688e				  -
    229  688e				  -			; Check to see if we are doing an actual en-passant capture...
    230  688e				  -
    231  688e				  -			; NOTE: If using test boards for debugging, the FLAG_MOVED flag is IMPORTANT
    232  688e				  -			;  as the en-passant will fail if the taking piece does not have this flag set correctly
    233  688e				  -
    234  688e				  -	      lda	fromPiece
    235  688e				  -	      and	#FLAG_ENPASSANT
    236  688e				  -	      beq	.notEnPassant	; not an en-passant, or it's enpassant by a MOVED piece
    237  688e				  -
    238  688e				  -
    239  688e				  -			; {
    240  688e				  -
    241  688e				  -			; Here we are the aggressor and we need to take the pawn 'en passant' fashion
    242  688e				  -			; y = the square containing the pawn to capture (i.e., previous value of 'enPassantPawn')
    243  688e				  -
    244  688e				  -			; Remove the pawn from the board and piecelist, and undraw
    245  688e				  -
    246  688e				  -	      sty	squareToDraw
    247  688e				  -	      jsr	CopySinglePiece	;@0	      ; undraw captured pawn
    248  688e				  -
    249  688e				  -	      lda	#EVAL
    250  688e				  -	      sta	SET_BANK	;@3
    251  688e				  -
    252  688e				  -	      ldy	originX12	; taken pawn's square
    253  688e				  -	      jsr	EnPassantRemovePiece
    254  688e				  -
    255  688e				  -.notEnPassant
    256  688e				  -			; }
    257  688e				  -
    258  688e				  -	      rts
    259  688e				  -
    260  688e					      ENDIF
    261  688e
    262  688e
    263  688e							;---------------------------------------------------------------------------------------------------
    264  688e
      0  688e					      CHECK_BANK_SIZE	"TWO"
      1  688e		       00 8e	   .TEMP      =	* - _BANK_START
 TWO (1K) SIZE =  $8e , FREE= $372
      2  688e					      ECHO	"TWO", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  688e				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  688e				  -	      ECHO	"BANK OVERFLOW @ ", "TWO", " size=", * - ORIGIN
      5  688e				  -	      ERR
      6  688e					      ENDIF
    266  688e
    267  688e							;---------------------------------------------------------------------------------------------------
    268  688e							;EOF
------- FILE ./chess.asm
------- FILE PIECE_HANDLER@1#1.asm LEVEL 2 PASS 4
      0  688e					      include	"PIECE_HANDLER@1#1.asm"
      0  688e					      SLOT	1
      1  688e				  -	      IF	(1 < 0) || (1 > 3)
      2  688e				  -	      ECHO	"Illegal bank address/segment location", 1
      3  688e				  -	      ERR
      4  688e					      ENDIF
      5  688e				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  688e				   _BANK_SLOT SET	1 * 64
      0  688e					      NEWBANK	PIECE_HANDLER_1
      1  6e68 ????				      SEG	PIECE_HANDLER_1
      2  6c00					      ORG	_ORIGIN
      3  6c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  6c00				   _BANK_START SET	*
      5  6c00				   PIECE_HANDLER_1_START SET	*
      6  6c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6c00				   PIECE_HANDLER_1 SET	_BANK_SLOT + _CURRENT_BANK
      8  6c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  6c00
------- FILE PIECE_PAWN.asm LEVEL 3 PASS 4
      0  6c00					      include	"PIECE_PAWN.asm"
      1  6c00							; Copyright (C)2020 Andrew Davie
      2  6c00							; Pawn move handlers
      3  6c00
      4  6c00							;---------------------------------------------------------------------------------------------------
      5  6c00							; WHITE PAWN
      6  6c00							;---------------------------------------------------------------------------------------------------
      7  6c00
      8  6c00		       00 28	   WHITE_HOME_ROW =	40	; < this, on home row
      9  6c00		       00 52	   BLACK_HOME_ROW =	82	; >= this, on home row
     10  6c00
     11  6c00							;---------------------------------------------------------------------------------------------------
     12  6c00
     13  6c00					      MAC	en_passant
     14  6c00					      SUBROUTINE
     15  6c00							; {1} = _LEFT or _RIGHT
     16  6c00
     17  6c00					      ldx	currentSquare
     18  6c00					      ldy	ValidSquare+{1},x
     19  6c00					      cpy	enPassantPawn
     20  6c00					      bne	.invalid
     21  6c00					      ldy	ValidSquare+{1}+{2},x	; en-passant endpoint must be blank
     22  6c00					      lda	Board,y
     23  6c00					      bne	.invalid
     24  6c00					      jsr	AddMove	; the MOVE will need to deal with the details of en-passant??
     25  6c00				   .invalid
     26  6c00					      ENDM
     27  6c00
     28  6c00							;---------------------------------------------------------------------------------------------------
     29  6c00
     30  6c00					      MAC	promote_pawn
     31  6c00							;SUBROUTINE
     32  6c00
     33  6c00							;{1} = BLACK or WHITE
     34  6c00
     35  6c00
     36  6c00					      sty	__temp
     37  6c00					      lda	#{1}|QUEEN
     38  6c00					      sta	currentPiece
     39  6c00					      jsr	AddMove
     40  6c00
     41  6c00					      lda	#{1}|ROOK
     42  6c00					      sta	currentPiece
     43  6c00					      ldy	__temp
     44  6c00					      jsr	AddMove
     45  6c00
     46  6c00					      lda	#{1}|BISHOP
     47  6c00					      sta	currentPiece
     48  6c00					      ldy	__temp
     49  6c00					      jsr	AddMove
     50  6c00
     51  6c00					      lda	#{1}|KNIGHT
     52  6c00					      sta	currentPiece
     53  6c00					      ldy	__temp
     54  6c00					      jsr	AddMove
     55  6c00
     56  6c00					      IF	{1} = WHITE
     57  6c00					      lda	#WHITE|WP
     58  6c00					      ENDIF
     59  6c00					      IF	{1} = BLACK
     60  6c00					      lda	#BLACK|BP
     61  6c00					      ENDIF
     62  6c00					      sta	currentPiece
     63  6c00					      ENDM
     64  6c00
     65  6c00							;---------------------------------------------------------------------------------------------------
     66  6c00
     67  6c00					      MAC	move_or_promote_pawn
     68  6c00							;SUBROUTINE
     69  6c00							; {1} = BLACK or WHITE
     70  6c00
     71  6c00					      IF	{1} = WHITE
     72  6c00					      cpy	#90	; last rank?
     73  6c00					      bcc	.standard
     74  6c00					      jsr	PromoteWhitePawn
     75  6c00					      jmp	.pMoved
     76  6c00					      ENDIF
     77  6c00
     78  6c00					      IF	{1} = BLACK
     79  6c00					      cpy	#30	; last rank?
     80  6c00					      bcs	.standard
     81  6c00					      jsr	PromoteBlackPawn
     82  6c00					      jmp	.pMoved
     83  6c00					      ENDIF
     84  6c00
     85  6c00				   .standard  jsr	AddMove	; add +1UP move
     86  6c00				   .pMoved
     87  6c00
     88  6c00					      ENDM
     89  6c00
     90  6c00							;---------------------------------------------------------------------------------------------------
     91  6c00
     92  6c00					      MAC	take
     93  6c00							;SUBROUTINE
     94  6c00							; {1} = capture square offset
     95  6c00
     96  6c00					      ldx	currentSquare
     97  6c00					      ldy	ValidSquare+{1},x
     98  6c00					      bmi	.invalid2
     99  6c00					      lda	Board,y
    100  6c00					      beq	.invalid2	; square empty
    101  6c00					      sta	capture
    102  6c00					      eor	currentPiece
    103  6c00					      bpl	.invalid	; same colour
    104  6c00
    105  6c00					      MOVE_OR_PROMOTE_PAWN	{2}
    106  6c00
    107  6c00					      jmp	.invalid2
    108  6c00				   .invalid   inc	protecting
    109  6c00				   .invalid2
    110  6c00					      ENDM
    111  6c00
    112  6c00							;---------------------------------------------------------------------------------------------------
    113  6c00
      0  6c00					      DEF	PromoteWhitePawn
      1  6c00				   SLOT_PromoteWhitePawn SET	_BANK_SLOT
      2  6c00				   BANK_PromoteWhitePawn SET	SLOT_PromoteWhitePawn + _CURRENT_BANK
      3  6c00				   PromoteWhitePawn
      4  6c00				   TEMPORARY_VAR SET	Overlay
      5  6c00				   TEMPORARY_OFFSET SET	0
      6  6c00				   VAR_BOUNDARY_PromoteWhitePawn SET	TEMPORARY_OFFSET
      7  6c00				   FUNCTION_NAME SET	PromoteWhitePawn
    115  6c00					      SUBROUTINE
    116  6c00
      0  6c00					      REFER	Handle_WHITE_PAWN
      1  6c00					      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  6c00				   TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  6c00					      ENDIF
      0  6c00					      VAR	__temp, 1
      1  6c00		       00 b5	   __temp     =	TEMPORARY_VAR
      2  6c00				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6c00
      4  6c00				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6c00				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6c00				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6c00					      ENDIF
      8  6c00				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6c00				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  6c00				  -	      ERR
     11  6c00					      ENDIF
     12  6c00					      LIST	ON
      0  6c00					      VEND	PromoteWhitePawn
      1  6c00				  -	      IFNCONST	PromoteWhitePawn
      2  6c00				  -	      ECHO	"Incorrect VEND label", PromoteWhitePawn
      3  6c00				  -	      ERR
      4  6c00					      ENDIF
      5  6c00		       00 b6	   VAREND_PromoteWhitePawn =	TEMPORARY_VAR
    120  6c00
      0  6c00					      PROMOTE_PAWN	WHITE
      1  6c00
      2  6c00
      3  6c00
      4  6c00
      5  6c00
      6  6c00		       84 b5		      sty	__temp
      7  6c02		       a9 06		      lda	#WHITE|QUEEN
      8  6c04		       85 91		      sta	currentPiece
      9  6c06		       20 33 f2 	      jsr	AddMove
     10  6c09
     11  6c09		       a9 05		      lda	#WHITE|ROOK
     12  6c0b		       85 91		      sta	currentPiece
     13  6c0d		       a4 b5		      ldy	__temp
     14  6c0f		       20 33 f2 	      jsr	AddMove
     15  6c12
     16  6c12		       a9 04		      lda	#WHITE|BISHOP
     17  6c14		       85 91		      sta	currentPiece
     18  6c16		       a4 b5		      ldy	__temp
     19  6c18		       20 33 f2 	      jsr	AddMove
     20  6c1b
     21  6c1b		       a9 03		      lda	#WHITE|KNIGHT
     22  6c1d		       85 91		      sta	currentPiece
     23  6c1f		       a4 b5		      ldy	__temp
     24  6c21		       20 33 f2 	      jsr	AddMove
     25  6c24
     26  6c24					      IF	WHITE = WHITE
     27  6c24		       a9 01		      lda	#WHITE|WP
     28  6c26					      ENDIF
     29  6c26				  -	      IF	WHITE = BLACK
     30  6c26				  -	      lda	#BLACK|BP
     31  6c26					      ENDIF
     32  6c26		       85 91		      sta	currentPiece
    122  6c28		       60		      rts
    123  6c29
    124  6c29							;---------------------------------------------------------------------------------------------------
    125  6c29
      0  6c29					      DEF	Handle_WHITE_PAWN
      1  6c29				   SLOT_Handle_WHITE_PAWN SET	_BANK_SLOT
      2  6c29				   BANK_Handle_WHITE_PAWN SET	SLOT_Handle_WHITE_PAWN + _CURRENT_BANK
      3  6c29				   Handle_WHITE_PAWN
      4  6c29				   TEMPORARY_VAR SET	Overlay
      5  6c29				   TEMPORARY_OFFSET SET	0
      6  6c29				   VAR_BOUNDARY_Handle_WHITE_PAWN SET	TEMPORARY_OFFSET
      7  6c29				   FUNCTION_NAME SET	Handle_WHITE_PAWN
    127  6c29					      SUBROUTINE
    128  6c29
      0  6c29					      REFER	GenerateAllMoves
      1  6c29					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6c29				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6c29					      ENDIF
      0  6c29					      VEND	Handle_WHITE_PAWN
      1  6c29				  -	      IFNCONST	Handle_WHITE_PAWN
      2  6c29				  -	      ECHO	"Incorrect VEND label", Handle_WHITE_PAWN
      3  6c29				  -	      ERR
      4  6c29					      ENDIF
      5  6c29		       00 b5	   VAREND_Handle_WHITE_PAWN =	TEMPORARY_VAR
    131  6c29
    132  6c29		       bc 1f fc 	      ldy	ValidSquare+_UP,x	; square above must be blank (WILL NOT EVER be off-board!)
    133  6c2c		       b9 79 fc 	      lda	Board,y
    134  6c2f		       d0 26		      bne	.pMoved	; occupied
    135  6c31		       85 9d		      sta	capture
    136  6c33
    137  6c33							; we may need to promote the pawn
    138  6c33							; All possibilites (Q/R/B/N) are added as individual moves
    139  6c33
      0  6c33					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  6c33
      2  6c33
      3  6c33
      4  6c33					      IF	WHITE = WHITE
      5  6c33		       c0 5a		      cpy	#90
      6  6c35		       90 06		      bcc	.standard
      7  6c37		       20 00 f4 	      jsr	PromoteWhitePawn
      8  6c3a		       4c 40 f4 	      jmp	.pMoved
      9  6c3d					      ENDIF
     10  6c3d
     11  6c3d				  -	      IF	WHITE = BLACK
     12  6c3d				  -	      cpy	#30
     13  6c3d				  -	      bcs	.standard
     14  6c3d				  -	      jsr	PromoteBlackPawn
     15  6c3d				  -	      jmp	.pMoved
     16  6c3d					      ENDIF
     17  6c3d
     18  6c3d		       20 33 f2    .standard  jsr	AddMove
     19  6c40				   .pMoved
     20  6c40
    141  6c40
    142  6c40							; the +2 move off the home rank...
    143  6c40
    144  6c40		       a6 92		      ldx	currentSquare
    145  6c42		       e0 28		      cpx	#WHITE_HOME_ROW
    146  6c44		       b0 11		      bcs	.pMoved	; pawn has moved so can't do +2
    147  6c46		       bc 29 fc 	      ldy	ValidSquare+_UP+_UP,x	; WILL be a valid square
    148  6c49		       b9 79 fc 	      lda	Board,y
    149  6c4c		       d0 09		      bne	.pMoved	; destination square occupied
    150  6c4e
    151  6c4e		       a5 91		      lda	currentPiece
    152  6c50		       09 20		      ora	#FLAG_ENPASSANT
    153  6c52		       85 91		      sta	currentPiece	; GENERATE en-passant opportunity
    154  6c54
    155  6c54		       20 33 f2 	      jsr	AddMove	; add the +2UP move off home row
    156  6c57
    157  6c57				   .pMoved
    158  6c57
    159  6c57							; regular captures...
    160  6c57
      0  6c57					      TAKE	_UP+_LEFT, WHITE
      1  6c57
      2  6c57
      3  6c57
      4  6c57		       a6 92		      ldx	currentSquare
      5  6c59		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      6  6c5c		       30 1d		      bmi	.invalid2
      7  6c5e		       b9 79 fc 	      lda	Board,y
      8  6c61		       f0 18		      beq	.invalid2
      9  6c63		       85 9d		      sta	capture
     10  6c65		       45 91		      eor	currentPiece
     11  6c67		       10 10		      bpl	.invalid
     12  6c69
      0  6c69					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  6c69
      2  6c69
      3  6c69
      4  6c69					      IF	WHITE = WHITE
      5  6c69		       c0 5a		      cpy	#90
      6  6c6b		       90 06		      bcc	.standard
      7  6c6d		       20 00 f4 	      jsr	PromoteWhitePawn
      8  6c70		       4c 76 f4 	      jmp	.pMoved
      9  6c73					      ENDIF
     10  6c73
     11  6c73				  -	      IF	WHITE = BLACK
     12  6c73				  -	      cpy	#30
     13  6c73				  -	      bcs	.standard
     14  6c73				  -	      jsr	PromoteBlackPawn
     15  6c73				  -	      jmp	.pMoved
     16  6c73					      ENDIF
     17  6c73
     18  6c73		       20 33 f2    .standard  jsr	AddMove
     19  6c76				   .pMoved
     20  6c76
     14  6c76
     15  6c76		       4c 7b f4 	      jmp	.invalid2
     16  6c79		       e6 a2	   .invalid   inc	protecting
     17  6c7b				   .invalid2
      0  6c7b					      TAKE	_UP+_RIGHT, WHITE
      1  6c7b
      2  6c7b
      3  6c7b
      4  6c7b		       a6 92		      ldx	currentSquare
      5  6c7d		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      6  6c80		       30 1d		      bmi	.invalid2
      7  6c82		       b9 79 fc 	      lda	Board,y
      8  6c85		       f0 18		      beq	.invalid2
      9  6c87		       85 9d		      sta	capture
     10  6c89		       45 91		      eor	currentPiece
     11  6c8b		       10 10		      bpl	.invalid
     12  6c8d
      0  6c8d					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  6c8d
      2  6c8d
      3  6c8d
      4  6c8d					      IF	WHITE = WHITE
      5  6c8d		       c0 5a		      cpy	#90
      6  6c8f		       90 06		      bcc	.standard
      7  6c91		       20 00 f4 	      jsr	PromoteWhitePawn
      8  6c94		       4c 9a f4 	      jmp	.pMoved
      9  6c97					      ENDIF
     10  6c97
     11  6c97				  -	      IF	WHITE = BLACK
     12  6c97				  -	      cpy	#30
     13  6c97				  -	      bcs	.standard
     14  6c97				  -	      jsr	PromoteBlackPawn
     15  6c97				  -	      jmp	.pMoved
     16  6c97					      ENDIF
     17  6c97
     18  6c97		       20 33 f2    .standard  jsr	AddMove
     19  6c9a				   .pMoved
     20  6c9a
     14  6c9a
     15  6c9a		       4c 9f f4 	      jmp	.invalid2
     16  6c9d		       e6 a2	   .invalid   inc	protecting
     17  6c9f				   .invalid2
    163  6c9f
    164  6c9f
    165  6c9f				  -	      IF	ENPASSANT_ENABLED
    166  6c9f				  -			; en-passant captures...
    167  6c9f				  -
    168  6c9f				  -	      lda	enPassantPawn
    169  6c9f				  -	      beq	.noEnPassant	; previous move (opponent) enpassant square?
    170  6c9f				  -
    171  6c9f				  -	      lda	currentPiece
    172  6c9f				  -	      ora	#FLAG_ENPASSANT
    173  6c9f				  -	      sta	currentPiece	; CONSUME en-passant opportunity
    174  6c9f				  -
    175  6c9f				  -	      EN_PASSANT	_LEFT, _UP
    176  6c9f				  -	      EN_PASSANT	_RIGHT, _UP
    177  6c9f				  -
    178  6c9f				  -.noEnPassant
    179  6c9f					      ENDIF
    180  6c9f
    181  6c9f		       4c b3 f1 	      jmp	MoveReturn
    182  6ca2
    183  6ca2
    184  6ca2							;---------------------------------------------------------------------------------------------------
    185  6ca2							; BLACK PAWN
    186  6ca2							;---------------------------------------------------------------------------------------------------
    187  6ca2
      0  6ca2					      DEF	PromoteBlackPawn
      1  6ca2				   SLOT_PromoteBlackPawn SET	_BANK_SLOT
      2  6ca2				   BANK_PromoteBlackPawn SET	SLOT_PromoteBlackPawn + _CURRENT_BANK
      3  6ca2				   PromoteBlackPawn
      4  6ca2				   TEMPORARY_VAR SET	Overlay
      5  6ca2				   TEMPORARY_OFFSET SET	0
      6  6ca2				   VAR_BOUNDARY_PromoteBlackPawn SET	TEMPORARY_OFFSET
      7  6ca2				   FUNCTION_NAME SET	PromoteBlackPawn
    189  6ca2					      SUBROUTINE
    190  6ca2
      0  6ca2					      REFER	Handle_BLACK_PAWN
      1  6ca2					      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  6ca2				   TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  6ca2					      ENDIF
      0  6ca2					      VAR	__temp, 1
      1  6ca2		       00 b5	   __temp     =	TEMPORARY_VAR
      2  6ca2				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6ca2
      4  6ca2				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6ca2				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6ca2				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6ca2					      ENDIF
      8  6ca2				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6ca2				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  6ca2				  -	      ERR
     11  6ca2					      ENDIF
     12  6ca2					      LIST	ON
      0  6ca2					      VEND	PromoteBlackPawn
      1  6ca2				  -	      IFNCONST	PromoteBlackPawn
      2  6ca2				  -	      ECHO	"Incorrect VEND label", PromoteBlackPawn
      3  6ca2				  -	      ERR
      4  6ca2					      ENDIF
      5  6ca2		       00 b6	   VAREND_PromoteBlackPawn =	TEMPORARY_VAR
    194  6ca2
      0  6ca2					      PROMOTE_PAWN	BLACK
      1  6ca2
      2  6ca2
      3  6ca2
      4  6ca2
      5  6ca2
      6  6ca2		       84 b5		      sty	__temp
      7  6ca4		       a9 86		      lda	#BLACK|QUEEN
      8  6ca6		       85 91		      sta	currentPiece
      9  6ca8		       20 33 f2 	      jsr	AddMove
     10  6cab
     11  6cab		       a9 85		      lda	#BLACK|ROOK
     12  6cad		       85 91		      sta	currentPiece
     13  6caf		       a4 b5		      ldy	__temp
     14  6cb1		       20 33 f2 	      jsr	AddMove
     15  6cb4
     16  6cb4		       a9 84		      lda	#BLACK|BISHOP
     17  6cb6		       85 91		      sta	currentPiece
     18  6cb8		       a4 b5		      ldy	__temp
     19  6cba		       20 33 f2 	      jsr	AddMove
     20  6cbd
     21  6cbd		       a9 83		      lda	#BLACK|KNIGHT
     22  6cbf		       85 91		      sta	currentPiece
     23  6cc1		       a4 b5		      ldy	__temp
     24  6cc3		       20 33 f2 	      jsr	AddMove
     25  6cc6
     26  6cc6				  -	      IF	BLACK = WHITE
     27  6cc6				  -	      lda	#WHITE|WP
     28  6cc6					      ENDIF
     29  6cc6					      IF	BLACK = BLACK
     30  6cc6		       a9 82		      lda	#BLACK|BP
     31  6cc8					      ENDIF
     32  6cc8		       85 91		      sta	currentPiece
    196  6cca		       60		      rts
    197  6ccb
      0  6ccb					      DEF	Handle_BLACK_PAWN
      1  6ccb				   SLOT_Handle_BLACK_PAWN SET	_BANK_SLOT
      2  6ccb				   BANK_Handle_BLACK_PAWN SET	SLOT_Handle_BLACK_PAWN + _CURRENT_BANK
      3  6ccb				   Handle_BLACK_PAWN
      4  6ccb				   TEMPORARY_VAR SET	Overlay
      5  6ccb				   TEMPORARY_OFFSET SET	0
      6  6ccb				   VAR_BOUNDARY_Handle_BLACK_PAWN SET	TEMPORARY_OFFSET
      7  6ccb				   FUNCTION_NAME SET	Handle_BLACK_PAWN
    199  6ccb					      SUBROUTINE
    200  6ccb
      0  6ccb					      REFER	GenerateAllMoves
      1  6ccb					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6ccb				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6ccb					      ENDIF
      0  6ccb					      VEND	Handle_BLACK_PAWN
      1  6ccb				  -	      IFNCONST	Handle_BLACK_PAWN
      2  6ccb				  -	      ECHO	"Incorrect VEND label", Handle_BLACK_PAWN
      3  6ccb				  -	      ERR
      4  6ccb					      ENDIF
      5  6ccb		       00 b5	   VAREND_Handle_BLACK_PAWN =	TEMPORARY_VAR
    203  6ccb
    204  6ccb		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x	; square below must be blank (WILL NOT EVER be off-board!)
    205  6cce		       b9 79 fc 	      lda	Board,y
    206  6cd1		       d0 26		      bne	.pMoved	; occupied
    207  6cd3		       85 9d		      sta	capture
    208  6cd5
    209  6cd5							; we may need to promote the pawn
    210  6cd5							; All possibilites (Q/R/B/N) are added as individual moves
    211  6cd5
      0  6cd5					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  6cd5
      2  6cd5
      3  6cd5
      4  6cd5				  -	      IF	BLACK = WHITE
      5  6cd5				  -	      cpy	#90
      6  6cd5				  -	      bcc	.standard
      7  6cd5				  -	      jsr	PromoteWhitePawn
      8  6cd5				  -	      jmp	.pMoved
      9  6cd5					      ENDIF
     10  6cd5
     11  6cd5					      IF	BLACK = BLACK
     12  6cd5		       c0 1e		      cpy	#30
     13  6cd7		       b0 06		      bcs	.standard
     14  6cd9		       20 a2 f4 	      jsr	PromoteBlackPawn
     15  6cdc		       4c e2 f4 	      jmp	.pMoved
     16  6cdf					      ENDIF
     17  6cdf
     18  6cdf		       20 33 f2    .standard  jsr	AddMove
     19  6ce2				   .pMoved
     20  6ce2
    213  6ce2
    214  6ce2							; the +2 move off the home rank...
    215  6ce2
    216  6ce2		       a6 92		      ldx	currentSquare
    217  6ce4		       e0 52		      cpx	#BLACK_HOME_ROW
    218  6ce6		       90 11		      bcc	.pMoved	; pawn has moved so can't do +2
    219  6ce8
    220  6ce8
    221  6ce8		       bc 01 fc 	      ldy	ValidSquare+_DOWN+_DOWN,x	; WILL be a valid square
    222  6ceb		       b9 79 fc 	      lda	Board,y
    223  6cee		       d0 09		      bne	.pMoved	; destination square occupied
    224  6cf0
    225  6cf0		       a5 91		      lda	currentPiece
    226  6cf2		       09 20		      ora	#FLAG_ENPASSANT
    227  6cf4		       85 91		      sta	currentPiece	; CAN en-passant
    228  6cf6
    229  6cf6		       20 33 f2 	      jsr	AddMove	; add the +2DOWN move off home row
    230  6cf9
    231  6cf9				   .pMoved
    232  6cf9
    233  6cf9							; regular captures... (with promotion)
    234  6cf9
      0  6cf9					      TAKE	_DOWN+_LEFT, BLACK
      1  6cf9
      2  6cf9
      3  6cf9
      4  6cf9		       a6 92		      ldx	currentSquare
      5  6cfb		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      6  6cfe		       30 1d		      bmi	.invalid2
      7  6d00		       b9 79 fc 	      lda	Board,y
      8  6d03		       f0 18		      beq	.invalid2
      9  6d05		       85 9d		      sta	capture
     10  6d07		       45 91		      eor	currentPiece
     11  6d09		       10 10		      bpl	.invalid
     12  6d0b
      0  6d0b					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  6d0b
      2  6d0b
      3  6d0b
      4  6d0b				  -	      IF	BLACK = WHITE
      5  6d0b				  -	      cpy	#90
      6  6d0b				  -	      bcc	.standard
      7  6d0b				  -	      jsr	PromoteWhitePawn
      8  6d0b				  -	      jmp	.pMoved
      9  6d0b					      ENDIF
     10  6d0b
     11  6d0b					      IF	BLACK = BLACK
     12  6d0b		       c0 1e		      cpy	#30
     13  6d0d		       b0 06		      bcs	.standard
     14  6d0f		       20 a2 f4 	      jsr	PromoteBlackPawn
     15  6d12		       4c 18 f5 	      jmp	.pMoved
     16  6d15					      ENDIF
     17  6d15
     18  6d15		       20 33 f2    .standard  jsr	AddMove
     19  6d18				   .pMoved
     20  6d18
     14  6d18
     15  6d18		       4c 1d f5 	      jmp	.invalid2
     16  6d1b		       e6 a2	   .invalid   inc	protecting
     17  6d1d				   .invalid2
      0  6d1d					      TAKE	_DOWN+_RIGHT, BLACK
      1  6d1d
      2  6d1d
      3  6d1d
      4  6d1d		       a6 92		      ldx	currentSquare
      5  6d1f		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      6  6d22		       30 1d		      bmi	.invalid2
      7  6d24		       b9 79 fc 	      lda	Board,y
      8  6d27		       f0 18		      beq	.invalid2
      9  6d29		       85 9d		      sta	capture
     10  6d2b		       45 91		      eor	currentPiece
     11  6d2d		       10 10		      bpl	.invalid
     12  6d2f
      0  6d2f					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  6d2f
      2  6d2f
      3  6d2f
      4  6d2f				  -	      IF	BLACK = WHITE
      5  6d2f				  -	      cpy	#90
      6  6d2f				  -	      bcc	.standard
      7  6d2f				  -	      jsr	PromoteWhitePawn
      8  6d2f				  -	      jmp	.pMoved
      9  6d2f					      ENDIF
     10  6d2f
     11  6d2f					      IF	BLACK = BLACK
     12  6d2f		       c0 1e		      cpy	#30
     13  6d31		       b0 06		      bcs	.standard
     14  6d33		       20 a2 f4 	      jsr	PromoteBlackPawn
     15  6d36		       4c 3c f5 	      jmp	.pMoved
     16  6d39					      ENDIF
     17  6d39
     18  6d39		       20 33 f2    .standard  jsr	AddMove
     19  6d3c				   .pMoved
     20  6d3c
     14  6d3c
     15  6d3c		       4c 41 f5 	      jmp	.invalid2
     16  6d3f		       e6 a2	   .invalid   inc	protecting
     17  6d41				   .invalid2
    237  6d41
    238  6d41
    239  6d41				  -	      IF	ENPASSANT_ENABLED
    240  6d41				  -			; en-passant captures...
    241  6d41				  -
    242  6d41				  -	      lda	enPassantPawn
    243  6d41				  -	      beq	.noEnPassant	; was last move en-passantable?
    244  6d41				  -
    245  6d41				  -	      lda	currentPiece
    246  6d41				  -	      ora	#FLAG_ENPASSANT
    247  6d41				  -	      sta	currentPiece	; any en-passant move added will have flag set
    248  6d41				  -
    249  6d41				  -	      EN_PASSANT	_LEFT, _DOWN
    250  6d41				  -	      EN_PASSANT	_RIGHT, _DOWN
    251  6d41				  -
    252  6d41				  -.noEnPassant
    253  6d41					      ENDIF
    254  6d41
    255  6d41		       4c b3 f1 	      jmp	MoveReturn
    256  6d44
    257  6d44							; EOF
------- FILE PIECE_HANDLER@1#1.asm
------- FILE PIECE_KNIGHT.asm LEVEL 3 PASS 4
      0  6d44					      include	"PIECE_KNIGHT.asm"
      1  6d44							; Copyright (C)2020 Andrew Davie
      2  6d44							; Knight move handler
      3  6d44
      4  6d44							;---------------------------------------------------------------------------------------------------
      5  6d44							; KNIGHT
      6  6d44							;---------------------------------------------------------------------------------------------------
      7  6d44
      0  6d44					      DEF	Handle_KNIGHT
      1  6d44				   SLOT_Handle_KNIGHT SET	_BANK_SLOT
      2  6d44				   BANK_Handle_KNIGHT SET	SLOT_Handle_KNIGHT + _CURRENT_BANK
      3  6d44				   Handle_KNIGHT
      4  6d44				   TEMPORARY_VAR SET	Overlay
      5  6d44				   TEMPORARY_OFFSET SET	0
      6  6d44				   VAR_BOUNDARY_Handle_KNIGHT SET	TEMPORARY_OFFSET
      7  6d44				   FUNCTION_NAME SET	Handle_KNIGHT
      9  6d44					      SUBROUTINE
     10  6d44
      0  6d44					      REFER	GenerateAllMoves
      1  6d44					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6d44				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6d44					      ENDIF
      0  6d44					      VEND	Handle_KNIGHT
      1  6d44				  -	      IFNCONST	Handle_KNIGHT
      2  6d44				  -	      ECHO	"Incorrect VEND label", Handle_KNIGHT
      3  6d44				  -	      ERR
      4  6d44					      ENDIF
      5  6d44		       00 b5	   VAREND_Handle_KNIGHT =	TEMPORARY_VAR
     13  6d44
     14  6d44							; x = currentSquare (square the piece is on)
     15  6d44							; currentPiece (with flags/colour attached)
     16  6d44
      0  6d44					      MOVE_TO	_DOWN+_DOWN+_LEFT
      1  6d44					      SUBROUTINE
      2  6d44		       bc 00 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_LEFT,x
      3  6d47		       30 0e		      bmi	.invalid
      4  6d49		       b9 79 fc 	      lda	Board,y
      5  6d4c		       85 9d		      sta	capture
      6  6d4e		       f0 04		      beq	.squareEmpty
      7  6d50		       45 91		      eor	currentPiece
      8  6d52		       10 03		      bpl	.invalid
      9  6d54		       20 33 f2    .squareEmpty jsr	AddMove
     10  6d57				   .invalid
      0  6d57					      MOVE_TO_X	_DOWN+_DOWN+_RIGHT
      1  6d57		       a6 92		      ldx	currentSquare
      0  6d59					      MOVE_TO	_DOWN+_DOWN+_RIGHT
      1  6d59					      SUBROUTINE
      2  6d59		       bc 02 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_RIGHT,x
      3  6d5c		       30 0e		      bmi	.invalid
      4  6d5e		       b9 79 fc 	      lda	Board,y
      5  6d61		       85 9d		      sta	capture
      6  6d63		       f0 04		      beq	.squareEmpty
      7  6d65		       45 91		      eor	currentPiece
      8  6d67		       10 03		      bpl	.invalid
      9  6d69		       20 33 f2    .squareEmpty jsr	AddMove
     10  6d6c				   .invalid
      0  6d6c					      MOVE_TO_X	_UP+_UP+_LEFT
      1  6d6c		       a6 92		      ldx	currentSquare
      0  6d6e					      MOVE_TO	_UP+_UP+_LEFT
      1  6d6e					      SUBROUTINE
      2  6d6e		       bc 28 fc 	      ldy	ValidSquare+_UP+_UP+_LEFT,x
      3  6d71		       30 0e		      bmi	.invalid
      4  6d73		       b9 79 fc 	      lda	Board,y
      5  6d76		       85 9d		      sta	capture
      6  6d78		       f0 04		      beq	.squareEmpty
      7  6d7a		       45 91		      eor	currentPiece
      8  6d7c		       10 03		      bpl	.invalid
      9  6d7e		       20 33 f2    .squareEmpty jsr	AddMove
     10  6d81				   .invalid
      0  6d81					      MOVE_TO_X	_UP+_UP+_RIGHT
      1  6d81		       a6 92		      ldx	currentSquare
      0  6d83					      MOVE_TO	_UP+_UP+_RIGHT
      1  6d83					      SUBROUTINE
      2  6d83		       bc 2a fc 	      ldy	ValidSquare+_UP+_UP+_RIGHT,x
      3  6d86		       30 0e		      bmi	.invalid
      4  6d88		       b9 79 fc 	      lda	Board,y
      5  6d8b		       85 9d		      sta	capture
      6  6d8d		       f0 04		      beq	.squareEmpty
      7  6d8f		       45 91		      eor	currentPiece
      8  6d91		       10 03		      bpl	.invalid
      9  6d93		       20 33 f2    .squareEmpty jsr	AddMove
     10  6d96				   .invalid
     21  6d96
      0  6d96					      MOVE_TO_X	_DOWN+_LEFT+_LEFT
      1  6d96		       a6 92		      ldx	currentSquare
      0  6d98					      MOVE_TO	_DOWN+_LEFT+_LEFT
      1  6d98					      SUBROUTINE
      2  6d98		       bc 09 fc 	      ldy	ValidSquare+_DOWN+_LEFT+_LEFT,x
      3  6d9b		       30 0e		      bmi	.invalid
      4  6d9d		       b9 79 fc 	      lda	Board,y
      5  6da0		       85 9d		      sta	capture
      6  6da2		       f0 04		      beq	.squareEmpty
      7  6da4		       45 91		      eor	currentPiece
      8  6da6		       10 03		      bpl	.invalid
      9  6da8		       20 33 f2    .squareEmpty jsr	AddMove
     10  6dab				   .invalid
      0  6dab					      MOVE_TO_X	_DOWN+_RIGHT+_RIGHT
      1  6dab		       a6 92		      ldx	currentSquare
      0  6dad					      MOVE_TO	_DOWN+_RIGHT+_RIGHT
      1  6dad					      SUBROUTINE
      2  6dad		       bc 0d fc 	      ldy	ValidSquare+_DOWN+_RIGHT+_RIGHT,x
      3  6db0		       30 0e		      bmi	.invalid
      4  6db2		       b9 79 fc 	      lda	Board,y
      5  6db5		       85 9d		      sta	capture
      6  6db7		       f0 04		      beq	.squareEmpty
      7  6db9		       45 91		      eor	currentPiece
      8  6dbb		       10 03		      bpl	.invalid
      9  6dbd		       20 33 f2    .squareEmpty jsr	AddMove
     10  6dc0				   .invalid
      0  6dc0					      MOVE_TO_X	_UP+_LEFT+_LEFT
      1  6dc0		       a6 92		      ldx	currentSquare
      0  6dc2					      MOVE_TO	_UP+_LEFT+_LEFT
      1  6dc2					      SUBROUTINE
      2  6dc2		       bc 1d fc 	      ldy	ValidSquare+_UP+_LEFT+_LEFT,x
      3  6dc5		       30 0e		      bmi	.invalid
      4  6dc7		       b9 79 fc 	      lda	Board,y
      5  6dca		       85 9d		      sta	capture
      6  6dcc		       f0 04		      beq	.squareEmpty
      7  6dce		       45 91		      eor	currentPiece
      8  6dd0		       10 03		      bpl	.invalid
      9  6dd2		       20 33 f2    .squareEmpty jsr	AddMove
     10  6dd5				   .invalid
      0  6dd5					      MOVE_TO_X	_UP+_RIGHT+_RIGHT
      1  6dd5		       a6 92		      ldx	currentSquare
      0  6dd7					      MOVE_TO	_UP+_RIGHT+_RIGHT
      1  6dd7					      SUBROUTINE
      2  6dd7		       bc 21 fc 	      ldy	ValidSquare+_UP+_RIGHT+_RIGHT,x
      3  6dda		       30 0e		      bmi	.invalid
      4  6ddc		       b9 79 fc 	      lda	Board,y
      5  6ddf		       85 9d		      sta	capture
      6  6de1		       f0 04		      beq	.squareEmpty
      7  6de3		       45 91		      eor	currentPiece
      8  6de5		       10 03		      bpl	.invalid
      9  6de7		       20 33 f2    .squareEmpty jsr	AddMove
     10  6dea				   .invalid
     26  6dea
     27  6dea		       4c b3 f1 	      jmp	MoveReturn
     28  6ded
     29  6ded							; EOF
------- FILE PIECE_HANDLER@1#1.asm
------- FILE PIECE_BISHOP.asm LEVEL 3 PASS 4
      0  6ded					      include	"PIECE_BISHOP.asm"
      1  6ded							; Copyright (C)2020 Andrew Davie
      2  6ded
      3  6ded							;---------------------------------------------------------------------------------------------------
      4  6ded							; BISHOP
      5  6ded							;---------------------------------------------------------------------------------------------------
      6  6ded
      0  6ded					      DEF	Handle_BISHOP
      1  6ded				   SLOT_Handle_BISHOP SET	_BANK_SLOT
      2  6ded				   BANK_Handle_BISHOP SET	SLOT_Handle_BISHOP + _CURRENT_BANK
      3  6ded				   Handle_BISHOP
      4  6ded				   TEMPORARY_VAR SET	Overlay
      5  6ded				   TEMPORARY_OFFSET SET	0
      6  6ded				   VAR_BOUNDARY_Handle_BISHOP SET	TEMPORARY_OFFSET
      7  6ded				   FUNCTION_NAME SET	Handle_BISHOP
      8  6ded					      SUBROUTINE
      9  6ded
      0  6ded					      REFER	GenerateAllMoves
      1  6ded					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6ded				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6ded					      ENDIF
      0  6ded					      VEND	Handle_BISHOP
      1  6ded				  -	      IFNCONST	Handle_BISHOP
      2  6ded				  -	      ECHO	"Incorrect VEND label", Handle_BISHOP
      3  6ded				  -	      ERR
      4  6ded					      ENDIF
      5  6ded		       00 b5	   VAREND_Handle_BISHOP =	TEMPORARY_VAR
     12  6ded
     13  6ded							; x = currentSquare (square the piece is on)
     14  6ded							; currentPiece (with flags/colour attached)
     15  6ded
      0  6ded					      MOVE_TOWARDS	_DOWN+_LEFT
      1  6ded					      SUBROUTINE
      2  6ded
      3  6ded
      4  6ded
      5  6ded		       a9 00		      lda	#0
      6  6def		       85 9d		      sta	capture
      7  6df1
      8  6df1		       a6 92		      ldx	currentSquare
      9  6df3		       d0 03		      bne	.project
     10  6df5
     11  6df5		       20 33 f2    .empty     jsr	AddMove
     12  6df8		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  6dfb		       30 0e		      bmi	.invalid
     14  6dfd		       b9 79 fc 	      lda	Board,y
     15  6e00		       f0 f3		      beq	.empty
     16  6e02		       85 9d		      sta	capture
     17  6e04		       45 91		      eor	currentPiece
     18  6e06		       10 03		      bpl	.invalid
     19  6e08		       20 33 f2 	      jsr	AddMove
     20  6e0b
     21  6e0b				   .invalid
      0  6e0b					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  6e0b					      SUBROUTINE
      2  6e0b
      3  6e0b
      4  6e0b
      5  6e0b		       a9 00		      lda	#0
      6  6e0d		       85 9d		      sta	capture
      7  6e0f
      8  6e0f		       a6 92		      ldx	currentSquare
      9  6e11		       d0 03		      bne	.project
     10  6e13
     11  6e13		       20 33 f2    .empty     jsr	AddMove
     12  6e16		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  6e19		       30 0e		      bmi	.invalid
     14  6e1b		       b9 79 fc 	      lda	Board,y
     15  6e1e		       f0 f3		      beq	.empty
     16  6e20		       85 9d		      sta	capture
     17  6e22		       45 91		      eor	currentPiece
     18  6e24		       10 03		      bpl	.invalid
     19  6e26		       20 33 f2 	      jsr	AddMove
     20  6e29
     21  6e29				   .invalid
      0  6e29					      MOVE_TOWARDS	_UP+_LEFT
      1  6e29					      SUBROUTINE
      2  6e29
      3  6e29
      4  6e29
      5  6e29		       a9 00		      lda	#0
      6  6e2b		       85 9d		      sta	capture
      7  6e2d
      8  6e2d		       a6 92		      ldx	currentSquare
      9  6e2f		       d0 03		      bne	.project
     10  6e31
     11  6e31		       20 33 f2    .empty     jsr	AddMove
     12  6e34		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  6e37		       30 0e		      bmi	.invalid
     14  6e39		       b9 79 fc 	      lda	Board,y
     15  6e3c		       f0 f3		      beq	.empty
     16  6e3e		       85 9d		      sta	capture
     17  6e40		       45 91		      eor	currentPiece
     18  6e42		       10 03		      bpl	.invalid
     19  6e44		       20 33 f2 	      jsr	AddMove
     20  6e47
     21  6e47				   .invalid
      0  6e47					      MOVE_TOWARDS	_UP+_RIGHT
      1  6e47					      SUBROUTINE
      2  6e47
      3  6e47
      4  6e47
      5  6e47		       a9 00		      lda	#0
      6  6e49		       85 9d		      sta	capture
      7  6e4b
      8  6e4b		       a6 92		      ldx	currentSquare
      9  6e4d		       d0 03		      bne	.project
     10  6e4f
     11  6e4f		       20 33 f2    .empty     jsr	AddMove
     12  6e52		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  6e55		       30 0e		      bmi	.invalid
     14  6e57		       b9 79 fc 	      lda	Board,y
     15  6e5a		       f0 f3		      beq	.empty
     16  6e5c		       85 9d		      sta	capture
     17  6e5e		       45 91		      eor	currentPiece
     18  6e60		       10 03		      bpl	.invalid
     19  6e62		       20 33 f2 	      jsr	AddMove
     20  6e65
     21  6e65				   .invalid
     20  6e65
     21  6e65		       4c b3 f1 	      jmp	MoveReturn
     22  6e68
     23  6e68							;---------------------------------------------------------------------------------------------------
     24  6e68							; EOF
------- FILE PIECE_HANDLER@1#1.asm
      7  6e68
      8  6e68							;---------------------------------------------------------------------------------------------------
      9  6e68
      0  6e68					      CHECK_BANK_SIZE	"PIECE_HANDLER_1"
      1  6e68		       02 68	   .TEMP      =	* - _BANK_START
 PIECE_HANDLER_1 (1K) SIZE =  $268 , FREE= $198
      2  6e68					      ECHO	"PIECE_HANDLER_1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  6e68				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6e68				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_HANDLER_1", " size=", * - ORIGIN
      5  6e68				  -	      ERR
      6  6e68					      ENDIF
     11  6e68
     12  6e68							;---------------------------------------------------------------------------------------------------
     13  6e68							; EOF
------- FILE ./chess.asm
------- FILE PIECE_HANDLER@1#2.asm LEVEL 2 PASS 4
      0  6e68					      include	"PIECE_HANDLER@1#2.asm"
      0  6e68					      SLOT	1
      1  6e68				  -	      IF	(1 < 0) || (1 > 3)
      2  6e68				  -	      ECHO	"Illegal bank address/segment location", 1
      3  6e68				  -	      ERR
      4  6e68					      ENDIF
      5  6e68				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  6e68				   _BANK_SLOT SET	1 * 64
      0  6e68					      NEWBANK	PIECE_HANDLER_2
      1  725c ????				      SEG	PIECE_HANDLER_2
      2  7000					      ORG	_ORIGIN
      3  7000					      RORG	_BANK_ADDRESS_ORIGIN
      4  7000				   _BANK_START SET	*
      5  7000				   PIECE_HANDLER_2_START SET	*
      6  7000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7000				   PIECE_HANDLER_2 SET	_BANK_SLOT + _CURRENT_BANK
      8  7000				   _ORIGIN    SET	_ORIGIN + 1024
      3  7000
------- FILE PIECE_ROOK.asm LEVEL 3 PASS 4
      0  7000					      include	"PIECE_ROOK.asm"
      1  7000							; Copyright (C)2020 Andrew Davie
      2  7000							; Rook move handler
      3  7000
      4  7000							;---------------------------------------------------------------------------------------------------
      5  7000							; ROOK
      6  7000							;---------------------------------------------------------------------------------------------------
      7  7000
      0  7000					      DEF	Handle_ROOK
      1  7000				   SLOT_Handle_ROOK SET	_BANK_SLOT
      2  7000				   BANK_Handle_ROOK SET	SLOT_Handle_ROOK + _CURRENT_BANK
      3  7000				   Handle_ROOK
      4  7000				   TEMPORARY_VAR SET	Overlay
      5  7000				   TEMPORARY_OFFSET SET	0
      6  7000				   VAR_BOUNDARY_Handle_ROOK SET	TEMPORARY_OFFSET
      7  7000				   FUNCTION_NAME SET	Handle_ROOK
      9  7000					      SUBROUTINE
     10  7000
      0  7000					      REFER	GenerateAllMoves
      1  7000					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  7000				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  7000					      ENDIF
      0  7000					      VEND	Handle_ROOK
      1  7000				  -	      IFNCONST	Handle_ROOK
      2  7000				  -	      ECHO	"Incorrect VEND label", Handle_ROOK
      3  7000				  -	      ERR
      4  7000					      ENDIF
      5  7000		       00 b5	   VAREND_Handle_ROOK =	TEMPORARY_VAR
     13  7000
     14  7000							; Pass...
     15  7000							; x = currentSquare (square the piece is on)
     16  7000							; currentPiece (with flags/colour attached)
     17  7000
      0  7000					      MOVE_TOWARDS	_DOWN
      1  7000					      SUBROUTINE
      2  7000
      3  7000
      4  7000
      5  7000		       a9 00		      lda	#0
      6  7002		       85 9d		      sta	capture
      7  7004
      8  7004		       a6 92		      ldx	currentSquare
      9  7006		       d0 03		      bne	.project
     10  7008
     11  7008		       20 33 f2    .empty     jsr	AddMove
     12  700b		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  700e		       30 0e		      bmi	.invalid
     14  7010		       b9 79 fc 	      lda	Board,y
     15  7013		       f0 f3		      beq	.empty
     16  7015		       85 9d		      sta	capture
     17  7017		       45 91		      eor	currentPiece
     18  7019		       10 03		      bpl	.invalid
     19  701b		       20 33 f2 	      jsr	AddMove
     20  701e
     21  701e				   .invalid
      0  701e					      MOVE_TOWARDS	_RIGHT
      1  701e					      SUBROUTINE
      2  701e
      3  701e
      4  701e
      5  701e		       a9 00		      lda	#0
      6  7020		       85 9d		      sta	capture
      7  7022
      8  7022		       a6 92		      ldx	currentSquare
      9  7024		       d0 03		      bne	.project
     10  7026
     11  7026		       20 33 f2    .empty     jsr	AddMove
     12  7029		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  702c		       30 0e		      bmi	.invalid
     14  702e		       b9 79 fc 	      lda	Board,y
     15  7031		       f0 f3		      beq	.empty
     16  7033		       85 9d		      sta	capture
     17  7035		       45 91		      eor	currentPiece
     18  7037		       10 03		      bpl	.invalid
     19  7039		       20 33 f2 	      jsr	AddMove
     20  703c
     21  703c				   .invalid
      0  703c					      MOVE_TOWARDS	_UP
      1  703c					      SUBROUTINE
      2  703c
      3  703c
      4  703c
      5  703c		       a9 00		      lda	#0
      6  703e		       85 9d		      sta	capture
      7  7040
      8  7040		       a6 92		      ldx	currentSquare
      9  7042		       d0 03		      bne	.project
     10  7044
     11  7044		       20 33 f2    .empty     jsr	AddMove
     12  7047		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  704a		       30 0e		      bmi	.invalid
     14  704c		       b9 79 fc 	      lda	Board,y
     15  704f		       f0 f3		      beq	.empty
     16  7051		       85 9d		      sta	capture
     17  7053		       45 91		      eor	currentPiece
     18  7055		       10 03		      bpl	.invalid
     19  7057		       20 33 f2 	      jsr	AddMove
     20  705a
     21  705a				   .invalid
      0  705a					      MOVE_TOWARDS	_LEFT
      1  705a					      SUBROUTINE
      2  705a
      3  705a
      4  705a
      5  705a		       a9 00		      lda	#0
      6  705c		       85 9d		      sta	capture
      7  705e
      8  705e		       a6 92		      ldx	currentSquare
      9  7060		       d0 03		      bne	.project
     10  7062
     11  7062		       20 33 f2    .empty     jsr	AddMove
     12  7065		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  7068		       30 0e		      bmi	.invalid
     14  706a		       b9 79 fc 	      lda	Board,y
     15  706d		       f0 f3		      beq	.empty
     16  706f		       85 9d		      sta	capture
     17  7071		       45 91		      eor	currentPiece
     18  7073		       10 03		      bpl	.invalid
     19  7075		       20 33 f2 	      jsr	AddMove
     20  7078
     21  7078				   .invalid
     22  7078
     23  7078		       4c b3 f1 	      jmp	MoveReturn
     24  707b
     25  707b							;---------------------------------------------------------------------------------------------------
     26  707b							; EOF
------- FILE PIECE_HANDLER@1#2.asm
------- FILE PIECE_QUEEN.asm LEVEL 3 PASS 4
      0  707b					      include	"PIECE_QUEEN.asm"
      1  707b							; Copyright (C)2020 Andrew Davie
      2  707b
      3  707b							;---------------------------------------------------------------------------------------------------
      4  707b							; QUEEN
      5  707b							;---------------------------------------------------------------------------------------------------
      6  707b
      0  707b					      DEF	Handle_QUEEN
      1  707b				   SLOT_Handle_QUEEN SET	_BANK_SLOT
      2  707b				   BANK_Handle_QUEEN SET	SLOT_Handle_QUEEN + _CURRENT_BANK
      3  707b				   Handle_QUEEN
      4  707b				   TEMPORARY_VAR SET	Overlay
      5  707b				   TEMPORARY_OFFSET SET	0
      6  707b				   VAR_BOUNDARY_Handle_QUEEN SET	TEMPORARY_OFFSET
      7  707b				   FUNCTION_NAME SET	Handle_QUEEN
      8  707b					      SUBROUTINE
      9  707b
      0  707b					      REFER	GenerateAllMoves
      1  707b					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  707b				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  707b					      ENDIF
      0  707b					      VEND	Handle_QUEEN
      1  707b				  -	      IFNCONST	Handle_QUEEN
      2  707b				  -	      ECHO	"Incorrect VEND label", Handle_QUEEN
      3  707b				  -	      ERR
      4  707b					      ENDIF
      5  707b		       00 b5	   VAREND_Handle_QUEEN =	TEMPORARY_VAR
     12  707b
     13  707b							; Pass...
     14  707b							; x = currentSquare (square the piece is on)
     15  707b							; currentPiece (with flags/colour attached)
     16  707b
      0  707b					      MOVE_TOWARDS	_DOWN+_LEFT
      1  707b					      SUBROUTINE
      2  707b
      3  707b
      4  707b
      5  707b		       a9 00		      lda	#0
      6  707d		       85 9d		      sta	capture
      7  707f
      8  707f		       a6 92		      ldx	currentSquare
      9  7081		       d0 03		      bne	.project
     10  7083
     11  7083		       20 33 f2    .empty     jsr	AddMove
     12  7086		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  7089		       30 0e		      bmi	.invalid
     14  708b		       b9 79 fc 	      lda	Board,y
     15  708e		       f0 f3		      beq	.empty
     16  7090		       85 9d		      sta	capture
     17  7092		       45 91		      eor	currentPiece
     18  7094		       10 03		      bpl	.invalid
     19  7096		       20 33 f2 	      jsr	AddMove
     20  7099
     21  7099				   .invalid
      0  7099					      MOVE_TOWARDS	_DOWN
      1  7099					      SUBROUTINE
      2  7099
      3  7099
      4  7099
      5  7099		       a9 00		      lda	#0
      6  709b		       85 9d		      sta	capture
      7  709d
      8  709d		       a6 92		      ldx	currentSquare
      9  709f		       d0 03		      bne	.project
     10  70a1
     11  70a1		       20 33 f2    .empty     jsr	AddMove
     12  70a4		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  70a7		       30 0e		      bmi	.invalid
     14  70a9		       b9 79 fc 	      lda	Board,y
     15  70ac		       f0 f3		      beq	.empty
     16  70ae		       85 9d		      sta	capture
     17  70b0		       45 91		      eor	currentPiece
     18  70b2		       10 03		      bpl	.invalid
     19  70b4		       20 33 f2 	      jsr	AddMove
     20  70b7
     21  70b7				   .invalid
      0  70b7					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  70b7					      SUBROUTINE
      2  70b7
      3  70b7
      4  70b7
      5  70b7		       a9 00		      lda	#0
      6  70b9		       85 9d		      sta	capture
      7  70bb
      8  70bb		       a6 92		      ldx	currentSquare
      9  70bd		       d0 03		      bne	.project
     10  70bf
     11  70bf		       20 33 f2    .empty     jsr	AddMove
     12  70c2		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  70c5		       30 0e		      bmi	.invalid
     14  70c7		       b9 79 fc 	      lda	Board,y
     15  70ca		       f0 f3		      beq	.empty
     16  70cc		       85 9d		      sta	capture
     17  70ce		       45 91		      eor	currentPiece
     18  70d0		       10 03		      bpl	.invalid
     19  70d2		       20 33 f2 	      jsr	AddMove
     20  70d5
     21  70d5				   .invalid
      0  70d5					      MOVE_TOWARDS	_RIGHT
      1  70d5					      SUBROUTINE
      2  70d5
      3  70d5
      4  70d5
      5  70d5		       a9 00		      lda	#0
      6  70d7		       85 9d		      sta	capture
      7  70d9
      8  70d9		       a6 92		      ldx	currentSquare
      9  70db		       d0 03		      bne	.project
     10  70dd
     11  70dd		       20 33 f2    .empty     jsr	AddMove
     12  70e0		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  70e3		       30 0e		      bmi	.invalid
     14  70e5		       b9 79 fc 	      lda	Board,y
     15  70e8		       f0 f3		      beq	.empty
     16  70ea		       85 9d		      sta	capture
     17  70ec		       45 91		      eor	currentPiece
     18  70ee		       10 03		      bpl	.invalid
     19  70f0		       20 33 f2 	      jsr	AddMove
     20  70f3
     21  70f3				   .invalid
      0  70f3					      MOVE_TOWARDS	_UP+_RIGHT
      1  70f3					      SUBROUTINE
      2  70f3
      3  70f3
      4  70f3
      5  70f3		       a9 00		      lda	#0
      6  70f5		       85 9d		      sta	capture
      7  70f7
      8  70f7		       a6 92		      ldx	currentSquare
      9  70f9		       d0 03		      bne	.project
     10  70fb
     11  70fb		       20 33 f2    .empty     jsr	AddMove
     12  70fe		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  7101		       30 0e		      bmi	.invalid
     14  7103		       b9 79 fc 	      lda	Board,y
     15  7106		       f0 f3		      beq	.empty
     16  7108		       85 9d		      sta	capture
     17  710a		       45 91		      eor	currentPiece
     18  710c		       10 03		      bpl	.invalid
     19  710e		       20 33 f2 	      jsr	AddMove
     20  7111
     21  7111				   .invalid
      0  7111					      MOVE_TOWARDS	_UP
      1  7111					      SUBROUTINE
      2  7111
      3  7111
      4  7111
      5  7111		       a9 00		      lda	#0
      6  7113		       85 9d		      sta	capture
      7  7115
      8  7115		       a6 92		      ldx	currentSquare
      9  7117		       d0 03		      bne	.project
     10  7119
     11  7119		       20 33 f2    .empty     jsr	AddMove
     12  711c		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  711f		       30 0e		      bmi	.invalid
     14  7121		       b9 79 fc 	      lda	Board,y
     15  7124		       f0 f3		      beq	.empty
     16  7126		       85 9d		      sta	capture
     17  7128		       45 91		      eor	currentPiece
     18  712a		       10 03		      bpl	.invalid
     19  712c		       20 33 f2 	      jsr	AddMove
     20  712f
     21  712f				   .invalid
      0  712f					      MOVE_TOWARDS	_UP+_LEFT
      1  712f					      SUBROUTINE
      2  712f
      3  712f
      4  712f
      5  712f		       a9 00		      lda	#0
      6  7131		       85 9d		      sta	capture
      7  7133
      8  7133		       a6 92		      ldx	currentSquare
      9  7135		       d0 03		      bne	.project
     10  7137
     11  7137		       20 33 f2    .empty     jsr	AddMove
     12  713a		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  713d		       30 0e		      bmi	.invalid
     14  713f		       b9 79 fc 	      lda	Board,y
     15  7142		       f0 f3		      beq	.empty
     16  7144		       85 9d		      sta	capture
     17  7146		       45 91		      eor	currentPiece
     18  7148		       10 03		      bpl	.invalid
     19  714a		       20 33 f2 	      jsr	AddMove
     20  714d
     21  714d				   .invalid
      0  714d					      MOVE_TOWARDS	_LEFT
      1  714d					      SUBROUTINE
      2  714d
      3  714d
      4  714d
      5  714d		       a9 00		      lda	#0
      6  714f		       85 9d		      sta	capture
      7  7151
      8  7151		       a6 92		      ldx	currentSquare
      9  7153		       d0 03		      bne	.project
     10  7155
     11  7155		       20 33 f2    .empty     jsr	AddMove
     12  7158		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  715b		       30 0e		      bmi	.invalid
     14  715d		       b9 79 fc 	      lda	Board,y
     15  7160		       f0 f3		      beq	.empty
     16  7162		       85 9d		      sta	capture
     17  7164		       45 91		      eor	currentPiece
     18  7166		       10 03		      bpl	.invalid
     19  7168		       20 33 f2 	      jsr	AddMove
     20  716b
     21  716b				   .invalid
     25  716b
     26  716b		       4c b3 f1 	      jmp	MoveReturn
     27  716e
     28  716e							; EOF
------- FILE PIECE_HANDLER@1#2.asm
------- FILE PIECE_KING.asm LEVEL 3 PASS 4
      0  716e					      include	"PIECE_KING.asm"
      1  716e							; Copyright (C)2020 Andrew Davie
      2  716e
      3  716e							;---------------------------------------------------------------------------------------------------
      4  716e							; KING
      5  716e							; This is the move handler for a KING
      6  716e							; "Check" is detected in the next ply of the search.
      7  716e
      8  716e
      9  716e							;---------------------------------------------------------------------------------------------------
     10  716e
     11  716e							; MACRO - Castling
     12  716e
     13  716e		       00 03	   KINGSIDE   =	3
     14  716e		       ff ff ff fc QUEENSIDE  =	-4
     15  716e
     16  716e					      MAC	castle
     17  716e							; {1} = "KINGSIDE" or "QUEENSIDE"
     18  716e
     19  716e					      ldx	currentSquare
     20  716e					      lda	Board+{1},x	; kingside/queenside R position
     21  716e					      and	#PIECE_MASK|FLAG_MOVED
     22  716e					      cmp	#ROOK
     23  716e					      bne	.noCastle	; not a R that hasn't moved
     24  716e
     25  716e							; It's a R and it *HAS* to be correct colour because it hasn't moved!
     26  716e							; AND the K hasn't moved (earlier check), so check for vacant squares between K and R
     27  716e
     28  716e					      IF	{1} = QUEENSIDE
     29  716e					      lda	Board-3,x	; N pos
     30  716e					      ora	Board-2,x	; B pos
     31  716e					      ora	Board-1,x	; Q pos
     32  716e					      bne	.noCastle	; not vacant?
     33  716e
     34  716e					      ENDIF
     35  716e
     36  716e					      IF	{1} = KINGSIDE
     37  716e					      lda	Board+2,x	; N pos
     38  716e					      ora	Board+1,x	; B pos
     39  716e					      bne	.noCastle	; not vacant?
     40  716e					      ENDIF
     41  716e
     42  716e							; appropriate N/B/(Q) squares are vacant so we proceed...
     43  716e
     44  716e							; FINALLY -- king can castle
     45  716e							; note: when we actually DO the move we MUST insert "Phantom" kings onto the board over the
     46  716e							; squares the king traverses so that "check" (and thus illegal moves) can be detected on the
     47  716e							; next move. Castling will be detected by K moving > 1 square. (TODO: FIX?? not CASTLE flag??)
     48  716e
     49  716e					      lda	currentPiece
     50  716e					      ora	#FLAG_CASTLE	; flag it's a castling move
     51  716e					      sta	currentPiece
     52  716e
     53  716e					      IF	{1} = KINGSIDE
     54  716e					      ldy	ValidSquare+2,x
     55  716e					      ENDIF
     56  716e
     57  716e					      IF	{1} = QUEENSIDE
     58  716e					      ldy	ValidSquare-2,x
     59  716e					      ENDIF
     60  716e
     61  716e					      jsr	AddMove	; 57
     62  716e
     63  716e				   .noCastle
     64  716e					      ENDM
     65  716e
     66  716e
     67  716e							;---------------------------------------------------------------------------------------------------
     68  716e
      0  716e					      DEF	Handle_KING
      1  716e				   SLOT_Handle_KING SET	_BANK_SLOT
      2  716e				   BANK_Handle_KING SET	SLOT_Handle_KING + _CURRENT_BANK
      3  716e				   Handle_KING
      4  716e				   TEMPORARY_VAR SET	Overlay
      5  716e				   TEMPORARY_OFFSET SET	0
      6  716e				   VAR_BOUNDARY_Handle_KING SET	TEMPORARY_OFFSET
      7  716e				   FUNCTION_NAME SET	Handle_KING
     70  716e					      SUBROUTINE
     71  716e
      0  716e					      REFER	GenerateAllMoves
      1  716e					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  716e				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  716e					      ENDIF
      0  716e					      VEND	Handle_KING
      1  716e				  -	      IFNCONST	Handle_KING
      2  716e				  -	      ECHO	"Incorrect VEND label", Handle_KING
      3  716e				  -	      ERR
      4  716e					      ENDIF
      5  716e		       00 b5	   VAREND_Handle_KING =	TEMPORARY_VAR
     74  716e
     75  716e							; x = currentSquare (square the KING is on)
     76  716e							; currentPiece (KING of course, but with flags/colour attached)
     77  716e
      0  716e					      MOVE_TO	_DOWN+_LEFT
      1  716e					      SUBROUTINE
      2  716e		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      3  7171		       30 0e		      bmi	.invalid
      4  7173		       b9 79 fc 	      lda	Board,y
      5  7176		       85 9d		      sta	capture
      6  7178		       f0 04		      beq	.squareEmpty
      7  717a		       45 91		      eor	currentPiece
      8  717c		       10 03		      bpl	.invalid
      9  717e		       20 33 f2    .squareEmpty jsr	AddMove
     10  7181				   .invalid
      0  7181					      MOVE_TO_X	_DOWN
      1  7181		       a6 92		      ldx	currentSquare
      0  7183					      MOVE_TO	_DOWN
      1  7183					      SUBROUTINE
      2  7183		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x
      3  7186		       30 0e		      bmi	.invalid
      4  7188		       b9 79 fc 	      lda	Board,y
      5  718b		       85 9d		      sta	capture
      6  718d		       f0 04		      beq	.squareEmpty
      7  718f		       45 91		      eor	currentPiece
      8  7191		       10 03		      bpl	.invalid
      9  7193		       20 33 f2    .squareEmpty jsr	AddMove
     10  7196				   .invalid
      0  7196					      MOVE_TO_X	_DOWN+_RIGHT
      1  7196		       a6 92		      ldx	currentSquare
      0  7198					      MOVE_TO	_DOWN+_RIGHT
      1  7198					      SUBROUTINE
      2  7198		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      3  719b		       30 0e		      bmi	.invalid
      4  719d		       b9 79 fc 	      lda	Board,y
      5  71a0		       85 9d		      sta	capture
      6  71a2		       f0 04		      beq	.squareEmpty
      7  71a4		       45 91		      eor	currentPiece
      8  71a6		       10 03		      bpl	.invalid
      9  71a8		       20 33 f2    .squareEmpty jsr	AddMove
     10  71ab				   .invalid
      0  71ab					      MOVE_TO_X	_RIGHT
      1  71ab		       a6 92		      ldx	currentSquare
      0  71ad					      MOVE_TO	_RIGHT
      1  71ad					      SUBROUTINE
      2  71ad		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      3  71b0		       30 0e		      bmi	.invalid
      4  71b2		       b9 79 fc 	      lda	Board,y
      5  71b5		       85 9d		      sta	capture
      6  71b7		       f0 04		      beq	.squareEmpty
      7  71b9		       45 91		      eor	currentPiece
      8  71bb		       10 03		      bpl	.invalid
      9  71bd		       20 33 f2    .squareEmpty jsr	AddMove
     10  71c0				   .invalid
      0  71c0					      MOVE_TO_X	_UP+_RIGHT
      1  71c0		       a6 92		      ldx	currentSquare
      0  71c2					      MOVE_TO	_UP+_RIGHT
      1  71c2					      SUBROUTINE
      2  71c2		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      3  71c5		       30 0e		      bmi	.invalid
      4  71c7		       b9 79 fc 	      lda	Board,y
      5  71ca		       85 9d		      sta	capture
      6  71cc		       f0 04		      beq	.squareEmpty
      7  71ce		       45 91		      eor	currentPiece
      8  71d0		       10 03		      bpl	.invalid
      9  71d2		       20 33 f2    .squareEmpty jsr	AddMove
     10  71d5				   .invalid
      0  71d5					      MOVE_TO_X	_UP
      1  71d5		       a6 92		      ldx	currentSquare
      0  71d7					      MOVE_TO	_UP
      1  71d7					      SUBROUTINE
      2  71d7		       bc 1f fc 	      ldy	ValidSquare+_UP,x
      3  71da		       30 0e		      bmi	.invalid
      4  71dc		       b9 79 fc 	      lda	Board,y
      5  71df		       85 9d		      sta	capture
      6  71e1		       f0 04		      beq	.squareEmpty
      7  71e3		       45 91		      eor	currentPiece
      8  71e5		       10 03		      bpl	.invalid
      9  71e7		       20 33 f2    .squareEmpty jsr	AddMove
     10  71ea				   .invalid
      0  71ea					      MOVE_TO_X	_UP+_LEFT
      1  71ea		       a6 92		      ldx	currentSquare
      0  71ec					      MOVE_TO	_UP+_LEFT
      1  71ec					      SUBROUTINE
      2  71ec		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      3  71ef		       30 0e		      bmi	.invalid
      4  71f1		       b9 79 fc 	      lda	Board,y
      5  71f4		       85 9d		      sta	capture
      6  71f6		       f0 04		      beq	.squareEmpty
      7  71f8		       45 91		      eor	currentPiece
      8  71fa		       10 03		      bpl	.invalid
      9  71fc		       20 33 f2    .squareEmpty jsr	AddMove
     10  71ff				   .invalid
      0  71ff					      MOVE_TO_X	_LEFT
      1  71ff		       a6 92		      ldx	currentSquare
      0  7201					      MOVE_TO	_LEFT
      1  7201					      SUBROUTINE
      2  7201		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      3  7204		       30 0e		      bmi	.invalid
      4  7206		       b9 79 fc 	      lda	Board,y
      5  7209		       85 9d		      sta	capture
      6  720b		       f0 04		      beq	.squareEmpty
      7  720d		       45 91		      eor	currentPiece
      8  720f		       10 03		      bpl	.invalid
      9  7211		       20 33 f2    .squareEmpty jsr	AddMove
     10  7214				   .invalid
     86  7214
     87  7214							;IF CASTLING_ENABLED
     88  7214
     89  7214		       24 91		      bit	currentPiece
     90  7216		       70 41		      bvs	.exit	; king has moved, so no castling
     91  7218
      0  7218					      CASTLE	KINGSIDE
      1  7218
      2  7218
      3  7218		       a6 92		      ldx	currentSquare
      4  721a		       bd 7c fc 	      lda	Board+KINGSIDE,x
      5  721d		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  721f		       c9 05		      cmp	#ROOK
      7  7221		       d0 14		      bne	.noCastle
      8  7223
      9  7223
     10  7223
     11  7223
     12  7223				  -	      IF	KINGSIDE = QUEENSIDE
     13  7223				  -	      lda	Board-3,x
     14  7223				  -	      ora	Board-2,x
     15  7223				  -	      ora	Board-1,x
     16  7223				  -	      bne	.noCastle
     17  7223				  -
     18  7223					      ENDIF
     19  7223
     20  7223					      IF	KINGSIDE = KINGSIDE
     21  7223		       bd 7b fc 	      lda	Board+2,x
     22  7226		       1d 7a fc 	      ora	Board+1,x
     23  7229		       d0 0c		      bne	.noCastle
     24  722b					      ENDIF
     25  722b
     26  722b
     27  722b
     28  722b
     29  722b
     30  722b
     31  722b
     32  722b
     33  722b		       a5 91		      lda	currentPiece
     34  722d		       09 10		      ora	#FLAG_CASTLE
     35  722f		       85 91		      sta	currentPiece
     36  7231
     37  7231					      IF	KINGSIDE = KINGSIDE
     38  7231		       bc 17 fc 	      ldy	ValidSquare+2,x
     39  7234					      ENDIF
     40  7234
     41  7234				  -	      IF	KINGSIDE = QUEENSIDE
     42  7234				  -	      ldy	ValidSquare-2,x
     43  7234					      ENDIF
     44  7234
     45  7234		       20 33 f2 	      jsr	AddMove
     46  7237
     47  7237				   .noCastle
      0  7237					      CASTLE	QUEENSIDE
      1  7237
      2  7237
      3  7237		       a6 92		      ldx	currentSquare
      4  7239		       bd 75 fc 	      lda	Board+QUEENSIDE,x
      5  723c		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  723e		       c9 05		      cmp	#ROOK
      7  7240		       d0 17		      bne	.noCastle
      8  7242
      9  7242
     10  7242
     11  7242
     12  7242					      IF	QUEENSIDE = QUEENSIDE
     13  7242		       bd 76 fc 	      lda	Board-3,x
     14  7245		       1d 77 fc 	      ora	Board-2,x
     15  7248		       1d 78 fc 	      ora	Board-1,x
     16  724b		       d0 0c		      bne	.noCastle
     17  724d
     18  724d					      ENDIF
     19  724d
     20  724d				  -	      IF	QUEENSIDE = KINGSIDE
     21  724d				  -	      lda	Board+2,x
     22  724d				  -	      ora	Board+1,x
     23  724d				  -	      bne	.noCastle
     24  724d					      ENDIF
     25  724d
     26  724d
     27  724d
     28  724d
     29  724d
     30  724d
     31  724d
     32  724d
     33  724d		       a5 91		      lda	currentPiece
     34  724f		       09 10		      ora	#FLAG_CASTLE
     35  7251		       85 91		      sta	currentPiece
     36  7253
     37  7253				  -	      IF	QUEENSIDE = KINGSIDE
     38  7253				  -	      ldy	ValidSquare+2,x
     39  7253					      ENDIF
     40  7253
     41  7253					      IF	QUEENSIDE = QUEENSIDE
     42  7253		       bc 13 fc 	      ldy	ValidSquare-2,x
     43  7256					      ENDIF
     44  7256
     45  7256		       20 33 f2 	      jsr	AddMove
     46  7259
     47  7259				   .noCastle
     94  7259
     95  7259							;ENDIF
     96  7259
     97  7259		       4c b3 f1    .exit      jmp	MoveReturn
     98  725c
     99  725c							;---------------------------------------------------------------------------------------------------
    100  725c							; EOF
------- FILE PIECE_HANDLER@1#2.asm
      7  725c
      8  725c							;---------------------------------------------------------------------------------------------------
      9  725c
      0  725c					      CHECK_BANK_SIZE	"PIECE_HANDLER_2"
      1  725c		       02 5c	   .TEMP      =	* - _BANK_START
 PIECE_HANDLER_2 (1K) SIZE =  $25c , FREE= $1a4
      2  725c					      ECHO	"PIECE_HANDLER_2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  725c				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  725c				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_HANDLER_2", " size=", * - ORIGIN
      5  725c				  -	      ERR
      6  725c					      ENDIF
     11  725c
     12  725c							;---------------------------------------------------------------------------------------------------
     13  725c							; EOF
------- FILE ./chess.asm
------- FILE BANK_3.asm LEVEL 2 PASS 4
      0  725c					      include	"BANK_3.asm"
      1  725c							; Chess
      2  725c							; Copyright (c) 2019-2020 Andrew Davie
      3  725c							; andrew@taswegian.com
      4  725c
      0  725c					      SLOT	3	; this code assembles for bank #1
      1  725c				  -	      IF	(3 < 0) || (3 > 3)
      2  725c				  -	      ECHO	"Illegal bank address/segment location", 3
      3  725c				  -	      ERR
      4  725c					      ENDIF
      5  725c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  725c				   _BANK_SLOT SET	3 * 64
      0  725c					      NEWBANK	THREE
      1  742b ????				      SEG	THREE
      2  7400					      ORG	_ORIGIN
      3  7400					      RORG	_BANK_ADDRESS_ORIGIN
      4  7400				   _BANK_START SET	*
      5  7400				   THREE_START SET	*
      6  7400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7400				   THREE      SET	_BANK_SLOT + _CURRENT_BANK
      8  7400				   _ORIGIN    SET	_ORIGIN + 1024
      7  7400
      8  7400							;---------------------------------------------------------------------------------------------------
      9  7400
      0  7400					      DEF	GetPiece
      1  7400				   SLOT_GetPiece SET	_BANK_SLOT
      2  7400				   BANK_GetPiece SET	SLOT_GetPiece + _CURRENT_BANK
      3  7400				   GetPiece
      4  7400				   TEMPORARY_VAR SET	Overlay
      5  7400				   TEMPORARY_OFFSET SET	0
      6  7400				   VAR_BOUNDARY_GetPiece SET	TEMPORARY_OFFSET
      7  7400				   FUNCTION_NAME SET	GetPiece
     11  7400					      SUBROUTINE
     12  7400
      0  7400					      REFER	aiSelectDestinationSquare
      1  7400				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  7400				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  7400					      ENDIF
      0  7400					      REFER	aiQuiescent
      1  7400				  -	      IF	VAREND_aiQuiescent > TEMPORARY_VAR
      2  7400				  -TEMPORARY_VAR SET	VAREND_aiQuiescent
      3  7400					      ENDIF
      0  7400					      VEND	GetPiece
      1  7400				  -	      IFNCONST	GetPiece
      2  7400				  -	      ECHO	"Incorrect VEND label", GetPiece
      3  7400				  -	      ERR
      4  7400					      ENDIF
      5  7400		       00 a4	   VAREND_GetPiece =	TEMPORARY_VAR
     16  7400
     17  7400							; Retrieve the piece+flags from the movelist, given from/to squares
     18  7400							; Required as moves have different flags but same origin squares (e.g., castling)
     19  7400
     20  7400		       a9 89		      lda	#RAMBANK_PLY+1	;currentPly
     21  7402							;lda currentPly
     22  7402		       85 3e		      sta	SET_BANK_RAM	;@2
     23  7404
     24  7404							; returns piece in A+fromPiece
     25  7404							; or Y=-1 if not found
     26  7404
     27  7404							; We need to get the piece from the movelist because it contains flags (e.g., castling) about
     28  7404							; the move. We need to do from/to checks because moves can have multiple origin/desinations.
     29  7404							; This fixes the move with/without castle flag
     30  7404
     31  7404
      0  7404					      ldy@PLY	moveIndex
      1  7404		       ac d0 f9 	      ldy	moveIndex
     33  7407		       30 11		      bmi	.fail	; shouldn't happen
     34  7409
     35  7409		       a5 85	   .scan      lda	fromX12
      0  740b					      cmp@PLY	MoveFrom,y
      1  740b		       d9 00 f8 	      cmp	MoveFrom,y
     37  740e		       d0 07		      bne	.next
     38  7410		       a5 86		      lda	toX12
      0  7412					      cmp@PLY	MoveTo,y
      1  7412		       d9 64 f8 	      cmp	MoveTo,y
     40  7415		       f0 04		      beq	.found
     41  7417		       88	   .next      dey
     42  7418		       10 ef		      bpl	.scan
     43  741a		       60	   .fail      rts
     44  741b
      0  741b				   .found     lda@PLY	MovePiece,y
      1  741b		       b9 00 f9 	      lda	MovePiece,y
     46  741e		       85 96		      sta	fromPiece
     47  7420
     48  7420		       60		      rts
     49  7421
     50  7421
     51  7421							;---------------------------------------------------------------------------------------------------
     52  7421
     53  7421
     54  7421
     55  7421							;---------------------------------------------------------------------------------------------------
     56  7421
      0  7421					      DEF	showPromoteOptions
      1  7421				   SLOT_showPromoteOptions SET	_BANK_SLOT
      2  7421				   BANK_showPromoteOptions SET	SLOT_showPromoteOptions + _CURRENT_BANK
      3  7421				   showPromoteOptions
      4  7421				   TEMPORARY_VAR SET	Overlay
      5  7421				   TEMPORARY_OFFSET SET	0
      6  7421				   VAR_BOUNDARY_showPromoteOptions SET	TEMPORARY_OFFSET
      7  7421				   FUNCTION_NAME SET	showPromoteOptions
     58  7421					      SUBROUTINE
     59  7421
      0  7421					      REFER	aiRollPromotionPiece
      1  7421				  -	      IF	VAREND_aiRollPromotionPiece > TEMPORARY_VAR
      2  7421				  -TEMPORARY_VAR SET	VAREND_aiRollPromotionPiece
      3  7421					      ENDIF
      0  7421					      REFER	aiChoosePromotePiece
      1  7421				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  7421				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  7421					      ENDIF
      0  7421					      VEND	showPromoteOptions
      1  7421				  -	      IFNCONST	showPromoteOptions
      2  7421				  -	      ECHO	"Incorrect VEND label", showPromoteOptions
      3  7421				  -	      ERR
      4  7421					      ENDIF
      5  7421		       00 a4	   VAREND_showPromoteOptions =	TEMPORARY_VAR
     63  7421
     64  7421							; X = character shape # (?/N/B/R/Q)
     65  7421
     66  7421		       a4 86		      ldy	toX12
     67  7423		       84 80		      sty	squareToDraw
     68  7425
     69  7425		       20 91 f5 	      jsr	CopySetupForMarker	;@1	   ; TODO: WRONG
     70  7428		       4c b4 f0 	      jmp	InterceptMarkerCopy	;@0
     71  742b
     72  742b
     73  742b							;---------------------------------------------------------------------------------------------------
     74  742b
      0  742b					      CHECK_BANK_SIZE	"BANK_3"
      1  742b		       00 2b	   .TEMP      =	* - _BANK_START
 BANK_3 (1K) SIZE =  $2b , FREE= $3d5
      2  742b					      ECHO	"BANK_3", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  742b				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  742b				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_3", " size=", * - ORIGIN
      5  742b				  -	      ERR
      6  742b					      ENDIF
     76  742b
     77  742b							;---------------------------------------------------------------------------------------------------
     78  742b							; EOF
------- FILE ./chess.asm
    641  742b
------- FILE BANK_LAST.asm LEVEL 2 PASS 4
      0  742b					      include	"BANK_LAST.asm"
      1  742b							; Chess
      2  742b							; Copyright (c) 2019-2020 Andrew Davie
      3  742b							; andrew@taswegian.com
      4  742b
      0  742b					      SLOT	3
      1  742b				  -	      IF	(3 < 0) || (3 > 3)
      2  742b				  -	      ECHO	"Illegal bank address/segment location", 3
      3  742b				  -	      ERR
      4  742b					      ENDIF
      5  742b				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  742b				   _BANK_SLOT SET	3 * 64
      0  742b					      NEWBANK	LAST
      1  7c00 ????				      SEG	LAST
      2  7800					      ORG	_ORIGIN
      3  7800					      RORG	_BANK_ADDRESS_ORIGIN
      4  7800				   _BANK_START SET	*
      5  7800				   LAST_START SET	*
      6  7800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7800				   LAST       SET	_BANK_SLOT + _CURRENT_BANK
      8  7800				   _ORIGIN    SET	_ORIGIN + 1024
      7  7800
      8  7800
      9  7800		       00 00 00 00*	      ds	1024
     10  7c00
     11  7c00							; EOF
------- FILE ./chess.asm
    643  7c00
    644  7c00							;---------------------------------------------------------------------------------------------------
    645  7c00							;EOF
